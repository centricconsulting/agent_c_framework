"""
HeyGen Streaming Avatar API Client - Refactored

This module provides a properly structured client that separates:
1. Token generation (using API key)
2. Streaming operations (using access tokens)

This aligns with how the JavaScript SDK works and follows HeyGen's intended architecture.
"""
import os
import httpx
import json

from typing import Optional, Dict, Any


from agent_c.models.heygen import (
    # Request models
    NewSessionRequest,
    SendTaskRequest,
    SessionIdRequest,

    # Response models
    ListAvatarsResponse,
    NewSessionResponse,
    ListActiveSessionsResponse,
    ListHistoricalSessionsResponse,
    SendTaskResponse,
    CreateSessionTokenResponse,
    HeyGenBaseResponse,
    SimpleStatusResponse, HeygenAvatarSessionData,
)
from agent_c.util.logging_utils import LoggingManager

class HeyGenStreamingClient:
    """
    HTTP client for HeyGen Streaming Avatar operations using access tokens.

    This client handles all streaming operations (create session, send tasks, etc.)
    using access tokens generated by HeyGenClient.

    This mirrors how the JavaScript SDK works internally.
    """

    BASE_URL = "https://api.heygen.com"

    def __init__(self, access_token: str, timeout: float = 30.0):
        """
        Initialize the streaming client with an access token.

        Args:
            access_token: Access token from HeyGenClient.create_access_token()
            timeout: Request timeout in seconds
        """
        self.logger = LoggingManager(__name__).get_logger()
        self.heygen_session: Optional[HeygenAvatarSessionData] = None
        self.access_token = access_token
        self.timeout = timeout
        self._client = httpx.AsyncClient(
            base_url=self.BASE_URL,
            timeout=timeout,
            headers={
                "Authorization": f"Bearer {access_token}",
                "Content-Type": "application/json"
            }
        )

        # Track session state
        self.session_id: Optional[str] = None

    async def __aenter__(self):
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()

    async def close(self):
        """Close the HTTP client."""
        await self._client.aclose()

    async def create_new_session(self, request: NewSessionRequest) -> Optional[HeygenAvatarSessionData]:
        """
        Create a new streaming avatar session.

        Args:
            request: Session creation parameters

        Returns:
            HeygenAvatarSessionData containing session details

        Raises:
            httpx.HTTPError: If the request fails
        """
        response = await self._client.post("/v1/streaming.new", json=request.model_dump(exclude_none=True))
        response.raise_for_status()

        session_response = NewSessionResponse.model_validate(response.json())
        self.heygen_session = session_response.data

        return self.heygen_session

    async def start_session(self, session_id: Optional[str] = None) -> SimpleStatusResponse:
        """
        Start an existing streaming session.

        Args:
            session_id: The session to start (uses stored session_id if not provided)

        Returns:
            SimpleStatusResponse containing status

        Raises:
            httpx.HTTPError: If the request fails
            ValueError: If no session_id is available
        """
        session_id = session_id or self.heygen_session.session_id
        if not session_id:
            raise ValueError("No session_id available. Create a session first or provide session_id.")

        request = SessionIdRequest(session_id=session_id)
        response = await self._client.post("/v1/streaming.start", json=request.model_dump())
        response.raise_for_status()
        return SimpleStatusResponse.model_validate(response.json())

    async def send_task(self, text: str, session_id: Optional[str] = None,
                        task_mode: str = "async", task_type: str = "repeat") -> SendTaskResponse:
        """
        Send a task to an active session.

        Args:
            text: The text input for the task
            session_id: The session ID to send the task to (uses stored session_id if not provided)
            task_mode: The mode of the task, either "sync" or "async" (default: "async")
            task_type: The type of task, e.g., "repeat"

        Returns:
            SendTaskResponse containing task response with duration and task_id

        Raises:
            httpx.HTTPError: If the request fails
            ValueError: If no session_id is available
        """
        session_id = session_id or self.heygen_session.session_id
        if not session_id:
            raise ValueError("No session_id available. Create a session first or provide session_id.")

        request = SendTaskRequest(session_id=session_id, text=text, task_mode=task_mode, task_type=task_type)
        response = await self._client.post("/v1/streaming.task", json=request.model_dump(exclude_none=True))
        response.raise_for_status()
        return SendTaskResponse.model_validate(response.json())

    async def interrupt_task(self, session_id: Optional[str] = None) -> HeyGenBaseResponse:
        """
        Interrupt a running task in a session.

        Args:
            session_id: The session ID to interrupt (uses stored session_id if not provided)

        Returns:
            HeyGenBaseResponse containing interruption response

        Raises:
            httpx.HTTPError: If the request fails
            ValueError: If no session_id is available
        """
        session_id = session_id or self.heygen_session.session_id
        if not session_id:
            raise ValueError("No session_id available. Create a session first or provide session_id.")

        request = SessionIdRequest(session_id=session_id)
        response = await self._client.post("/v1/streaming.interrupt", json=request.model_dump())
        response.raise_for_status()
        return HeyGenBaseResponse.model_validate(response.json())

    async def close_session(self, session_id: Optional[str] = None) -> SimpleStatusResponse:
        """
        Close an active session.

        Args:
            session_id: The session ID to close (uses stored session_id if not provided)

        Returns:
            SimpleStatusResponse containing closure response

        Raises:
            httpx.HTTPError: If the request fails
            ValueError: If no session_id is available
        """
        session_id = session_id or self.heygen_session.session_id
        if not session_id:
            raise ValueError("No session_id available. Create a session first or provide session_id.")

        request = SessionIdRequest(session_id=session_id)
        response = await self._client.post("/v1/streaming.stop", json=request.model_dump())
        response.raise_for_status()

        if session_id == self.heygen_session.session_id:
            self.heygen_session = None

        return SimpleStatusResponse.model_validate(response.json())

    async def keep_alive(self, session_id: Optional[str] = None) -> HeyGenBaseResponse:
        """
        Reset the idle timeout countdown for an active session.

        Args:
            session_id: The session ID to keep alive (uses stored session_id if not provided)

        Returns:
            HeyGenBaseResponse containing keep alive response

        Raises:
            httpx.HTTPError: If the request fails
            ValueError: If no session_id is available
        """
        session_id = session_id or self.heygen_session.session_id
        if not session_id:
            raise ValueError("No session_id available. Create a session first or provide session_id.")

        request = SessionIdRequest(session_id=session_id)
        response = await self._client.post("/v1/streaming.keep_alive", json=request.model_dump())
        response.raise_for_status()
        return HeyGenBaseResponse.model_validate(response.json())

class HeyGenClient:
    """
    Handles HeyGen API key operations - specifically generating access tokens.

    This class should be used sparingly and only for token generation.
    The actual streaming operations should use HeyGenStreamingClient with access tokens.
    """

    BASE_URL = "https://api.heygen.com"

    def __init__(self, api_key: Optional[str] = None, timeout: float = 30.0):
        """
        Initialize the token generator.

        Args:
            api_key: HeyGen API key for authentication
            timeout: Request timeout in seconds
        """
        self.logger = LoggingManager(__name__).get_logger()
        self.api_key = api_key if api_key else os.environ.get("HEYGEN_API_KEY")
        if not self.api_key:
            raise ValueError("HeyGen API key is required")

        self.timeout = timeout
        self._client = httpx.AsyncClient(
            base_url=self.BASE_URL,
            timeout=timeout,
            headers={
                "x-api-key": self.api_key,
                "Content-Type": "application/json"
            }
        )

    async def __aenter__(self):
        """Async context manager entry."""
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()

    async def close(self):
        """Close the HTTP client."""
        await self._client.aclose()

    async def create_streaming_access_token(self) -> str:
        """
        Create a one-time access token for streaming operations.

        This token should be used to initialize a HeyGenStreamingClient.
        Note: Tokens are one-time use and tied to a single streaming session.

        Returns:
            Access token string

        Raises:
            httpx.HTTPError: If the request fails
            ValueError: If token creation fails
        """
        response = await self._client.post("/v1/streaming.create_token", json={})
        response.raise_for_status()

        resp_model = CreateSessionTokenResponse.model_validate(response.json())
        if resp_model.error:
            raise ValueError(f"Error creating access token: {resp_model.error}")

        return resp_model.data.token

    async def create_streaming_client(self) -> HeyGenStreamingClient:
        """
        Convenience method to create a HeyGenStreamingClient with a fresh access token.

        Returns:
            HeyGenStreamingClient initialized with a fresh access token

        Raises:
            httpx.HTTPError: If token generation fails
            ValueError: If API key is missing
        """
        access_token = await self.create_streaming_access_token()
        return HeyGenStreamingClient(access_token)

    @staticmethod
    def _locate_config_path() -> str:
        """
        Locate configuration path by walking up directory tree.

        Returns:
            Path to agent_c_config directory

        Raises:
            FileNotFoundError: If configuration folder cannot be found
        """
        current_dir = os.getcwd()
        while True:
            config_dir = os.path.join(current_dir, "agent_c_config")
            if os.path.exists(config_dir):
                return config_dir

            parent_dir = os.path.dirname(current_dir)
            if current_dir == parent_dir:  # Reached root directory
                break
            current_dir = parent_dir

        raise FileNotFoundError(
            "Configuration folder not found. Please ensure you are in the correct directory or set AGENT_C_CONFIG_PATH."
        )

    async def fetch_avatars(self) -> ListAvatarsResponse:
        """
        Fetch avatars from HeyGen API and cache the results.

        This method makes the actual API call to HeyGen, deduplicates the results,
        and saves them to a JSON cache file in the config directory.

        Returns:
            ListAvatarsResponse containing unique avatars

        Raises:
            httpx.HTTPError: If the request fails
            FileNotFoundError: If config directory cannot be found
        """
        response = await self._client.get("/v1/streaming/avatar.list")
        response.raise_for_status()

        raw_response = response.json()

        # Deduplicate avatars by avatar_id, keeping the most recent (highest created_at)
        avatars_by_id = {}
        for avatar_data in raw_response["data"]:
            avatar_id = avatar_data["avatar_id"]
            if avatar_id not in avatars_by_id or avatar_data["created_at"] > avatars_by_id[avatar_id]["created_at"]:
                avatars_by_id[avatar_id] = avatar_data

        # Reconstruct response with deduplicated avatars
        deduplicated_response = {
            "code": raw_response["code"],
            "message": raw_response["message"],
            "data": list(avatars_by_id.values())
        }

        # Cache the results
        try:
            config_path = self._locate_config_path()
            cache_file = os.path.join(config_path, "avatars_cache.json")
            with open(cache_file, 'w') as f:
                json.dump(deduplicated_response, f, indent=2)
        except Exception as e:
            # Log the error but don't fail the request
            self.logger.exception("Failed to cache avatars", exc_info=e)

        return ListAvatarsResponse.model_validate(deduplicated_response)

    async def list_avatars(self) -> ListAvatarsResponse:
        """
        List available streaming avatars.

        This method first checks for cached avatar data in the config directory.
        If cached data exists, it loads and returns that. Otherwise, it calls
        fetch_avatars() to get fresh data from the API.

        Note: HeyGen's API returns duplicate avatars (different revisions with same avatar_id).
        The fetch method deduplicates by avatar_id, keeping the most recent version.

        Returns:
            ListAvatarsResponse containing unique avatars

        Raises:
            httpx.HTTPError: If the request fails and no cache is available
        """
        config_path = self._locate_config_path()
        cache_file = os.path.join(config_path, "avatars_cache.json")

        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r') as f:
                    cached_data = json.load(f)
                return ListAvatarsResponse.model_validate(cached_data)
            except Exception:
                self.logger.exception("Failed to load cached avatars", exc_info=True)

        # No cache available or cache loading failed, fetch from API
        return await self.fetch_avatars()



# Convenience factory function
async def create_heygen_streaming_client(api_key: Optional[str] = None) -> HeyGenStreamingClient:
    """
    Convenience function to create a streaming client with a fresh access token.

    Args:
        api_key: HeyGen API key (uses environment variable if not provided)

    Returns:
        HeyGenStreamingClient initialized with a fresh access token

    Raises:
        httpx.HTTPError: If token generation fails
        ValueError: If API key is missing
    """
    async with HeyGenClient(api_key) as token_gen:
        access_token = await token_gen.create_streaming_access_token()

    return HeyGenStreamingClient(access_token)

