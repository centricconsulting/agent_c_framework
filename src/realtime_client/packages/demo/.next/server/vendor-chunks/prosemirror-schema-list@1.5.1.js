"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-schema-list@1.5.1";
exports.ids = ["vendor-chunks/prosemirror-schema-list@1.5.1"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/prosemirror-schema-list@1.5.1/node_modules/prosemirror-schema-list/dist/index.cjs":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/prosemirror-schema-list@1.5.1/node_modules/prosemirror-schema-list/dist/index.cjs ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"(rsc)/../../node_modules/.pnpm/prosemirror-transform@1.10.4/node_modules/prosemirror-transform/dist/index.cjs\");\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"(rsc)/../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs\");\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"(rsc)/../../node_modules/.pnpm/prosemirror-state@1.4.3/node_modules/prosemirror-state/dist/index.cjs\");\nvar olDOM = [\"ol\", 0],\n  ulDOM = [\"ul\", 0],\n  liDOM = [\"li\", 0];\nvar orderedList = {\n  attrs: {\n    order: {\n      \"default\": 1,\n      validate: \"number\"\n    }\n  },\n  parseDOM: [{\n    tag: \"ol\",\n    getAttrs: function getAttrs(dom) {\n      return {\n        order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1\n      };\n    }\n  }],\n  toDOM: function toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {\n      start: node.attrs.order\n    }, 0];\n  }\n};\nvar bulletList = {\n  parseDOM: [{\n    tag: \"ul\"\n  }],\n  toDOM: function toDOM() {\n    return ulDOM;\n  }\n};\nvar listItem = {\n  parseDOM: [{\n    tag: \"li\"\n  }],\n  toDOM: function toDOM() {\n    return liDOM;\n  },\n  defining: true\n};\nfunction add(obj, props) {\n  var copy = {};\n  for (var prop in obj) copy[prop] = obj[prop];\n  for (var _prop in props) copy[_prop] = props[_prop];\n  return copy;\n}\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    bullet_list: add(bulletList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    list_item: add(listItem, {\n      content: itemContent\n    })\n  });\n}\nfunction wrapInList(listType) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    var _state$selection = state.selection,\n      $from = _state$selection.$from,\n      $to = _state$selection.$to;\n    var range = $from.blockRange($to);\n    if (!range) return false;\n    var tr = dispatch ? state.tr : null;\n    if (!wrapRangeInList(tr, range, listType, attrs)) return false;\n    if (dispatch) dispatch(tr.scrollIntoView());\n    return true;\n  };\n}\nfunction wrapRangeInList(tr, range, listType) {\n  var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var doJoin = false,\n    outerRange = range,\n    doc = range.$from.doc;\n  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n    if (range.$from.index(range.depth - 1) == 0) return false;\n    var $insert = doc.resolve(range.start - 2);\n    outerRange = new prosemirrorModel.NodeRange($insert, $insert, range.depth);\n    if (range.endIndex < range.parent.childCount) range = new prosemirrorModel.NodeRange(range.$from, doc.resolve(range.$to.end(range.depth)), range.depth);\n    doJoin = true;\n  }\n  var wrap = prosemirrorTransform.findWrapping(outerRange, listType, attrs, range);\n  if (!wrap) return false;\n  if (tr) doWrapInList(tr, range, wrap, doJoin, listType);\n  return true;\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  var content = prosemirrorModel.Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--) content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  tr.step(new prosemirrorTransform.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));\n  var found = 0;\n  for (var _i = 0; _i < wrappers.length; _i++) if (wrappers[_i].type == listType) found = _i + 1;\n  var splitDepth = wrappers.length - found;\n  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),\n    parent = range.parent;\n  for (var _i2 = range.startIndex, e = range.endIndex, first = true; _i2 < e; _i2++, first = false) {\n    if (!first && prosemirrorTransform.canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n    splitPos += parent.child(_i2).nodeSize;\n  }\n  return tr;\n}\nfunction splitListItem(itemType, itemAttrs) {\n  return function (state, dispatch) {\n    var _state$selection2 = state.selection,\n      $from = _state$selection2.$from,\n      $to = _state$selection2.$to,\n      node = _state$selection2.node;\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n    var grandParent = $from.node(-1);\n    if (grandParent.type != itemType) return false;\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n      if (dispatch) {\n        var wrap = prosemirrorModel.Fragment.empty;\n        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--) wrap = prosemirrorModel.Fragment.from($from.node(d).copy(wrap));\n        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n        wrap = wrap.append(prosemirrorModel.Fragment.from(itemType.createAndFill()));\n        var start = $from.before($from.depth - (depthBefore - 1));\n        var _tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirrorModel.Slice(wrap, 4 - depthBefore, 0));\n        var sel = -1;\n        _tr.doc.nodesBetween(start, _tr.doc.content.size, function (node, pos) {\n          if (sel > -1) return false;\n          if (node.isTextblock && node.content.size == 0) sel = pos + 1;\n        });\n        if (sel > -1) _tr.setSelection(prosemirrorState.Selection.near(_tr.doc.resolve(sel)));\n        dispatch(_tr.scrollIntoView());\n      }\n      return true;\n    }\n    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    var tr = state.tr[\"delete\"]($from.pos, $to.pos);\n    var types = nextType ? [itemAttrs ? {\n      type: itemType,\n      attrs: itemAttrs\n    } : null, {\n      type: nextType\n    }] : undefined;\n    if (!prosemirrorTransform.canSplit(tr.doc, $from.pos, 2, types)) return false;\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    return true;\n  };\n}\nfunction splitListItemKeepMarks(itemType, itemAttrs) {\n  var split = splitListItem(itemType, itemAttrs);\n  return function (state, dispatch) {\n    return split(state, dispatch && function (tr) {\n      var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n      if (marks) tr.ensureMarks(marks);\n      dispatch(tr);\n    });\n  };\n}\nfunction liftListItem(itemType) {\n  return function (state, dispatch) {\n    var _state$selection3 = state.selection,\n      $from = _state$selection3.$from,\n      $to = _state$selection3.$to;\n    var range = $from.blockRange($to, function (node) {\n      return node.childCount > 0 && node.firstChild.type == itemType;\n    });\n    if (!range) return false;\n    if (!dispatch) return true;\n    if ($from.node(range.depth - 1).type == itemType) return liftToOuterList(state, dispatch, itemType, range);else return liftOutOfList(state, dispatch, range);\n  };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  var tr = state.tr,\n    end = range.end,\n    endOfList = range.$to.end(range.depth);\n  if (end < endOfList) {\n    tr.step(new prosemirrorTransform.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new prosemirrorModel.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n  var target = prosemirrorTransform.liftTarget(range);\n  if (target == null) return false;\n  tr.lift(range, target);\n  var $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);\n  if (prosemirrorTransform.canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type) tr.join($after.pos);\n  dispatch(tr.scrollIntoView());\n  return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n  var tr = state.tr,\n    list = range.parent;\n  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr[\"delete\"](pos - 1, pos + 1);\n  }\n  var $start = tr.doc.resolve(range.start),\n    item = $start.nodeAfter;\n  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;\n  var atStart = range.startIndex == 0,\n    atEnd = range.endIndex == list.childCount;\n  var parent = $start.node(-1),\n    indexBefore = $start.index(-1);\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list)))) return false;\n  var start = $start.pos,\n    end = start + item.nodeSize;\n  tr.step(new prosemirrorTransform.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirrorModel.Slice((atStart ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))).append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true;\n}\nfunction sinkListItem(itemType) {\n  return function (state, dispatch) {\n    var _state$selection4 = state.selection,\n      $from = _state$selection4.$from,\n      $to = _state$selection4.$to;\n    var range = $from.blockRange($to, function (node) {\n      return node.childCount > 0 && node.firstChild.type == itemType;\n    });\n    if (!range) return false;\n    var startIndex = range.startIndex;\n    if (startIndex == 0) return false;\n    var parent = range.parent,\n      nodeBefore = parent.child(startIndex - 1);\n    if (nodeBefore.type != itemType) return false;\n    if (dispatch) {\n      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      var inner = prosemirrorModel.Fragment.from(nestedBefore ? itemType.create() : null);\n      var slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, prosemirrorModel.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n      var before = range.start,\n        after = range.end;\n      dispatch(state.tr.step(new prosemirrorTransform.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());\n    }\n    return true;\n  };\n}\nexports.addListNodes = addListNodes;\nexports.bulletList = bulletList;\nexports.liftListItem = liftListItem;\nexports.listItem = listItem;\nexports.orderedList = orderedList;\nexports.sinkListItem = sinkListItem;\nexports.splitListItem = splitListItem;\nexports.splitListItemKeepMarks = splitListItemKeepMarks;\nexports.wrapInList = wrapInList;\nexports.wrapRangeInList = wrapRangeInList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0QDEuNS4xL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyw0SUFBdUI7QUFDMUQsdUJBQXVCLG1CQUFPLENBQUMsZ0lBQW1CO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLCtIQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsU0FBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsOEJBQThCO0FBQzlCLGtCQUFrQjtBQUNsQix1QkFBdUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FYm9vdGgvYWdlbnRfY19mcmFtZXdvcmsvc3JjL3JlYWx0aW1lX2NsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vcHJvc2VtaXJyb3Itc2NoZW1hLWxpc3RAMS41LjEvbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHByb3NlbWlycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItdHJhbnNmb3JtJyk7XG52YXIgcHJvc2VtaXJyb3JNb2RlbCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLW1vZGVsJyk7XG52YXIgcHJvc2VtaXJyb3JTdGF0ZSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXN0YXRlJyk7XG52YXIgb2xET00gPSBbXCJvbFwiLCAwXSxcbiAgdWxET00gPSBbXCJ1bFwiLCAwXSxcbiAgbGlET00gPSBbXCJsaVwiLCAwXTtcbnZhciBvcmRlcmVkTGlzdCA9IHtcbiAgYXR0cnM6IHtcbiAgICBvcmRlcjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICB2YWxpZGF0ZTogXCJudW1iZXJcIlxuICAgIH1cbiAgfSxcbiAgcGFyc2VET006IFt7XG4gICAgdGFnOiBcIm9sXCIsXG4gICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIGdldEF0dHJzKGRvbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JkZXI6IGRvbS5oYXNBdHRyaWJ1dGUoXCJzdGFydFwiKSA/ICtkb20uZ2V0QXR0cmlidXRlKFwic3RhcnRcIikgOiAxXG4gICAgICB9O1xuICAgIH1cbiAgfV0sXG4gIHRvRE9NOiBmdW5jdGlvbiB0b0RPTShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuYXR0cnMub3JkZXIgPT0gMSA/IG9sRE9NIDogW1wib2xcIiwge1xuICAgICAgc3RhcnQ6IG5vZGUuYXR0cnMub3JkZXJcbiAgICB9LCAwXTtcbiAgfVxufTtcbnZhciBidWxsZXRMaXN0ID0ge1xuICBwYXJzZURPTTogW3tcbiAgICB0YWc6IFwidWxcIlxuICB9XSxcbiAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgIHJldHVybiB1bERPTTtcbiAgfVxufTtcbnZhciBsaXN0SXRlbSA9IHtcbiAgcGFyc2VET006IFt7XG4gICAgdGFnOiBcImxpXCJcbiAgfV0sXG4gIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICByZXR1cm4gbGlET007XG4gIH0sXG4gIGRlZmluaW5nOiB0cnVlXG59O1xuZnVuY3Rpb24gYWRkKG9iaiwgcHJvcHMpIHtcbiAgdmFyIGNvcHkgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gIGZvciAodmFyIF9wcm9wIGluIHByb3BzKSBjb3B5W19wcm9wXSA9IHByb3BzW19wcm9wXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgcmV0dXJuIG5vZGVzLmFwcGVuZCh7XG4gICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHtcbiAgICAgIGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLFxuICAgICAgZ3JvdXA6IGxpc3RHcm91cFxuICAgIH0pLFxuICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwge1xuICAgICAgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsXG4gICAgICBncm91cDogbGlzdEdyb3VwXG4gICAgfSksXG4gICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHtcbiAgICAgIGNvbnRlbnQ6IGl0ZW1Db250ZW50XG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiB3cmFwSW5MaXN0KGxpc3RUeXBlKSB7XG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbi4kZnJvbSxcbiAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb24uJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICBpZiAoIXJhbmdlKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHRyID0gZGlzcGF0Y2ggPyBzdGF0ZS50ciA6IG51bGw7XG4gICAgaWYgKCF3cmFwUmFuZ2VJbkxpc3QodHIsIHJhbmdlLCBsaXN0VHlwZSwgYXR0cnMpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBSYW5nZUluTGlzdCh0ciwgcmFuZ2UsIGxpc3RUeXBlKSB7XG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgdmFyIGRvSm9pbiA9IGZhbHNlLFxuICAgIG91dGVyUmFuZ2UgPSByYW5nZSxcbiAgICBkb2MgPSByYW5nZS4kZnJvbS5kb2M7XG4gIGlmIChyYW5nZS5kZXB0aCA+PSAyICYmIHJhbmdlLiRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlLmNvbXBhdGlibGVDb250ZW50KGxpc3RUeXBlKSAmJiByYW5nZS5zdGFydEluZGV4ID09IDApIHtcbiAgICBpZiAocmFuZ2UuJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyICRpbnNlcnQgPSBkb2MucmVzb2x2ZShyYW5nZS5zdGFydCAtIDIpO1xuICAgIG91dGVyUmFuZ2UgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5Ob2RlUmFuZ2UoJGluc2VydCwgJGluc2VydCwgcmFuZ2UuZGVwdGgpO1xuICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KSByYW5nZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLk5vZGVSYW5nZShyYW5nZS4kZnJvbSwgZG9jLnJlc29sdmUocmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCkpLCByYW5nZS5kZXB0aCk7XG4gICAgZG9Kb2luID0gdHJ1ZTtcbiAgfVxuICB2YXIgd3JhcCA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmZpbmRXcmFwcGluZyhvdXRlclJhbmdlLCBsaXN0VHlwZSwgYXR0cnMsIHJhbmdlKTtcbiAgaWYgKCF3cmFwKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0cikgZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcCwgZG9Kb2luLCBsaXN0VHlwZSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3RUeXBlKSB7XG4gIHZhciBjb250ZW50ID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcbiAgZm9yICh2YXIgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjb250ZW50ID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gIHRyLnN0ZXAobmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKHJhbmdlLnN0YXJ0IC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHJhbmdlLmVuZCwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICB2YXIgZm91bmQgPSAwO1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgd3JhcHBlcnMubGVuZ3RoOyBfaSsrKSBpZiAod3JhcHBlcnNbX2ldLnR5cGUgPT0gbGlzdFR5cGUpIGZvdW5kID0gX2kgKyAxO1xuICB2YXIgc3BsaXREZXB0aCA9IHdyYXBwZXJzLmxlbmd0aCAtIGZvdW5kO1xuICB2YXIgc3BsaXRQb3MgPSByYW5nZS5zdGFydCArIHdyYXBwZXJzLmxlbmd0aCAtIChqb2luQmVmb3JlID8gMiA6IDApLFxuICAgIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgZm9yICh2YXIgX2kyID0gcmFuZ2Uuc3RhcnRJbmRleCwgZSA9IHJhbmdlLmVuZEluZGV4LCBmaXJzdCA9IHRydWU7IF9pMiA8IGU7IF9pMisrLCBmaXJzdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFmaXJzdCAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5TcGxpdCh0ci5kb2MsIHNwbGl0UG9zLCBzcGxpdERlcHRoKSkge1xuICAgICAgdHIuc3BsaXQoc3BsaXRQb3MsIHNwbGl0RGVwdGgpO1xuICAgICAgc3BsaXRQb3MgKz0gMiAqIHNwbGl0RGVwdGg7XG4gICAgfVxuICAgIHNwbGl0UG9zICs9IHBhcmVudC5jaGlsZChfaTIpLm5vZGVTaXplO1xuICB9XG4gIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW0oaXRlbVR5cGUsIGl0ZW1BdHRycykge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uMiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjIuJGZyb20sXG4gICAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uMi4kdG8sXG4gICAgICBub2RlID0gX3N0YXRlJHNlbGVjdGlvbjIubm9kZTtcbiAgICBpZiAobm9kZSAmJiBub2RlLmlzQmxvY2sgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPSBpdGVtVHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgaWYgKCRmcm9tLmRlcHRoID09IDMgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPSBpdGVtVHlwZSB8fCAkZnJvbS5pbmRleCgtMikgIT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB2YXIgd3JhcCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIHZhciBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgZm9yICh2YXIgZCA9ICRmcm9tLmRlcHRoIC0gZGVwdGhCZWZvcmU7IGQgPj0gJGZyb20uZGVwdGggLSAzOyBkLS0pIHdyYXAgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgdmFyIGRlcHRoQWZ0ZXIgPSAkZnJvbS5pbmRleEFmdGVyKC0xKSA8ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgPyAxIDogJGZyb20uaW5kZXhBZnRlcigtMikgPCAkZnJvbS5ub2RlKC0zKS5jaGlsZENvdW50ID8gMiA6IDM7XG4gICAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgIHZhciBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKTtcbiAgICAgICAgdmFyIF90ciA9IHN0YXRlLnRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XG4gICAgICAgIHZhciBzZWwgPSAtMTtcbiAgICAgICAgX3RyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIF90ci5kb2MuY29udGVudC5zaXplLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICAgICAgaWYgKHNlbCA+IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgbm9kZS5jb250ZW50LnNpemUgPT0gMCkgc2VsID0gcG9zICsgMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzZWwgPiAtMSkgX3RyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5uZWFyKF90ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgIGRpc3BhdGNoKF90ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFR5cGUgPSAkdG8ucG9zID09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgIHZhciB0ciA9IHN0YXRlLnRyW1wiZGVsZXRlXCJdKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgdmFyIHR5cGVzID0gbmV4dFR5cGUgPyBbaXRlbUF0dHJzID8ge1xuICAgICAgdHlwZTogaXRlbVR5cGUsXG4gICAgICBhdHRyczogaXRlbUF0dHJzXG4gICAgfSA6IG51bGwsIHtcbiAgICAgIHR5cGU6IG5leHRUeXBlXG4gICAgfV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaCh0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW1LZWVwTWFya3MoaXRlbVR5cGUsIGl0ZW1BdHRycykge1xuICB2YXIgc3BsaXQgPSBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHJldHVybiBzcGxpdChzdGF0ZSwgZGlzcGF0Y2ggJiYgZnVuY3Rpb24gKHRyKSB7XG4gICAgICB2YXIgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICAgIGlmIChtYXJrcykgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbGlmdExpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24zID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uMy4kZnJvbSxcbiAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb24zLiR0bztcbiAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlO1xuICAgIH0pO1xuICAgIGlmICghcmFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWRpc3BhdGNoKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUgPT0gaXRlbVR5cGUpIHJldHVybiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpO2Vsc2UgcmV0dXJuIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpIHtcbiAgdmFyIHRyID0gc3RhdGUudHIsXG4gICAgZW5kID0gcmFuZ2UuZW5kLFxuICAgIGVuZE9mTGlzdCA9IHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpO1xuICBpZiAoZW5kIDwgZW5kT2ZMaXN0KSB7XG4gICAgdHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCByYW5nZS5wYXJlbnQuY29weSgpKSksIDEsIDApLCAxLCB0cnVlKSk7XG4gICAgcmFuZ2UgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5Ob2RlUmFuZ2UodHIuZG9jLnJlc29sdmUocmFuZ2UuJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgcmFuZ2UuZGVwdGgpO1xuICB9XG4gIHZhciB0YXJnZXQgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5saWZ0VGFyZ2V0KHJhbmdlKTtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHRyLmxpZnQocmFuZ2UsIHRhcmdldCk7XG4gIHZhciAkYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcChlbmQsIC0xKSAtIDEpO1xuICBpZiAocHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuSm9pbih0ci5kb2MsICRhZnRlci5wb3MpICYmICRhZnRlci5ub2RlQmVmb3JlLnR5cGUgPT0gJGFmdGVyLm5vZGVBZnRlci50eXBlKSB0ci5qb2luKCRhZnRlci5wb3MpO1xuICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIHtcbiAgdmFyIHRyID0gc3RhdGUudHIsXG4gICAgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgZm9yICh2YXIgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgIHBvcyAtPSBsaXN0LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgIHRyW1wiZGVsZXRlXCJdKHBvcyAtIDEsIHBvcyArIDEpO1xuICB9XG4gIHZhciAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCksXG4gICAgaXRlbSA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gIGlmICh0ci5tYXBwaW5nLm1hcChyYW5nZS5lbmQpICE9IHJhbmdlLnN0YXJ0ICsgJHN0YXJ0Lm5vZGVBZnRlci5ub2RlU2l6ZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT0gMCxcbiAgICBhdEVuZCA9IHJhbmdlLmVuZEluZGV4ID09IGxpc3QuY2hpbGRDb3VudDtcbiAgdmFyIHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSxcbiAgICBpbmRleEJlZm9yZSA9ICRzdGFydC5pbmRleCgtMSk7XG4gIGlmICghcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLCBpdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSA6IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShsaXN0KSkpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzdGFydCA9ICRzdGFydC5wb3MsXG4gICAgZW5kID0gc3RhcnQgKyBpdGVtLm5vZGVTaXplO1xuICB0ci5zdGVwKG5ldyBwcm9zZW1pcnJvclRyYW5zZm9ybS5SZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoKGF0U3RhcnQgPyBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5IDogcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGxpc3QuY29weShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5KSkpLmFwcGVuZChhdEVuZCA/IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHkgOiBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20obGlzdC5jb3B5KHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbjQgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb240LiRmcm9tLFxuICAgICAgJHRvID0gX3N0YXRlJHNlbGVjdGlvbjQuJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGU7XG4gICAgfSk7XG4gICAgaWYgKCFyYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleDtcbiAgICBpZiAoc3RhcnRJbmRleCA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudCxcbiAgICAgIG5vZGVCZWZvcmUgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpO1xuICAgIGlmIChub2RlQmVmb3JlLnR5cGUgIT0gaXRlbVR5cGUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHZhciBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09IHBhcmVudC50eXBlO1xuICAgICAgdmFyIGlubmVyID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKG5lc3RlZEJlZm9yZSA/IGl0ZW1UeXBlLmNyZWF0ZSgpIDogbnVsbCk7XG4gICAgICB2YXIgc2xpY2UgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShwYXJlbnQudHlwZS5jcmVhdGUobnVsbCwgaW5uZXIpKSkpLCBuZXN0ZWRCZWZvcmUgPyAzIDogMSwgMCk7XG4gICAgICB2YXIgYmVmb3JlID0gcmFuZ2Uuc3RhcnQsXG4gICAgICAgIGFmdGVyID0gcmFuZ2UuZW5kO1xuICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoYmVmb3JlIC0gKG5lc3RlZEJlZm9yZSA/IDMgOiAxKSwgYWZ0ZXIsIGJlZm9yZSwgYWZ0ZXIsIHNsaWNlLCAxLCB0cnVlKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZXhwb3J0cy5hZGRMaXN0Tm9kZXMgPSBhZGRMaXN0Tm9kZXM7XG5leHBvcnRzLmJ1bGxldExpc3QgPSBidWxsZXRMaXN0O1xuZXhwb3J0cy5saWZ0TGlzdEl0ZW0gPSBsaWZ0TGlzdEl0ZW07XG5leHBvcnRzLmxpc3RJdGVtID0gbGlzdEl0ZW07XG5leHBvcnRzLm9yZGVyZWRMaXN0ID0gb3JkZXJlZExpc3Q7XG5leHBvcnRzLnNpbmtMaXN0SXRlbSA9IHNpbmtMaXN0SXRlbTtcbmV4cG9ydHMuc3BsaXRMaXN0SXRlbSA9IHNwbGl0TGlzdEl0ZW07XG5leHBvcnRzLnNwbGl0TGlzdEl0ZW1LZWVwTWFya3MgPSBzcGxpdExpc3RJdGVtS2VlcE1hcmtzO1xuZXhwb3J0cy53cmFwSW5MaXN0ID0gd3JhcEluTGlzdDtcbmV4cG9ydHMud3JhcFJhbmdlSW5MaXN0ID0gd3JhcFJhbmdlSW5MaXN0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/prosemirror-schema-list@1.5.1/node_modules/prosemirror-schema-list/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/prosemirror-schema-list@1.5.1/node_modules/prosemirror-schema-list/dist/index.cjs":
/*!******************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/prosemirror-schema-list@1.5.1/node_modules/prosemirror-schema-list/dist/index.cjs ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/../../node_modules/.pnpm/prosemirror-transform@1.10.4/node_modules/prosemirror-transform/dist/index.cjs\");\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"(ssr)/../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs\");\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"(ssr)/../../node_modules/.pnpm/prosemirror-state@1.4.3/node_modules/prosemirror-state/dist/index.cjs\");\nvar olDOM = [\"ol\", 0],\n  ulDOM = [\"ul\", 0],\n  liDOM = [\"li\", 0];\nvar orderedList = {\n  attrs: {\n    order: {\n      \"default\": 1,\n      validate: \"number\"\n    }\n  },\n  parseDOM: [{\n    tag: \"ol\",\n    getAttrs: function getAttrs(dom) {\n      return {\n        order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1\n      };\n    }\n  }],\n  toDOM: function toDOM(node) {\n    return node.attrs.order == 1 ? olDOM : [\"ol\", {\n      start: node.attrs.order\n    }, 0];\n  }\n};\nvar bulletList = {\n  parseDOM: [{\n    tag: \"ul\"\n  }],\n  toDOM: function toDOM() {\n    return ulDOM;\n  }\n};\nvar listItem = {\n  parseDOM: [{\n    tag: \"li\"\n  }],\n  toDOM: function toDOM() {\n    return liDOM;\n  },\n  defining: true\n};\nfunction add(obj, props) {\n  var copy = {};\n  for (var prop in obj) copy[prop] = obj[prop];\n  for (var _prop in props) copy[_prop] = props[_prop];\n  return copy;\n}\nfunction addListNodes(nodes, itemContent, listGroup) {\n  return nodes.append({\n    ordered_list: add(orderedList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    bullet_list: add(bulletList, {\n      content: \"list_item+\",\n      group: listGroup\n    }),\n    list_item: add(listItem, {\n      content: itemContent\n    })\n  });\n}\nfunction wrapInList(listType) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    var _state$selection = state.selection,\n      $from = _state$selection.$from,\n      $to = _state$selection.$to;\n    var range = $from.blockRange($to);\n    if (!range) return false;\n    var tr = dispatch ? state.tr : null;\n    if (!wrapRangeInList(tr, range, listType, attrs)) return false;\n    if (dispatch) dispatch(tr.scrollIntoView());\n    return true;\n  };\n}\nfunction wrapRangeInList(tr, range, listType) {\n  var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var doJoin = false,\n    outerRange = range,\n    doc = range.$from.doc;\n  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n    if (range.$from.index(range.depth - 1) == 0) return false;\n    var $insert = doc.resolve(range.start - 2);\n    outerRange = new prosemirrorModel.NodeRange($insert, $insert, range.depth);\n    if (range.endIndex < range.parent.childCount) range = new prosemirrorModel.NodeRange(range.$from, doc.resolve(range.$to.end(range.depth)), range.depth);\n    doJoin = true;\n  }\n  var wrap = prosemirrorTransform.findWrapping(outerRange, listType, attrs, range);\n  if (!wrap) return false;\n  if (tr) doWrapInList(tr, range, wrap, doJoin, listType);\n  return true;\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n  var content = prosemirrorModel.Fragment.empty;\n  for (var i = wrappers.length - 1; i >= 0; i--) content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  tr.step(new prosemirrorTransform.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));\n  var found = 0;\n  for (var _i = 0; _i < wrappers.length; _i++) if (wrappers[_i].type == listType) found = _i + 1;\n  var splitDepth = wrappers.length - found;\n  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),\n    parent = range.parent;\n  for (var _i2 = range.startIndex, e = range.endIndex, first = true; _i2 < e; _i2++, first = false) {\n    if (!first && prosemirrorTransform.canSplit(tr.doc, splitPos, splitDepth)) {\n      tr.split(splitPos, splitDepth);\n      splitPos += 2 * splitDepth;\n    }\n    splitPos += parent.child(_i2).nodeSize;\n  }\n  return tr;\n}\nfunction splitListItem(itemType, itemAttrs) {\n  return function (state, dispatch) {\n    var _state$selection2 = state.selection,\n      $from = _state$selection2.$from,\n      $to = _state$selection2.$to,\n      node = _state$selection2.node;\n    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;\n    var grandParent = $from.node(-1);\n    if (grandParent.type != itemType) return false;\n    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;\n      if (dispatch) {\n        var wrap = prosemirrorModel.Fragment.empty;\n        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--) wrap = prosemirrorModel.Fragment.from($from.node(d).copy(wrap));\n        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n        wrap = wrap.append(prosemirrorModel.Fragment.from(itemType.createAndFill()));\n        var start = $from.before($from.depth - (depthBefore - 1));\n        var _tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirrorModel.Slice(wrap, 4 - depthBefore, 0));\n        var sel = -1;\n        _tr.doc.nodesBetween(start, _tr.doc.content.size, function (node, pos) {\n          if (sel > -1) return false;\n          if (node.isTextblock && node.content.size == 0) sel = pos + 1;\n        });\n        if (sel > -1) _tr.setSelection(prosemirrorState.Selection.near(_tr.doc.resolve(sel)));\n        dispatch(_tr.scrollIntoView());\n      }\n      return true;\n    }\n    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    var tr = state.tr[\"delete\"]($from.pos, $to.pos);\n    var types = nextType ? [itemAttrs ? {\n      type: itemType,\n      attrs: itemAttrs\n    } : null, {\n      type: nextType\n    }] : undefined;\n    if (!prosemirrorTransform.canSplit(tr.doc, $from.pos, 2, types)) return false;\n    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n    return true;\n  };\n}\nfunction splitListItemKeepMarks(itemType, itemAttrs) {\n  var split = splitListItem(itemType, itemAttrs);\n  return function (state, dispatch) {\n    return split(state, dispatch && function (tr) {\n      var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n      if (marks) tr.ensureMarks(marks);\n      dispatch(tr);\n    });\n  };\n}\nfunction liftListItem(itemType) {\n  return function (state, dispatch) {\n    var _state$selection3 = state.selection,\n      $from = _state$selection3.$from,\n      $to = _state$selection3.$to;\n    var range = $from.blockRange($to, function (node) {\n      return node.childCount > 0 && node.firstChild.type == itemType;\n    });\n    if (!range) return false;\n    if (!dispatch) return true;\n    if ($from.node(range.depth - 1).type == itemType) return liftToOuterList(state, dispatch, itemType, range);else return liftOutOfList(state, dispatch, range);\n  };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n  var tr = state.tr,\n    end = range.end,\n    endOfList = range.$to.end(range.depth);\n  if (end < endOfList) {\n    tr.step(new prosemirrorTransform.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n    range = new prosemirrorModel.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n  }\n  var target = prosemirrorTransform.liftTarget(range);\n  if (target == null) return false;\n  tr.lift(range, target);\n  var $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);\n  if (prosemirrorTransform.canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type) tr.join($after.pos);\n  dispatch(tr.scrollIntoView());\n  return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n  var tr = state.tr,\n    list = range.parent;\n  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n    pos -= list.child(i).nodeSize;\n    tr[\"delete\"](pos - 1, pos + 1);\n  }\n  var $start = tr.doc.resolve(range.start),\n    item = $start.nodeAfter;\n  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;\n  var atStart = range.startIndex == 0,\n    atEnd = range.endIndex == list.childCount;\n  var parent = $start.node(-1),\n    indexBefore = $start.index(-1);\n  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list)))) return false;\n  var start = $start.pos,\n    end = start + item.nodeSize;\n  tr.step(new prosemirrorTransform.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirrorModel.Slice((atStart ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))).append(atEnd ? prosemirrorModel.Fragment.empty : prosemirrorModel.Fragment.from(list.copy(prosemirrorModel.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n  dispatch(tr.scrollIntoView());\n  return true;\n}\nfunction sinkListItem(itemType) {\n  return function (state, dispatch) {\n    var _state$selection4 = state.selection,\n      $from = _state$selection4.$from,\n      $to = _state$selection4.$to;\n    var range = $from.blockRange($to, function (node) {\n      return node.childCount > 0 && node.firstChild.type == itemType;\n    });\n    if (!range) return false;\n    var startIndex = range.startIndex;\n    if (startIndex == 0) return false;\n    var parent = range.parent,\n      nodeBefore = parent.child(startIndex - 1);\n    if (nodeBefore.type != itemType) return false;\n    if (dispatch) {\n      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n      var inner = prosemirrorModel.Fragment.from(nestedBefore ? itemType.create() : null);\n      var slice = new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(itemType.create(null, prosemirrorModel.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n      var before = range.start,\n        after = range.end;\n      dispatch(state.tr.step(new prosemirrorTransform.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());\n    }\n    return true;\n  };\n}\nexports.addListNodes = addListNodes;\nexports.bulletList = bulletList;\nexports.liftListItem = liftListItem;\nexports.listItem = listItem;\nexports.orderedList = orderedList;\nexports.sinkListItem = sinkListItem;\nexports.splitListItem = splitListItem;\nexports.splitListItemKeepMarks = splitListItemKeepMarks;\nexports.wrapInList = wrapInList;\nexports.wrapRangeInList = wrapRangeInList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0QDEuNS4xL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyw0SUFBdUI7QUFDMUQsdUJBQXVCLG1CQUFPLENBQUMsZ0lBQW1CO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLCtIQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsU0FBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzQkFBc0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrR0FBK0c7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckIsOEJBQThCO0FBQzlCLGtCQUFrQjtBQUNsQix1QkFBdUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FYm9vdGgvYWdlbnRfY19mcmFtZXdvcmsvc3JjL3JlYWx0aW1lX2NsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vcHJvc2VtaXJyb3Itc2NoZW1hLWxpc3RAMS41LjEvbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHByb3NlbWlycm9yVHJhbnNmb3JtID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItdHJhbnNmb3JtJyk7XG52YXIgcHJvc2VtaXJyb3JNb2RlbCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLW1vZGVsJyk7XG52YXIgcHJvc2VtaXJyb3JTdGF0ZSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXN0YXRlJyk7XG52YXIgb2xET00gPSBbXCJvbFwiLCAwXSxcbiAgdWxET00gPSBbXCJ1bFwiLCAwXSxcbiAgbGlET00gPSBbXCJsaVwiLCAwXTtcbnZhciBvcmRlcmVkTGlzdCA9IHtcbiAgYXR0cnM6IHtcbiAgICBvcmRlcjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICB2YWxpZGF0ZTogXCJudW1iZXJcIlxuICAgIH1cbiAgfSxcbiAgcGFyc2VET006IFt7XG4gICAgdGFnOiBcIm9sXCIsXG4gICAgZ2V0QXR0cnM6IGZ1bmN0aW9uIGdldEF0dHJzKGRvbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JkZXI6IGRvbS5oYXNBdHRyaWJ1dGUoXCJzdGFydFwiKSA/ICtkb20uZ2V0QXR0cmlidXRlKFwic3RhcnRcIikgOiAxXG4gICAgICB9O1xuICAgIH1cbiAgfV0sXG4gIHRvRE9NOiBmdW5jdGlvbiB0b0RPTShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuYXR0cnMub3JkZXIgPT0gMSA/IG9sRE9NIDogW1wib2xcIiwge1xuICAgICAgc3RhcnQ6IG5vZGUuYXR0cnMub3JkZXJcbiAgICB9LCAwXTtcbiAgfVxufTtcbnZhciBidWxsZXRMaXN0ID0ge1xuICBwYXJzZURPTTogW3tcbiAgICB0YWc6IFwidWxcIlxuICB9XSxcbiAgdG9ET006IGZ1bmN0aW9uIHRvRE9NKCkge1xuICAgIHJldHVybiB1bERPTTtcbiAgfVxufTtcbnZhciBsaXN0SXRlbSA9IHtcbiAgcGFyc2VET006IFt7XG4gICAgdGFnOiBcImxpXCJcbiAgfV0sXG4gIHRvRE9NOiBmdW5jdGlvbiB0b0RPTSgpIHtcbiAgICByZXR1cm4gbGlET007XG4gIH0sXG4gIGRlZmluaW5nOiB0cnVlXG59O1xuZnVuY3Rpb24gYWRkKG9iaiwgcHJvcHMpIHtcbiAgdmFyIGNvcHkgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gIGZvciAodmFyIF9wcm9wIGluIHByb3BzKSBjb3B5W19wcm9wXSA9IHByb3BzW19wcm9wXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgcmV0dXJuIG5vZGVzLmFwcGVuZCh7XG4gICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHtcbiAgICAgIGNvbnRlbnQ6IFwibGlzdF9pdGVtK1wiLFxuICAgICAgZ3JvdXA6IGxpc3RHcm91cFxuICAgIH0pLFxuICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwge1xuICAgICAgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsXG4gICAgICBncm91cDogbGlzdEdyb3VwXG4gICAgfSksXG4gICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHtcbiAgICAgIGNvbnRlbnQ6IGl0ZW1Db250ZW50XG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiB3cmFwSW5MaXN0KGxpc3RUeXBlKSB7XG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbi4kZnJvbSxcbiAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb24uJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKTtcbiAgICBpZiAoIXJhbmdlKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHRyID0gZGlzcGF0Y2ggPyBzdGF0ZS50ciA6IG51bGw7XG4gICAgaWYgKCF3cmFwUmFuZ2VJbkxpc3QodHIsIHJhbmdlLCBsaXN0VHlwZSwgYXR0cnMpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBSYW5nZUluTGlzdCh0ciwgcmFuZ2UsIGxpc3RUeXBlKSB7XG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgdmFyIGRvSm9pbiA9IGZhbHNlLFxuICAgIG91dGVyUmFuZ2UgPSByYW5nZSxcbiAgICBkb2MgPSByYW5nZS4kZnJvbS5kb2M7XG4gIGlmIChyYW5nZS5kZXB0aCA+PSAyICYmIHJhbmdlLiRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlLmNvbXBhdGlibGVDb250ZW50KGxpc3RUeXBlKSAmJiByYW5nZS5zdGFydEluZGV4ID09IDApIHtcbiAgICBpZiAocmFuZ2UuJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyICRpbnNlcnQgPSBkb2MucmVzb2x2ZShyYW5nZS5zdGFydCAtIDIpO1xuICAgIG91dGVyUmFuZ2UgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5Ob2RlUmFuZ2UoJGluc2VydCwgJGluc2VydCwgcmFuZ2UuZGVwdGgpO1xuICAgIGlmIChyYW5nZS5lbmRJbmRleCA8IHJhbmdlLnBhcmVudC5jaGlsZENvdW50KSByYW5nZSA9IG5ldyBwcm9zZW1pcnJvck1vZGVsLk5vZGVSYW5nZShyYW5nZS4kZnJvbSwgZG9jLnJlc29sdmUocmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCkpLCByYW5nZS5kZXB0aCk7XG4gICAgZG9Kb2luID0gdHJ1ZTtcbiAgfVxuICB2YXIgd3JhcCA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmZpbmRXcmFwcGluZyhvdXRlclJhbmdlLCBsaXN0VHlwZSwgYXR0cnMsIHJhbmdlKTtcbiAgaWYgKCF3cmFwKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0cikgZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcCwgZG9Kb2luLCBsaXN0VHlwZSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3RUeXBlKSB7XG4gIHZhciBjb250ZW50ID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcbiAgZm9yICh2YXIgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBjb250ZW50ID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gIHRyLnN0ZXAobmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKHJhbmdlLnN0YXJ0IC0gKGpvaW5CZWZvcmUgPyAyIDogMCksIHJhbmdlLmVuZCwgcmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICB2YXIgZm91bmQgPSAwO1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgd3JhcHBlcnMubGVuZ3RoOyBfaSsrKSBpZiAod3JhcHBlcnNbX2ldLnR5cGUgPT0gbGlzdFR5cGUpIGZvdW5kID0gX2kgKyAxO1xuICB2YXIgc3BsaXREZXB0aCA9IHdyYXBwZXJzLmxlbmd0aCAtIGZvdW5kO1xuICB2YXIgc3BsaXRQb3MgPSByYW5nZS5zdGFydCArIHdyYXBwZXJzLmxlbmd0aCAtIChqb2luQmVmb3JlID8gMiA6IDApLFxuICAgIHBhcmVudCA9IHJhbmdlLnBhcmVudDtcbiAgZm9yICh2YXIgX2kyID0gcmFuZ2Uuc3RhcnRJbmRleCwgZSA9IHJhbmdlLmVuZEluZGV4LCBmaXJzdCA9IHRydWU7IF9pMiA8IGU7IF9pMisrLCBmaXJzdCA9IGZhbHNlKSB7XG4gICAgaWYgKCFmaXJzdCAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5TcGxpdCh0ci5kb2MsIHNwbGl0UG9zLCBzcGxpdERlcHRoKSkge1xuICAgICAgdHIuc3BsaXQoc3BsaXRQb3MsIHNwbGl0RGVwdGgpO1xuICAgICAgc3BsaXRQb3MgKz0gMiAqIHNwbGl0RGVwdGg7XG4gICAgfVxuICAgIHNwbGl0UG9zICs9IHBhcmVudC5jaGlsZChfaTIpLm5vZGVTaXplO1xuICB9XG4gIHJldHVybiB0cjtcbn1cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW0oaXRlbVR5cGUsIGl0ZW1BdHRycykge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uMiA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjIuJGZyb20sXG4gICAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uMi4kdG8sXG4gICAgICBub2RlID0gX3N0YXRlJHNlbGVjdGlvbjIubm9kZTtcbiAgICBpZiAobm9kZSAmJiBub2RlLmlzQmxvY2sgfHwgJGZyb20uZGVwdGggPCAyIHx8ICEkZnJvbS5zYW1lUGFyZW50KCR0bykpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPSBpdGVtVHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgaWYgKCRmcm9tLmRlcHRoID09IDMgfHwgJGZyb20ubm9kZSgtMykudHlwZSAhPSBpdGVtVHlwZSB8fCAkZnJvbS5pbmRleCgtMikgIT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB2YXIgd3JhcCA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIHZhciBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgZm9yICh2YXIgZCA9ICRmcm9tLmRlcHRoIC0gZGVwdGhCZWZvcmU7IGQgPj0gJGZyb20uZGVwdGggLSAzOyBkLS0pIHdyYXAgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgdmFyIGRlcHRoQWZ0ZXIgPSAkZnJvbS5pbmRleEFmdGVyKC0xKSA8ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgPyAxIDogJGZyb20uaW5kZXhBZnRlcigtMikgPCAkZnJvbS5ub2RlKC0zKS5jaGlsZENvdW50ID8gMiA6IDM7XG4gICAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgIHZhciBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKTtcbiAgICAgICAgdmFyIF90ciA9IHN0YXRlLnRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2Uod3JhcCwgNCAtIGRlcHRoQmVmb3JlLCAwKSk7XG4gICAgICAgIHZhciBzZWwgPSAtMTtcbiAgICAgICAgX3RyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIF90ci5kb2MuY29udGVudC5zaXplLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICAgICAgaWYgKHNlbCA+IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgbm9kZS5jb250ZW50LnNpemUgPT0gMCkgc2VsID0gcG9zICsgMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzZWwgPiAtMSkgX3RyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbi5uZWFyKF90ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgIGRpc3BhdGNoKF90ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFR5cGUgPSAkdG8ucG9zID09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgIHZhciB0ciA9IHN0YXRlLnRyW1wiZGVsZXRlXCJdKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgdmFyIHR5cGVzID0gbmV4dFR5cGUgPyBbaXRlbUF0dHJzID8ge1xuICAgICAgdHlwZTogaXRlbVR5cGUsXG4gICAgICBhdHRyczogaXRlbUF0dHJzXG4gICAgfSA6IG51bGwsIHtcbiAgICAgIHR5cGU6IG5leHRUeXBlXG4gICAgfV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMiwgdHlwZXMpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaCh0ci5zcGxpdCgkZnJvbS5wb3MsIDIsIHR5cGVzKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0TGlzdEl0ZW1LZWVwTWFya3MoaXRlbVR5cGUsIGl0ZW1BdHRycykge1xuICB2YXIgc3BsaXQgPSBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHJldHVybiBzcGxpdChzdGF0ZSwgZGlzcGF0Y2ggJiYgZnVuY3Rpb24gKHRyKSB7XG4gICAgICB2YXIgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICAgIGlmIChtYXJrcykgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gbGlmdExpc3RJdGVtKGl0ZW1UeXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24zID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uMy4kZnJvbSxcbiAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb24zLiR0bztcbiAgICB2YXIgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0bywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmNoaWxkQ291bnQgPiAwICYmIG5vZGUuZmlyc3RDaGlsZC50eXBlID09IGl0ZW1UeXBlO1xuICAgIH0pO1xuICAgIGlmICghcmFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWRpc3BhdGNoKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoJGZyb20ubm9kZShyYW5nZS5kZXB0aCAtIDEpLnR5cGUgPT0gaXRlbVR5cGUpIHJldHVybiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpO2Vsc2UgcmV0dXJuIGxpZnRPdXRPZkxpc3Qoc3RhdGUsIGRpc3BhdGNoLCByYW5nZSk7XG4gIH07XG59XG5mdW5jdGlvbiBsaWZ0VG9PdXRlckxpc3Qoc3RhdGUsIGRpc3BhdGNoLCBpdGVtVHlwZSwgcmFuZ2UpIHtcbiAgdmFyIHRyID0gc3RhdGUudHIsXG4gICAgZW5kID0gcmFuZ2UuZW5kLFxuICAgIGVuZE9mTGlzdCA9IHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpO1xuICBpZiAoZW5kIDwgZW5kT2ZMaXN0KSB7XG4gICAgdHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoZW5kIC0gMSwgZW5kT2ZMaXN0LCBlbmQsIGVuZE9mTGlzdCwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UocHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGl0ZW1UeXBlLmNyZWF0ZShudWxsLCByYW5nZS5wYXJlbnQuY29weSgpKSksIDEsIDApLCAxLCB0cnVlKSk7XG4gICAgcmFuZ2UgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5Ob2RlUmFuZ2UodHIuZG9jLnJlc29sdmUocmFuZ2UuJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgcmFuZ2UuZGVwdGgpO1xuICB9XG4gIHZhciB0YXJnZXQgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5saWZ0VGFyZ2V0KHJhbmdlKTtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHRyLmxpZnQocmFuZ2UsIHRhcmdldCk7XG4gIHZhciAkYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcChlbmQsIC0xKSAtIDEpO1xuICBpZiAocHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuSm9pbih0ci5kb2MsICRhZnRlci5wb3MpICYmICRhZnRlci5ub2RlQmVmb3JlLnR5cGUgPT0gJGFmdGVyLm5vZGVBZnRlci50eXBlKSB0ci5qb2luKCRhZnRlci5wb3MpO1xuICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIHtcbiAgdmFyIHRyID0gc3RhdGUudHIsXG4gICAgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgZm9yICh2YXIgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgIHBvcyAtPSBsaXN0LmNoaWxkKGkpLm5vZGVTaXplO1xuICAgIHRyW1wiZGVsZXRlXCJdKHBvcyAtIDEsIHBvcyArIDEpO1xuICB9XG4gIHZhciAkc3RhcnQgPSB0ci5kb2MucmVzb2x2ZShyYW5nZS5zdGFydCksXG4gICAgaXRlbSA9ICRzdGFydC5ub2RlQWZ0ZXI7XG4gIGlmICh0ci5tYXBwaW5nLm1hcChyYW5nZS5lbmQpICE9IHJhbmdlLnN0YXJ0ICsgJHN0YXJ0Lm5vZGVBZnRlci5ub2RlU2l6ZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT0gMCxcbiAgICBhdEVuZCA9IHJhbmdlLmVuZEluZGV4ID09IGxpc3QuY2hpbGRDb3VudDtcbiAgdmFyIHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSxcbiAgICBpbmRleEJlZm9yZSA9ICRzdGFydC5pbmRleCgtMSk7XG4gIGlmICghcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLCBpdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eSA6IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShsaXN0KSkpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzdGFydCA9ICRzdGFydC5wb3MsXG4gICAgZW5kID0gc3RhcnQgKyBpdGVtLm5vZGVTaXplO1xuICB0ci5zdGVwKG5ldyBwcm9zZW1pcnJvclRyYW5zZm9ybS5SZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IHByb3NlbWlycm9yTW9kZWwuU2xpY2UoKGF0U3RhcnQgPyBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5IDogcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGxpc3QuY29weShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmVtcHR5KSkpLmFwcGVuZChhdEVuZCA/IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHkgOiBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20obGlzdC5jb3B5KHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHkpKSksIGF0U3RhcnQgPyAwIDogMSwgYXRFbmQgPyAwIDogMSksIGF0U3RhcnQgPyAwIDogMSkpO1xuICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbjQgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAkZnJvbSA9IF9zdGF0ZSRzZWxlY3Rpb240LiRmcm9tLFxuICAgICAgJHRvID0gX3N0YXRlJHNlbGVjdGlvbjQuJHRvO1xuICAgIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGU7XG4gICAgfSk7XG4gICAgaWYgKCFyYW5nZSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzdGFydEluZGV4ID0gcmFuZ2Uuc3RhcnRJbmRleDtcbiAgICBpZiAoc3RhcnRJbmRleCA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHBhcmVudCA9IHJhbmdlLnBhcmVudCxcbiAgICAgIG5vZGVCZWZvcmUgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpO1xuICAgIGlmIChub2RlQmVmb3JlLnR5cGUgIT0gaXRlbVR5cGUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHZhciBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09IHBhcmVudC50eXBlO1xuICAgICAgdmFyIGlubmVyID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKG5lc3RlZEJlZm9yZSA/IGl0ZW1UeXBlLmNyZWF0ZSgpIDogbnVsbCk7XG4gICAgICB2YXIgc2xpY2UgPSBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZnJvbShwYXJlbnQudHlwZS5jcmVhdGUobnVsbCwgaW5uZXIpKSkpLCBuZXN0ZWRCZWZvcmUgPyAzIDogMSwgMCk7XG4gICAgICB2YXIgYmVmb3JlID0gcmFuZ2Uuc3RhcnQsXG4gICAgICAgIGFmdGVyID0gcmFuZ2UuZW5kO1xuICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoYmVmb3JlIC0gKG5lc3RlZEJlZm9yZSA/IDMgOiAxKSwgYWZ0ZXIsIGJlZm9yZSwgYWZ0ZXIsIHNsaWNlLCAxLCB0cnVlKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZXhwb3J0cy5hZGRMaXN0Tm9kZXMgPSBhZGRMaXN0Tm9kZXM7XG5leHBvcnRzLmJ1bGxldExpc3QgPSBidWxsZXRMaXN0O1xuZXhwb3J0cy5saWZ0TGlzdEl0ZW0gPSBsaWZ0TGlzdEl0ZW07XG5leHBvcnRzLmxpc3RJdGVtID0gbGlzdEl0ZW07XG5leHBvcnRzLm9yZGVyZWRMaXN0ID0gb3JkZXJlZExpc3Q7XG5leHBvcnRzLnNpbmtMaXN0SXRlbSA9IHNpbmtMaXN0SXRlbTtcbmV4cG9ydHMuc3BsaXRMaXN0SXRlbSA9IHNwbGl0TGlzdEl0ZW07XG5leHBvcnRzLnNwbGl0TGlzdEl0ZW1LZWVwTWFya3MgPSBzcGxpdExpc3RJdGVtS2VlcE1hcmtzO1xuZXhwb3J0cy53cmFwSW5MaXN0ID0gd3JhcEluTGlzdDtcbmV4cG9ydHMud3JhcFJhbmdlSW5MaXN0ID0gd3JhcFJhbmdlSW5MaXN0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/prosemirror-schema-list@1.5.1/node_modules/prosemirror-schema-list/dist/index.cjs\n");

/***/ })

};
;