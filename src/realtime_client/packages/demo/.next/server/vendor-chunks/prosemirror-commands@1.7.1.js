"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-commands@1.7.1";
exports.ids = ["vendor-chunks/prosemirror-commands@1.7.1"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/prosemirror-commands@1.7.1/node_modules/prosemirror-commands/dist/index.cjs":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/prosemirror-commands@1.7.1/node_modules/prosemirror-commands/dist/index.cjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"(rsc)/../../node_modules/.pnpm/prosemirror-transform@1.10.4/node_modules/prosemirror-transform/dist/index.cjs\");\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"(rsc)/../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs\");\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"(rsc)/../../node_modules/.pnpm/prosemirror-state@1.4.3/node_modules/prosemirror-state/dist/index.cjs\");\nvar deleteSelection = function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false;\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());\n  return true;\n};\nfunction atBlockStart(state, view) {\n  var $cursor = state.selection.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) return null;\n  return $cursor;\n}\nvar joinBackward = function joinBackward(state, dispatch, view) {\n  var $cursor = atBlockStart(state, view);\n  if (!$cursor) return false;\n  var $cut = findCutBefore($cursor);\n  if (!$cut) {\n    var range = $cursor.blockRange(),\n      target = range && prosemirrorTransform.liftTarget(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n  var before = $cut.nodeBefore;\n  if (deleteBarrier(state, $cut, dispatch, -1)) return true;\n  if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || prosemirrorState.NodeSelection.isSelectable(before))) {\n    for (var depth = $cursor.depth;; depth--) {\n      var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), prosemirrorModel.Slice.empty);\n      if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n        if (dispatch) {\n          var tr = state.tr.step(delStep);\n          tr.setSelection(textblockAt(before, \"end\") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirrorState.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n          dispatch(tr.scrollIntoView());\n        }\n        return true;\n      }\n      if (depth == 1 || $cursor.node(depth - 1).childCount > 1) break;\n    }\n  }\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr[\"delete\"]($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n    return true;\n  }\n  return false;\n};\nvar joinTextblockBackward = function joinTextblockBackward(state, dispatch, view) {\n  var $cursor = atBlockStart(state, view);\n  if (!$cursor) return false;\n  var $cut = findCutBefore($cursor);\n  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nvar joinTextblockForward = function joinTextblockForward(state, dispatch, view) {\n  var $cursor = atBlockEnd(state, view);\n  if (!$cursor) return false;\n  var $cut = findCutAfter($cursor);\n  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n  var before = $cut.nodeBefore,\n    beforeText = before,\n    beforePos = $cut.pos - 1;\n  for (; !beforeText.isTextblock; beforePos--) {\n    if (beforeText.type.spec.isolating) return false;\n    var child = beforeText.lastChild;\n    if (!child) return false;\n    beforeText = child;\n  }\n  var after = $cut.nodeAfter,\n    afterText = after,\n    afterPos = $cut.pos + 1;\n  for (; !afterText.isTextblock; afterPos++) {\n    if (afterText.type.spec.isolating) return false;\n    var _child = afterText.firstChild;\n    if (!_child) return false;\n    afterText = _child;\n  }\n  var step = prosemirrorTransform.replaceStep(state.doc, beforePos, afterPos, prosemirrorModel.Slice.empty);\n  if (!step || step.from != beforePos || step instanceof prosemirrorTransform.ReplaceStep && step.slice.size >= afterPos - beforePos) return false;\n  if (dispatch) {\n    var tr = state.tr.step(step);\n    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, beforePos));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n}\nfunction textblockAt(node, side) {\n  var only = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  for (var scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild) {\n    if (scan.isTextblock) return true;\n    if (only && scan.childCount != 1) return false;\n  }\n  return false;\n}\nvar selectNodeBackward = function selectNodeBackward(state, dispatch, view) {\n  var _state$selection = state.selection,\n    $head = _state$selection.$head,\n    empty = _state$selection.empty,\n    $cut = $head;\n  if (!empty) return false;\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false;\n    $cut = findCutBefore($head);\n  }\n  var node = $cut && $cut.nodeBefore;\n  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n  return true;\n};\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));\n    if ($pos.node(i).type.spec.isolating) break;\n  }\n  return null;\n}\nfunction atBlockEnd(state, view) {\n  var $cursor = state.selection.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) return null;\n  return $cursor;\n}\nvar joinForward = function joinForward(state, dispatch, view) {\n  var $cursor = atBlockEnd(state, view);\n  if (!$cursor) return false;\n  var $cut = findCutAfter($cursor);\n  if (!$cut) return false;\n  var after = $cut.nodeAfter;\n  if (deleteBarrier(state, $cut, dispatch, 1)) return true;\n  if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || prosemirrorState.NodeSelection.isSelectable(after))) {\n    var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(), $cursor.after(), prosemirrorModel.Slice.empty);\n    if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        var tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(after, \"start\") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirrorState.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n  }\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr[\"delete\"]($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n    return true;\n  }\n  return false;\n};\nvar selectNodeForward = function selectNodeForward(state, dispatch, view) {\n  var _state$selection2 = state.selection,\n    $head = _state$selection2.$head,\n    empty = _state$selection2.empty,\n    $cut = $head;\n  if (!empty) return false;\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) return false;\n    $cut = findCutAfter($head);\n  }\n  var node = $cut && $cut.nodeAfter;\n  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n  return true;\n};\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {\n    var parent = $pos.node(i);\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));\n    if (parent.type.spec.isolating) break;\n  }\n  return null;\n}\nvar joinUp = function joinUp(state, dispatch) {\n  var sel = state.selection,\n    nodeSel = sel instanceof prosemirrorState.NodeSelection,\n    point;\n  if (nodeSel) {\n    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.from)) return false;\n    point = sel.from;\n  } else {\n    point = prosemirrorTransform.joinPoint(state.doc, sel.from, -1);\n    if (point == null) return false;\n  }\n  if (dispatch) {\n    var tr = state.tr.join(point);\n    if (nodeSel) tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nvar joinDown = function joinDown(state, dispatch) {\n  var sel = state.selection,\n    point;\n  if (sel instanceof prosemirrorState.NodeSelection) {\n    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.to)) return false;\n    point = sel.to;\n  } else {\n    point = prosemirrorTransform.joinPoint(state.doc, sel.to, 1);\n    if (point == null) return false;\n  }\n  if (dispatch) dispatch(state.tr.join(point).scrollIntoView());\n  return true;\n};\nvar lift = function lift(state, dispatch) {\n  var _state$selection3 = state.selection,\n    $from = _state$selection3.$from,\n    $to = _state$selection3.$to;\n  var range = $from.blockRange($to),\n    target = range && prosemirrorTransform.liftTarget(range);\n  if (target == null) return false;\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n  return true;\n};\nvar newlineInCode = function newlineInCode(state, dispatch) {\n  var _state$selection4 = state.selection,\n    $head = _state$selection4.$head,\n    $anchor = _state$selection4.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n  return true;\n};\nfunction defaultBlockAt(match) {\n  for (var i = 0; i < match.edgeCount; i++) {\n    var _match$edge = match.edge(i),\n      type = _match$edge.type;\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type;\n  }\n  return null;\n}\nvar exitCode = function exitCode(state, dispatch) {\n  var _state$selection5 = state.selection,\n    $head = _state$selection5.$head,\n    $anchor = _state$selection5.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n  var above = $head.node(-1),\n    after = $head.indexAfter(-1),\n    type = defaultBlockAt(above.contentMatchAt(after));\n  if (!type || !above.canReplaceWith(after, after, type)) return false;\n  if (dispatch) {\n    var pos = $head.after(),\n      tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nvar createParagraphNear = function createParagraphNear(state, dispatch) {\n  var sel = state.selection,\n    $from = sel.$from,\n    $to = sel.$to;\n  if (sel instanceof prosemirrorState.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;\n  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n  if (!type || !type.isTextblock) return false;\n  if (dispatch) {\n    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    var tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nvar liftEmptyBlock = function liftEmptyBlock(state, dispatch) {\n  var $cursor = state.selection.$cursor;\n  if (!$cursor || $cursor.parent.content.size) return false;\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    var before = $cursor.before();\n    if (prosemirrorTransform.canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView());\n      return true;\n    }\n  }\n  var range = $cursor.blockRange(),\n    target = range && prosemirrorTransform.liftTarget(range);\n  if (target == null) return false;\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n  return true;\n};\nfunction splitBlockAs(splitNode) {\n  return function (state, dispatch) {\n    var _state$selection6 = state.selection,\n      $from = _state$selection6.$from,\n      $to = _state$selection6.$to;\n    if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.isBlock) {\n      if (!$from.parentOffset || !prosemirrorTransform.canSplit(state.doc, $from.pos)) return false;\n      if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());\n      return true;\n    }\n    if (!$from.depth) return false;\n    var types = [];\n    var splitDepth,\n      deflt,\n      atEnd = false,\n      atStart = false;\n    for (var d = $from.depth;; d--) {\n      var node = $from.node(d);\n      if (node.isBlock) {\n        atEnd = $from.end(d) == $from.pos + ($from.depth - d);\n        atStart = $from.start(d) == $from.pos - ($from.depth - d);\n        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));\n        var splitType = splitNode && splitNode($to.parent, atEnd, $from);\n        types.unshift(splitType || (atEnd && deflt ? {\n          type: deflt\n        } : null));\n        splitDepth = d;\n        break;\n      } else {\n        if (d == 1) return false;\n        types.unshift(null);\n      }\n    }\n    var tr = state.tr;\n    if (state.selection instanceof prosemirrorState.TextSelection || state.selection instanceof prosemirrorState.AllSelection) tr.deleteSelection();\n    var splitPos = tr.mapping.map($from.pos);\n    var can = prosemirrorTransform.canSplit(tr.doc, splitPos, types.length, types);\n    if (!can) {\n      types[0] = deflt ? {\n        type: deflt\n      } : null;\n      can = prosemirrorTransform.canSplit(tr.doc, splitPos, types.length, types);\n    }\n    if (!can) return false;\n    tr.split(splitPos, types.length, types);\n    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {\n      var first = tr.mapping.map($from.before(splitDepth)),\n        $first = tr.doc.resolve(first);\n      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);\n    }\n    if (dispatch) dispatch(tr.scrollIntoView());\n    return true;\n  };\n}\nvar splitBlock = splitBlockAs();\nvar splitBlockKeepMarks = function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && function (tr) {\n    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n    if (marks) tr.ensureMarks(marks);\n    dispatch(tr);\n  });\n};\nvar selectParentNode = function selectParentNode(state, dispatch) {\n  var _state$selection7 = state.selection,\n    $from = _state$selection7.$from,\n    to = _state$selection7.to,\n    pos;\n  var same = $from.sharedDepth(to);\n  if (same == 0) return false;\n  pos = $from.before(same);\n  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, pos)));\n  return true;\n};\nvar selectAll = function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new prosemirrorState.AllSelection(state.doc)));\n  return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n  var before = $pos.nodeBefore,\n    after = $pos.nodeAfter,\n    index = $pos.index();\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false;\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr[\"delete\"]($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n    return true;\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || prosemirrorTransform.canJoin(state.doc, $pos.pos))) return false;\n  if (dispatch) dispatch(state.tr.join($pos.pos).scrollIntoView());\n  return true;\n}\nfunction deleteBarrier(state, $cut, dispatch, dir) {\n  var before = $cut.nodeBefore,\n    after = $cut.nodeAfter,\n    conn,\n    match;\n  var isolated = before.type.spec.isolating || after.type.spec.isolating;\n  if (!isolated && joinMaybeClear(state, $cut, dispatch)) return true;\n  var canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      var end = $cut.pos + after.nodeSize,\n        wrap = prosemirrorModel.Fragment.empty;\n      for (var i = conn.length - 1; i >= 0; i--) wrap = prosemirrorModel.Fragment.from(conn[i].create(null, wrap));\n      wrap = prosemirrorModel.Fragment.from(before.copy(wrap));\n      var tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirrorModel.Slice(wrap, 1, 0), conn.length, true));\n      var $joinAt = tr.doc.resolve(end + 2 * conn.length);\n      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && prosemirrorTransform.canJoin(tr.doc, $joinAt.pos)) tr.join($joinAt.pos);\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  }\n  var selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : prosemirrorState.Selection.findFrom($cut, 1);\n  var range = selAfter && selAfter.$from.blockRange(selAfter.$to),\n    target = range && prosemirrorTransform.liftTarget(range);\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    var at = before,\n      _wrap = [];\n    for (;;) {\n      _wrap.push(at);\n      if (at.isTextblock) break;\n      at = at.lastChild;\n    }\n    var afterText = after,\n      afterDepth = 1;\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++;\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        var _end = prosemirrorModel.Fragment.empty;\n        for (var _i = _wrap.length - 1; _i >= 0; _i--) _end = prosemirrorModel.Fragment.from(_wrap[_i].copy(_end));\n        var _tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - _wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirrorModel.Slice(_end, _wrap.length, 0), 0, true));\n        dispatch(_tr.scrollIntoView());\n      }\n      return true;\n    }\n  }\n  return false;\n}\nfunction selectTextblockSide(side) {\n  return function (state, dispatch) {\n    var sel = state.selection,\n      $pos = side < 0 ? sel.$from : sel.$to;\n    var depth = $pos.depth;\n    while ($pos.node(depth).isInline) {\n      if (!depth) return false;\n      depth--;\n    }\n    if (!$pos.node(depth).isTextblock) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n    return true;\n  };\n}\nvar selectTextblockStart = selectTextblockSide(-1);\nvar selectTextblockEnd = selectTextblockSide(1);\nfunction wrapIn(nodeType) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    var _state$selection8 = state.selection,\n      $from = _state$selection8.$from,\n      $to = _state$selection8.$to;\n    var range = $from.blockRange($to),\n      wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);\n    if (!wrapping) return false;\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n    return true;\n  };\n}\nfunction setBlockType(nodeType) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    var applicable = false;\n    for (var i = 0; i < state.selection.ranges.length && !applicable; i++) {\n      var _state$selection$rang = state.selection.ranges[i],\n        from = _state$selection$rang.$from.pos,\n        to = _state$selection$rang.$to.pos;\n      state.doc.nodesBetween(from, to, function (node, pos) {\n        if (applicable) return false;\n        if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;\n        if (node.type == nodeType) {\n          applicable = true;\n        } else {\n          var $pos = state.doc.resolve(pos),\n            index = $pos.index();\n          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n        }\n      });\n    }\n    if (!applicable) return false;\n    if (dispatch) {\n      var tr = state.tr;\n      for (var _i2 = 0; _i2 < state.selection.ranges.length; _i2++) {\n        var _state$selection$rang2 = state.selection.ranges[_i2],\n          _from = _state$selection$rang2.$from.pos,\n          _to = _state$selection$rang2.$to.pos;\n        tr.setBlockType(_from, _to, nodeType, attrs);\n      }\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  };\n}\nfunction markApplies(doc, ranges, type, enterAtoms) {\n  var _loop = function _loop() {\n      var _ranges$i = ranges[i],\n        $from = _ranges$i.$from,\n        $to = _ranges$i.$to;\n      var can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n      doc.nodesBetween($from.pos, $to.pos, function (node, pos) {\n        if (can || !enterAtoms && node.isAtom && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) return false;\n        can = node.inlineContent && node.type.allowsMarkType(type);\n      });\n      if (can) return {\n        v: true\n      };\n    },\n    _ret;\n  for (var i = 0; i < ranges.length; i++) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n  return false;\n}\nfunction removeInlineAtoms(ranges) {\n  var result = [];\n  var _loop2 = function _loop2() {\n    var _ranges$i2 = ranges[i],\n      $from = _ranges$i2.$from,\n      $to = _ranges$i2.$to;\n    $from.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {\n      if (node.isAtom && node.content.size && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) {\n        if (pos + 1 > $from.pos) result.push(new prosemirrorState.SelectionRange($from, $from.doc.resolve(pos + 1)));\n        $from = $from.doc.resolve(pos + 1 + node.content.size);\n        return false;\n      }\n    });\n    if ($from.pos < $to.pos) result.push(new prosemirrorState.SelectionRange($from, $to));\n  };\n  for (var i = 0; i < ranges.length; i++) {\n    _loop2();\n  }\n  return result;\n}\nfunction toggleMark(markType) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n  var removeWhenPresent = (options && options.removeWhenPresent) !== false;\n  var enterAtoms = (options && options.enterInlineAtoms) !== false;\n  var dropSpace = !(options && options.includeWhitespace);\n  return function (state, dispatch) {\n    var _state$selection9 = state.selection,\n      empty = _state$selection9.empty,\n      $cursor = _state$selection9.$cursor,\n      ranges = _state$selection9.ranges;\n    if (empty && !$cursor || !markApplies(state.doc, ranges, markType, enterAtoms)) return false;\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));else dispatch(state.tr.addStoredMark(markType.create(attrs)));\n      } else {\n        var add,\n          tr = state.tr;\n        if (!enterAtoms) ranges = removeInlineAtoms(ranges);\n        if (removeWhenPresent) {\n          add = !ranges.some(function (r) {\n            return state.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType);\n          });\n        } else {\n          add = !ranges.every(function (r) {\n            var missing = false;\n            tr.doc.nodesBetween(r.$from.pos, r.$to.pos, function (node, pos, parent) {\n              if (missing) return false;\n              missing = !markType.isInSet(node.marks) && !!parent && parent.type.allowsMarkType(markType) && !(node.isText && /^\\s*$/.test(node.textBetween(Math.max(0, r.$from.pos - pos), Math.min(node.nodeSize, r.$to.pos - pos))));\n            });\n            return !missing;\n          });\n        }\n        for (var i = 0; i < ranges.length; i++) {\n          var _ranges$i3 = ranges[i],\n            $from = _ranges$i3.$from,\n            $to = _ranges$i3.$to;\n          if (!add) {\n            tr.removeMark($from.pos, $to.pos, markType);\n          } else {\n            var from = $from.pos,\n              to = $to.pos,\n              start = $from.nodeAfter,\n              end = $to.nodeBefore;\n            var spaceStart = dropSpace && start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n            var spaceEnd = dropSpace && end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n            if (from + spaceStart < to) {\n              from += spaceStart;\n              to -= spaceEnd;\n            }\n            tr.addMark(from, to, markType.create(attrs));\n          }\n        }\n        dispatch(tr.scrollIntoView());\n      }\n    }\n    return true;\n  };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return function (tr) {\n    if (!tr.isGeneric) return dispatch(tr);\n    var ranges = [];\n    for (var i = 0; i < tr.mapping.maps.length; i++) {\n      var map = tr.mapping.maps[i];\n      for (var j = 0; j < ranges.length; j++) ranges[j] = map.map(ranges[j]);\n      map.forEach(function (_s, _e, from, to) {\n        return ranges.push(from, to);\n      });\n    }\n    var joinable = [];\n    for (var _i3 = 0; _i3 < ranges.length; _i3 += 2) {\n      var from = ranges[_i3],\n        to = ranges[_i3 + 1];\n      var $from = tr.doc.resolve(from),\n        depth = $from.sharedDepth(to),\n        parent = $from.node(depth);\n      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        var after = parent.maybeChild(index);\n        if (!after) break;\n        if (index && joinable.indexOf(pos) == -1) {\n          var before = parent.child(index - 1);\n          if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);\n        }\n        pos += after.nodeSize;\n      }\n    }\n    joinable.sort(function (a, b) {\n      return a - b;\n    });\n    for (var _i4 = joinable.length - 1; _i4 >= 0; _i4--) {\n      if (prosemirrorTransform.canJoin(tr.doc, joinable[_i4])) tr.join(joinable[_i4]);\n    }\n    dispatch(tr);\n  };\n}\nfunction autoJoin(command, isJoinable) {\n  var canJoin = Array.isArray(isJoinable) ? function (node) {\n    return isJoinable.indexOf(node.type.name) > -1;\n  } : isJoinable;\n  return function (state, dispatch, view) {\n    return command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n  };\n}\nfunction chainCommands() {\n  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {\n    commands[_key] = arguments[_key];\n  }\n  return function (state, dispatch, view) {\n    for (var i = 0; i < commands.length; i++) if (commands[i](state, dispatch, view)) return true;\n    return false;\n  };\n}\nvar backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nvar del = chainCommands(deleteSelection, joinForward, selectNodeForward);\nvar pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n};\nvar macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n};\nfor (var key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key];\nvar mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\nvar baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\nexports.autoJoin = autoJoin;\nexports.baseKeymap = baseKeymap;\nexports.chainCommands = chainCommands;\nexports.createParagraphNear = createParagraphNear;\nexports.deleteSelection = deleteSelection;\nexports.exitCode = exitCode;\nexports.joinBackward = joinBackward;\nexports.joinDown = joinDown;\nexports.joinForward = joinForward;\nexports.joinTextblockBackward = joinTextblockBackward;\nexports.joinTextblockForward = joinTextblockForward;\nexports.joinUp = joinUp;\nexports.lift = lift;\nexports.liftEmptyBlock = liftEmptyBlock;\nexports.macBaseKeymap = macBaseKeymap;\nexports.newlineInCode = newlineInCode;\nexports.pcBaseKeymap = pcBaseKeymap;\nexports.selectAll = selectAll;\nexports.selectNodeBackward = selectNodeBackward;\nexports.selectNodeForward = selectNodeForward;\nexports.selectParentNode = selectParentNode;\nexports.selectTextblockEnd = selectTextblockEnd;\nexports.selectTextblockStart = selectTextblockStart;\nexports.setBlockType = setBlockType;\nexports.splitBlock = splitBlock;\nexports.splitBlockAs = splitBlockAs;\nexports.splitBlockKeepMarks = splitBlockKeepMarks;\nexports.toggleMark = toggleMark;\nexports.wrapIn = wrapIn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLWNvbW1hbmRzQDEuNy4xL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyw0SUFBdUI7QUFDMUQsdUJBQXVCLG1CQUFPLENBQUMsZ0lBQW1CO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLCtIQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBa0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLGNBQWM7QUFDZCxZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQixrQkFBa0I7QUFDbEIsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL0Vib290aC9hZ2VudF9jX2ZyYW1ld29yay9zcmMvcmVhbHRpbWVfY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9wcm9zZW1pcnJvci1jb21tYW5kc0AxLjcuMS9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJvc2VtaXJyb3JUcmFuc2Zvcm0gPSByZXF1aXJlKCdwcm9zZW1pcnJvci10cmFuc2Zvcm0nKTtcbnZhciBwcm9zZW1pcnJvck1vZGVsID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItbW9kZWwnKTtcbnZhciBwcm9zZW1pcnJvclN0YXRlID0gcmVxdWlyZSgncHJvc2VtaXJyb3Itc3RhdGUnKTtcbnZhciBkZWxldGVTZWxlY3Rpb24gPSBmdW5jdGlvbiBkZWxldGVTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KSB7XG4gIHZhciAkY3Vyc29yID0gc3RhdGUuc2VsZWN0aW9uLiRjdXJzb3I7XG4gIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPiAwKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiAkY3Vyc29yO1xufVxudmFyIGpvaW5CYWNrd2FyZCA9IGZ1bmN0aW9uIGpvaW5CYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICBpZiAoISRjdXJzb3IpIHJldHVybiBmYWxzZTtcbiAgdmFyICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICBpZiAoISRjdXQpIHtcbiAgICB2YXIgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSxcbiAgICAgIHRhcmdldCA9IHJhbmdlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlO1xuICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gsIC0xKSkgcmV0dXJuIHRydWU7XG4gIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAodGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSB8fCBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgZm9yICh2YXIgZGVwdGggPSAkY3Vyc29yLmRlcHRoOzsgZGVwdGgtLSkge1xuICAgICAgdmFyIGRlbFN0ZXAgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5yZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKGRlcHRoKSwgJGN1cnNvci5hZnRlcihkZXB0aCksIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkpO1xuICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICB2YXIgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpID8gcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MsIC0xKSksIC0xKSA6IHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlcHRoID09IDEgfHwgJGN1cnNvci5ub2RlKGRlcHRoIC0gMSkuY2hpbGRDb3VudCA+IDEpIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoYmVmb3JlLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50cltcImRlbGV0ZVwiXSgkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJGN1dC5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgam9pblRleHRibG9ja0JhY2t3YXJkID0gZnVuY3Rpb24gam9pblRleHRibG9ja0JhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICB2YXIgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gIGlmICghJGN1cnNvcikgcmV0dXJuIGZhbHNlO1xuICB2YXIgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbnZhciBqb2luVGV4dGJsb2NrRm9yd2FyZCA9IGZ1bmN0aW9uIGpvaW5UZXh0YmxvY2tGb3J3YXJkKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICB2YXIgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICBpZiAoISRjdXJzb3IpIHJldHVybiBmYWxzZTtcbiAgdmFyICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICB2YXIgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLFxuICAgIGJlZm9yZVRleHQgPSBiZWZvcmUsXG4gICAgYmVmb3JlUG9zID0gJGN1dC5wb3MgLSAxO1xuICBmb3IgKDsgIWJlZm9yZVRleHQuaXNUZXh0YmxvY2s7IGJlZm9yZVBvcy0tKSB7XG4gICAgaWYgKGJlZm9yZVRleHQudHlwZS5zcGVjLmlzb2xhdGluZykgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBjaGlsZCA9IGJlZm9yZVRleHQubGFzdENoaWxkO1xuICAgIGlmICghY2hpbGQpIHJldHVybiBmYWxzZTtcbiAgICBiZWZvcmVUZXh0ID0gY2hpbGQ7XG4gIH1cbiAgdmFyIGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsXG4gICAgYWZ0ZXJUZXh0ID0gYWZ0ZXIsXG4gICAgYWZ0ZXJQb3MgPSAkY3V0LnBvcyArIDE7XG4gIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclBvcysrKSB7XG4gICAgaWYgKGFmdGVyVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIF9jaGlsZCA9IGFmdGVyVGV4dC5maXJzdENoaWxkO1xuICAgIGlmICghX2NoaWxkKSByZXR1cm4gZmFsc2U7XG4gICAgYWZ0ZXJUZXh0ID0gX2NoaWxkO1xuICB9XG4gIHZhciBzdGVwID0gcHJvc2VtaXJyb3JUcmFuc2Zvcm0ucmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCBiZWZvcmVQb3MsIGFmdGVyUG9zLCBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5KTtcbiAgaWYgKCFzdGVwIHx8IHN0ZXAuZnJvbSAhPSBiZWZvcmVQb3MgfHwgc3RlcCBpbnN0YW5jZW9mIHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VTdGVwICYmIHN0ZXAuc2xpY2Uuc2l6ZSA+PSBhZnRlclBvcyAtIGJlZm9yZVBvcykgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB2YXIgdHIgPSBzdGF0ZS50ci5zdGVwKHN0ZXApO1xuICAgIHRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYmVmb3JlUG9zKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0ZXh0YmxvY2tBdChub2RlLCBzaWRlKSB7XG4gIHZhciBvbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgZm9yICh2YXIgc2NhbiA9IG5vZGU7IHNjYW47IHNjYW4gPSBzaWRlID09IFwic3RhcnRcIiA/IHNjYW4uZmlyc3RDaGlsZCA6IHNjYW4ubGFzdENoaWxkKSB7XG4gICAgaWYgKHNjYW4uaXNUZXh0YmxvY2spIHJldHVybiB0cnVlO1xuICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIHNlbGVjdE5vZGVCYWNrd2FyZCA9IGZ1bmN0aW9uIHNlbGVjdE5vZGVCYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgJGhlYWQgPSBfc3RhdGUkc2VsZWN0aW9uLiRoZWFkLFxuICAgIGVtcHR5ID0gX3N0YXRlJHNlbGVjdGlvbi5lbXB0eSxcbiAgICAkY3V0ID0gJGhlYWQ7XG4gIGlmICghZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICB9XG4gIHZhciBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVCZWZvcmU7XG4gIGlmICghbm9kZSB8fCAhcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MgLSBub2RlLm5vZGVTaXplKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRCZWZvcmUoJHBvcykge1xuICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIGZvciAodmFyIGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoJHBvcy5pbmRleChpKSA+IDApIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSk7XG4gICAgaWYgKCRwb3Mubm9kZShpKS50eXBlLnNwZWMuaXNvbGF0aW5nKSBicmVhaztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpIHtcbiAgdmFyICRjdXJzb3IgPSBzdGF0ZS5zZWxlY3Rpb24uJGN1cnNvcjtcbiAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKSA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiAkY3Vyc29yO1xufVxudmFyIGpvaW5Gb3J3YXJkID0gZnVuY3Rpb24gam9pbkZvcndhcmQoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gIHZhciAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gIGlmICghJGN1cnNvcikgcmV0dXJuIGZhbHNlO1xuICB2YXIgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgaWYgKCEkY3V0KSByZXR1cm4gZmFsc2U7XG4gIHZhciBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gsIDEpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGFmdGVyKSkpIHtcbiAgICB2YXIgZGVsU3RlcCA9IHByb3NlbWlycm9yVHJhbnNmb3JtLnJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5KTtcbiAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSkgOiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChhZnRlci5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHJbXCJkZWxldGVcIl0oJGN1dC5wb3MsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgc2VsZWN0Tm9kZUZvcndhcmQgPSBmdW5jdGlvbiBzZWxlY3ROb2RlRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24yID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICRoZWFkID0gX3N0YXRlJHNlbGVjdGlvbjIuJGhlYWQsXG4gICAgZW1wdHkgPSBfc3RhdGUkc2VsZWN0aW9uMi5lbXB0eSxcbiAgICAkY3V0ID0gJGhlYWQ7XG4gIGlmICghZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA8ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemUpIHJldHVybiBmYWxzZTtcbiAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgfVxuICB2YXIgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQWZ0ZXI7XG4gIGlmICghbm9kZSB8fCAhcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcmVudCA9ICRwb3Mubm9kZShpKTtcbiAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudCkgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpO1xuICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgam9pblVwID0gZnVuY3Rpb24gam9pblVwKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgc2VsID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24sXG4gICAgcG9pbnQ7XG4gIGlmIChub2RlU2VsKSB7XG4gICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5Kb2luKHN0YXRlLmRvYywgc2VsLmZyb20pKSByZXR1cm4gZmFsc2U7XG4gICAgcG9pbnQgPSBzZWwuZnJvbTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludCA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC5mcm9tLCAtMSk7XG4gICAgaWYgKHBvaW50ID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB2YXIgdHIgPSBzdGF0ZS50ci5qb2luKHBvaW50KTtcbiAgICBpZiAobm9kZVNlbCkgdHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb2ludCAtIHN0YXRlLmRvYy5yZXNvbHZlKHBvaW50KS5ub2RlQmVmb3JlLm5vZGVTaXplKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGpvaW5Eb3duID0gZnVuY3Rpb24gam9pbkRvd24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgcG9pbnQ7XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIXByb3NlbWlycm9yVHJhbnNmb3JtLmNhbkpvaW4oc3RhdGUuZG9jLCBzZWwudG8pKSByZXR1cm4gZmFsc2U7XG4gICAgcG9pbnQgPSBzZWwudG87XG4gIH0gZWxzZSB7XG4gICAgcG9pbnQgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5qb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgIGlmIChwb2ludCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGxpZnQgPSBmdW5jdGlvbiBsaWZ0KHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjMgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uMy4kZnJvbSxcbiAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uMy4kdG87XG4gIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSxcbiAgICB0YXJnZXQgPSByYW5nZSAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5saWZ0VGFyZ2V0KHJhbmdlKTtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIG5ld2xpbmVJbkNvZGUgPSBmdW5jdGlvbiBuZXdsaW5lSW5Db2RlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjQgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgJGhlYWQgPSBfc3RhdGUkc2VsZWN0aW9uNC4kaGVhZCxcbiAgICAkYW5jaG9yID0gX3N0YXRlJHNlbGVjdGlvbjQuJGFuY2hvcjtcbiAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnRUZXh0KFwiXFxuXCIpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgdmFyIF9tYXRjaCRlZGdlID0gbWF0Y2guZWRnZShpKSxcbiAgICAgIHR5cGUgPSBfbWF0Y2gkZWRnZS50eXBlO1xuICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgcmV0dXJuIHR5cGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgZXhpdENvZGUgPSBmdW5jdGlvbiBleGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb241ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICRoZWFkID0gX3N0YXRlJHNlbGVjdGlvbjUuJGhlYWQsXG4gICAgJGFuY2hvciA9IF9zdGF0ZSRzZWxlY3Rpb241LiRhbmNob3I7XG4gIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBhYm92ZSA9ICRoZWFkLm5vZGUoLTEpLFxuICAgIGFmdGVyID0gJGhlYWQuaW5kZXhBZnRlcigtMSksXG4gICAgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gIGlmICghdHlwZSB8fCAhYWJvdmUuY2FuUmVwbGFjZVdpdGgoYWZ0ZXIsIGFmdGVyLCB0eXBlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB2YXIgcG9zID0gJGhlYWQuYWZ0ZXIoKSxcbiAgICAgIHRyID0gc3RhdGUudHIucmVwbGFjZVdpdGgocG9zLCBwb3MsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShwb3MpLCAxKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGNyZWF0ZVBhcmFncmFwaE5lYXIgPSBmdW5jdGlvbiBjcmVhdGVQYXJhZ3JhcGhOZWFyKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgc2VsID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICRmcm9tID0gc2VsLiRmcm9tLFxuICAgICR0byA9IHNlbC4kdG87XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLkFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpIHJldHVybiBmYWxzZTtcbiAgdmFyIHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgaWYgKCF0eXBlIHx8ICF0eXBlLmlzVGV4dGJsb2NrKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHZhciBzaWRlID0gKCEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJHRvLmluZGV4KCkgPCAkdG8ucGFyZW50LmNoaWxkQ291bnQgPyAkZnJvbSA6ICR0bykucG9zO1xuICAgIHZhciB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBzaWRlICsgMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBsaWZ0RW1wdHlCbG9jayA9IGZ1bmN0aW9uIGxpZnRFbXB0eUJsb2NrKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgJGN1cnNvciA9IHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yO1xuICBpZiAoISRjdXJzb3IgfHwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSByZXR1cm4gZmFsc2U7XG4gIGlmICgkY3Vyc29yLmRlcHRoID4gMSAmJiAkY3Vyc29yLmFmdGVyKCkgIT0gJGN1cnNvci5lbmQoLTEpKSB7XG4gICAgdmFyIGJlZm9yZSA9ICRjdXJzb3IuYmVmb3JlKCk7XG4gICAgaWYgKHByb3NlbWlycm9yVHJhbnNmb3JtLmNhblNwbGl0KHN0YXRlLmRvYywgYmVmb3JlKSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdChiZWZvcmUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHZhciByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLFxuICAgIHRhcmdldCA9IHJhbmdlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmxpZnRUYXJnZXQocmFuZ2UpO1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBzcGxpdEJsb2NrQXMoc3BsaXROb2RlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb242ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uNi4kZnJvbSxcbiAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb242LiR0bztcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uICYmIHN0YXRlLnNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5TcGxpdChzdGF0ZS5kb2MsICRmcm9tLnBvcykpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRmcm9tLmRlcHRoKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgdmFyIHNwbGl0RGVwdGgsXG4gICAgICBkZWZsdCxcbiAgICAgIGF0RW5kID0gZmFsc2UsXG4gICAgICBhdFN0YXJ0ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgZCA9ICRmcm9tLmRlcHRoOzsgZC0tKSB7XG4gICAgICB2YXIgbm9kZSA9ICRmcm9tLm5vZGUoZCk7XG4gICAgICBpZiAobm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgIGF0RW5kID0gJGZyb20uZW5kKGQpID09ICRmcm9tLnBvcyArICgkZnJvbS5kZXB0aCAtIGQpO1xuICAgICAgICBhdFN0YXJ0ID0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCk7XG4gICAgICAgIGRlZmx0ID0gZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZShkIC0gMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihkIC0gMSkpKTtcbiAgICAgICAgdmFyIHNwbGl0VHlwZSA9IHNwbGl0Tm9kZSAmJiBzcGxpdE5vZGUoJHRvLnBhcmVudCwgYXRFbmQsICRmcm9tKTtcbiAgICAgICAgdHlwZXMudW5zaGlmdChzcGxpdFR5cGUgfHwgKGF0RW5kICYmIGRlZmx0ID8ge1xuICAgICAgICAgIHR5cGU6IGRlZmx0XG4gICAgICAgIH0gOiBudWxsKSk7XG4gICAgICAgIHNwbGl0RGVwdGggPSBkO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkID09IDEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdHlwZXMudW5zaGlmdChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRyID0gc3RhdGUudHI7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLkFsbFNlbGVjdGlvbikgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgdmFyIHNwbGl0UG9zID0gdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKTtcbiAgICB2YXIgY2FuID0gcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgdHlwZXMubGVuZ3RoLCB0eXBlcyk7XG4gICAgaWYgKCFjYW4pIHtcbiAgICAgIHR5cGVzWzBdID0gZGVmbHQgPyB7XG4gICAgICAgIHR5cGU6IGRlZmx0XG4gICAgICB9IDogbnVsbDtcbiAgICAgIGNhbiA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHR5cGVzLmxlbmd0aCwgdHlwZXMpO1xuICAgIH1cbiAgICBpZiAoIWNhbikgcmV0dXJuIGZhbHNlO1xuICAgIHRyLnNwbGl0KHNwbGl0UG9zLCB0eXBlcy5sZW5ndGgsIHR5cGVzKTtcbiAgICBpZiAoIWF0RW5kICYmIGF0U3RhcnQgJiYgJGZyb20ubm9kZShzcGxpdERlcHRoKS50eXBlICE9IGRlZmx0KSB7XG4gICAgICB2YXIgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoc3BsaXREZXB0aCkpLFxuICAgICAgICAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICBpZiAoZGVmbHQgJiYgJGZyb20ubm9kZShzcGxpdERlcHRoIC0gMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKSB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZShzcGxpdERlcHRoKSksIGRlZmx0KTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbnZhciBzcGxpdEJsb2NrID0gc3BsaXRCbG9ja0FzKCk7XG52YXIgc3BsaXRCbG9ja0tlZXBNYXJrcyA9IGZ1bmN0aW9uIHNwbGl0QmxvY2tLZWVwTWFya3Moc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBzcGxpdEJsb2NrKHN0YXRlLCBkaXNwYXRjaCAmJiBmdW5jdGlvbiAodHIpIHtcbiAgICB2YXIgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICBpZiAobWFya3MpIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICBkaXNwYXRjaCh0cik7XG4gIH0pO1xufTtcbnZhciBzZWxlY3RQYXJlbnROb2RlID0gZnVuY3Rpb24gc2VsZWN0UGFyZW50Tm9kZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb243ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjcuJGZyb20sXG4gICAgdG8gPSBfc3RhdGUkc2VsZWN0aW9uNy50byxcbiAgICBwb3M7XG4gIHZhciBzYW1lID0gJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICBpZiAoc2FtZSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gIHBvcyA9ICRmcm9tLmJlZm9yZShzYW1lKTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHBvcykpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHNlbGVjdEFsbCA9IGZ1bmN0aW9uIHNlbGVjdEFsbChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IHByb3NlbWlycm9yU3RhdGUuQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gam9pbk1heWJlQ2xlYXIoc3RhdGUsICRwb3MsIGRpc3BhdGNoKSB7XG4gIHZhciBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsXG4gICAgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcixcbiAgICBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8ICFiZWZvcmUudHlwZS5jb21wYXRpYmxlQ29udGVudChhZnRlci50eXBlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWJlZm9yZS5jb250ZW50LnNpemUgJiYgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCAtIDEsIGluZGV4KSkge1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHJbXCJkZWxldGVcIl0oJHBvcy5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRwb3MucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoISRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkgfHwgIShhZnRlci5pc1RleHRibG9jayB8fCBwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5Kb2luKHN0YXRlLmRvYywgJHBvcy5wb3MpKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLmpvaW4oJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoLCBkaXIpIHtcbiAgdmFyIGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSxcbiAgICBhZnRlciA9ICRjdXQubm9kZUFmdGVyLFxuICAgIGNvbm4sXG4gICAgbWF0Y2g7XG4gIHZhciBpc29sYXRlZCA9IGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmc7XG4gIGlmICghaXNvbGF0ZWQgJiYgam9pbk1heWJlQ2xlYXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSkgcmV0dXJuIHRydWU7XG4gIHZhciBjYW5EZWxBZnRlciA9ICFpc29sYXRlZCAmJiAkY3V0LnBhcmVudC5jYW5SZXBsYWNlKCRjdXQuaW5kZXgoKSwgJGN1dC5pbmRleCgpICsgMSk7XG4gIGlmIChjYW5EZWxBZnRlciAmJiAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiYgbWF0Y2gubWF0Y2hUeXBlKGNvbm5bMF0gfHwgYWZ0ZXIudHlwZSkudmFsaWRFbmQpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHZhciBlbmQgPSAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLFxuICAgICAgICB3cmFwID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcbiAgICAgIGZvciAodmFyIGkgPSBjb25uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB3cmFwID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGNvbm5baV0uY3JlYXRlKG51bGwsIHdyYXApKTtcbiAgICAgIHdyYXAgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgdmFyIHRyID0gc3RhdGUudHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHdyYXAsIDEsIDApLCBjb25uLmxlbmd0aCwgdHJ1ZSkpO1xuICAgICAgdmFyICRqb2luQXQgPSB0ci5kb2MucmVzb2x2ZShlbmQgKyAyICogY29ubi5sZW5ndGgpO1xuICAgICAgaWYgKCRqb2luQXQubm9kZUFmdGVyICYmICRqb2luQXQubm9kZUFmdGVyLnR5cGUgPT0gYmVmb3JlLnR5cGUgJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuSm9pbih0ci5kb2MsICRqb2luQXQucG9zKSkgdHIuam9pbigkam9pbkF0LnBvcyk7XG4gICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHNlbEFmdGVyID0gYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZyB8fCBkaXIgPiAwICYmIGlzb2xhdGVkID8gbnVsbCA6IHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uLmZpbmRGcm9tKCRjdXQsIDEpO1xuICB2YXIgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksXG4gICAgdGFyZ2V0ID0gcmFuZ2UgJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0ubGlmdFRhcmdldChyYW5nZSk7XG4gIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQgPj0gJGN1dC5kZXB0aCkge1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY2FuRGVsQWZ0ZXIgJiYgdGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIiwgdHJ1ZSkgJiYgdGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSkge1xuICAgIHZhciBhdCA9IGJlZm9yZSxcbiAgICAgIF93cmFwID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgX3dyYXAucHVzaChhdCk7XG4gICAgICBpZiAoYXQuaXNUZXh0YmxvY2spIGJyZWFrO1xuICAgICAgYXQgPSBhdC5sYXN0Q2hpbGQ7XG4gICAgfVxuICAgIHZhciBhZnRlclRleHQgPSBhZnRlcixcbiAgICAgIGFmdGVyRGVwdGggPSAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclRleHQgPSBhZnRlclRleHQuZmlyc3RDaGlsZCkgYWZ0ZXJEZXB0aCsrO1xuICAgIGlmIChhdC5jYW5SZXBsYWNlKGF0LmNoaWxkQ291bnQsIGF0LmNoaWxkQ291bnQsIGFmdGVyVGV4dC5jb250ZW50KSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciBfZW5kID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSBfd3JhcC5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSBfZW5kID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKF93cmFwW19pXS5jb3B5KF9lbmQpKTtcbiAgICAgICAgdmFyIF90ciA9IHN0YXRlLnRyLnN0ZXAobmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gX3dyYXAubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShfZW5kLCBfd3JhcC5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgIGRpc3BhdGNoKF90ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUZXh0YmxvY2tTaWRlKHNpZGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgc2VsID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJHBvcyA9IHNpZGUgPCAwID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICB2YXIgZGVwdGggPSAkcG9zLmRlcHRoO1xuICAgIHdoaWxlICgkcG9zLm5vZGUoZGVwdGgpLmlzSW5saW5lKSB7XG4gICAgICBpZiAoIWRlcHRoKSByZXR1cm4gZmFsc2U7XG4gICAgICBkZXB0aC0tO1xuICAgIH1cbiAgICBpZiAoISRwb3Mubm9kZShkZXB0aCkuaXNUZXh0YmxvY2spIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgc2lkZSA8IDAgPyAkcG9zLnN0YXJ0KGRlcHRoKSA6ICRwb3MuZW5kKGRlcHRoKSkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbnZhciBzZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1NpZGUoLTEpO1xudmFyIHNlbGVjdFRleHRibG9ja0VuZCA9IHNlbGVjdFRleHRibG9ja1NpZGUoMSk7XG5mdW5jdGlvbiB3cmFwSW4obm9kZVR5cGUpIHtcbiAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uOCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjguJGZyb20sXG4gICAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uOC4kdG87XG4gICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLFxuICAgICAgd3JhcHBpbmcgPSByYW5nZSAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5maW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgaWYgKCF3cmFwcGluZykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIud3JhcChyYW5nZSwgd3JhcHBpbmcpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKG5vZGVUeXBlKSB7XG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgYXBwbGljYWJsZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggJiYgIWFwcGxpY2FibGU7IGkrKykge1xuICAgICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24kcmFuZyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV0sXG4gICAgICAgIGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uJHJhbmcuJGZyb20ucG9zLFxuICAgICAgICB0byA9IF9zdGF0ZSRzZWxlY3Rpb24kcmFuZy4kdG8ucG9zO1xuICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgICAgICBpZiAoYXBwbGljYWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS5oYXNNYXJrdXAobm9kZVR5cGUsIGF0dHJzKSkgcmV0dXJuO1xuICAgICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgICAgYXBwbGljYWJsZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLFxuICAgICAgICAgICAgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghYXBwbGljYWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgdmFyIHRyID0gc3RhdGUudHI7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24kcmFuZzIgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW19pMl0sXG4gICAgICAgICAgX2Zyb20gPSBfc3RhdGUkc2VsZWN0aW9uJHJhbmcyLiRmcm9tLnBvcyxcbiAgICAgICAgICBfdG8gPSBfc3RhdGUkc2VsZWN0aW9uJHJhbmcyLiR0by5wb3M7XG4gICAgICAgIHRyLnNldEJsb2NrVHlwZShfZnJvbSwgX3RvLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gbWFya0FwcGxpZXMoZG9jLCByYW5nZXMsIHR5cGUsIGVudGVyQXRvbXMpIHtcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgX3JhbmdlcyRpID0gcmFuZ2VzW2ldLFxuICAgICAgICAkZnJvbSA9IF9yYW5nZXMkaS4kZnJvbSxcbiAgICAgICAgJHRvID0gX3JhbmdlcyRpLiR0bztcbiAgICAgIHZhciBjYW4gPSAkZnJvbS5kZXB0aCA9PSAwID8gZG9jLmlubGluZUNvbnRlbnQgJiYgZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSkgOiBmYWxzZTtcbiAgICAgIGRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICAgIGlmIChjYW4gfHwgIWVudGVyQXRvbXMgJiYgbm9kZS5pc0F0b20gJiYgbm9kZS5pc0lubGluZSAmJiBwb3MgPj0gJGZyb20ucG9zICYmIHBvcyArIG5vZGUubm9kZVNpemUgPD0gJHRvLnBvcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgICAgfSk7XG4gICAgICBpZiAoY2FuKSByZXR1cm4ge1xuICAgICAgICB2OiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgX3JldDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICBpZiAoX3JldCkgcmV0dXJuIF9yZXQudjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZW1vdmVJbmxpbmVBdG9tcyhyYW5nZXMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgIHZhciBfcmFuZ2VzJGkyID0gcmFuZ2VzW2ldLFxuICAgICAgJGZyb20gPSBfcmFuZ2VzJGkyLiRmcm9tLFxuICAgICAgJHRvID0gX3JhbmdlcyRpMi4kdG87XG4gICAgJGZyb20uZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICAgIGlmIChub2RlLmlzQXRvbSAmJiBub2RlLmNvbnRlbnQuc2l6ZSAmJiBub2RlLmlzSW5saW5lICYmIHBvcyA+PSAkZnJvbS5wb3MgJiYgcG9zICsgbm9kZS5ub2RlU2l6ZSA8PSAkdG8ucG9zKSB7XG4gICAgICAgIGlmIChwb3MgKyAxID4gJGZyb20ucG9zKSByZXN1bHQucHVzaChuZXcgcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb25SYW5nZSgkZnJvbSwgJGZyb20uZG9jLnJlc29sdmUocG9zICsgMSkpKTtcbiAgICAgICAgJGZyb20gPSAkZnJvbS5kb2MucmVzb2x2ZShwb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCRmcm9tLnBvcyA8ICR0by5wb3MpIHJlc3VsdC5wdXNoKG5ldyBwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvblJhbmdlKCRmcm9tLCAkdG8pKTtcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBfbG9vcDIoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9nZ2xlTWFyayhtYXJrVHlwZSkge1xuICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciByZW1vdmVXaGVuUHJlc2VudCA9IChvcHRpb25zICYmIG9wdGlvbnMucmVtb3ZlV2hlblByZXNlbnQpICE9PSBmYWxzZTtcbiAgdmFyIGVudGVyQXRvbXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLmVudGVySW5saW5lQXRvbXMpICE9PSBmYWxzZTtcbiAgdmFyIGRyb3BTcGFjZSA9ICEob3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVXaGl0ZXNwYWNlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbjkgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICBlbXB0eSA9IF9zdGF0ZSRzZWxlY3Rpb245LmVtcHR5LFxuICAgICAgJGN1cnNvciA9IF9zdGF0ZSRzZWxlY3Rpb245LiRjdXJzb3IsXG4gICAgICByYW5nZXMgPSBfc3RhdGUkc2VsZWN0aW9uOS5yYW5nZXM7XG4gICAgaWYgKGVtcHR5ICYmICEkY3Vyc29yIHx8ICFtYXJrQXBwbGllcyhzdGF0ZS5kb2MsIHJhbmdlcywgbWFya1R5cGUsIGVudGVyQXRvbXMpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICBpZiAobWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkY3Vyc29yLm1hcmtzKCkpKSBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7ZWxzZSBkaXNwYXRjaChzdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZShhdHRycykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhZGQsXG4gICAgICAgICAgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgaWYgKCFlbnRlckF0b21zKSByYW5nZXMgPSByZW1vdmVJbmxpbmVBdG9tcyhyYW5nZXMpO1xuICAgICAgICBpZiAocmVtb3ZlV2hlblByZXNlbnQpIHtcbiAgICAgICAgICBhZGQgPSAhcmFuZ2VzLnNvbWUoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKHIuJGZyb20ucG9zLCByLiR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGQgPSAhcmFuZ2VzLmV2ZXJ5KGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICB2YXIgbWlzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihyLiRmcm9tLnBvcywgci4kdG8ucG9zLCBmdW5jdGlvbiAobm9kZSwgcG9zLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKG1pc3NpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgbWlzc2luZyA9ICFtYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpICYmICEhcGFyZW50ICYmIHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSAmJiAhKG5vZGUuaXNUZXh0ICYmIC9eXFxzKiQvLnRlc3Qobm9kZS50ZXh0QmV0d2VlbihNYXRoLm1heCgwLCByLiRmcm9tLnBvcyAtIHBvcyksIE1hdGgubWluKG5vZGUubm9kZVNpemUsIHIuJHRvLnBvcyAtIHBvcykpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhbWlzc2luZztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfcmFuZ2VzJGkzID0gcmFuZ2VzW2ldLFxuICAgICAgICAgICAgJGZyb20gPSBfcmFuZ2VzJGkzLiRmcm9tLFxuICAgICAgICAgICAgJHRvID0gX3JhbmdlcyRpMy4kdG87XG4gICAgICAgICAgaWYgKCFhZGQpIHtcbiAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gJGZyb20ucG9zLFxuICAgICAgICAgICAgICB0byA9ICR0by5wb3MsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gJGZyb20ubm9kZUFmdGVyLFxuICAgICAgICAgICAgICBlbmQgPSAkdG8ubm9kZUJlZm9yZTtcbiAgICAgICAgICAgIHZhciBzcGFjZVN0YXJ0ID0gZHJvcFNwYWNlICYmIHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgdmFyIHNwYWNlRW5kID0gZHJvcFNwYWNlICYmIGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgaWYgKGZyb20gKyBzcGFjZVN0YXJ0IDwgdG8pIHtcbiAgICAgICAgICAgICAgZnJvbSArPSBzcGFjZVN0YXJ0O1xuICAgICAgICAgICAgICB0byAtPSBzcGFjZUVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBpc0pvaW5hYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodHIpIHtcbiAgICBpZiAoIXRyLmlzR2VuZXJpYykgcmV0dXJuIGRpc3BhdGNoKHRyKTtcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJhbmdlcy5sZW5ndGg7IGorKykgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKF9zLCBfZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlcy5wdXNoKGZyb20sIHRvKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgam9pbmFibGUgPSBbXTtcbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCByYW5nZXMubGVuZ3RoOyBfaTMgKz0gMikge1xuICAgICAgdmFyIGZyb20gPSByYW5nZXNbX2kzXSxcbiAgICAgICAgdG8gPSByYW5nZXNbX2kzICsgMV07XG4gICAgICB2YXIgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSxcbiAgICAgICAgZGVwdGggPSAkZnJvbS5zaGFyZWREZXB0aCh0byksXG4gICAgICAgIHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSwgcG9zID0gJGZyb20uYWZ0ZXIoZGVwdGggKyAxKTsgcG9zIDw9IHRvOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBhZnRlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgaWYgKCFhZnRlcikgYnJlYWs7XG4gICAgICAgIGlmIChpbmRleCAmJiBqb2luYWJsZS5pbmRleE9mKHBvcykgPT0gLTEpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgaWYgKGJlZm9yZS50eXBlID09IGFmdGVyLnR5cGUgJiYgaXNKb2luYWJsZShiZWZvcmUsIGFmdGVyKSkgam9pbmFibGUucHVzaChwb3MpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgam9pbmFibGUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuICAgIGZvciAodmFyIF9pNCA9IGpvaW5hYmxlLmxlbmd0aCAtIDE7IF9pNCA+PSAwOyBfaTQtLSkge1xuICAgICAgaWYgKHByb3NlbWlycm9yVHJhbnNmb3JtLmNhbkpvaW4odHIuZG9jLCBqb2luYWJsZVtfaTRdKSkgdHIuam9pbihqb2luYWJsZVtfaTRdKTtcbiAgICB9XG4gICAgZGlzcGF0Y2godHIpO1xuICB9O1xufVxuZnVuY3Rpb24gYXV0b0pvaW4oY29tbWFuZCwgaXNKb2luYWJsZSkge1xuICB2YXIgY2FuSm9pbiA9IEFycmF5LmlzQXJyYXkoaXNKb2luYWJsZSkgPyBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBpc0pvaW5hYmxlLmluZGV4T2Yobm9kZS50eXBlLm5hbWUpID4gLTE7XG4gIH0gOiBpc0pvaW5hYmxlO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgIHJldHVybiBjb21tYW5kKHN0YXRlLCBkaXNwYXRjaCAmJiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBjYW5Kb2luKSwgdmlldyk7XG4gIH07XG59XG5mdW5jdGlvbiBjaGFpbkNvbW1hbmRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY29tbWFuZHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgY29tbWFuZHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSBpZiAoY29tbWFuZHNbaV0oc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxudmFyIGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG52YXIgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG52YXIgcGNCYXNlS2V5bWFwID0ge1xuICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgXCJCYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gIFwiRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG52YXIgbWFjQmFzZUtleW1hcCA9IHtcbiAgXCJDdHJsLWhcIjogcGNCYXNlS2V5bWFwW1wiQmFja3NwYWNlXCJdLFxuICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgXCJDdHJsLWRcIjogcGNCYXNlS2V5bWFwW1wiRGVsZXRlXCJdLFxuICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgXCJBbHQtZFwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICBcIkN0cmwtYVwiOiBzZWxlY3RUZXh0YmxvY2tTdGFydCxcbiAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuZm9yICh2YXIga2V5IGluIHBjQmFzZUtleW1hcCkgbWFjQmFzZUtleW1hcFtrZXldID0gcGNCYXNlS2V5bWFwW2tleV07XG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogdHlwZW9mIG9zICE9IFwidW5kZWZpbmVkXCIgJiYgb3MucGxhdGZvcm0gPyBvcy5wbGF0Zm9ybSgpID09IFwiZGFyd2luXCIgOiBmYWxzZTtcbnZhciBiYXNlS2V5bWFwID0gbWFjID8gbWFjQmFzZUtleW1hcCA6IHBjQmFzZUtleW1hcDtcbmV4cG9ydHMuYXV0b0pvaW4gPSBhdXRvSm9pbjtcbmV4cG9ydHMuYmFzZUtleW1hcCA9IGJhc2VLZXltYXA7XG5leHBvcnRzLmNoYWluQ29tbWFuZHMgPSBjaGFpbkNvbW1hbmRzO1xuZXhwb3J0cy5jcmVhdGVQYXJhZ3JhcGhOZWFyID0gY3JlYXRlUGFyYWdyYXBoTmVhcjtcbmV4cG9ydHMuZGVsZXRlU2VsZWN0aW9uID0gZGVsZXRlU2VsZWN0aW9uO1xuZXhwb3J0cy5leGl0Q29kZSA9IGV4aXRDb2RlO1xuZXhwb3J0cy5qb2luQmFja3dhcmQgPSBqb2luQmFja3dhcmQ7XG5leHBvcnRzLmpvaW5Eb3duID0gam9pbkRvd247XG5leHBvcnRzLmpvaW5Gb3J3YXJkID0gam9pbkZvcndhcmQ7XG5leHBvcnRzLmpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9IGpvaW5UZXh0YmxvY2tCYWNrd2FyZDtcbmV4cG9ydHMuam9pblRleHRibG9ja0ZvcndhcmQgPSBqb2luVGV4dGJsb2NrRm9yd2FyZDtcbmV4cG9ydHMuam9pblVwID0gam9pblVwO1xuZXhwb3J0cy5saWZ0ID0gbGlmdDtcbmV4cG9ydHMubGlmdEVtcHR5QmxvY2sgPSBsaWZ0RW1wdHlCbG9jaztcbmV4cG9ydHMubWFjQmFzZUtleW1hcCA9IG1hY0Jhc2VLZXltYXA7XG5leHBvcnRzLm5ld2xpbmVJbkNvZGUgPSBuZXdsaW5lSW5Db2RlO1xuZXhwb3J0cy5wY0Jhc2VLZXltYXAgPSBwY0Jhc2VLZXltYXA7XG5leHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbmV4cG9ydHMuc2VsZWN0Tm9kZUJhY2t3YXJkID0gc2VsZWN0Tm9kZUJhY2t3YXJkO1xuZXhwb3J0cy5zZWxlY3ROb2RlRm9yd2FyZCA9IHNlbGVjdE5vZGVGb3J3YXJkO1xuZXhwb3J0cy5zZWxlY3RQYXJlbnROb2RlID0gc2VsZWN0UGFyZW50Tm9kZTtcbmV4cG9ydHMuc2VsZWN0VGV4dGJsb2NrRW5kID0gc2VsZWN0VGV4dGJsb2NrRW5kO1xuZXhwb3J0cy5zZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1N0YXJ0O1xuZXhwb3J0cy5zZXRCbG9ja1R5cGUgPSBzZXRCbG9ja1R5cGU7XG5leHBvcnRzLnNwbGl0QmxvY2sgPSBzcGxpdEJsb2NrO1xuZXhwb3J0cy5zcGxpdEJsb2NrQXMgPSBzcGxpdEJsb2NrQXM7XG5leHBvcnRzLnNwbGl0QmxvY2tLZWVwTWFya3MgPSBzcGxpdEJsb2NrS2VlcE1hcmtzO1xuZXhwb3J0cy50b2dnbGVNYXJrID0gdG9nZ2xlTWFyaztcbmV4cG9ydHMud3JhcEluID0gd3JhcEluO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/prosemirror-commands@1.7.1/node_modules/prosemirror-commands/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/prosemirror-commands@1.7.1/node_modules/prosemirror-commands/dist/index.cjs":
/*!************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/prosemirror-commands@1.7.1/node_modules/prosemirror-commands/dist/index.cjs ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/../../node_modules/.pnpm/prosemirror-transform@1.10.4/node_modules/prosemirror-transform/dist/index.cjs\");\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"(ssr)/../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs\");\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"(ssr)/../../node_modules/.pnpm/prosemirror-state@1.4.3/node_modules/prosemirror-state/dist/index.cjs\");\nvar deleteSelection = function deleteSelection(state, dispatch) {\n  if (state.selection.empty) return false;\n  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());\n  return true;\n};\nfunction atBlockStart(state, view) {\n  var $cursor = state.selection.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) return null;\n  return $cursor;\n}\nvar joinBackward = function joinBackward(state, dispatch, view) {\n  var $cursor = atBlockStart(state, view);\n  if (!$cursor) return false;\n  var $cut = findCutBefore($cursor);\n  if (!$cut) {\n    var range = $cursor.blockRange(),\n      target = range && prosemirrorTransform.liftTarget(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n  var before = $cut.nodeBefore;\n  if (deleteBarrier(state, $cut, dispatch, -1)) return true;\n  if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || prosemirrorState.NodeSelection.isSelectable(before))) {\n    for (var depth = $cursor.depth;; depth--) {\n      var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), prosemirrorModel.Slice.empty);\n      if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n        if (dispatch) {\n          var tr = state.tr.step(delStep);\n          tr.setSelection(textblockAt(before, \"end\") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirrorState.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n          dispatch(tr.scrollIntoView());\n        }\n        return true;\n      }\n      if (depth == 1 || $cursor.node(depth - 1).childCount > 1) break;\n    }\n  }\n  if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr[\"delete\"]($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n    return true;\n  }\n  return false;\n};\nvar joinTextblockBackward = function joinTextblockBackward(state, dispatch, view) {\n  var $cursor = atBlockStart(state, view);\n  if (!$cursor) return false;\n  var $cut = findCutBefore($cursor);\n  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nvar joinTextblockForward = function joinTextblockForward(state, dispatch, view) {\n  var $cursor = atBlockEnd(state, view);\n  if (!$cursor) return false;\n  var $cut = findCutAfter($cursor);\n  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n  var before = $cut.nodeBefore,\n    beforeText = before,\n    beforePos = $cut.pos - 1;\n  for (; !beforeText.isTextblock; beforePos--) {\n    if (beforeText.type.spec.isolating) return false;\n    var child = beforeText.lastChild;\n    if (!child) return false;\n    beforeText = child;\n  }\n  var after = $cut.nodeAfter,\n    afterText = after,\n    afterPos = $cut.pos + 1;\n  for (; !afterText.isTextblock; afterPos++) {\n    if (afterText.type.spec.isolating) return false;\n    var _child = afterText.firstChild;\n    if (!_child) return false;\n    afterText = _child;\n  }\n  var step = prosemirrorTransform.replaceStep(state.doc, beforePos, afterPos, prosemirrorModel.Slice.empty);\n  if (!step || step.from != beforePos || step instanceof prosemirrorTransform.ReplaceStep && step.slice.size >= afterPos - beforePos) return false;\n  if (dispatch) {\n    var tr = state.tr.step(step);\n    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, beforePos));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n}\nfunction textblockAt(node, side) {\n  var only = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  for (var scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild) {\n    if (scan.isTextblock) return true;\n    if (only && scan.childCount != 1) return false;\n  }\n  return false;\n}\nvar selectNodeBackward = function selectNodeBackward(state, dispatch, view) {\n  var _state$selection = state.selection,\n    $head = _state$selection.$head,\n    empty = _state$selection.empty,\n    $cut = $head;\n  if (!empty) return false;\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false;\n    $cut = findCutBefore($head);\n  }\n  var node = $cut && $cut.nodeBefore;\n  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n  return true;\n};\nfunction findCutBefore($pos) {\n  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {\n    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));\n    if ($pos.node(i).type.spec.isolating) break;\n  }\n  return null;\n}\nfunction atBlockEnd(state, view) {\n  var $cursor = state.selection.$cursor;\n  if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) return null;\n  return $cursor;\n}\nvar joinForward = function joinForward(state, dispatch, view) {\n  var $cursor = atBlockEnd(state, view);\n  if (!$cursor) return false;\n  var $cut = findCutAfter($cursor);\n  if (!$cut) return false;\n  var after = $cut.nodeAfter;\n  if (deleteBarrier(state, $cut, dispatch, 1)) return true;\n  if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || prosemirrorState.NodeSelection.isSelectable(after))) {\n    var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(), $cursor.after(), prosemirrorModel.Slice.empty);\n    if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n      if (dispatch) {\n        var tr = state.tr.step(delStep);\n        tr.setSelection(textblockAt(after, \"start\") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirrorState.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n  }\n  if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n    if (dispatch) dispatch(state.tr[\"delete\"]($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n    return true;\n  }\n  return false;\n};\nvar selectNodeForward = function selectNodeForward(state, dispatch, view) {\n  var _state$selection2 = state.selection,\n    $head = _state$selection2.$head,\n    empty = _state$selection2.empty,\n    $cut = $head;\n  if (!empty) return false;\n  if ($head.parent.isTextblock) {\n    if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) return false;\n    $cut = findCutAfter($head);\n  }\n  var node = $cut && $cut.nodeAfter;\n  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n  return true;\n};\nfunction findCutAfter($pos) {\n  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {\n    var parent = $pos.node(i);\n    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));\n    if (parent.type.spec.isolating) break;\n  }\n  return null;\n}\nvar joinUp = function joinUp(state, dispatch) {\n  var sel = state.selection,\n    nodeSel = sel instanceof prosemirrorState.NodeSelection,\n    point;\n  if (nodeSel) {\n    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.from)) return false;\n    point = sel.from;\n  } else {\n    point = prosemirrorTransform.joinPoint(state.doc, sel.from, -1);\n    if (point == null) return false;\n  }\n  if (dispatch) {\n    var tr = state.tr.join(point);\n    if (nodeSel) tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nvar joinDown = function joinDown(state, dispatch) {\n  var sel = state.selection,\n    point;\n  if (sel instanceof prosemirrorState.NodeSelection) {\n    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.to)) return false;\n    point = sel.to;\n  } else {\n    point = prosemirrorTransform.joinPoint(state.doc, sel.to, 1);\n    if (point == null) return false;\n  }\n  if (dispatch) dispatch(state.tr.join(point).scrollIntoView());\n  return true;\n};\nvar lift = function lift(state, dispatch) {\n  var _state$selection3 = state.selection,\n    $from = _state$selection3.$from,\n    $to = _state$selection3.$to;\n  var range = $from.blockRange($to),\n    target = range && prosemirrorTransform.liftTarget(range);\n  if (target == null) return false;\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n  return true;\n};\nvar newlineInCode = function newlineInCode(state, dispatch) {\n  var _state$selection4 = state.selection,\n    $head = _state$selection4.$head,\n    $anchor = _state$selection4.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n  if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n  return true;\n};\nfunction defaultBlockAt(match) {\n  for (var i = 0; i < match.edgeCount; i++) {\n    var _match$edge = match.edge(i),\n      type = _match$edge.type;\n    if (type.isTextblock && !type.hasRequiredAttrs()) return type;\n  }\n  return null;\n}\nvar exitCode = function exitCode(state, dispatch) {\n  var _state$selection5 = state.selection,\n    $head = _state$selection5.$head,\n    $anchor = _state$selection5.$anchor;\n  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n  var above = $head.node(-1),\n    after = $head.indexAfter(-1),\n    type = defaultBlockAt(above.contentMatchAt(after));\n  if (!type || !above.canReplaceWith(after, after, type)) return false;\n  if (dispatch) {\n    var pos = $head.after(),\n      tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n    tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nvar createParagraphNear = function createParagraphNear(state, dispatch) {\n  var sel = state.selection,\n    $from = sel.$from,\n    $to = sel.$to;\n  if (sel instanceof prosemirrorState.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;\n  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n  if (!type || !type.isTextblock) return false;\n  if (dispatch) {\n    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n    var tr = state.tr.insert(side, type.createAndFill());\n    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, side + 1));\n    dispatch(tr.scrollIntoView());\n  }\n  return true;\n};\nvar liftEmptyBlock = function liftEmptyBlock(state, dispatch) {\n  var $cursor = state.selection.$cursor;\n  if (!$cursor || $cursor.parent.content.size) return false;\n  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n    var before = $cursor.before();\n    if (prosemirrorTransform.canSplit(state.doc, before)) {\n      if (dispatch) dispatch(state.tr.split(before).scrollIntoView());\n      return true;\n    }\n  }\n  var range = $cursor.blockRange(),\n    target = range && prosemirrorTransform.liftTarget(range);\n  if (target == null) return false;\n  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n  return true;\n};\nfunction splitBlockAs(splitNode) {\n  return function (state, dispatch) {\n    var _state$selection6 = state.selection,\n      $from = _state$selection6.$from,\n      $to = _state$selection6.$to;\n    if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.isBlock) {\n      if (!$from.parentOffset || !prosemirrorTransform.canSplit(state.doc, $from.pos)) return false;\n      if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());\n      return true;\n    }\n    if (!$from.depth) return false;\n    var types = [];\n    var splitDepth,\n      deflt,\n      atEnd = false,\n      atStart = false;\n    for (var d = $from.depth;; d--) {\n      var node = $from.node(d);\n      if (node.isBlock) {\n        atEnd = $from.end(d) == $from.pos + ($from.depth - d);\n        atStart = $from.start(d) == $from.pos - ($from.depth - d);\n        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));\n        var splitType = splitNode && splitNode($to.parent, atEnd, $from);\n        types.unshift(splitType || (atEnd && deflt ? {\n          type: deflt\n        } : null));\n        splitDepth = d;\n        break;\n      } else {\n        if (d == 1) return false;\n        types.unshift(null);\n      }\n    }\n    var tr = state.tr;\n    if (state.selection instanceof prosemirrorState.TextSelection || state.selection instanceof prosemirrorState.AllSelection) tr.deleteSelection();\n    var splitPos = tr.mapping.map($from.pos);\n    var can = prosemirrorTransform.canSplit(tr.doc, splitPos, types.length, types);\n    if (!can) {\n      types[0] = deflt ? {\n        type: deflt\n      } : null;\n      can = prosemirrorTransform.canSplit(tr.doc, splitPos, types.length, types);\n    }\n    if (!can) return false;\n    tr.split(splitPos, types.length, types);\n    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {\n      var first = tr.mapping.map($from.before(splitDepth)),\n        $first = tr.doc.resolve(first);\n      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);\n    }\n    if (dispatch) dispatch(tr.scrollIntoView());\n    return true;\n  };\n}\nvar splitBlock = splitBlockAs();\nvar splitBlockKeepMarks = function splitBlockKeepMarks(state, dispatch) {\n  return splitBlock(state, dispatch && function (tr) {\n    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n    if (marks) tr.ensureMarks(marks);\n    dispatch(tr);\n  });\n};\nvar selectParentNode = function selectParentNode(state, dispatch) {\n  var _state$selection7 = state.selection,\n    $from = _state$selection7.$from,\n    to = _state$selection7.to,\n    pos;\n  var same = $from.sharedDepth(to);\n  if (same == 0) return false;\n  pos = $from.before(same);\n  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, pos)));\n  return true;\n};\nvar selectAll = function selectAll(state, dispatch) {\n  if (dispatch) dispatch(state.tr.setSelection(new prosemirrorState.AllSelection(state.doc)));\n  return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n  var before = $pos.nodeBefore,\n    after = $pos.nodeAfter,\n    index = $pos.index();\n  if (!before || !after || !before.type.compatibleContent(after.type)) return false;\n  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n    if (dispatch) dispatch(state.tr[\"delete\"]($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n    return true;\n  }\n  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || prosemirrorTransform.canJoin(state.doc, $pos.pos))) return false;\n  if (dispatch) dispatch(state.tr.join($pos.pos).scrollIntoView());\n  return true;\n}\nfunction deleteBarrier(state, $cut, dispatch, dir) {\n  var before = $cut.nodeBefore,\n    after = $cut.nodeAfter,\n    conn,\n    match;\n  var isolated = before.type.spec.isolating || after.type.spec.isolating;\n  if (!isolated && joinMaybeClear(state, $cut, dispatch)) return true;\n  var canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n    if (dispatch) {\n      var end = $cut.pos + after.nodeSize,\n        wrap = prosemirrorModel.Fragment.empty;\n      for (var i = conn.length - 1; i >= 0; i--) wrap = prosemirrorModel.Fragment.from(conn[i].create(null, wrap));\n      wrap = prosemirrorModel.Fragment.from(before.copy(wrap));\n      var tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirrorModel.Slice(wrap, 1, 0), conn.length, true));\n      var $joinAt = tr.doc.resolve(end + 2 * conn.length);\n      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && prosemirrorTransform.canJoin(tr.doc, $joinAt.pos)) tr.join($joinAt.pos);\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  }\n  var selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : prosemirrorState.Selection.findFrom($cut, 1);\n  var range = selAfter && selAfter.$from.blockRange(selAfter.$to),\n    target = range && prosemirrorTransform.liftTarget(range);\n  if (target != null && target >= $cut.depth) {\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  }\n  if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n    var at = before,\n      _wrap = [];\n    for (;;) {\n      _wrap.push(at);\n      if (at.isTextblock) break;\n      at = at.lastChild;\n    }\n    var afterText = after,\n      afterDepth = 1;\n    for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++;\n    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n      if (dispatch) {\n        var _end = prosemirrorModel.Fragment.empty;\n        for (var _i = _wrap.length - 1; _i >= 0; _i--) _end = prosemirrorModel.Fragment.from(_wrap[_i].copy(_end));\n        var _tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - _wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirrorModel.Slice(_end, _wrap.length, 0), 0, true));\n        dispatch(_tr.scrollIntoView());\n      }\n      return true;\n    }\n  }\n  return false;\n}\nfunction selectTextblockSide(side) {\n  return function (state, dispatch) {\n    var sel = state.selection,\n      $pos = side < 0 ? sel.$from : sel.$to;\n    var depth = $pos.depth;\n    while ($pos.node(depth).isInline) {\n      if (!depth) return false;\n      depth--;\n    }\n    if (!$pos.node(depth).isTextblock) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n    return true;\n  };\n}\nvar selectTextblockStart = selectTextblockSide(-1);\nvar selectTextblockEnd = selectTextblockSide(1);\nfunction wrapIn(nodeType) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    var _state$selection8 = state.selection,\n      $from = _state$selection8.$from,\n      $to = _state$selection8.$to;\n    var range = $from.blockRange($to),\n      wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);\n    if (!wrapping) return false;\n    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n    return true;\n  };\n}\nfunction setBlockType(nodeType) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return function (state, dispatch) {\n    var applicable = false;\n    for (var i = 0; i < state.selection.ranges.length && !applicable; i++) {\n      var _state$selection$rang = state.selection.ranges[i],\n        from = _state$selection$rang.$from.pos,\n        to = _state$selection$rang.$to.pos;\n      state.doc.nodesBetween(from, to, function (node, pos) {\n        if (applicable) return false;\n        if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;\n        if (node.type == nodeType) {\n          applicable = true;\n        } else {\n          var $pos = state.doc.resolve(pos),\n            index = $pos.index();\n          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n        }\n      });\n    }\n    if (!applicable) return false;\n    if (dispatch) {\n      var tr = state.tr;\n      for (var _i2 = 0; _i2 < state.selection.ranges.length; _i2++) {\n        var _state$selection$rang2 = state.selection.ranges[_i2],\n          _from = _state$selection$rang2.$from.pos,\n          _to = _state$selection$rang2.$to.pos;\n        tr.setBlockType(_from, _to, nodeType, attrs);\n      }\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  };\n}\nfunction markApplies(doc, ranges, type, enterAtoms) {\n  var _loop = function _loop() {\n      var _ranges$i = ranges[i],\n        $from = _ranges$i.$from,\n        $to = _ranges$i.$to;\n      var can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n      doc.nodesBetween($from.pos, $to.pos, function (node, pos) {\n        if (can || !enterAtoms && node.isAtom && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) return false;\n        can = node.inlineContent && node.type.allowsMarkType(type);\n      });\n      if (can) return {\n        v: true\n      };\n    },\n    _ret;\n  for (var i = 0; i < ranges.length; i++) {\n    _ret = _loop();\n    if (_ret) return _ret.v;\n  }\n  return false;\n}\nfunction removeInlineAtoms(ranges) {\n  var result = [];\n  var _loop2 = function _loop2() {\n    var _ranges$i2 = ranges[i],\n      $from = _ranges$i2.$from,\n      $to = _ranges$i2.$to;\n    $from.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {\n      if (node.isAtom && node.content.size && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) {\n        if (pos + 1 > $from.pos) result.push(new prosemirrorState.SelectionRange($from, $from.doc.resolve(pos + 1)));\n        $from = $from.doc.resolve(pos + 1 + node.content.size);\n        return false;\n      }\n    });\n    if ($from.pos < $to.pos) result.push(new prosemirrorState.SelectionRange($from, $to));\n  };\n  for (var i = 0; i < ranges.length; i++) {\n    _loop2();\n  }\n  return result;\n}\nfunction toggleMark(markType) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n  var removeWhenPresent = (options && options.removeWhenPresent) !== false;\n  var enterAtoms = (options && options.enterInlineAtoms) !== false;\n  var dropSpace = !(options && options.includeWhitespace);\n  return function (state, dispatch) {\n    var _state$selection9 = state.selection,\n      empty = _state$selection9.empty,\n      $cursor = _state$selection9.$cursor,\n      ranges = _state$selection9.ranges;\n    if (empty && !$cursor || !markApplies(state.doc, ranges, markType, enterAtoms)) return false;\n    if (dispatch) {\n      if ($cursor) {\n        if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));else dispatch(state.tr.addStoredMark(markType.create(attrs)));\n      } else {\n        var add,\n          tr = state.tr;\n        if (!enterAtoms) ranges = removeInlineAtoms(ranges);\n        if (removeWhenPresent) {\n          add = !ranges.some(function (r) {\n            return state.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType);\n          });\n        } else {\n          add = !ranges.every(function (r) {\n            var missing = false;\n            tr.doc.nodesBetween(r.$from.pos, r.$to.pos, function (node, pos, parent) {\n              if (missing) return false;\n              missing = !markType.isInSet(node.marks) && !!parent && parent.type.allowsMarkType(markType) && !(node.isText && /^\\s*$/.test(node.textBetween(Math.max(0, r.$from.pos - pos), Math.min(node.nodeSize, r.$to.pos - pos))));\n            });\n            return !missing;\n          });\n        }\n        for (var i = 0; i < ranges.length; i++) {\n          var _ranges$i3 = ranges[i],\n            $from = _ranges$i3.$from,\n            $to = _ranges$i3.$to;\n          if (!add) {\n            tr.removeMark($from.pos, $to.pos, markType);\n          } else {\n            var from = $from.pos,\n              to = $to.pos,\n              start = $from.nodeAfter,\n              end = $to.nodeBefore;\n            var spaceStart = dropSpace && start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n            var spaceEnd = dropSpace && end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n            if (from + spaceStart < to) {\n              from += spaceStart;\n              to -= spaceEnd;\n            }\n            tr.addMark(from, to, markType.create(attrs));\n          }\n        }\n        dispatch(tr.scrollIntoView());\n      }\n    }\n    return true;\n  };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n  return function (tr) {\n    if (!tr.isGeneric) return dispatch(tr);\n    var ranges = [];\n    for (var i = 0; i < tr.mapping.maps.length; i++) {\n      var map = tr.mapping.maps[i];\n      for (var j = 0; j < ranges.length; j++) ranges[j] = map.map(ranges[j]);\n      map.forEach(function (_s, _e, from, to) {\n        return ranges.push(from, to);\n      });\n    }\n    var joinable = [];\n    for (var _i3 = 0; _i3 < ranges.length; _i3 += 2) {\n      var from = ranges[_i3],\n        to = ranges[_i3 + 1];\n      var $from = tr.doc.resolve(from),\n        depth = $from.sharedDepth(to),\n        parent = $from.node(depth);\n      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n        var after = parent.maybeChild(index);\n        if (!after) break;\n        if (index && joinable.indexOf(pos) == -1) {\n          var before = parent.child(index - 1);\n          if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);\n        }\n        pos += after.nodeSize;\n      }\n    }\n    joinable.sort(function (a, b) {\n      return a - b;\n    });\n    for (var _i4 = joinable.length - 1; _i4 >= 0; _i4--) {\n      if (prosemirrorTransform.canJoin(tr.doc, joinable[_i4])) tr.join(joinable[_i4]);\n    }\n    dispatch(tr);\n  };\n}\nfunction autoJoin(command, isJoinable) {\n  var canJoin = Array.isArray(isJoinable) ? function (node) {\n    return isJoinable.indexOf(node.type.name) > -1;\n  } : isJoinable;\n  return function (state, dispatch, view) {\n    return command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n  };\n}\nfunction chainCommands() {\n  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {\n    commands[_key] = arguments[_key];\n  }\n  return function (state, dispatch, view) {\n    for (var i = 0; i < commands.length; i++) if (commands[i](state, dispatch, view)) return true;\n    return false;\n  };\n}\nvar backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nvar del = chainCommands(deleteSelection, joinForward, selectNodeForward);\nvar pcBaseKeymap = {\n  \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n  \"Mod-Enter\": exitCode,\n  \"Backspace\": backspace,\n  \"Mod-Backspace\": backspace,\n  \"Shift-Backspace\": backspace,\n  \"Delete\": del,\n  \"Mod-Delete\": del,\n  \"Mod-a\": selectAll\n};\nvar macBaseKeymap = {\n  \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n  \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n  \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n  \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n  \"Ctrl-a\": selectTextblockStart,\n  \"Ctrl-e\": selectTextblockEnd\n};\nfor (var key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key];\nvar mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\nvar baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\nexports.autoJoin = autoJoin;\nexports.baseKeymap = baseKeymap;\nexports.chainCommands = chainCommands;\nexports.createParagraphNear = createParagraphNear;\nexports.deleteSelection = deleteSelection;\nexports.exitCode = exitCode;\nexports.joinBackward = joinBackward;\nexports.joinDown = joinDown;\nexports.joinForward = joinForward;\nexports.joinTextblockBackward = joinTextblockBackward;\nexports.joinTextblockForward = joinTextblockForward;\nexports.joinUp = joinUp;\nexports.lift = lift;\nexports.liftEmptyBlock = liftEmptyBlock;\nexports.macBaseKeymap = macBaseKeymap;\nexports.newlineInCode = newlineInCode;\nexports.pcBaseKeymap = pcBaseKeymap;\nexports.selectAll = selectAll;\nexports.selectNodeBackward = selectNodeBackward;\nexports.selectNodeForward = selectNodeForward;\nexports.selectParentNode = selectParentNode;\nexports.selectTextblockEnd = selectTextblockEnd;\nexports.selectTextblockStart = selectTextblockStart;\nexports.setBlockType = setBlockType;\nexports.splitBlock = splitBlock;\nexports.splitBlockAs = splitBlockAs;\nexports.splitBlockKeepMarks = splitBlockKeepMarks;\nexports.toggleMark = toggleMark;\nexports.wrapIn = wrapIn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLWNvbW1hbmRzQDEuNy4xL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiwyQkFBMkIsbUJBQU8sQ0FBQyw0SUFBdUI7QUFDMUQsdUJBQXVCLG1CQUFPLENBQUMsZ0lBQW1CO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLCtIQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBa0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSDtBQUNsSCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsV0FBVztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLGNBQWM7QUFDZCxZQUFZO0FBQ1osc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQixrQkFBa0I7QUFDbEIsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL0Vib290aC9hZ2VudF9jX2ZyYW1ld29yay9zcmMvcmVhbHRpbWVfY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9wcm9zZW1pcnJvci1jb21tYW5kc0AxLjcuMS9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJvc2VtaXJyb3JUcmFuc2Zvcm0gPSByZXF1aXJlKCdwcm9zZW1pcnJvci10cmFuc2Zvcm0nKTtcbnZhciBwcm9zZW1pcnJvck1vZGVsID0gcmVxdWlyZSgncHJvc2VtaXJyb3ItbW9kZWwnKTtcbnZhciBwcm9zZW1pcnJvclN0YXRlID0gcmVxdWlyZSgncHJvc2VtaXJyb3Itc3RhdGUnKTtcbnZhciBkZWxldGVTZWxlY3Rpb24gPSBmdW5jdGlvbiBkZWxldGVTZWxlY3Rpb24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGVTZWxlY3Rpb24oKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KSB7XG4gIHZhciAkY3Vyc29yID0gc3RhdGUuc2VsZWN0aW9uLiRjdXJzb3I7XG4gIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPiAwKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiAkY3Vyc29yO1xufVxudmFyIGpvaW5CYWNrd2FyZCA9IGZ1bmN0aW9uIGpvaW5CYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICBpZiAoISRjdXJzb3IpIHJldHVybiBmYWxzZTtcbiAgdmFyICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICBpZiAoISRjdXQpIHtcbiAgICB2YXIgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSxcbiAgICAgIHRhcmdldCA9IHJhbmdlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlO1xuICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gsIC0xKSkgcmV0dXJuIHRydWU7XG4gIGlmICgkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUgPT0gMCAmJiAodGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSB8fCBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgZm9yICh2YXIgZGVwdGggPSAkY3Vyc29yLmRlcHRoOzsgZGVwdGgtLSkge1xuICAgICAgdmFyIGRlbFN0ZXAgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5yZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKGRlcHRoKSwgJGN1cnNvci5hZnRlcihkZXB0aCksIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHkpO1xuICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICB2YXIgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpID8gcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MsIC0xKSksIC0xKSA6IHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRlcHRoID09IDEgfHwgJGN1cnNvci5ub2RlKGRlcHRoIC0gMSkuY2hpbGRDb3VudCA+IDEpIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoYmVmb3JlLmlzQXRvbSAmJiAkY3V0LmRlcHRoID09ICRjdXJzb3IuZGVwdGggLSAxKSB7XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50cltcImRlbGV0ZVwiXSgkY3V0LnBvcyAtIGJlZm9yZS5ub2RlU2l6ZSwgJGN1dC5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgam9pblRleHRibG9ja0JhY2t3YXJkID0gZnVuY3Rpb24gam9pblRleHRibG9ja0JhY2t3YXJkKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICB2YXIgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gIGlmICghJGN1cnNvcikgcmV0dXJuIGZhbHNlO1xuICB2YXIgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbnZhciBqb2luVGV4dGJsb2NrRm9yd2FyZCA9IGZ1bmN0aW9uIGpvaW5UZXh0YmxvY2tGb3J3YXJkKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICB2YXIgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICBpZiAoISRjdXJzb3IpIHJldHVybiBmYWxzZTtcbiAgdmFyICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICB2YXIgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLFxuICAgIGJlZm9yZVRleHQgPSBiZWZvcmUsXG4gICAgYmVmb3JlUG9zID0gJGN1dC5wb3MgLSAxO1xuICBmb3IgKDsgIWJlZm9yZVRleHQuaXNUZXh0YmxvY2s7IGJlZm9yZVBvcy0tKSB7XG4gICAgaWYgKGJlZm9yZVRleHQudHlwZS5zcGVjLmlzb2xhdGluZykgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBjaGlsZCA9IGJlZm9yZVRleHQubGFzdENoaWxkO1xuICAgIGlmICghY2hpbGQpIHJldHVybiBmYWxzZTtcbiAgICBiZWZvcmVUZXh0ID0gY2hpbGQ7XG4gIH1cbiAgdmFyIGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXIsXG4gICAgYWZ0ZXJUZXh0ID0gYWZ0ZXIsXG4gICAgYWZ0ZXJQb3MgPSAkY3V0LnBvcyArIDE7XG4gIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclBvcysrKSB7XG4gICAgaWYgKGFmdGVyVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIF9jaGlsZCA9IGFmdGVyVGV4dC5maXJzdENoaWxkO1xuICAgIGlmICghX2NoaWxkKSByZXR1cm4gZmFsc2U7XG4gICAgYWZ0ZXJUZXh0ID0gX2NoaWxkO1xuICB9XG4gIHZhciBzdGVwID0gcHJvc2VtaXJyb3JUcmFuc2Zvcm0ucmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCBiZWZvcmVQb3MsIGFmdGVyUG9zLCBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5KTtcbiAgaWYgKCFzdGVwIHx8IHN0ZXAuZnJvbSAhPSBiZWZvcmVQb3MgfHwgc3RlcCBpbnN0YW5jZW9mIHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VTdGVwICYmIHN0ZXAuc2xpY2Uuc2l6ZSA+PSBhZnRlclBvcyAtIGJlZm9yZVBvcykgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB2YXIgdHIgPSBzdGF0ZS50ci5zdGVwKHN0ZXApO1xuICAgIHRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYmVmb3JlUG9zKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0ZXh0YmxvY2tBdChub2RlLCBzaWRlKSB7XG4gIHZhciBvbmx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgZm9yICh2YXIgc2NhbiA9IG5vZGU7IHNjYW47IHNjYW4gPSBzaWRlID09IFwic3RhcnRcIiA/IHNjYW4uZmlyc3RDaGlsZCA6IHNjYW4ubGFzdENoaWxkKSB7XG4gICAgaWYgKHNjYW4uaXNUZXh0YmxvY2spIHJldHVybiB0cnVlO1xuICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIHNlbGVjdE5vZGVCYWNrd2FyZCA9IGZ1bmN0aW9uIHNlbGVjdE5vZGVCYWNrd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgJGhlYWQgPSBfc3RhdGUkc2VsZWN0aW9uLiRoZWFkLFxuICAgIGVtcHR5ID0gX3N0YXRlJHNlbGVjdGlvbi5lbXB0eSxcbiAgICAkY3V0ID0gJGhlYWQ7XG4gIGlmICghZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPiAwKSByZXR1cm4gZmFsc2U7XG4gICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICB9XG4gIHZhciBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVCZWZvcmU7XG4gIGlmICghbm9kZSB8fCAhcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MgLSBub2RlLm5vZGVTaXplKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRCZWZvcmUoJHBvcykge1xuICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpIGZvciAodmFyIGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoJHBvcy5pbmRleChpKSA+IDApIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSk7XG4gICAgaWYgKCRwb3Mubm9kZShpKS50eXBlLnNwZWMuaXNvbGF0aW5nKSBicmVhaztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpIHtcbiAgdmFyICRjdXJzb3IgPSBzdGF0ZS5zZWxlY3Rpb24uJGN1cnNvcjtcbiAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKSA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSkgcmV0dXJuIG51bGw7XG4gIHJldHVybiAkY3Vyc29yO1xufVxudmFyIGpvaW5Gb3J3YXJkID0gZnVuY3Rpb24gam9pbkZvcndhcmQoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gIHZhciAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gIGlmICghJGN1cnNvcikgcmV0dXJuIGZhbHNlO1xuICB2YXIgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgaWYgKCEkY3V0KSByZXR1cm4gZmFsc2U7XG4gIHZhciBhZnRlciA9ICRjdXQubm9kZUFmdGVyO1xuICBpZiAoZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gsIDEpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGFmdGVyKSkpIHtcbiAgICB2YXIgZGVsU3RlcCA9IHByb3NlbWlycm9yVHJhbnNmb3JtLnJlcGxhY2VTdGVwKHN0YXRlLmRvYywgJGN1cnNvci5iZWZvcmUoKSwgJGN1cnNvci5hZnRlcigpLCBwcm9zZW1pcnJvck1vZGVsLlNsaWNlLmVtcHR5KTtcbiAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdmFyIHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpID8gcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSkgOiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChhZnRlci5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHJbXCJkZWxldGVcIl0oJGN1dC5wb3MsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgc2VsZWN0Tm9kZUZvcndhcmQgPSBmdW5jdGlvbiBzZWxlY3ROb2RlRm9yd2FyZChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24yID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICRoZWFkID0gX3N0YXRlJHNlbGVjdGlvbjIuJGhlYWQsXG4gICAgZW1wdHkgPSBfc3RhdGUkc2VsZWN0aW9uMi5lbXB0eSxcbiAgICAkY3V0ID0gJGhlYWQ7XG4gIGlmICghZW1wdHkpIHJldHVybiBmYWxzZTtcbiAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA8ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemUpIHJldHVybiBmYWxzZTtcbiAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgfVxuICB2YXIgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQWZ0ZXI7XG4gIGlmICghbm9kZSB8fCAhcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSBmb3IgKHZhciBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcmVudCA9ICRwb3Mubm9kZShpKTtcbiAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudCkgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5hZnRlcihpICsgMSkpO1xuICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgam9pblVwID0gZnVuY3Rpb24gam9pblVwKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgc2VsID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24sXG4gICAgcG9pbnQ7XG4gIGlmIChub2RlU2VsKSB7XG4gICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5Kb2luKHN0YXRlLmRvYywgc2VsLmZyb20pKSByZXR1cm4gZmFsc2U7XG4gICAgcG9pbnQgPSBzZWwuZnJvbTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludCA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC5mcm9tLCAtMSk7XG4gICAgaWYgKHBvaW50ID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB2YXIgdHIgPSBzdGF0ZS50ci5qb2luKHBvaW50KTtcbiAgICBpZiAobm9kZVNlbCkgdHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb2ludCAtIHN0YXRlLmRvYy5yZXNvbHZlKHBvaW50KS5ub2RlQmVmb3JlLm5vZGVTaXplKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGpvaW5Eb3duID0gZnVuY3Rpb24gam9pbkRvd24oc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgcG9pbnQ7XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIXByb3NlbWlycm9yVHJhbnNmb3JtLmNhbkpvaW4oc3RhdGUuZG9jLCBzZWwudG8pKSByZXR1cm4gZmFsc2U7XG4gICAgcG9pbnQgPSBzZWwudG87XG4gIH0gZWxzZSB7XG4gICAgcG9pbnQgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5qb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgIGlmIChwb2ludCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGxpZnQgPSBmdW5jdGlvbiBsaWZ0KHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjMgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uMy4kZnJvbSxcbiAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uMy4kdG87XG4gIHZhciByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSxcbiAgICB0YXJnZXQgPSByYW5nZSAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5saWZ0VGFyZ2V0KHJhbmdlKTtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIG5ld2xpbmVJbkNvZGUgPSBmdW5jdGlvbiBuZXdsaW5lSW5Db2RlKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgX3N0YXRlJHNlbGVjdGlvbjQgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgJGhlYWQgPSBfc3RhdGUkc2VsZWN0aW9uNC4kaGVhZCxcbiAgICAkYW5jaG9yID0gX3N0YXRlJHNlbGVjdGlvbjQuJGFuY2hvcjtcbiAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5pbnNlcnRUZXh0KFwiXFxuXCIpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgdmFyIF9tYXRjaCRlZGdlID0gbWF0Y2guZWRnZShpKSxcbiAgICAgIHR5cGUgPSBfbWF0Y2gkZWRnZS50eXBlO1xuICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkgcmV0dXJuIHR5cGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgZXhpdENvZGUgPSBmdW5jdGlvbiBleGl0Q29kZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb241ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICRoZWFkID0gX3N0YXRlJHNlbGVjdGlvbjUuJGhlYWQsXG4gICAgJGFuY2hvciA9IF9zdGF0ZSRzZWxlY3Rpb241LiRhbmNob3I7XG4gIGlmICghJGhlYWQucGFyZW50LnR5cGUuc3BlYy5jb2RlIHx8ICEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBhYm92ZSA9ICRoZWFkLm5vZGUoLTEpLFxuICAgIGFmdGVyID0gJGhlYWQuaW5kZXhBZnRlcigtMSksXG4gICAgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gIGlmICghdHlwZSB8fCAhYWJvdmUuY2FuUmVwbGFjZVdpdGgoYWZ0ZXIsIGFmdGVyLCB0eXBlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIHtcbiAgICB2YXIgcG9zID0gJGhlYWQuYWZ0ZXIoKSxcbiAgICAgIHRyID0gc3RhdGUudHIucmVwbGFjZVdpdGgocG9zLCBwb3MsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICB0ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShwb3MpLCAxKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGNyZWF0ZVBhcmFncmFwaE5lYXIgPSBmdW5jdGlvbiBjcmVhdGVQYXJhZ3JhcGhOZWFyKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgc2VsID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICRmcm9tID0gc2VsLiRmcm9tLFxuICAgICR0byA9IHNlbC4kdG87XG4gIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLkFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpIHJldHVybiBmYWxzZTtcbiAgdmFyIHR5cGUgPSBkZWZhdWx0QmxvY2tBdCgkdG8ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCR0by5pbmRleEFmdGVyKCkpKTtcbiAgaWYgKCF0eXBlIHx8ICF0eXBlLmlzVGV4dGJsb2NrKSByZXR1cm4gZmFsc2U7XG4gIGlmIChkaXNwYXRjaCkge1xuICAgIHZhciBzaWRlID0gKCEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJHRvLmluZGV4KCkgPCAkdG8ucGFyZW50LmNoaWxkQ291bnQgPyAkZnJvbSA6ICR0bykucG9zO1xuICAgIHZhciB0ciA9IHN0YXRlLnRyLmluc2VydChzaWRlLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBzaWRlICsgMSkpO1xuICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBsaWZ0RW1wdHlCbG9jayA9IGZ1bmN0aW9uIGxpZnRFbXB0eUJsb2NrKHN0YXRlLCBkaXNwYXRjaCkge1xuICB2YXIgJGN1cnNvciA9IHN0YXRlLnNlbGVjdGlvbi4kY3Vyc29yO1xuICBpZiAoISRjdXJzb3IgfHwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSByZXR1cm4gZmFsc2U7XG4gIGlmICgkY3Vyc29yLmRlcHRoID4gMSAmJiAkY3Vyc29yLmFmdGVyKCkgIT0gJGN1cnNvci5lbmQoLTEpKSB7XG4gICAgdmFyIGJlZm9yZSA9ICRjdXJzb3IuYmVmb3JlKCk7XG4gICAgaWYgKHByb3NlbWlycm9yVHJhbnNmb3JtLmNhblNwbGl0KHN0YXRlLmRvYywgYmVmb3JlKSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdChiZWZvcmUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHZhciByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLFxuICAgIHRhcmdldCA9IHJhbmdlICYmIHByb3NlbWlycm9yVHJhbnNmb3JtLmxpZnRUYXJnZXQocmFuZ2UpO1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBzcGxpdEJsb2NrQXMoc3BsaXROb2RlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb242ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uNi4kZnJvbSxcbiAgICAgICR0byA9IF9zdGF0ZSRzZWxlY3Rpb242LiR0bztcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uICYmIHN0YXRlLnNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5TcGxpdChzdGF0ZS5kb2MsICRmcm9tLnBvcykpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRmcm9tLmRlcHRoKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHR5cGVzID0gW107XG4gICAgdmFyIHNwbGl0RGVwdGgsXG4gICAgICBkZWZsdCxcbiAgICAgIGF0RW5kID0gZmFsc2UsXG4gICAgICBhdFN0YXJ0ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgZCA9ICRmcm9tLmRlcHRoOzsgZC0tKSB7XG4gICAgICB2YXIgbm9kZSA9ICRmcm9tLm5vZGUoZCk7XG4gICAgICBpZiAobm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgIGF0RW5kID0gJGZyb20uZW5kKGQpID09ICRmcm9tLnBvcyArICgkZnJvbS5kZXB0aCAtIGQpO1xuICAgICAgICBhdFN0YXJ0ID0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCk7XG4gICAgICAgIGRlZmx0ID0gZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZShkIC0gMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihkIC0gMSkpKTtcbiAgICAgICAgdmFyIHNwbGl0VHlwZSA9IHNwbGl0Tm9kZSAmJiBzcGxpdE5vZGUoJHRvLnBhcmVudCwgYXRFbmQsICRmcm9tKTtcbiAgICAgICAgdHlwZXMudW5zaGlmdChzcGxpdFR5cGUgfHwgKGF0RW5kICYmIGRlZmx0ID8ge1xuICAgICAgICAgIHR5cGU6IGRlZmx0XG4gICAgICAgIH0gOiBudWxsKSk7XG4gICAgICAgIHNwbGl0RGVwdGggPSBkO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkID09IDEpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdHlwZXMudW5zaGlmdChudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRyID0gc3RhdGUudHI7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIHByb3NlbWlycm9yU3RhdGUuVGV4dFNlbGVjdGlvbiB8fCBzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLkFsbFNlbGVjdGlvbikgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgdmFyIHNwbGl0UG9zID0gdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKTtcbiAgICB2YXIgY2FuID0gcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgdHlwZXMubGVuZ3RoLCB0eXBlcyk7XG4gICAgaWYgKCFjYW4pIHtcbiAgICAgIHR5cGVzWzBdID0gZGVmbHQgPyB7XG4gICAgICAgIHR5cGU6IGRlZmx0XG4gICAgICB9IDogbnVsbDtcbiAgICAgIGNhbiA9IHByb3NlbWlycm9yVHJhbnNmb3JtLmNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHR5cGVzLmxlbmd0aCwgdHlwZXMpO1xuICAgIH1cbiAgICBpZiAoIWNhbikgcmV0dXJuIGZhbHNlO1xuICAgIHRyLnNwbGl0KHNwbGl0UG9zLCB0eXBlcy5sZW5ndGgsIHR5cGVzKTtcbiAgICBpZiAoIWF0RW5kICYmIGF0U3RhcnQgJiYgJGZyb20ubm9kZShzcGxpdERlcHRoKS50eXBlICE9IGRlZmx0KSB7XG4gICAgICB2YXIgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoc3BsaXREZXB0aCkpLFxuICAgICAgICAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICBpZiAoZGVmbHQgJiYgJGZyb20ubm9kZShzcGxpdERlcHRoIC0gMSkuY2FuUmVwbGFjZVdpdGgoJGZpcnN0LmluZGV4KCksICRmaXJzdC5pbmRleCgpICsgMSwgZGVmbHQpKSB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZShzcGxpdERlcHRoKSksIGRlZmx0KTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbnZhciBzcGxpdEJsb2NrID0gc3BsaXRCbG9ja0FzKCk7XG52YXIgc3BsaXRCbG9ja0tlZXBNYXJrcyA9IGZ1bmN0aW9uIHNwbGl0QmxvY2tLZWVwTWFya3Moc3RhdGUsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBzcGxpdEJsb2NrKHN0YXRlLCBkaXNwYXRjaCAmJiBmdW5jdGlvbiAodHIpIHtcbiAgICB2YXIgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKTtcbiAgICBpZiAobWFya3MpIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICBkaXNwYXRjaCh0cik7XG4gIH0pO1xufTtcbnZhciBzZWxlY3RQYXJlbnROb2RlID0gZnVuY3Rpb24gc2VsZWN0UGFyZW50Tm9kZShzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgdmFyIF9zdGF0ZSRzZWxlY3Rpb243ID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjcuJGZyb20sXG4gICAgdG8gPSBfc3RhdGUkc2VsZWN0aW9uNy50byxcbiAgICBwb3M7XG4gIHZhciBzYW1lID0gJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICBpZiAoc2FtZSA9PSAwKSByZXR1cm4gZmFsc2U7XG4gIHBvcyA9ICRmcm9tLmJlZm9yZShzYW1lKTtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24ocHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHBvcykpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHNlbGVjdEFsbCA9IGZ1bmN0aW9uIHNlbGVjdEFsbChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgaWYgKGRpc3BhdGNoKSBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IHByb3NlbWlycm9yU3RhdGUuQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gam9pbk1heWJlQ2xlYXIoc3RhdGUsICRwb3MsIGRpc3BhdGNoKSB7XG4gIHZhciBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsXG4gICAgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcixcbiAgICBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgaWYgKCFiZWZvcmUgfHwgIWFmdGVyIHx8ICFiZWZvcmUudHlwZS5jb21wYXRpYmxlQ29udGVudChhZnRlci50eXBlKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWJlZm9yZS5jb250ZW50LnNpemUgJiYgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCAtIDEsIGluZGV4KSkge1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHJbXCJkZWxldGVcIl0oJHBvcy5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRwb3MucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoISRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkgfHwgIShhZnRlci5pc1RleHRibG9jayB8fCBwcm9zZW1pcnJvclRyYW5zZm9ybS5jYW5Kb2luKHN0YXRlLmRvYywgJHBvcy5wb3MpKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLmpvaW4oJHBvcy5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoLCBkaXIpIHtcbiAgdmFyIGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSxcbiAgICBhZnRlciA9ICRjdXQubm9kZUFmdGVyLFxuICAgIGNvbm4sXG4gICAgbWF0Y2g7XG4gIHZhciBpc29sYXRlZCA9IGJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmc7XG4gIGlmICghaXNvbGF0ZWQgJiYgam9pbk1heWJlQ2xlYXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSkgcmV0dXJuIHRydWU7XG4gIHZhciBjYW5EZWxBZnRlciA9ICFpc29sYXRlZCAmJiAkY3V0LnBhcmVudC5jYW5SZXBsYWNlKCRjdXQuaW5kZXgoKSwgJGN1dC5pbmRleCgpICsgMSk7XG4gIGlmIChjYW5EZWxBZnRlciAmJiAoY29ubiA9IChtYXRjaCA9IGJlZm9yZS5jb250ZW50TWF0Y2hBdChiZWZvcmUuY2hpbGRDb3VudCkpLmZpbmRXcmFwcGluZyhhZnRlci50eXBlKSkgJiYgbWF0Y2gubWF0Y2hUeXBlKGNvbm5bMF0gfHwgYWZ0ZXIudHlwZSkudmFsaWRFbmQpIHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgIHZhciBlbmQgPSAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLFxuICAgICAgICB3cmFwID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcbiAgICAgIGZvciAodmFyIGkgPSBjb25uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB3cmFwID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKGNvbm5baV0uY3JlYXRlKG51bGwsIHdyYXApKTtcbiAgICAgIHdyYXAgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oYmVmb3JlLmNvcHkod3JhcCkpO1xuICAgICAgdmFyIHRyID0gc3RhdGUudHIuc3RlcChuZXcgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uUmVwbGFjZUFyb3VuZFN0ZXAoJGN1dC5wb3MgLSAxLCBlbmQsICRjdXQucG9zLCBlbmQsIG5ldyBwcm9zZW1pcnJvck1vZGVsLlNsaWNlKHdyYXAsIDEsIDApLCBjb25uLmxlbmd0aCwgdHJ1ZSkpO1xuICAgICAgdmFyICRqb2luQXQgPSB0ci5kb2MucmVzb2x2ZShlbmQgKyAyICogY29ubi5sZW5ndGgpO1xuICAgICAgaWYgKCRqb2luQXQubm9kZUFmdGVyICYmICRqb2luQXQubm9kZUFmdGVyLnR5cGUgPT0gYmVmb3JlLnR5cGUgJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0uY2FuSm9pbih0ci5kb2MsICRqb2luQXQucG9zKSkgdHIuam9pbigkam9pbkF0LnBvcyk7XG4gICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHNlbEFmdGVyID0gYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZyB8fCBkaXIgPiAwICYmIGlzb2xhdGVkID8gbnVsbCA6IHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uLmZpbmRGcm9tKCRjdXQsIDEpO1xuICB2YXIgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksXG4gICAgdGFyZ2V0ID0gcmFuZ2UgJiYgcHJvc2VtaXJyb3JUcmFuc2Zvcm0ubGlmdFRhcmdldChyYW5nZSk7XG4gIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQgPj0gJGN1dC5kZXB0aCkge1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY2FuRGVsQWZ0ZXIgJiYgdGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIiwgdHJ1ZSkgJiYgdGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSkge1xuICAgIHZhciBhdCA9IGJlZm9yZSxcbiAgICAgIF93cmFwID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgX3dyYXAucHVzaChhdCk7XG4gICAgICBpZiAoYXQuaXNUZXh0YmxvY2spIGJyZWFrO1xuICAgICAgYXQgPSBhdC5sYXN0Q2hpbGQ7XG4gICAgfVxuICAgIHZhciBhZnRlclRleHQgPSBhZnRlcixcbiAgICAgIGFmdGVyRGVwdGggPSAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclRleHQgPSBhZnRlclRleHQuZmlyc3RDaGlsZCkgYWZ0ZXJEZXB0aCsrO1xuICAgIGlmIChhdC5jYW5SZXBsYWNlKGF0LmNoaWxkQ291bnQsIGF0LmNoaWxkQ291bnQsIGFmdGVyVGV4dC5jb250ZW50KSkge1xuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHZhciBfZW5kID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSBfd3JhcC5sZW5ndGggLSAxOyBfaSA+PSAwOyBfaS0tKSBfZW5kID0gcHJvc2VtaXJyb3JNb2RlbC5GcmFnbWVudC5mcm9tKF93cmFwW19pXS5jb3B5KF9lbmQpKTtcbiAgICAgICAgdmFyIF90ciA9IHN0YXRlLnRyLnN0ZXAobmV3IHByb3NlbWlycm9yVHJhbnNmb3JtLlJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gX3dyYXAubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShfZW5kLCBfd3JhcC5sZW5ndGgsIDApLCAwLCB0cnVlKSk7XG4gICAgICAgIGRpc3BhdGNoKF90ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUZXh0YmxvY2tTaWRlKHNpZGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgc2VsID0gc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgJHBvcyA9IHNpZGUgPCAwID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICB2YXIgZGVwdGggPSAkcG9zLmRlcHRoO1xuICAgIHdoaWxlICgkcG9zLm5vZGUoZGVwdGgpLmlzSW5saW5lKSB7XG4gICAgICBpZiAoIWRlcHRoKSByZXR1cm4gZmFsc2U7XG4gICAgICBkZXB0aC0tO1xuICAgIH1cbiAgICBpZiAoISRwb3Mubm9kZShkZXB0aCkuaXNUZXh0YmxvY2spIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgc2lkZSA8IDAgPyAkcG9zLnN0YXJ0KGRlcHRoKSA6ICRwb3MuZW5kKGRlcHRoKSkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cbnZhciBzZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1NpZGUoLTEpO1xudmFyIHNlbGVjdFRleHRibG9ja0VuZCA9IHNlbGVjdFRleHRibG9ja1NpZGUoMSk7XG5mdW5jdGlvbiB3cmFwSW4obm9kZVR5cGUpIHtcbiAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgIHZhciBfc3RhdGUkc2VsZWN0aW9uOCA9IHN0YXRlLnNlbGVjdGlvbixcbiAgICAgICRmcm9tID0gX3N0YXRlJHNlbGVjdGlvbjguJGZyb20sXG4gICAgICAkdG8gPSBfc3RhdGUkc2VsZWN0aW9uOC4kdG87XG4gICAgdmFyIHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLFxuICAgICAgd3JhcHBpbmcgPSByYW5nZSAmJiBwcm9zZW1pcnJvclRyYW5zZm9ybS5maW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgaWYgKCF3cmFwcGluZykgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkgZGlzcGF0Y2goc3RhdGUudHIud3JhcChyYW5nZSwgd3JhcHBpbmcpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKG5vZGVUeXBlKSB7XG4gIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgYXBwbGljYWJsZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggJiYgIWFwcGxpY2FibGU7IGkrKykge1xuICAgICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24kcmFuZyA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV0sXG4gICAgICAgIGZyb20gPSBfc3RhdGUkc2VsZWN0aW9uJHJhbmcuJGZyb20ucG9zLFxuICAgICAgICB0byA9IF9zdGF0ZSRzZWxlY3Rpb24kcmFuZy4kdG8ucG9zO1xuICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUsIHBvcykge1xuICAgICAgICBpZiAoYXBwbGljYWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS5oYXNNYXJrdXAobm9kZVR5cGUsIGF0dHJzKSkgcmV0dXJuO1xuICAgICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgICAgYXBwbGljYWJsZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLFxuICAgICAgICAgICAgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghYXBwbGljYWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgdmFyIHRyID0gc3RhdGUudHI7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIF9zdGF0ZSRzZWxlY3Rpb24kcmFuZzIgPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW19pMl0sXG4gICAgICAgICAgX2Zyb20gPSBfc3RhdGUkc2VsZWN0aW9uJHJhbmcyLiRmcm9tLnBvcyxcbiAgICAgICAgICBfdG8gPSBfc3RhdGUkc2VsZWN0aW9uJHJhbmcyLiR0by5wb3M7XG4gICAgICAgIHRyLnNldEJsb2NrVHlwZShfZnJvbSwgX3RvLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgfVxuICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuZnVuY3Rpb24gbWFya0FwcGxpZXMoZG9jLCByYW5nZXMsIHR5cGUsIGVudGVyQXRvbXMpIHtcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgX3JhbmdlcyRpID0gcmFuZ2VzW2ldLFxuICAgICAgICAkZnJvbSA9IF9yYW5nZXMkaS4kZnJvbSxcbiAgICAgICAgJHRvID0gX3JhbmdlcyRpLiR0bztcbiAgICAgIHZhciBjYW4gPSAkZnJvbS5kZXB0aCA9PSAwID8gZG9jLmlubGluZUNvbnRlbnQgJiYgZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSkgOiBmYWxzZTtcbiAgICAgIGRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICAgIGlmIChjYW4gfHwgIWVudGVyQXRvbXMgJiYgbm9kZS5pc0F0b20gJiYgbm9kZS5pc0lubGluZSAmJiBwb3MgPj0gJGZyb20ucG9zICYmIHBvcyArIG5vZGUubm9kZVNpemUgPD0gJHRvLnBvcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgICAgfSk7XG4gICAgICBpZiAoY2FuKSByZXR1cm4ge1xuICAgICAgICB2OiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgX3JldDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBfcmV0ID0gX2xvb3AoKTtcbiAgICBpZiAoX3JldCkgcmV0dXJuIF9yZXQudjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZW1vdmVJbmxpbmVBdG9tcyhyYW5nZXMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgIHZhciBfcmFuZ2VzJGkyID0gcmFuZ2VzW2ldLFxuICAgICAgJGZyb20gPSBfcmFuZ2VzJGkyLiRmcm9tLFxuICAgICAgJHRvID0gX3JhbmdlcyRpMi4kdG87XG4gICAgJGZyb20uZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIGZ1bmN0aW9uIChub2RlLCBwb3MpIHtcbiAgICAgIGlmIChub2RlLmlzQXRvbSAmJiBub2RlLmNvbnRlbnQuc2l6ZSAmJiBub2RlLmlzSW5saW5lICYmIHBvcyA+PSAkZnJvbS5wb3MgJiYgcG9zICsgbm9kZS5ub2RlU2l6ZSA8PSAkdG8ucG9zKSB7XG4gICAgICAgIGlmIChwb3MgKyAxID4gJGZyb20ucG9zKSByZXN1bHQucHVzaChuZXcgcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb25SYW5nZSgkZnJvbSwgJGZyb20uZG9jLnJlc29sdmUocG9zICsgMSkpKTtcbiAgICAgICAgJGZyb20gPSAkZnJvbS5kb2MucmVzb2x2ZShwb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCRmcm9tLnBvcyA8ICR0by5wb3MpIHJlc3VsdC5wdXNoKG5ldyBwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvblJhbmdlKCRmcm9tLCAkdG8pKTtcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBfbG9vcDIoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdG9nZ2xlTWFyayhtYXJrVHlwZSkge1xuICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciByZW1vdmVXaGVuUHJlc2VudCA9IChvcHRpb25zICYmIG9wdGlvbnMucmVtb3ZlV2hlblByZXNlbnQpICE9PSBmYWxzZTtcbiAgdmFyIGVudGVyQXRvbXMgPSAob3B0aW9ucyAmJiBvcHRpb25zLmVudGVySW5saW5lQXRvbXMpICE9PSBmYWxzZTtcbiAgdmFyIGRyb3BTcGFjZSA9ICEob3B0aW9ucyAmJiBvcHRpb25zLmluY2x1ZGVXaGl0ZXNwYWNlKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICB2YXIgX3N0YXRlJHNlbGVjdGlvbjkgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICBlbXB0eSA9IF9zdGF0ZSRzZWxlY3Rpb245LmVtcHR5LFxuICAgICAgJGN1cnNvciA9IF9zdGF0ZSRzZWxlY3Rpb245LiRjdXJzb3IsXG4gICAgICByYW5nZXMgPSBfc3RhdGUkc2VsZWN0aW9uOS5yYW5nZXM7XG4gICAgaWYgKGVtcHR5ICYmICEkY3Vyc29yIHx8ICFtYXJrQXBwbGllcyhzdGF0ZS5kb2MsIHJhbmdlcywgbWFya1R5cGUsIGVudGVyQXRvbXMpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICBpZiAobWFya1R5cGUuaXNJblNldChzdGF0ZS5zdG9yZWRNYXJrcyB8fCAkY3Vyc29yLm1hcmtzKCkpKSBkaXNwYXRjaChzdGF0ZS50ci5yZW1vdmVTdG9yZWRNYXJrKG1hcmtUeXBlKSk7ZWxzZSBkaXNwYXRjaChzdGF0ZS50ci5hZGRTdG9yZWRNYXJrKG1hcmtUeXBlLmNyZWF0ZShhdHRycykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhZGQsXG4gICAgICAgICAgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgaWYgKCFlbnRlckF0b21zKSByYW5nZXMgPSByZW1vdmVJbmxpbmVBdG9tcyhyYW5nZXMpO1xuICAgICAgICBpZiAocmVtb3ZlV2hlblByZXNlbnQpIHtcbiAgICAgICAgICBhZGQgPSAhcmFuZ2VzLnNvbWUoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKHIuJGZyb20ucG9zLCByLiR0by5wb3MsIG1hcmtUeXBlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGQgPSAhcmFuZ2VzLmV2ZXJ5KGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICB2YXIgbWlzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihyLiRmcm9tLnBvcywgci4kdG8ucG9zLCBmdW5jdGlvbiAobm9kZSwgcG9zLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgaWYgKG1pc3NpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgbWlzc2luZyA9ICFtYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpICYmICEhcGFyZW50ICYmIHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSAmJiAhKG5vZGUuaXNUZXh0ICYmIC9eXFxzKiQvLnRlc3Qobm9kZS50ZXh0QmV0d2VlbihNYXRoLm1heCgwLCByLiRmcm9tLnBvcyAtIHBvcyksIE1hdGgubWluKG5vZGUubm9kZVNpemUsIHIuJHRvLnBvcyAtIHBvcykpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhbWlzc2luZztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfcmFuZ2VzJGkzID0gcmFuZ2VzW2ldLFxuICAgICAgICAgICAgJGZyb20gPSBfcmFuZ2VzJGkzLiRmcm9tLFxuICAgICAgICAgICAgJHRvID0gX3JhbmdlcyRpMy4kdG87XG4gICAgICAgICAgaWYgKCFhZGQpIHtcbiAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gJGZyb20ucG9zLFxuICAgICAgICAgICAgICB0byA9ICR0by5wb3MsXG4gICAgICAgICAgICAgIHN0YXJ0ID0gJGZyb20ubm9kZUFmdGVyLFxuICAgICAgICAgICAgICBlbmQgPSAkdG8ubm9kZUJlZm9yZTtcbiAgICAgICAgICAgIHZhciBzcGFjZVN0YXJ0ID0gZHJvcFNwYWNlICYmIHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgdmFyIHNwYWNlRW5kID0gZHJvcFNwYWNlICYmIGVuZCAmJiBlbmQuaXNUZXh0ID8gL1xccyokLy5leGVjKGVuZC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgaWYgKGZyb20gKyBzcGFjZVN0YXJ0IDwgdG8pIHtcbiAgICAgICAgICAgICAgZnJvbSArPSBzcGFjZVN0YXJ0O1xuICAgICAgICAgICAgICB0byAtPSBzcGFjZUVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5mdW5jdGlvbiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBpc0pvaW5hYmxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodHIpIHtcbiAgICBpZiAoIXRyLmlzR2VuZXJpYykgcmV0dXJuIGRpc3BhdGNoKHRyKTtcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJhbmdlcy5sZW5ndGg7IGorKykgcmFuZ2VzW2pdID0gbWFwLm1hcChyYW5nZXNbal0pO1xuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24gKF9zLCBfZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlcy5wdXNoKGZyb20sIHRvKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgam9pbmFibGUgPSBbXTtcbiAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCByYW5nZXMubGVuZ3RoOyBfaTMgKz0gMikge1xuICAgICAgdmFyIGZyb20gPSByYW5nZXNbX2kzXSxcbiAgICAgICAgdG8gPSByYW5nZXNbX2kzICsgMV07XG4gICAgICB2YXIgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSxcbiAgICAgICAgZGVwdGggPSAkZnJvbS5zaGFyZWREZXB0aCh0byksXG4gICAgICAgIHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSwgcG9zID0gJGZyb20uYWZ0ZXIoZGVwdGggKyAxKTsgcG9zIDw9IHRvOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBhZnRlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgaWYgKCFhZnRlcikgYnJlYWs7XG4gICAgICAgIGlmIChpbmRleCAmJiBqb2luYWJsZS5pbmRleE9mKHBvcykgPT0gLTEpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gcGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgICAgaWYgKGJlZm9yZS50eXBlID09IGFmdGVyLnR5cGUgJiYgaXNKb2luYWJsZShiZWZvcmUsIGFmdGVyKSkgam9pbmFibGUucHVzaChwb3MpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBhZnRlci5ub2RlU2l6ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgam9pbmFibGUuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEgLSBiO1xuICAgIH0pO1xuICAgIGZvciAodmFyIF9pNCA9IGpvaW5hYmxlLmxlbmd0aCAtIDE7IF9pNCA+PSAwOyBfaTQtLSkge1xuICAgICAgaWYgKHByb3NlbWlycm9yVHJhbnNmb3JtLmNhbkpvaW4odHIuZG9jLCBqb2luYWJsZVtfaTRdKSkgdHIuam9pbihqb2luYWJsZVtfaTRdKTtcbiAgICB9XG4gICAgZGlzcGF0Y2godHIpO1xuICB9O1xufVxuZnVuY3Rpb24gYXV0b0pvaW4oY29tbWFuZCwgaXNKb2luYWJsZSkge1xuICB2YXIgY2FuSm9pbiA9IEFycmF5LmlzQXJyYXkoaXNKb2luYWJsZSkgPyBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBpc0pvaW5hYmxlLmluZGV4T2Yobm9kZS50eXBlLm5hbWUpID4gLTE7XG4gIH0gOiBpc0pvaW5hYmxlO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgIHJldHVybiBjb21tYW5kKHN0YXRlLCBkaXNwYXRjaCAmJiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBjYW5Kb2luKSwgdmlldyk7XG4gIH07XG59XG5mdW5jdGlvbiBjaGFpbkNvbW1hbmRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY29tbWFuZHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgY29tbWFuZHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSBpZiAoY29tbWFuZHNbaV0oc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxudmFyIGJhY2tzcGFjZSA9IGNoYWluQ29tbWFuZHMoZGVsZXRlU2VsZWN0aW9uLCBqb2luQmFja3dhcmQsIHNlbGVjdE5vZGVCYWNrd2FyZCk7XG52YXIgZGVsID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5Gb3J3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCk7XG52YXIgcGNCYXNlS2V5bWFwID0ge1xuICBcIkVudGVyXCI6IGNoYWluQ29tbWFuZHMobmV3bGluZUluQ29kZSwgY3JlYXRlUGFyYWdyYXBoTmVhciwgbGlmdEVtcHR5QmxvY2ssIHNwbGl0QmxvY2spLFxuICBcIk1vZC1FbnRlclwiOiBleGl0Q29kZSxcbiAgXCJCYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIk1vZC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICBcIlNoaWZ0LUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gIFwiRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtRGVsZXRlXCI6IGRlbCxcbiAgXCJNb2QtYVwiOiBzZWxlY3RBbGxcbn07XG52YXIgbWFjQmFzZUtleW1hcCA9IHtcbiAgXCJDdHJsLWhcIjogcGNCYXNlS2V5bWFwW1wiQmFja3NwYWNlXCJdLFxuICBcIkFsdC1CYWNrc3BhY2VcIjogcGNCYXNlS2V5bWFwW1wiTW9kLUJhY2tzcGFjZVwiXSxcbiAgXCJDdHJsLWRcIjogcGNCYXNlS2V5bWFwW1wiRGVsZXRlXCJdLFxuICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICBcIkFsdC1EZWxldGVcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgXCJBbHQtZFwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICBcIkN0cmwtYVwiOiBzZWxlY3RUZXh0YmxvY2tTdGFydCxcbiAgXCJDdHJsLWVcIjogc2VsZWN0VGV4dGJsb2NrRW5kXG59O1xuZm9yICh2YXIga2V5IGluIHBjQmFzZUtleW1hcCkgbWFjQmFzZUtleW1hcFtrZXldID0gcGNCYXNlS2V5bWFwW2tleV07XG52YXIgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogdHlwZW9mIG9zICE9IFwidW5kZWZpbmVkXCIgJiYgb3MucGxhdGZvcm0gPyBvcy5wbGF0Zm9ybSgpID09IFwiZGFyd2luXCIgOiBmYWxzZTtcbnZhciBiYXNlS2V5bWFwID0gbWFjID8gbWFjQmFzZUtleW1hcCA6IHBjQmFzZUtleW1hcDtcbmV4cG9ydHMuYXV0b0pvaW4gPSBhdXRvSm9pbjtcbmV4cG9ydHMuYmFzZUtleW1hcCA9IGJhc2VLZXltYXA7XG5leHBvcnRzLmNoYWluQ29tbWFuZHMgPSBjaGFpbkNvbW1hbmRzO1xuZXhwb3J0cy5jcmVhdGVQYXJhZ3JhcGhOZWFyID0gY3JlYXRlUGFyYWdyYXBoTmVhcjtcbmV4cG9ydHMuZGVsZXRlU2VsZWN0aW9uID0gZGVsZXRlU2VsZWN0aW9uO1xuZXhwb3J0cy5leGl0Q29kZSA9IGV4aXRDb2RlO1xuZXhwb3J0cy5qb2luQmFja3dhcmQgPSBqb2luQmFja3dhcmQ7XG5leHBvcnRzLmpvaW5Eb3duID0gam9pbkRvd247XG5leHBvcnRzLmpvaW5Gb3J3YXJkID0gam9pbkZvcndhcmQ7XG5leHBvcnRzLmpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9IGpvaW5UZXh0YmxvY2tCYWNrd2FyZDtcbmV4cG9ydHMuam9pblRleHRibG9ja0ZvcndhcmQgPSBqb2luVGV4dGJsb2NrRm9yd2FyZDtcbmV4cG9ydHMuam9pblVwID0gam9pblVwO1xuZXhwb3J0cy5saWZ0ID0gbGlmdDtcbmV4cG9ydHMubGlmdEVtcHR5QmxvY2sgPSBsaWZ0RW1wdHlCbG9jaztcbmV4cG9ydHMubWFjQmFzZUtleW1hcCA9IG1hY0Jhc2VLZXltYXA7XG5leHBvcnRzLm5ld2xpbmVJbkNvZGUgPSBuZXdsaW5lSW5Db2RlO1xuZXhwb3J0cy5wY0Jhc2VLZXltYXAgPSBwY0Jhc2VLZXltYXA7XG5leHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbmV4cG9ydHMuc2VsZWN0Tm9kZUJhY2t3YXJkID0gc2VsZWN0Tm9kZUJhY2t3YXJkO1xuZXhwb3J0cy5zZWxlY3ROb2RlRm9yd2FyZCA9IHNlbGVjdE5vZGVGb3J3YXJkO1xuZXhwb3J0cy5zZWxlY3RQYXJlbnROb2RlID0gc2VsZWN0UGFyZW50Tm9kZTtcbmV4cG9ydHMuc2VsZWN0VGV4dGJsb2NrRW5kID0gc2VsZWN0VGV4dGJsb2NrRW5kO1xuZXhwb3J0cy5zZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1N0YXJ0O1xuZXhwb3J0cy5zZXRCbG9ja1R5cGUgPSBzZXRCbG9ja1R5cGU7XG5leHBvcnRzLnNwbGl0QmxvY2sgPSBzcGxpdEJsb2NrO1xuZXhwb3J0cy5zcGxpdEJsb2NrQXMgPSBzcGxpdEJsb2NrQXM7XG5leHBvcnRzLnNwbGl0QmxvY2tLZWVwTWFya3MgPSBzcGxpdEJsb2NrS2VlcE1hcmtzO1xuZXhwb3J0cy50b2dnbGVNYXJrID0gdG9nZ2xlTWFyaztcbmV4cG9ydHMud3JhcEluID0gd3JhcEluO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/prosemirror-commands@1.7.1/node_modules/prosemirror-commands/dist/index.cjs\n");

/***/ })

};
;