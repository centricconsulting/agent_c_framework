"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap+extension-link@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1";
exports.ids = ["vendor-chunks/@tiptap+extension-link@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@tiptap+extension-link@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1/node_modules/@tiptap/extension-link/dist/index.cjs":
/*!**************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@tiptap+extension-link@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1/node_modules/@tiptap/extension-link/dist/index.cjs ***!
  \**************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar core = __webpack_require__(/*! @tiptap/core */ \"(ssr)/../../node_modules/.pnpm/@tiptap+core@2.26.1_@tiptap+pm@2.26.1/node_modules/@tiptap/core/dist/index.cjs\");\nvar linkifyjs = __webpack_require__(/*! linkifyjs */ \"(ssr)/../../node_modules/.pnpm/linkifyjs@4.3.2/node_modules/linkifyjs/dist/linkify.mjs\");\nvar state = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/../../node_modules/.pnpm/@tiptap+pm@2.26.1/node_modules/@tiptap/pm/state/dist/index.cjs\");\n\n// From DOMPurify\n// https://github.com/cure53/DOMPurify/blob/main/src/regexp.ts\nconst UNICODE_WHITESPACE_PATTERN = '[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]';\nconst UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);\nconst UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);\nconst UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, 'g');\n\n/**\n * Check if the provided tokens form a valid link structure, which can either be a single link token\n * or a link token surrounded by parentheses or square brackets.\n *\n * This ensures that only complete and valid text is hyperlinked, preventing cases where a valid\n * top-level domain (TLD) is immediately followed by an invalid character, like a number. For\n * example, with the `find` method from Linkify, entering `example.com1` would result in\n * `example.com` being linked and the trailing `1` left as plain text. By using the `tokenize`\n * method, we can perform more comprehensive validation on the input text.\n */\nfunction isValidLinkStructure(tokens) {\n    if (tokens.length === 1) {\n        return tokens[0].isLink;\n    }\n    if (tokens.length === 3 && tokens[1].isLink) {\n        return ['()', '[]'].includes(tokens[0].value + tokens[2].value);\n    }\n    return false;\n}\n/**\n * This plugin allows you to automatically add links to your editor.\n * @param options The plugin options\n * @returns The plugin instance\n */\nfunction autolink(options) {\n    return new state.Plugin({\n        key: new state.PluginKey('autolink'),\n        appendTransaction: (transactions, oldState, newState) => {\n            /**\n             * Does the transaction change the document?\n             */\n            const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n            /**\n             * Prevent autolink if the transaction is not a document change or if the transaction has the meta `preventAutolink`.\n             */\n            const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));\n            /**\n             * Prevent autolink if the transaction is not a document change\n             * or if the transaction has the meta `preventAutolink`.\n             */\n            if (!docChanges || preventAutolink) {\n                return;\n            }\n            const { tr } = newState;\n            const transform = core.combineTransactionSteps(oldState.doc, [...transactions]);\n            const changes = core.getChangedRanges(transform);\n            changes.forEach(({ newRange }) => {\n                // Now letâ€™s see if we can add new links.\n                const nodesInChangedRanges = core.findChildrenInRange(newState.doc, newRange, node => node.isTextblock);\n                let textBlock;\n                let textBeforeWhitespace;\n                if (nodesInChangedRanges.length > 1) {\n                    // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n                }\n                else if (nodesInChangedRanges.length) {\n                    const endText = newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ');\n                    if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {\n                        return;\n                    }\n                    textBlock = nodesInChangedRanges[0];\n                    textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n                }\n                if (textBlock && textBeforeWhitespace) {\n                    const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);\n                    if (wordsBeforeWhitespace.length <= 0) {\n                        return false;\n                    }\n                    const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n                    const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n                    if (!lastWordBeforeSpace) {\n                        return false;\n                    }\n                    const linksBeforeSpace = linkifyjs.tokenize(lastWordBeforeSpace).map(t => t.toObject(options.defaultProtocol));\n                    if (!isValidLinkStructure(linksBeforeSpace)) {\n                        return false;\n                    }\n                    linksBeforeSpace\n                        .filter(link => link.isLink)\n                        // Calculate link position.\n                        .map(link => ({\n                        ...link,\n                        from: lastWordAndBlockOffset + link.start + 1,\n                        to: lastWordAndBlockOffset + link.end + 1,\n                    }))\n                        // ignore link inside code mark\n                        .filter(link => {\n                        if (!newState.schema.marks.code) {\n                            return true;\n                        }\n                        return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);\n                    })\n                        // validate link\n                        .filter(link => options.validate(link.value))\n                        // check whether should autolink\n                        .filter(link => options.shouldAutoLink(link.value))\n                        // Add link mark.\n                        .forEach(link => {\n                        if (core.getMarksBetween(link.from, link.to, newState.doc).some(item => item.mark.type === options.type)) {\n                            return;\n                        }\n                        tr.addMark(link.from, link.to, options.type.create({\n                            href: link.href,\n                        }));\n                    });\n                }\n            });\n            if (!tr.steps.length) {\n                return;\n            }\n            return tr;\n        },\n    });\n}\n\nfunction clickHandler(options) {\n    return new state.Plugin({\n        key: new state.PluginKey('handleClickLink'),\n        props: {\n            handleClick: (view, pos, event) => {\n                var _a, _b;\n                if (event.button !== 0) {\n                    return false;\n                }\n                if (!view.editable) {\n                    return false;\n                }\n                let a = event.target;\n                const els = [];\n                while (a.nodeName !== 'DIV') {\n                    els.push(a);\n                    a = a.parentNode;\n                }\n                if (!els.find(value => value.nodeName === 'A')) {\n                    return false;\n                }\n                const attrs = core.getAttributes(view.state, options.type.name);\n                const link = event.target;\n                const href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;\n                const target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;\n                if (link && href) {\n                    window.open(href, target);\n                    return true;\n                }\n                return false;\n            },\n        },\n    });\n}\n\nfunction pasteHandler(options) {\n    return new state.Plugin({\n        key: new state.PluginKey('handlePasteLink'),\n        props: {\n            handlePaste: (view, event, slice) => {\n                const { state } = view;\n                const { selection } = state;\n                const { empty } = selection;\n                if (empty) {\n                    return false;\n                }\n                let textContent = '';\n                slice.content.forEach(node => {\n                    textContent += node.textContent;\n                });\n                const link = linkifyjs.find(textContent, { defaultProtocol: options.defaultProtocol }).find(item => item.isLink && item.value === textContent);\n                if (!textContent || !link) {\n                    return false;\n                }\n                return options.editor.commands.setMark(options.type, {\n                    href: link.href,\n                });\n            },\n        },\n    });\n}\n\nconst pasteRegex = /https?:\\/\\/(?:www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z]{2,}\\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;\nfunction isAllowedUri(uri, protocols) {\n    const allowedProtocols = [\n        'http',\n        'https',\n        'ftp',\n        'ftps',\n        'mailto',\n        'tel',\n        'callto',\n        'sms',\n        'cid',\n        'xmpp',\n    ];\n    if (protocols) {\n        protocols.forEach(protocol => {\n            const nextProtocol = typeof protocol === 'string' ? protocol : protocol.scheme;\n            if (nextProtocol) {\n                allowedProtocols.push(nextProtocol);\n            }\n        });\n    }\n    return (!uri\n        || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, '').match(new RegExp(\n        // eslint-disable-next-line no-useless-escape\n        `^(?:(?:${allowedProtocols.join('|')}):|[^a-z]|[a-z0-9+.\\-]+(?:[^a-z+.\\-:]|$))`, 'i')));\n}\n/**\n * This extension allows you to create links.\n * @see https://www.tiptap.dev/api/marks/link\n */\nconst Link = core.Mark.create({\n    name: 'link',\n    priority: 1000,\n    keepOnSplit: false,\n    exitable: true,\n    onCreate() {\n        if (this.options.validate && !this.options.shouldAutoLink) {\n            // Copy the validate function to the shouldAutoLink option\n            this.options.shouldAutoLink = this.options.validate;\n            console.warn('The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.');\n        }\n        this.options.protocols.forEach(protocol => {\n            if (typeof protocol === 'string') {\n                linkifyjs.registerCustomProtocol(protocol);\n                return;\n            }\n            linkifyjs.registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);\n        });\n    },\n    onDestroy() {\n        linkifyjs.reset();\n    },\n    inclusive() {\n        return this.options.autolink;\n    },\n    addOptions() {\n        return {\n            openOnClick: true,\n            linkOnPaste: true,\n            autolink: true,\n            protocols: [],\n            defaultProtocol: 'http',\n            HTMLAttributes: {\n                target: '_blank',\n                rel: 'noopener noreferrer nofollow',\n                class: null,\n            },\n            isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),\n            validate: url => !!url,\n            shouldAutoLink: url => !!url,\n        };\n    },\n    addAttributes() {\n        return {\n            href: {\n                default: null,\n                parseHTML(element) {\n                    return element.getAttribute('href');\n                },\n            },\n            target: {\n                default: this.options.HTMLAttributes.target,\n            },\n            rel: {\n                default: this.options.HTMLAttributes.rel,\n            },\n            class: {\n                default: this.options.HTMLAttributes.class,\n            },\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'a[href]',\n                getAttrs: dom => {\n                    const href = dom.getAttribute('href');\n                    // prevent XSS attacks\n                    if (!href\n                        || !this.options.isAllowedUri(href, {\n                            defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n                            protocols: this.options.protocols,\n                            defaultProtocol: this.options.defaultProtocol,\n                        })) {\n                        return false;\n                    }\n                    return null;\n                },\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        // prevent XSS attacks\n        if (!this.options.isAllowedUri(HTMLAttributes.href, {\n            defaultValidate: href => !!isAllowedUri(href, this.options.protocols),\n            protocols: this.options.protocols,\n            defaultProtocol: this.options.defaultProtocol,\n        })) {\n            // strip out the href\n            return [\n                'a',\n                core.mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: '' }),\n                0,\n            ];\n        }\n        return ['a', core.mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setLink: attributes => ({ chain }) => {\n                const { href } = attributes;\n                if (!this.options.isAllowedUri(href, {\n                    defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n                    protocols: this.options.protocols,\n                    defaultProtocol: this.options.defaultProtocol,\n                })) {\n                    return false;\n                }\n                return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run();\n            },\n            toggleLink: attributes => ({ chain }) => {\n                const { href } = attributes;\n                if (!this.options.isAllowedUri(href, {\n                    defaultValidate: url => !!isAllowedUri(url, this.options.protocols),\n                    protocols: this.options.protocols,\n                    defaultProtocol: this.options.defaultProtocol,\n                })) {\n                    return false;\n                }\n                return chain()\n                    .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n                    .setMeta('preventAutolink', true)\n                    .run();\n            },\n            unsetLink: () => ({ chain }) => {\n                return chain()\n                    .unsetMark(this.name, { extendEmptyMarkRange: true })\n                    .setMeta('preventAutolink', true)\n                    .run();\n            },\n        };\n    },\n    addPasteRules() {\n        return [\n            core.markPasteRule({\n                find: text => {\n                    const foundLinks = [];\n                    if (text) {\n                        const { protocols, defaultProtocol } = this.options;\n                        const links = linkifyjs.find(text).filter(item => item.isLink\n                            && this.options.isAllowedUri(item.value, {\n                                defaultValidate: href => !!isAllowedUri(href, protocols),\n                                protocols,\n                                defaultProtocol,\n                            }));\n                        if (links.length) {\n                            links.forEach(link => foundLinks.push({\n                                text: link.value,\n                                data: {\n                                    href: link.href,\n                                },\n                                index: link.start,\n                            }));\n                        }\n                    }\n                    return foundLinks;\n                },\n                type: this.type,\n                getAttributes: match => {\n                    var _a;\n                    return {\n                        href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href,\n                    };\n                },\n            }),\n        ];\n    },\n    addProseMirrorPlugins() {\n        const plugins = [];\n        const { protocols, defaultProtocol } = this.options;\n        if (this.options.autolink) {\n            plugins.push(autolink({\n                type: this.type,\n                defaultProtocol: this.options.defaultProtocol,\n                validate: url => this.options.isAllowedUri(url, {\n                    defaultValidate: href => !!isAllowedUri(href, protocols),\n                    protocols,\n                    defaultProtocol,\n                }),\n                shouldAutoLink: this.options.shouldAutoLink,\n            }));\n        }\n        if (this.options.openOnClick === true) {\n            plugins.push(clickHandler({\n                type: this.type,\n            }));\n        }\n        if (this.options.linkOnPaste) {\n            plugins.push(pasteHandler({\n                editor: this.editor,\n                defaultProtocol: this.options.defaultProtocol,\n                type: this.type,\n            }));\n        }\n        return plugins;\n    },\n});\n\nexports.Link = Link;\nexports[\"default\"] = Link;\nexports.isAllowedUri = isAllowedUri;\nexports.pasteRegex = pasteRegex;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0aXB0YXArZXh0ZW5zaW9uLWxpbmtAMi4yNi4xX0B0aXB0YXArY29yZUAyLjI2LjFfQHRpcHRhcCtwbUAyLjI2LjFfX0B0aXB0YXArcG1AMi4yNi4xL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saW5rL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsV0FBVyxtQkFBTyxDQUFDLG1JQUFjO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHlHQUFXO0FBQ25DLFlBQVksbUJBQU8sQ0FBQyx1SEFBa0I7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDJCQUEyQjtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtB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QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQsWUFBWTtBQUNaLGtCQUFlO0FBQ2Ysb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsiL1VzZXJzL0Vib290aC9hZ2VudF9jX2ZyYW1ld29yay9zcmMvcmVhbHRpbWVfY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9AdGlwdGFwK2V4dGVuc2lvbi1saW5rQDIuMjYuMV9AdGlwdGFwK2NvcmVAMi4yNi4xX0B0aXB0YXArcG1AMi4yNi4xX19AdGlwdGFwK3BtQDIuMjYuMS9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGluay9kaXN0L2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQHRpcHRhcC9jb3JlJyk7XG52YXIgbGlua2lmeWpzID0gcmVxdWlyZSgnbGlua2lmeWpzJyk7XG52YXIgc3RhdGUgPSByZXF1aXJlKCdAdGlwdGFwL3BtL3N0YXRlJyk7XG5cbi8vIEZyb20gRE9NUHVyaWZ5XG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3VyZTUzL0RPTVB1cmlmeS9ibG9iL21haW4vc3JjL3JlZ2V4cC50c1xuY29uc3QgVU5JQ09ERV9XSElURVNQQUNFX1BBVFRFUk4gPSAnW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXSc7XG5jb25zdCBVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVggPSBuZXcgUmVnRXhwKFVOSUNPREVfV0hJVEVTUEFDRV9QQVRURVJOKTtcbmNvbnN0IFVOSUNPREVfV0hJVEVTUEFDRV9SRUdFWF9FTkQgPSBuZXcgUmVnRXhwKGAke1VOSUNPREVfV0hJVEVTUEFDRV9QQVRURVJOfSRgKTtcbmNvbnN0IFVOSUNPREVfV0hJVEVTUEFDRV9SRUdFWF9HTE9CQUwgPSBuZXcgUmVnRXhwKFVOSUNPREVfV0hJVEVTUEFDRV9QQVRURVJOLCAnZycpO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBwcm92aWRlZCB0b2tlbnMgZm9ybSBhIHZhbGlkIGxpbmsgc3RydWN0dXJlLCB3aGljaCBjYW4gZWl0aGVyIGJlIGEgc2luZ2xlIGxpbmsgdG9rZW5cbiAqIG9yIGEgbGluayB0b2tlbiBzdXJyb3VuZGVkIGJ5IHBhcmVudGhlc2VzIG9yIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCBvbmx5IGNvbXBsZXRlIGFuZCB2YWxpZCB0ZXh0IGlzIGh5cGVybGlua2VkLCBwcmV2ZW50aW5nIGNhc2VzIHdoZXJlIGEgdmFsaWRcbiAqIHRvcC1sZXZlbCBkb21haW4gKFRMRCkgaXMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gaW52YWxpZCBjaGFyYWN0ZXIsIGxpa2UgYSBudW1iZXIuIEZvclxuICogZXhhbXBsZSwgd2l0aCB0aGUgYGZpbmRgIG1ldGhvZCBmcm9tIExpbmtpZnksIGVudGVyaW5nIGBleGFtcGxlLmNvbTFgIHdvdWxkIHJlc3VsdCBpblxuICogYGV4YW1wbGUuY29tYCBiZWluZyBsaW5rZWQgYW5kIHRoZSB0cmFpbGluZyBgMWAgbGVmdCBhcyBwbGFpbiB0ZXh0LiBCeSB1c2luZyB0aGUgYHRva2VuaXplYFxuICogbWV0aG9kLCB3ZSBjYW4gcGVyZm9ybSBtb3JlIGNvbXByZWhlbnNpdmUgdmFsaWRhdGlvbiBvbiB0aGUgaW5wdXQgdGV4dC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZExpbmtTdHJ1Y3R1cmUodG9rZW5zKSB7XG4gICAgaWYgKHRva2Vucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRva2Vuc1swXS5pc0xpbms7XG4gICAgfVxuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAzICYmIHRva2Vuc1sxXS5pc0xpbmspIHtcbiAgICAgICAgcmV0dXJuIFsnKCknLCAnW10nXS5pbmNsdWRlcyh0b2tlbnNbMF0udmFsdWUgKyB0b2tlbnNbMl0udmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFRoaXMgcGx1Z2luIGFsbG93cyB5b3UgdG8gYXV0b21hdGljYWxseSBhZGQgbGlua3MgdG8geW91ciBlZGl0b3IuXG4gKiBAcGFyYW0gb3B0aW9ucyBUaGUgcGx1Z2luIG9wdGlvbnNcbiAqIEByZXR1cm5zIFRoZSBwbHVnaW4gaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYXV0b2xpbmsob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgc3RhdGUuUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgc3RhdGUuUGx1Z2luS2V5KCdhdXRvbGluaycpLFxuICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERvZXMgdGhlIHRyYW5zYWN0aW9uIGNoYW5nZSB0aGUgZG9jdW1lbnQ/XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkKSAmJiAhb2xkU3RhdGUuZG9jLmVxKG5ld1N0YXRlLmRvYyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZXZlbnQgYXV0b2xpbmsgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIG5vdCBhIGRvY3VtZW50IGNoYW5nZSBvciBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIHRoZSBtZXRhIGBwcmV2ZW50QXV0b2xpbmtgLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBwcmV2ZW50QXV0b2xpbmsgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwcmV2ZW50QXV0b2xpbmsnKSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZXZlbnQgYXV0b2xpbmsgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIG5vdCBhIGRvY3VtZW50IGNoYW5nZVxuICAgICAgICAgICAgICogb3IgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyB0aGUgbWV0YSBgcHJldmVudEF1dG9saW5rYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFkb2NDaGFuZ2VzIHx8IHByZXZlbnRBdXRvbGluaykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gY29yZS5jb21iaW5lVHJhbnNhY3Rpb25TdGVwcyhvbGRTdGF0ZS5kb2MsIFsuLi50cmFuc2FjdGlvbnNdKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBjb3JlLmdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtKTtcbiAgICAgICAgICAgIGNoYW5nZXMuZm9yRWFjaCgoeyBuZXdSYW5nZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gTm93IGxldOKAmXMgc2VlIGlmIHdlIGNhbiBhZGQgbmV3IGxpbmtzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzID0gY29yZS5maW5kQ2hpbGRyZW5JblJhbmdlKG5ld1N0YXRlLmRvYywgbmV3UmFuZ2UsIG5vZGUgPT4gbm9kZS5pc1RleHRibG9jayk7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRCbG9jaztcbiAgICAgICAgICAgICAgICBsZXQgdGV4dEJlZm9yZVdoaXRlc3BhY2U7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVzSW5DaGFuZ2VkUmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR3JhYiB0aGUgZmlyc3Qgbm9kZSB3aXRoaW4gdGhlIGNoYW5nZWQgcmFuZ2VzIChleC4gdGhlIGZpcnN0IG9mIHR3byBwYXJhZ3JhcGhzIHdoZW4gaGl0dGluZyBlbnRlcikuXG4gICAgICAgICAgICAgICAgICAgIHRleHRCbG9jayA9IG5vZGVzSW5DaGFuZ2VkUmFuZ2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QmVmb3JlV2hpdGVzcGFjZSA9IG5ld1N0YXRlLmRvYy50ZXh0QmV0d2Vlbih0ZXh0QmxvY2sucG9zLCB0ZXh0QmxvY2sucG9zICsgdGV4dEJsb2NrLm5vZGUubm9kZVNpemUsIHVuZGVmaW5lZCwgJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZXNJbkNoYW5nZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZFRleHQgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4obmV3UmFuZ2UuZnJvbSwgbmV3UmFuZ2UudG8sICcgJywgJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVhfRU5ELnRlc3QoZW5kVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmxvY2sgPSBub2Rlc0luQ2hhbmdlZFJhbmdlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEJlZm9yZVdoaXRlc3BhY2UgPSBuZXdTdGF0ZS5kb2MudGV4dEJldHdlZW4odGV4dEJsb2NrLnBvcywgbmV3UmFuZ2UudG8sIHVuZGVmaW5lZCwgJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHRCbG9jayAmJiB0ZXh0QmVmb3JlV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3b3Jkc0JlZm9yZVdoaXRlc3BhY2UgPSB0ZXh0QmVmb3JlV2hpdGVzcGFjZS5zcGxpdChVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVgpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmRzQmVmb3JlV2hpdGVzcGFjZS5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RXb3JkQmVmb3JlU3BhY2UgPSB3b3Jkc0JlZm9yZVdoaXRlc3BhY2Vbd29yZHNCZWZvcmVXaGl0ZXNwYWNlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0V29yZEFuZEJsb2NrT2Zmc2V0ID0gdGV4dEJsb2NrLnBvcyArIHRleHRCZWZvcmVXaGl0ZXNwYWNlLmxhc3RJbmRleE9mKGxhc3RXb3JkQmVmb3JlU3BhY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3RXb3JkQmVmb3JlU3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rc0JlZm9yZVNwYWNlID0gbGlua2lmeWpzLnRva2VuaXplKGxhc3RXb3JkQmVmb3JlU3BhY2UpLm1hcCh0ID0+IHQudG9PYmplY3Qob3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkTGlua1N0cnVjdHVyZShsaW5rc0JlZm9yZVNwYWNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpbmtzQmVmb3JlU3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiBsaW5rLmlzTGluaylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBsaW5rIHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChsaW5rID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5saW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbGFzdFdvcmRBbmRCbG9ja09mZnNldCArIGxpbmsuc3RhcnQgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IGxhc3RXb3JkQW5kQmxvY2tPZmZzZXQgKyBsaW5rLmVuZCArIDEsXG4gICAgICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGxpbmsgaW5zaWRlIGNvZGUgbWFya1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihsaW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3U3RhdGUuc2NoZW1hLm1hcmtzLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhbmV3U3RhdGUuZG9jLnJhbmdlSGFzTWFyayhsaW5rLmZyb20sIGxpbmsudG8sIG5ld1N0YXRlLnNjaGVtYS5tYXJrcy5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRlIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiBvcHRpb25zLnZhbGlkYXRlKGxpbmsudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgd2hldGhlciBzaG91bGQgYXV0b2xpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobGluayA9PiBvcHRpb25zLnNob3VsZEF1dG9MaW5rKGxpbmsudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGxpbmsgbWFyay5cbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGxpbmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcmUuZ2V0TWFya3NCZXR3ZWVuKGxpbmsuZnJvbSwgbGluay50bywgbmV3U3RhdGUuZG9jKS5zb21lKGl0ZW0gPT4gaXRlbS5tYXJrLnR5cGUgPT09IG9wdGlvbnMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGxpbmsuZnJvbSwgbGluay50bywgb3B0aW9ucy50eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogbGluay5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjbGlja0hhbmRsZXIob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgc3RhdGUuUGx1Z2luKHtcbiAgICAgICAga2V5OiBuZXcgc3RhdGUuUGx1Z2luS2V5KCdoYW5kbGVDbGlja0xpbmsnKSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZUNsaWNrOiAodmlldywgcG9zLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdmlldy5lZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBhID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGVscyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChhLm5vZGVOYW1lICE9PSAnRElWJykge1xuICAgICAgICAgICAgICAgICAgICBlbHMucHVzaChhKTtcbiAgICAgICAgICAgICAgICAgICAgYSA9IGEucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbHMuZmluZCh2YWx1ZSA9PiB2YWx1ZS5ub2RlTmFtZSA9PT0gJ0EnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gY29yZS5nZXRBdHRyaWJ1dGVzKHZpZXcuc3RhdGUsIG9wdGlvbnMudHlwZS5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGhyZWYgPSAoX2EgPSBsaW5rID09PSBudWxsIHx8IGxpbmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmsuaHJlZikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYXR0cnMuaHJlZjtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSAoX2IgPSBsaW5rID09PSBudWxsIHx8IGxpbmsgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmsudGFyZ2V0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBhdHRycy50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsgJiYgaHJlZikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihocmVmLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFzdGVIYW5kbGVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHN0YXRlLlBsdWdpbih7XG4gICAgICAgIGtleTogbmV3IHN0YXRlLlBsdWdpbktleSgnaGFuZGxlUGFzdGVMaW5rJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVQYXN0ZTogKHZpZXcsIGV2ZW50LCBzbGljZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICBzbGljZS5jb250ZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRDb250ZW50ICs9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluayA9IGxpbmtpZnlqcy5maW5kKHRleHRDb250ZW50LCB7IGRlZmF1bHRQcm90b2NvbDogb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgfSkuZmluZChpdGVtID0+IGl0ZW0uaXNMaW5rICYmIGl0ZW0udmFsdWUgPT09IHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRleHRDb250ZW50IHx8ICFsaW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZWRpdG9yLmNvbW1hbmRzLnNldE1hcmsob3B0aW9ucy50eXBlLCB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmNvbnN0IHBhc3RlUmVnZXggPSAvaHR0cHM/OlxcL1xcLyg/Ond3d1xcLik/Wy1hLXpBLVowLTlAOiUuXyt+Iz1dezEsMjU2fVxcLlthLXpBLVpdezIsfVxcYig/OlstYS16QS1aMC05QDolLl8rfiM9PyEmL10qKSg/OlstYS16QS1aMC05QDolLl8rfiM9PyEmL10qKS9naTtcbmZ1bmN0aW9uIGlzQWxsb3dlZFVyaSh1cmksIHByb3RvY29scykge1xuICAgIGNvbnN0IGFsbG93ZWRQcm90b2NvbHMgPSBbXG4gICAgICAgICdodHRwJyxcbiAgICAgICAgJ2h0dHBzJyxcbiAgICAgICAgJ2Z0cCcsXG4gICAgICAgICdmdHBzJyxcbiAgICAgICAgJ21haWx0bycsXG4gICAgICAgICd0ZWwnLFxuICAgICAgICAnY2FsbHRvJyxcbiAgICAgICAgJ3NtcycsXG4gICAgICAgICdjaWQnLFxuICAgICAgICAneG1wcCcsXG4gICAgXTtcbiAgICBpZiAocHJvdG9jb2xzKSB7XG4gICAgICAgIHByb3RvY29scy5mb3JFYWNoKHByb3RvY29sID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQcm90b2NvbCA9IHR5cGVvZiBwcm90b2NvbCA9PT0gJ3N0cmluZycgPyBwcm90b2NvbCA6IHByb3RvY29sLnNjaGVtZTtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICBhbGxvd2VkUHJvdG9jb2xzLnB1c2gobmV4dFByb3RvY29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoIXVyaVxuICAgICAgICB8fCB1cmkucmVwbGFjZShVTklDT0RFX1dISVRFU1BBQ0VfUkVHRVhfR0xPQkFMLCAnJykubWF0Y2gobmV3IFJlZ0V4cChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICAgIGBeKD86KD86JHthbGxvd2VkUHJvdG9jb2xzLmpvaW4oJ3wnKX0pOnxbXmEtel18W2EtejAtOSsuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpYCwgJ2knKSkpO1xufVxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBsaW5rcy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbWFya3MvbGlua1xuICovXG5jb25zdCBMaW5rID0gY29yZS5NYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2xpbmsnLFxuICAgIHByaW9yaXR5OiAxMDAwLFxuICAgIGtlZXBPblNwbGl0OiBmYWxzZSxcbiAgICBleGl0YWJsZTogdHJ1ZSxcbiAgICBvbkNyZWF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52YWxpZGF0ZSAmJiAhdGhpcy5vcHRpb25zLnNob3VsZEF1dG9MaW5rKSB7XG4gICAgICAgICAgICAvLyBDb3B5IHRoZSB2YWxpZGF0ZSBmdW5jdGlvbiB0byB0aGUgc2hvdWxkQXV0b0xpbmsgb3B0aW9uXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmsgPSB0aGlzLm9wdGlvbnMudmFsaWRhdGU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBgdmFsaWRhdGVgIG9wdGlvbiBpcyBkZXByZWNhdGVkLiBSZW5hbWUgdG8gdGhlIGBzaG91bGRBdXRvTGlua2Agb3B0aW9uIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLnByb3RvY29scy5mb3JFYWNoKHByb3RvY29sID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2wgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbGlua2lmeWpzLnJlZ2lzdGVyQ3VzdG9tUHJvdG9jb2wocHJvdG9jb2wpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtpZnlqcy5yZWdpc3RlckN1c3RvbVByb3RvY29sKHByb3RvY29sLnNjaGVtZSwgcHJvdG9jb2wub3B0aW9uYWxTbGFzaGVzKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBvbkRlc3Ryb3koKSB7XG4gICAgICAgIGxpbmtpZnlqcy5yZXNldCgpO1xuICAgIH0sXG4gICAgaW5jbHVzaXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmF1dG9saW5rO1xuICAgIH0sXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wZW5PbkNsaWNrOiB0cnVlLFxuICAgICAgICAgICAgbGlua09uUGFzdGU6IHRydWUsXG4gICAgICAgICAgICBhdXRvbGluazogdHJ1ZSxcbiAgICAgICAgICAgIHByb3RvY29sczogW10sXG4gICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6ICdodHRwJyxcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiAnX2JsYW5rJyxcbiAgICAgICAgICAgICAgICByZWw6ICdub29wZW5lciBub3JlZmVycmVyIG5vZm9sbG93JyxcbiAgICAgICAgICAgICAgICBjbGFzczogbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0FsbG93ZWRVcmk6ICh1cmwsIGN0eCkgPT4gISFpc0FsbG93ZWRVcmkodXJsLCBjdHgucHJvdG9jb2xzKSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB1cmwgPT4gISF1cmwsXG4gICAgICAgICAgICBzaG91bGRBdXRvTGluazogdXJsID0+ICEhdXJsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhyZWY6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLnRhcmdldCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWw6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMucmVsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLmNsYXNzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdhW2hyZWZdJyxcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogZG9tID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaHJlZiA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJldmVudCBYU1MgYXR0YWNrc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhyZWZcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8ICF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGhyZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IHVybCA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvY29sczogdGhpcy5vcHRpb25zLnByb3RvY29scyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgLy8gcHJldmVudCBYU1MgYXR0YWNrc1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoSFRNTEF0dHJpYnV0ZXMuaHJlZiwge1xuICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiBocmVmID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgLy8gc3RyaXAgb3V0IHRoZSBocmVmXG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICBjb3JlLm1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIHsgLi4uSFRNTEF0dHJpYnV0ZXMsIGhyZWY6ICcnIH0pLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ2EnLCBjb3JlLm1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldExpbms6IGF0dHJpYnV0ZXMgPT4gKHsgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaHJlZiB9ID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0FsbG93ZWRVcmkoaHJlZiwge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsaWRhdGU6IHVybCA9PiAhIWlzQWxsb3dlZFVyaSh1cmwsIHRoaXMub3B0aW9ucy5wcm90b2NvbHMpLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbHM6IHRoaXMub3B0aW9ucy5wcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbDogdGhpcy5vcHRpb25zLmRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpLnNldE1hcmsodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKS5zZXRNZXRhKCdwcmV2ZW50QXV0b2xpbmsnLCB0cnVlKS5ydW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVMaW5rOiBhdHRyaWJ1dGVzID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGhyZWYgfSA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaXNBbGxvd2VkVXJpKGhyZWYsIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiB1cmwgPT4gISFpc0FsbG93ZWRVcmkodXJsLCB0aGlzLm9wdGlvbnMucHJvdG9jb2xzKSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xzOiB0aGlzLm9wdGlvbnMucHJvdG9jb2xzLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvdG9jb2w6IHRoaXMub3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgICAgICAgICAudG9nZ2xlTWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMsIHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2U6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgLnNldE1ldGEoJ3ByZXZlbnRBdXRvbGluaycsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5ydW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldExpbms6ICgpID0+ICh7IGNoYWluIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgICAgICAgICAudW5zZXRNYXJrKHRoaXMubmFtZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZTogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgncHJldmVudEF1dG9saW5rJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgLnJ1bigpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjb3JlLm1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHRleHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3VuZExpbmtzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHByb3RvY29scywgZGVmYXVsdFByb3RvY29sIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rcyA9IGxpbmtpZnlqcy5maW5kKHRleHQpLmZpbHRlcihpdGVtID0+IGl0ZW0uaXNMaW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaShpdGVtLnZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWxpZGF0ZTogaHJlZiA9PiAhIWlzQWxsb3dlZFVyaShocmVmLCBwcm90b2NvbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRQcm90b2NvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IGZvdW5kTGlua3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxpbmsudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IGxpbmsuaHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxpbmsuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3VuZExpbmtzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKF9hID0gbWF0Y2guZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICBjb25zdCBwbHVnaW5zID0gW107XG4gICAgICAgIGNvbnN0IHsgcHJvdG9jb2xzLCBkZWZhdWx0UHJvdG9jb2wgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvbGluaykge1xuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKGF1dG9saW5rKHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgICAgICAgIHZhbGlkYXRlOiB1cmwgPT4gdGhpcy5vcHRpb25zLmlzQWxsb3dlZFVyaSh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbGlkYXRlOiBocmVmID0+ICEhaXNBbGxvd2VkVXJpKGhyZWYsIHByb3RvY29scyksXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29scyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHNob3VsZEF1dG9MaW5rOiB0aGlzLm9wdGlvbnMuc2hvdWxkQXV0b0xpbmssXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcGVuT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKGNsaWNrSGFuZGxlcih7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGlua09uUGFzdGUpIHtcbiAgICAgICAgICAgIHBsdWdpbnMucHVzaChwYXN0ZUhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFByb3RvY29sOiB0aGlzLm9wdGlvbnMuZGVmYXVsdFByb3RvY29sLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGx1Z2lucztcbiAgICB9LFxufSk7XG5cbmV4cG9ydHMuTGluayA9IExpbms7XG5leHBvcnRzLmRlZmF1bHQgPSBMaW5rO1xuZXhwb3J0cy5pc0FsbG93ZWRVcmkgPSBpc0FsbG93ZWRVcmk7XG5leHBvcnRzLnBhc3RlUmVnZXggPSBwYXN0ZVJlZ2V4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguY2pzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@tiptap+extension-link@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1/node_modules/@tiptap/extension-link/dist/index.cjs\n");

/***/ })

};
;