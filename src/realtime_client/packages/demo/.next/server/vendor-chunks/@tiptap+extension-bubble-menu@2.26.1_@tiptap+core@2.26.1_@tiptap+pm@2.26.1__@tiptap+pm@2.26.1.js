"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap+extension-bubble-menu@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1";
exports.ids = ["vendor-chunks/@tiptap+extension-bubble-menu@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@tiptap+extension-bubble-menu@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1/node_modules/@tiptap/extension-bubble-menu/dist/index.cjs":
/*!****************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@tiptap+extension-bubble-menu@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1/node_modules/@tiptap/extension-bubble-menu/dist/index.cjs ***!
  \****************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar core = __webpack_require__(/*! @tiptap/core */ \"(ssr)/../../node_modules/.pnpm/@tiptap+core@2.26.1_@tiptap+pm@2.26.1/node_modules/@tiptap/core/dist/index.cjs\");\nvar state = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/../../node_modules/.pnpm/@tiptap+pm@2.26.1/node_modules/@tiptap/pm/state/dist/index.cjs\");\nvar tippy = __webpack_require__(/*! tippy.js */ \"(ssr)/../../node_modules/.pnpm/tippy.js@6.3.7/node_modules/tippy.js/dist/tippy.esm.js\");\n\nfunction _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }\n\nvar tippy__default = /*#__PURE__*/_interopDefaultCompat(tippy);\n\nclass BubbleMenuView {\n    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow, }) {\n        this.preventHide = false;\n        this.shouldShow = ({ view, state, from, to, }) => {\n            const { doc, selection } = state;\n            const { empty } = selection;\n            // Sometime check for `empty` is not enough.\n            // Doubleclick an empty paragraph returns a node size of 2.\n            // So we check also for an empty text size.\n            const isEmptyTextBlock = !doc.textBetween(from, to).length && core.isTextSelection(state.selection);\n            // When clicking on a element inside the bubble menu the editor \"blur\" event\n            // is called and the bubble menu item is focussed. In this case we should\n            // consider the menu as part of the editor and keep showing the menu\n            const isChildOfMenu = this.element.contains(document.activeElement);\n            const hasEditorFocus = view.hasFocus() || isChildOfMenu;\n            if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = () => {\n            this.preventHide = true;\n        };\n        this.dragstartHandler = () => {\n            this.hide();\n        };\n        this.focusHandler = () => {\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(() => this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event }) => {\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event) => {\n            this.blurHandler({ event });\n        };\n        this.handleDebouncedUpdate = (view, oldState) => {\n            const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n            const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n            if (!selectionChanged && !docChanged) {\n                return;\n            }\n            if (this.updateDebounceTimer) {\n                clearTimeout(this.updateDebounceTimer);\n            }\n            this.updateDebounceTimer = window.setTimeout(() => {\n                this.updateHandler(view, selectionChanged, docChanged, oldState);\n            }, this.updateDelay);\n        };\n        this.updateHandler = (view, selectionChanged, docChanged, oldState) => {\n            var _a, _b, _c;\n            const { state, composing } = view;\n            const { selection } = state;\n            const isSame = !selectionChanged && !docChanged;\n            if (composing || isSame) {\n                return;\n            }\n            this.createTooltip();\n            // support for CellSelections\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map(range => range.$from.pos));\n            const to = Math.max(...ranges.map(range => range.$to.pos));\n            const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n                editor: this.editor,\n                element: this.element,\n                view,\n                state,\n                oldState,\n                from,\n                to,\n            });\n            if (!shouldShow) {\n                this.hide();\n                return;\n            }\n            (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n                getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect)\n                    || (() => {\n                        if (core.isNodeSelection(state.selection)) {\n                            let node = view.nodeDOM(from);\n                            if (node) {\n                                const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector('[data-node-view-wrapper]');\n                                if (nodeViewWrapper) {\n                                    node = nodeViewWrapper.firstChild;\n                                }\n                                if (node) {\n                                    return node.getBoundingClientRect();\n                                }\n                            }\n                        }\n                        return core.posToDOMRect(view, from, to);\n                    }),\n            });\n            this.show();\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        this.updateDelay = updateDelay;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.view.dom.addEventListener('dragstart', this.dragstartHandler);\n        this.editor.on('focus', this.focusHandler);\n        this.editor.on('blur', this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = 'visible';\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        this.element.tabIndex = 0;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = tippy__default.default(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: 'manual',\n            placement: 'top',\n            hideOnClick: 'toggle',\n            ...this.tippyOptions,\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        const { state } = view;\n        const hasValidSelection = state.selection.from !== state.selection.to;\n        if (this.updateDelay > 0 && hasValidSelection) {\n            this.handleDebouncedUpdate(view, oldState);\n            return;\n        }\n        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n        this.updateHandler(view, selectionChanged, docChanged, oldState);\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.view.dom.removeEventListener('dragstart', this.dragstartHandler);\n        this.editor.off('focus', this.focusHandler);\n        this.editor.off('blur', this.blurHandler);\n    }\n}\nconst BubbleMenuPlugin = (options) => {\n    return new state.Plugin({\n        key: typeof options.pluginKey === 'string' ? new state.PluginKey(options.pluginKey) : options.pluginKey,\n        view: view => new BubbleMenuView({ view, ...options }),\n    });\n};\n\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */\nconst BubbleMenu = core.Extension.create({\n    name: 'bubbleMenu',\n    addOptions() {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: 'bubbleMenu',\n            updateDelay: undefined,\n            shouldShow: null,\n        };\n    },\n    addProseMirrorPlugins() {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            BubbleMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                updateDelay: this.options.updateDelay,\n                shouldShow: this.options.shouldShow,\n            }),\n        ];\n    },\n});\n\nexports.BubbleMenu = BubbleMenu;\nexports.BubbleMenuPlugin = BubbleMenuPlugin;\nexports.BubbleMenuView = BubbleMenuView;\nexports[\"default\"] = BubbleMenu;\n//# sourceMappingURL=index.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0aXB0YXArZXh0ZW5zaW9uLWJ1YmJsZS1tZW51QDIuMjYuMV9AdGlwdGFwK2NvcmVAMi4yNi4xX0B0aXB0YXArcG1AMi4yNi4xX19AdGlwdGFwK3BtQDIuMjYuMS9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxXQUFXLG1CQUFPLENBQUMsbUlBQWM7QUFDakMsWUFBWSxtQkFBTyxDQUFDLHVIQUFrQjtBQUN0QyxZQUFZLG1CQUFPLENBQUMsdUdBQVU7O0FBRTlCLHFDQUFxQyw0REFBNEQ7O0FBRWpHOztBQUVBO0FBQ0Esa0JBQWtCLHdDQUF3QyxrQ0FBa0M7QUFDNUY7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JELG9CQUFvQixpQkFBaUI7QUFDckMsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGVBQWU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRCxrQkFBa0I7QUFDbEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QixrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvRWJvb3RoL2FnZW50X2NfZnJhbWV3b3JrL3NyYy9yZWFsdGltZV9jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL0B0aXB0YXArZXh0ZW5zaW9uLWJ1YmJsZS1tZW51QDIuMjYuMV9AdGlwdGFwK2NvcmVAMi4yNi4xX0B0aXB0YXArcG1AMi4yNi4xX19AdGlwdGFwK3BtQDIuMjYuMS9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUvZGlzdC9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29yZSA9IHJlcXVpcmUoJ0B0aXB0YXAvY29yZScpO1xudmFyIHN0YXRlID0gcmVxdWlyZSgnQHRpcHRhcC9wbS9zdGF0ZScpO1xudmFyIHRpcHB5ID0gcmVxdWlyZSgndGlwcHkuanMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0Q29tcGF0IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuXG52YXIgdGlwcHlfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0Q29tcGF0KHRpcHB5KTtcblxuY2xhc3MgQnViYmxlTWVudVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKHsgZWRpdG9yLCBlbGVtZW50LCB2aWV3LCB0aXBweU9wdGlvbnMgPSB7fSwgdXBkYXRlRGVsYXkgPSAyNTAsIHNob3VsZFNob3csIH0pIHtcbiAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3VsZFNob3cgPSAoeyB2aWV3LCBzdGF0ZSwgZnJvbSwgdG8sIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgLy8gU29tZXRpbWUgY2hlY2sgZm9yIGBlbXB0eWAgaXMgbm90IGVub3VnaC5cbiAgICAgICAgICAgIC8vIERvdWJsZWNsaWNrIGFuIGVtcHR5IHBhcmFncmFwaCByZXR1cm5zIGEgbm9kZSBzaXplIG9mIDIuXG4gICAgICAgICAgICAvLyBTbyB3ZSBjaGVjayBhbHNvIGZvciBhbiBlbXB0eSB0ZXh0IHNpemUuXG4gICAgICAgICAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gIWRvYy50ZXh0QmV0d2Vlbihmcm9tLCB0bykubGVuZ3RoICYmIGNvcmUuaXNUZXh0U2VsZWN0aW9uKHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAvLyBXaGVuIGNsaWNraW5nIG9uIGEgZWxlbWVudCBpbnNpZGUgdGhlIGJ1YmJsZSBtZW51IHRoZSBlZGl0b3IgXCJibHVyXCIgZXZlbnRcbiAgICAgICAgICAgIC8vIGlzIGNhbGxlZCBhbmQgdGhlIGJ1YmJsZSBtZW51IGl0ZW0gaXMgZm9jdXNzZWQuIEluIHRoaXMgY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBtZW51IGFzIHBhcnQgb2YgdGhlIGVkaXRvciBhbmQga2VlcCBzaG93aW5nIHRoZSBtZW51XG4gICAgICAgICAgICBjb25zdCBpc0NoaWxkT2ZNZW51ID0gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgaGFzRWRpdG9yRm9jdXMgPSB2aWV3Lmhhc0ZvY3VzKCkgfHwgaXNDaGlsZE9mTWVudTtcbiAgICAgICAgICAgIGlmICghaGFzRWRpdG9yRm9jdXMgfHwgZW1wdHkgfHwgaXNFbXB0eVRleHRCbG9jayB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vdXNlZG93bkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcmFnc3RhcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgdXNlIGBzZXRUaW1lb3V0YCB0byBtYWtlIHN1cmUgYHNlbGVjdGlvbmAgaXMgYWxyZWFkeSB1cGRhdGVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlKHRoaXMuZWRpdG9yLnZpZXcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ibHVySGFuZGxlciA9ICh7IGV2ZW50IH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmICgoX2EgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpID09PSB0aGlzLmVkaXRvci52aWV3LmRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmx1ckhhbmRsZXIoeyBldmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEZWJvdW5jZWRVcGRhdGUgPSAodmlldywgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkNoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5zZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKTtcbiAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5kb2MuZXEodmlldy5zdGF0ZS5kb2MpKTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZURlYm91bmNlVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIodmlldywgc2VsZWN0aW9uQ2hhbmdlZCwgZG9jQ2hhbmdlZCwgb2xkU3RhdGUpO1xuICAgICAgICAgICAgfSwgdGhpcy51cGRhdGVEZWxheSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlciA9ICh2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlLCBjb21wb3NpbmcgfSA9IHZpZXc7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBpc1NhbWUgPSAhc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZDtcbiAgICAgICAgICAgIGlmIChjb21wb3NpbmcgfHwgaXNTYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKCk7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBDZWxsU2VsZWN0aW9uc1xuICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNob3cgPSAoX2EgPSB0aGlzLnNob3VsZFNob3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkU2hvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRQcm9wcyh7XG4gICAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogKChfYyA9IHRoaXMudGlwcHlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdClcbiAgICAgICAgICAgICAgICAgICAgfHwgKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzTm9kZVNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aWV3Lm5vZGVET00oZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZpZXdXcmFwcGVyID0gbm9kZS5kYXRhc2V0Lm5vZGVWaWV3V3JhcHBlciA/IG5vZGUgOiBub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW5vZGUtdmlldy13cmFwcGVyXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVZpZXdXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVZpZXdXcmFwcGVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmUucG9zVG9ET01SZWN0KHZpZXcsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy51cGRhdGVEZWxheSA9IHVwZGF0ZURlbGF5O1xuICAgICAgICBpZiAoc2hvdWxkU2hvdykge1xuICAgICAgICAgICAgdGhpcy5zaG91bGRTaG93ID0gc2hvdWxkU2hvdztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZWRvd25IYW5kbGVyLCB7IGNhcHR1cmU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5kcmFnc3RhcnRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xuICAgICAgICB0aGlzLnRpcHB5T3B0aW9ucyA9IHRpcHB5T3B0aW9ucztcbiAgICAgICAgLy8gRGV0YWNoZXMgbWVudSBjb250ZW50IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAoKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudDogZWRpdG9yRWxlbWVudCB9ID0gdGhpcy5lZGl0b3Iub3B0aW9ucztcbiAgICAgICAgY29uc3QgZWRpdG9ySXNBdHRhY2hlZCA9ICEhZWRpdG9yRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgICAgICBpZiAodGhpcy50aXBweSB8fCAhZWRpdG9ySXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlwcHkgPSB0aXBweV9fZGVmYXVsdC5kZWZhdWx0KGVkaXRvckVsZW1lbnQsIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICd0b2dnbGUnLFxuICAgICAgICAgICAgLi4udGhpcy50aXBweU9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtYXliZSB3ZSBoYXZlIHRvIGhpZGUgdGlwcHkgb24gaXRzIG93biBibHVyIGV2ZW50IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIG9sZFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgICAgIGNvbnN0IGhhc1ZhbGlkU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLmZyb20gIT09IHN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlRGVsYXkgPiAwICYmIGhhc1ZhbGlkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSh2aWV3LCBvbGRTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlZCA9ICEob2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLnNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpO1xuICAgICAgICBjb25zdCBkb2NDaGFuZ2VkID0gIShvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuZG9jLmVxKHZpZXcuc3RhdGUuZG9jKSk7XG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlcih2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSk7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3coKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICB9XG59XG5jb25zdCBCdWJibGVNZW51UGx1Z2luID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IHN0YXRlLlBsdWdpbih7XG4gICAgICAgIGtleTogdHlwZW9mIG9wdGlvbnMucGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IG5ldyBzdGF0ZS5QbHVnaW5LZXkob3B0aW9ucy5wbHVnaW5LZXkpIDogb3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgIHZpZXc6IHZpZXcgPT4gbmV3IEJ1YmJsZU1lbnVWaWV3KHsgdmlldywgLi4ub3B0aW9ucyB9KSxcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgYSBidWJibGUgbWVudS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2J1YmJsZS1tZW51XG4gKi9cbmNvbnN0IEJ1YmJsZU1lbnUgPSBjb3JlLkV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdidWJibGVNZW51JyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIHRpcHB5T3B0aW9uczoge30sXG4gICAgICAgICAgICBwbHVnaW5LZXk6ICdidWJibGVNZW51JyxcbiAgICAgICAgICAgIHVwZGF0ZURlbGF5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaG91bGRTaG93OiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEJ1YmJsZU1lbnVQbHVnaW4oe1xuICAgICAgICAgICAgICAgIHBsdWdpbktleTogdGhpcy5vcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMub3B0aW9ucy5lbGVtZW50LFxuICAgICAgICAgICAgICAgIHRpcHB5T3B0aW9uczogdGhpcy5vcHRpb25zLnRpcHB5T3B0aW9ucyxcbiAgICAgICAgICAgICAgICB1cGRhdGVEZWxheTogdGhpcy5vcHRpb25zLnVwZGF0ZURlbGF5LFxuICAgICAgICAgICAgICAgIHNob3VsZFNob3c6IHRoaXMub3B0aW9ucy5zaG91bGRTaG93LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnRzLkJ1YmJsZU1lbnUgPSBCdWJibGVNZW51O1xuZXhwb3J0cy5CdWJibGVNZW51UGx1Z2luID0gQnViYmxlTWVudVBsdWdpbjtcbmV4cG9ydHMuQnViYmxlTWVudVZpZXcgPSBCdWJibGVNZW51VmlldztcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1YmJsZU1lbnU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@tiptap+extension-bubble-menu@2.26.1_@tiptap+core@2.26.1_@tiptap+pm@2.26.1__@tiptap+pm@2.26.1/node_modules/@tiptap/extension-bubble-menu/dist/index.cjs\n");

/***/ })

};
;