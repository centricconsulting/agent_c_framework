"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-dropcursor@1.8.2";
exports.ids = ["vendor-chunks/prosemirror-dropcursor@1.8.2"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/prosemirror-dropcursor@1.8.2/node_modules/prosemirror-dropcursor/dist/index.cjs":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/prosemirror-dropcursor@1.8.2/node_modules/prosemirror-dropcursor/dist/index.cjs ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"(ssr)/../../node_modules/.pnpm/prosemirror-state@1.4.3/node_modules/prosemirror-state/dist/index.cjs\");\nvar prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/../../node_modules/.pnpm/prosemirror-transform@1.10.4/node_modules/prosemirror-transform/dist/index.cjs\");\nfunction dropCursor() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new prosemirrorState.Plugin({\n    view: function view(editorView) {\n      return new DropCursorView(editorView, options);\n    }\n  });\n}\nvar DropCursorView = function () {\n  function DropCursorView(editorView, options) {\n    var _this = this;\n    _classCallCheck(this, DropCursorView);\n    var _a;\n    this.editorView = editorView;\n    this.cursorPos = null;\n    this.element = null;\n    this.timeout = -1;\n    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;\n    this.color = options.color === false ? undefined : options.color || \"black\";\n    this[\"class\"] = options[\"class\"];\n    this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(function (name) {\n      var handler = function handler(e) {\n        _this[name](e);\n      };\n      editorView.dom.addEventListener(name, handler);\n      return {\n        name: name,\n        handler: handler\n      };\n    });\n  }\n  _createClass(DropCursorView, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this2 = this;\n      this.handlers.forEach(function (_ref) {\n        var name = _ref.name,\n          handler = _ref.handler;\n        return _this2.editorView.dom.removeEventListener(name, handler);\n      });\n    }\n  }, {\n    key: \"update\",\n    value: function update(editorView, prevState) {\n      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {\n        if (this.cursorPos > editorView.state.doc.content.size) this.setCursor(null);else this.updateOverlay();\n      }\n    }\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(pos) {\n      if (pos == this.cursorPos) return;\n      this.cursorPos = pos;\n      if (pos == null) {\n        this.element.parentNode.removeChild(this.element);\n        this.element = null;\n      } else {\n        this.updateOverlay();\n      }\n    }\n  }, {\n    key: \"updateOverlay\",\n    value: function updateOverlay() {\n      var $pos = this.editorView.state.doc.resolve(this.cursorPos);\n      var isBlock = !$pos.parent.inlineContent,\n        rect;\n      var editorDOM = this.editorView.dom,\n        editorRect = editorDOM.getBoundingClientRect();\n      var scaleX = editorRect.width / editorDOM.offsetWidth,\n        scaleY = editorRect.height / editorDOM.offsetHeight;\n      if (isBlock) {\n        var before = $pos.nodeBefore,\n          after = $pos.nodeAfter;\n        if (before || after) {\n          var node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));\n          if (node) {\n            var nodeRect = node.getBoundingClientRect();\n            var top = before ? nodeRect.bottom : nodeRect.top;\n            if (before && after) top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;\n            var halfWidth = this.width / 2 * scaleY;\n            rect = {\n              left: nodeRect.left,\n              right: nodeRect.right,\n              top: top - halfWidth,\n              bottom: top + halfWidth\n            };\n          }\n        }\n      }\n      if (!rect) {\n        var coords = this.editorView.coordsAtPos(this.cursorPos);\n        var _halfWidth = this.width / 2 * scaleX;\n        rect = {\n          left: coords.left - _halfWidth,\n          right: coords.left + _halfWidth,\n          top: coords.top,\n          bottom: coords.bottom\n        };\n      }\n      var parent = this.editorView.dom.offsetParent;\n      if (!this.element) {\n        this.element = parent.appendChild(document.createElement(\"div\"));\n        if (this[\"class\"]) this.element.className = this[\"class\"];\n        this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none;\";\n        if (this.color) {\n          this.element.style.backgroundColor = this.color;\n        }\n      }\n      this.element.classList.toggle(\"prosemirror-dropcursor-block\", isBlock);\n      this.element.classList.toggle(\"prosemirror-dropcursor-inline\", !isBlock);\n      var parentLeft, parentTop;\n      if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n        parentLeft = -pageXOffset;\n        parentTop = -pageYOffset;\n      } else {\n        var _rect = parent.getBoundingClientRect();\n        var parentScaleX = _rect.width / parent.offsetWidth,\n          parentScaleY = _rect.height / parent.offsetHeight;\n        parentLeft = _rect.left - parent.scrollLeft * parentScaleX;\n        parentTop = _rect.top - parent.scrollTop * parentScaleY;\n      }\n      this.element.style.left = (rect.left - parentLeft) / scaleX + \"px\";\n      this.element.style.top = (rect.top - parentTop) / scaleY + \"px\";\n      this.element.style.width = (rect.right - rect.left) / scaleX + \"px\";\n      this.element.style.height = (rect.bottom - rect.top) / scaleY + \"px\";\n    }\n  }, {\n    key: \"scheduleRemoval\",\n    value: function scheduleRemoval(timeout) {\n      var _this3 = this;\n      clearTimeout(this.timeout);\n      this.timeout = setTimeout(function () {\n        return _this3.setCursor(null);\n      }, timeout);\n    }\n  }, {\n    key: \"dragover\",\n    value: function dragover(event) {\n      if (!this.editorView.editable) return;\n      var pos = this.editorView.posAtCoords({\n        left: event.clientX,\n        top: event.clientY\n      });\n      var node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);\n      var disableDropCursor = node && node.type.spec.disableDropCursor;\n      var disabled = typeof disableDropCursor == \"function\" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;\n      if (pos && !disabled) {\n        var target = pos.pos;\n        if (this.editorView.dragging && this.editorView.dragging.slice) {\n          var point = prosemirrorTransform.dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);\n          if (point != null) target = point;\n        }\n        this.setCursor(target);\n        this.scheduleRemoval(5000);\n      }\n    }\n  }, {\n    key: \"dragend\",\n    value: function dragend() {\n      this.scheduleRemoval(20);\n    }\n  }, {\n    key: \"drop\",\n    value: function drop() {\n      this.scheduleRemoval(20);\n    }\n  }, {\n    key: \"dragleave\",\n    value: function dragleave(event) {\n      if (!this.editorView.dom.contains(event.relatedTarget)) this.setCursor(null);\n    }\n  }]);\n  return DropCursorView;\n}();\nexports.dropCursor = dropCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLWRyb3BjdXJzb3JAMS44LjIvbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWRyb3BjdXJzb3IvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1Msa0RBQWtELDBDQUEwQztBQUM1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDtBQUMvUCw4REFBOEQsc0VBQXNFLDhEQUE4RCxrREFBa0QsaUJBQWlCLEdBQUc7QUFDeFEsK0JBQStCLHVDQUF1QztBQUN0RSxxQ0FBcUMsaUVBQWlFLHNDQUFzQywwQkFBMEIsK0NBQStDLDJDQUEyQyx1RUFBdUU7QUFDdlUsdUJBQXVCLG1CQUFPLENBQUMsK0hBQW1CO0FBQ2xELDJCQUEyQixtQkFBTyxDQUFDLDRJQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYSxxQkFBcUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNELGtCQUFrQiIsInNvdXJjZXMiOlsiL1VzZXJzL0Vib290aC9hZ2VudF9jX2ZyYW1ld29yay9zcmMvcmVhbHRpbWVfY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9wcm9zZW1pcnJvci1kcm9wY3Vyc29yQDEuOC4yL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1kcm9wY3Vyc29yL2Rpc3QvaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHsgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7IHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkgeyB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTsgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgcHJvc2VtaXJyb3JTdGF0ZSA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLXN0YXRlJyk7XG52YXIgcHJvc2VtaXJyb3JUcmFuc2Zvcm0gPSByZXF1aXJlKCdwcm9zZW1pcnJvci10cmFuc2Zvcm0nKTtcbmZ1bmN0aW9uIGRyb3BDdXJzb3IoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgcmV0dXJuIG5ldyBwcm9zZW1pcnJvclN0YXRlLlBsdWdpbih7XG4gICAgdmlldzogZnVuY3Rpb24gdmlldyhlZGl0b3JWaWV3KSB7XG4gICAgICByZXR1cm4gbmV3IERyb3BDdXJzb3JWaWV3KGVkaXRvclZpZXcsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRHJvcEN1cnNvclZpZXcgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERyb3BDdXJzb3JWaWV3KGVkaXRvclZpZXcsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wQ3Vyc29yVmlldyk7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuZWRpdG9yVmlldyA9IGVkaXRvclZpZXc7XG4gICAgdGhpcy5jdXJzb3JQb3MgPSBudWxsO1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy50aW1lb3V0ID0gLTE7XG4gICAgdGhpcy53aWR0aCA9IChfYSA9IG9wdGlvbnMud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgPT09IGZhbHNlID8gdW5kZWZpbmVkIDogb3B0aW9ucy5jb2xvciB8fCBcImJsYWNrXCI7XG4gICAgdGhpc1tcImNsYXNzXCJdID0gb3B0aW9uc1tcImNsYXNzXCJdO1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXCJkcmFnb3ZlclwiLCBcImRyYWdlbmRcIiwgXCJkcm9wXCIsIFwiZHJhZ2xlYXZlXCJdLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGUpIHtcbiAgICAgICAgX3RoaXNbbmFtZV0oZSk7XG4gICAgICB9O1xuICAgICAgZWRpdG9yVmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKERyb3BDdXJzb3JWaWV3LCBbe1xuICAgIGtleTogXCJkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgICBoYW5kbGVyID0gX3JlZi5oYW5kbGVyO1xuICAgICAgICByZXR1cm4gX3RoaXMyLmVkaXRvclZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShlZGl0b3JWaWV3LCBwcmV2U3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmN1cnNvclBvcyAhPSBudWxsICYmIHByZXZTdGF0ZS5kb2MgIT0gZWRpdG9yVmlldy5zdGF0ZS5kb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuY3Vyc29yUG9zID4gZWRpdG9yVmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplKSB0aGlzLnNldEN1cnNvcihudWxsKTtlbHNlIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDdXJzb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3Vyc29yKHBvcykge1xuICAgICAgaWYgKHBvcyA9PSB0aGlzLmN1cnNvclBvcykgcmV0dXJuO1xuICAgICAgdGhpcy5jdXJzb3JQb3MgPSBwb3M7XG4gICAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVPdmVybGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU92ZXJsYXkoKSB7XG4gICAgICB2YXIgJHBvcyA9IHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0aGlzLmN1cnNvclBvcyk7XG4gICAgICB2YXIgaXNCbG9jayA9ICEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50LFxuICAgICAgICByZWN0O1xuICAgICAgdmFyIGVkaXRvckRPTSA9IHRoaXMuZWRpdG9yVmlldy5kb20sXG4gICAgICAgIGVkaXRvclJlY3QgPSBlZGl0b3JET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2NhbGVYID0gZWRpdG9yUmVjdC53aWR0aCAvIGVkaXRvckRPTS5vZmZzZXRXaWR0aCxcbiAgICAgICAgc2NhbGVZID0gZWRpdG9yUmVjdC5oZWlnaHQgLyBlZGl0b3JET00ub2Zmc2V0SGVpZ2h0O1xuICAgICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9ICRwb3Mubm9kZUJlZm9yZSxcbiAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICBpZiAoYmVmb3JlIHx8IGFmdGVyKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcyAtIChiZWZvcmUgPyBiZWZvcmUubm9kZVNpemUgOiAwKSk7XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICB2YXIgdG9wID0gYmVmb3JlID8gbm9kZVJlY3QuYm90dG9tIDogbm9kZVJlY3QudG9wO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSAmJiBhZnRlcikgdG9wID0gKHRvcCArIHRoaXMuZWRpdG9yVmlldy5ub2RlRE9NKHRoaXMuY3Vyc29yUG9zKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIC8gMjtcbiAgICAgICAgICAgIHZhciBoYWxmV2lkdGggPSB0aGlzLndpZHRoIC8gMiAqIHNjYWxlWTtcbiAgICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICAgIGxlZnQ6IG5vZGVSZWN0LmxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0OiBub2RlUmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgdG9wOiB0b3AgLSBoYWxmV2lkdGgsXG4gICAgICAgICAgICAgIGJvdHRvbTogdG9wICsgaGFsZldpZHRoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLmVkaXRvclZpZXcuY29vcmRzQXRQb3ModGhpcy5jdXJzb3JQb3MpO1xuICAgICAgICB2YXIgX2hhbGZXaWR0aCA9IHRoaXMud2lkdGggLyAyICogc2NhbGVYO1xuICAgICAgICByZWN0ID0ge1xuICAgICAgICAgIGxlZnQ6IGNvb3Jkcy5sZWZ0IC0gX2hhbGZXaWR0aCxcbiAgICAgICAgICByaWdodDogY29vcmRzLmxlZnQgKyBfaGFsZldpZHRoLFxuICAgICAgICAgIHRvcDogY29vcmRzLnRvcCxcbiAgICAgICAgICBib3R0b206IGNvb3Jkcy5ib3R0b21cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmVkaXRvclZpZXcuZG9tLm9mZnNldFBhcmVudDtcbiAgICAgIGlmICghdGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgaWYgKHRoaXNbXCJjbGFzc1wiXSkgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IHRoaXNbXCJjbGFzc1wiXTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgei1pbmRleDogNTA7IHBvaW50ZXItZXZlbnRzOiBub25lO1wiO1xuICAgICAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItYmxvY2tcIiwgaXNCbG9jayk7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItaW5saW5lXCIsICFpc0Jsb2NrKTtcbiAgICAgIHZhciBwYXJlbnRMZWZ0LCBwYXJlbnRUb3A7XG4gICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT0gZG9jdW1lbnQuYm9keSAmJiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb24gPT0gXCJzdGF0aWNcIikge1xuICAgICAgICBwYXJlbnRMZWZ0ID0gLXBhZ2VYT2Zmc2V0O1xuICAgICAgICBwYXJlbnRUb3AgPSAtcGFnZVlPZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3JlY3QgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwYXJlbnRTY2FsZVggPSBfcmVjdC53aWR0aCAvIHBhcmVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBwYXJlbnRTY2FsZVkgPSBfcmVjdC5oZWlnaHQgLyBwYXJlbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBwYXJlbnRMZWZ0ID0gX3JlY3QubGVmdCAtIHBhcmVudC5zY3JvbGxMZWZ0ICogcGFyZW50U2NhbGVYO1xuICAgICAgICBwYXJlbnRUb3AgPSBfcmVjdC50b3AgLSBwYXJlbnQuc2Nyb2xsVG9wICogcGFyZW50U2NhbGVZO1xuICAgICAgfVxuICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSAocmVjdC5sZWZ0IC0gcGFyZW50TGVmdCkgLyBzY2FsZVggKyBcInB4XCI7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudG9wID0gKHJlY3QudG9wIC0gcGFyZW50VG9wKSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5oZWlnaHQgPSAocmVjdC5ib3R0b20gLSByZWN0LnRvcCkgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjaGVkdWxlUmVtb3ZhbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZVJlbW92YWwodGltZW91dCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnNldEN1cnNvcihudWxsKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmFnb3ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmFnb3ZlcihldmVudCkge1xuICAgICAgaWYgKCF0aGlzLmVkaXRvclZpZXcuZWRpdGFibGUpIHJldHVybjtcbiAgICAgIHZhciBwb3MgPSB0aGlzLmVkaXRvclZpZXcucG9zQXRDb29yZHMoe1xuICAgICAgICBsZWZ0OiBldmVudC5jbGllbnRYLFxuICAgICAgICB0b3A6IGV2ZW50LmNsaWVudFlcbiAgICAgIH0pO1xuICAgICAgdmFyIG5vZGUgPSBwb3MgJiYgcG9zLmluc2lkZSA+PSAwICYmIHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgdmFyIGRpc2FibGVEcm9wQ3Vyc29yID0gbm9kZSAmJiBub2RlLnR5cGUuc3BlYy5kaXNhYmxlRHJvcEN1cnNvcjtcbiAgICAgIHZhciBkaXNhYmxlZCA9IHR5cGVvZiBkaXNhYmxlRHJvcEN1cnNvciA9PSBcImZ1bmN0aW9uXCIgPyBkaXNhYmxlRHJvcEN1cnNvcih0aGlzLmVkaXRvclZpZXcsIHBvcywgZXZlbnQpIDogZGlzYWJsZURyb3BDdXJzb3I7XG4gICAgICBpZiAocG9zICYmICFkaXNhYmxlZCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gcG9zLnBvcztcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yVmlldy5kcmFnZ2luZyAmJiB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSBwcm9zZW1pcnJvclRyYW5zZm9ybS5kcm9wUG9pbnQodGhpcy5lZGl0b3JWaWV3LnN0YXRlLmRvYywgdGFyZ2V0LCB0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcuc2xpY2UpO1xuICAgICAgICAgIGlmIChwb2ludCAhPSBudWxsKSB0YXJnZXQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEN1cnNvcih0YXJnZXQpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCg1MDAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhZ2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmFnZW5kKCkge1xuICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcm9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyb3AoKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCgyMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYWdsZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmFnbGVhdmUoZXZlbnQpIHtcbiAgICAgIGlmICghdGhpcy5lZGl0b3JWaWV3LmRvbS5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkgdGhpcy5zZXRDdXJzb3IobnVsbCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEcm9wQ3Vyc29yVmlldztcbn0oKTtcbmV4cG9ydHMuZHJvcEN1cnNvciA9IGRyb3BDdXJzb3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/prosemirror-dropcursor@1.8.2/node_modules/prosemirror-dropcursor/dist/index.cjs\n");

/***/ })

};
;