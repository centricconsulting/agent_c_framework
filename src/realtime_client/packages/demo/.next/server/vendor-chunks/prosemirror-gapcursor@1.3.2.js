"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-gapcursor@1.3.2";
exports.ids = ["vendor-chunks/prosemirror-gapcursor@1.3.2"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/prosemirror-gapcursor@1.3.2/node_modules/prosemirror-gapcursor/dist/index.cjs":
/*!**************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/prosemirror-gapcursor@1.3.2/node_modules/prosemirror-gapcursor/dist/index.cjs ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar prosemirrorKeymap = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/../../node_modules/.pnpm/prosemirror-keymap@1.2.3/node_modules/prosemirror-keymap/dist/index.cjs\");\n\nvar prosemirrorState = __webpack_require__(/*! prosemirror-state */ \"(ssr)/../../node_modules/.pnpm/prosemirror-state@1.4.3/node_modules/prosemirror-state/dist/index.cjs\");\n\nvar prosemirrorModel = __webpack_require__(/*! prosemirror-model */ \"(ssr)/../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs\");\n\nvar prosemirrorView = __webpack_require__(/*! prosemirror-view */ \"(ssr)/../../node_modules/.pnpm/prosemirror-view@1.41.0/node_modules/prosemirror-view/dist/index.cjs\");\n\nvar GapCursor = function (_prosemirrorState$Sel) {\n  _inherits(GapCursor, _prosemirrorState$Sel);\n\n  var _super = _createSuper(GapCursor);\n\n  function GapCursor($pos) {\n    _classCallCheck(this, GapCursor);\n\n    return _super.call(this, $pos, $pos);\n  }\n\n  _createClass(GapCursor, [{\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var $pos = doc.resolve(mapping.map(this.head));\n      return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState.Selection.near($pos);\n    }\n  }, {\n    key: \"content\",\n    value: function content() {\n      return prosemirrorModel.Slice.empty;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof GapCursor && other.head == this.head;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"gapcursor\",\n        pos: this.head\n      };\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return new GapBookmark(this.anchor);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n      return new GapCursor(doc.resolve(json.pos));\n    }\n  }, {\n    key: \"valid\",\n    value: function valid($pos) {\n      var parent = $pos.parent;\n      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;\n      var override = parent.type.spec.allowGapCursor;\n      if (override != null) return override;\n      var deflt = parent.contentMatchAt($pos.index()).defaultType;\n      return deflt && deflt.isTextblock;\n    }\n  }, {\n    key: \"findGapCursorFrom\",\n    value: function findGapCursorFrom($pos, dir) {\n      var mustMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      search: for (;;) {\n        if (!mustMove && GapCursor.valid($pos)) return $pos;\n        var pos = $pos.pos,\n            next = null;\n\n        for (var d = $pos.depth;; d--) {\n          var parent = $pos.node(d);\n\n          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n            break;\n          } else if (d == 0) {\n            return null;\n          }\n\n          pos += dir;\n          var $cur = $pos.doc.resolve(pos);\n          if (GapCursor.valid($cur)) return $cur;\n        }\n\n        for (;;) {\n          var inside = dir > 0 ? next.firstChild : next.lastChild;\n\n          if (!inside) {\n            if (next.isAtom && !next.isText && !prosemirrorState.NodeSelection.isSelectable(next)) {\n              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n              mustMove = false;\n              continue search;\n            }\n\n            break;\n          }\n\n          next = inside;\n          pos += dir;\n\n          var _$cur = $pos.doc.resolve(pos);\n\n          if (GapCursor.valid(_$cur)) return _$cur;\n        }\n\n        return null;\n      }\n    }\n  }]);\n\n  return GapCursor;\n}(prosemirrorState.Selection);\n\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nprosemirrorState.Selection.jsonID(\"gapcursor\", GapCursor);\n\nvar GapBookmark = function () {\n  function GapBookmark(pos) {\n    _classCallCheck(this, GapBookmark);\n\n    this.pos = pos;\n  }\n\n  _createClass(GapBookmark, [{\n    key: \"map\",\n    value: function map(mapping) {\n      return new GapBookmark(mapping.map(this.pos));\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(doc) {\n      var $pos = doc.resolve(this.pos);\n      return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirrorState.Selection.near($pos);\n    }\n  }]);\n\n  return GapBookmark;\n}();\n\nfunction closedBefore($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.index(d),\n        parent = $pos.node(d);\n\n    if (index == 0) {\n      if (parent.type.spec.isolating) return true;\n      continue;\n    }\n\n    for (var before = parent.child(index - 1);; before = before.lastChild) {\n      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) return true;\n      if (before.inlineContent) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction closedAfter($pos) {\n  for (var d = $pos.depth; d >= 0; d--) {\n    var index = $pos.indexAfter(d),\n        parent = $pos.node(d);\n\n    if (index == parent.childCount) {\n      if (parent.type.spec.isolating) return true;\n      continue;\n    }\n\n    for (var after = parent.child(index);; after = after.firstChild) {\n      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) return true;\n      if (after.inlineContent) return false;\n    }\n  }\n\n  return true;\n}\n\nfunction gapCursor() {\n  return new prosemirrorState.Plugin({\n    props: {\n      decorations: drawGapCursor,\n      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {\n        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n      },\n      handleClick: handleClick,\n      handleKeyDown: handleKeyDown,\n      handleDOMEvents: {\n        beforeinput: beforeinput\n      }\n    }\n  });\n}\n\nvar handleKeyDown = prosemirrorKeymap.keydownHandler({\n  \"ArrowLeft\": arrow(\"horiz\", -1),\n  \"ArrowRight\": arrow(\"horiz\", 1),\n  \"ArrowUp\": arrow(\"vert\", -1),\n  \"ArrowDown\": arrow(\"vert\", 1)\n});\n\nfunction arrow(axis, dir) {\n  var dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n  return function (state, dispatch, view) {\n    var sel = state.selection;\n    var $start = dir > 0 ? sel.$to : sel.$from,\n        mustMove = sel.empty;\n\n    if (sel instanceof prosemirrorState.TextSelection) {\n      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;\n      mustMove = false;\n      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n    }\n\n    var $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n    if (!$found) return false;\n    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));\n    return true;\n  };\n}\n\nfunction handleClick(view, pos, event) {\n  if (!view || !view.editable) return false;\n  var $pos = view.state.doc.resolve(pos);\n  if (!GapCursor.valid($pos)) return false;\n  var clickPos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (clickPos && clickPos.inside > -1 && prosemirrorState.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;\n  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n  return true;\n}\n\nfunction beforeinput(view, event) {\n  if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor)) return false;\n  var $from = view.state.selection.$from;\n  var insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n  if (!insert) return false;\n  var frag = prosemirrorModel.Fragment.empty;\n\n  for (var i = insert.length - 1; i >= 0; i--) {\n    frag = prosemirrorModel.Fragment.from(insert[i].createAndFill(null, frag));\n  }\n\n  var tr = view.state.tr.replace($from.pos, $from.pos, new prosemirrorModel.Slice(frag, 0, 0));\n  tr.setSelection(prosemirrorState.TextSelection.near(tr.doc.resolve($from.pos + 1)));\n  view.dispatch(tr);\n  return false;\n}\n\nfunction drawGapCursor(state) {\n  if (!(state.selection instanceof GapCursor)) return null;\n  var node = document.createElement(\"div\");\n  node.className = \"ProseMirror-gapcursor\";\n  return prosemirrorView.DecorationSet.create(state.doc, [prosemirrorView.Decoration.widget(state.selection.head, node, {\n    key: \"gapcursor\"\n  })]);\n}\n\nexports.GapCursor = GapCursor;\nexports.gapCursor = gapCursor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLWdhcGN1cnNvckAxLjMuMi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZ2FwY3Vyc29yL2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHdCQUF3QiwyQkFBMkIsc0dBQXNHLHFCQUFxQixtQkFBbUIsOEhBQThIOztBQUUvVCxrREFBa0QsMENBQTBDOztBQUU1Riw0Q0FBNEMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RDs7QUFFL1AsOERBQThELHNFQUFzRSw4REFBOEQsa0RBQWtELGlCQUFpQixHQUFHOztBQUV4USwyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRywrQ0FBK0MsaUJBQWlCLEdBQUc7O0FBRTVZLGlDQUFpQyw0RUFBNEUsaUJBQWlCLGFBQWE7O0FBRTNJLGlDQUFpQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELDJEQUEyRCxPQUFPLHlDQUF5Qzs7QUFFcFgsa0RBQWtELDBFQUEwRSxlQUFlLDRCQUE0QixtRkFBbUY7O0FBRTFQLHdDQUF3Qyx1QkFBdUIseUZBQXlGOztBQUV4Six1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhULDhCQUE4QixnR0FBZ0csbURBQW1EOztBQUVqTCw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUYsd0JBQXdCLG1CQUFPLENBQUMsa0lBQW9COztBQUVwRCx1QkFBdUIsbUJBQU8sQ0FBQywrSEFBbUI7O0FBRWxELHVCQUF1QixtQkFBTyxDQUFDLGdJQUFtQjs7QUFFbEQsc0JBQXNCLG1CQUFPLENBQUMsNkhBQWtCOztBQUVoRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsaUJBQWlCO0FBQ2pCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL0Vib290aC9hZ2VudF9jX2ZyYW1ld29yay9zcmMvcmVhbHRpbWVfY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9wcm9zZW1pcnJvci1nYXBjdXJzb3JAMS4zLjIvbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWdhcGN1cnNvci9kaXN0L2luZGV4LmNqcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgcHJvc2VtaXJyb3JLZXltYXAgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1rZXltYXAnKTtcblxudmFyIHByb3NlbWlycm9yU3RhdGUgPSByZXF1aXJlKCdwcm9zZW1pcnJvci1zdGF0ZScpO1xuXG52YXIgcHJvc2VtaXJyb3JNb2RlbCA9IHJlcXVpcmUoJ3Byb3NlbWlycm9yLW1vZGVsJyk7XG5cbnZhciBwcm9zZW1pcnJvclZpZXcgPSByZXF1aXJlKCdwcm9zZW1pcnJvci12aWV3Jyk7XG5cbnZhciBHYXBDdXJzb3IgPSBmdW5jdGlvbiAoX3Byb3NlbWlycm9yU3RhdGUkU2VsKSB7XG4gIF9pbmhlcml0cyhHYXBDdXJzb3IsIF9wcm9zZW1pcnJvclN0YXRlJFNlbCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihHYXBDdXJzb3IpO1xuXG4gIGZ1bmN0aW9uIEdhcEN1cnNvcigkcG9zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdhcEN1cnNvcik7XG5cbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgJHBvcywgJHBvcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoR2FwQ3Vyc29yLCBbe1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcCh0aGlzLmhlYWQpKTtcbiAgICAgIHJldHVybiBHYXBDdXJzb3IudmFsaWQoJHBvcykgPyBuZXcgR2FwQ3Vyc29yKCRwb3MpIDogcHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24ubmVhcigkcG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb250ZW50KCkge1xuICAgICAgcmV0dXJuIHByb3NlbWlycm9yTW9kZWwuU2xpY2UuZW1wdHk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVxXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxKG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBHYXBDdXJzb3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImdhcGN1cnNvclwiLFxuICAgICAgICBwb3M6IHRoaXMuaGVhZFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm9va21hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm9va21hcmsoKSB7XG4gICAgICByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKHRoaXMuYW5jaG9yKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihkb2MsIGpzb24pIHtcbiAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBHYXBDdXJzb3IuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IEdhcEN1cnNvcihkb2MucmVzb2x2ZShqc29uLnBvcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZCgkcG9zKSB7XG4gICAgICB2YXIgcGFyZW50ID0gJHBvcy5wYXJlbnQ7XG4gICAgICBpZiAocGFyZW50LmlzVGV4dGJsb2NrIHx8ICFjbG9zZWRCZWZvcmUoJHBvcykgfHwgIWNsb3NlZEFmdGVyKCRwb3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBwYXJlbnQudHlwZS5zcGVjLmFsbG93R2FwQ3Vyc29yO1xuICAgICAgaWYgKG92ZXJyaWRlICE9IG51bGwpIHJldHVybiBvdmVycmlkZTtcbiAgICAgIHZhciBkZWZsdCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgkcG9zLmluZGV4KCkpLmRlZmF1bHRUeXBlO1xuICAgICAgcmV0dXJuIGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kR2FwQ3Vyc29yRnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kR2FwQ3Vyc29yRnJvbSgkcG9zLCBkaXIpIHtcbiAgICAgIHZhciBtdXN0TW92ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgICBpZiAoIW11c3RNb3ZlICYmIEdhcEN1cnNvci52YWxpZCgkcG9zKSkgcmV0dXJuICRwb3M7XG4gICAgICAgIHZhciBwb3MgPSAkcG9zLnBvcyxcbiAgICAgICAgICAgIG5leHQgPSBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9ICRwb3Mubm9kZShkKTtcblxuICAgICAgICAgIGlmIChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDwgcGFyZW50LmNoaWxkQ291bnQgOiAkcG9zLmluZGV4KGQpID4gMCkge1xuICAgICAgICAgICAgbmV4dCA9IHBhcmVudC5jaGlsZChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDogJHBvcy5pbmRleChkKSAtIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChkID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyArPSBkaXI7XG4gICAgICAgICAgdmFyICRjdXIgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgICAgaWYgKEdhcEN1cnNvci52YWxpZCgkY3VyKSkgcmV0dXJuICRjdXI7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgdmFyIGluc2lkZSA9IGRpciA+IDAgPyBuZXh0LmZpcnN0Q2hpbGQgOiBuZXh0Lmxhc3RDaGlsZDtcblxuICAgICAgICAgIGlmICghaW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAobmV4dC5pc0F0b20gJiYgIW5leHQuaXNUZXh0ICYmICFwcm9zZW1pcnJvclN0YXRlLk5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICRwb3MgPSAkcG9zLmRvYy5yZXNvbHZlKHBvcyArIG5leHQubm9kZVNpemUgKiBkaXIpO1xuICAgICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQgPSBpbnNpZGU7XG4gICAgICAgICAgcG9zICs9IGRpcjtcblxuICAgICAgICAgIHZhciBfJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcblxuICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoXyRjdXIpKSByZXR1cm4gXyRjdXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR2FwQ3Vyc29yO1xufShwcm9zZW1pcnJvclN0YXRlLlNlbGVjdGlvbik7XG5cbkdhcEN1cnNvci5wcm90b3R5cGUudmlzaWJsZSA9IGZhbHNlO1xuR2FwQ3Vyc29yLmZpbmRGcm9tID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tO1xucHJvc2VtaXJyb3JTdGF0ZS5TZWxlY3Rpb24uanNvbklEKFwiZ2FwY3Vyc29yXCIsIEdhcEN1cnNvcik7XG5cbnZhciBHYXBCb29rbWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gR2FwQm9va21hcmsocG9zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdhcEJvb2ttYXJrKTtcblxuICAgIHRoaXMucG9zID0gcG9zO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdhcEJvb2ttYXJrLCBbe1xuICAgIGtleTogXCJtYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKG1hcHBpbmcpIHtcbiAgICAgIHJldHVybiBuZXcgR2FwQm9va21hcmsobWFwcGluZy5tYXAodGhpcy5wb3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKGRvYykge1xuICAgICAgdmFyICRwb3MgPSBkb2MucmVzb2x2ZSh0aGlzLnBvcyk7XG4gICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IHByb3NlbWlycm9yU3RhdGUuU2VsZWN0aW9uLm5lYXIoJHBvcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdhcEJvb2ttYXJrO1xufSgpO1xuXG5mdW5jdGlvbiBjbG9zZWRCZWZvcmUoJHBvcykge1xuICBmb3IgKHZhciBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICB2YXIgaW5kZXggPSAkcG9zLmluZGV4KGQpLFxuICAgICAgICBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG5cbiAgICBpZiAoaW5kZXggPT0gMCkge1xuICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpOzsgYmVmb3JlID0gYmVmb3JlLmxhc3RDaGlsZCkge1xuICAgICAgaWYgKGJlZm9yZS5jaGlsZENvdW50ID09IDAgJiYgIWJlZm9yZS5pbmxpbmVDb250ZW50IHx8IGJlZm9yZS5pc0F0b20gfHwgYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGJlZm9yZS5pbmxpbmVDb250ZW50KSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNsb3NlZEFmdGVyKCRwb3MpIHtcbiAgZm9yICh2YXIgZCA9ICRwb3MuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgdmFyIGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpLFxuICAgICAgICBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG5cbiAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpIHtcbiAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykgcmV0dXJuIHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBhZnRlciA9IHBhcmVudC5jaGlsZChpbmRleCk7OyBhZnRlciA9IGFmdGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGlmIChhZnRlci5jaGlsZENvdW50ID09IDAgJiYgIWFmdGVyLmlubGluZUNvbnRlbnQgfHwgYWZ0ZXIuaXNBdG9tIHx8IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGFmdGVyLmlubGluZUNvbnRlbnQpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2FwQ3Vyc29yKCkge1xuICByZXR1cm4gbmV3IHByb3NlbWlycm9yU3RhdGUuUGx1Z2luKHtcbiAgICBwcm9wczoge1xuICAgICAgZGVjb3JhdGlvbnM6IGRyYXdHYXBDdXJzb3IsXG4gICAgICBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuOiBmdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb25CZXR3ZWVuKF92aWV3LCAkYW5jaG9yLCAkaGVhZCkge1xuICAgICAgICByZXR1cm4gJGFuY2hvci5wb3MgPT0gJGhlYWQucG9zICYmIEdhcEN1cnNvci52YWxpZCgkaGVhZCkgPyBuZXcgR2FwQ3Vyc29yKCRoZWFkKSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2xpY2s6IGhhbmRsZUNsaWNrLFxuICAgICAgaGFuZGxlS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICBiZWZvcmVpbnB1dDogYmVmb3JlaW5wdXRcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG52YXIgaGFuZGxlS2V5RG93biA9IHByb3NlbWlycm9yS2V5bWFwLmtleWRvd25IYW5kbGVyKHtcbiAgXCJBcnJvd0xlZnRcIjogYXJyb3coXCJob3JpelwiLCAtMSksXG4gIFwiQXJyb3dSaWdodFwiOiBhcnJvdyhcImhvcml6XCIsIDEpLFxuICBcIkFycm93VXBcIjogYXJyb3coXCJ2ZXJ0XCIsIC0xKSxcbiAgXCJBcnJvd0Rvd25cIjogYXJyb3coXCJ2ZXJ0XCIsIDEpXG59KTtcblxuZnVuY3Rpb24gYXJyb3coYXhpcywgZGlyKSB7XG4gIHZhciBkaXJTdHIgPSBheGlzID09IFwidmVydFwiID8gZGlyID4gMCA/IFwiZG93blwiIDogXCJ1cFwiIDogZGlyID4gMCA/IFwicmlnaHRcIiA6IFwibGVmdFwiO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykge1xuICAgIHZhciBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgdmFyICRzdGFydCA9IGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tLFxuICAgICAgICBtdXN0TW92ZSA9IHNlbC5lbXB0eTtcblxuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24pIHtcbiAgICAgIGlmICghdmlldy5lbmRPZlRleHRibG9jayhkaXJTdHIpIHx8ICRzdGFydC5kZXB0aCA9PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzdGFydC5hZnRlcigpIDogJHN0YXJ0LmJlZm9yZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgJGZvdW5kID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tKCRzdGFydCwgZGlyLCBtdXN0TW92ZSk7XG4gICAgaWYgKCEkZm91bmQpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRmb3VuZCkpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2xpY2sodmlldywgcG9zLCBldmVudCkge1xuICBpZiAoIXZpZXcgfHwgIXZpZXcuZWRpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgdmFyICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gIGlmICghR2FwQ3Vyc29yLnZhbGlkKCRwb3MpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBjbGlja1BvcyA9IHZpZXcucG9zQXRDb29yZHMoe1xuICAgIGxlZnQ6IGV2ZW50LmNsaWVudFgsXG4gICAgdG9wOiBldmVudC5jbGllbnRZXG4gIH0pO1xuICBpZiAoY2xpY2tQb3MgJiYgY2xpY2tQb3MuaW5zaWRlID4gLTEgJiYgcHJvc2VtaXJyb3JTdGF0ZS5Ob2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh2aWV3LnN0YXRlLmRvYy5ub2RlQXQoY2xpY2tQb3MuaW5zaWRlKSkpIHJldHVybiBmYWxzZTtcbiAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgR2FwQ3Vyc29yKCRwb3MpKSk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBiZWZvcmVpbnB1dCh2aWV3LCBldmVudCkge1xuICBpZiAoZXZlbnQuaW5wdXRUeXBlICE9IFwiaW5zZXJ0Q29tcG9zaXRpb25UZXh0XCIgfHwgISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpIHJldHVybiBmYWxzZTtcbiAgdmFyICRmcm9tID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gIHZhciBpbnNlcnQgPSAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSkuZmluZFdyYXBwaW5nKHZpZXcuc3RhdGUuc2NoZW1hLm5vZGVzLnRleHQpO1xuICBpZiAoIWluc2VydCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgZnJhZyA9IHByb3NlbWlycm9yTW9kZWwuRnJhZ21lbnQuZW1wdHk7XG5cbiAgZm9yICh2YXIgaSA9IGluc2VydC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZyYWcgPSBwcm9zZW1pcnJvck1vZGVsLkZyYWdtZW50LmZyb20oaW5zZXJ0W2ldLmNyZWF0ZUFuZEZpbGwobnVsbCwgZnJhZykpO1xuICB9XG5cbiAgdmFyIHRyID0gdmlldy5zdGF0ZS50ci5yZXBsYWNlKCRmcm9tLnBvcywgJGZyb20ucG9zLCBuZXcgcHJvc2VtaXJyb3JNb2RlbC5TbGljZShmcmFnLCAwLCAwKSk7XG4gIHRyLnNldFNlbGVjdGlvbihwcm9zZW1pcnJvclN0YXRlLlRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZSgkZnJvbS5wb3MgKyAxKSkpO1xuICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkcmF3R2FwQ3Vyc29yKHN0YXRlKSB7XG4gIGlmICghKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEdhcEN1cnNvcikpIHJldHVybiBudWxsO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG5vZGUuY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1nYXBjdXJzb3JcIjtcbiAgcmV0dXJuIHByb3NlbWlycm9yVmlldy5EZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIFtwcm9zZW1pcnJvclZpZXcuRGVjb3JhdGlvbi53aWRnZXQoc3RhdGUuc2VsZWN0aW9uLmhlYWQsIG5vZGUsIHtcbiAgICBrZXk6IFwiZ2FwY3Vyc29yXCJcbiAgfSldKTtcbn1cblxuZXhwb3J0cy5HYXBDdXJzb3IgPSBHYXBDdXJzb3I7XG5leHBvcnRzLmdhcEN1cnNvciA9IGdhcEN1cnNvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/prosemirror-gapcursor@1.3.2/node_modules/prosemirror-gapcursor/dist/index.cjs\n");

/***/ })

};
;