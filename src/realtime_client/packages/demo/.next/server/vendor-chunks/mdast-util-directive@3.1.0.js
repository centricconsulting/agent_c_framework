"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-directive@3.1.0";
exports.ids = ["vendor-chunks/mdast-util-directive@3.1.0"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/mdast-util-directive@3.1.0/node_modules/mdast-util-directive/lib/index.js":
/*!**********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/mdast-util-directive@3.1.0/node_modules/mdast-util-directive/lib/index.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   directiveFromMarkdown: () => (/* binding */ directiveFromMarkdown),\n/* harmony export */   directiveToMarkdown: () => (/* binding */ directiveToMarkdown)\n/* harmony export */ });\n/* harmony import */ var ccount__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ccount */ \"(ssr)/../../node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js\");\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! devlop */ \"(ssr)/../../node_modules/.pnpm/devlop@1.1.0/node_modules/devlop/lib/development.js\");\n/* harmony import */ var parse_entities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! parse-entities */ \"(ssr)/../../node_modules/.pnpm/parse-entities@4.0.2/node_modules/parse-entities/lib/index.js\");\n/* harmony import */ var stringify_entities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stringify-entities */ \"(ssr)/../../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js\");\n/* harmony import */ var unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! unist-util-visit-parents */ \"(ssr)/../../node_modules/.pnpm/unist-util-visit-parents@6.0.1/node_modules/unist-util-visit-parents/lib/index.js\");\n/**\n * @import {Directives, LeafDirective, TextDirective, ToMarkdownOptions} from 'mdast-util-directive'\n * @import {\n *   CompileContext,\n *   Extension as FromMarkdownExtension,\n *   Handle as FromMarkdownHandle,\n *   Token\n * } from 'mdast-util-from-markdown'\n * @import {\n *   ConstructName,\n *   Handle as ToMarkdownHandle,\n *   Options as ToMarkdownExtension,\n *   State\n * } from 'mdast-util-to-markdown'\n * @import {Nodes, Paragraph} from 'mdast'\n */\n\n\n\n\n\n\n\nconst own = {}.hasOwnProperty\n\n/** @type {Readonly<ToMarkdownOptions>} */\nconst emptyOptions = {}\n\nconst shortcut = /^[^\\t\\n\\r \"#'.<=>`}]+$/\nconst unquoted = /^[^\\t\\n\\r \"'<=>`}]+$/\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable directives in\n * markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable directives.\n */\nfunction directiveFromMarkdown() {\n  return {\n    canContainEols: ['textDirective'],\n    enter: {\n      directiveContainer: enterContainer,\n      directiveContainerAttributes: enterAttributes,\n      directiveContainerLabel: enterContainerLabel,\n\n      directiveLeaf: enterLeaf,\n      directiveLeafAttributes: enterAttributes,\n\n      directiveText: enterText,\n      directiveTextAttributes: enterAttributes\n    },\n    exit: {\n      directiveContainer: exit,\n      directiveContainerAttributeClassValue: exitAttributeClassValue,\n      directiveContainerAttributeIdValue: exitAttributeIdValue,\n      directiveContainerAttributeName: exitAttributeName,\n      directiveContainerAttributeValue: exitAttributeValue,\n      directiveContainerAttributes: exitAttributes,\n      directiveContainerLabel: exitContainerLabel,\n      directiveContainerName: exitName,\n\n      directiveLeaf: exit,\n      directiveLeafAttributeClassValue: exitAttributeClassValue,\n      directiveLeafAttributeIdValue: exitAttributeIdValue,\n      directiveLeafAttributeName: exitAttributeName,\n      directiveLeafAttributeValue: exitAttributeValue,\n      directiveLeafAttributes: exitAttributes,\n      directiveLeafName: exitName,\n\n      directiveText: exit,\n      directiveTextAttributeClassValue: exitAttributeClassValue,\n      directiveTextAttributeIdValue: exitAttributeIdValue,\n      directiveTextAttributeName: exitAttributeName,\n      directiveTextAttributeValue: exitAttributeValue,\n      directiveTextAttributes: exitAttributes,\n      directiveTextName: exitName\n    }\n  }\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown` to enable directives in\n * markdown.\n *\n * @param {Readonly<ToMarkdownOptions> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable directives.\n */\nfunction directiveToMarkdown(options) {\n  const settings = options || emptyOptions\n\n  if (\n    settings.quote !== '\"' &&\n    settings.quote !== \"'\" &&\n    settings.quote !== null &&\n    settings.quote !== undefined\n  ) {\n    throw new Error(\n      'Invalid quote `' + settings.quote + '`, expected `\\'` or `\"`'\n    )\n  }\n\n  handleDirective.peek = peekDirective\n\n  return {\n    handlers: {\n      containerDirective: handleDirective,\n      leafDirective: handleDirective,\n      textDirective: handleDirective\n    },\n    unsafe: [\n      {\n        character: '\\r',\n        inConstruct: ['leafDirectiveLabel', 'containerDirectiveLabel']\n      },\n      {\n        character: '\\n',\n        inConstruct: ['leafDirectiveLabel', 'containerDirectiveLabel']\n      },\n      {\n        before: '[^:]',\n        character: ':',\n        after: '[A-Za-z]',\n        inConstruct: ['phrasing']\n      },\n      {atBreak: true, character: ':', after: ':'}\n    ]\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Directives} node\n   */\n  function handleDirective(node, _, state, info) {\n    const tracker = state.createTracker(info)\n    const sequence = fence(node)\n    const exit = state.enter(node.type)\n    let value = tracker.move(sequence + (node.name || ''))\n    /** @type {LeafDirective | Paragraph | TextDirective | undefined} */\n    let label\n\n    if (node.type === 'containerDirective') {\n      const head = (node.children || [])[0]\n      label = inlineDirectiveLabel(head) ? head : undefined\n    } else {\n      label = node\n    }\n\n    if (label && label.children && label.children.length > 0) {\n      const exit = state.enter('label')\n      /** @type {ConstructName} */\n      const labelType = `${node.type}Label`\n      const subexit = state.enter(labelType)\n      value += tracker.move('[')\n      value += tracker.move(\n        state.containerPhrasing(label, {\n          ...tracker.current(),\n          before: value,\n          after: ']'\n        })\n      )\n      value += tracker.move(']')\n      subexit()\n      exit()\n    }\n\n    value += tracker.move(attributes(node, state))\n\n    if (node.type === 'containerDirective') {\n      const head = (node.children || [])[0]\n      let shallow = node\n\n      if (inlineDirectiveLabel(head)) {\n        shallow = Object.assign({}, node, {children: node.children.slice(1)})\n      }\n\n      if (shallow && shallow.children && shallow.children.length > 0) {\n        value += tracker.move('\\n')\n        value += tracker.move(state.containerFlow(shallow, tracker.current()))\n      }\n\n      value += tracker.move('\\n' + sequence)\n    }\n\n    exit()\n    return value\n  }\n\n  /**\n   * @param {Directives} node\n   * @param {State} state\n   * @returns {string}\n   */\n  function attributes(node, state) {\n    const attributes = node.attributes || {}\n    /** @type {Array<string>} */\n    const values = []\n    /** @type {string | undefined} */\n    let classesFull\n    /** @type {string | undefined} */\n    let classes\n    /** @type {string | undefined} */\n    let id\n    /** @type {string} */\n    let key\n\n    for (key in attributes) {\n      if (\n        own.call(attributes, key) &&\n        attributes[key] !== undefined &&\n        attributes[key] !== null\n      ) {\n        const value = String(attributes[key])\n\n        // To do: next major:\n        // Do not reorder `id` and `class` attributes when they do not turn into\n        // shortcuts.\n        // Additionally, join shortcuts: `#a .b.c d=\"e\"` -> `#a.b.c d=\"e\"`\n        if (key === 'id') {\n          id =\n            settings.preferShortcut !== false && shortcut.test(value)\n              ? '#' + value\n              : quoted('id', value, node, state)\n        } else if (key === 'class') {\n          const list = value.split(/[\\t\\n\\r ]+/g)\n          /** @type {Array<string>} */\n          const classesFullList = []\n          /** @type {Array<string>} */\n          const classesList = []\n          let index = -1\n\n          while (++index < list.length) {\n            ;(settings.preferShortcut !== false && shortcut.test(list[index])\n              ? classesList\n              : classesFullList\n            ).push(list[index])\n          }\n\n          classesFull =\n            classesFullList.length > 0\n              ? quoted('class', classesFullList.join(' '), node, state)\n              : ''\n          classes = classesList.length > 0 ? '.' + classesList.join('.') : ''\n        } else {\n          values.push(quoted(key, value, node, state))\n        }\n      }\n    }\n\n    if (classesFull) {\n      values.unshift(classesFull)\n    }\n\n    if (classes) {\n      values.unshift(classes)\n    }\n\n    if (id) {\n      values.unshift(id)\n    }\n\n    return values.length > 0 ? '{' + values.join(' ') + '}' : ''\n  }\n\n  /**\n   * @param {string} key\n   * @param {string} value\n   * @param {Directives} node\n   * @param {State} state\n   * @returns {string}\n   */\n  function quoted(key, value, node, state) {\n    if (settings.collapseEmptyAttributes !== false && !value) return key\n\n    if (settings.preferUnquoted && unquoted.test(value)) {\n      return key + '=' + value\n    }\n\n    // If the alternative is less common than `quote`, switch.\n    const preferred = settings.quote || state.options.quote || '\"'\n    const alternative = preferred === '\"' ? \"'\" : '\"'\n    // If the alternative is less common than `quote`, switch.\n    const appliedQuote =\n      settings.quoteSmart &&\n      (0,ccount__WEBPACK_IMPORTED_MODULE_0__.ccount)(value, preferred) > (0,ccount__WEBPACK_IMPORTED_MODULE_0__.ccount)(value, alternative)\n        ? alternative\n        : preferred\n    const subset =\n      node.type === 'textDirective'\n        ? [appliedQuote]\n        : [appliedQuote, '\\n', '\\r']\n\n    return (\n      key +\n      '=' +\n      appliedQuote +\n      (0,stringify_entities__WEBPACK_IMPORTED_MODULE_1__.stringifyEntitiesLight)(value, {subset}) +\n      appliedQuote\n    )\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterContainer(token) {\n  enter.call(this, 'containerDirective', token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterLeaf(token) {\n  enter.call(this, 'leafDirective', token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterText(token) {\n  enter.call(this, 'textDirective', token)\n}\n\n/**\n * @this {CompileContext}\n * @param {Directives['type']} type\n * @param {Token} token\n */\nfunction enter(type, token) {\n  this.enter({type, name: '', attributes: {}, children: []}, token)\n}\n\n/**\n * @this {CompileContext}\n * @param {Token} token\n */\nfunction exitName(token) {\n  const node = this.stack[this.stack.length - 1]\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(\n    node.type === 'containerDirective' ||\n      node.type === 'leafDirective' ||\n      node.type === 'textDirective'\n  )\n  node.name = this.sliceSerialize(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterContainerLabel(token) {\n  this.enter(\n    {type: 'paragraph', data: {directiveLabel: true}, children: []},\n    token\n  )\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitContainerLabel(token) {\n  this.exit(token)\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction enterAttributes() {\n  this.data.directiveAttributes = []\n  this.buffer() // Capture EOLs\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributeIdValue(token) {\n  const list = this.data.directiveAttributes\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(list, 'expected `directiveAttributes`')\n  list.push([\n    'id',\n    (0,parse_entities__WEBPACK_IMPORTED_MODULE_3__.parseEntities)(this.sliceSerialize(token), {attribute: true})\n  ])\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributeClassValue(token) {\n  const list = this.data.directiveAttributes\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(list, 'expected `directiveAttributes`')\n  list.push([\n    'class',\n    (0,parse_entities__WEBPACK_IMPORTED_MODULE_3__.parseEntities)(this.sliceSerialize(token), {attribute: true})\n  ])\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributeValue(token) {\n  const list = this.data.directiveAttributes\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(list, 'expected `directiveAttributes`')\n  list[list.length - 1][1] = (0,parse_entities__WEBPACK_IMPORTED_MODULE_3__.parseEntities)(this.sliceSerialize(token), {\n    attribute: true\n  })\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributeName(token) {\n  const list = this.data.directiveAttributes\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(list, 'expected `directiveAttributes`')\n\n  // Attribute names in CommonMark are significantly limited, so character\n  // references can’t exist.\n  list.push([this.sliceSerialize(token), ''])\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exitAttributes() {\n  const list = this.data.directiveAttributes\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(list, 'expected `directiveAttributes`')\n  /** @type {Record<string, string>} */\n  const cleaned = {}\n  let index = -1\n\n  while (++index < list.length) {\n    const attribute = list[index]\n\n    if (attribute[0] === 'class' && cleaned.class) {\n      cleaned.class += ' ' + attribute[1]\n    } else {\n      cleaned[attribute[0]] = attribute[1]\n    }\n  }\n\n  this.data.directiveAttributes = undefined\n  this.resume() // Drop EOLs\n  const node = this.stack[this.stack.length - 1]\n  ;(0,devlop__WEBPACK_IMPORTED_MODULE_2__.ok)(\n    node.type === 'containerDirective' ||\n      node.type === 'leafDirective' ||\n      node.type === 'textDirective'\n  )\n  node.attributes = cleaned\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction exit(token) {\n  this.exit(token)\n}\n\n/** @type {ToMarkdownHandle} */\nfunction peekDirective() {\n  return ':'\n}\n\n/**\n * @param {Nodes} node\n * @returns {node is Paragraph & {data: {directiveLabel: true}}}\n */\nfunction inlineDirectiveLabel(node) {\n  return Boolean(\n    node && node.type === 'paragraph' && node.data && node.data.directiveLabel\n  )\n}\n\n/**\n * @param {Directives} node\n * @returns {string}\n */\nfunction fence(node) {\n  let size = 0\n\n  if (node.type === 'containerDirective') {\n    (0,unist_util_visit_parents__WEBPACK_IMPORTED_MODULE_4__.visitParents)(node, function (node, parents) {\n      if (node.type === 'containerDirective') {\n        let index = parents.length\n        let nesting = 0\n\n        while (index--) {\n          if (parents[index].type === 'containerDirective') {\n            nesting++\n          }\n        }\n\n        if (nesting > size) size = nesting\n      }\n    })\n    size += 3\n  } else if (node.type === 'leafDirective') {\n    size = 2\n  } else {\n    size = 1\n  }\n\n  return ':'.repeat(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21kYXN0LXV0aWwtZGlyZWN0aXZlQDMuMS4wL25vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWRpcmVjdGl2ZS9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0EsWUFBWSw2REFBNkQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksa0JBQWtCO0FBQzlCOztBQUU2QjtBQUNNO0FBQ1M7QUFDYTtBQUNKOztBQUVyRCxjQUFjOztBQUVkLFdBQVcsNkJBQTZCO0FBQ3hDOztBQUVBLHFDQUFxQztBQUNyQyxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBZ0Q7QUFDM0Q7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWixhQUFhLFlB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QUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyQ0FBTTtBQUNSLDZCQUE2Qiw2REFBYTtBQUMxQztBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyQ0FBTTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyQ0FBTTtBQUNSLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDJDQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxxQkFBcUIsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksc0VBQVk7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FYm9vdGgvYWdlbnRfY19mcmFtZXdvcmsvc3JjL3JlYWx0aW1lX2NsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vbWRhc3QtdXRpbC1kaXJlY3RpdmVAMy4xLjAvbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZGlyZWN0aXZlL2xpYi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBpbXBvcnQge0RpcmVjdGl2ZXMsIExlYWZEaXJlY3RpdmUsIFRleHREaXJlY3RpdmUsIFRvTWFya2Rvd25PcHRpb25zfSBmcm9tICdtZGFzdC11dGlsLWRpcmVjdGl2ZSdcbiAqIEBpbXBvcnQge1xuICogICBDb21waWxlQ29udGV4dCxcbiAqICAgRXh0ZW5zaW9uIGFzIEZyb21NYXJrZG93bkV4dGVuc2lvbixcbiAqICAgSGFuZGxlIGFzIEZyb21NYXJrZG93bkhhbmRsZSxcbiAqICAgVG9rZW5cbiAqIH0gZnJvbSAnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJ1xuICogQGltcG9ydCB7XG4gKiAgIENvbnN0cnVjdE5hbWUsXG4gKiAgIEhhbmRsZSBhcyBUb01hcmtkb3duSGFuZGxlLFxuICogICBPcHRpb25zIGFzIFRvTWFya2Rvd25FeHRlbnNpb24sXG4gKiAgIFN0YXRlXG4gKiB9IGZyb20gJ21kYXN0LXV0aWwtdG8tbWFya2Rvd24nXG4gKiBAaW1wb3J0IHtOb2RlcywgUGFyYWdyYXBofSBmcm9tICdtZGFzdCdcbiAqL1xuXG5pbXBvcnQge2Njb3VudH0gZnJvbSAnY2NvdW50J1xuaW1wb3J0IHtvayBhcyBhc3NlcnR9IGZyb20gJ2RldmxvcCdcbmltcG9ydCB7cGFyc2VFbnRpdGllc30gZnJvbSAncGFyc2UtZW50aXRpZXMnXG5pbXBvcnQge3N0cmluZ2lmeUVudGl0aWVzTGlnaHR9IGZyb20gJ3N0cmluZ2lmeS1lbnRpdGllcydcbmltcG9ydCB7dmlzaXRQYXJlbnRzfSBmcm9tICd1bmlzdC11dGlsLXZpc2l0LXBhcmVudHMnXG5cbmNvbnN0IG93biA9IHt9Lmhhc093blByb3BlcnR5XG5cbi8qKiBAdHlwZSB7UmVhZG9ubHk8VG9NYXJrZG93bk9wdGlvbnM+fSAqL1xuY29uc3QgZW1wdHlPcHRpb25zID0ge31cblxuY29uc3Qgc2hvcnRjdXQgPSAvXlteXFx0XFxuXFxyIFwiIycuPD0+YH1dKyQvXG5jb25zdCB1bnF1b3RlZCA9IC9eW15cXHRcXG5cXHIgXCInPD0+YH1dKyQvXG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtZnJvbS1tYXJrZG93bmAgdG8gZW5hYmxlIGRpcmVjdGl2ZXMgaW5cbiAqIG1hcmtkb3duLlxuICpcbiAqIEByZXR1cm5zIHtGcm9tTWFya2Rvd25FeHRlbnNpb259XG4gKiAgIEV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtZnJvbS1tYXJrZG93bmAgdG8gZW5hYmxlIGRpcmVjdGl2ZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXJlY3RpdmVGcm9tTWFya2Rvd24oKSB7XG4gIHJldHVybiB7XG4gICAgY2FuQ29udGFpbkVvbHM6IFsndGV4dERpcmVjdGl2ZSddLFxuICAgIGVudGVyOiB7XG4gICAgICBkaXJlY3RpdmVDb250YWluZXI6IGVudGVyQ29udGFpbmVyLFxuICAgICAgZGlyZWN0aXZlQ29udGFpbmVyQXR0cmlidXRlczogZW50ZXJBdHRyaWJ1dGVzLFxuICAgICAgZGlyZWN0aXZlQ29udGFpbmVyTGFiZWw6IGVudGVyQ29udGFpbmVyTGFiZWwsXG5cbiAgICAgIGRpcmVjdGl2ZUxlYWY6IGVudGVyTGVhZixcbiAgICAgIGRpcmVjdGl2ZUxlYWZBdHRyaWJ1dGVzOiBlbnRlckF0dHJpYnV0ZXMsXG5cbiAgICAgIGRpcmVjdGl2ZVRleHQ6IGVudGVyVGV4dCxcbiAgICAgIGRpcmVjdGl2ZVRleHRBdHRyaWJ1dGVzOiBlbnRlckF0dHJpYnV0ZXNcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIGRpcmVjdGl2ZUNvbnRhaW5lcjogZXhpdCxcbiAgICAgIGRpcmVjdGl2ZUNvbnRhaW5lckF0dHJpYnV0ZUNsYXNzVmFsdWU6IGV4aXRBdHRyaWJ1dGVDbGFzc1ZhbHVlLFxuICAgICAgZGlyZWN0aXZlQ29udGFpbmVyQXR0cmlidXRlSWRWYWx1ZTogZXhpdEF0dHJpYnV0ZUlkVmFsdWUsXG4gICAgICBkaXJlY3RpdmVDb250YWluZXJBdHRyaWJ1dGVOYW1lOiBleGl0QXR0cmlidXRlTmFtZSxcbiAgICAgIGRpcmVjdGl2ZUNvbnRhaW5lckF0dHJpYnV0ZVZhbHVlOiBleGl0QXR0cmlidXRlVmFsdWUsXG4gICAgICBkaXJlY3RpdmVDb250YWluZXJBdHRyaWJ1dGVzOiBleGl0QXR0cmlidXRlcyxcbiAgICAgIGRpcmVjdGl2ZUNvbnRhaW5lckxhYmVsOiBleGl0Q29udGFpbmVyTGFiZWwsXG4gICAgICBkaXJlY3RpdmVDb250YWluZXJOYW1lOiBleGl0TmFtZSxcblxuICAgICAgZGlyZWN0aXZlTGVhZjogZXhpdCxcbiAgICAgIGRpcmVjdGl2ZUxlYWZBdHRyaWJ1dGVDbGFzc1ZhbHVlOiBleGl0QXR0cmlidXRlQ2xhc3NWYWx1ZSxcbiAgICAgIGRpcmVjdGl2ZUxlYWZBdHRyaWJ1dGVJZFZhbHVlOiBleGl0QXR0cmlidXRlSWRWYWx1ZSxcbiAgICAgIGRpcmVjdGl2ZUxlYWZBdHRyaWJ1dGVOYW1lOiBleGl0QXR0cmlidXRlTmFtZSxcbiAgICAgIGRpcmVjdGl2ZUxlYWZBdHRyaWJ1dGVWYWx1ZTogZXhpdEF0dHJpYnV0ZVZhbHVlLFxuICAgICAgZGlyZWN0aXZlTGVhZkF0dHJpYnV0ZXM6IGV4aXRBdHRyaWJ1dGVzLFxuICAgICAgZGlyZWN0aXZlTGVhZk5hbWU6IGV4aXROYW1lLFxuXG4gICAgICBkaXJlY3RpdmVUZXh0OiBleGl0LFxuICAgICAgZGlyZWN0aXZlVGV4dEF0dHJpYnV0ZUNsYXNzVmFsdWU6IGV4aXRBdHRyaWJ1dGVDbGFzc1ZhbHVlLFxuICAgICAgZGlyZWN0aXZlVGV4dEF0dHJpYnV0ZUlkVmFsdWU6IGV4aXRBdHRyaWJ1dGVJZFZhbHVlLFxuICAgICAgZGlyZWN0aXZlVGV4dEF0dHJpYnV0ZU5hbWU6IGV4aXRBdHRyaWJ1dGVOYW1lLFxuICAgICAgZGlyZWN0aXZlVGV4dEF0dHJpYnV0ZVZhbHVlOiBleGl0QXR0cmlidXRlVmFsdWUsXG4gICAgICBkaXJlY3RpdmVUZXh0QXR0cmlidXRlczogZXhpdEF0dHJpYnV0ZXMsXG4gICAgICBkaXJlY3RpdmVUZXh0TmFtZTogZXhpdE5hbWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIGZvciBgbWRhc3QtdXRpbC10by1tYXJrZG93bmAgdG8gZW5hYmxlIGRpcmVjdGl2ZXMgaW5cbiAqIG1hcmtkb3duLlxuICpcbiAqIEBwYXJhbSB7UmVhZG9ubHk8VG9NYXJrZG93bk9wdGlvbnM+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS5cbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB0byBlbmFibGUgZGlyZWN0aXZlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpcmVjdGl2ZVRvTWFya2Rvd24ob3B0aW9ucykge1xuICBjb25zdCBzZXR0aW5ncyA9IG9wdGlvbnMgfHwgZW1wdHlPcHRpb25zXG5cbiAgaWYgKFxuICAgIHNldHRpbmdzLnF1b3RlICE9PSAnXCInICYmXG4gICAgc2V0dGluZ3MucXVvdGUgIT09IFwiJ1wiICYmXG4gICAgc2V0dGluZ3MucXVvdGUgIT09IG51bGwgJiZcbiAgICBzZXR0aW5ncy5xdW90ZSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHF1b3RlIGAnICsgc2V0dGluZ3MucXVvdGUgKyAnYCwgZXhwZWN0ZWQgYFxcJ2Agb3IgYFwiYCdcbiAgICApXG4gIH1cblxuICBoYW5kbGVEaXJlY3RpdmUucGVlayA9IHBlZWtEaXJlY3RpdmVcblxuICByZXR1cm4ge1xuICAgIGhhbmRsZXJzOiB7XG4gICAgICBjb250YWluZXJEaXJlY3RpdmU6IGhhbmRsZURpcmVjdGl2ZSxcbiAgICAgIGxlYWZEaXJlY3RpdmU6IGhhbmRsZURpcmVjdGl2ZSxcbiAgICAgIHRleHREaXJlY3RpdmU6IGhhbmRsZURpcmVjdGl2ZVxuICAgIH0sXG4gICAgdW5zYWZlOiBbXG4gICAgICB7XG4gICAgICAgIGNoYXJhY3RlcjogJ1xccicsXG4gICAgICAgIGluQ29uc3RydWN0OiBbJ2xlYWZEaXJlY3RpdmVMYWJlbCcsICdjb250YWluZXJEaXJlY3RpdmVMYWJlbCddXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjaGFyYWN0ZXI6ICdcXG4nLFxuICAgICAgICBpbkNvbnN0cnVjdDogWydsZWFmRGlyZWN0aXZlTGFiZWwnLCAnY29udGFpbmVyRGlyZWN0aXZlTGFiZWwnXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVmb3JlOiAnW146XScsXG4gICAgICAgIGNoYXJhY3RlcjogJzonLFxuICAgICAgICBhZnRlcjogJ1tBLVphLXpdJyxcbiAgICAgICAgaW5Db25zdHJ1Y3Q6IFsncGhyYXNpbmcnXVxuICAgICAgfSxcbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICc6JywgYWZ0ZXI6ICc6J31cbiAgICBdXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7RGlyZWN0aXZlc30gbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlRGlyZWN0aXZlKG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gICAgY29uc3QgdHJhY2tlciA9IHN0YXRlLmNyZWF0ZVRyYWNrZXIoaW5mbylcbiAgICBjb25zdCBzZXF1ZW5jZSA9IGZlbmNlKG5vZGUpXG4gICAgY29uc3QgZXhpdCA9IHN0YXRlLmVudGVyKG5vZGUudHlwZSlcbiAgICBsZXQgdmFsdWUgPSB0cmFja2VyLm1vdmUoc2VxdWVuY2UgKyAobm9kZS5uYW1lIHx8ICcnKSlcbiAgICAvKiogQHR5cGUge0xlYWZEaXJlY3RpdmUgfCBQYXJhZ3JhcGggfCBUZXh0RGlyZWN0aXZlIHwgdW5kZWZpbmVkfSAqL1xuICAgIGxldCBsYWJlbFxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbnRhaW5lckRpcmVjdGl2ZScpIHtcbiAgICAgIGNvbnN0IGhlYWQgPSAobm9kZS5jaGlsZHJlbiB8fCBbXSlbMF1cbiAgICAgIGxhYmVsID0gaW5saW5lRGlyZWN0aXZlTGFiZWwoaGVhZCkgPyBoZWFkIDogdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsID0gbm9kZVxuICAgIH1cblxuICAgIGlmIChsYWJlbCAmJiBsYWJlbC5jaGlsZHJlbiAmJiBsYWJlbC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBleGl0ID0gc3RhdGUuZW50ZXIoJ2xhYmVsJylcbiAgICAgIC8qKiBAdHlwZSB7Q29uc3RydWN0TmFtZX0gKi9cbiAgICAgIGNvbnN0IGxhYmVsVHlwZSA9IGAke25vZGUudHlwZX1MYWJlbGBcbiAgICAgIGNvbnN0IHN1YmV4aXQgPSBzdGF0ZS5lbnRlcihsYWJlbFR5cGUpXG4gICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ1snKVxuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKFxuICAgICAgICBzdGF0ZS5jb250YWluZXJQaHJhc2luZyhsYWJlbCwge1xuICAgICAgICAgIC4uLnRyYWNrZXIuY3VycmVudCgpLFxuICAgICAgICAgIGJlZm9yZTogdmFsdWUsXG4gICAgICAgICAgYWZ0ZXI6ICddJ1xuICAgICAgICB9KVxuICAgICAgKVxuICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKCddJylcbiAgICAgIHN1YmV4aXQoKVxuICAgICAgZXhpdCgpXG4gICAgfVxuXG4gICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKGF0dHJpYnV0ZXMobm9kZSwgc3RhdGUpKVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbnRhaW5lckRpcmVjdGl2ZScpIHtcbiAgICAgIGNvbnN0IGhlYWQgPSAobm9kZS5jaGlsZHJlbiB8fCBbXSlbMF1cbiAgICAgIGxldCBzaGFsbG93ID0gbm9kZVxuXG4gICAgICBpZiAoaW5saW5lRGlyZWN0aXZlTGFiZWwoaGVhZCkpIHtcbiAgICAgICAgc2hhbGxvdyA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUsIHtjaGlsZHJlbjogbm9kZS5jaGlsZHJlbi5zbGljZSgxKX0pXG4gICAgICB9XG5cbiAgICAgIGlmIChzaGFsbG93ICYmIHNoYWxsb3cuY2hpbGRyZW4gJiYgc2hhbGxvdy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhbHVlICs9IHRyYWNrZXIubW92ZSgnXFxuJylcbiAgICAgICAgdmFsdWUgKz0gdHJhY2tlci5tb3ZlKHN0YXRlLmNvbnRhaW5lckZsb3coc2hhbGxvdywgdHJhY2tlci5jdXJyZW50KCkpKVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSArPSB0cmFja2VyLm1vdmUoJ1xcbicgKyBzZXF1ZW5jZSlcbiAgICB9XG5cbiAgICBleGl0KClcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RpcmVjdGl2ZXN9IG5vZGVcbiAgICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGF0dHJpYnV0ZXMobm9kZSwgc3RhdGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzIHx8IHt9XG4gICAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdXG4gICAgLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGNsYXNzZXNGdWxsXG4gICAgLyoqIEB0eXBlIHtzdHJpbmcgfCB1bmRlZmluZWR9ICovXG4gICAgbGV0IGNsYXNzZXNcbiAgICAvKiogQHR5cGUge3N0cmluZyB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgaWRcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBsZXQga2V5XG5cbiAgICBmb3IgKGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG93bi5jYWxsKGF0dHJpYnV0ZXMsIGtleSkgJiZcbiAgICAgICAgYXR0cmlidXRlc1trZXldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgYXR0cmlidXRlc1trZXldICE9PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBTdHJpbmcoYXR0cmlidXRlc1trZXldKVxuXG4gICAgICAgIC8vIFRvIGRvOiBuZXh0IG1ham9yOlxuICAgICAgICAvLyBEbyBub3QgcmVvcmRlciBgaWRgIGFuZCBgY2xhc3NgIGF0dHJpYnV0ZXMgd2hlbiB0aGV5IGRvIG5vdCB0dXJuIGludG9cbiAgICAgICAgLy8gc2hvcnRjdXRzLlxuICAgICAgICAvLyBBZGRpdGlvbmFsbHksIGpvaW4gc2hvcnRjdXRzOiBgI2EgLmIuYyBkPVwiZVwiYCAtPiBgI2EuYi5jIGQ9XCJlXCJgXG4gICAgICAgIGlmIChrZXkgPT09ICdpZCcpIHtcbiAgICAgICAgICBpZCA9XG4gICAgICAgICAgICBzZXR0aW5ncy5wcmVmZXJTaG9ydGN1dCAhPT0gZmFsc2UgJiYgc2hvcnRjdXQudGVzdCh2YWx1ZSlcbiAgICAgICAgICAgICAgPyAnIycgKyB2YWx1ZVxuICAgICAgICAgICAgICA6IHF1b3RlZCgnaWQnLCB2YWx1ZSwgbm9kZSwgc3RhdGUpXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IHZhbHVlLnNwbGl0KC9bXFx0XFxuXFxyIF0rL2cpXG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAgICAgICAgIGNvbnN0IGNsYXNzZXNGdWxsTGlzdCA9IFtdXG4gICAgICAgICAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAgICAgICAgIGNvbnN0IGNsYXNzZXNMaXN0ID0gW11cbiAgICAgICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgOyhzZXR0aW5ncy5wcmVmZXJTaG9ydGN1dCAhPT0gZmFsc2UgJiYgc2hvcnRjdXQudGVzdChsaXN0W2luZGV4XSlcbiAgICAgICAgICAgICAgPyBjbGFzc2VzTGlzdFxuICAgICAgICAgICAgICA6IGNsYXNzZXNGdWxsTGlzdFxuICAgICAgICAgICAgKS5wdXNoKGxpc3RbaW5kZXhdKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNsYXNzZXNGdWxsID1cbiAgICAgICAgICAgIGNsYXNzZXNGdWxsTGlzdC5sZW5ndGggPiAwXG4gICAgICAgICAgICAgID8gcXVvdGVkKCdjbGFzcycsIGNsYXNzZXNGdWxsTGlzdC5qb2luKCcgJyksIG5vZGUsIHN0YXRlKVxuICAgICAgICAgICAgICA6ICcnXG4gICAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXNMaXN0Lmxlbmd0aCA+IDAgPyAnLicgKyBjbGFzc2VzTGlzdC5qb2luKCcuJykgOiAnJ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlcy5wdXNoKHF1b3RlZChrZXksIHZhbHVlLCBub2RlLCBzdGF0ZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xhc3Nlc0Z1bGwpIHtcbiAgICAgIHZhbHVlcy51bnNoaWZ0KGNsYXNzZXNGdWxsKVxuICAgIH1cblxuICAgIGlmIChjbGFzc2VzKSB7XG4gICAgICB2YWx1ZXMudW5zaGlmdChjbGFzc2VzKVxuICAgIH1cblxuICAgIGlmIChpZCkge1xuICAgICAgdmFsdWVzLnVuc2hpZnQoaWQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPiAwID8gJ3snICsgdmFsdWVzLmpvaW4oJyAnKSArICd9JyA6ICcnXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtEaXJlY3RpdmVzfSBub2RlXG4gICAqIEBwYXJhbSB7U3RhdGV9IHN0YXRlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBmdW5jdGlvbiBxdW90ZWQoa2V5LCB2YWx1ZSwgbm9kZSwgc3RhdGUpIHtcbiAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VFbXB0eUF0dHJpYnV0ZXMgIT09IGZhbHNlICYmICF2YWx1ZSkgcmV0dXJuIGtleVxuXG4gICAgaWYgKHNldHRpbmdzLnByZWZlclVucXVvdGVkICYmIHVucXVvdGVkLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4ga2V5ICsgJz0nICsgdmFsdWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgYWx0ZXJuYXRpdmUgaXMgbGVzcyBjb21tb24gdGhhbiBgcXVvdGVgLCBzd2l0Y2guXG4gICAgY29uc3QgcHJlZmVycmVkID0gc2V0dGluZ3MucXVvdGUgfHwgc3RhdGUub3B0aW9ucy5xdW90ZSB8fCAnXCInXG4gICAgY29uc3QgYWx0ZXJuYXRpdmUgPSBwcmVmZXJyZWQgPT09ICdcIicgPyBcIidcIiA6ICdcIidcbiAgICAvLyBJZiB0aGUgYWx0ZXJuYXRpdmUgaXMgbGVzcyBjb21tb24gdGhhbiBgcXVvdGVgLCBzd2l0Y2guXG4gICAgY29uc3QgYXBwbGllZFF1b3RlID1cbiAgICAgIHNldHRpbmdzLnF1b3RlU21hcnQgJiZcbiAgICAgIGNjb3VudCh2YWx1ZSwgcHJlZmVycmVkKSA+IGNjb3VudCh2YWx1ZSwgYWx0ZXJuYXRpdmUpXG4gICAgICAgID8gYWx0ZXJuYXRpdmVcbiAgICAgICAgOiBwcmVmZXJyZWRcbiAgICBjb25zdCBzdWJzZXQgPVxuICAgICAgbm9kZS50eXBlID09PSAndGV4dERpcmVjdGl2ZSdcbiAgICAgICAgPyBbYXBwbGllZFF1b3RlXVxuICAgICAgICA6IFthcHBsaWVkUXVvdGUsICdcXG4nLCAnXFxyJ11cblxuICAgIHJldHVybiAoXG4gICAgICBrZXkgK1xuICAgICAgJz0nICtcbiAgICAgIGFwcGxpZWRRdW90ZSArXG4gICAgICBzdHJpbmdpZnlFbnRpdGllc0xpZ2h0KHZhbHVlLCB7c3Vic2V0fSkgK1xuICAgICAgYXBwbGllZFF1b3RlXG4gICAgKVxuICB9XG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZW50ZXJDb250YWluZXIodG9rZW4pIHtcbiAgZW50ZXIuY2FsbCh0aGlzLCAnY29udGFpbmVyRGlyZWN0aXZlJywgdG9rZW4pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZW50ZXJMZWFmKHRva2VuKSB7XG4gIGVudGVyLmNhbGwodGhpcywgJ2xlYWZEaXJlY3RpdmUnLCB0b2tlbilcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBlbnRlclRleHQodG9rZW4pIHtcbiAgZW50ZXIuY2FsbCh0aGlzLCAndGV4dERpcmVjdGl2ZScsIHRva2VuKVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEBwYXJhbSB7RGlyZWN0aXZlc1sndHlwZSddfSB0eXBlXG4gKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICovXG5mdW5jdGlvbiBlbnRlcih0eXBlLCB0b2tlbikge1xuICB0aGlzLmVudGVyKHt0eXBlLCBuYW1lOiAnJywgYXR0cmlidXRlczoge30sIGNoaWxkcmVuOiBbXX0sIHRva2VuKVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gKi9cbmZ1bmN0aW9uIGV4aXROYW1lKHRva2VuKSB7XG4gIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgYXNzZXJ0KFxuICAgIG5vZGUudHlwZSA9PT0gJ2NvbnRhaW5lckRpcmVjdGl2ZScgfHxcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2xlYWZEaXJlY3RpdmUnIHx8XG4gICAgICBub2RlLnR5cGUgPT09ICd0ZXh0RGlyZWN0aXZlJ1xuICApXG4gIG5vZGUubmFtZSA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZW50ZXJDb250YWluZXJMYWJlbCh0b2tlbikge1xuICB0aGlzLmVudGVyKFxuICAgIHt0eXBlOiAncGFyYWdyYXBoJywgZGF0YToge2RpcmVjdGl2ZUxhYmVsOiB0cnVlfSwgY2hpbGRyZW46IFtdfSxcbiAgICB0b2tlblxuICApXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdENvbnRhaW5lckxhYmVsKHRva2VuKSB7XG4gIHRoaXMuZXhpdCh0b2tlbilcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBlbnRlckF0dHJpYnV0ZXMoKSB7XG4gIHRoaXMuZGF0YS5kaXJlY3RpdmVBdHRyaWJ1dGVzID0gW11cbiAgdGhpcy5idWZmZXIoKSAvLyBDYXB0dXJlIEVPTHNcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBleGl0QXR0cmlidXRlSWRWYWx1ZSh0b2tlbikge1xuICBjb25zdCBsaXN0ID0gdGhpcy5kYXRhLmRpcmVjdGl2ZUF0dHJpYnV0ZXNcbiAgYXNzZXJ0KGxpc3QsICdleHBlY3RlZCBgZGlyZWN0aXZlQXR0cmlidXRlc2AnKVxuICBsaXN0LnB1c2goW1xuICAgICdpZCcsXG4gICAgcGFyc2VFbnRpdGllcyh0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKSwge2F0dHJpYnV0ZTogdHJ1ZX0pXG4gIF0pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdEF0dHJpYnV0ZUNsYXNzVmFsdWUodG9rZW4pIHtcbiAgY29uc3QgbGlzdCA9IHRoaXMuZGF0YS5kaXJlY3RpdmVBdHRyaWJ1dGVzXG4gIGFzc2VydChsaXN0LCAnZXhwZWN0ZWQgYGRpcmVjdGl2ZUF0dHJpYnV0ZXNgJylcbiAgbGlzdC5wdXNoKFtcbiAgICAnY2xhc3MnLFxuICAgIHBhcnNlRW50aXRpZXModGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbiksIHthdHRyaWJ1dGU6IHRydWV9KVxuICBdKVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGV4aXRBdHRyaWJ1dGVWYWx1ZSh0b2tlbikge1xuICBjb25zdCBsaXN0ID0gdGhpcy5kYXRhLmRpcmVjdGl2ZUF0dHJpYnV0ZXNcbiAgYXNzZXJ0KGxpc3QsICdleHBlY3RlZCBgZGlyZWN0aXZlQXR0cmlidXRlc2AnKVxuICBsaXN0W2xpc3QubGVuZ3RoIC0gMV1bMV0gPSBwYXJzZUVudGl0aWVzKHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLCB7XG4gICAgYXR0cmlidXRlOiB0cnVlXG4gIH0pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdEF0dHJpYnV0ZU5hbWUodG9rZW4pIHtcbiAgY29uc3QgbGlzdCA9IHRoaXMuZGF0YS5kaXJlY3RpdmVBdHRyaWJ1dGVzXG4gIGFzc2VydChsaXN0LCAnZXhwZWN0ZWQgYGRpcmVjdGl2ZUF0dHJpYnV0ZXNgJylcblxuICAvLyBBdHRyaWJ1dGUgbmFtZXMgaW4gQ29tbW9uTWFyayBhcmUgc2lnbmlmaWNhbnRseSBsaW1pdGVkLCBzbyBjaGFyYWN0ZXJcbiAgLy8gcmVmZXJlbmNlcyBjYW7igJl0IGV4aXN0LlxuICBsaXN0LnB1c2goW3RoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLCAnJ10pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdEF0dHJpYnV0ZXMoKSB7XG4gIGNvbnN0IGxpc3QgPSB0aGlzLmRhdGEuZGlyZWN0aXZlQXR0cmlidXRlc1xuICBhc3NlcnQobGlzdCwgJ2V4cGVjdGVkIGBkaXJlY3RpdmVBdHRyaWJ1dGVzYCcpXG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgY29uc3QgY2xlYW5lZCA9IHt9XG4gIGxldCBpbmRleCA9IC0xXG5cbiAgd2hpbGUgKCsraW5kZXggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGxpc3RbaW5kZXhdXG5cbiAgICBpZiAoYXR0cmlidXRlWzBdID09PSAnY2xhc3MnICYmIGNsZWFuZWQuY2xhc3MpIHtcbiAgICAgIGNsZWFuZWQuY2xhc3MgKz0gJyAnICsgYXR0cmlidXRlWzFdXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFuZWRbYXR0cmlidXRlWzBdXSA9IGF0dHJpYnV0ZVsxXVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuZGF0YS5kaXJlY3RpdmVBdHRyaWJ1dGVzID0gdW5kZWZpbmVkXG4gIHRoaXMucmVzdW1lKCkgLy8gRHJvcCBFT0xzXG4gIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV1cbiAgYXNzZXJ0KFxuICAgIG5vZGUudHlwZSA9PT0gJ2NvbnRhaW5lckRpcmVjdGl2ZScgfHxcbiAgICAgIG5vZGUudHlwZSA9PT0gJ2xlYWZEaXJlY3RpdmUnIHx8XG4gICAgICBub2RlLnR5cGUgPT09ICd0ZXh0RGlyZWN0aXZlJ1xuICApXG4gIG5vZGUuYXR0cmlidXRlcyA9IGNsZWFuZWRcbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBleGl0KHRva2VuKSB7XG4gIHRoaXMuZXhpdCh0b2tlbilcbn1cblxuLyoqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfSAqL1xuZnVuY3Rpb24gcGVla0RpcmVjdGl2ZSgpIHtcbiAgcmV0dXJuICc6J1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZXN9IG5vZGVcbiAqIEByZXR1cm5zIHtub2RlIGlzIFBhcmFncmFwaCAmIHtkYXRhOiB7ZGlyZWN0aXZlTGFiZWw6IHRydWV9fX1cbiAqL1xuZnVuY3Rpb24gaW5saW5lRGlyZWN0aXZlTGFiZWwobm9kZSkge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICBub2RlICYmIG5vZGUudHlwZSA9PT0gJ3BhcmFncmFwaCcgJiYgbm9kZS5kYXRhICYmIG5vZGUuZGF0YS5kaXJlY3RpdmVMYWJlbFxuICApXG59XG5cbi8qKlxuICogQHBhcmFtIHtEaXJlY3RpdmVzfSBub2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBmZW5jZShub2RlKSB7XG4gIGxldCBzaXplID0gMFxuXG4gIGlmIChub2RlLnR5cGUgPT09ICdjb250YWluZXJEaXJlY3RpdmUnKSB7XG4gICAgdmlzaXRQYXJlbnRzKG5vZGUsIGZ1bmN0aW9uIChub2RlLCBwYXJlbnRzKSB7XG4gICAgICBpZiAobm9kZS50eXBlID09PSAnY29udGFpbmVyRGlyZWN0aXZlJykge1xuICAgICAgICBsZXQgaW5kZXggPSBwYXJlbnRzLmxlbmd0aFxuICAgICAgICBsZXQgbmVzdGluZyA9IDBcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGlmIChwYXJlbnRzW2luZGV4XS50eXBlID09PSAnY29udGFpbmVyRGlyZWN0aXZlJykge1xuICAgICAgICAgICAgbmVzdGluZysrXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lc3RpbmcgPiBzaXplKSBzaXplID0gbmVzdGluZ1xuICAgICAgfVxuICAgIH0pXG4gICAgc2l6ZSArPSAzXG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAnbGVhZkRpcmVjdGl2ZScpIHtcbiAgICBzaXplID0gMlxuICB9IGVsc2Uge1xuICAgIHNpemUgPSAxXG4gIH1cblxuICByZXR1cm4gJzonLnJlcGVhdChzaXplKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/mdast-util-directive@3.1.0/node_modules/mdast-util-directive/lib/index.js\n");

/***/ })

};
;