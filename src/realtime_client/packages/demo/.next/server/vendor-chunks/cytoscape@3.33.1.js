"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape@3.33.1";
exports.ids = ["vendor-chunks/cytoscape@3.33.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/cytoscape@3.33.1/node_modules/cytoscape/dist/cytoscape.esm.mjs":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/cytoscape@3.33.1/node_modules/cytoscape/dist/cytoscape.esm.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ cytoscape)\n/* harmony export */ });\n/**\n * Copyright (c) 2016-2025, The Cytoscape Consortium.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the “Software”), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */ function _arrayLikeToArray(r, a) {\n    (null == a || a > r.length) && (a = r.length);\n    for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];\n    return n;\n}\nfunction _arrayWithHoles(r) {\n    if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n    if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n    for(var t = 0; t < r.length; t++){\n        var o = r[t];\n        o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n}\nfunction _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n        writable: false\n    }), e;\n}\nfunction _createForOfIteratorHelper(r, e) {\n    var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (!t) {\n        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) {\n            t && (r = t);\n            var n = 0, F = function() {};\n            return {\n                s: F,\n                n: function() {\n                    return n >= r.length ? {\n                        done: true\n                    } : {\n                        done: false,\n                        value: r[n++]\n                    };\n                },\n                e: function(r) {\n                    throw r;\n                },\n                f: F\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var o, a = true, u = false;\n    return {\n        s: function() {\n            t = t.call(r);\n        },\n        n: function() {\n            var r = t.next();\n            return a = r.done, r;\n        },\n        e: function(r) {\n            u = true, o = r;\n        },\n        f: function() {\n            try {\n                a || null == t.return || t.return();\n            } finally{\n                if (u) throw o;\n            }\n        }\n    };\n}\nfunction _defineProperty$1(e, r, t) {\n    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: true,\n        configurable: true,\n        writable: true\n    }) : e[r] = t, e;\n}\nfunction _iterableToArray(r) {\n    if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n    var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n    if (null != t) {\n        var e, n, i, u, a = [], f = true, o = false;\n        try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n                if (Object(t) !== t) return;\n                f = !1;\n            } else for(; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n        } catch (r) {\n            o = true, n = r;\n        } finally{\n            try {\n                if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n            } finally{\n                if (o) throw n;\n            }\n        }\n        return a;\n    }\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(r, e) {\n    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (undefined !== e) {\n        var i = e.call(t, r);\n        if (\"object\" != typeof i) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return String(t);\n}\nfunction _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n        return typeof o;\n    } : function(o) {\n        return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n    }, _typeof(o);\n}\nfunction _unsupportedIterableToArray(r, a) {\n    if (r) {\n        if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n        var t = ({}).toString.call(r).slice(8, -1);\n        return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n    }\n}\nvar _window =  true ? null : 0; // eslint-disable-line no-undef\nvar navigator = _window ? _window.navigator : null;\n_window ? _window.document : null;\nvar typeofstr = _typeof('');\nvar typeofobj = _typeof({});\nvar typeoffn = _typeof(function() {});\nvar typeofhtmlele = typeof HTMLElement === \"undefined\" ? \"undefined\" : _typeof(HTMLElement);\nvar instanceStr = function instanceStr(obj) {\n    return obj && obj.instanceString && fn$6(obj.instanceString) ? obj.instanceString() : null;\n};\nvar string = function string(obj) {\n    return obj != null && _typeof(obj) == typeofstr;\n};\nvar fn$6 = function fn(obj) {\n    return obj != null && _typeof(obj) === typeoffn;\n};\nvar array = function array(obj) {\n    return !elementOrCollection(obj) && (Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array);\n};\nvar plainObject = function plainObject(obj) {\n    return obj != null && _typeof(obj) === typeofobj && !array(obj) && obj.constructor === Object;\n};\nvar object = function object(obj) {\n    return obj != null && _typeof(obj) === typeofobj;\n};\nvar number$1 = function number(obj) {\n    return obj != null && _typeof(obj) === _typeof(1) && !isNaN(obj);\n};\nvar integer = function integer(obj) {\n    return number$1(obj) && Math.floor(obj) === obj;\n};\nvar htmlElement = function htmlElement(obj) {\n    if ('undefined' === typeofhtmlele) {\n        return undefined;\n    } else {\n        return null != obj && obj instanceof HTMLElement;\n    }\n};\nvar elementOrCollection = function elementOrCollection(obj) {\n    return element(obj) || collection(obj);\n};\nvar element = function element(obj) {\n    return instanceStr(obj) === 'collection' && obj._private.single;\n};\nvar collection = function collection(obj) {\n    return instanceStr(obj) === 'collection' && !obj._private.single;\n};\nvar core = function core(obj) {\n    return instanceStr(obj) === 'core';\n};\nvar stylesheet = function stylesheet(obj) {\n    return instanceStr(obj) === 'stylesheet';\n};\nvar event = function event(obj) {\n    return instanceStr(obj) === 'event';\n};\nvar emptyString = function emptyString(obj) {\n    if (obj === undefined || obj === null) {\n        // null is empty\n        return true;\n    } else if (obj === '' || obj.match(/^\\s+$/)) {\n        return true; // empty string is empty\n    }\n    return false; // otherwise, we don't know what we've got\n};\nvar domElement = function domElement(obj) {\n    if (typeof HTMLElement === 'undefined') {\n        return false; // we're not in a browser so it doesn't matter\n    } else {\n        return obj instanceof HTMLElement;\n    }\n};\nvar boundingBox = function boundingBox(obj) {\n    return plainObject(obj) && number$1(obj.x1) && number$1(obj.x2) && number$1(obj.y1) && number$1(obj.y2);\n};\nvar promise = function promise(obj) {\n    return object(obj) && fn$6(obj.then);\n};\nvar ms = function ms() {\n    return navigator && navigator.userAgent.match(/msie|trident|edge/i);\n}; // probably a better way to detect this...\nvar memoize = function memoize(fn, keyFn) {\n    if (!keyFn) {\n        keyFn = function keyFn() {\n            if (arguments.length === 1) {\n                return arguments[0];\n            } else if (arguments.length === 0) {\n                return 'undefined';\n            }\n            var args = [];\n            for(var i = 0; i < arguments.length; i++){\n                args.push(arguments[i]);\n            }\n            return args.join('$');\n        };\n    }\n    var _memoizedFn = function memoizedFn() {\n        var self1 = this;\n        var args = arguments;\n        var ret;\n        var k = keyFn.apply(self1, args);\n        var cache = _memoizedFn.cache;\n        if (!(ret = cache[k])) {\n            ret = cache[k] = fn.apply(self1, args);\n        }\n        return ret;\n    };\n    _memoizedFn.cache = {};\n    return _memoizedFn;\n};\nvar camel2dash = memoize(function(str) {\n    return str.replace(/([A-Z])/g, function(v) {\n        return '-' + v.toLowerCase();\n    });\n});\nvar dash2camel = memoize(function(str) {\n    return str.replace(/(-\\w)/g, function(v) {\n        return v[1].toUpperCase();\n    });\n});\nvar prependCamel = memoize(function(prefix, str) {\n    return prefix + str[0].toUpperCase() + str.substring(1);\n}, function(prefix, str) {\n    return prefix + '$' + str;\n});\nvar capitalize = function capitalize(str) {\n    if (emptyString(str)) {\n        return str;\n    }\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\nvar endsWith = function endsWith(string, suffix) {\n    return string.slice(-1 * suffix.length) === suffix;\n};\nvar number = '(?:[-+]?(?:(?:\\\\d+|\\\\d*\\\\.\\\\d+)(?:[Ee][+-]?\\\\d+)?))';\nvar rgba = 'rgb[a]?\\\\((' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)\\\\s*,\\\\s*(' + number + '[%]?)(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar rgbaNoBackRefs = 'rgb[a]?\\\\((?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)\\\\s*,\\\\s*(?:' + number + '[%]?)(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\nvar hsla = 'hsl[a]?\\\\((' + number + ')\\\\s*,\\\\s*(' + number + '[%])\\\\s*,\\\\s*(' + number + '[%])(?:\\\\s*,\\\\s*(' + number + '))?\\\\)';\nvar hslaNoBackRefs = 'hsl[a]?\\\\((?:' + number + ')\\\\s*,\\\\s*(?:' + number + '[%])\\\\s*,\\\\s*(?:' + number + '[%])(?:\\\\s*,\\\\s*(?:' + number + '))?\\\\)';\nvar hex3 = '\\\\#[0-9a-fA-F]{3}';\nvar hex6 = '\\\\#[0-9a-fA-F]{6}';\nvar ascending = function ascending(a, b) {\n    if (a < b) {\n        return -1;\n    } else if (a > b) {\n        return 1;\n    } else {\n        return 0;\n    }\n};\nvar descending = function descending(a, b) {\n    return -1 * ascending(a, b);\n};\nvar extend = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {\n    var args = arguments;\n    for(var i = 1; i < args.length; i++){\n        var obj = args[i];\n        if (obj == null) {\n            continue;\n        }\n        var keys = Object.keys(obj);\n        for(var j = 0; j < keys.length; j++){\n            var k = keys[j];\n            tgt[k] = obj[k];\n        }\n    }\n    return tgt;\n};\n// get [r, g, b] from #abc or #aabbcc\nvar hex2tuple = function hex2tuple(hex) {\n    if (!(hex.length === 4 || hex.length === 7) || hex[0] !== '#') {\n        return;\n    }\n    var shortHex = hex.length === 4;\n    var r, g, b;\n    var base = 16;\n    if (shortHex) {\n        r = parseInt(hex[1] + hex[1], base);\n        g = parseInt(hex[2] + hex[2], base);\n        b = parseInt(hex[3] + hex[3], base);\n    } else {\n        r = parseInt(hex[1] + hex[2], base);\n        g = parseInt(hex[3] + hex[4], base);\n        b = parseInt(hex[5] + hex[6], base);\n    }\n    return [\n        r,\n        g,\n        b\n    ];\n};\n// get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)\nvar hsl2tuple = function hsl2tuple(hsl) {\n    var ret;\n    var h, s, l, a, r, g, b;\n    function hue2rgb(p, q, t) {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n    }\n    var m1 = new RegExp('^' + hsla + '$').exec(hsl);\n    if (m1) {\n        // get hue\n        h = parseInt(m1[1]);\n        if (h < 0) {\n            h = (360 - -1 * h % 360) % 360;\n        } else if (h > 360) {\n            h = h % 360;\n        }\n        h /= 360; // normalise on [0, 1]\n        s = parseFloat(m1[2]);\n        if (s < 0 || s > 100) {\n            return;\n        } // saturation is [0, 100]\n        s = s / 100; // normalise on [0, 1]\n        l = parseFloat(m1[3]);\n        if (l < 0 || l > 100) {\n            return;\n        } // lightness is [0, 100]\n        l = l / 100; // normalise on [0, 1]\n        a = m1[4];\n        if (a !== undefined) {\n            a = parseFloat(a);\n            if (a < 0 || a > 1) {\n                return;\n            } // alpha is [0, 1]\n        }\n        // now, convert to rgb\n        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n        if (s === 0) {\n            r = g = b = Math.round(l * 255); // achromatic\n        } else {\n            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            var p = 2 * l - q;\n            r = Math.round(255 * hue2rgb(p, q, h + 1 / 3));\n            g = Math.round(255 * hue2rgb(p, q, h));\n            b = Math.round(255 * hue2rgb(p, q, h - 1 / 3));\n        }\n        ret = [\n            r,\n            g,\n            b,\n            a\n        ];\n    }\n    return ret;\n};\n// get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)\nvar rgb2tuple = function rgb2tuple(rgb) {\n    var ret;\n    var m1 = new RegExp('^' + rgba + '$').exec(rgb);\n    if (m1) {\n        ret = [];\n        var isPct = [];\n        for(var i = 1; i <= 3; i++){\n            var channel = m1[i];\n            if (channel[channel.length - 1] === '%') {\n                isPct[i] = true;\n            }\n            channel = parseFloat(channel);\n            if (isPct[i]) {\n                channel = channel / 100 * 255; // normalise to [0, 255]\n            }\n            if (channel < 0 || channel > 255) {\n                return;\n            } // invalid channel value\n            ret.push(Math.floor(channel));\n        }\n        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];\n        var allArePct = isPct[1] && isPct[2] && isPct[3];\n        if (atLeastOneIsPct && !allArePct) {\n            return;\n        } // must all be percent values if one is\n        var alpha = m1[4];\n        if (alpha !== undefined) {\n            alpha = parseFloat(alpha);\n            if (alpha < 0 || alpha > 1) {\n                return;\n            } // invalid alpha value\n            ret.push(alpha);\n        }\n    }\n    return ret;\n};\nvar colorname2tuple = function colorname2tuple(color) {\n    return colors[color.toLowerCase()];\n};\nvar color2tuple = function color2tuple(color) {\n    return (array(color) ? color : null) || colorname2tuple(color) || hex2tuple(color) || rgb2tuple(color) || hsl2tuple(color);\n};\nvar colors = {\n    // special colour names\n    transparent: [\n        0,\n        0,\n        0,\n        0\n    ],\n    // NB alpha === 0\n    // regular colours\n    aliceblue: [\n        240,\n        248,\n        255\n    ],\n    antiquewhite: [\n        250,\n        235,\n        215\n    ],\n    aqua: [\n        0,\n        255,\n        255\n    ],\n    aquamarine: [\n        127,\n        255,\n        212\n    ],\n    azure: [\n        240,\n        255,\n        255\n    ],\n    beige: [\n        245,\n        245,\n        220\n    ],\n    bisque: [\n        255,\n        228,\n        196\n    ],\n    black: [\n        0,\n        0,\n        0\n    ],\n    blanchedalmond: [\n        255,\n        235,\n        205\n    ],\n    blue: [\n        0,\n        0,\n        255\n    ],\n    blueviolet: [\n        138,\n        43,\n        226\n    ],\n    brown: [\n        165,\n        42,\n        42\n    ],\n    burlywood: [\n        222,\n        184,\n        135\n    ],\n    cadetblue: [\n        95,\n        158,\n        160\n    ],\n    chartreuse: [\n        127,\n        255,\n        0\n    ],\n    chocolate: [\n        210,\n        105,\n        30\n    ],\n    coral: [\n        255,\n        127,\n        80\n    ],\n    cornflowerblue: [\n        100,\n        149,\n        237\n    ],\n    cornsilk: [\n        255,\n        248,\n        220\n    ],\n    crimson: [\n        220,\n        20,\n        60\n    ],\n    cyan: [\n        0,\n        255,\n        255\n    ],\n    darkblue: [\n        0,\n        0,\n        139\n    ],\n    darkcyan: [\n        0,\n        139,\n        139\n    ],\n    darkgoldenrod: [\n        184,\n        134,\n        11\n    ],\n    darkgray: [\n        169,\n        169,\n        169\n    ],\n    darkgreen: [\n        0,\n        100,\n        0\n    ],\n    darkgrey: [\n        169,\n        169,\n        169\n    ],\n    darkkhaki: [\n        189,\n        183,\n        107\n    ],\n    darkmagenta: [\n        139,\n        0,\n        139\n    ],\n    darkolivegreen: [\n        85,\n        107,\n        47\n    ],\n    darkorange: [\n        255,\n        140,\n        0\n    ],\n    darkorchid: [\n        153,\n        50,\n        204\n    ],\n    darkred: [\n        139,\n        0,\n        0\n    ],\n    darksalmon: [\n        233,\n        150,\n        122\n    ],\n    darkseagreen: [\n        143,\n        188,\n        143\n    ],\n    darkslateblue: [\n        72,\n        61,\n        139\n    ],\n    darkslategray: [\n        47,\n        79,\n        79\n    ],\n    darkslategrey: [\n        47,\n        79,\n        79\n    ],\n    darkturquoise: [\n        0,\n        206,\n        209\n    ],\n    darkviolet: [\n        148,\n        0,\n        211\n    ],\n    deeppink: [\n        255,\n        20,\n        147\n    ],\n    deepskyblue: [\n        0,\n        191,\n        255\n    ],\n    dimgray: [\n        105,\n        105,\n        105\n    ],\n    dimgrey: [\n        105,\n        105,\n        105\n    ],\n    dodgerblue: [\n        30,\n        144,\n        255\n    ],\n    firebrick: [\n        178,\n        34,\n        34\n    ],\n    floralwhite: [\n        255,\n        250,\n        240\n    ],\n    forestgreen: [\n        34,\n        139,\n        34\n    ],\n    fuchsia: [\n        255,\n        0,\n        255\n    ],\n    gainsboro: [\n        220,\n        220,\n        220\n    ],\n    ghostwhite: [\n        248,\n        248,\n        255\n    ],\n    gold: [\n        255,\n        215,\n        0\n    ],\n    goldenrod: [\n        218,\n        165,\n        32\n    ],\n    gray: [\n        128,\n        128,\n        128\n    ],\n    grey: [\n        128,\n        128,\n        128\n    ],\n    green: [\n        0,\n        128,\n        0\n    ],\n    greenyellow: [\n        173,\n        255,\n        47\n    ],\n    honeydew: [\n        240,\n        255,\n        240\n    ],\n    hotpink: [\n        255,\n        105,\n        180\n    ],\n    indianred: [\n        205,\n        92,\n        92\n    ],\n    indigo: [\n        75,\n        0,\n        130\n    ],\n    ivory: [\n        255,\n        255,\n        240\n    ],\n    khaki: [\n        240,\n        230,\n        140\n    ],\n    lavender: [\n        230,\n        230,\n        250\n    ],\n    lavenderblush: [\n        255,\n        240,\n        245\n    ],\n    lawngreen: [\n        124,\n        252,\n        0\n    ],\n    lemonchiffon: [\n        255,\n        250,\n        205\n    ],\n    lightblue: [\n        173,\n        216,\n        230\n    ],\n    lightcoral: [\n        240,\n        128,\n        128\n    ],\n    lightcyan: [\n        224,\n        255,\n        255\n    ],\n    lightgoldenrodyellow: [\n        250,\n        250,\n        210\n    ],\n    lightgray: [\n        211,\n        211,\n        211\n    ],\n    lightgreen: [\n        144,\n        238,\n        144\n    ],\n    lightgrey: [\n        211,\n        211,\n        211\n    ],\n    lightpink: [\n        255,\n        182,\n        193\n    ],\n    lightsalmon: [\n        255,\n        160,\n        122\n    ],\n    lightseagreen: [\n        32,\n        178,\n        170\n    ],\n    lightskyblue: [\n        135,\n        206,\n        250\n    ],\n    lightslategray: [\n        119,\n        136,\n        153\n    ],\n    lightslategrey: [\n        119,\n        136,\n        153\n    ],\n    lightsteelblue: [\n        176,\n        196,\n        222\n    ],\n    lightyellow: [\n        255,\n        255,\n        224\n    ],\n    lime: [\n        0,\n        255,\n        0\n    ],\n    limegreen: [\n        50,\n        205,\n        50\n    ],\n    linen: [\n        250,\n        240,\n        230\n    ],\n    magenta: [\n        255,\n        0,\n        255\n    ],\n    maroon: [\n        128,\n        0,\n        0\n    ],\n    mediumaquamarine: [\n        102,\n        205,\n        170\n    ],\n    mediumblue: [\n        0,\n        0,\n        205\n    ],\n    mediumorchid: [\n        186,\n        85,\n        211\n    ],\n    mediumpurple: [\n        147,\n        112,\n        219\n    ],\n    mediumseagreen: [\n        60,\n        179,\n        113\n    ],\n    mediumslateblue: [\n        123,\n        104,\n        238\n    ],\n    mediumspringgreen: [\n        0,\n        250,\n        154\n    ],\n    mediumturquoise: [\n        72,\n        209,\n        204\n    ],\n    mediumvioletred: [\n        199,\n        21,\n        133\n    ],\n    midnightblue: [\n        25,\n        25,\n        112\n    ],\n    mintcream: [\n        245,\n        255,\n        250\n    ],\n    mistyrose: [\n        255,\n        228,\n        225\n    ],\n    moccasin: [\n        255,\n        228,\n        181\n    ],\n    navajowhite: [\n        255,\n        222,\n        173\n    ],\n    navy: [\n        0,\n        0,\n        128\n    ],\n    oldlace: [\n        253,\n        245,\n        230\n    ],\n    olive: [\n        128,\n        128,\n        0\n    ],\n    olivedrab: [\n        107,\n        142,\n        35\n    ],\n    orange: [\n        255,\n        165,\n        0\n    ],\n    orangered: [\n        255,\n        69,\n        0\n    ],\n    orchid: [\n        218,\n        112,\n        214\n    ],\n    palegoldenrod: [\n        238,\n        232,\n        170\n    ],\n    palegreen: [\n        152,\n        251,\n        152\n    ],\n    paleturquoise: [\n        175,\n        238,\n        238\n    ],\n    palevioletred: [\n        219,\n        112,\n        147\n    ],\n    papayawhip: [\n        255,\n        239,\n        213\n    ],\n    peachpuff: [\n        255,\n        218,\n        185\n    ],\n    peru: [\n        205,\n        133,\n        63\n    ],\n    pink: [\n        255,\n        192,\n        203\n    ],\n    plum: [\n        221,\n        160,\n        221\n    ],\n    powderblue: [\n        176,\n        224,\n        230\n    ],\n    purple: [\n        128,\n        0,\n        128\n    ],\n    red: [\n        255,\n        0,\n        0\n    ],\n    rosybrown: [\n        188,\n        143,\n        143\n    ],\n    royalblue: [\n        65,\n        105,\n        225\n    ],\n    saddlebrown: [\n        139,\n        69,\n        19\n    ],\n    salmon: [\n        250,\n        128,\n        114\n    ],\n    sandybrown: [\n        244,\n        164,\n        96\n    ],\n    seagreen: [\n        46,\n        139,\n        87\n    ],\n    seashell: [\n        255,\n        245,\n        238\n    ],\n    sienna: [\n        160,\n        82,\n        45\n    ],\n    silver: [\n        192,\n        192,\n        192\n    ],\n    skyblue: [\n        135,\n        206,\n        235\n    ],\n    slateblue: [\n        106,\n        90,\n        205\n    ],\n    slategray: [\n        112,\n        128,\n        144\n    ],\n    slategrey: [\n        112,\n        128,\n        144\n    ],\n    snow: [\n        255,\n        250,\n        250\n    ],\n    springgreen: [\n        0,\n        255,\n        127\n    ],\n    steelblue: [\n        70,\n        130,\n        180\n    ],\n    tan: [\n        210,\n        180,\n        140\n    ],\n    teal: [\n        0,\n        128,\n        128\n    ],\n    thistle: [\n        216,\n        191,\n        216\n    ],\n    tomato: [\n        255,\n        99,\n        71\n    ],\n    turquoise: [\n        64,\n        224,\n        208\n    ],\n    violet: [\n        238,\n        130,\n        238\n    ],\n    wheat: [\n        245,\n        222,\n        179\n    ],\n    white: [\n        255,\n        255,\n        255\n    ],\n    whitesmoke: [\n        245,\n        245,\n        245\n    ],\n    yellow: [\n        255,\n        255,\n        0\n    ],\n    yellowgreen: [\n        154,\n        205,\n        50\n    ]\n};\n// sets the value in a map (map may not be built)\nvar setMap = function setMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n    for(var i = 0; i < l; i++){\n        var key = keys[i];\n        if (plainObject(key)) {\n            throw Error('Tried to set map with object key');\n        }\n        if (i < keys.length - 1) {\n            // extend the map if necessary\n            if (obj[key] == null) {\n                obj[key] = {};\n            }\n            obj = obj[key];\n        } else {\n            // set the value\n            obj[key] = options.value;\n        }\n    }\n};\n// gets the value in a map even if it's not built in places\nvar getMap = function getMap(options) {\n    var obj = options.map;\n    var keys = options.keys;\n    var l = keys.length;\n    for(var i = 0; i < l; i++){\n        var key = keys[i];\n        if (plainObject(key)) {\n            throw Error('Tried to get map with object key');\n        }\n        obj = obj[key];\n        if (obj == null) {\n            return obj;\n        }\n    }\n    return obj;\n};\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis :  false ? 0 : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */ var isObject_1;\nvar hasRequiredIsObject;\nfunction requireIsObject() {\n    if (hasRequiredIsObject) return isObject_1;\n    hasRequiredIsObject = 1;\n    function isObject(value) {\n        var type = typeof value;\n        return value != null && (type == 'object' || type == 'function');\n    }\n    isObject_1 = isObject;\n    return isObject_1;\n}\n/** Detect free variable `global` from Node.js. */ var _freeGlobal;\nvar hasRequired_freeGlobal;\nfunction require_freeGlobal() {\n    if (hasRequired_freeGlobal) return _freeGlobal;\n    hasRequired_freeGlobal = 1;\n    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n    _freeGlobal = freeGlobal;\n    return _freeGlobal;\n}\nvar _root;\nvar hasRequired_root;\nfunction require_root() {\n    if (hasRequired_root) return _root;\n    hasRequired_root = 1;\n    var freeGlobal = require_freeGlobal();\n    /** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n    /** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();\n    _root = root;\n    return _root;\n}\nvar now_1;\nvar hasRequiredNow;\nfunction requireNow() {\n    if (hasRequiredNow) return now_1;\n    hasRequiredNow = 1;\n    var root = require_root();\n    /**\n\t * Gets the timestamp of the number of milliseconds that have elapsed since\n\t * the Unix epoch (1 January 1970 00:00:00 UTC).\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 2.4.0\n\t * @category Date\n\t * @returns {number} Returns the timestamp.\n\t * @example\n\t *\n\t * _.defer(function(stamp) {\n\t *   console.log(_.now() - stamp);\n\t * }, _.now());\n\t * // => Logs the number of milliseconds it took for the deferred invocation.\n\t */ var now = function() {\n        return root.Date.now();\n    };\n    now_1 = now;\n    return now_1;\n}\n/** Used to match a single whitespace character. */ var _trimmedEndIndex;\nvar hasRequired_trimmedEndIndex;\nfunction require_trimmedEndIndex() {\n    if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;\n    hasRequired_trimmedEndIndex = 1;\n    var reWhitespace = /\\s/;\n    /**\n\t * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n\t * character of `string`.\n\t *\n\t * @private\n\t * @param {string} string The string to inspect.\n\t * @returns {number} Returns the index of the last non-whitespace character.\n\t */ function trimmedEndIndex(string) {\n        var index = string.length;\n        while(index-- && reWhitespace.test(string.charAt(index))){}\n        return index;\n    }\n    _trimmedEndIndex = trimmedEndIndex;\n    return _trimmedEndIndex;\n}\nvar _baseTrim;\nvar hasRequired_baseTrim;\nfunction require_baseTrim() {\n    if (hasRequired_baseTrim) return _baseTrim;\n    hasRequired_baseTrim = 1;\n    var trimmedEndIndex = require_trimmedEndIndex();\n    /** Used to match leading whitespace. */ var reTrimStart = /^\\s+/;\n    /**\n\t * The base implementation of `_.trim`.\n\t *\n\t * @private\n\t * @param {string} string The string to trim.\n\t * @returns {string} Returns the trimmed string.\n\t */ function baseTrim(string) {\n        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;\n    }\n    _baseTrim = baseTrim;\n    return _baseTrim;\n}\nvar _Symbol;\nvar hasRequired_Symbol;\nfunction require_Symbol() {\n    if (hasRequired_Symbol) return _Symbol;\n    hasRequired_Symbol = 1;\n    var root = require_root();\n    /** Built-in value references. */ var Symbol1 = root.Symbol;\n    _Symbol = Symbol1;\n    return _Symbol;\n}\nvar _getRawTag;\nvar hasRequired_getRawTag;\nfunction require_getRawTag() {\n    if (hasRequired_getRawTag) return _getRawTag;\n    hasRequired_getRawTag = 1;\n    var Symbol1 = require_Symbol();\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */ var nativeObjectToString = objectProto.toString;\n    /** Built-in value references. */ var symToStringTag = Symbol1 ? Symbol1.toStringTag : undefined;\n    /**\n\t * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the raw `toStringTag`.\n\t */ function getRawTag(value) {\n        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n        try {\n            value[symToStringTag] = undefined;\n            var unmasked = true;\n        } catch (e) {}\n        var result = nativeObjectToString.call(value);\n        if (unmasked) {\n            if (isOwn) {\n                value[symToStringTag] = tag;\n            } else {\n                delete value[symToStringTag];\n            }\n        }\n        return result;\n    }\n    _getRawTag = getRawTag;\n    return _getRawTag;\n}\n/** Used for built-in method references. */ var _objectToString;\nvar hasRequired_objectToString;\nfunction require_objectToString() {\n    if (hasRequired_objectToString) return _objectToString;\n    hasRequired_objectToString = 1;\n    var objectProto = Object.prototype;\n    /**\n\t * Used to resolve the\n\t * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n\t * of values.\n\t */ var nativeObjectToString = objectProto.toString;\n    /**\n\t * Converts `value` to a string using `Object.prototype.toString`.\n\t *\n\t * @private\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t */ function objectToString(value) {\n        return nativeObjectToString.call(value);\n    }\n    _objectToString = objectToString;\n    return _objectToString;\n}\nvar _baseGetTag;\nvar hasRequired_baseGetTag;\nfunction require_baseGetTag() {\n    if (hasRequired_baseGetTag) return _baseGetTag;\n    hasRequired_baseGetTag = 1;\n    var Symbol1 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();\n    /** `Object#toString` result references. */ var nullTag = '[object Null]', undefinedTag = '[object Undefined]';\n    /** Built-in value references. */ var symToStringTag = Symbol1 ? Symbol1.toStringTag : undefined;\n    /**\n\t * The base implementation of `getTag` without fallbacks for buggy environments.\n\t *\n\t * @private\n\t * @param {*} value The value to query.\n\t * @returns {string} Returns the `toStringTag`.\n\t */ function baseGetTag(value) {\n        if (value == null) {\n            return value === undefined ? undefinedTag : nullTag;\n        }\n        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);\n    }\n    _baseGetTag = baseGetTag;\n    return _baseGetTag;\n}\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */ var isObjectLike_1;\nvar hasRequiredIsObjectLike;\nfunction requireIsObjectLike() {\n    if (hasRequiredIsObjectLike) return isObjectLike_1;\n    hasRequiredIsObjectLike = 1;\n    function isObjectLike(value) {\n        return value != null && typeof value == 'object';\n    }\n    isObjectLike_1 = isObjectLike;\n    return isObjectLike_1;\n}\nvar isSymbol_1;\nvar hasRequiredIsSymbol;\nfunction requireIsSymbol() {\n    if (hasRequiredIsSymbol) return isSymbol_1;\n    hasRequiredIsSymbol = 1;\n    var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();\n    /** `Object#toString` result references. */ var symbolTag = '[object Symbol]';\n    /**\n\t * Checks if `value` is classified as a `Symbol` primitive or object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n\t * @example\n\t *\n\t * _.isSymbol(Symbol.iterator);\n\t * // => true\n\t *\n\t * _.isSymbol('abc');\n\t * // => false\n\t */ function isSymbol(value) {\n        return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;\n    }\n    isSymbol_1 = isSymbol;\n    return isSymbol_1;\n}\nvar toNumber_1;\nvar hasRequiredToNumber;\nfunction requireToNumber() {\n    if (hasRequiredToNumber) return toNumber_1;\n    hasRequiredToNumber = 1;\n    var baseTrim = require_baseTrim(), isObject = requireIsObject(), isSymbol = requireIsSymbol();\n    /** Used as references for various `Number` constants. */ var NAN = 0 / 0;\n    /** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    /** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;\n    /** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;\n    /** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;\n    /**\n\t * Converts `value` to a number.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to process.\n\t * @returns {number} Returns the number.\n\t * @example\n\t *\n\t * _.toNumber(3.2);\n\t * // => 3.2\n\t *\n\t * _.toNumber(Number.MIN_VALUE);\n\t * // => 5e-324\n\t *\n\t * _.toNumber(Infinity);\n\t * // => Infinity\n\t *\n\t * _.toNumber('3.2');\n\t * // => 3.2\n\t */ function toNumber(value) {\n        if (typeof value == 'number') {\n            return value;\n        }\n        if (isSymbol(value)) {\n            return NAN;\n        }\n        if (isObject(value)) {\n            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n            value = isObject(other) ? other + '' : other;\n        }\n        if (typeof value != 'string') {\n            return value === 0 ? value : +value;\n        }\n        value = baseTrim(value);\n        var isBinary = reIsBinary.test(value);\n        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n    }\n    toNumber_1 = toNumber;\n    return toNumber_1;\n}\nvar debounce_1;\nvar hasRequiredDebounce;\nfunction requireDebounce() {\n    if (hasRequiredDebounce) return debounce_1;\n    hasRequiredDebounce = 1;\n    var isObject = requireIsObject(), now = requireNow(), toNumber = requireToNumber();\n    /** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';\n    /* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;\n    /**\n\t * Creates a debounced function that delays invoking `func` until after `wait`\n\t * milliseconds have elapsed since the last time the debounced function was\n\t * invoked. The debounced function comes with a `cancel` method to cancel\n\t * delayed `func` invocations and a `flush` method to immediately invoke them.\n\t * Provide `options` to indicate whether `func` should be invoked on the\n\t * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n\t * with the last arguments provided to the debounced function. Subsequent\n\t * calls to the debounced function return the result of the last `func`\n\t * invocation.\n\t *\n\t * **Note:** If `leading` and `trailing` options are `true`, `func` is\n\t * invoked on the trailing edge of the timeout only if the debounced function\n\t * is invoked more than once during the `wait` timeout.\n\t *\n\t * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n\t * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n\t *\n\t * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n\t * for details over the differences between `_.debounce` and `_.throttle`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to debounce.\n\t * @param {number} [wait=0] The number of milliseconds to delay.\n\t * @param {Object} [options={}] The options object.\n\t * @param {boolean} [options.leading=false]\n\t *  Specify invoking on the leading edge of the timeout.\n\t * @param {number} [options.maxWait]\n\t *  The maximum time `func` is allowed to be delayed before it's invoked.\n\t * @param {boolean} [options.trailing=true]\n\t *  Specify invoking on the trailing edge of the timeout.\n\t * @returns {Function} Returns the new debounced function.\n\t * @example\n\t *\n\t * // Avoid costly calculations while the window size is in flux.\n\t * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n\t *\n\t * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n\t * jQuery(element).on('click', _.debounce(sendMail, 300, {\n\t *   'leading': true,\n\t *   'trailing': false\n\t * }));\n\t *\n\t * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n\t * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n\t * var source = new EventSource('/stream');\n\t * jQuery(source).on('message', debounced);\n\t *\n\t * // Cancel the trailing debounced invocation.\n\t * jQuery(window).on('popstate', debounced.cancel);\n\t */ function debounce(func, wait, options) {\n        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n        if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        wait = toNumber(wait) || 0;\n        if (isObject(options)) {\n            leading = !!options.leading;\n            maxing = 'maxWait' in options;\n            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n            trailing = 'trailing' in options ? !!options.trailing : trailing;\n        }\n        function invokeFunc(time) {\n            var args = lastArgs, thisArg = lastThis;\n            lastArgs = lastThis = undefined;\n            lastInvokeTime = time;\n            result = func.apply(thisArg, args);\n            return result;\n        }\n        function leadingEdge(time) {\n            // Reset any `maxWait` timer.\n            lastInvokeTime = time;\n            // Start the timer for the trailing edge.\n            timerId = setTimeout(timerExpired, wait);\n            // Invoke the leading edge.\n            return leading ? invokeFunc(time) : result;\n        }\n        function remainingWait(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n        }\n        function shouldInvoke(time) {\n            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n            // Either this is the first call, activity has stopped and we're at the\n            // trailing edge, the system time has gone backwards and we're treating\n            // it as the trailing edge, or we've hit the `maxWait` limit.\n            return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n        }\n        function timerExpired() {\n            var time = now();\n            if (shouldInvoke(time)) {\n                return trailingEdge(time);\n            }\n            // Restart the timer.\n            timerId = setTimeout(timerExpired, remainingWait(time));\n        }\n        function trailingEdge(time) {\n            timerId = undefined;\n            // Only invoke if we have `lastArgs` which means `func` has been\n            // debounced at least once.\n            if (trailing && lastArgs) {\n                return invokeFunc(time);\n            }\n            lastArgs = lastThis = undefined;\n            return result;\n        }\n        function cancel() {\n            if (timerId !== undefined) {\n                clearTimeout(timerId);\n            }\n            lastInvokeTime = 0;\n            lastArgs = lastCallTime = lastThis = timerId = undefined;\n        }\n        function flush() {\n            return timerId === undefined ? result : trailingEdge(now());\n        }\n        function debounced() {\n            var time = now(), isInvoking = shouldInvoke(time);\n            lastArgs = arguments;\n            lastThis = this;\n            lastCallTime = time;\n            if (isInvoking) {\n                if (timerId === undefined) {\n                    return leadingEdge(lastCallTime);\n                }\n                if (maxing) {\n                    // Handle invocations in a tight loop.\n                    clearTimeout(timerId);\n                    timerId = setTimeout(timerExpired, wait);\n                    return invokeFunc(lastCallTime);\n                }\n            }\n            if (timerId === undefined) {\n                timerId = setTimeout(timerExpired, wait);\n            }\n            return result;\n        }\n        debounced.cancel = cancel;\n        debounced.flush = flush;\n        return debounced;\n    }\n    debounce_1 = debounce;\n    return debounce_1;\n}\nvar debounceExports = requireDebounce();\nvar debounce = /*@__PURE__*/ getDefaultExportFromCjs(debounceExports);\nvar performance$1 = _window ? _window.performance : null;\nvar pnow = performance$1 && performance$1.now ? function() {\n    return performance$1.now();\n} : function() {\n    return Date.now();\n};\nvar raf = function() {\n    if (_window) {\n        if (_window.requestAnimationFrame) {\n            return function(fn) {\n                _window.requestAnimationFrame(fn);\n            };\n        } else if (_window.mozRequestAnimationFrame) {\n            return function(fn) {\n                _window.mozRequestAnimationFrame(fn);\n            };\n        } else if (_window.webkitRequestAnimationFrame) {\n            return function(fn) {\n                _window.webkitRequestAnimationFrame(fn);\n            };\n        } else if (_window.msRequestAnimationFrame) {\n            return function(fn) {\n                _window.msRequestAnimationFrame(fn);\n            };\n        }\n    }\n    return function(fn) {\n        if (fn) {\n            setTimeout(function() {\n                fn(pnow());\n            }, 1000 / 60);\n        }\n    };\n}();\nvar requestAnimationFrame = function requestAnimationFrame(fn) {\n    return raf(fn);\n};\nvar performanceNow = pnow;\nvar DEFAULT_HASH_SEED = 9261;\nvar K = 65599; // 37 also works pretty well\nvar DEFAULT_HASH_SEED_ALT = 5381;\nvar hashIterableInts = function hashIterableInts(iterator) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    var hash = seed;\n    var entry;\n    for(;;){\n        entry = iterator.next();\n        if (entry.done) {\n            break;\n        }\n        hash = hash * K + entry.value | 0;\n    }\n    return hash;\n};\nvar hashInt = function hashInt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED;\n    // sdbm/string-hash\n    return seed * K + num | 0;\n};\nvar hashIntAlt = function hashIntAlt(num) {\n    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HASH_SEED_ALT;\n    // djb2/string-hash\n    return (seed << 5) + seed + num | 0;\n};\nvar combineHashes = function combineHashes(hash1, hash2) {\n    return hash1 * 0x200000 + hash2;\n};\nvar combineHashesArray = function combineHashesArray(hashes) {\n    return hashes[0] * 0x200000 + hashes[1];\n};\nvar hashArrays = function hashArrays(hashes1, hashes2) {\n    return [\n        hashInt(hashes1[0], hashes2[0]),\n        hashIntAlt(hashes1[1], hashes2[1])\n    ];\n};\nvar hashIntsArray = function hashIntsArray(ints, seed) {\n    var entry = {\n        value: 0,\n        done: false\n    };\n    var i = 0;\n    var length = ints.length;\n    var iterator = {\n        next: function next() {\n            if (i < length) {\n                entry.value = ints[i++];\n            } else {\n                entry.done = true;\n            }\n            return entry;\n        }\n    };\n    return hashIterableInts(iterator, seed);\n};\nvar hashString = function hashString(str, seed) {\n    var entry = {\n        value: 0,\n        done: false\n    };\n    var i = 0;\n    var length = str.length;\n    var iterator = {\n        next: function next() {\n            if (i < length) {\n                entry.value = str.charCodeAt(i++);\n            } else {\n                entry.done = true;\n            }\n            return entry;\n        }\n    };\n    return hashIterableInts(iterator, seed);\n};\nvar hashStrings = function hashStrings() {\n    return hashStringsArray(arguments);\n};\nvar hashStringsArray = function hashStringsArray(strs) {\n    var hash;\n    for(var i = 0; i < strs.length; i++){\n        var str = strs[i];\n        if (i === 0) {\n            hash = hashString(str);\n        } else {\n            hash = hashString(str, hash);\n        }\n    }\n    return hash;\n};\nfunction rotatePoint(x, y, centerX, centerY, angleDegrees) {\n    var angleRadians = angleDegrees * Math.PI / 180;\n    var rotatedX = Math.cos(angleRadians) * (x - centerX) - Math.sin(angleRadians) * (y - centerY) + centerX;\n    var rotatedY = Math.sin(angleRadians) * (x - centerX) + Math.cos(angleRadians) * (y - centerY) + centerY;\n    return {\n        x: rotatedX,\n        y: rotatedY\n    };\n}\nvar movePointByBoxAspect = function movePointByBoxAspect(x, y, boxX, boxY, skewX, skewY) {\n    return {\n        x: (x - boxX) * skewX + boxX,\n        y: (y - boxY) * skewY + boxY\n    };\n};\nfunction rotatePosAndSkewByBox(pos, box, angleDegrees) {\n    if (angleDegrees === 0) return pos;\n    var centerX = (box.x1 + box.x2) / 2;\n    var centerY = (box.y1 + box.y2) / 2;\n    var skewX = box.w / box.h;\n    var skewY = 1 / skewX;\n    var rotated = rotatePoint(pos.x, pos.y, centerX, centerY, angleDegrees);\n    var skewed = movePointByBoxAspect(rotated.x, rotated.y, centerX, centerY, skewX, skewY);\n    return {\n        x: skewed.x,\n        y: skewed.y\n    };\n}\nvar warningsEnabled = true;\nvar warnSupported = console.warn != null;\nvar traceSupported = console.trace != null;\nvar MAX_INT$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;\nvar trueify = function trueify() {\n    return true;\n};\nvar falsify = function falsify() {\n    return false;\n};\nvar zeroify = function zeroify() {\n    return 0;\n};\nvar noop$1 = function noop() {};\nvar error = function error(msg) {\n    throw new Error(msg);\n};\nvar warnings = function warnings(enabled) {\n    if (enabled !== undefined) {\n        warningsEnabled = !!enabled;\n    } else {\n        return warningsEnabled;\n    }\n};\nvar warn = function warn(msg) {\n    if (!warnings()) {\n        return;\n    }\n    if (warnSupported) {\n        console.warn(msg);\n    } else {\n        console.log(msg);\n        if (traceSupported) {\n            console.trace();\n        }\n    }\n};\nvar clone = function clone(obj) {\n    return extend({}, obj);\n};\n// gets a shallow copy of the argument\nvar copy = function copy(obj) {\n    if (obj == null) {\n        return obj;\n    }\n    if (array(obj)) {\n        return obj.slice();\n    } else if (plainObject(obj)) {\n        return clone(obj);\n    } else {\n        return obj;\n    }\n};\nvar copyArray = function copyArray(arr) {\n    return arr.slice();\n};\nvar uuid = function uuid(a, b /* placeholders */ ) {\n    for(// loop :)\n    b = a = ''; // b - result , a - numeric letiable\n    a++ < 36; //\n    b += a * 51 & 52 // if \"a\" is not 9 or 14 or 19 or 24\n     ? //  return a random number or 4\n    (a ^ 15 // if \"a\" is not 15\n     ? // generate a random number from 0 to 15\n    8 ^ Math.random() * (a ^ 20 ? 16 : 4 // unless \"a\" is 20, in which case a random number from 8 to 11\n    ) : 4 //  otherwise 4\n    ).toString(16) : '-' //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n    );\n    return b;\n};\nvar _staticEmptyObject = {};\nvar staticEmptyObject = function staticEmptyObject() {\n    return _staticEmptyObject;\n};\nvar defaults$g = function defaults(_defaults) {\n    var keys = Object.keys(_defaults);\n    return function(opts) {\n        var filledOpts = {};\n        for(var i = 0; i < keys.length; i++){\n            var key = keys[i];\n            var optVal = opts == null ? undefined : opts[key];\n            filledOpts[key] = optVal === undefined ? _defaults[key] : optVal;\n        }\n        return filledOpts;\n    };\n};\nvar removeFromArray = function removeFromArray(arr, ele, oneCopy) {\n    for(var i = arr.length - 1; i >= 0; i--){\n        if (arr[i] === ele) {\n            arr.splice(i, 1);\n        }\n    }\n};\nvar clearArray = function clearArray(arr) {\n    arr.splice(0, arr.length);\n};\nvar push = function push(arr, otherArr) {\n    for(var i = 0; i < otherArr.length; i++){\n        var el = otherArr[i];\n        arr.push(el);\n    }\n};\nvar getPrefixedProperty = function getPrefixedProperty(obj, propName, prefix) {\n    if (prefix) {\n        propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n    return obj[propName];\n};\nvar setPrefixedProperty = function setPrefixedProperty(obj, propName, prefix, value) {\n    if (prefix) {\n        propName = prependCamel(prefix, propName); // e.g. (labelWidth, source) => sourceLabelWidth\n    }\n    obj[propName] = value;\n};\n/* global Map */ var ObjectMap = /*#__PURE__*/ function() {\n    function ObjectMap() {\n        _classCallCheck(this, ObjectMap);\n        this._obj = {};\n    }\n    return _createClass(ObjectMap, [\n        {\n            key: \"set\",\n            value: function set(key, val) {\n                this._obj[key] = val;\n                return this;\n            }\n        },\n        {\n            key: \"delete\",\n            value: function _delete(key) {\n                this._obj[key] = undefined;\n                return this;\n            }\n        },\n        {\n            key: \"clear\",\n            value: function clear() {\n                this._obj = {};\n            }\n        },\n        {\n            key: \"has\",\n            value: function has(key) {\n                return this._obj[key] !== undefined;\n            }\n        },\n        {\n            key: \"get\",\n            value: function get(key) {\n                return this._obj[key];\n            }\n        }\n    ]);\n}();\nvar Map$1 = typeof Map !== 'undefined' ? Map : ObjectMap;\n/* global Set */ var undef = \"undefined\";\nvar ObjectSet = /*#__PURE__*/ function() {\n    function ObjectSet(arrayOrObjectSet) {\n        _classCallCheck(this, ObjectSet);\n        this._obj = Object.create(null);\n        this.size = 0;\n        if (arrayOrObjectSet != null) {\n            var arr;\n            if (arrayOrObjectSet.instanceString != null && arrayOrObjectSet.instanceString() === this.instanceString()) {\n                arr = arrayOrObjectSet.toArray();\n            } else {\n                arr = arrayOrObjectSet;\n            }\n            for(var i = 0; i < arr.length; i++){\n                this.add(arr[i]);\n            }\n        }\n    }\n    return _createClass(ObjectSet, [\n        {\n            key: \"instanceString\",\n            value: function instanceString() {\n                return 'set';\n            }\n        },\n        {\n            key: \"add\",\n            value: function add(val) {\n                var o = this._obj;\n                if (o[val] !== 1) {\n                    o[val] = 1;\n                    this.size++;\n                }\n            }\n        },\n        {\n            key: \"delete\",\n            value: function _delete(val) {\n                var o = this._obj;\n                if (o[val] === 1) {\n                    o[val] = 0;\n                    this.size--;\n                }\n            }\n        },\n        {\n            key: \"clear\",\n            value: function clear() {\n                this._obj = Object.create(null);\n            }\n        },\n        {\n            key: \"has\",\n            value: function has(val) {\n                return this._obj[val] === 1;\n            }\n        },\n        {\n            key: \"toArray\",\n            value: function toArray() {\n                var _this = this;\n                return Object.keys(this._obj).filter(function(key) {\n                    return _this.has(key);\n                });\n            }\n        },\n        {\n            key: \"forEach\",\n            value: function forEach(callback, thisArg) {\n                return this.toArray().forEach(callback, thisArg);\n            }\n        }\n    ]);\n}();\nvar Set$1 = (typeof Set === \"undefined\" ? \"undefined\" : _typeof(Set)) !== undef ? Set : ObjectSet;\n// represents a node or an edge\nvar Element = function Element(cy, params) {\n    var restore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (cy === undefined || params === undefined || !core(cy)) {\n        error('An element must have a core reference and parameters set');\n        return;\n    }\n    var group = params.group;\n    // try to automatically infer the group if unspecified\n    if (group == null) {\n        if (params.data && params.data.source != null && params.data.target != null) {\n            group = 'edges';\n        } else {\n            group = 'nodes';\n        }\n    }\n    // validate group\n    if (group !== 'nodes' && group !== 'edges') {\n        error('An element must be of type `nodes` or `edges`; you specified `' + group + '`');\n        return;\n    }\n    // make the element array-like, just like a collection\n    this.length = 1;\n    this[0] = this;\n    // NOTE: when something is added here, add also to ele.json()\n    var _p = this._private = {\n        cy: cy,\n        single: true,\n        // indicates this is an element\n        data: params.data || {},\n        // data object\n        position: params.position || {\n            x: 0,\n            y: 0\n        },\n        // (x, y) position pair\n        autoWidth: undefined,\n        // width and height of nodes calculated by the renderer when set to special 'auto' value\n        autoHeight: undefined,\n        autoPadding: undefined,\n        compoundBoundsClean: false,\n        // whether the compound dimensions need to be recalculated the next time dimensions are read\n        listeners: [],\n        // array of bound listeners\n        group: group,\n        // string; 'nodes' or 'edges'\n        style: {},\n        // properties as set by the style\n        rstyle: {},\n        // properties for style sent from the renderer to the core\n        styleCxts: [],\n        // applied style contexts from the styler\n        styleKeys: {},\n        // per-group keys of style property values\n        removed: true,\n        // whether it's inside the vis; true if removed (set true here since we call restore)\n        selected: params.selected ? true : false,\n        // whether it's selected\n        selectable: params.selectable === undefined ? true : params.selectable ? true : false,\n        // whether it's selectable\n        locked: params.locked ? true : false,\n        // whether the element is locked (cannot be moved)\n        grabbed: false,\n        // whether the element is grabbed by the mouse; renderer sets this privately\n        grabbable: params.grabbable === undefined ? true : params.grabbable ? true : false,\n        // whether the element can be grabbed\n        pannable: params.pannable === undefined ? group === 'edges' ? true : false : params.pannable ? true : false,\n        // whether the element has passthrough panning enabled\n        active: false,\n        // whether the element is active from user interaction\n        classes: new Set$1(),\n        // map ( className => true )\n        animation: {\n            // object for currently-running animations\n            current: [],\n            queue: []\n        },\n        rscratch: {},\n        // object in which the renderer can store information\n        scratch: params.scratch || {},\n        // scratch objects\n        edges: [],\n        // array of connected edges\n        children: [],\n        // array of children\n        parent: params.parent && params.parent.isNode() ? params.parent : null,\n        // parent ref\n        traversalCache: {},\n        // cache of output of traversal functions\n        backgrounding: false,\n        // whether background images are loading\n        bbCache: null,\n        // cache of the current bounding box\n        bbCacheShift: {\n            x: 0,\n            y: 0\n        },\n        // shift applied to cached bb to be applied on next get\n        bodyBounds: null,\n        // bounds cache of element body, w/o overlay\n        overlayBounds: null,\n        // bounds cache of element body, including overlay\n        labelBounds: {\n            // bounds cache of labels\n            all: null,\n            source: null,\n            target: null,\n            main: null\n        },\n        arrowBounds: {\n            // bounds cache of edge arrows\n            source: null,\n            target: null,\n            'mid-source': null,\n            'mid-target': null\n        }\n    };\n    if (_p.position.x == null) {\n        _p.position.x = 0;\n    }\n    if (_p.position.y == null) {\n        _p.position.y = 0;\n    }\n    // renderedPosition overrides if specified\n    if (params.renderedPosition) {\n        var rpos = params.renderedPosition;\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        _p.position = {\n            x: (rpos.x - pan.x) / zoom,\n            y: (rpos.y - pan.y) / zoom\n        };\n    }\n    var classes = [];\n    if (array(params.classes)) {\n        classes = params.classes;\n    } else if (string(params.classes)) {\n        classes = params.classes.split(/\\s+/);\n    }\n    for(var i = 0, l = classes.length; i < l; i++){\n        var cls = classes[i];\n        if (!cls || cls === '') {\n            continue;\n        }\n        _p.classes.add(cls);\n    }\n    this.createEmitter();\n    if (restore === undefined || restore) {\n        this.restore();\n    }\n    var bypass = params.style || params.css;\n    if (bypass) {\n        warn('Setting a `style` bypass at element creation should be done only when absolutely necessary.  Try to use the stylesheet instead.');\n        this.style(bypass);\n    }\n};\nvar defineSearch = function defineSearch(params) {\n    params = {\n        bfs: params.bfs || !params.dfs,\n        dfs: params.dfs || !params.bfs\n    };\n    // from pseudocode on wikipedia\n    return function searchFn(roots, fn, directed) {\n        var options;\n        if (plainObject(roots) && !elementOrCollection(roots)) {\n            options = roots;\n            roots = options.roots || options.root;\n            fn = options.visit;\n            directed = options.directed;\n        }\n        directed = arguments.length === 2 && !fn$6(fn) ? fn : directed;\n        fn = fn$6(fn) ? fn : function() {};\n        var cy = this._private.cy;\n        var v = roots = string(roots) ? this.filter(roots) : roots;\n        var Q = [];\n        var connectedNodes = [];\n        var connectedBy = {};\n        var id2depth = {};\n        var V = {};\n        var j = 0;\n        var found;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        // enqueue v\n        for(var i = 0; i < v.length; i++){\n            var vi = v[i];\n            var viId = vi.id();\n            if (vi.isNode()) {\n                Q.unshift(vi);\n                if (params.bfs) {\n                    V[viId] = true;\n                    connectedNodes.push(vi);\n                }\n                id2depth[viId] = 0;\n            }\n        }\n        var _loop = function _loop() {\n            var v = params.bfs ? Q.shift() : Q.pop();\n            var vId = v.id();\n            if (params.dfs) {\n                if (V[vId]) {\n                    return 0; // continue\n                }\n                V[vId] = true;\n                connectedNodes.push(v);\n            }\n            var depth = id2depth[vId];\n            var prevEdge = connectedBy[vId];\n            var src = prevEdge != null ? prevEdge.source() : null;\n            var tgt = prevEdge != null ? prevEdge.target() : null;\n            var prevNode = prevEdge == null ? undefined : v.same(src) ? tgt[0] : src[0];\n            var ret;\n            ret = fn(v, prevEdge, prevNode, j++, depth);\n            if (ret === true) {\n                found = v;\n                return 1; // break\n            }\n            if (ret === false) {\n                return 1; // break\n            }\n            var vwEdges = v.connectedEdges().filter(function(e) {\n                return (!directed || e.source().same(v)) && edges.has(e);\n            });\n            for(var _i2 = 0; _i2 < vwEdges.length; _i2++){\n                var e = vwEdges[_i2];\n                var w = e.connectedNodes().filter(function(n) {\n                    return !n.same(v) && nodes.has(n);\n                });\n                var wId = w.id();\n                if (w.length !== 0 && !V[wId]) {\n                    w = w[0];\n                    Q.push(w);\n                    if (params.bfs) {\n                        V[wId] = true;\n                        connectedNodes.push(w);\n                    }\n                    connectedBy[wId] = e;\n                    id2depth[wId] = id2depth[vId] + 1;\n                }\n            }\n        }, _ret;\n        while(Q.length !== 0){\n            _ret = _loop();\n            if (_ret === 0) continue;\n            if (_ret === 1) break;\n        }\n        var connectedEles = cy.collection();\n        for(var _i = 0; _i < connectedNodes.length; _i++){\n            var node = connectedNodes[_i];\n            var edge = connectedBy[node.id()];\n            if (edge != null) {\n                connectedEles.push(edge);\n            }\n            connectedEles.push(node);\n        }\n        return {\n            path: cy.collection(connectedEles),\n            found: cy.collection(found)\n        };\n    };\n};\n// search, spanning trees, etc\nvar elesfn$v = {\n    breadthFirstSearch: defineSearch({\n        bfs: true\n    }),\n    depthFirstSearch: defineSearch({\n        dfs: true\n    })\n};\n// nice, short mathematical alias\nelesfn$v.bfs = elesfn$v.breadthFirstSearch;\nelesfn$v.dfs = elesfn$v.depthFirstSearch;\nvar heap$2 = {\n    exports: {}\n};\nvar heap$1 = heap$2.exports;\nvar hasRequiredHeap$1;\nfunction requireHeap$1() {\n    if (hasRequiredHeap$1) return heap$2.exports;\n    hasRequiredHeap$1 = 1;\n    (function(module, exports) {\n        // Generated by CoffeeScript 1.8.0\n        (function() {\n            var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n            floor = Math.floor, min = Math.min;\n            /*\n\t\t  Default comparison function to be used\n\t\t   */ defaultCmp = function(x, y) {\n                if (x < y) {\n                    return -1;\n                }\n                if (x > y) {\n                    return 1;\n                }\n                return 0;\n            };\n            /*\n\t\t  Insert item x in list a, and keep it sorted assuming a is sorted.\n\t\t  \n\t\t  If x is already in a, insert it to the right of the rightmost x.\n\t\t  \n\t\t  Optional args lo (default 0) and hi (default a.length) bound the slice\n\t\t  of a to be searched.\n\t\t   */ insort = function(a, x, lo, hi, cmp) {\n                var mid;\n                if (lo == null) {\n                    lo = 0;\n                }\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (lo < 0) {\n                    throw new Error('lo must be non-negative');\n                }\n                if (hi == null) {\n                    hi = a.length;\n                }\n                while(lo < hi){\n                    mid = floor((lo + hi) / 2);\n                    if (cmp(x, a[mid]) < 0) {\n                        hi = mid;\n                    } else {\n                        lo = mid + 1;\n                    }\n                }\n                return [].splice.apply(a, [\n                    lo,\n                    lo - lo\n                ].concat(x)), x;\n            };\n            /*\n\t\t  Push item onto heap, maintaining the heap invariant.\n\t\t   */ heappush = function(array, item, cmp) {\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                array.push(item);\n                return _siftdown(array, 0, array.length - 1, cmp);\n            };\n            /*\n\t\t  Pop the smallest item off the heap, maintaining the heap invariant.\n\t\t   */ heappop = function(array, cmp) {\n                var lastelt, returnitem;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                lastelt = array.pop();\n                if (array.length) {\n                    returnitem = array[0];\n                    array[0] = lastelt;\n                    _siftup(array, 0, cmp);\n                } else {\n                    returnitem = lastelt;\n                }\n                return returnitem;\n            };\n            /*\n\t\t  Pop and return the current smallest value, and add the new item.\n\t\t  \n\t\t  This is more efficient than heappop() followed by heappush(), and can be\n\t\t  more appropriate when using a fixed size heap. Note that the value\n\t\t  returned may be larger than item! That constrains reasonable use of\n\t\t  this routine unless written as part of a conditional replacement:\n\t\t      if item > array[0]\n\t\t        item = heapreplace(array, item)\n\t\t   */ heapreplace = function(array, item, cmp) {\n                var returnitem;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                returnitem = array[0];\n                array[0] = item;\n                _siftup(array, 0, cmp);\n                return returnitem;\n            };\n            /*\n\t\t  Fast version of a heappush followed by a heappop.\n\t\t   */ heappushpop = function(array, item, cmp) {\n                var _ref;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (array.length && cmp(array[0], item) < 0) {\n                    _ref = [\n                        array[0],\n                        item\n                    ], item = _ref[0], array[0] = _ref[1];\n                    _siftup(array, 0, cmp);\n                }\n                return item;\n            };\n            /*\n\t\t  Transform list into a heap, in-place, in O(array.length) time.\n\t\t   */ heapify = function(array, cmp) {\n                var i, _i, _len, _ref1, _results, _results1;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                _ref1 = (function() {\n                    _results1 = [];\n                    for(var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){\n                        _results1.push(_j);\n                    }\n                    return _results1;\n                }).apply(this).reverse();\n                _results = [];\n                for(_i = 0, _len = _ref1.length; _i < _len; _i++){\n                    i = _ref1[_i];\n                    _results.push(_siftup(array, i, cmp));\n                }\n                return _results;\n            };\n            /*\n\t\t  Update the position of the given item in the heap.\n\t\t  This function should be called every time the item is being modified.\n\t\t   */ updateItem = function(array, item, cmp) {\n                var pos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                pos = array.indexOf(item);\n                if (pos === -1) {\n                    return;\n                }\n                _siftdown(array, 0, pos, cmp);\n                return _siftup(array, pos, cmp);\n            };\n            /*\n\t\t  Find the n largest elements in a dataset.\n\t\t   */ nlargest = function(array, n, cmp) {\n                var elem, result, _i, _len, _ref;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                result = array.slice(0, n);\n                if (!result.length) {\n                    return result;\n                }\n                heapify(result, cmp);\n                _ref = array.slice(n);\n                for(_i = 0, _len = _ref.length; _i < _len; _i++){\n                    elem = _ref[_i];\n                    heappushpop(result, elem, cmp);\n                }\n                return result.sort(cmp).reverse();\n            };\n            /*\n\t\t  Find the n smallest elements in a dataset.\n\t\t   */ nsmallest = function(array, n, cmp) {\n                var elem, los, result, _i, _j, _len, _ref, _ref1, _results;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                if (n * 10 <= array.length) {\n                    result = array.slice(0, n).sort(cmp);\n                    if (!result.length) {\n                        return result;\n                    }\n                    los = result[result.length - 1];\n                    _ref = array.slice(n);\n                    for(_i = 0, _len = _ref.length; _i < _len; _i++){\n                        elem = _ref[_i];\n                        if (cmp(elem, los) < 0) {\n                            insort(result, elem, 0, null, cmp);\n                            result.pop();\n                            los = result[result.length - 1];\n                        }\n                    }\n                    return result;\n                }\n                heapify(array, cmp);\n                _results = [];\n                for(_j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; 0 <= _ref1 ? ++_j : --_j){\n                    _results.push(heappop(array, cmp));\n                }\n                return _results;\n            };\n            _siftdown = function(array, startpos, pos, cmp) {\n                var newitem, parent, parentpos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                newitem = array[pos];\n                while(pos > startpos){\n                    parentpos = pos - 1 >> 1;\n                    parent = array[parentpos];\n                    if (cmp(newitem, parent) < 0) {\n                        array[pos] = parent;\n                        pos = parentpos;\n                        continue;\n                    }\n                    break;\n                }\n                return array[pos] = newitem;\n            };\n            _siftup = function(array, pos, cmp) {\n                var childpos, endpos, newitem, rightpos, startpos;\n                if (cmp == null) {\n                    cmp = defaultCmp;\n                }\n                endpos = array.length;\n                startpos = pos;\n                newitem = array[pos];\n                childpos = 2 * pos + 1;\n                while(childpos < endpos){\n                    rightpos = childpos + 1;\n                    if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n                        childpos = rightpos;\n                    }\n                    array[pos] = array[childpos];\n                    pos = childpos;\n                    childpos = 2 * pos + 1;\n                }\n                array[pos] = newitem;\n                return _siftdown(array, startpos, pos, cmp);\n            };\n            Heap = function() {\n                Heap.push = heappush;\n                Heap.pop = heappop;\n                Heap.replace = heapreplace;\n                Heap.pushpop = heappushpop;\n                Heap.heapify = heapify;\n                Heap.updateItem = updateItem;\n                Heap.nlargest = nlargest;\n                Heap.nsmallest = nsmallest;\n                function Heap(cmp) {\n                    this.cmp = cmp != null ? cmp : defaultCmp;\n                    this.nodes = [];\n                }\n                Heap.prototype.push = function(x) {\n                    return heappush(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.pop = function() {\n                    return heappop(this.nodes, this.cmp);\n                };\n                Heap.prototype.peek = function() {\n                    return this.nodes[0];\n                };\n                Heap.prototype.contains = function(x) {\n                    return this.nodes.indexOf(x) !== -1;\n                };\n                Heap.prototype.replace = function(x) {\n                    return heapreplace(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.pushpop = function(x) {\n                    return heappushpop(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.heapify = function() {\n                    return heapify(this.nodes, this.cmp);\n                };\n                Heap.prototype.updateItem = function(x) {\n                    return updateItem(this.nodes, x, this.cmp);\n                };\n                Heap.prototype.clear = function() {\n                    return this.nodes = [];\n                };\n                Heap.prototype.empty = function() {\n                    return this.nodes.length === 0;\n                };\n                Heap.prototype.size = function() {\n                    return this.nodes.length;\n                };\n                Heap.prototype.clone = function() {\n                    var heap;\n                    heap = new Heap();\n                    heap.nodes = this.nodes.slice(0);\n                    return heap;\n                };\n                Heap.prototype.toArray = function() {\n                    return this.nodes.slice(0);\n                };\n                Heap.prototype.insert = Heap.prototype.push;\n                Heap.prototype.top = Heap.prototype.peek;\n                Heap.prototype.front = Heap.prototype.peek;\n                Heap.prototype.has = Heap.prototype.contains;\n                Heap.prototype.copy = Heap.prototype.clone;\n                return Heap;\n            }();\n            (function(root, factory) {\n                {\n                    return module.exports = factory();\n                }\n            })(this, function() {\n                return Heap;\n            });\n        }).call(heap$1);\n    })(heap$2);\n    return heap$2.exports;\n}\nvar heap;\nvar hasRequiredHeap;\nfunction requireHeap() {\n    if (hasRequiredHeap) return heap;\n    hasRequiredHeap = 1;\n    heap = requireHeap$1();\n    return heap;\n}\nvar heapExports = requireHeap();\nvar Heap = /*@__PURE__*/ getDefaultExportFromCjs(heapExports);\nvar dijkstraDefaults = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false\n});\nvar elesfn$u = {\n    dijkstra: function dijkstra(options) {\n        if (!plainObject(options)) {\n            var args = arguments;\n            options = {\n                root: args[0],\n                weight: args[1],\n                directed: args[2]\n            };\n        }\n        var _dijkstraDefaults = dijkstraDefaults(options), root = _dijkstraDefaults.root, weight = _dijkstraDefaults.weight, directed = _dijkstraDefaults.directed;\n        var eles = this;\n        var weightFn = weight;\n        var source = string(root) ? this.filter(root)[0] : root[0];\n        var dist = {};\n        var prev = {};\n        var knownDist = {};\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        edges.unmergeBy(function(ele) {\n            return ele.isLoop();\n        });\n        var getDist = function getDist(node) {\n            return dist[node.id()];\n        };\n        var setDist = function setDist(node, d) {\n            dist[node.id()] = d;\n            Q.updateItem(node);\n        };\n        var Q = new Heap(function(a, b) {\n            return getDist(a) - getDist(b);\n        });\n        for(var i = 0; i < nodes.length; i++){\n            var node = nodes[i];\n            dist[node.id()] = node.same(source) ? 0 : Infinity;\n            Q.push(node);\n        }\n        var distBetween = function distBetween(u, v) {\n            var uvs = (directed ? u.edgesTo(v) : u.edgesWith(v)).intersect(edges);\n            var smallestDistance = Infinity;\n            var smallestEdge;\n            for(var _i = 0; _i < uvs.length; _i++){\n                var edge = uvs[_i];\n                var _weight = weightFn(edge);\n                if (_weight < smallestDistance || !smallestEdge) {\n                    smallestDistance = _weight;\n                    smallestEdge = edge;\n                }\n            }\n            return {\n                edge: smallestEdge,\n                dist: smallestDistance\n            };\n        };\n        while(Q.size() > 0){\n            var u = Q.pop();\n            var smalletsDist = getDist(u);\n            var uid = u.id();\n            knownDist[uid] = smalletsDist;\n            if (smalletsDist === Infinity) {\n                continue;\n            }\n            var neighbors = u.neighborhood().intersect(nodes);\n            for(var _i2 = 0; _i2 < neighbors.length; _i2++){\n                var v = neighbors[_i2];\n                var vid = v.id();\n                var vDist = distBetween(u, v);\n                var alt = smalletsDist + vDist.dist;\n                if (alt < getDist(v)) {\n                    setDist(v, alt);\n                    prev[vid] = {\n                        node: u,\n                        edge: vDist.edge\n                    };\n                }\n            } // for\n        } // while\n        return {\n            distanceTo: function distanceTo(node) {\n                var target = string(node) ? nodes.filter(node)[0] : node[0];\n                return knownDist[target.id()];\n            },\n            pathTo: function pathTo(node) {\n                var target = string(node) ? nodes.filter(node)[0] : node[0];\n                var S = [];\n                var u = target;\n                var uid = u.id();\n                if (target.length > 0) {\n                    S.unshift(target);\n                    while(prev[uid]){\n                        var p = prev[uid];\n                        S.unshift(p.edge);\n                        S.unshift(p.node);\n                        u = p.node;\n                        uid = u.id();\n                    }\n                }\n                return eles.spawn(S);\n            }\n        };\n    }\n};\nvar elesfn$t = {\n    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)\n    // implemented from pseudocode from wikipedia\n    kruskal: function kruskal(weightFn) {\n        weightFn = weightFn || function(edge) {\n            return 1;\n        };\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        var numNodes = nodes.length;\n        var forest = new Array(numNodes);\n        var A = nodes; // assumes byGroup() creates new collections that can be safely mutated\n        var findSetIndex = function findSetIndex(ele) {\n            for(var i = 0; i < forest.length; i++){\n                var eles = forest[i];\n                if (eles.has(ele)) {\n                    return i;\n                }\n            }\n        };\n        // start with one forest per node\n        for(var i = 0; i < numNodes; i++){\n            forest[i] = this.spawn(nodes[i]);\n        }\n        var S = edges.sort(function(a, b) {\n            return weightFn(a) - weightFn(b);\n        });\n        for(var _i = 0; _i < S.length; _i++){\n            var edge = S[_i];\n            var u = edge.source()[0];\n            var v = edge.target()[0];\n            var setUIndex = findSetIndex(u);\n            var setVIndex = findSetIndex(v);\n            var setU = forest[setUIndex];\n            var setV = forest[setVIndex];\n            if (setUIndex !== setVIndex) {\n                A.merge(edge);\n                // combine forests for u and v\n                setU.merge(setV);\n                forest.splice(setVIndex, 1);\n            }\n        }\n        return A;\n    }\n};\nvar aStarDefaults = defaults$g({\n    root: null,\n    goal: null,\n    weight: function weight(edge) {\n        return 1;\n    },\n    heuristic: function heuristic(edge) {\n        return 0;\n    },\n    directed: false\n});\nvar elesfn$s = {\n    // Implemented from pseudocode from wikipedia\n    aStar: function aStar(options) {\n        var cy = this.cy();\n        var _aStarDefaults = aStarDefaults(options), root = _aStarDefaults.root, goal = _aStarDefaults.goal, heuristic = _aStarDefaults.heuristic, directed = _aStarDefaults.directed, weight = _aStarDefaults.weight;\n        root = cy.collection(root)[0];\n        goal = cy.collection(goal)[0];\n        var sid = root.id();\n        var tid = goal.id();\n        var gScore = {};\n        var fScore = {};\n        var closedSetIds = {};\n        var openSet = new Heap(function(a, b) {\n            return fScore[a.id()] - fScore[b.id()];\n        });\n        var openSetIds = new Set$1();\n        var cameFrom = {};\n        var cameFromEdge = {};\n        var addToOpenSet = function addToOpenSet(ele, id) {\n            openSet.push(ele);\n            openSetIds.add(id);\n        };\n        var cMin, cMinId;\n        var popFromOpenSet = function popFromOpenSet() {\n            cMin = openSet.pop();\n            cMinId = cMin.id();\n            openSetIds[\"delete\"](cMinId);\n        };\n        var isInOpenSet = function isInOpenSet(id) {\n            return openSetIds.has(id);\n        };\n        addToOpenSet(root, sid);\n        gScore[sid] = 0;\n        fScore[sid] = heuristic(root);\n        // Counter\n        var steps = 0;\n        // Main loop\n        while(openSet.size() > 0){\n            popFromOpenSet();\n            steps++;\n            // If we've found our goal, then we are done\n            if (cMinId === tid) {\n                var path = [];\n                var pathNode = goal;\n                var pathNodeId = tid;\n                var pathEdge = cameFromEdge[pathNodeId];\n                for(;;){\n                    path.unshift(pathNode);\n                    if (pathEdge != null) {\n                        path.unshift(pathEdge);\n                    }\n                    pathNode = cameFrom[pathNodeId];\n                    if (pathNode == null) {\n                        break;\n                    }\n                    pathNodeId = pathNode.id();\n                    pathEdge = cameFromEdge[pathNodeId];\n                }\n                return {\n                    found: true,\n                    distance: gScore[cMinId],\n                    path: this.spawn(path),\n                    steps: steps\n                };\n            }\n            // Add cMin to processed nodes\n            closedSetIds[cMinId] = true;\n            // Update scores for neighbors of cMin\n            // Take into account if graph is directed or not\n            var vwEdges = cMin._private.edges;\n            for(var i = 0; i < vwEdges.length; i++){\n                var e = vwEdges[i];\n                // edge must be in set of calling eles\n                if (!this.hasElementWithId(e.id())) {\n                    continue;\n                }\n                // cMin must be the source of edge if directed\n                if (directed && e.data('source') !== cMinId) {\n                    continue;\n                }\n                var wSrc = e.source();\n                var wTgt = e.target();\n                var w = wSrc.id() !== cMinId ? wSrc : wTgt;\n                var wid = w.id();\n                // node must be in set of calling eles\n                if (!this.hasElementWithId(wid)) {\n                    continue;\n                }\n                // if node is in closedSet, ignore it\n                if (closedSetIds[wid]) {\n                    continue;\n                }\n                // New tentative score for node w\n                var tempScore = gScore[cMinId] + weight(e);\n                // Update gScore for node w if:\n                //   w not present in openSet\n                // OR\n                //   tentative gScore is less than previous value\n                // w not in openSet\n                if (!isInOpenSet(wid)) {\n                    gScore[wid] = tempScore;\n                    fScore[wid] = tempScore + heuristic(w);\n                    addToOpenSet(w, wid);\n                    cameFrom[wid] = cMin;\n                    cameFromEdge[wid] = e;\n                    continue;\n                }\n                // w already in openSet, but with greater gScore\n                if (tempScore < gScore[wid]) {\n                    gScore[wid] = tempScore;\n                    fScore[wid] = tempScore + heuristic(w);\n                    cameFrom[wid] = cMin;\n                    cameFromEdge[wid] = e;\n                }\n            } // End of neighbors update\n        } // End of main loop\n        // If we've reached here, then we've not reached our goal\n        return {\n            found: false,\n            distance: undefined,\n            path: undefined,\n            steps: steps\n        };\n    }\n}; // elesfn\nvar floydWarshallDefaults = defaults$g({\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false\n});\nvar elesfn$r = {\n    // Implemented from pseudocode from wikipedia\n    floydWarshall: function floydWarshall(options) {\n        var cy = this.cy();\n        var _floydWarshallDefault = floydWarshallDefaults(options), weight = _floydWarshallDefault.weight, directed = _floydWarshallDefault.directed;\n        var weightFn = weight;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        var N = nodes.length;\n        var Nsq = N * N;\n        var indexOf = function indexOf(node) {\n            return nodes.indexOf(node);\n        };\n        var atIndex = function atIndex(i) {\n            return nodes[i];\n        };\n        // Initialize distance matrix\n        var dist = new Array(Nsq);\n        for(var n = 0; n < Nsq; n++){\n            var j = n % N;\n            var i = (n - j) / N;\n            if (i === j) {\n                dist[n] = 0;\n            } else {\n                dist[n] = Infinity;\n            }\n        }\n        // Initialize matrix used for path reconstruction\n        // Initialize distance matrix\n        var next = new Array(Nsq);\n        var edgeNext = new Array(Nsq);\n        // Process edges\n        for(var _i = 0; _i < edges.length; _i++){\n            var edge = edges[_i];\n            var src = edge.source()[0];\n            var tgt = edge.target()[0];\n            if (src === tgt) {\n                continue;\n            } // exclude loops\n            var s = indexOf(src);\n            var t = indexOf(tgt);\n            var st = s * N + t; // source to target index\n            var _weight = weightFn(edge);\n            // Check if already process another edge between same 2 nodes\n            if (dist[st] > _weight) {\n                dist[st] = _weight;\n                next[st] = t;\n                edgeNext[st] = edge;\n            }\n            // If undirected graph, process 'reversed' edge\n            if (!directed) {\n                var ts = t * N + s; // target to source index\n                if (!directed && dist[ts] > _weight) {\n                    dist[ts] = _weight;\n                    next[ts] = s;\n                    edgeNext[ts] = edge;\n                }\n            }\n        }\n        // Main loop\n        for(var k = 0; k < N; k++){\n            for(var _i2 = 0; _i2 < N; _i2++){\n                var ik = _i2 * N + k;\n                for(var _j = 0; _j < N; _j++){\n                    var ij = _i2 * N + _j;\n                    var kj = k * N + _j;\n                    if (dist[ik] + dist[kj] < dist[ij]) {\n                        dist[ij] = dist[ik] + dist[kj];\n                        next[ij] = next[ik];\n                    }\n                }\n            }\n        }\n        var getArgEle = function getArgEle(ele) {\n            return (string(ele) ? cy.filter(ele) : ele)[0];\n        };\n        var indexOfArgEle = function indexOfArgEle(ele) {\n            return indexOf(getArgEle(ele));\n        };\n        var res = {\n            distance: function distance(from, to) {\n                var i = indexOfArgEle(from);\n                var j = indexOfArgEle(to);\n                return dist[i * N + j];\n            },\n            path: function path(from, to) {\n                var i = indexOfArgEle(from);\n                var j = indexOfArgEle(to);\n                var fromNode = atIndex(i);\n                if (i === j) {\n                    return fromNode.collection();\n                }\n                if (next[i * N + j] == null) {\n                    return cy.collection();\n                }\n                var path = cy.collection();\n                var prev = i;\n                var edge;\n                path.merge(fromNode);\n                while(i !== j){\n                    prev = i;\n                    i = next[i * N + j];\n                    edge = edgeNext[prev * N + i];\n                    path.merge(edge);\n                    path.merge(atIndex(i));\n                }\n                return path;\n            }\n        };\n        return res;\n    } // floydWarshall\n}; // elesfn\nvar bellmanFordDefaults = defaults$g({\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false,\n    root: null\n});\nvar elesfn$q = {\n    // Implemented from pseudocode from wikipedia\n    bellmanFord: function bellmanFord(options) {\n        var _this = this;\n        var _bellmanFordDefaults = bellmanFordDefaults(options), weight = _bellmanFordDefaults.weight, directed = _bellmanFordDefaults.directed, root = _bellmanFordDefaults.root;\n        var weightFn = weight;\n        var eles = this;\n        var cy = this.cy();\n        var _this$byGroup = this.byGroup(), edges = _this$byGroup.edges, nodes = _this$byGroup.nodes;\n        var numNodes = nodes.length;\n        var infoMap = new Map$1();\n        var hasNegativeWeightCycle = false;\n        var negativeWeightCycles = [];\n        root = cy.collection(root)[0]; // in case selector passed\n        edges.unmergeBy(function(edge) {\n            return edge.isLoop();\n        });\n        var numEdges = edges.length;\n        var getInfo = function getInfo(node) {\n            var obj = infoMap.get(node.id());\n            if (!obj) {\n                obj = {};\n                infoMap.set(node.id(), obj);\n            }\n            return obj;\n        };\n        var getNodeFromTo = function getNodeFromTo(to) {\n            return (string(to) ? cy.$(to) : to)[0];\n        };\n        var distanceTo = function distanceTo(to) {\n            return getInfo(getNodeFromTo(to)).dist;\n        };\n        var pathTo = function pathTo(to) {\n            var thisStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : root;\n            var end = getNodeFromTo(to);\n            var path = [];\n            var node = end;\n            for(;;){\n                if (node == null) {\n                    return _this.spawn();\n                }\n                var _getInfo = getInfo(node), edge = _getInfo.edge, pred = _getInfo.pred;\n                path.unshift(node[0]);\n                if (node.same(thisStart) && path.length > 0) {\n                    break;\n                }\n                if (edge != null) {\n                    path.unshift(edge);\n                }\n                node = pred;\n            }\n            return eles.spawn(path);\n        };\n        // Initializations { dist, pred, edge }\n        for(var i = 0; i < numNodes; i++){\n            var node = nodes[i];\n            var info = getInfo(node);\n            if (node.same(root)) {\n                info.dist = 0;\n            } else {\n                info.dist = Infinity;\n            }\n            info.pred = null;\n            info.edge = null;\n        }\n        // Edges relaxation\n        var replacedEdge = false;\n        var checkForEdgeReplacement = function checkForEdgeReplacement(node1, node2, edge, info1, info2, weight) {\n            var dist = info1.dist + weight;\n            if (dist < info2.dist && !edge.same(info1.edge)) {\n                info2.dist = dist;\n                info2.pred = node1;\n                info2.edge = edge;\n                replacedEdge = true;\n            }\n        };\n        for(var _i = 1; _i < numNodes; _i++){\n            replacedEdge = false;\n            for(var e = 0; e < numEdges; e++){\n                var edge = edges[e];\n                var src = edge.source();\n                var tgt = edge.target();\n                var _weight = weightFn(edge);\n                var srcInfo = getInfo(src);\n                var tgtInfo = getInfo(tgt);\n                checkForEdgeReplacement(src, tgt, edge, srcInfo, tgtInfo, _weight);\n                // If undirected graph, we need to take into account the 'reverse' edge\n                if (!directed) {\n                    checkForEdgeReplacement(tgt, src, edge, tgtInfo, srcInfo, _weight);\n                }\n            }\n            if (!replacedEdge) {\n                break;\n            }\n        }\n        if (replacedEdge) {\n            // Check for negative weight cycles\n            var negativeWeightCycleIds = [];\n            for(var _e = 0; _e < numEdges; _e++){\n                var _edge = edges[_e];\n                var _src = _edge.source();\n                var _tgt = _edge.target();\n                var _weight2 = weightFn(_edge);\n                var srcDist = getInfo(_src).dist;\n                var tgtDist = getInfo(_tgt).dist;\n                if (srcDist + _weight2 < tgtDist || !directed && tgtDist + _weight2 < srcDist) {\n                    if (!hasNegativeWeightCycle) {\n                        warn('Graph contains a negative weight cycle for Bellman-Ford');\n                        hasNegativeWeightCycle = true;\n                    }\n                    if (options.findNegativeWeightCycles !== false) {\n                        var negativeNodes = [];\n                        if (srcDist + _weight2 < tgtDist) {\n                            negativeNodes.push(_src);\n                        }\n                        if (!directed && tgtDist + _weight2 < srcDist) {\n                            negativeNodes.push(_tgt);\n                        }\n                        var numNegativeNodes = negativeNodes.length;\n                        for(var n = 0; n < numNegativeNodes; n++){\n                            var start = negativeNodes[n];\n                            var cycle = [\n                                start\n                            ];\n                            cycle.push(getInfo(start).edge);\n                            var _node = getInfo(start).pred;\n                            while(cycle.indexOf(_node) === -1){\n                                cycle.push(_node);\n                                cycle.push(getInfo(_node).edge);\n                                _node = getInfo(_node).pred;\n                            }\n                            cycle = cycle.slice(cycle.indexOf(_node));\n                            var smallestId = cycle[0].id();\n                            var smallestIndex = 0;\n                            for(var c = 2; c < cycle.length; c += 2){\n                                if (cycle[c].id() < smallestId) {\n                                    smallestId = cycle[c].id();\n                                    smallestIndex = c;\n                                }\n                            }\n                            cycle = cycle.slice(smallestIndex).concat(cycle.slice(0, smallestIndex));\n                            cycle.push(cycle[0]);\n                            var cycleId = cycle.map(function(el) {\n                                return el.id();\n                            }).join(\",\");\n                            if (negativeWeightCycleIds.indexOf(cycleId) === -1) {\n                                negativeWeightCycles.push(eles.spawn(cycle));\n                                negativeWeightCycleIds.push(cycleId);\n                            }\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        return {\n            distanceTo: distanceTo,\n            pathTo: pathTo,\n            hasNegativeWeightCycle: hasNegativeWeightCycle,\n            negativeWeightCycles: negativeWeightCycles\n        };\n    } // bellmanFord\n}; // elesfn\nvar sqrt2 = Math.sqrt(2);\n// Function which colapses 2 (meta) nodes into one\n// Updates the remaining edge lists\n// Receives as a paramater the edge which causes the collapse\nvar collapse = function collapse(edgeIndex, nodeMap, remainingEdges) {\n    if (remainingEdges.length === 0) {\n        error(\"Karger-Stein must be run on a connected (sub)graph\");\n    }\n    var edgeInfo = remainingEdges[edgeIndex];\n    var sourceIn = edgeInfo[1];\n    var targetIn = edgeInfo[2];\n    var partition1 = nodeMap[sourceIn];\n    var partition2 = nodeMap[targetIn];\n    var newEdges = remainingEdges; // re-use array\n    // Delete all edges between partition1 and partition2\n    for(var i = newEdges.length - 1; i >= 0; i--){\n        var edge = newEdges[i];\n        var src = edge[1];\n        var tgt = edge[2];\n        if (nodeMap[src] === partition1 && nodeMap[tgt] === partition2 || nodeMap[src] === partition2 && nodeMap[tgt] === partition1) {\n            newEdges.splice(i, 1);\n        }\n    }\n    // All edges pointing to partition2 should now point to partition1\n    for(var _i = 0; _i < newEdges.length; _i++){\n        var _edge = newEdges[_i];\n        if (_edge[1] === partition2) {\n            // Check source\n            newEdges[_i] = _edge.slice(); // copy\n            newEdges[_i][1] = partition1;\n        } else if (_edge[2] === partition2) {\n            // Check target\n            newEdges[_i] = _edge.slice(); // copy\n            newEdges[_i][2] = partition1;\n        }\n    }\n    // Move all nodes from partition2 to partition1\n    for(var _i2 = 0; _i2 < nodeMap.length; _i2++){\n        if (nodeMap[_i2] === partition2) {\n            nodeMap[_i2] = partition1;\n        }\n    }\n    return newEdges;\n};\n// Contracts a graph until we reach a certain number of meta nodes\nvar contractUntil = function contractUntil(metaNodeMap, remainingEdges, size, sizeLimit) {\n    while(size > sizeLimit){\n        // Choose an edge randomly\n        var edgeIndex = Math.floor(Math.random() * remainingEdges.length);\n        // Collapse graph based on edge\n        remainingEdges = collapse(edgeIndex, metaNodeMap, remainingEdges);\n        size--;\n    }\n    return remainingEdges;\n};\nvar elesfn$p = {\n    // Computes the minimum cut of an undirected graph\n    // Returns the correct answer with high probability\n    kargerStein: function kargerStein() {\n        var _this = this;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        edges.unmergeBy(function(edge) {\n            return edge.isLoop();\n        });\n        var numNodes = nodes.length;\n        var numEdges = edges.length;\n        var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));\n        var stopSize = Math.floor(numNodes / sqrt2);\n        if (numNodes < 2) {\n            error('At least 2 nodes are required for Karger-Stein algorithm');\n            return undefined;\n        }\n        // Now store edge destination as indexes\n        // Format for each edge (edge index, source node index, target node index)\n        var edgeIndexes = [];\n        for(var i = 0; i < numEdges; i++){\n            var e = edges[i];\n            edgeIndexes.push([\n                i,\n                nodes.indexOf(e.source()),\n                nodes.indexOf(e.target())\n            ]);\n        }\n        // We will store the best cut found here\n        var minCutSize = Infinity;\n        var minCutEdgeIndexes = [];\n        var minCutNodeMap = new Array(numNodes);\n        // Initial meta node partition\n        var metaNodeMap = new Array(numNodes);\n        var metaNodeMap2 = new Array(numNodes);\n        var copyNodesMap = function copyNodesMap(from, to) {\n            for(var _i3 = 0; _i3 < numNodes; _i3++){\n                to[_i3] = from[_i3];\n            }\n        };\n        // Main loop\n        for(var iter = 0; iter <= numIter; iter++){\n            // Reset meta node partition\n            for(var _i4 = 0; _i4 < numNodes; _i4++){\n                metaNodeMap[_i4] = _i4;\n            }\n            // Contract until stop point (stopSize nodes)\n            var edgesState = contractUntil(metaNodeMap, edgeIndexes.slice(), numNodes, stopSize);\n            var edgesState2 = edgesState.slice(); // copy\n            // Create a copy of the colapsed nodes state\n            copyNodesMap(metaNodeMap, metaNodeMap2);\n            // Run 2 iterations starting in the stop state\n            var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);\n            var res2 = contractUntil(metaNodeMap2, edgesState2, stopSize, 2);\n            // Is any of the 2 results the best cut so far?\n            if (res1.length <= res2.length && res1.length < minCutSize) {\n                minCutSize = res1.length;\n                minCutEdgeIndexes = res1;\n                copyNodesMap(metaNodeMap, minCutNodeMap);\n            } else if (res2.length <= res1.length && res2.length < minCutSize) {\n                minCutSize = res2.length;\n                minCutEdgeIndexes = res2;\n                copyNodesMap(metaNodeMap2, minCutNodeMap);\n            }\n        } // end of main loop\n        // Construct result\n        var cut = this.spawn(minCutEdgeIndexes.map(function(e) {\n            return edges[e[0]];\n        }));\n        var partition1 = this.spawn();\n        var partition2 = this.spawn();\n        // traverse metaNodeMap for best cut\n        var witnessNodePartition = minCutNodeMap[0];\n        for(var _i5 = 0; _i5 < minCutNodeMap.length; _i5++){\n            var partitionId = minCutNodeMap[_i5];\n            var node = nodes[_i5];\n            if (partitionId === witnessNodePartition) {\n                partition1.merge(node);\n            } else {\n                partition2.merge(node);\n            }\n        }\n        // construct components corresponding to each disjoint subset of nodes\n        var constructComponent = function constructComponent(subset) {\n            var component = _this.spawn();\n            subset.forEach(function(node) {\n                component.merge(node);\n                node.connectedEdges().forEach(function(edge) {\n                    // ensure edge is within calling collection and edge is not in cut\n                    if (_this.contains(edge) && !cut.contains(edge)) {\n                        component.merge(edge);\n                    }\n                });\n            });\n            return component;\n        };\n        var components = [\n            constructComponent(partition1),\n            constructComponent(partition2)\n        ];\n        var ret = {\n            cut: cut,\n            components: components,\n            // n.b. partitions are included to be compatible with the old api spec\n            // (could be removed in a future major version)\n            partition1: partition1,\n            partition2: partition2\n        };\n        return ret;\n    }\n}; // elesfn\nvar _Math$hypot;\nvar copyPosition = function copyPosition(p) {\n    return {\n        x: p.x,\n        y: p.y\n    };\n};\nvar modelToRenderedPosition$1 = function modelToRenderedPosition(p, zoom, pan) {\n    return {\n        x: p.x * zoom + pan.x,\n        y: p.y * zoom + pan.y\n    };\n};\nvar renderedToModelPosition = function renderedToModelPosition(p, zoom, pan) {\n    return {\n        x: (p.x - pan.x) / zoom,\n        y: (p.y - pan.y) / zoom\n    };\n};\nvar array2point = function array2point(arr) {\n    return {\n        x: arr[0],\n        y: arr[1]\n    };\n};\nvar min = function min(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var min = Infinity;\n    for(var i = begin; i < end; i++){\n        var val = arr[i];\n        if (isFinite(val)) {\n            min = Math.min(val, min);\n        }\n    }\n    return min;\n};\nvar max = function max(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var max = -Infinity;\n    for(var i = begin; i < end; i++){\n        var val = arr[i];\n        if (isFinite(val)) {\n            max = Math.max(val, max);\n        }\n    }\n    return max;\n};\nvar mean = function mean(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var total = 0;\n    var n = 0;\n    for(var i = begin; i < end; i++){\n        var val = arr[i];\n        if (isFinite(val)) {\n            total += val;\n            n++;\n        }\n    }\n    return total / n;\n};\nvar median = function median(arr) {\n    var begin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arr.length;\n    var copy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var sort = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var includeHoles = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    if (copy) {\n        arr = arr.slice(begin, end);\n    } else {\n        if (end < arr.length) {\n            arr.splice(end, arr.length - end);\n        }\n        if (begin > 0) {\n            arr.splice(0, begin);\n        }\n    }\n    // all non finite (e.g. Infinity, NaN) elements must be -Infinity so they go to the start\n    var off = 0; // offset from non-finite values\n    for(var i = arr.length - 1; i >= 0; i--){\n        var v = arr[i];\n        if (includeHoles) {\n            if (!isFinite(v)) {\n                arr[i] = -Infinity;\n                off++;\n            }\n        } else {\n            // just remove it if we don't want to consider holes\n            arr.splice(i, 1);\n        }\n    }\n    if (sort) {\n        arr.sort(function(a, b) {\n            return a - b;\n        }); // requires copy = true if you don't want to change the orig\n    }\n    var len = arr.length;\n    var mid = Math.floor(len / 2);\n    if (len % 2 !== 0) {\n        return arr[mid + 1 + off];\n    } else {\n        return (arr[mid - 1 + off] + arr[mid + off]) / 2;\n    }\n};\nvar deg2rad = function deg2rad(deg) {\n    return Math.PI * deg / 180;\n};\nvar getAngleFromDisp = function getAngleFromDisp(dispX, dispY) {\n    return Math.atan2(dispY, dispX) - Math.PI / 2;\n};\nvar log2 = Math.log2 || function(n) {\n    return Math.log(n) / Math.log(2);\n};\nvar signum = function signum(x) {\n    if (x > 0) {\n        return 1;\n    } else if (x < 0) {\n        return -1;\n    } else {\n        return 0;\n    }\n};\nvar dist = function dist(p1, p2) {\n    return Math.sqrt(sqdist(p1, p2));\n};\nvar sqdist = function sqdist(p1, p2) {\n    var dx = p2.x - p1.x;\n    var dy = p2.y - p1.y;\n    return dx * dx + dy * dy;\n};\nvar inPlaceSumNormalize = function inPlaceSumNormalize(v) {\n    var length = v.length;\n    // First, get sum of all elements\n    var total = 0;\n    for(var i = 0; i < length; i++){\n        total += v[i];\n    }\n    // Now, divide each by the sum of all elements\n    for(var _i = 0; _i < length; _i++){\n        v[_i] = v[_i] / total;\n    }\n    return v;\n};\n// from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves\nvar qbezierAt = function qbezierAt(p0, p1, p2, t) {\n    return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;\n};\nvar qbezierPtAt = function qbezierPtAt(p0, p1, p2, t) {\n    return {\n        x: qbezierAt(p0.x, p1.x, p2.x, t),\n        y: qbezierAt(p0.y, p1.y, p2.y, t)\n    };\n};\nvar lineAt = function lineAt(p0, p1, t, d) {\n    var vec = {\n        x: p1.x - p0.x,\n        y: p1.y - p0.y\n    };\n    var vecDist = dist(p0, p1);\n    var normVec = {\n        x: vec.x / vecDist,\n        y: vec.y / vecDist\n    };\n    t = t == null ? 0 : t;\n    d = d != null ? d : t * vecDist;\n    return {\n        x: p0.x + normVec.x * d,\n        y: p0.y + normVec.y * d\n    };\n};\nvar bound = function bound(min, val, max) {\n    return Math.max(min, Math.min(max, val));\n};\n// makes a full bb (x1, y1, x2, y2, w, h) from implicit params\nvar makeBoundingBox = function makeBoundingBox(bb) {\n    if (bb == null) {\n        return {\n            x1: Infinity,\n            y1: Infinity,\n            x2: -Infinity,\n            y2: -Infinity,\n            w: 0,\n            h: 0\n        };\n    } else if (bb.x1 != null && bb.y1 != null) {\n        if (bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1) {\n            return {\n                x1: bb.x1,\n                y1: bb.y1,\n                x2: bb.x2,\n                y2: bb.y2,\n                w: bb.x2 - bb.x1,\n                h: bb.y2 - bb.y1\n            };\n        } else if (bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0) {\n            return {\n                x1: bb.x1,\n                y1: bb.y1,\n                x2: bb.x1 + bb.w,\n                y2: bb.y1 + bb.h,\n                w: bb.w,\n                h: bb.h\n            };\n        }\n    }\n};\nvar copyBoundingBox = function copyBoundingBox(bb) {\n    return {\n        x1: bb.x1,\n        x2: bb.x2,\n        w: bb.w,\n        y1: bb.y1,\n        y2: bb.y2,\n        h: bb.h\n    };\n};\nvar clearBoundingBox = function clearBoundingBox(bb) {\n    bb.x1 = Infinity;\n    bb.y1 = Infinity;\n    bb.x2 = -Infinity;\n    bb.y2 = -Infinity;\n    bb.w = 0;\n    bb.h = 0;\n};\nvar updateBoundingBox = function updateBoundingBox(bb1, bb2) {\n    // update bb1 with bb2 bounds\n    bb1.x1 = Math.min(bb1.x1, bb2.x1);\n    bb1.x2 = Math.max(bb1.x2, bb2.x2);\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.y1 = Math.min(bb1.y1, bb2.y1);\n    bb1.y2 = Math.max(bb1.y2, bb2.y2);\n    bb1.h = bb1.y2 - bb1.y1;\n};\nvar expandBoundingBoxByPoint = function expandBoundingBoxByPoint(bb, x, y) {\n    bb.x1 = Math.min(bb.x1, x);\n    bb.x2 = Math.max(bb.x2, x);\n    bb.w = bb.x2 - bb.x1;\n    bb.y1 = Math.min(bb.y1, y);\n    bb.y2 = Math.max(bb.y2, y);\n    bb.h = bb.y2 - bb.y1;\n};\nvar expandBoundingBox = function expandBoundingBox(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    bb.x1 -= padding;\n    bb.x2 += padding;\n    bb.y1 -= padding;\n    bb.y2 += padding;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n};\nvar expandBoundingBoxSides = function expandBoundingBoxSides(bb) {\n    var padding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\n        0\n    ];\n    var top, right, bottom, left;\n    if (padding.length === 1) {\n        top = right = bottom = left = padding[0];\n    } else if (padding.length === 2) {\n        top = bottom = padding[0];\n        left = right = padding[1];\n    } else if (padding.length === 4) {\n        var _padding = _slicedToArray(padding, 4);\n        top = _padding[0];\n        right = _padding[1];\n        bottom = _padding[2];\n        left = _padding[3];\n    }\n    bb.x1 -= left;\n    bb.x2 += right;\n    bb.y1 -= top;\n    bb.y2 += bottom;\n    bb.w = bb.x2 - bb.x1;\n    bb.h = bb.y2 - bb.y1;\n    return bb;\n};\n// assign the values of bb2 into bb1\nvar assignBoundingBox = function assignBoundingBox(bb1, bb2) {\n    bb1.x1 = bb2.x1;\n    bb1.y1 = bb2.y1;\n    bb1.x2 = bb2.x2;\n    bb1.y2 = bb2.y2;\n    bb1.w = bb1.x2 - bb1.x1;\n    bb1.h = bb1.y2 - bb1.y1;\n};\nvar boundingBoxesIntersect = function boundingBoxesIntersect(bb1, bb2) {\n    // case: one bb to right of other\n    if (bb1.x1 > bb2.x2) {\n        return false;\n    }\n    if (bb2.x1 > bb1.x2) {\n        return false;\n    }\n    // case: one bb to left of other\n    if (bb1.x2 < bb2.x1) {\n        return false;\n    }\n    if (bb2.x2 < bb1.x1) {\n        return false;\n    }\n    // case: one bb above other\n    if (bb1.y2 < bb2.y1) {\n        return false;\n    }\n    if (bb2.y2 < bb1.y1) {\n        return false;\n    }\n    // case: one bb below other\n    if (bb1.y1 > bb2.y2) {\n        return false;\n    }\n    if (bb2.y1 > bb1.y2) {\n        return false;\n    }\n    // otherwise, must have some overlap\n    return true;\n};\nvar inBoundingBox = function inBoundingBox(bb, x, y) {\n    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;\n};\nvar pointInBoundingBox = function pointInBoundingBox(bb, pt) {\n    return inBoundingBox(bb, pt.x, pt.y);\n};\nvar boundingBoxInBoundingBox = function boundingBoxInBoundingBox(bb1, bb2) {\n    return inBoundingBox(bb1, bb2.x1, bb2.y1) && inBoundingBox(bb1, bb2.x2, bb2.y2);\n};\nvar hypot = (_Math$hypot = Math.hypot) !== null && _Math$hypot !== undefined ? _Math$hypot : function(x, y) {\n    return Math.sqrt(x * x + y * y);\n};\nfunction inflatePolygon(polygon, d) {\n    if (polygon.length < 3) {\n        throw new Error('Need at least 3 vertices');\n    }\n    // Helpers\n    var add = function add(a, b) {\n        return {\n            x: a.x + b.x,\n            y: a.y + b.y\n        };\n    };\n    var sub = function sub(a, b) {\n        return {\n            x: a.x - b.x,\n            y: a.y - b.y\n        };\n    };\n    var scale = function scale(v, s) {\n        return {\n            x: v.x * s,\n            y: v.y * s\n        };\n    };\n    var cross = function cross(u, v) {\n        return u.x * v.y - u.y * v.x;\n    };\n    var normalize = function normalize(v) {\n        var len = hypot(v.x, v.y);\n        return len === 0 ? {\n            x: 0,\n            y: 0\n        } : {\n            x: v.x / len,\n            y: v.y / len\n        };\n    };\n    // Signed area (positive = CCW)\n    var signedArea = function signedArea(pts) {\n        var A = 0;\n        for(var i = 0; i < pts.length; i++){\n            var p = pts[i], q = pts[(i + 1) % pts.length];\n            A += p.x * q.y - q.x * p.y;\n        }\n        return A / 2;\n    };\n    // Line–line intersection (infinite lines)\n    var intersectLines = function intersectLines(p1, p2, p3, p4) {\n        var r = sub(p2, p1);\n        var s = sub(p4, p3);\n        var denom = cross(r, s);\n        if (Math.abs(denom) < 1e-9) {\n            // Parallel or nearly so — fallback to midpoint\n            return add(p1, scale(r, 0.5));\n        }\n        var t = cross(sub(p3, p1), s) / denom;\n        return add(p1, scale(r, t));\n    };\n    // Make a shallow copy and enforce CCW\n    var pts = polygon.map(function(p) {\n        return {\n            x: p.x,\n            y: p.y\n        };\n    });\n    if (signedArea(pts) < 0) pts.reverse();\n    var n = pts.length;\n    // Compute outward normals for each edge\n    var normals = [];\n    for(var i = 0; i < n; i++){\n        var p = pts[i], q = pts[(i + 1) % n];\n        var edge = sub(q, p);\n        // For CCW polygon, inward normal = (-edge.y, edge.x)\n        // so outward normal = (edge.y, -edge.x)\n        var out = normalize({\n            x: edge.y,\n            y: -edge.x\n        });\n        normals.push(out);\n    }\n    // Build offset edges\n    var offsetEdges = normals.map(function(nrm, i) {\n        var p1 = add(pts[i], scale(nrm, d));\n        var p2 = add(pts[(i + 1) % n], scale(nrm, d));\n        return {\n            p1: p1,\n            p2: p2\n        };\n    });\n    // Intersect consecutive offset edges\n    var inflated = [];\n    for(var _i2 = 0; _i2 < n; _i2++){\n        var prevEdge = offsetEdges[(_i2 - 1 + n) % n];\n        var currEdge = offsetEdges[_i2];\n        var ip = intersectLines(prevEdge.p1, prevEdge.p2, currEdge.p1, currEdge.p2);\n        inflated.push(ip);\n    }\n    return inflated;\n}\nfunction miterBox(pts, centerX, centerY, width, height, strokeWidth) {\n    var tpts = transformPoints(pts, centerX, centerY, width, height);\n    var offsetPoints = inflatePolygon(tpts, strokeWidth);\n    var bb = makeBoundingBox();\n    offsetPoints.forEach(function(pt) {\n        return expandBoundingBoxByPoint(bb, pt.x, pt.y);\n    });\n    return bb;\n}\nvar roundRectangleIntersectLine = function roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding) {\n    var radius = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'auto';\n    var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : radius;\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    cornerRadius = Math.min(cornerRadius, halfWidth, halfHeight);\n    var doWidth = cornerRadius !== halfWidth, doHeight = cornerRadius !== halfHeight;\n    // Check intersections with straight line segments\n    var straightLineIntersections;\n    // Top segment, left to right\n    if (doWidth) {\n        var topStartX = nodeX - halfWidth + cornerRadius - padding;\n        var topStartY = nodeY - halfHeight - padding;\n        var topEndX = nodeX + halfWidth - cornerRadius + padding;\n        var topEndY = topStartY;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Right segment, top to bottom\n    if (doHeight) {\n        var rightStartX = nodeX + halfWidth + padding;\n        var rightStartY = nodeY - halfHeight + cornerRadius - padding;\n        var rightEndX = rightStartX;\n        var rightEndY = nodeY + halfHeight - cornerRadius + padding;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Bottom segment, left to right\n    if (doWidth) {\n        var bottomStartX = nodeX - halfWidth + cornerRadius - padding;\n        var bottomStartY = nodeY + halfHeight + padding;\n        var bottomEndX = nodeX + halfWidth - cornerRadius + padding;\n        var bottomEndY = bottomStartY;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Left segment, top to bottom\n    if (doHeight) {\n        var leftStartX = nodeX - halfWidth - padding;\n        var leftStartY = nodeY - halfHeight + cornerRadius - padding;\n        var leftEndX = leftStartX;\n        var leftEndY = nodeY + halfHeight - cornerRadius + padding;\n        straightLineIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);\n        if (straightLineIntersections.length > 0) {\n            return straightLineIntersections;\n        }\n    }\n    // Check intersections with arc segments\n    var arcIntersections;\n    // Top Left\n    {\n        var topLeftCenterX = nodeX - halfWidth + cornerRadius;\n        var topLeftCenterY = nodeY - halfHeight + cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topLeftCenterX, topLeftCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] <= topLeftCenterX && arcIntersections[1] <= topLeftCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    // Top Right\n    {\n        var topRightCenterX = nodeX + halfWidth - cornerRadius;\n        var topRightCenterY = nodeY - halfHeight + cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, topRightCenterX, topRightCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] >= topRightCenterX && arcIntersections[1] <= topRightCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    // Bottom Right\n    {\n        var bottomRightCenterX = nodeX + halfWidth - cornerRadius;\n        var bottomRightCenterY = nodeY + halfHeight - cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] >= bottomRightCenterX && arcIntersections[1] >= bottomRightCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    // Bottom Left\n    {\n        var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;\n        var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;\n        arcIntersections = intersectLineCircle(x, y, nodeX, nodeY, bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);\n        // Ensure the intersection is on the desired quarter of the circle\n        if (arcIntersections.length > 0 && arcIntersections[0] <= bottomLeftCenterX && arcIntersections[1] >= bottomLeftCenterY) {\n            return [\n                arcIntersections[0],\n                arcIntersections[1]\n            ];\n        }\n    }\n    return []; // if nothing\n};\nvar inLineVicinity = function inLineVicinity(x, y, lx1, ly1, lx2, ly2, tolerance) {\n    var t = tolerance;\n    var x1 = Math.min(lx1, lx2);\n    var x2 = Math.max(lx1, lx2);\n    var y1 = Math.min(ly1, ly2);\n    var y2 = Math.max(ly1, ly2);\n    return x1 - t <= x && x <= x2 + t && y1 - t <= y && y <= y2 + t;\n};\nvar inBezierVicinity = function inBezierVicinity(x, y, x1, y1, x2, y2, x3, y3, tolerance) {\n    var bb = {\n        x1: Math.min(x1, x3, x2) - tolerance,\n        x2: Math.max(x1, x3, x2) + tolerance,\n        y1: Math.min(y1, y3, y2) - tolerance,\n        y2: Math.max(y1, y3, y2) + tolerance\n    };\n    // if outside the rough bounding box for the bezier, then it can't be a hit\n    if (x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2) {\n        // console.log('bezier out of rough bb')\n        return false;\n    } else {\n        // console.log('do more expensive check');\n        return true;\n    }\n};\nvar solveQuadratic = function solveQuadratic(a, b, c, val) {\n    c -= val;\n    var r = b * b - 4 * a * c;\n    if (r < 0) {\n        return [];\n    }\n    var sqrtR = Math.sqrt(r);\n    var denom = 2 * a;\n    var root1 = (-b + sqrtR) / denom;\n    var root2 = (-b - sqrtR) / denom;\n    return [\n        root1,\n        root2\n    ];\n};\nvar solveCubic = function solveCubic(a, b, c, d, result) {\n    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where\n    // r is the real component, i is the imaginary component\n    // An implementation of the Cardano method from the year 1545\n    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots\n    var epsilon = 0.00001;\n    // avoid division by zero while keeping the overall expression close in value\n    if (a === 0) {\n        a = epsilon;\n    }\n    b /= a;\n    c /= a;\n    d /= a;\n    var discriminant, q, r, dum1, s, t, term1, r13;\n    q = (3.0 * c - b * b) / 9.0;\n    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));\n    r /= 54.0;\n    discriminant = q * q * q + r * r;\n    result[1] = 0;\n    term1 = b / 3.0;\n    if (discriminant > 0) {\n        s = r + Math.sqrt(discriminant);\n        s = s < 0 ? -Math.pow(-s, 1.0 / 3.0) : Math.pow(s, 1.0 / 3.0);\n        t = r - Math.sqrt(discriminant);\n        t = t < 0 ? -Math.pow(-t, 1.0 / 3.0) : Math.pow(t, 1.0 / 3.0);\n        result[0] = -term1 + s + t;\n        term1 += (s + t) / 2.0;\n        result[4] = result[2] = -term1;\n        term1 = Math.sqrt(3.0) * (-t + s) / 2;\n        result[3] = term1;\n        result[5] = -term1;\n        return;\n    }\n    result[5] = result[3] = 0;\n    if (discriminant === 0) {\n        r13 = r < 0 ? -Math.pow(-r, 1.0 / 3.0) : Math.pow(r, 1.0 / 3.0);\n        result[0] = -term1 + 2.0 * r13;\n        result[4] = result[2] = -(r13 + term1);\n        return;\n    }\n    q = -q;\n    dum1 = q * q * q;\n    dum1 = Math.acos(r / Math.sqrt(dum1));\n    r13 = 2.0 * Math.sqrt(q);\n    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);\n    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);\n    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);\n    return;\n};\nvar sqdistToQuadraticBezier = function sqdistToQuadraticBezier(x, y, x1, y1, x2, y2, x3, y3) {\n    // Find minimum distance by using the minimum of the distance\n    // function between the given point and the curve\n    // This gives the coefficients of the resulting cubic equation\n    // whose roots tell us where a possible minimum is\n    // (Coefficients are divided by 4)\n    var a = 1.0 * x1 * x1 - 4 * x1 * x2 + 2 * x1 * x3 + 4 * x2 * x2 - 4 * x2 * x3 + x3 * x3 + y1 * y1 - 4 * y1 * y2 + 2 * y1 * y3 + 4 * y2 * y2 - 4 * y2 * y3 + y3 * y3;\n    var b = 1.0 * 9 * x1 * x2 - 3 * x1 * x1 - 3 * x1 * x3 - 6 * x2 * x2 + 3 * x2 * x3 + 9 * y1 * y2 - 3 * y1 * y1 - 3 * y1 * y3 - 6 * y2 * y2 + 3 * y2 * y3;\n    var c = 1.0 * 3 * x1 * x1 - 6 * x1 * x2 + x1 * x3 - x1 * x + 2 * x2 * x2 + 2 * x2 * x - x3 * x + 3 * y1 * y1 - 6 * y1 * y2 + y1 * y3 - y1 * y + 2 * y2 * y2 + 2 * y2 * y - y3 * y;\n    var d = 1.0 * x1 * x2 - x1 * x1 + x1 * x - x2 * x + y1 * y2 - y1 * y1 + y1 * y - y2 * y;\n    // debug(\"coefficients: \" + a / a + \", \" + b / a + \", \" + c / a + \", \" + d / a);\n    var roots = [];\n    // Use the cubic solving algorithm\n    solveCubic(a, b, c, d, roots);\n    var zeroThreshold = 0.0000001;\n    var params = [];\n    for(var index = 0; index < 6; index += 2){\n        if (Math.abs(roots[index + 1]) < zeroThreshold && roots[index] >= 0 && roots[index] <= 1.0) {\n            params.push(roots[index]);\n        }\n    }\n    params.push(1.0);\n    params.push(0.0);\n    var minDistanceSquared = -1;\n    var curX, curY, distSquared;\n    for(var i = 0; i < params.length; i++){\n        curX = Math.pow(1.0 - params[i], 2.0) * x1 + 2.0 * (1 - params[i]) * params[i] * x2 + params[i] * params[i] * x3;\n        curY = Math.pow(1 - params[i], 2.0) * y1 + 2 * (1.0 - params[i]) * params[i] * y2 + params[i] * params[i] * y3;\n        distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);\n        // debug('distance for param ' + params[i] + \": \" + Math.sqrt(distSquared));\n        if (minDistanceSquared >= 0) {\n            if (distSquared < minDistanceSquared) {\n                minDistanceSquared = distSquared;\n            }\n        } else {\n            minDistanceSquared = distSquared;\n        }\n    }\n    return minDistanceSquared;\n};\nvar sqdistToFiniteLine = function sqdistToFiniteLine(x, y, x1, y1, x2, y2) {\n    var offset = [\n        x - x1,\n        y - y1\n    ];\n    var line = [\n        x2 - x1,\n        y2 - y1\n    ];\n    var lineSq = line[0] * line[0] + line[1] * line[1];\n    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];\n    var dotProduct = offset[0] * line[0] + offset[1] * line[1];\n    var adjSq = dotProduct * dotProduct / lineSq;\n    if (dotProduct < 0) {\n        return hypSq;\n    }\n    if (adjSq > lineSq) {\n        return (x - x2) * (x - x2) + (y - y2) * (y - y2);\n    }\n    return hypSq - adjSq;\n};\nvar pointInsidePolygonPoints = function pointInsidePolygonPoints(x, y, points) {\n    var x1, y1, x2, y2;\n    var y3;\n    // Intersect with vertical line through (x, y)\n    var up = 0;\n    // let down = 0;\n    for(var i = 0; i < points.length / 2; i++){\n        x1 = points[i * 2];\n        y1 = points[i * 2 + 1];\n        if (i + 1 < points.length / 2) {\n            x2 = points[(i + 1) * 2];\n            y2 = points[(i + 1) * 2 + 1];\n        } else {\n            x2 = points[(i + 1 - points.length / 2) * 2];\n            y2 = points[(i + 1 - points.length / 2) * 2 + 1];\n        }\n        if (x1 == x && x2 == x) ;\n        else if (x1 >= x && x >= x2 || x1 <= x && x <= x2) {\n            y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;\n            if (y3 > y) {\n                up++;\n            }\n        // if( y3 < y ){\n        // down++;\n        // }\n        } else {\n            continue;\n        }\n    }\n    if (up % 2 === 0) {\n        return false;\n    } else {\n        return true;\n    }\n};\nvar pointInsidePolygon = function pointInsidePolygon(x, y, basePoints, centerX, centerY, width, height, direction, padding) {\n    var transformedPoints = new Array(basePoints.length);\n    // Gives negative angle\n    var angle;\n    if (direction[0] != null) {\n        angle = Math.atan(direction[1] / direction[0]);\n        if (direction[0] < 0) {\n            angle = angle + Math.PI / 2;\n        } else {\n            angle = -angle - Math.PI / 2;\n        }\n    } else {\n        angle = direction;\n    }\n    var cos = Math.cos(-angle);\n    var sin = Math.sin(-angle);\n    //    console.log(\"base: \" + basePoints);\n    for(var i = 0; i < transformedPoints.length / 2; i++){\n        transformedPoints[i * 2] = width / 2 * (basePoints[i * 2] * cos - basePoints[i * 2 + 1] * sin);\n        transformedPoints[i * 2 + 1] = height / 2 * (basePoints[i * 2 + 1] * cos + basePoints[i * 2] * sin);\n        transformedPoints[i * 2] += centerX;\n        transformedPoints[i * 2 + 1] += centerY;\n    }\n    var points;\n    if (padding > 0) {\n        var expandedLineSet = expandPolygon(transformedPoints, -padding);\n        points = joinLines(expandedLineSet);\n    } else {\n        points = transformedPoints;\n    }\n    return pointInsidePolygonPoints(x, y, points);\n};\nvar pointInsideRoundPolygon = function pointInsideRoundPolygon(x, y, basePoints, centerX, centerY, width, height, corners) {\n    var cutPolygonPoints = new Array(basePoints.length * 2);\n    for(var i = 0; i < corners.length; i++){\n        var corner = corners[i];\n        cutPolygonPoints[i * 4 + 0] = corner.startX;\n        cutPolygonPoints[i * 4 + 1] = corner.startY;\n        cutPolygonPoints[i * 4 + 2] = corner.stopX;\n        cutPolygonPoints[i * 4 + 3] = corner.stopY;\n        var squaredDistance = Math.pow(corner.cx - x, 2) + Math.pow(corner.cy - y, 2);\n        if (squaredDistance <= Math.pow(corner.radius, 2)) {\n            return true;\n        }\n    }\n    return pointInsidePolygonPoints(x, y, cutPolygonPoints);\n};\nvar joinLines = function joinLines(lineSet) {\n    var vertices = new Array(lineSet.length / 2);\n    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;\n    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;\n    for(var i = 0; i < lineSet.length / 4; i++){\n        currentLineStartX = lineSet[i * 4];\n        currentLineStartY = lineSet[i * 4 + 1];\n        currentLineEndX = lineSet[i * 4 + 2];\n        currentLineEndY = lineSet[i * 4 + 3];\n        if (i < lineSet.length / 4 - 1) {\n            nextLineStartX = lineSet[(i + 1) * 4];\n            nextLineStartY = lineSet[(i + 1) * 4 + 1];\n            nextLineEndX = lineSet[(i + 1) * 4 + 2];\n            nextLineEndY = lineSet[(i + 1) * 4 + 3];\n        } else {\n            nextLineStartX = lineSet[0];\n            nextLineStartY = lineSet[1];\n            nextLineEndX = lineSet[2];\n            nextLineEndY = lineSet[3];\n        }\n        var intersection = finiteLinesIntersect(currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY, nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY, true);\n        vertices[i * 2] = intersection[0];\n        vertices[i * 2 + 1] = intersection[1];\n    }\n    return vertices;\n};\nvar expandPolygon = function expandPolygon(points, pad) {\n    var expandedLineSet = new Array(points.length * 2);\n    var currentPointX, currentPointY, nextPointX, nextPointY;\n    for(var i = 0; i < points.length / 2; i++){\n        currentPointX = points[i * 2];\n        currentPointY = points[i * 2 + 1];\n        if (i < points.length / 2 - 1) {\n            nextPointX = points[(i + 1) * 2];\n            nextPointY = points[(i + 1) * 2 + 1];\n        } else {\n            nextPointX = points[0];\n            nextPointY = points[1];\n        }\n        // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]\n        // Assume CCW polygon winding\n        var offsetX = nextPointY - currentPointY;\n        var offsetY = -(nextPointX - currentPointX);\n        // Normalize\n        var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n        var normalizedOffsetX = offsetX / offsetLength;\n        var normalizedOffsetY = offsetY / offsetLength;\n        expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;\n        expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;\n        expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;\n        expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;\n    }\n    return expandedLineSet;\n};\nvar intersectLineEllipse = function intersectLineEllipse(x, y, centerX, centerY, ellipseWradius, ellipseHradius) {\n    var dispX = centerX - x;\n    var dispY = centerY - y;\n    dispX /= ellipseWradius;\n    dispY /= ellipseHradius;\n    var len = Math.sqrt(dispX * dispX + dispY * dispY);\n    var newLength = len - 1;\n    if (newLength < 0) {\n        return [];\n    }\n    var lenProportion = newLength / len;\n    return [\n        (centerX - x) * lenProportion + x,\n        (centerY - y) * lenProportion + y\n    ];\n};\nvar checkInEllipse = function checkInEllipse(x, y, width, height, centerX, centerY, padding) {\n    x -= centerX;\n    y -= centerY;\n    x /= width / 2 + padding;\n    y /= height / 2 + padding;\n    return x * x + y * y <= 1;\n};\n// Returns intersections of increasing distance from line's start point\nvar intersectLineCircle = function intersectLineCircle(x1, y1, x2, y2, centerX, centerY, radius) {\n    // Calculate d, direction vector of line\n    var d = [\n        x2 - x1,\n        y2 - y1\n    ]; // Direction vector of line\n    var f = [\n        x1 - centerX,\n        y1 - centerY\n    ];\n    var a = d[0] * d[0] + d[1] * d[1];\n    var b = 2 * (f[0] * d[0] + f[1] * d[1]);\n    var c = f[0] * f[0] + f[1] * f[1] - radius * radius;\n    var discriminant = b * b - 4 * a * c;\n    if (discriminant < 0) {\n        return [];\n    }\n    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);\n    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);\n    var tMin = Math.min(t1, t2);\n    var tMax = Math.max(t1, t2);\n    var inRangeParams = [];\n    if (tMin >= 0 && tMin <= 1) {\n        inRangeParams.push(tMin);\n    }\n    if (tMax >= 0 && tMax <= 1) {\n        inRangeParams.push(tMax);\n    }\n    if (inRangeParams.length === 0) {\n        return [];\n    }\n    var nearIntersectionX = inRangeParams[0] * d[0] + x1;\n    var nearIntersectionY = inRangeParams[0] * d[1] + y1;\n    if (inRangeParams.length > 1) {\n        if (inRangeParams[0] == inRangeParams[1]) {\n            return [\n                nearIntersectionX,\n                nearIntersectionY\n            ];\n        } else {\n            var farIntersectionX = inRangeParams[1] * d[0] + x1;\n            var farIntersectionY = inRangeParams[1] * d[1] + y1;\n            return [\n                nearIntersectionX,\n                nearIntersectionY,\n                farIntersectionX,\n                farIntersectionY\n            ];\n        }\n    } else {\n        return [\n            nearIntersectionX,\n            nearIntersectionY\n        ];\n    }\n};\nvar midOfThree = function midOfThree(a, b, c) {\n    if (b <= a && a <= c || c <= a && a <= b) {\n        return a;\n    } else if (a <= b && b <= c || c <= b && b <= a) {\n        return b;\n    } else {\n        return c;\n    }\n};\n// (x1,y1)=>(x2,y2) intersect with (x3,y3)=>(x4,y4)\nvar finiteLinesIntersect = function finiteLinesIntersect(x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {\n    var dx13 = x1 - x3;\n    var dx21 = x2 - x1;\n    var dx43 = x4 - x3;\n    var dy13 = y1 - y3;\n    var dy21 = y2 - y1;\n    var dy43 = y4 - y3;\n    var ua_t = dx43 * dy13 - dy43 * dx13;\n    var ub_t = dx21 * dy13 - dy21 * dx13;\n    var u_b = dy43 * dx21 - dx43 * dy21;\n    if (u_b !== 0) {\n        var ua = ua_t / u_b;\n        var ub = ub_t / u_b;\n        var flptThreshold = 0.001;\n        var _min = 0 - flptThreshold;\n        var _max = 1 + flptThreshold;\n        if (_min <= ua && ua <= _max && _min <= ub && ub <= _max) {\n            return [\n                x1 + ua * dx21,\n                y1 + ua * dy21\n            ];\n        } else {\n            if (!infiniteLines) {\n                return [];\n            } else {\n                return [\n                    x1 + ua * dx21,\n                    y1 + ua * dy21\n                ];\n            }\n        }\n    } else {\n        if (ua_t === 0 || ub_t === 0) {\n            // Parallel, coincident lines. Check if overlap\n            // Check endpoint of second line\n            if (midOfThree(x1, x2, x4) === x4) {\n                return [\n                    x4,\n                    y4\n                ];\n            }\n            // Check start point of second line\n            if (midOfThree(x1, x2, x3) === x3) {\n                return [\n                    x3,\n                    y3\n                ];\n            }\n            // Endpoint of first line\n            if (midOfThree(x3, x4, x2) === x2) {\n                return [\n                    x2,\n                    y2\n                ];\n            }\n            return [];\n        } else {\n            // Parallel, non-coincident\n            return [];\n        }\n    }\n};\nvar transformPoints = function transformPoints(points, centerX, centerY, width, height) {\n    var ret = [];\n    var halfW = width / 2;\n    var halfH = height / 2;\n    var x = centerX;\n    var y = centerY;\n    ret.push({\n        x: x + halfW * points[0],\n        y: y + halfH * points[1]\n    });\n    for(var i = 1; i < points.length / 2; i++){\n        ret.push({\n            x: x + halfW * points[i * 2],\n            y: y + halfH * points[i * 2 + 1]\n        });\n    }\n    return ret;\n};\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY, width, height, padding )\n// intersect a node polygon (pts transformed)\n//\n// math.polygonIntersectLine( x, y, basePoints, centerX, centerY )\n// intersect the points (no transform)\nvar polygonIntersectLine = function polygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding) {\n    var intersections = [];\n    var intersection;\n    var transformedPoints = new Array(basePoints.length);\n    var doTransform = true;\n    if (width == null) {\n        doTransform = false;\n    }\n    var points;\n    if (doTransform) {\n        for(var i = 0; i < transformedPoints.length / 2; i++){\n            transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;\n            transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;\n        }\n        if (padding > 0) {\n            var expandedLineSet = expandPolygon(transformedPoints, -padding);\n            points = joinLines(expandedLineSet);\n        } else {\n            points = transformedPoints;\n        }\n    } else {\n        points = basePoints;\n    }\n    var currentX, currentY, nextX, nextY;\n    for(var _i3 = 0; _i3 < points.length / 2; _i3++){\n        currentX = points[_i3 * 2];\n        currentY = points[_i3 * 2 + 1];\n        if (_i3 < points.length / 2 - 1) {\n            nextX = points[(_i3 + 1) * 2];\n            nextY = points[(_i3 + 1) * 2 + 1];\n        } else {\n            nextX = points[0];\n            nextY = points[1];\n        }\n        intersection = finiteLinesIntersect(x, y, centerX, centerY, currentX, currentY, nextX, nextY);\n        if (intersection.length !== 0) {\n            intersections.push(intersection[0], intersection[1]);\n        }\n    }\n    return intersections;\n};\nvar roundPolygonIntersectLine = function roundPolygonIntersectLine(x, y, basePoints, centerX, centerY, width, height, padding, corners) {\n    var intersections = [];\n    var intersection;\n    var lines = new Array(basePoints.length * 2);\n    corners.forEach(function(corner, i) {\n        if (i === 0) {\n            lines[lines.length - 2] = corner.startX;\n            lines[lines.length - 1] = corner.startY;\n        } else {\n            lines[i * 4 - 2] = corner.startX;\n            lines[i * 4 - 1] = corner.startY;\n        }\n        lines[i * 4] = corner.stopX;\n        lines[i * 4 + 1] = corner.stopY;\n        intersection = intersectLineCircle(x, y, centerX, centerY, corner.cx, corner.cy, corner.radius);\n        if (intersection.length !== 0) {\n            intersections.push(intersection[0], intersection[1]);\n        }\n    });\n    for(var i = 0; i < lines.length / 4; i++){\n        intersection = finiteLinesIntersect(x, y, centerX, centerY, lines[i * 4], lines[i * 4 + 1], lines[i * 4 + 2], lines[i * 4 + 3], false);\n        if (intersection.length !== 0) {\n            intersections.push(intersection[0], intersection[1]);\n        }\n    }\n    if (intersections.length > 2) {\n        var lowestIntersection = [\n            intersections[0],\n            intersections[1]\n        ];\n        var lowestSquaredDistance = Math.pow(lowestIntersection[0] - x, 2) + Math.pow(lowestIntersection[1] - y, 2);\n        for(var _i4 = 1; _i4 < intersections.length / 2; _i4++){\n            var squaredDistance = Math.pow(intersections[_i4 * 2] - x, 2) + Math.pow(intersections[_i4 * 2 + 1] - y, 2);\n            if (squaredDistance <= lowestSquaredDistance) {\n                lowestIntersection[0] = intersections[_i4 * 2];\n                lowestIntersection[1] = intersections[_i4 * 2 + 1];\n                lowestSquaredDistance = squaredDistance;\n            }\n        }\n        return lowestIntersection;\n    }\n    return intersections;\n};\nvar shortenIntersection = function shortenIntersection(intersection, offset, amount) {\n    var disp = [\n        intersection[0] - offset[0],\n        intersection[1] - offset[1]\n    ];\n    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);\n    var lenRatio = (length - amount) / length;\n    if (lenRatio < 0) {\n        lenRatio = 0.00001;\n    }\n    return [\n        offset[0] + lenRatio * disp[0],\n        offset[1] + lenRatio * disp[1]\n    ];\n};\nvar generateUnitNgonPointsFitToSquare = function generateUnitNgonPointsFitToSquare(sides, rotationRadians) {\n    var points = generateUnitNgonPoints(sides, rotationRadians);\n    points = fitPolygonToSquare(points);\n    return points;\n};\nvar fitPolygonToSquare = function fitPolygonToSquare(points) {\n    var x, y;\n    var sides = points.length / 2;\n    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    for(var i = 0; i < sides; i++){\n        x = points[2 * i];\n        y = points[2 * i + 1];\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n    // stretch factors\n    var sx = 2 / (maxX - minX);\n    var sy = 2 / (maxY - minY);\n    for(var _i5 = 0; _i5 < sides; _i5++){\n        x = points[2 * _i5] = points[2 * _i5] * sx;\n        y = points[2 * _i5 + 1] = points[2 * _i5 + 1] * sy;\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n    if (minY < -1) {\n        for(var _i6 = 0; _i6 < sides; _i6++){\n            y = points[2 * _i6 + 1] = points[2 * _i6 + 1] + (-1 - minY);\n        }\n    }\n    return points;\n};\nvar generateUnitNgonPoints = function generateUnitNgonPoints(sides, rotationRadians) {\n    var increment = 1.0 / sides * 2 * Math.PI;\n    var startAngle = sides % 2 === 0 ? Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;\n    startAngle += rotationRadians;\n    var points = new Array(sides * 2);\n    var currentAngle;\n    for(var i = 0; i < sides; i++){\n        currentAngle = i * increment + startAngle;\n        points[2 * i] = Math.cos(currentAngle); // x\n        points[2 * i + 1] = Math.sin(-currentAngle); // y\n    }\n    return points;\n};\n// Set the default radius, unless half of width or height is smaller than default\nvar getRoundRectangleRadius = function getRoundRectangleRadius(width, height) {\n    return Math.min(width / 4, height / 4, 8);\n};\n// Set the default radius\nvar getRoundPolygonRadius = function getRoundPolygonRadius(width, height) {\n    return Math.min(width / 10, height / 10, 8);\n};\nvar getCutRectangleCornerLength = function getCutRectangleCornerLength() {\n    return 8;\n};\nvar bezierPtsToQuadCoeff = function bezierPtsToQuadCoeff(p0, p1, p2) {\n    return [\n        p0 - 2 * p1 + p2,\n        2 * (p1 - p0),\n        p0\n    ];\n};\n// get curve width, height, and control point position offsets as a percentage of node height / width\nvar getBarrelCurveConstants = function getBarrelCurveConstants(width, height) {\n    return {\n        heightOffset: Math.min(15, 0.05 * height),\n        widthOffset: Math.min(100, 0.25 * width),\n        ctrlPtOffsetPct: 0.05\n    };\n};\n// Separating Axis Theorem (SAT) to determine if two polygons intersect. \n// The function takes two polygons as input and returns a boolean value indicating \n// whether the two polygons intersect.\nfunction satPolygonIntersection(poly1, poly2) {\n    function getAxes(polygon) {\n        var axes = [];\n        for(var i = 0; i < polygon.length; i++){\n            var p1 = polygon[i];\n            var p2 = polygon[(i + 1) % polygon.length];\n            var edge = {\n                x: p2.x - p1.x,\n                y: p2.y - p1.y\n            };\n            var normal = {\n                x: -edge.y,\n                y: edge.x\n            };\n            var length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);\n            axes.push({\n                x: normal.x / length,\n                y: normal.y / length\n            });\n        }\n        return axes;\n    }\n    function project(polygon, axis) {\n        var min = Infinity;\n        var max = -Infinity;\n        var _iterator = _createForOfIteratorHelper(polygon), _step;\n        try {\n            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                var point = _step.value;\n                var projection = point.x * axis.x + point.y * axis.y;\n                min = Math.min(min, projection);\n                max = Math.max(max, projection);\n            }\n        } catch (err) {\n            _iterator.e(err);\n        } finally{\n            _iterator.f();\n        }\n        return {\n            min: min,\n            max: max\n        };\n    }\n    function overlaps(proj1, proj2) {\n        return !(proj1.max < proj2.min || proj2.max < proj1.min);\n    }\n    var axes = [].concat(_toConsumableArray(getAxes(poly1)), _toConsumableArray(getAxes(poly2)));\n    var _iterator2 = _createForOfIteratorHelper(axes), _step2;\n    try {\n        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n            var axis = _step2.value;\n            var proj1 = project(poly1, axis);\n            var proj2 = project(poly2, axis);\n            if (!overlaps(proj1, proj2)) {\n                return false; // No overlap, so the polygons do not intersect\n            }\n        }\n    } catch (err) {\n        _iterator2.e(err);\n    } finally{\n        _iterator2.f();\n    }\n    return true; // polygons intersect\n}\nvar pageRankDefaults = defaults$g({\n    dampingFactor: 0.8,\n    precision: 0.000001,\n    iterations: 200,\n    weight: function weight(edge) {\n        return 1;\n    }\n});\nvar elesfn$o = {\n    pageRank: function pageRank(options) {\n        var _pageRankDefaults = pageRankDefaults(options), dampingFactor = _pageRankDefaults.dampingFactor, precision = _pageRankDefaults.precision, iterations = _pageRankDefaults.iterations, weight = _pageRankDefaults.weight;\n        var cy = this._private.cy;\n        var _this$byGroup = this.byGroup(), nodes = _this$byGroup.nodes, edges = _this$byGroup.edges;\n        var numNodes = nodes.length;\n        var numNodesSqd = numNodes * numNodes;\n        var numEdges = edges.length;\n        // Construct transposed adjacency matrix\n        // First lets have a zeroed matrix of the right size\n        // We'll also keep track of the sum of each column\n        var matrix = new Array(numNodesSqd);\n        var columnSum = new Array(numNodes);\n        var additionalProb = (1 - dampingFactor) / numNodes;\n        // Create null matrix\n        for(var i = 0; i < numNodes; i++){\n            for(var j = 0; j < numNodes; j++){\n                var n = i * numNodes + j;\n                matrix[n] = 0;\n            }\n            columnSum[i] = 0;\n        }\n        // Now, process edges\n        for(var _i = 0; _i < numEdges; _i++){\n            var edge = edges[_i];\n            var srcId = edge.data('source');\n            var tgtId = edge.data('target');\n            // Don't include loops in the matrix\n            if (srcId === tgtId) {\n                continue;\n            }\n            var s = nodes.indexOfId(srcId);\n            var t = nodes.indexOfId(tgtId);\n            var w = weight(edge);\n            var _n = t * numNodes + s;\n            // Update matrix\n            matrix[_n] += w;\n            // Update column sum\n            columnSum[s] += w;\n        }\n        // Add additional probability based on damping factor\n        // Also, take into account columns that have sum = 0\n        var p = 1.0 / numNodes + additionalProb; // Shorthand\n        // Traverse matrix, column by column\n        for(var _j = 0; _j < numNodes; _j++){\n            if (columnSum[_j] === 0) {\n                // No 'links' out from node jth, assume equal probability for each possible node\n                for(var _i2 = 0; _i2 < numNodes; _i2++){\n                    var _n2 = _i2 * numNodes + _j;\n                    matrix[_n2] = p;\n                }\n            } else {\n                // Node jth has outgoing link, compute normalized probabilities\n                for(var _i3 = 0; _i3 < numNodes; _i3++){\n                    var _n3 = _i3 * numNodes + _j;\n                    matrix[_n3] = matrix[_n3] / columnSum[_j] + additionalProb;\n                }\n            }\n        }\n        // Compute dominant eigenvector using power method\n        var eigenvector = new Array(numNodes);\n        var temp = new Array(numNodes);\n        var previous;\n        // Start with a vector of all 1's\n        // Also, initialize a null vector which will be used as shorthand\n        for(var _i4 = 0; _i4 < numNodes; _i4++){\n            eigenvector[_i4] = 1;\n        }\n        for(var iter = 0; iter < iterations; iter++){\n            // Temp array with all 0's\n            for(var _i5 = 0; _i5 < numNodes; _i5++){\n                temp[_i5] = 0;\n            }\n            // Multiply matrix with previous result\n            for(var _i6 = 0; _i6 < numNodes; _i6++){\n                for(var _j2 = 0; _j2 < numNodes; _j2++){\n                    var _n4 = _i6 * numNodes + _j2;\n                    temp[_i6] += matrix[_n4] * eigenvector[_j2];\n                }\n            }\n            inPlaceSumNormalize(temp);\n            previous = eigenvector;\n            eigenvector = temp;\n            temp = previous;\n            var diff = 0;\n            // Compute difference (squared module) of both vectors\n            for(var _i7 = 0; _i7 < numNodes; _i7++){\n                var delta = previous[_i7] - eigenvector[_i7];\n                diff += delta * delta;\n            }\n            // If difference is less than the desired threshold, stop iterating\n            if (diff < precision) {\n                break;\n            }\n        }\n        // Construct result\n        var res = {\n            rank: function rank(node) {\n                node = cy.collection(node)[0];\n                return eigenvector[nodes.indexOf(node)];\n            }\n        };\n        return res;\n    } // pageRank\n}; // elesfn\nvar defaults$f = defaults$g({\n    root: null,\n    weight: function weight(edge) {\n        return 1;\n    },\n    directed: false,\n    alpha: 0\n});\nvar elesfn$n = {\n    degreeCentralityNormalized: function degreeCentralityNormalized(options) {\n        options = defaults$f(options);\n        var cy = this.cy();\n        var nodes = this.nodes();\n        var numNodes = nodes.length;\n        if (!options.directed) {\n            var degrees = {};\n            var maxDegree = 0;\n            for(var i = 0; i < numNodes; i++){\n                var node = nodes[i];\n                // add current node to the current options object and call degreeCentrality\n                options.root = node;\n                var currDegree = this.degreeCentrality(options);\n                if (maxDegree < currDegree.degree) {\n                    maxDegree = currDegree.degree;\n                }\n                degrees[node.id()] = currDegree.degree;\n            }\n            return {\n                degree: function degree(node) {\n                    if (maxDegree === 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node);\n                    }\n                    return degrees[node.id()] / maxDegree;\n                }\n            };\n        } else {\n            var indegrees = {};\n            var outdegrees = {};\n            var maxIndegree = 0;\n            var maxOutdegree = 0;\n            for(var _i = 0; _i < numNodes; _i++){\n                var _node = nodes[_i];\n                var id = _node.id();\n                // add current node to the current options object and call degreeCentrality\n                options.root = _node;\n                var _currDegree = this.degreeCentrality(options);\n                if (maxIndegree < _currDegree.indegree) maxIndegree = _currDegree.indegree;\n                if (maxOutdegree < _currDegree.outdegree) maxOutdegree = _currDegree.outdegree;\n                indegrees[id] = _currDegree.indegree;\n                outdegrees[id] = _currDegree.outdegree;\n            }\n            return {\n                indegree: function indegree(node) {\n                    if (maxIndegree == 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node);\n                    }\n                    return indegrees[node.id()] / maxIndegree;\n                },\n                outdegree: function outdegree(node) {\n                    if (maxOutdegree === 0) {\n                        return 0;\n                    }\n                    if (string(node)) {\n                        // from is a selector string\n                        node = cy.filter(node);\n                    }\n                    return outdegrees[node.id()] / maxOutdegree;\n                }\n            };\n        }\n    },\n    // degreeCentralityNormalized\n    // Implemented from the algorithm in Opsahl's paper\n    // \"Node centrality in weighted networks: Generalizing degree and shortest paths\"\n    // check the heading 2 \"Degree\"\n    degreeCentrality: function degreeCentrality(options) {\n        options = defaults$f(options);\n        var cy = this.cy();\n        var callingEles = this;\n        var _options = options, root = _options.root, weight = _options.weight, directed = _options.directed, alpha = _options.alpha;\n        root = cy.collection(root)[0];\n        if (!directed) {\n            var connEdges = root.connectedEdges().intersection(callingEles);\n            var k = connEdges.length;\n            var s = 0;\n            // Now, sum edge weights\n            for(var i = 0; i < connEdges.length; i++){\n                s += weight(connEdges[i]);\n            }\n            return {\n                degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)\n            };\n        } else {\n            var edges = root.connectedEdges();\n            var incoming = edges.filter(function(edge) {\n                return edge.target().same(root) && callingEles.has(edge);\n            });\n            var outgoing = edges.filter(function(edge) {\n                return edge.source().same(root) && callingEles.has(edge);\n            });\n            var k_in = incoming.length;\n            var k_out = outgoing.length;\n            var s_in = 0;\n            var s_out = 0;\n            // Now, sum incoming edge weights\n            for(var _i2 = 0; _i2 < incoming.length; _i2++){\n                s_in += weight(incoming[_i2]);\n            }\n            // Now, sum outgoing edge weights\n            for(var _i3 = 0; _i3 < outgoing.length; _i3++){\n                s_out += weight(outgoing[_i3]);\n            }\n            return {\n                indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),\n                outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)\n            };\n        }\n    } // degreeCentrality\n}; // elesfn\n// nice, short mathematical alias\nelesfn$n.dc = elesfn$n.degreeCentrality;\nelesfn$n.dcn = elesfn$n.degreeCentralityNormalised = elesfn$n.degreeCentralityNormalized;\nvar defaults$e = defaults$g({\n    harmonic: true,\n    weight: function weight() {\n        return 1;\n    },\n    directed: false,\n    root: null\n});\nvar elesfn$m = {\n    closenessCentralityNormalized: function closenessCentralityNormalized(options) {\n        var _defaults = defaults$e(options), harmonic = _defaults.harmonic, weight = _defaults.weight, directed = _defaults.directed;\n        var cy = this.cy();\n        var closenesses = {};\n        var maxCloseness = 0;\n        var nodes = this.nodes();\n        var fw = this.floydWarshall({\n            weight: weight,\n            directed: directed\n        });\n        // Compute closeness for every node and find the maximum closeness\n        for(var i = 0; i < nodes.length; i++){\n            var currCloseness = 0;\n            var node_i = nodes[i];\n            for(var j = 0; j < nodes.length; j++){\n                if (i !== j) {\n                    var d = fw.distance(node_i, nodes[j]);\n                    if (harmonic) {\n                        currCloseness += 1 / d;\n                    } else {\n                        currCloseness += d;\n                    }\n                }\n            }\n            if (!harmonic) {\n                currCloseness = 1 / currCloseness;\n            }\n            if (maxCloseness < currCloseness) {\n                maxCloseness = currCloseness;\n            }\n            closenesses[node_i.id()] = currCloseness;\n        }\n        return {\n            closeness: function closeness(node) {\n                if (maxCloseness == 0) {\n                    return 0;\n                }\n                if (string(node)) {\n                    // from is a selector string\n                    node = cy.filter(node)[0].id();\n                } else {\n                    // from is a node\n                    node = node.id();\n                }\n                return closenesses[node] / maxCloseness;\n            }\n        };\n    },\n    // Implemented from pseudocode from wikipedia\n    closenessCentrality: function closenessCentrality(options) {\n        var _defaults2 = defaults$e(options), root = _defaults2.root, weight = _defaults2.weight, directed = _defaults2.directed, harmonic = _defaults2.harmonic;\n        root = this.filter(root)[0];\n        // we need distance from this node to every other node\n        var dijkstra = this.dijkstra({\n            root: root,\n            weight: weight,\n            directed: directed\n        });\n        var totalDistance = 0;\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            var n = nodes[i];\n            if (!n.same(root)) {\n                var d = dijkstra.distanceTo(n);\n                if (harmonic) {\n                    totalDistance += 1 / d;\n                } else {\n                    totalDistance += d;\n                }\n            }\n        }\n        return harmonic ? totalDistance : 1 / totalDistance;\n    } // closenessCentrality\n}; // elesfn\n// nice, short mathematical alias\nelesfn$m.cc = elesfn$m.closenessCentrality;\nelesfn$m.ccn = elesfn$m.closenessCentralityNormalised = elesfn$m.closenessCentralityNormalized;\nvar defaults$d = defaults$g({\n    weight: null,\n    directed: false\n});\nvar elesfn$l = {\n    // Implemented from the algorithm in the paper \"On Variants of Shortest-Path Betweenness Centrality and their Generic Computation\" by Ulrik Brandes\n    betweennessCentrality: function betweennessCentrality(options) {\n        var _defaults = defaults$d(options), directed = _defaults.directed, weight = _defaults.weight;\n        var weighted = weight != null;\n        var cy = this.cy();\n        // starting\n        var V = this.nodes();\n        var A = {};\n        var _C = {};\n        var max = 0;\n        var C = {\n            set: function set(key, val) {\n                _C[key] = val;\n                if (val > max) {\n                    max = val;\n                }\n            },\n            get: function get(key) {\n                return _C[key];\n            }\n        };\n        // A contains the neighborhoods of every node\n        for(var i = 0; i < V.length; i++){\n            var v = V[i];\n            var vid = v.id();\n            if (directed) {\n                A[vid] = v.outgoers().nodes(); // get outgoers of every node\n            } else {\n                A[vid] = v.openNeighborhood().nodes(); // get neighbors of every node\n            }\n            C.set(vid, 0);\n        }\n        var _loop = function _loop() {\n            var sid = V[s].id();\n            var S = []; // stack\n            var P = {};\n            var g = {};\n            var d = {};\n            var Q = new Heap(function(a, b) {\n                return d[a] - d[b];\n            }); // queue\n            // init dictionaries\n            for(var _i = 0; _i < V.length; _i++){\n                var _vid = V[_i].id();\n                P[_vid] = [];\n                g[_vid] = 0;\n                d[_vid] = Infinity;\n            }\n            g[sid] = 1; // sigma\n            d[sid] = 0; // distance to s\n            Q.push(sid);\n            while(!Q.empty()){\n                var _v = Q.pop();\n                S.push(_v);\n                if (weighted) {\n                    for(var j = 0; j < A[_v].length; j++){\n                        var w = A[_v][j];\n                        var vEle = cy.getElementById(_v);\n                        var edge = undefined;\n                        if (vEle.edgesTo(w).length > 0) {\n                            edge = vEle.edgesTo(w)[0];\n                        } else {\n                            edge = w.edgesTo(vEle)[0];\n                        }\n                        var edgeWeight = weight(edge);\n                        w = w.id();\n                        if (d[w] > d[_v] + edgeWeight) {\n                            d[w] = d[_v] + edgeWeight;\n                            if (Q.nodes.indexOf(w) < 0) {\n                                //if w is not in Q\n                                Q.push(w);\n                            } else {\n                                // update position if w is in Q\n                                Q.updateItem(w);\n                            }\n                            g[w] = 0;\n                            P[w] = [];\n                        }\n                        if (d[w] == d[_v] + edgeWeight) {\n                            g[w] = g[w] + g[_v];\n                            P[w].push(_v);\n                        }\n                    }\n                } else {\n                    for(var _j = 0; _j < A[_v].length; _j++){\n                        var _w = A[_v][_j].id();\n                        if (d[_w] == Infinity) {\n                            Q.push(_w);\n                            d[_w] = d[_v] + 1;\n                        }\n                        if (d[_w] == d[_v] + 1) {\n                            g[_w] = g[_w] + g[_v];\n                            P[_w].push(_v);\n                        }\n                    }\n                }\n            }\n            var e = {};\n            for(var _i2 = 0; _i2 < V.length; _i2++){\n                e[V[_i2].id()] = 0;\n            }\n            while(S.length > 0){\n                var _w2 = S.pop();\n                for(var _j2 = 0; _j2 < P[_w2].length; _j2++){\n                    var _v2 = P[_w2][_j2];\n                    e[_v2] = e[_v2] + g[_v2] / g[_w2] * (1 + e[_w2]);\n                }\n                if (_w2 != V[s].id()) {\n                    C.set(_w2, C.get(_w2) + e[_w2]);\n                }\n            }\n        };\n        for(var s = 0; s < V.length; s++){\n            _loop();\n        }\n        var ret = {\n            betweenness: function betweenness(node) {\n                var id = cy.collection(node).id();\n                return C.get(id);\n            },\n            betweennessNormalized: function betweennessNormalized(node) {\n                if (max == 0) {\n                    return 0;\n                }\n                var id = cy.collection(node).id();\n                return C.get(id) / max;\n            }\n        };\n        // alias\n        ret.betweennessNormalised = ret.betweennessNormalized;\n        return ret;\n    } // betweennessCentrality\n}; // elesfn\n// nice, short mathematical alias\nelesfn$l.bc = elesfn$l.betweennessCentrality;\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n// https://github.com/cytoscape/cytoscape.js-markov-cluster\n/* eslint-disable no-unused-vars */ var defaults$c = defaults$g({\n    expandFactor: 2,\n    // affects time of computation and cluster granularity to some extent: M * M\n    inflateFactor: 2,\n    // affects cluster granularity (the greater the value, the more clusters): M(i,j) / E(j)\n    multFactor: 1,\n    // optional self loops for each node. Use a neutral value to improve cluster computations.\n    maxIterations: 20,\n    // maximum number of iterations of the MCL algorithm in a single run\n    attributes: [\n        // attributes/features used to group nodes, ie. similarity values between nodes\n        function(edge) {\n            return 1;\n        }\n    ]\n});\n/* eslint-enable */ var setOptions$3 = function setOptions(options) {\n    return defaults$c(options);\n};\n/* eslint-enable */ var getSimilarity$1 = function getSimilarity(edge, attributes) {\n    var total = 0;\n    for(var i = 0; i < attributes.length; i++){\n        total += attributes[i](edge);\n    }\n    return total;\n};\nvar addLoops = function addLoops(M, n, val) {\n    for(var i = 0; i < n; i++){\n        M[i * n + i] = val;\n    }\n};\nvar normalize = function normalize(M, n) {\n    var sum;\n    for(var col = 0; col < n; col++){\n        sum = 0;\n        for(var row = 0; row < n; row++){\n            sum += M[row * n + col];\n        }\n        for(var _row = 0; _row < n; _row++){\n            M[_row * n + col] = M[_row * n + col] / sum;\n        }\n    }\n};\n// TODO: blocked matrix multiplication?\nvar mmult = function mmult(A, B, n) {\n    var C = new Array(n * n);\n    for(var i = 0; i < n; i++){\n        for(var j = 0; j < n; j++){\n            C[i * n + j] = 0;\n        }\n        for(var k = 0; k < n; k++){\n            for(var _j = 0; _j < n; _j++){\n                C[i * n + _j] += A[i * n + k] * B[k * n + _j];\n            }\n        }\n    }\n    return C;\n};\nvar expand = function expand(M, n, expandFactor /** power **/ ) {\n    var _M = M.slice(0);\n    for(var p = 1; p < expandFactor; p++){\n        M = mmult(M, _M, n);\n    }\n    return M;\n};\nvar inflate = function inflate(M, n, inflateFactor /** r **/ ) {\n    var _M = new Array(n * n);\n    // M(i,j) ^ inflatePower\n    for(var i = 0; i < n * n; i++){\n        _M[i] = Math.pow(M[i], inflateFactor);\n    }\n    normalize(_M, n);\n    return _M;\n};\nvar hasConverged = function hasConverged(M, _M, n2, roundFactor) {\n    // Check that both matrices have the same elements (i,j)\n    for(var i = 0; i < n2; i++){\n        var v1 = Math.round(M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor); // truncate to 'roundFactor' decimal places\n        var v2 = Math.round(_M[i] * Math.pow(10, roundFactor)) / Math.pow(10, roundFactor);\n        if (v1 !== v2) {\n            return false;\n        }\n    }\n    return true;\n};\nvar assign$2 = function assign(M, n, nodes, cy) {\n    var clusters = [];\n    for(var i = 0; i < n; i++){\n        var cluster = [];\n        for(var j = 0; j < n; j++){\n            // Row-wise attractors and elements that they attract belong in same cluster\n            if (Math.round(M[i * n + j] * 1000) / 1000 > 0) {\n                cluster.push(nodes[j]);\n            }\n        }\n        if (cluster.length !== 0) {\n            clusters.push(cy.collection(cluster));\n        }\n    }\n    return clusters;\n};\nvar isDuplicate = function isDuplicate(c1, c2) {\n    for(var i = 0; i < c1.length; i++){\n        if (!c2[i] || c1[i].id() !== c2[i].id()) {\n            return false;\n        }\n    }\n    return true;\n};\nvar removeDuplicates = function removeDuplicates(clusters) {\n    for(var i = 0; i < clusters.length; i++){\n        for(var j = 0; j < clusters.length; j++){\n            if (i != j && isDuplicate(clusters[i], clusters[j])) {\n                clusters.splice(j, 1);\n            }\n        }\n    }\n    return clusters;\n};\nvar markovClustering = function markovClustering(options) {\n    var nodes = this.nodes();\n    var edges = this.edges();\n    var cy = this.cy();\n    // Set parameters of algorithm:\n    var opts = setOptions$3(options);\n    // Map each node to its position in node array\n    var id2position = {};\n    for(var i = 0; i < nodes.length; i++){\n        id2position[nodes[i].id()] = i;\n    }\n    // Generate stochastic matrix M from input graph G (should be symmetric/undirected)\n    var n = nodes.length, n2 = n * n;\n    var M = new Array(n2), _M;\n    for(var _i = 0; _i < n2; _i++){\n        M[_i] = 0;\n    }\n    for(var e = 0; e < edges.length; e++){\n        var edge = edges[e];\n        var _i2 = id2position[edge.source().id()];\n        var j = id2position[edge.target().id()];\n        var sim = getSimilarity$1(edge, opts.attributes);\n        M[_i2 * n + j] += sim; // G should be symmetric and undirected\n        M[j * n + _i2] += sim;\n    }\n    // Begin Markov cluster algorithm\n    // Step 1: Add self loops to each node, ie. add multFactor to matrix diagonal\n    addLoops(M, n, opts.multFactor);\n    // Step 2: M = normalize( M );\n    normalize(M, n);\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        isStillMoving = false;\n        // Step 3:\n        _M = expand(M, n, opts.expandFactor);\n        // Step 4:\n        M = inflate(_M, n, opts.inflateFactor);\n        // Step 5: check to see if ~steady state has been reached\n        if (!hasConverged(M, _M, n2, 4)) {\n            isStillMoving = true;\n        }\n        iterations++;\n    }\n    // Build clusters from matrix\n    var clusters = assign$2(M, n, nodes, cy);\n    // Remove duplicate clusters due to symmetry of graph and M matrix\n    clusters = removeDuplicates(clusters);\n    return clusters;\n};\nvar markovClustering$1 = {\n    markovClustering: markovClustering,\n    mcl: markovClustering\n};\n// Common distance metrics for clustering algorithms\n// https://en.wikipedia.org/wiki/Hierarchical_clustering#Metric\nvar identity$1 = function identity(x) {\n    return x;\n};\nvar absDiff = function absDiff(p, q) {\n    return Math.abs(q - p);\n};\nvar addAbsDiff = function addAbsDiff(total, p, q) {\n    return total + absDiff(p, q);\n};\nvar addSquaredDiff = function addSquaredDiff(total, p, q) {\n    return total + Math.pow(q - p, 2);\n};\nvar sqrt = function sqrt(x) {\n    return Math.sqrt(x);\n};\nvar maxAbsDiff = function maxAbsDiff(currentMax, p, q) {\n    return Math.max(currentMax, absDiff(p, q));\n};\nvar getDistance = function getDistance(length, getP, getQ, init, visit) {\n    var post = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : identity$1;\n    var ret = init;\n    var p, q;\n    for(var dim = 0; dim < length; dim++){\n        p = getP(dim);\n        q = getQ(dim);\n        ret = visit(ret, p, q);\n    }\n    return post(ret);\n};\nvar distances = {\n    euclidean: function euclidean(length, getP, getQ) {\n        if (length >= 2) {\n            return getDistance(length, getP, getQ, 0, addSquaredDiff, sqrt);\n        } else {\n            // for single attr case, more efficient to avoid sqrt\n            return getDistance(length, getP, getQ, 0, addAbsDiff);\n        }\n    },\n    squaredEuclidean: function squaredEuclidean(length, getP, getQ) {\n        return getDistance(length, getP, getQ, 0, addSquaredDiff);\n    },\n    manhattan: function manhattan(length, getP, getQ) {\n        return getDistance(length, getP, getQ, 0, addAbsDiff);\n    },\n    max: function max(length, getP, getQ) {\n        return getDistance(length, getP, getQ, -Infinity, maxAbsDiff);\n    }\n};\n// in case the user accidentally doesn't use camel case\ndistances['squared-euclidean'] = distances['squaredEuclidean'];\ndistances['squaredeuclidean'] = distances['squaredEuclidean'];\nfunction clusteringDistance(method, length, getP, getQ, nodeP, nodeQ) {\n    var impl;\n    if (fn$6(method)) {\n        impl = method;\n    } else {\n        impl = distances[method] || distances.euclidean;\n    }\n    if (length === 0 && fn$6(method)) {\n        return impl(nodeP, nodeQ);\n    } else {\n        return impl(length, getP, getQ, nodeP, nodeQ);\n    }\n}\nvar defaults$b = defaults$g({\n    k: 2,\n    m: 2,\n    sensitivityThreshold: 0.0001,\n    distance: 'euclidean',\n    maxIterations: 10,\n    attributes: [],\n    testMode: false,\n    testCentroids: null\n});\nvar setOptions$2 = function setOptions(options) {\n    return defaults$b(options);\n};\nvar getDist = function getDist(type, node, centroid, attributes, mode) {\n    var noNodeP = mode !== 'kMedoids';\n    var getP = noNodeP ? function(i) {\n        return centroid[i];\n    } : function(i) {\n        return attributes[i](centroid);\n    };\n    var getQ = function getQ(i) {\n        return attributes[i](node);\n    };\n    var nodeP = centroid;\n    var nodeQ = node;\n    return clusteringDistance(type, attributes.length, getP, getQ, nodeP, nodeQ);\n};\nvar randomCentroids = function randomCentroids(nodes, k, attributes) {\n    var ndim = attributes.length;\n    var min = new Array(ndim);\n    var max = new Array(ndim);\n    var centroids = new Array(k);\n    var centroid = null;\n    // Find min, max values for each attribute dimension\n    for(var i = 0; i < ndim; i++){\n        min[i] = nodes.min(attributes[i]).value;\n        max[i] = nodes.max(attributes[i]).value;\n    }\n    // Build k centroids, each represented as an n-dim feature vector\n    for(var c = 0; c < k; c++){\n        centroid = [];\n        for(var _i = 0; _i < ndim; _i++){\n            centroid[_i] = Math.random() * (max[_i] - min[_i]) + min[_i]; // random initial value\n        }\n        centroids[c] = centroid;\n    }\n    return centroids;\n};\nvar classify = function classify(node, centroids, distance, attributes, type) {\n    var min = Infinity;\n    var index = 0;\n    for(var i = 0; i < centroids.length; i++){\n        var dist = getDist(distance, node, centroids[i], attributes, type);\n        if (dist < min) {\n            min = dist;\n            index = i;\n        }\n    }\n    return index;\n};\nvar buildCluster = function buildCluster(centroid, nodes, assignment) {\n    var cluster = [];\n    var node = null;\n    for(var n = 0; n < nodes.length; n++){\n        node = nodes[n];\n        if (assignment[node.id()] === centroid) {\n            //console.log(\"Node \" + node.id() + \" is associated with medoid #: \" + m);\n            cluster.push(node);\n        }\n    }\n    return cluster;\n};\nvar haveValuesConverged = function haveValuesConverged(v1, v2, sensitivityThreshold) {\n    return Math.abs(v2 - v1) <= sensitivityThreshold;\n};\nvar haveMatricesConverged = function haveMatricesConverged(v1, v2, sensitivityThreshold) {\n    for(var i = 0; i < v1.length; i++){\n        for(var j = 0; j < v1[i].length; j++){\n            var diff = Math.abs(v1[i][j] - v2[i][j]);\n            if (diff > sensitivityThreshold) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\nvar seenBefore = function seenBefore(node, medoids, n) {\n    for(var i = 0; i < n; i++){\n        if (node === medoids[i]) return true;\n    }\n    return false;\n};\nvar randomMedoids = function randomMedoids(nodes, k) {\n    var medoids = new Array(k);\n    // For small data sets, the probability of medoid conflict is greater,\n    // so we need to check to see if we've already seen or chose this node before.\n    if (nodes.length < 50) {\n        // Randomly select k medoids from the n nodes\n        for(var i = 0; i < k; i++){\n            var node = nodes[Math.floor(Math.random() * nodes.length)];\n            // If we've already chosen this node to be a medoid, don't choose it again (for small data sets).\n            // Instead choose a different random node.\n            while(seenBefore(node, medoids, i)){\n                node = nodes[Math.floor(Math.random() * nodes.length)];\n            }\n            medoids[i] = node;\n        }\n    } else {\n        // Relatively large data set, so pretty safe to not check and just select random nodes\n        for(var _i2 = 0; _i2 < k; _i2++){\n            medoids[_i2] = nodes[Math.floor(Math.random() * nodes.length)];\n        }\n    }\n    return medoids;\n};\nvar findCost = function findCost(potentialNewMedoid, cluster, attributes) {\n    var cost = 0;\n    for(var n = 0; n < cluster.length; n++){\n        cost += getDist('manhattan', cluster[n], potentialNewMedoid, attributes, 'kMedoids');\n    }\n    return cost;\n};\nvar kMeans = function kMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null;\n    // Set parameters of algorithm: # of clusters, distance metric, etc.\n    var opts = setOptions$2(options);\n    // Begin k-means algorithm\n    var clusters = new Array(opts.k);\n    var assignment = {};\n    var centroids;\n    // Step 1: Initialize centroid positions\n    if (opts.testMode) {\n        if (typeof opts.testCentroids === 'number') {\n            // TODO: implement a seeded random number generator.\n            opts.testCentroids;\n            centroids = randomCentroids(nodes, opts.k, opts.attributes);\n        } else if (_typeof(opts.testCentroids) === 'object') {\n            centroids = opts.testCentroids;\n        } else {\n            centroids = randomCentroids(nodes, opts.k, opts.attributes);\n        }\n    } else {\n        centroids = randomCentroids(nodes, opts.k, opts.attributes);\n    }\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        // Step 2: Assign nodes to the nearest centroid\n        for(var n = 0; n < nodes.length; n++){\n            node = nodes[n];\n            // Determine which cluster this node belongs to: node id => cluster #\n            assignment[node.id()] = classify(node, centroids, opts.distance, opts.attributes, 'kMeans');\n        }\n        // Step 3: For each of the k clusters, update its centroid\n        isStillMoving = false;\n        for(var c = 0; c < opts.k; c++){\n            // Get all nodes that belong to this cluster\n            var cluster = buildCluster(c, nodes, assignment);\n            if (cluster.length === 0) {\n                continue;\n            }\n            // Update centroids by calculating avg of all nodes within the cluster.\n            var ndim = opts.attributes.length;\n            var centroid = centroids[c]; // [ dim_1, dim_2, dim_3, ... , dim_n ]\n            var newCentroid = new Array(ndim);\n            var sum = new Array(ndim);\n            for(var d = 0; d < ndim; d++){\n                sum[d] = 0.0;\n                for(var i = 0; i < cluster.length; i++){\n                    node = cluster[i];\n                    sum[d] += opts.attributes[d](node);\n                }\n                newCentroid[d] = sum[d] / cluster.length;\n                // Check to see if algorithm has converged, i.e. when centroids no longer change\n                if (!haveValuesConverged(newCentroid[d], centroid[d], opts.sensitivityThreshold)) {\n                    isStillMoving = true;\n                }\n            }\n            centroids[c] = newCentroid;\n            clusters[c] = cy.collection(cluster);\n        }\n        iterations++;\n    }\n    return clusters;\n};\nvar kMedoids = function kMedoids(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var node = null;\n    var opts = setOptions$2(options);\n    // Begin k-medoids algorithm\n    var clusters = new Array(opts.k);\n    var medoids;\n    var assignment = {};\n    var curCost;\n    var minCosts = new Array(opts.k); // minimum cost configuration for each cluster\n    // Step 1: Initialize k medoids\n    if (opts.testMode) {\n        if (typeof opts.testCentroids === 'number') ;\n        else if (_typeof(opts.testCentroids) === 'object') {\n            medoids = opts.testCentroids;\n        } else {\n            medoids = randomMedoids(nodes, opts.k);\n        }\n    } else {\n        medoids = randomMedoids(nodes, opts.k);\n    }\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        // Step 2: Assign nodes to the nearest medoid\n        for(var n = 0; n < nodes.length; n++){\n            node = nodes[n];\n            // Determine which cluster this node belongs to: node id => cluster #\n            assignment[node.id()] = classify(node, medoids, opts.distance, opts.attributes, 'kMedoids');\n        }\n        isStillMoving = false;\n        // Step 3: For each medoid m, and for each node associated with mediod m,\n        // select the node with the lowest configuration cost as new medoid.\n        for(var m1 = 0; m1 < medoids.length; m1++){\n            // Get all nodes that belong to this medoid\n            var cluster = buildCluster(m1, nodes, assignment);\n            if (cluster.length === 0) {\n                continue;\n            }\n            minCosts[m1] = findCost(medoids[m1], cluster, opts.attributes); // original cost\n            // Select different medoid if its configuration has the lowest cost\n            for(var _n = 0; _n < cluster.length; _n++){\n                curCost = findCost(cluster[_n], cluster, opts.attributes);\n                if (curCost < minCosts[m1]) {\n                    minCosts[m1] = curCost;\n                    medoids[m1] = cluster[_n];\n                    isStillMoving = true;\n                }\n            }\n            clusters[m1] = cy.collection(cluster);\n        }\n        iterations++;\n    }\n    return clusters;\n};\nvar updateCentroids = function updateCentroids(centroids, nodes, U, weight, opts) {\n    var numerator, denominator;\n    for(var n = 0; n < nodes.length; n++){\n        for(var c = 0; c < centroids.length; c++){\n            weight[n][c] = Math.pow(U[n][c], opts.m);\n        }\n    }\n    for(var _c = 0; _c < centroids.length; _c++){\n        for(var dim = 0; dim < opts.attributes.length; dim++){\n            numerator = 0;\n            denominator = 0;\n            for(var _n2 = 0; _n2 < nodes.length; _n2++){\n                numerator += weight[_n2][_c] * opts.attributes[dim](nodes[_n2]);\n                denominator += weight[_n2][_c];\n            }\n            centroids[_c][dim] = numerator / denominator;\n        }\n    }\n};\nvar updateMembership = function updateMembership(U, _U, centroids, nodes, opts) {\n    // Save previous step\n    for(var i = 0; i < U.length; i++){\n        _U[i] = U[i].slice();\n    }\n    var sum, numerator, denominator;\n    var pow = 2 / (opts.m - 1);\n    for(var c = 0; c < centroids.length; c++){\n        for(var n = 0; n < nodes.length; n++){\n            sum = 0;\n            for(var k = 0; k < centroids.length; k++){\n                // against all other centroids\n                numerator = getDist(opts.distance, nodes[n], centroids[c], opts.attributes, 'cmeans');\n                denominator = getDist(opts.distance, nodes[n], centroids[k], opts.attributes, 'cmeans');\n                sum += Math.pow(numerator / denominator, pow);\n            }\n            U[n][c] = 1 / sum;\n        }\n    }\n};\nvar assign$1 = function assign(nodes, U, opts, cy) {\n    var clusters = new Array(opts.k);\n    for(var c = 0; c < clusters.length; c++){\n        clusters[c] = [];\n    }\n    var max;\n    var index;\n    for(var n = 0; n < U.length; n++){\n        // for each node (U is N x C matrix)\n        max = -Infinity;\n        index = -1;\n        // Determine which cluster the node is most likely to belong in\n        for(var _c2 = 0; _c2 < U[0].length; _c2++){\n            if (U[n][_c2] > max) {\n                max = U[n][_c2];\n                index = _c2;\n            }\n        }\n        clusters[index].push(nodes[n]);\n    }\n    // Turn every array into a collection of nodes\n    for(var _c3 = 0; _c3 < clusters.length; _c3++){\n        clusters[_c3] = cy.collection(clusters[_c3]);\n    }\n    return clusters;\n};\nvar fuzzyCMeans = function fuzzyCMeans(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions$2(options);\n    // Begin fuzzy c-means algorithm\n    var clusters;\n    var centroids;\n    var U;\n    var _U;\n    var weight;\n    // Step 1: Initialize letiables.\n    _U = new Array(nodes.length);\n    for(var i = 0; i < nodes.length; i++){\n        // N x C matrix\n        _U[i] = new Array(opts.k);\n    }\n    U = new Array(nodes.length);\n    for(var _i3 = 0; _i3 < nodes.length; _i3++){\n        // N x C matrix\n        U[_i3] = new Array(opts.k);\n    }\n    for(var _i4 = 0; _i4 < nodes.length; _i4++){\n        var total = 0;\n        for(var j = 0; j < opts.k; j++){\n            U[_i4][j] = Math.random();\n            total += U[_i4][j];\n        }\n        for(var _j = 0; _j < opts.k; _j++){\n            U[_i4][_j] = U[_i4][_j] / total;\n        }\n    }\n    centroids = new Array(opts.k);\n    for(var _i5 = 0; _i5 < opts.k; _i5++){\n        centroids[_i5] = new Array(opts.attributes.length);\n    }\n    weight = new Array(nodes.length);\n    for(var _i6 = 0; _i6 < nodes.length; _i6++){\n        // N x C matrix\n        weight[_i6] = new Array(opts.k);\n    }\n    // end init FCM\n    var isStillMoving = true;\n    var iterations = 0;\n    while(isStillMoving && iterations < opts.maxIterations){\n        isStillMoving = false;\n        // Step 2: Calculate the centroids for each step.\n        updateCentroids(centroids, nodes, U, weight, opts);\n        // Step 3: Update the partition matrix U.\n        updateMembership(U, _U, centroids, nodes, opts);\n        // Step 4: Check for convergence.\n        if (!haveMatricesConverged(U, _U, opts.sensitivityThreshold)) {\n            isStillMoving = true;\n        }\n        iterations++;\n    }\n    // Assign nodes to clusters with highest probability.\n    clusters = assign$1(nodes, U, opts, cy);\n    return {\n        clusters: clusters,\n        degreeOfMembership: U\n    };\n};\nvar kClustering = {\n    kMeans: kMeans,\n    kMedoids: kMedoids,\n    fuzzyCMeans: fuzzyCMeans,\n    fcm: fuzzyCMeans\n};\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n// https://github.com/cytoscape/cytoscape.js-hierarchical\nvar defaults$a = defaults$g({\n    distance: 'euclidean',\n    // distance metric to compare nodes\n    linkage: 'min',\n    // linkage criterion : how to determine the distance between clusters of nodes\n    mode: 'threshold',\n    // mode:'threshold' => clusters must be threshold distance apart\n    threshold: Infinity,\n    // the distance threshold\n    // mode:'dendrogram' => the nodes are organised as leaves in a tree (siblings are close), merging makes clusters\n    addDendrogram: false,\n    // whether to add the dendrogram to the graph for viz\n    dendrogramDepth: 0,\n    // depth at which dendrogram branches are merged into the returned clusters\n    attributes: [] // array of attr functions\n});\nvar linkageAliases = {\n    'single': 'min',\n    'complete': 'max'\n};\nvar setOptions$1 = function setOptions(options) {\n    var opts = defaults$a(options);\n    var preferredAlias = linkageAliases[opts.linkage];\n    if (preferredAlias != null) {\n        opts.linkage = preferredAlias;\n    }\n    return opts;\n};\nvar mergeClosest = function mergeClosest(clusters, index, dists, mins, opts) {\n    // Find two closest clusters from cached mins\n    var minKey = 0;\n    var min = Infinity;\n    var dist;\n    var attrs = opts.attributes;\n    var getDist = function getDist(n1, n2) {\n        return clusteringDistance(opts.distance, attrs.length, function(i) {\n            return attrs[i](n1);\n        }, function(i) {\n            return attrs[i](n2);\n        }, n1, n2);\n    };\n    for(var i = 0; i < clusters.length; i++){\n        var key = clusters[i].key;\n        var _dist = dists[key][mins[key]];\n        if (_dist < min) {\n            minKey = key;\n            min = _dist;\n        }\n    }\n    if (opts.mode === 'threshold' && min >= opts.threshold || opts.mode === 'dendrogram' && clusters.length === 1) {\n        return false;\n    }\n    var c1 = index[minKey];\n    var c2 = index[mins[minKey]];\n    var merged;\n    // Merge two closest clusters\n    if (opts.mode === 'dendrogram') {\n        merged = {\n            left: c1,\n            right: c2,\n            key: c1.key\n        };\n    } else {\n        merged = {\n            value: c1.value.concat(c2.value),\n            key: c1.key\n        };\n    }\n    clusters[c1.index] = merged;\n    clusters.splice(c2.index, 1);\n    index[c1.key] = merged;\n    // Update distances with new merged cluster\n    for(var _i = 0; _i < clusters.length; _i++){\n        var cur = clusters[_i];\n        if (c1.key === cur.key) {\n            dist = Infinity;\n        } else if (opts.linkage === 'min') {\n            dist = dists[c1.key][cur.key];\n            if (dists[c1.key][cur.key] > dists[c2.key][cur.key]) {\n                dist = dists[c2.key][cur.key];\n            }\n        } else if (opts.linkage === 'max') {\n            dist = dists[c1.key][cur.key];\n            if (dists[c1.key][cur.key] < dists[c2.key][cur.key]) {\n                dist = dists[c2.key][cur.key];\n            }\n        } else if (opts.linkage === 'mean') {\n            dist = (dists[c1.key][cur.key] * c1.size + dists[c2.key][cur.key] * c2.size) / (c1.size + c2.size);\n        } else {\n            if (opts.mode === 'dendrogram') dist = getDist(cur.value, c1.value);\n            else dist = getDist(cur.value[0], c1.value[0]);\n        }\n        dists[c1.key][cur.key] = dists[cur.key][c1.key] = dist; // distance matrix is symmetric\n    }\n    // Update cached mins\n    for(var _i2 = 0; _i2 < clusters.length; _i2++){\n        var key1 = clusters[_i2].key;\n        if (mins[key1] === c1.key || mins[key1] === c2.key) {\n            var _min = key1;\n            for(var j = 0; j < clusters.length; j++){\n                var key2 = clusters[j].key;\n                if (dists[key1][key2] < dists[key1][_min]) {\n                    _min = key2;\n                }\n            }\n            mins[key1] = _min;\n        }\n        clusters[_i2].index = _i2;\n    }\n    // Clean up meta data used for clustering\n    c1.key = c2.key = c1.index = c2.index = null;\n    return true;\n};\nvar _getAllChildren = function getAllChildren(root, arr, cy) {\n    if (!root) return;\n    if (root.value) {\n        arr.push(root.value);\n    } else {\n        if (root.left) _getAllChildren(root.left, arr);\n        if (root.right) _getAllChildren(root.right, arr);\n    }\n};\nvar _buildDendrogram = function buildDendrogram(root, cy) {\n    if (!root) return '';\n    if (root.left && root.right) {\n        var leftStr = _buildDendrogram(root.left, cy);\n        var rightStr = _buildDendrogram(root.right, cy);\n        var node = cy.add({\n            group: 'nodes',\n            data: {\n                id: leftStr + ',' + rightStr\n            }\n        });\n        cy.add({\n            group: 'edges',\n            data: {\n                source: leftStr,\n                target: node.id()\n            }\n        });\n        cy.add({\n            group: 'edges',\n            data: {\n                source: rightStr,\n                target: node.id()\n            }\n        });\n        return node.id();\n    } else if (root.value) {\n        return root.value.id();\n    }\n};\nvar _buildClustersFromTree = function buildClustersFromTree(root, k, cy) {\n    if (!root) return [];\n    var left = [], right = [], leaves = [];\n    if (k === 0) {\n        // don't cut tree, simply return all nodes as 1 single cluster\n        if (root.left) _getAllChildren(root.left, left);\n        if (root.right) _getAllChildren(root.right, right);\n        leaves = left.concat(right);\n        return [\n            cy.collection(leaves)\n        ];\n    } else if (k === 1) {\n        // cut at root\n        if (root.value) {\n            // leaf node\n            return [\n                cy.collection(root.value)\n            ];\n        } else {\n            if (root.left) _getAllChildren(root.left, left);\n            if (root.right) _getAllChildren(root.right, right);\n            return [\n                cy.collection(left),\n                cy.collection(right)\n            ];\n        }\n    } else {\n        if (root.value) {\n            return [\n                cy.collection(root.value)\n            ];\n        } else {\n            if (root.left) left = _buildClustersFromTree(root.left, k - 1, cy);\n            if (root.right) right = _buildClustersFromTree(root.right, k - 1, cy);\n            return left.concat(right);\n        }\n    }\n};\nvar hierarchicalClustering = function hierarchicalClustering(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    // Set parameters of algorithm: linkage type, distance metric, etc.\n    var opts = setOptions$1(options);\n    var attrs = opts.attributes;\n    var getDist = function getDist(n1, n2) {\n        return clusteringDistance(opts.distance, attrs.length, function(i) {\n            return attrs[i](n1);\n        }, function(i) {\n            return attrs[i](n2);\n        }, n1, n2);\n    };\n    // Begin hierarchical algorithm\n    var clusters = [];\n    var dists = []; // distances between each pair of clusters\n    var mins = []; // closest cluster for each cluster\n    var index = []; // hash of all clusters by key\n    // In agglomerative (bottom-up) clustering, each node starts as its own cluster\n    for(var n = 0; n < nodes.length; n++){\n        var cluster = {\n            value: opts.mode === 'dendrogram' ? nodes[n] : [\n                nodes[n]\n            ],\n            key: n,\n            index: n\n        };\n        clusters[n] = cluster;\n        index[n] = cluster;\n        dists[n] = [];\n        mins[n] = 0;\n    }\n    // Calculate the distance between each pair of clusters\n    for(var i = 0; i < clusters.length; i++){\n        for(var j = 0; j <= i; j++){\n            var dist = undefined;\n            if (opts.mode === 'dendrogram') {\n                // modes store cluster values differently\n                dist = i === j ? Infinity : getDist(clusters[i].value, clusters[j].value);\n            } else {\n                dist = i === j ? Infinity : getDist(clusters[i].value[0], clusters[j].value[0]);\n            }\n            dists[i][j] = dist;\n            dists[j][i] = dist;\n            if (dist < dists[i][mins[i]]) {\n                mins[i] = j; // Cache mins: closest cluster to cluster i is cluster j\n            }\n        }\n    }\n    // Find the closest pair of clusters and merge them into a single cluster.\n    // Update distances between new cluster and each of the old clusters, and loop until threshold reached.\n    var merged = mergeClosest(clusters, index, dists, mins, opts);\n    while(merged){\n        merged = mergeClosest(clusters, index, dists, mins, opts);\n    }\n    var retClusters;\n    // Dendrogram mode builds the hierarchy and adds intermediary nodes + edges\n    // in addition to returning the clusters.\n    if (opts.mode === 'dendrogram') {\n        retClusters = _buildClustersFromTree(clusters[0], opts.dendrogramDepth, cy);\n        if (opts.addDendrogram) _buildDendrogram(clusters[0], cy);\n    } else {\n        // Regular mode simply returns the clusters\n        retClusters = new Array(clusters.length);\n        clusters.forEach(function(cluster, i) {\n            // Clean up meta data used for clustering\n            cluster.key = cluster.index = null;\n            retClusters[i] = cy.collection(cluster.value);\n        });\n    }\n    return retClusters;\n};\nvar hierarchicalClustering$1 = {\n    hierarchicalClustering: hierarchicalClustering,\n    hca: hierarchicalClustering\n};\n// Implemented by Zoe Xi @zoexi for GSOC 2016\n// https://github.com/cytoscape/cytoscape.js-affinity-propagation\nvar defaults$9 = defaults$g({\n    distance: 'euclidean',\n    // distance metric to compare attributes between two nodes\n    preference: 'median',\n    // suitability of a data point to serve as an exemplar\n    damping: 0.8,\n    // damping factor between [0.5, 1)\n    maxIterations: 1000,\n    // max number of iterations to run\n    minIterations: 100,\n    // min number of iterations to run in order for clustering to stop\n    attributes: []\n});\nvar setOptions = function setOptions(options) {\n    var dmp = options.damping;\n    var pref = options.preference;\n    if (!(0.5 <= dmp && dmp < 1)) {\n        error(\"Damping must range on [0.5, 1).  Got: \".concat(dmp));\n    }\n    var validPrefs = [\n        'median',\n        'mean',\n        'min',\n        'max'\n    ];\n    if (!(validPrefs.some(function(v) {\n        return v === pref;\n    }) || number$1(pref))) {\n        error(\"Preference must be one of [\".concat(validPrefs.map(function(p) {\n            return \"'\".concat(p, \"'\");\n        }).join(', '), \"] or a number.  Got: \").concat(pref));\n    }\n    return defaults$9(options);\n};\nvar getSimilarity = function getSimilarity(type, n1, n2, attributes) {\n    var attr = function attr(n, i) {\n        return attributes[i](n);\n    };\n    // nb negative because similarity should have an inverse relationship to distance\n    return -clusteringDistance(type, attributes.length, function(i) {\n        return attr(n1, i);\n    }, function(i) {\n        return attr(n2, i);\n    }, n1, n2);\n};\nvar getPreference = function getPreference(S, preference) {\n    // larger preference = greater # of clusters\n    var p = null;\n    if (preference === 'median') {\n        p = median(S);\n    } else if (preference === 'mean') {\n        p = mean(S);\n    } else if (preference === 'min') {\n        p = min(S);\n    } else if (preference === 'max') {\n        p = max(S);\n    } else {\n        // Custom preference number, as set by user\n        p = preference;\n    }\n    return p;\n};\nvar findExemplars = function findExemplars(n, R, A) {\n    var indices = [];\n    for(var i = 0; i < n; i++){\n        if (R[i * n + i] + A[i * n + i] > 0) {\n            indices.push(i);\n        }\n    }\n    return indices;\n};\nvar assignClusters = function assignClusters(n, S, exemplars) {\n    var clusters = [];\n    for(var i = 0; i < n; i++){\n        var index = -1;\n        var max = -Infinity;\n        for(var ei = 0; ei < exemplars.length; ei++){\n            var e = exemplars[ei];\n            if (S[i * n + e] > max) {\n                index = e;\n                max = S[i * n + e];\n            }\n        }\n        if (index > 0) {\n            clusters.push(index);\n        }\n    }\n    for(var _ei = 0; _ei < exemplars.length; _ei++){\n        clusters[exemplars[_ei]] = exemplars[_ei];\n    }\n    return clusters;\n};\nvar assign = function assign(n, S, exemplars) {\n    var clusters = assignClusters(n, S, exemplars);\n    for(var ei = 0; ei < exemplars.length; ei++){\n        var ii = [];\n        for(var c = 0; c < clusters.length; c++){\n            if (clusters[c] === exemplars[ei]) {\n                ii.push(c);\n            }\n        }\n        var maxI = -1;\n        var maxSum = -Infinity;\n        for(var i = 0; i < ii.length; i++){\n            var sum = 0;\n            for(var j = 0; j < ii.length; j++){\n                sum += S[ii[j] * n + ii[i]];\n            }\n            if (sum > maxSum) {\n                maxI = i;\n                maxSum = sum;\n            }\n        }\n        exemplars[ei] = ii[maxI];\n    }\n    clusters = assignClusters(n, S, exemplars);\n    return clusters;\n};\nvar affinityPropagation = function affinityPropagation(options) {\n    var cy = this.cy();\n    var nodes = this.nodes();\n    var opts = setOptions(options);\n    // Map each node to its position in node array\n    var id2position = {};\n    for(var i = 0; i < nodes.length; i++){\n        id2position[nodes[i].id()] = i;\n    }\n    // Begin affinity propagation algorithm\n    var n; // number of data points\n    var n2; // size of matrices\n    var S; // similarity matrix (1D array)\n    var p; // preference/suitability of a data point to serve as an exemplar\n    var R; // responsibility matrix (1D array)\n    var A; // availability matrix (1D array)\n    n = nodes.length;\n    n2 = n * n;\n    // Initialize and build S similarity matrix\n    S = new Array(n2);\n    for(var _i = 0; _i < n2; _i++){\n        S[_i] = -Infinity; // for cases where two data points shouldn't be linked together\n    }\n    for(var _i2 = 0; _i2 < n; _i2++){\n        for(var j = 0; j < n; j++){\n            if (_i2 !== j) {\n                S[_i2 * n + j] = getSimilarity(opts.distance, nodes[_i2], nodes[j], opts.attributes);\n            }\n        }\n    }\n    // Place preferences on the diagonal of S\n    p = getPreference(S, opts.preference);\n    for(var _i3 = 0; _i3 < n; _i3++){\n        S[_i3 * n + _i3] = p;\n    }\n    // Initialize R responsibility matrix\n    R = new Array(n2);\n    for(var _i4 = 0; _i4 < n2; _i4++){\n        R[_i4] = 0.0;\n    }\n    // Initialize A availability matrix\n    A = new Array(n2);\n    for(var _i5 = 0; _i5 < n2; _i5++){\n        A[_i5] = 0.0;\n    }\n    var old = new Array(n);\n    var Rp = new Array(n);\n    var se = new Array(n);\n    for(var _i6 = 0; _i6 < n; _i6++){\n        old[_i6] = 0.0;\n        Rp[_i6] = 0.0;\n        se[_i6] = 0;\n    }\n    var e = new Array(n * opts.minIterations);\n    for(var _i7 = 0; _i7 < e.length; _i7++){\n        e[_i7] = 0;\n    }\n    var iter;\n    for(iter = 0; iter < opts.maxIterations; iter++){\n        // main algorithmic loop\n        // Update R responsibility matrix\n        for(var _i8 = 0; _i8 < n; _i8++){\n            var max = -Infinity, max2 = -Infinity, maxI = -1, AS = 0.0;\n            for(var _j = 0; _j < n; _j++){\n                old[_j] = R[_i8 * n + _j];\n                AS = A[_i8 * n + _j] + S[_i8 * n + _j];\n                if (AS >= max) {\n                    max2 = max;\n                    max = AS;\n                    maxI = _j;\n                } else if (AS > max2) {\n                    max2 = AS;\n                }\n            }\n            for(var _j2 = 0; _j2 < n; _j2++){\n                R[_i8 * n + _j2] = (1 - opts.damping) * (S[_i8 * n + _j2] - max) + opts.damping * old[_j2];\n            }\n            R[_i8 * n + maxI] = (1 - opts.damping) * (S[_i8 * n + maxI] - max2) + opts.damping * old[maxI];\n        }\n        // Update A availability matrix\n        for(var _i9 = 0; _i9 < n; _i9++){\n            var sum = 0;\n            for(var _j3 = 0; _j3 < n; _j3++){\n                old[_j3] = A[_j3 * n + _i9];\n                Rp[_j3] = Math.max(0, R[_j3 * n + _i9]);\n                sum += Rp[_j3];\n            }\n            sum -= Rp[_i9];\n            Rp[_i9] = R[_i9 * n + _i9];\n            sum += Rp[_i9];\n            for(var _j4 = 0; _j4 < n; _j4++){\n                A[_j4 * n + _i9] = (1 - opts.damping) * Math.min(0, sum - Rp[_j4]) + opts.damping * old[_j4];\n            }\n            A[_i9 * n + _i9] = (1 - opts.damping) * (sum - Rp[_i9]) + opts.damping * old[_i9];\n        }\n        // Check for convergence\n        var K = 0;\n        for(var _i10 = 0; _i10 < n; _i10++){\n            var E = A[_i10 * n + _i10] + R[_i10 * n + _i10] > 0 ? 1 : 0;\n            e[iter % opts.minIterations * n + _i10] = E;\n            K += E;\n        }\n        if (K > 0 && (iter >= opts.minIterations - 1 || iter == opts.maxIterations - 1)) {\n            var _sum = 0;\n            for(var _i11 = 0; _i11 < n; _i11++){\n                se[_i11] = 0;\n                for(var _j5 = 0; _j5 < opts.minIterations; _j5++){\n                    se[_i11] += e[_j5 * n + _i11];\n                }\n                if (se[_i11] === 0 || se[_i11] === opts.minIterations) {\n                    _sum++;\n                }\n            }\n            if (_sum === n) {\n                break;\n            }\n        }\n    }\n    // Identify exemplars (cluster centers)\n    var exemplarsIndices = findExemplars(n, R, A);\n    // Assign nodes to clusters\n    var clusterIndices = assign(n, S, exemplarsIndices);\n    var clusters = {};\n    for(var c = 0; c < exemplarsIndices.length; c++){\n        clusters[exemplarsIndices[c]] = [];\n    }\n    for(var _i12 = 0; _i12 < nodes.length; _i12++){\n        var pos = id2position[nodes[_i12].id()];\n        var clusterIndex = clusterIndices[pos];\n        if (clusterIndex != null) {\n            // the node may have not been assigned a cluster if no valid attributes were specified\n            clusters[clusterIndex].push(nodes[_i12]);\n        }\n    }\n    var retClusters = new Array(exemplarsIndices.length);\n    for(var _c = 0; _c < exemplarsIndices.length; _c++){\n        retClusters[_c] = cy.collection(clusters[exemplarsIndices[_c]]);\n    }\n    return retClusters;\n};\nvar affinityPropagation$1 = {\n    affinityPropagation: affinityPropagation,\n    ap: affinityPropagation\n};\nvar hierholzerDefaults = defaults$g({\n    root: undefined,\n    directed: false\n});\nvar elesfn$k = {\n    hierholzer: function hierholzer(options) {\n        if (!plainObject(options)) {\n            var args = arguments;\n            options = {\n                root: args[0],\n                directed: args[1]\n            };\n        }\n        var _hierholzerDefaults = hierholzerDefaults(options), root = _hierholzerDefaults.root, directed = _hierholzerDefaults.directed;\n        var eles = this;\n        var dflag = false;\n        var oddIn;\n        var oddOut;\n        var startVertex;\n        if (root) startVertex = string(root) ? this.filter(root)[0].id() : root[0].id();\n        var nodes = {};\n        var edges = {};\n        if (directed) {\n            eles.forEach(function(ele) {\n                var id = ele.id();\n                if (ele.isNode()) {\n                    var ind = ele.indegree(true);\n                    var outd = ele.outdegree(true);\n                    var d1 = ind - outd;\n                    var d2 = outd - ind;\n                    if (d1 == 1) {\n                        if (oddIn) dflag = true;\n                        else oddIn = id;\n                    } else if (d2 == 1) {\n                        if (oddOut) dflag = true;\n                        else oddOut = id;\n                    } else if (d2 > 1 || d1 > 1) {\n                        dflag = true;\n                    }\n                    nodes[id] = [];\n                    ele.outgoers().forEach(function(e) {\n                        if (e.isEdge()) nodes[id].push(e.id());\n                    });\n                } else {\n                    edges[id] = [\n                        undefined,\n                        ele.target().id()\n                    ];\n                }\n            });\n        } else {\n            eles.forEach(function(ele) {\n                var id = ele.id();\n                if (ele.isNode()) {\n                    var d = ele.degree(true);\n                    if (d % 2) {\n                        if (!oddIn) oddIn = id;\n                        else if (!oddOut) oddOut = id;\n                        else dflag = true;\n                    }\n                    nodes[id] = [];\n                    ele.connectedEdges().forEach(function(e) {\n                        return nodes[id].push(e.id());\n                    });\n                } else {\n                    edges[id] = [\n                        ele.source().id(),\n                        ele.target().id()\n                    ];\n                }\n            });\n        }\n        var result = {\n            found: false,\n            trail: undefined\n        };\n        if (dflag) return result;\n        else if (oddOut && oddIn) {\n            if (directed) {\n                if (startVertex && oddOut != startVertex) {\n                    return result;\n                }\n                startVertex = oddOut;\n            } else {\n                if (startVertex && oddOut != startVertex && oddIn != startVertex) {\n                    return result;\n                } else if (!startVertex) {\n                    startVertex = oddOut;\n                }\n            }\n        } else {\n            if (!startVertex) startVertex = eles[0].id();\n        }\n        var walk = function walk(v) {\n            var currentNode = v;\n            var subtour = [\n                v\n            ];\n            var adj, adjTail, adjHead;\n            while(nodes[currentNode].length){\n                adj = nodes[currentNode].shift();\n                adjTail = edges[adj][0];\n                adjHead = edges[adj][1];\n                if (currentNode != adjHead) {\n                    nodes[adjHead] = nodes[adjHead].filter(function(e) {\n                        return e != adj;\n                    });\n                    currentNode = adjHead;\n                } else if (!directed && currentNode != adjTail) {\n                    nodes[adjTail] = nodes[adjTail].filter(function(e) {\n                        return e != adj;\n                    });\n                    currentNode = adjTail;\n                }\n                subtour.unshift(adj);\n                subtour.unshift(currentNode);\n            }\n            return subtour;\n        };\n        var trail = [];\n        var subtour = [];\n        subtour = walk(startVertex);\n        while(subtour.length != 1){\n            if (nodes[subtour[0]].length == 0) {\n                trail.unshift(eles.getElementById(subtour.shift()));\n                trail.unshift(eles.getElementById(subtour.shift()));\n            } else {\n                subtour = walk(subtour.shift()).concat(subtour);\n            }\n        }\n        trail.unshift(eles.getElementById(subtour.shift())); // final node\n        for(var d in nodes){\n            if (nodes[d].length) {\n                return result;\n            }\n        }\n        result.found = true;\n        result.trail = this.spawn(trail, true);\n        return result;\n    }\n};\nvar hopcroftTarjanBiconnected = function hopcroftTarjanBiconnected() {\n    var eles = this;\n    var nodes = {};\n    var id = 0;\n    var edgeCount = 0;\n    var components = [];\n    var stack = [];\n    var visitedEdges = {};\n    var buildComponent = function buildComponent(x, y) {\n        var i = stack.length - 1;\n        var cutset = [];\n        var component = eles.spawn();\n        while(stack[i].x != x || stack[i].y != y){\n            cutset.push(stack.pop().edge);\n            i--;\n        }\n        cutset.push(stack.pop().edge);\n        cutset.forEach(function(edge) {\n            var connectedNodes = edge.connectedNodes().intersection(eles);\n            component.merge(edge);\n            connectedNodes.forEach(function(node) {\n                var nodeId = node.id();\n                var connectedEdges = node.connectedEdges().intersection(eles);\n                component.merge(node);\n                if (!nodes[nodeId].cutVertex) {\n                    component.merge(connectedEdges);\n                } else {\n                    component.merge(connectedEdges.filter(function(edge) {\n                        return edge.isLoop();\n                    }));\n                }\n            });\n        });\n        components.push(component);\n    };\n    var _biconnectedSearch = function biconnectedSearch(root, currentNode, parent) {\n        if (root === parent) edgeCount += 1;\n        nodes[currentNode] = {\n            id: id,\n            low: id++,\n            cutVertex: false\n        };\n        var edges = eles.getElementById(currentNode).connectedEdges().intersection(eles);\n        if (edges.size() === 0) {\n            components.push(eles.spawn(eles.getElementById(currentNode)));\n        } else {\n            var sourceId, targetId, otherNodeId, edgeId;\n            edges.forEach(function(edge) {\n                sourceId = edge.source().id();\n                targetId = edge.target().id();\n                otherNodeId = sourceId === currentNode ? targetId : sourceId;\n                if (otherNodeId !== parent) {\n                    edgeId = edge.id();\n                    if (!visitedEdges[edgeId]) {\n                        visitedEdges[edgeId] = true;\n                        stack.push({\n                            x: currentNode,\n                            y: otherNodeId,\n                            edge: edge\n                        });\n                    }\n                    if (!(otherNodeId in nodes)) {\n                        _biconnectedSearch(root, otherNodeId, currentNode);\n                        nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].low);\n                        if (nodes[currentNode].id <= nodes[otherNodeId].low) {\n                            nodes[currentNode].cutVertex = true;\n                            buildComponent(currentNode, otherNodeId);\n                        }\n                    } else {\n                        nodes[currentNode].low = Math.min(nodes[currentNode].low, nodes[otherNodeId].id);\n                    }\n                }\n            });\n        }\n    };\n    eles.forEach(function(ele) {\n        if (ele.isNode()) {\n            var nodeId = ele.id();\n            if (!(nodeId in nodes)) {\n                edgeCount = 0;\n                _biconnectedSearch(nodeId, nodeId);\n                nodes[nodeId].cutVertex = edgeCount > 1;\n            }\n        }\n    });\n    var cutVertices = Object.keys(nodes).filter(function(id) {\n        return nodes[id].cutVertex;\n    }).map(function(id) {\n        return eles.getElementById(id);\n    });\n    return {\n        cut: eles.spawn(cutVertices),\n        components: components\n    };\n};\nvar hopcroftTarjanBiconnected$1 = {\n    hopcroftTarjanBiconnected: hopcroftTarjanBiconnected,\n    htbc: hopcroftTarjanBiconnected,\n    htb: hopcroftTarjanBiconnected,\n    hopcroftTarjanBiconnectedComponents: hopcroftTarjanBiconnected\n};\nvar tarjanStronglyConnected = function tarjanStronglyConnected() {\n    var eles = this;\n    var nodes = {};\n    var index = 0;\n    var components = [];\n    var stack = [];\n    var cut = eles.spawn(eles);\n    var _stronglyConnectedSearch = function stronglyConnectedSearch(sourceNodeId) {\n        stack.push(sourceNodeId);\n        nodes[sourceNodeId] = {\n            index: index,\n            low: index++,\n            explored: false\n        };\n        var connectedEdges = eles.getElementById(sourceNodeId).connectedEdges().intersection(eles);\n        connectedEdges.forEach(function(edge) {\n            var targetNodeId = edge.target().id();\n            if (targetNodeId !== sourceNodeId) {\n                if (!(targetNodeId in nodes)) {\n                    _stronglyConnectedSearch(targetNodeId);\n                }\n                if (!nodes[targetNodeId].explored) {\n                    nodes[sourceNodeId].low = Math.min(nodes[sourceNodeId].low, nodes[targetNodeId].low);\n                }\n            }\n        });\n        if (nodes[sourceNodeId].index === nodes[sourceNodeId].low) {\n            var componentNodes = eles.spawn();\n            for(;;){\n                var nodeId = stack.pop();\n                componentNodes.merge(eles.getElementById(nodeId));\n                nodes[nodeId].low = nodes[sourceNodeId].index;\n                nodes[nodeId].explored = true;\n                if (nodeId === sourceNodeId) {\n                    break;\n                }\n            }\n            var componentEdges = componentNodes.edgesWith(componentNodes);\n            var component = componentNodes.merge(componentEdges);\n            components.push(component);\n            cut = cut.difference(component);\n        }\n    };\n    eles.forEach(function(ele) {\n        if (ele.isNode()) {\n            var nodeId = ele.id();\n            if (!(nodeId in nodes)) {\n                _stronglyConnectedSearch(nodeId);\n            }\n        }\n    });\n    return {\n        cut: cut,\n        components: components\n    };\n};\nvar tarjanStronglyConnected$1 = {\n    tarjanStronglyConnected: tarjanStronglyConnected,\n    tsc: tarjanStronglyConnected,\n    tscc: tarjanStronglyConnected,\n    tarjanStronglyConnectedComponents: tarjanStronglyConnected\n};\nvar elesfn$j = {};\n[\n    elesfn$v,\n    elesfn$u,\n    elesfn$t,\n    elesfn$s,\n    elesfn$r,\n    elesfn$q,\n    elesfn$p,\n    elesfn$o,\n    elesfn$n,\n    elesfn$m,\n    elesfn$l,\n    markovClustering$1,\n    kClustering,\n    hierarchicalClustering$1,\n    affinityPropagation$1,\n    elesfn$k,\n    hopcroftTarjanBiconnected$1,\n    tarjanStronglyConnected$1\n].forEach(function(props) {\n    extend(elesfn$j, props);\n});\n/*!\nEmbeddable Minimum Strictly-Compliant Promises/A+ 1.1.1 Thenable\nCopyright (c) 2013-2014 Ralf S. Engelschall (http://engelschall.com)\nLicensed under The MIT License (http://opensource.org/licenses/MIT)\n*/ /*  promise states [Promises/A+ 2.1]  */ var STATE_PENDING = 0; /*  [Promises/A+ 2.1.1]  */ \nvar STATE_FULFILLED = 1; /*  [Promises/A+ 2.1.2]  */ \nvar STATE_REJECTED = 2; /*  [Promises/A+ 2.1.3]  */ \n/*  promise object constructor  */ var _api = function api(executor) {\n    /*  optionally support non-constructor/plain-function call  */ if (!(this instanceof _api)) return new _api(executor);\n    /*  initialize object  */ this.id = 'Thenable/1.0.7';\n    this.state = STATE_PENDING; /*  initial state  */ \n    this.fulfillValue = undefined; /*  initial value  */  /*  [Promises/A+ 1.3, 2.1.2.2]  */ \n    this.rejectReason = undefined; /*  initial reason */  /*  [Promises/A+ 1.5, 2.1.3.2]  */ \n    this.onFulfilled = []; /*  initial handlers  */ \n    this.onRejected = []; /*  initial handlers  */ \n    /*  provide optional information-hiding proxy  */ this.proxy = {\n        then: this.then.bind(this)\n    };\n    /*  support optional executor function  */ if (typeof executor === 'function') executor.call(this, this.fulfill.bind(this), this.reject.bind(this));\n};\n/*  promise API methods  */ _api.prototype = {\n    /*  promise resolving methods  */ fulfill: function fulfill(value) {\n        return deliver(this, STATE_FULFILLED, 'fulfillValue', value);\n    },\n    reject: function reject(value) {\n        return deliver(this, STATE_REJECTED, 'rejectReason', value);\n    },\n    /*  \"The then Method\" [Promises/A+ 1.1, 1.2, 2.2]  */ then: function then(onFulfilled, onRejected) {\n        var curr = this;\n        var next = new _api(); /*  [Promises/A+ 2.2.7]  */ \n        curr.onFulfilled.push(resolver(onFulfilled, next, 'fulfill')); /*  [Promises/A+ 2.2.2/2.2.6]  */ \n        curr.onRejected.push(resolver(onRejected, next, 'reject')); /*  [Promises/A+ 2.2.3/2.2.6]  */ \n        execute(curr);\n        return next.proxy; /*  [Promises/A+ 2.2.7, 3.3]  */ \n    }\n};\n/*  deliver an action  */ var deliver = function deliver(curr, state, name, value) {\n    if (curr.state === STATE_PENDING) {\n        curr.state = state; /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */ \n        curr[name] = value; /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */ \n        execute(curr);\n    }\n    return curr;\n};\n/*  execute all handlers  */ var execute = function execute(curr) {\n    if (curr.state === STATE_FULFILLED) execute_handlers(curr, 'onFulfilled', curr.fulfillValue);\n    else if (curr.state === STATE_REJECTED) execute_handlers(curr, 'onRejected', curr.rejectReason);\n};\n/*  execute particular set of handlers  */ var execute_handlers = function execute_handlers(curr, name, value) {\n    /* global setImmediate: true */ /* global setTimeout: true */ /*  short-circuit processing  */ if (curr[name].length === 0) return;\n    /*  iterate over all handlers, exactly once  */ var handlers = curr[name];\n    curr[name] = []; /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */ \n    var func = function func() {\n        for(var i = 0; i < handlers.length; i++)handlers[i](value); /*  [Promises/A+ 2.2.5]  */ \n    };\n    /*  execute procedure asynchronously  */ /*  [Promises/A+ 2.2.4, 3.1]  */ if (typeof setImmediate === 'function') setImmediate(func);\n    else setTimeout(func, 0);\n};\n/*  generate a resolver function  */ var resolver = function resolver(cb, next, method) {\n    return function(value) {\n        if (typeof cb !== 'function') /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */ next[method].call(next, value); /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */ \n        else {\n            var result;\n            try {\n                result = cb(value);\n            } catch (e) {\n                next.reject(e); /*  [Promises/A+ 2.2.7.2]  */ \n                return;\n            }\n            _resolve(next, result); /*  [Promises/A+ 2.2.7.1]  */ \n        }\n    };\n};\n/*  \"Promise Resolution Procedure\"  */ /*  [Promises/A+ 2.3]  */ var _resolve = function resolve(promise, x) {\n    /*  sanity check arguments  */ /*  [Promises/A+ 2.3.1]  */ if (promise === x || promise.proxy === x) {\n        promise.reject(new TypeError('cannot resolve promise with itself'));\n        return;\n    }\n    /*  surgically check for a \"then\" method\n    (mainly to just call the \"getter\" of \"then\" only once)  */ var then;\n    if (_typeof(x) === 'object' && x !== null || typeof x === 'function') {\n        try {\n            then = x.then;\n        } catch (e) {\n            promise.reject(e); /*  [Promises/A+ 2.3.3.2]  */ \n            return;\n        }\n    }\n    /*  handle own Thenables    [Promises/A+ 2.3.2]\n    and similar \"thenables\" [Promises/A+ 2.3.3]  */ if (typeof then === 'function') {\n        var resolved = false;\n        try {\n            /*  call retrieved \"then\" method */ /*  [Promises/A+ 2.3.3.3]  */ then.call(x, /*  resolvePromise  */ /*  [Promises/A+ 2.3.3.3.1]  */ function(y) {\n                if (resolved) return;\n                resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */ \n                if (y === x) /*  [Promises/A+ 3.6]  */ promise.reject(new TypeError('circular thenable chain'));\n                else _resolve(promise, y);\n            }, /*  rejectPromise  */ /*  [Promises/A+ 2.3.3.3.2]  */ function(r) {\n                if (resolved) return;\n                resolved = true; /*  [Promises/A+ 2.3.3.3.3]  */ \n                promise.reject(r);\n            });\n        } catch (e) {\n            if (!resolved) /*  [Promises/A+ 2.3.3.3.3]  */ promise.reject(e); /*  [Promises/A+ 2.3.3.3.4]  */ \n        }\n        return;\n    }\n    /*  handle other values  */ promise.fulfill(x); /*  [Promises/A+ 2.3.4, 2.3.3.4]  */ \n};\n// so we always have Promise.all()\n_api.all = function(ps) {\n    return new _api(function(resolveAll, rejectAll) {\n        var vals = new Array(ps.length);\n        var doneCount = 0;\n        var fulfill = function fulfill(i, val) {\n            vals[i] = val;\n            doneCount++;\n            if (doneCount === ps.length) {\n                resolveAll(vals);\n            }\n        };\n        for(var i = 0; i < ps.length; i++){\n            (function(i) {\n                var p = ps[i];\n                var isPromise = p != null && p.then != null;\n                if (isPromise) {\n                    p.then(function(val) {\n                        fulfill(i, val);\n                    }, function(err) {\n                        rejectAll(err);\n                    });\n                } else {\n                    var val = p;\n                    fulfill(i, val);\n                }\n            })(i);\n        }\n    });\n};\n_api.resolve = function(val) {\n    return new _api(function(resolve, reject) {\n        resolve(val);\n    });\n};\n_api.reject = function(val) {\n    return new _api(function(resolve, reject) {\n        reject(val);\n    });\n};\nvar Promise$1 = typeof Promise !== 'undefined' ? Promise : _api; // eslint-disable-line no-undef\nvar Animation = function Animation(target, opts, opts2) {\n    var isCore = core(target);\n    var isEle = !isCore;\n    var _p = this._private = extend({\n        duration: 1000\n    }, opts, opts2);\n    _p.target = target;\n    _p.style = _p.style || _p.css;\n    _p.started = false;\n    _p.playing = false;\n    _p.hooked = false;\n    _p.applying = false;\n    _p.progress = 0;\n    _p.completes = [];\n    _p.frames = [];\n    if (_p.complete && fn$6(_p.complete)) {\n        _p.completes.push(_p.complete);\n    }\n    if (isEle) {\n        var pos = target.position();\n        _p.startPosition = _p.startPosition || {\n            x: pos.x,\n            y: pos.y\n        };\n        _p.startStyle = _p.startStyle || target.cy().style().getAnimationStartStyle(target, _p.style);\n    }\n    if (isCore) {\n        var pan = target.pan();\n        _p.startPan = {\n            x: pan.x,\n            y: pan.y\n        };\n        _p.startZoom = target.zoom();\n    }\n    // for future timeline/animations impl\n    this.length = 1;\n    this[0] = this;\n};\nvar anifn = Animation.prototype;\nextend(anifn, {\n    instanceString: function instanceString() {\n        return 'animation';\n    },\n    hook: function hook() {\n        var _p = this._private;\n        if (!_p.hooked) {\n            // add to target's animation queue\n            var q;\n            var tAni = _p.target._private.animation;\n            if (_p.queue) {\n                q = tAni.queue;\n            } else {\n                q = tAni.current;\n            }\n            q.push(this);\n            // add to the animation loop pool\n            if (elementOrCollection(_p.target)) {\n                _p.target.cy().addToAnimationPool(_p.target);\n            }\n            _p.hooked = true;\n        }\n        return this;\n    },\n    play: function play() {\n        var _p = this._private;\n        // autorewind\n        if (_p.progress === 1) {\n            _p.progress = 0;\n        }\n        _p.playing = true;\n        _p.started = false; // needs to be started by animation loop\n        _p.stopped = false;\n        this.hook();\n        // the animation loop will start the animation...\n        return this;\n    },\n    playing: function playing() {\n        return this._private.playing;\n    },\n    apply: function apply() {\n        var _p = this._private;\n        _p.applying = true;\n        _p.started = false; // needs to be started by animation loop\n        _p.stopped = false;\n        this.hook();\n        // the animation loop will apply the animation at this progress\n        return this;\n    },\n    applying: function applying() {\n        return this._private.applying;\n    },\n    pause: function pause() {\n        var _p = this._private;\n        _p.playing = false;\n        _p.started = false;\n        return this;\n    },\n    stop: function stop() {\n        var _p = this._private;\n        _p.playing = false;\n        _p.started = false;\n        _p.stopped = true; // to be removed from animation queues\n        return this;\n    },\n    rewind: function rewind() {\n        return this.progress(0);\n    },\n    fastforward: function fastforward() {\n        return this.progress(1);\n    },\n    time: function time(t) {\n        var _p = this._private;\n        if (t === undefined) {\n            return _p.progress * _p.duration;\n        } else {\n            return this.progress(t / _p.duration);\n        }\n    },\n    progress: function progress(p) {\n        var _p = this._private;\n        var wasPlaying = _p.playing;\n        if (p === undefined) {\n            return _p.progress;\n        } else {\n            if (wasPlaying) {\n                this.pause();\n            }\n            _p.progress = p;\n            _p.started = false;\n            if (wasPlaying) {\n                this.play();\n            }\n        }\n        return this;\n    },\n    completed: function completed() {\n        return this._private.progress === 1;\n    },\n    reverse: function reverse() {\n        var _p = this._private;\n        var wasPlaying = _p.playing;\n        if (wasPlaying) {\n            this.pause();\n        }\n        _p.progress = 1 - _p.progress;\n        _p.started = false;\n        var swap = function swap(a, b) {\n            var _pa = _p[a];\n            if (_pa == null) {\n                return;\n            }\n            _p[a] = _p[b];\n            _p[b] = _pa;\n        };\n        swap('zoom', 'startZoom');\n        swap('pan', 'startPan');\n        swap('position', 'startPosition');\n        // swap styles\n        if (_p.style) {\n            for(var i = 0; i < _p.style.length; i++){\n                var prop = _p.style[i];\n                var name = prop.name;\n                var startStyleProp = _p.startStyle[name];\n                _p.startStyle[name] = prop;\n                _p.style[i] = startStyleProp;\n            }\n        }\n        if (wasPlaying) {\n            this.play();\n        }\n        return this;\n    },\n    promise: function promise(type) {\n        var _p = this._private;\n        var arr;\n        switch(type){\n            case 'frame':\n                arr = _p.frames;\n                break;\n            default:\n            case 'complete':\n            case 'completed':\n                arr = _p.completes;\n        }\n        return new Promise$1(function(resolve, reject) {\n            arr.push(function() {\n                resolve();\n            });\n        });\n    }\n});\nanifn.complete = anifn.completed;\nanifn.run = anifn.play;\nanifn.running = anifn.playing;\nvar define$3 = {\n    animated: function animated() {\n        return function animatedImpl() {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return false;\n            }\n            var ele = all[0];\n            if (ele) {\n                return ele._private.animation.current.length > 0;\n            }\n        };\n    },\n    // animated\n    clearQueue: function clearQueue() {\n        return function clearQueueImpl() {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            for(var i = 0; i < all.length; i++){\n                var ele = all[i];\n                ele._private.animation.queue = [];\n            }\n            return this;\n        };\n    },\n    // clearQueue\n    delay: function delay() {\n        return function delayImpl(time, complete) {\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            return this.animate({\n                delay: time,\n                duration: time,\n                complete: complete\n            });\n        };\n    },\n    // delay\n    delayAnimation: function delayAnimation() {\n        return function delayAnimationImpl(time, complete) {\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            return this.animation({\n                delay: time,\n                duration: time,\n                complete: complete\n            });\n        };\n    },\n    // delay\n    animation: function animation() {\n        return function animationImpl(properties, params) {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            var isCore = !selfIsArrayLike;\n            var isEles = !isCore;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            var style = cy.style();\n            properties = extend({}, properties, params);\n            var propertiesEmpty = Object.keys(properties).length === 0;\n            if (propertiesEmpty) {\n                return new Animation(all[0], properties); // nothing to animate\n            }\n            if (properties.duration === undefined) {\n                properties.duration = 400;\n            }\n            switch(properties.duration){\n                case 'slow':\n                    properties.duration = 600;\n                    break;\n                case 'fast':\n                    properties.duration = 200;\n                    break;\n            }\n            if (isEles) {\n                properties.style = style.getPropsList(properties.style || properties.css);\n                properties.css = undefined;\n            }\n            if (isEles && properties.renderedPosition != null) {\n                var rpos = properties.renderedPosition;\n                var pan = cy.pan();\n                var zoom = cy.zoom();\n                properties.position = renderedToModelPosition(rpos, zoom, pan);\n            }\n            // override pan w/ panBy if set\n            if (isCore && properties.panBy != null) {\n                var panBy = properties.panBy;\n                var cyPan = cy.pan();\n                properties.pan = {\n                    x: cyPan.x + panBy.x,\n                    y: cyPan.y + panBy.y\n                };\n            }\n            // override pan w/ center if set\n            var center = properties.center || properties.centre;\n            if (isCore && center != null) {\n                var centerPan = cy.getCenterPan(center.eles, properties.zoom);\n                if (centerPan != null) {\n                    properties.pan = centerPan;\n                }\n            }\n            // override pan & zoom w/ fit if set\n            if (isCore && properties.fit != null) {\n                var fit = properties.fit;\n                var fitVp = cy.getFitViewport(fit.eles || fit.boundingBox, fit.padding);\n                if (fitVp != null) {\n                    properties.pan = fitVp.pan;\n                    properties.zoom = fitVp.zoom;\n                }\n            }\n            // override zoom (& potentially pan) w/ zoom obj if set\n            if (isCore && plainObject(properties.zoom)) {\n                var vp = cy.getZoomedViewport(properties.zoom);\n                if (vp != null) {\n                    if (vp.zoomed) {\n                        properties.zoom = vp.zoom;\n                    }\n                    if (vp.panned) {\n                        properties.pan = vp.pan;\n                    }\n                } else {\n                    properties.zoom = null; // an inavalid zoom (e.g. no delta) gets automatically destroyed\n                }\n            }\n            return new Animation(all[0], properties);\n        };\n    },\n    // animate\n    animate: function animate() {\n        return function animateImpl(properties, params) {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            if (params) {\n                properties = extend({}, properties, params);\n            }\n            // manually hook and run the animation\n            for(var i = 0; i < all.length; i++){\n                var ele = all[i];\n                var queue = ele.animated() && (properties.queue === undefined || properties.queue);\n                var ani = ele.animation(properties, queue ? {\n                    queue: true\n                } : undefined);\n                ani.play();\n            }\n            return this; // chaining\n        };\n    },\n    // animate\n    stop: function stop() {\n        return function stopImpl(clearQueue, jumpToEnd) {\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var cy = this._private.cy || this;\n            if (!cy.styleEnabled()) {\n                return this;\n            }\n            for(var i = 0; i < all.length; i++){\n                var ele = all[i];\n                var _p = ele._private;\n                var anis = _p.animation.current;\n                for(var j = 0; j < anis.length; j++){\n                    var ani = anis[j];\n                    var ani_p = ani._private;\n                    if (jumpToEnd) {\n                        // next iteration of the animation loop, the animation\n                        // will go straight to the end and be removed\n                        ani_p.duration = 0;\n                    }\n                }\n                // clear the queue of future animations\n                if (clearQueue) {\n                    _p.animation.queue = [];\n                }\n                if (!jumpToEnd) {\n                    _p.animation.current = [];\n                }\n            }\n            // we have to notify (the animation loop doesn't do it for us on `stop`)\n            cy.notify('draw');\n            return this;\n        };\n    } // stop\n}; // define\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */ var isArray_1;\nvar hasRequiredIsArray;\nfunction requireIsArray() {\n    if (hasRequiredIsArray) return isArray_1;\n    hasRequiredIsArray = 1;\n    var isArray = Array.isArray;\n    isArray_1 = isArray;\n    return isArray_1;\n}\nvar _isKey;\nvar hasRequired_isKey;\nfunction require_isKey() {\n    if (hasRequired_isKey) return _isKey;\n    hasRequired_isKey = 1;\n    var isArray = requireIsArray(), isSymbol = requireIsSymbol();\n    /** Used to match property names within property paths. */ var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/;\n    /**\n\t * Checks if `value` is a property name and not a property path.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n\t */ function isKey(value, object) {\n        if (isArray(value)) {\n            return false;\n        }\n        var type = typeof value;\n        if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n            return true;\n        }\n        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n    }\n    _isKey = isKey;\n    return _isKey;\n}\nvar isFunction_1;\nvar hasRequiredIsFunction;\nfunction requireIsFunction() {\n    if (hasRequiredIsFunction) return isFunction_1;\n    hasRequiredIsFunction = 1;\n    var baseGetTag = require_baseGetTag(), isObject = requireIsObject();\n    /** `Object#toString` result references. */ var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';\n    /**\n\t * Checks if `value` is classified as a `Function` object.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Lang\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n\t * @example\n\t *\n\t * _.isFunction(_);\n\t * // => true\n\t *\n\t * _.isFunction(/abc/);\n\t * // => false\n\t */ function isFunction(value) {\n        if (!isObject(value)) {\n            return false;\n        }\n        // The use of `Object#toString` avoids issues with the `typeof` operator\n        // in Safari 9 which returns 'object' for typed arrays and other constructors.\n        var tag = baseGetTag(value);\n        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n    isFunction_1 = isFunction;\n    return isFunction_1;\n}\nvar _coreJsData;\nvar hasRequired_coreJsData;\nfunction require_coreJsData() {\n    if (hasRequired_coreJsData) return _coreJsData;\n    hasRequired_coreJsData = 1;\n    var root = require_root();\n    /** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];\n    _coreJsData = coreJsData;\n    return _coreJsData;\n}\nvar _isMasked;\nvar hasRequired_isMasked;\nfunction require_isMasked() {\n    if (hasRequired_isMasked) return _isMasked;\n    hasRequired_isMasked = 1;\n    var coreJsData = require_coreJsData();\n    /** Used to detect methods masquerading as native. */ var maskSrcKey = function() {\n        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n        return uid ? 'Symbol(src)_1.' + uid : '';\n    }();\n    /**\n\t * Checks if `func` has its source masked.\n\t *\n\t * @private\n\t * @param {Function} func The function to check.\n\t * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n\t */ function isMasked(func) {\n        return !!maskSrcKey && maskSrcKey in func;\n    }\n    _isMasked = isMasked;\n    return _isMasked;\n}\n/** Used for built-in method references. */ var _toSource;\nvar hasRequired_toSource;\nfunction require_toSource() {\n    if (hasRequired_toSource) return _toSource;\n    hasRequired_toSource = 1;\n    var funcProto = Function.prototype;\n    /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n    /**\n\t * Converts `func` to its source code.\n\t *\n\t * @private\n\t * @param {Function} func The function to convert.\n\t * @returns {string} Returns the source code.\n\t */ function toSource(func) {\n        if (func != null) {\n            try {\n                return funcToString.call(func);\n            } catch (e) {}\n            try {\n                return func + '';\n            } catch (e) {}\n        }\n        return '';\n    }\n    _toSource = toSource;\n    return _toSource;\n}\nvar _baseIsNative;\nvar hasRequired_baseIsNative;\nfunction require_baseIsNative() {\n    if (hasRequired_baseIsNative) return _baseIsNative;\n    hasRequired_baseIsNative = 1;\n    var isFunction = requireIsFunction(), isMasked = require_isMasked(), isObject = requireIsObject(), toSource = require_toSource();\n    /**\n\t * Used to match `RegExp`\n\t * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n\t */ var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    /** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    /** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;\n    /** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n    /**\n\t * The base implementation of `_.isNative` without bad shim checks.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @returns {boolean} Returns `true` if `value` is a native function,\n\t *  else `false`.\n\t */ function baseIsNative(value) {\n        if (!isObject(value) || isMasked(value)) {\n            return false;\n        }\n        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n        return pattern.test(toSource(value));\n    }\n    _baseIsNative = baseIsNative;\n    return _baseIsNative;\n}\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */ var _getValue;\nvar hasRequired_getValue;\nfunction require_getValue() {\n    if (hasRequired_getValue) return _getValue;\n    hasRequired_getValue = 1;\n    function getValue(object, key) {\n        return object == null ? undefined : object[key];\n    }\n    _getValue = getValue;\n    return _getValue;\n}\nvar _getNative;\nvar hasRequired_getNative;\nfunction require_getNative() {\n    if (hasRequired_getNative) return _getNative;\n    hasRequired_getNative = 1;\n    var baseIsNative = require_baseIsNative(), getValue = require_getValue();\n    /**\n\t * Gets the native function at `key` of `object`.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {string} key The key of the method to get.\n\t * @returns {*} Returns the function if it's native, else `undefined`.\n\t */ function getNative(object, key) {\n        var value = getValue(object, key);\n        return baseIsNative(value) ? value : undefined;\n    }\n    _getNative = getNative;\n    return _getNative;\n}\nvar _nativeCreate;\nvar hasRequired_nativeCreate;\nfunction require_nativeCreate() {\n    if (hasRequired_nativeCreate) return _nativeCreate;\n    hasRequired_nativeCreate = 1;\n    var getNative = require_getNative();\n    /* Built-in method references that are verified to be native. */ var nativeCreate = getNative(Object, 'create');\n    _nativeCreate = nativeCreate;\n    return _nativeCreate;\n}\nvar _hashClear;\nvar hasRequired_hashClear;\nfunction require_hashClear() {\n    if (hasRequired_hashClear) return _hashClear;\n    hasRequired_hashClear = 1;\n    var nativeCreate = require_nativeCreate();\n    /**\n\t * Removes all key-value entries from the hash.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf Hash\n\t */ function hashClear() {\n        this.__data__ = nativeCreate ? nativeCreate(null) : {};\n        this.size = 0;\n    }\n    _hashClear = hashClear;\n    return _hashClear;\n}\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */ var _hashDelete;\nvar hasRequired_hashDelete;\nfunction require_hashDelete() {\n    if (hasRequired_hashDelete) return _hashDelete;\n    hasRequired_hashDelete = 1;\n    function hashDelete(key) {\n        var result = this.has(key) && delete this.__data__[key];\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    _hashDelete = hashDelete;\n    return _hashDelete;\n}\nvar _hashGet;\nvar hasRequired_hashGet;\nfunction require_hashGet() {\n    if (hasRequired_hashGet) return _hashGet;\n    hasRequired_hashGet = 1;\n    var nativeCreate = require_nativeCreate();\n    /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Gets the hash value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */ function hashGet(key) {\n        var data = this.__data__;\n        if (nativeCreate) {\n            var result = data[key];\n            return result === HASH_UNDEFINED ? undefined : result;\n        }\n        return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n    _hashGet = hashGet;\n    return _hashGet;\n}\nvar _hashHas;\nvar hasRequired_hashHas;\nfunction require_hashHas() {\n    if (hasRequired_hashHas) return _hashHas;\n    hasRequired_hashHas = 1;\n    var nativeCreate = require_nativeCreate();\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Checks if a hash value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf Hash\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */ function hashHas(key) {\n        var data = this.__data__;\n        return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n    }\n    _hashHas = hashHas;\n    return _hashHas;\n}\nvar _hashSet;\nvar hasRequired_hashSet;\nfunction require_hashSet() {\n    if (hasRequired_hashSet) return _hashSet;\n    hasRequired_hashSet = 1;\n    var nativeCreate = require_nativeCreate();\n    /** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';\n    /**\n\t * Sets the hash `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf Hash\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the hash instance.\n\t */ function hashSet(key, value) {\n        var data = this.__data__;\n        this.size += this.has(key) ? 0 : 1;\n        data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n        return this;\n    }\n    _hashSet = hashSet;\n    return _hashSet;\n}\nvar _Hash;\nvar hasRequired_Hash;\nfunction require_Hash() {\n    if (hasRequired_Hash) return _Hash;\n    hasRequired_Hash = 1;\n    var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();\n    /**\n\t * Creates a hash object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */ function Hash(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n    _Hash = Hash;\n    return _Hash;\n}\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */ var _listCacheClear;\nvar hasRequired_listCacheClear;\nfunction require_listCacheClear() {\n    if (hasRequired_listCacheClear) return _listCacheClear;\n    hasRequired_listCacheClear = 1;\n    function listCacheClear() {\n        this.__data__ = [];\n        this.size = 0;\n    }\n    _listCacheClear = listCacheClear;\n    return _listCacheClear;\n}\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */ var eq_1;\nvar hasRequiredEq;\nfunction requireEq() {\n    if (hasRequiredEq) return eq_1;\n    hasRequiredEq = 1;\n    function eq(value, other) {\n        return value === other || value !== value && other !== other;\n    }\n    eq_1 = eq;\n    return eq_1;\n}\nvar _assocIndexOf;\nvar hasRequired_assocIndexOf;\nfunction require_assocIndexOf() {\n    if (hasRequired_assocIndexOf) return _assocIndexOf;\n    hasRequired_assocIndexOf = 1;\n    var eq = requireEq();\n    /**\n\t * Gets the index at which the `key` is found in `array` of key-value pairs.\n\t *\n\t * @private\n\t * @param {Array} array The array to inspect.\n\t * @param {*} key The key to search for.\n\t * @returns {number} Returns the index of the matched value, else `-1`.\n\t */ function assocIndexOf(array, key) {\n        var length = array.length;\n        while(length--){\n            if (eq(array[length][0], key)) {\n                return length;\n            }\n        }\n        return -1;\n    }\n    _assocIndexOf = assocIndexOf;\n    return _assocIndexOf;\n}\nvar _listCacheDelete;\nvar hasRequired_listCacheDelete;\nfunction require_listCacheDelete() {\n    if (hasRequired_listCacheDelete) return _listCacheDelete;\n    hasRequired_listCacheDelete = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /** Used for built-in method references. */ var arrayProto = Array.prototype;\n    /** Built-in value references. */ var splice = arrayProto.splice;\n    /**\n\t * Removes `key` and its value from the list cache.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */ function listCacheDelete(key) {\n        var data = this.__data__, index = assocIndexOf(data, key);\n        if (index < 0) {\n            return false;\n        }\n        var lastIndex = data.length - 1;\n        if (index == lastIndex) {\n            data.pop();\n        } else {\n            splice.call(data, index, 1);\n        }\n        --this.size;\n        return true;\n    }\n    _listCacheDelete = listCacheDelete;\n    return _listCacheDelete;\n}\nvar _listCacheGet;\nvar hasRequired_listCacheGet;\nfunction require_listCacheGet() {\n    if (hasRequired_listCacheGet) return _listCacheGet;\n    hasRequired_listCacheGet = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /**\n\t * Gets the list cache value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */ function listCacheGet(key) {\n        var data = this.__data__, index = assocIndexOf(data, key);\n        return index < 0 ? undefined : data[index][1];\n    }\n    _listCacheGet = listCacheGet;\n    return _listCacheGet;\n}\nvar _listCacheHas;\nvar hasRequired_listCacheHas;\nfunction require_listCacheHas() {\n    if (hasRequired_listCacheHas) return _listCacheHas;\n    hasRequired_listCacheHas = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /**\n\t * Checks if a list cache value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf ListCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */ function listCacheHas(key) {\n        return assocIndexOf(this.__data__, key) > -1;\n    }\n    _listCacheHas = listCacheHas;\n    return _listCacheHas;\n}\nvar _listCacheSet;\nvar hasRequired_listCacheSet;\nfunction require_listCacheSet() {\n    if (hasRequired_listCacheSet) return _listCacheSet;\n    hasRequired_listCacheSet = 1;\n    var assocIndexOf = require_assocIndexOf();\n    /**\n\t * Sets the list cache `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf ListCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the list cache instance.\n\t */ function listCacheSet(key, value) {\n        var data = this.__data__, index = assocIndexOf(data, key);\n        if (index < 0) {\n            ++this.size;\n            data.push([\n                key,\n                value\n            ]);\n        } else {\n            data[index][1] = value;\n        }\n        return this;\n    }\n    _listCacheSet = listCacheSet;\n    return _listCacheSet;\n}\nvar _ListCache;\nvar hasRequired_ListCache;\nfunction require_ListCache() {\n    if (hasRequired_ListCache) return _ListCache;\n    hasRequired_ListCache = 1;\n    var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();\n    /**\n\t * Creates an list cache object.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */ function ListCache(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n    _ListCache = ListCache;\n    return _ListCache;\n}\nvar _Map;\nvar hasRequired_Map;\nfunction require_Map() {\n    if (hasRequired_Map) return _Map;\n    hasRequired_Map = 1;\n    var getNative = require_getNative(), root = require_root();\n    /* Built-in method references that are verified to be native. */ var Map1 = getNative(root, 'Map');\n    _Map = Map1;\n    return _Map;\n}\nvar _mapCacheClear;\nvar hasRequired_mapCacheClear;\nfunction require_mapCacheClear() {\n    if (hasRequired_mapCacheClear) return _mapCacheClear;\n    hasRequired_mapCacheClear = 1;\n    var Hash = require_Hash(), ListCache = require_ListCache(), Map1 = require_Map();\n    /**\n\t * Removes all key-value entries from the map.\n\t *\n\t * @private\n\t * @name clear\n\t * @memberOf MapCache\n\t */ function mapCacheClear() {\n        this.size = 0;\n        this.__data__ = {\n            'hash': new Hash,\n            'map': new (Map1 || ListCache),\n            'string': new Hash\n        };\n    }\n    _mapCacheClear = mapCacheClear;\n    return _mapCacheClear;\n}\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */ var _isKeyable;\nvar hasRequired_isKeyable;\nfunction require_isKeyable() {\n    if (hasRequired_isKeyable) return _isKeyable;\n    hasRequired_isKeyable = 1;\n    function isKeyable(value) {\n        var type = typeof value;\n        return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n    }\n    _isKeyable = isKeyable;\n    return _isKeyable;\n}\nvar _getMapData;\nvar hasRequired_getMapData;\nfunction require_getMapData() {\n    if (hasRequired_getMapData) return _getMapData;\n    hasRequired_getMapData = 1;\n    var isKeyable = require_isKeyable();\n    /**\n\t * Gets the data for `map`.\n\t *\n\t * @private\n\t * @param {Object} map The map to query.\n\t * @param {string} key The reference key.\n\t * @returns {*} Returns the map data.\n\t */ function getMapData(map, key) {\n        var data = map.__data__;\n        return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n    }\n    _getMapData = getMapData;\n    return _getMapData;\n}\nvar _mapCacheDelete;\nvar hasRequired_mapCacheDelete;\nfunction require_mapCacheDelete() {\n    if (hasRequired_mapCacheDelete) return _mapCacheDelete;\n    hasRequired_mapCacheDelete = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Removes `key` and its value from the map.\n\t *\n\t * @private\n\t * @name delete\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to remove.\n\t * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n\t */ function mapCacheDelete(key) {\n        var result = getMapData(this, key)['delete'](key);\n        this.size -= result ? 1 : 0;\n        return result;\n    }\n    _mapCacheDelete = mapCacheDelete;\n    return _mapCacheDelete;\n}\nvar _mapCacheGet;\nvar hasRequired_mapCacheGet;\nfunction require_mapCacheGet() {\n    if (hasRequired_mapCacheGet) return _mapCacheGet;\n    hasRequired_mapCacheGet = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Gets the map value for `key`.\n\t *\n\t * @private\n\t * @name get\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to get.\n\t * @returns {*} Returns the entry value.\n\t */ function mapCacheGet(key) {\n        return getMapData(this, key).get(key);\n    }\n    _mapCacheGet = mapCacheGet;\n    return _mapCacheGet;\n}\nvar _mapCacheHas;\nvar hasRequired_mapCacheHas;\nfunction require_mapCacheHas() {\n    if (hasRequired_mapCacheHas) return _mapCacheHas;\n    hasRequired_mapCacheHas = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Checks if a map value for `key` exists.\n\t *\n\t * @private\n\t * @name has\n\t * @memberOf MapCache\n\t * @param {string} key The key of the entry to check.\n\t * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n\t */ function mapCacheHas(key) {\n        return getMapData(this, key).has(key);\n    }\n    _mapCacheHas = mapCacheHas;\n    return _mapCacheHas;\n}\nvar _mapCacheSet;\nvar hasRequired_mapCacheSet;\nfunction require_mapCacheSet() {\n    if (hasRequired_mapCacheSet) return _mapCacheSet;\n    hasRequired_mapCacheSet = 1;\n    var getMapData = require_getMapData();\n    /**\n\t * Sets the map `key` to `value`.\n\t *\n\t * @private\n\t * @name set\n\t * @memberOf MapCache\n\t * @param {string} key The key of the value to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns the map cache instance.\n\t */ function mapCacheSet(key, value) {\n        var data = getMapData(this, key), size = data.size;\n        data.set(key, value);\n        this.size += data.size == size ? 0 : 1;\n        return this;\n    }\n    _mapCacheSet = mapCacheSet;\n    return _mapCacheSet;\n}\nvar _MapCache;\nvar hasRequired_MapCache;\nfunction require_MapCache() {\n    if (hasRequired_MapCache) return _MapCache;\n    hasRequired_MapCache = 1;\n    var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();\n    /**\n\t * Creates a map cache object to store key-value pairs.\n\t *\n\t * @private\n\t * @constructor\n\t * @param {Array} [entries] The key-value pairs to cache.\n\t */ function MapCache(entries) {\n        var index = -1, length = entries == null ? 0 : entries.length;\n        this.clear();\n        while(++index < length){\n            var entry = entries[index];\n            this.set(entry[0], entry[1]);\n        }\n    }\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n    _MapCache = MapCache;\n    return _MapCache;\n}\nvar memoize_1;\nvar hasRequiredMemoize;\nfunction requireMemoize() {\n    if (hasRequiredMemoize) return memoize_1;\n    hasRequiredMemoize = 1;\n    var MapCache = require_MapCache();\n    /** Error message constants. */ var FUNC_ERROR_TEXT = 'Expected a function';\n    /**\n\t * Creates a function that memoizes the result of `func`. If `resolver` is\n\t * provided, it determines the cache key for storing the result based on the\n\t * arguments provided to the memoized function. By default, the first argument\n\t * provided to the memoized function is used as the map cache key. The `func`\n\t * is invoked with the `this` binding of the memoized function.\n\t *\n\t * **Note:** The cache is exposed as the `cache` property on the memoized\n\t * function. Its creation may be customized by replacing the `_.memoize.Cache`\n\t * constructor with one whose instances implement the\n\t * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n\t * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 0.1.0\n\t * @category Function\n\t * @param {Function} func The function to have its output memoized.\n\t * @param {Function} [resolver] The function to resolve the cache key.\n\t * @returns {Function} Returns the new memoized function.\n\t * @example\n\t *\n\t * var object = { 'a': 1, 'b': 2 };\n\t * var other = { 'c': 3, 'd': 4 };\n\t *\n\t * var values = _.memoize(_.values);\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * values(other);\n\t * // => [3, 4]\n\t *\n\t * object.a = 2;\n\t * values(object);\n\t * // => [1, 2]\n\t *\n\t * // Modify the result cache.\n\t * values.cache.set(object, ['a', 'b']);\n\t * values(object);\n\t * // => ['a', 'b']\n\t *\n\t * // Replace `_.memoize.Cache`.\n\t * _.memoize.Cache = WeakMap;\n\t */ function memoize(func, resolver) {\n        if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        var memoized = function() {\n            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n            if (cache.has(key)) {\n                return cache.get(key);\n            }\n            var result = func.apply(this, args);\n            memoized.cache = cache.set(key, result) || cache;\n            return result;\n        };\n        memoized.cache = new (memoize.Cache || MapCache);\n        return memoized;\n    }\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n    memoize_1 = memoize;\n    return memoize_1;\n}\nvar _memoizeCapped;\nvar hasRequired_memoizeCapped;\nfunction require_memoizeCapped() {\n    if (hasRequired_memoizeCapped) return _memoizeCapped;\n    hasRequired_memoizeCapped = 1;\n    var memoize = requireMemoize();\n    /** Used as the maximum memoize cache size. */ var MAX_MEMOIZE_SIZE = 500;\n    /**\n\t * A specialized version of `_.memoize` which clears the memoized function's\n\t * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n\t *\n\t * @private\n\t * @param {Function} func The function to have its output memoized.\n\t * @returns {Function} Returns the new memoized function.\n\t */ function memoizeCapped(func) {\n        var result = memoize(func, function(key) {\n            if (cache.size === MAX_MEMOIZE_SIZE) {\n                cache.clear();\n            }\n            return key;\n        });\n        var cache = result.cache;\n        return result;\n    }\n    _memoizeCapped = memoizeCapped;\n    return _memoizeCapped;\n}\nvar _stringToPath;\nvar hasRequired_stringToPath;\nfunction require_stringToPath() {\n    if (hasRequired_stringToPath) return _stringToPath;\n    hasRequired_stringToPath = 1;\n    var memoizeCapped = require_memoizeCapped();\n    /** Used to match property names within property paths. */ var rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    /** Used to match backslashes in property paths. */ var reEscapeChar = /\\\\(\\\\)?/g;\n    /**\n\t * Converts `string` to a property path array.\n\t *\n\t * @private\n\t * @param {string} string The string to convert.\n\t * @returns {Array} Returns the property path array.\n\t */ var stringToPath = memoizeCapped(function(string) {\n        var result = [];\n        if (string.charCodeAt(0) === 46 /* . */ ) {\n            result.push('');\n        }\n        string.replace(rePropName, function(match, number, quote, subString) {\n            result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);\n        });\n        return result;\n    });\n    _stringToPath = stringToPath;\n    return _stringToPath;\n}\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */ var _arrayMap;\nvar hasRequired_arrayMap;\nfunction require_arrayMap() {\n    if (hasRequired_arrayMap) return _arrayMap;\n    hasRequired_arrayMap = 1;\n    function arrayMap(array, iteratee) {\n        var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n        while(++index < length){\n            result[index] = iteratee(array[index], index, array);\n        }\n        return result;\n    }\n    _arrayMap = arrayMap;\n    return _arrayMap;\n}\nvar _baseToString;\nvar hasRequired_baseToString;\nfunction require_baseToString() {\n    if (hasRequired_baseToString) return _baseToString;\n    hasRequired_baseToString = 1;\n    var Symbol1 = require_Symbol(), arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();\n    /** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol1 ? Symbol1.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;\n    /**\n\t * The base implementation of `_.toString` which doesn't convert nullish\n\t * values to empty strings.\n\t *\n\t * @private\n\t * @param {*} value The value to process.\n\t * @returns {string} Returns the string.\n\t */ function baseToString(value) {\n        // Exit early for strings to avoid a performance hit in some environments.\n        if (typeof value == 'string') {\n            return value;\n        }\n        if (isArray(value)) {\n            // Recursively convert values (susceptible to call stack limits).\n            return arrayMap(value, baseToString) + '';\n        }\n        if (isSymbol(value)) {\n            return symbolToString ? symbolToString.call(value) : '';\n        }\n        var result = value + '';\n        return result == '0' && 1 / value == -Infinity ? '-0' : result;\n    }\n    _baseToString = baseToString;\n    return _baseToString;\n}\nvar toString_1;\nvar hasRequiredToString;\nfunction requireToString() {\n    if (hasRequiredToString) return toString_1;\n    hasRequiredToString = 1;\n    var baseToString = require_baseToString();\n    /**\n\t * Converts `value` to a string. An empty string is returned for `null`\n\t * and `undefined` values. The sign of `-0` is preserved.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Lang\n\t * @param {*} value The value to convert.\n\t * @returns {string} Returns the converted string.\n\t * @example\n\t *\n\t * _.toString(null);\n\t * // => ''\n\t *\n\t * _.toString(-0);\n\t * // => '-0'\n\t *\n\t * _.toString([1, 2, 3]);\n\t * // => '1,2,3'\n\t */ function toString(value) {\n        return value == null ? '' : baseToString(value);\n    }\n    toString_1 = toString;\n    return toString_1;\n}\nvar _castPath;\nvar hasRequired_castPath;\nfunction require_castPath() {\n    if (hasRequired_castPath) return _castPath;\n    hasRequired_castPath = 1;\n    var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString = requireToString();\n    /**\n\t * Casts `value` to a path array if it's not one.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @param {Object} [object] The object to query keys on.\n\t * @returns {Array} Returns the cast property path array.\n\t */ function castPath(value, object) {\n        if (isArray(value)) {\n            return value;\n        }\n        return isKey(value, object) ? [\n            value\n        ] : stringToPath(toString(value));\n    }\n    _castPath = castPath;\n    return _castPath;\n}\nvar _toKey;\nvar hasRequired_toKey;\nfunction require_toKey() {\n    if (hasRequired_toKey) return _toKey;\n    hasRequired_toKey = 1;\n    var isSymbol = requireIsSymbol();\n    /**\n\t * Converts `value` to a string key if it's not a string or symbol.\n\t *\n\t * @private\n\t * @param {*} value The value to inspect.\n\t * @returns {string|symbol} Returns the key.\n\t */ function toKey(value) {\n        if (typeof value == 'string' || isSymbol(value)) {\n            return value;\n        }\n        var result = value + '';\n        return result == '0' && 1 / value == -Infinity ? '-0' : result;\n    }\n    _toKey = toKey;\n    return _toKey;\n}\nvar _baseGet;\nvar hasRequired_baseGet;\nfunction require_baseGet() {\n    if (hasRequired_baseGet) return _baseGet;\n    hasRequired_baseGet = 1;\n    var castPath = require_castPath(), toKey = require_toKey();\n    /**\n\t * The base implementation of `_.get` without support for default values.\n\t *\n\t * @private\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @returns {*} Returns the resolved value.\n\t */ function baseGet(object, path) {\n        path = castPath(path, object);\n        var index = 0, length = path.length;\n        while(object != null && index < length){\n            object = object[toKey(path[index++])];\n        }\n        return index && index == length ? object : undefined;\n    }\n    _baseGet = baseGet;\n    return _baseGet;\n}\nvar get_1;\nvar hasRequiredGet;\nfunction requireGet() {\n    if (hasRequiredGet) return get_1;\n    hasRequiredGet = 1;\n    var baseGet = require_baseGet();\n    /**\n\t * Gets the value at `path` of `object`. If the resolved value is\n\t * `undefined`, the `defaultValue` is returned in its place.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.7.0\n\t * @category Object\n\t * @param {Object} object The object to query.\n\t * @param {Array|string} path The path of the property to get.\n\t * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n\t * @returns {*} Returns the resolved value.\n\t * @example\n\t *\n\t * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t *\n\t * _.get(object, 'a[0].b.c');\n\t * // => 3\n\t *\n\t * _.get(object, ['a', '0', 'b', 'c']);\n\t * // => 3\n\t *\n\t * _.get(object, 'a.b.c', 'default');\n\t * // => 'default'\n\t */ function get(object, path, defaultValue) {\n        var result = object == null ? undefined : baseGet(object, path);\n        return result === undefined ? defaultValue : result;\n    }\n    get_1 = get;\n    return get_1;\n}\nvar getExports = requireGet();\nvar get = /*@__PURE__*/ getDefaultExportFromCjs(getExports);\nvar _defineProperty;\nvar hasRequired_defineProperty;\nfunction require_defineProperty() {\n    if (hasRequired_defineProperty) return _defineProperty;\n    hasRequired_defineProperty = 1;\n    var getNative = require_getNative();\n    var defineProperty = function() {\n        try {\n            var func = getNative(Object, 'defineProperty');\n            func({}, '', {});\n            return func;\n        } catch (e) {}\n    }();\n    _defineProperty = defineProperty;\n    return _defineProperty;\n}\nvar _baseAssignValue;\nvar hasRequired_baseAssignValue;\nfunction require_baseAssignValue() {\n    if (hasRequired_baseAssignValue) return _baseAssignValue;\n    hasRequired_baseAssignValue = 1;\n    var defineProperty = require_defineProperty();\n    /**\n\t * The base implementation of `assignValue` and `assignMergeValue` without\n\t * value checks.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */ function baseAssignValue(object, key, value) {\n        if (key == '__proto__' && defineProperty) {\n            defineProperty(object, key, {\n                'configurable': true,\n                'enumerable': true,\n                'value': value,\n                'writable': true\n            });\n        } else {\n            object[key] = value;\n        }\n    }\n    _baseAssignValue = baseAssignValue;\n    return _baseAssignValue;\n}\nvar _assignValue;\nvar hasRequired_assignValue;\nfunction require_assignValue() {\n    if (hasRequired_assignValue) return _assignValue;\n    hasRequired_assignValue = 1;\n    var baseAssignValue = require_baseAssignValue(), eq = requireEq();\n    /** Used for built-in method references. */ var objectProto = Object.prototype;\n    /** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n\t * Assigns `value` to `key` of `object` if the existing value is not equivalent\n\t * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n\t * for equality comparisons.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {string} key The key of the property to assign.\n\t * @param {*} value The value to assign.\n\t */ function assignValue(object, key, value) {\n        var objValue = object[key];\n        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {\n            baseAssignValue(object, key, value);\n        }\n    }\n    _assignValue = assignValue;\n    return _assignValue;\n}\n/** Used as references for various `Number` constants. */ var _isIndex;\nvar hasRequired_isIndex;\nfunction require_isIndex() {\n    if (hasRequired_isIndex) return _isIndex;\n    hasRequired_isIndex = 1;\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    /** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    /**\n\t * Checks if `value` is a valid array-like index.\n\t *\n\t * @private\n\t * @param {*} value The value to check.\n\t * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n\t * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n\t */ function isIndex(value, length) {\n        var type = typeof value;\n        length = length == null ? MAX_SAFE_INTEGER : length;\n        return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n    }\n    _isIndex = isIndex;\n    return _isIndex;\n}\nvar _baseSet;\nvar hasRequired_baseSet;\nfunction require_baseSet() {\n    if (hasRequired_baseSet) return _baseSet;\n    hasRequired_baseSet = 1;\n    var assignValue = require_assignValue(), castPath = require_castPath(), isIndex = require_isIndex(), isObject = requireIsObject(), toKey = require_toKey();\n    /**\n\t * The base implementation of `_.set`.\n\t *\n\t * @private\n\t * @param {Object} object The object to modify.\n\t * @param {Array|string} path The path of the property to set.\n\t * @param {*} value The value to set.\n\t * @param {Function} [customizer] The function to customize path creation.\n\t * @returns {Object} Returns `object`.\n\t */ function baseSet(object, path, value, customizer) {\n        if (!isObject(object)) {\n            return object;\n        }\n        path = castPath(path, object);\n        var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n        while(nested != null && ++index < length){\n            var key = toKey(path[index]), newValue = value;\n            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n                return object;\n            }\n            if (index != lastIndex) {\n                var objValue = nested[key];\n                newValue = customizer ? customizer(objValue, key, nested) : undefined;\n                if (newValue === undefined) {\n                    newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n                }\n            }\n            assignValue(nested, key, newValue);\n            nested = nested[key];\n        }\n        return object;\n    }\n    _baseSet = baseSet;\n    return _baseSet;\n}\nvar set_1;\nvar hasRequiredSet;\nfunction requireSet() {\n    if (hasRequiredSet) return set_1;\n    hasRequiredSet = 1;\n    var baseSet = require_baseSet();\n    /**\n\t * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n\t * it's created. Arrays are created for missing index properties while objects\n\t * are created for all other missing properties. Use `_.setWith` to customize\n\t * `path` creation.\n\t *\n\t * **Note:** This method mutates `object`.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 3.7.0\n\t * @category Object\n\t * @param {Object} object The object to modify.\n\t * @param {Array|string} path The path of the property to set.\n\t * @param {*} value The value to set.\n\t * @returns {Object} Returns `object`.\n\t * @example\n\t *\n\t * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n\t *\n\t * _.set(object, 'a[0].b.c', 4);\n\t * console.log(object.a[0].b.c);\n\t * // => 4\n\t *\n\t * _.set(object, ['x', '0', 'y', 'z'], 5);\n\t * console.log(object.x[0].y.z);\n\t * // => 5\n\t */ function set(object, path, value) {\n        return object == null ? object : baseSet(object, path, value);\n    }\n    set_1 = set;\n    return set_1;\n}\nvar setExports = requireSet();\nvar set = /*@__PURE__*/ getDefaultExportFromCjs(setExports);\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */ var _copyArray;\nvar hasRequired_copyArray;\nfunction require_copyArray() {\n    if (hasRequired_copyArray) return _copyArray;\n    hasRequired_copyArray = 1;\n    function copyArray(source, array) {\n        var index = -1, length = source.length;\n        array || (array = Array(length));\n        while(++index < length){\n            array[index] = source[index];\n        }\n        return array;\n    }\n    _copyArray = copyArray;\n    return _copyArray;\n}\nvar toPath_1;\nvar hasRequiredToPath;\nfunction requireToPath() {\n    if (hasRequiredToPath) return toPath_1;\n    hasRequiredToPath = 1;\n    var arrayMap = require_arrayMap(), copyArray = require_copyArray(), isArray = requireIsArray(), isSymbol = requireIsSymbol(), stringToPath = require_stringToPath(), toKey = require_toKey(), toString = requireToString();\n    /**\n\t * Converts `value` to a property path array.\n\t *\n\t * @static\n\t * @memberOf _\n\t * @since 4.0.0\n\t * @category Util\n\t * @param {*} value The value to convert.\n\t * @returns {Array} Returns the new property path array.\n\t * @example\n\t *\n\t * _.toPath('a.b.c');\n\t * // => ['a', 'b', 'c']\n\t *\n\t * _.toPath('a[0].b.c');\n\t * // => ['a', '0', 'b', 'c']\n\t */ function toPath(value) {\n        if (isArray(value)) {\n            return arrayMap(value, toKey);\n        }\n        return isSymbol(value) ? [\n            value\n        ] : copyArray(stringToPath(toString(value)));\n    }\n    toPath_1 = toPath;\n    return toPath_1;\n}\nvar toPathExports = requireToPath();\nvar toPath = /*@__PURE__*/ getDefaultExportFromCjs(toPathExports);\nvar define$2 = {\n    // access data field\n    data: function data(params) {\n        var defaults = {\n            field: 'data',\n            bindingEvent: 'data',\n            allowBinding: false,\n            allowSetting: false,\n            allowGetting: false,\n            settingEvent: 'data',\n            settingTriggersEvent: false,\n            triggerFnName: 'trigger',\n            immutableKeys: {},\n            // key => true if immutable\n            updateStyle: false,\n            beforeGet: function beforeGet(self1) {},\n            beforeSet: function beforeSet(self1, obj) {},\n            onSet: function onSet(self1) {},\n            canSet: function canSet(self1) {\n                return true;\n            }\n        };\n        params = extend({}, defaults, params);\n        return function dataImpl(name, value) {\n            var p = params;\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            var single = selfIsArrayLike ? self1[0] : self1;\n            // .data('foo', ...)\n            if (string(name)) {\n                // set or get property\n                var isPathLike = name.indexOf('.') !== -1; // there might be a normal field with a dot \n                var path = isPathLike && toPath(name);\n                // .data('foo')\n                if (p.allowGetting && value === undefined) {\n                    // get\n                    var ret;\n                    if (single) {\n                        p.beforeGet(single);\n                        // check if it's path and a field with the same name doesn't exist\n                        if (path && single._private[p.field][name] === undefined) {\n                            ret = get(single._private[p.field], path);\n                        } else {\n                            ret = single._private[p.field][name];\n                        }\n                    }\n                    return ret;\n                // .data('foo', 'bar')\n                } else if (p.allowSetting && value !== undefined) {\n                    // set\n                    var valid = !p.immutableKeys[name];\n                    if (valid) {\n                        var change = _defineProperty$1({}, name, value);\n                        p.beforeSet(self1, change);\n                        for(var i = 0, l = all.length; i < l; i++){\n                            var ele = all[i];\n                            if (p.canSet(ele)) {\n                                if (path && single._private[p.field][name] === undefined) {\n                                    set(ele._private[p.field], path, value);\n                                } else {\n                                    ele._private[p.field][name] = value;\n                                }\n                            }\n                        }\n                        // update mappers if asked\n                        if (p.updateStyle) {\n                            self1.updateStyle();\n                        }\n                        // call onSet callback\n                        p.onSet(self1);\n                        if (p.settingTriggersEvent) {\n                            self1[p.triggerFnName](p.settingEvent);\n                        }\n                    }\n                }\n            // .data({ 'foo': 'bar' })\n            } else if (p.allowSetting && plainObject(name)) {\n                // extend\n                var obj = name;\n                var k, v;\n                var keys = Object.keys(obj);\n                p.beforeSet(self1, obj);\n                for(var _i = 0; _i < keys.length; _i++){\n                    k = keys[_i];\n                    v = obj[k];\n                    var _valid = !p.immutableKeys[k];\n                    if (_valid) {\n                        for(var j = 0; j < all.length; j++){\n                            var _ele = all[j];\n                            if (p.canSet(_ele)) {\n                                _ele._private[p.field][k] = v;\n                            }\n                        }\n                    }\n                }\n                // update mappers if asked\n                if (p.updateStyle) {\n                    self1.updateStyle();\n                }\n                // call onSet callback\n                p.onSet(self1);\n                if (p.settingTriggersEvent) {\n                    self1[p.triggerFnName](p.settingEvent);\n                }\n            // .data(function(){ ... })\n            } else if (p.allowBinding && fn$6(name)) {\n                // bind to event\n                var fn = name;\n                self1.on(p.bindingEvent, fn);\n            // .data()\n            } else if (p.allowGetting && name === undefined) {\n                // get whole object\n                var _ret;\n                if (single) {\n                    p.beforeGet(single);\n                    _ret = single._private[p.field];\n                }\n                return _ret;\n            }\n            return self1; // maintain chainability\n        }; // function\n    },\n    // data\n    // remove data field\n    removeData: function removeData(params) {\n        var defaults = {\n            field: 'data',\n            event: 'data',\n            triggerFnName: 'trigger',\n            triggerEvent: false,\n            immutableKeys: {} // key => true if immutable\n        };\n        params = extend({}, defaults, params);\n        return function removeDataImpl(names) {\n            var p = params;\n            var self1 = this;\n            var selfIsArrayLike = self1.length !== undefined;\n            var all = selfIsArrayLike ? self1 : [\n                self1\n            ]; // put in array if not array-like\n            // .removeData('foo bar')\n            if (string(names)) {\n                // then get the list of keys, and delete them\n                var keys = names.split(/\\s+/);\n                var l = keys.length;\n                for(var i = 0; i < l; i++){\n                    // delete each non-empty key\n                    var key = keys[i];\n                    if (emptyString(key)) {\n                        continue;\n                    }\n                    var valid = !p.immutableKeys[key]; // not valid if immutable\n                    if (valid) {\n                        for(var i_a = 0, l_a = all.length; i_a < l_a; i_a++){\n                            all[i_a]._private[p.field][key] = undefined;\n                        }\n                    }\n                }\n                if (p.triggerEvent) {\n                    self1[p.triggerFnName](p.event);\n                }\n            // .removeData()\n            } else if (names === undefined) {\n                // then delete all keys\n                for(var _i_a = 0, _l_a = all.length; _i_a < _l_a; _i_a++){\n                    var _privateFields = all[_i_a]._private[p.field];\n                    var _keys = Object.keys(_privateFields);\n                    for(var _i2 = 0; _i2 < _keys.length; _i2++){\n                        var _key = _keys[_i2];\n                        var validKeyToDelete = !p.immutableKeys[_key];\n                        if (validKeyToDelete) {\n                            _privateFields[_key] = undefined;\n                        }\n                    }\n                }\n                if (p.triggerEvent) {\n                    self1[p.triggerFnName](p.event);\n                }\n            }\n            return self1; // maintain chaining\n        }; // function\n    } // removeData\n}; // define\nvar define$1 = {\n    eventAliasesOn: function eventAliasesOn(proto) {\n        var p = proto;\n        p.addListener = p.listen = p.bind = p.on;\n        p.unlisten = p.unbind = p.off = p.removeListener;\n        p.trigger = p.emit;\n        // this is just a wrapper alias of .on()\n        p.pon = p.promiseOn = function(events, selector) {\n            var self1 = this;\n            var args = Array.prototype.slice.call(arguments, 0);\n            return new Promise$1(function(resolve, reject) {\n                var callback = function callback(e) {\n                    self1.off.apply(self1, offArgs);\n                    resolve(e);\n                };\n                var onArgs = args.concat([\n                    callback\n                ]);\n                var offArgs = onArgs.concat([]);\n                self1.on.apply(self1, onArgs);\n            });\n        };\n    }\n}; // define\n// use this module to cherry pick functions into your prototype\n// (useful for functions shared between the core and collections, for example)\nvar define = {};\n[\n    define$3,\n    define$2,\n    define$1\n].forEach(function(m1) {\n    extend(define, m1);\n});\nvar elesfn$i = {\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop()\n};\nvar elesfn$h = {\n    classes: function classes(_classes) {\n        var self1 = this;\n        if (_classes === undefined) {\n            var ret = [];\n            self1[0]._private.classes.forEach(function(cls) {\n                return ret.push(cls);\n            });\n            return ret;\n        } else if (!array(_classes)) {\n            // extract classes from string\n            _classes = (_classes || '').match(/\\S+/g) || [];\n        }\n        var changed = [];\n        var classesSet = new Set$1(_classes);\n        // check and update each ele\n        for(var j = 0; j < self1.length; j++){\n            var ele = self1[j];\n            var _p = ele._private;\n            var eleClasses = _p.classes;\n            var changedEle = false;\n            // check if ele has all of the passed classes\n            for(var i = 0; i < _classes.length; i++){\n                var cls = _classes[i];\n                var eleHasClass = eleClasses.has(cls);\n                if (!eleHasClass) {\n                    changedEle = true;\n                    break;\n                }\n            }\n            // check if ele has classes outside of those passed\n            if (!changedEle) {\n                changedEle = eleClasses.size !== _classes.length;\n            }\n            if (changedEle) {\n                _p.classes = classesSet;\n                changed.push(ele);\n            }\n        }\n        // trigger update style on those eles that had class changes\n        if (changed.length > 0) {\n            this.spawn(changed).updateStyle().emit('class');\n        }\n        return self1;\n    },\n    addClass: function addClass(classes) {\n        return this.toggleClass(classes, true);\n    },\n    hasClass: function hasClass(className) {\n        var ele = this[0];\n        return ele != null && ele._private.classes.has(className);\n    },\n    toggleClass: function toggleClass(classes, toggle) {\n        if (!array(classes)) {\n            // extract classes from string\n            classes = classes.match(/\\S+/g) || [];\n        }\n        var self1 = this;\n        var toggleUndefd = toggle === undefined;\n        var changed = []; // eles who had classes changed\n        for(var i = 0, il = self1.length; i < il; i++){\n            var ele = self1[i];\n            var eleClasses = ele._private.classes;\n            var changedEle = false;\n            for(var j = 0; j < classes.length; j++){\n                var cls = classes[j];\n                var hasClass = eleClasses.has(cls);\n                var changedNow = false;\n                if (toggle || toggleUndefd && !hasClass) {\n                    eleClasses.add(cls);\n                    changedNow = true;\n                } else if (!toggle || toggleUndefd && hasClass) {\n                    eleClasses[\"delete\"](cls);\n                    changedNow = true;\n                }\n                if (!changedEle && changedNow) {\n                    changed.push(ele);\n                    changedEle = true;\n                }\n            } // for j classes\n        } // for i eles\n        // trigger update style on those eles that had class changes\n        if (changed.length > 0) {\n            this.spawn(changed).updateStyle().emit('class');\n        }\n        return self1;\n    },\n    removeClass: function removeClass(classes) {\n        return this.toggleClass(classes, false);\n    },\n    flashClass: function flashClass(classes, duration) {\n        var self1 = this;\n        if (duration == null) {\n            duration = 250;\n        } else if (duration === 0) {\n            return self1; // nothing to do really\n        }\n        self1.addClass(classes);\n        setTimeout(function() {\n            self1.removeClass(classes);\n        }, duration);\n        return self1;\n    }\n};\nelesfn$h.className = elesfn$h.classNames = elesfn$h.classes;\n// tokens in the query language\nvar tokens = {\n    metaChar: '[\\\\!\\\\\"\\\\#\\\\$\\\\%\\\\&\\\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\.\\\\/\\\\:\\\\;\\\\<\\\\=\\\\>\\\\?\\\\@\\\\[\\\\]\\\\^\\\\`\\\\{\\\\|\\\\}\\\\~]',\n    // chars we need to escape in let names, etc\n    comparatorOp: '=|\\\\!=|>|>=|<|<=|\\\\$=|\\\\^=|\\\\*=',\n    // binary comparison op (used in data selectors)\n    boolOp: '\\\\?|\\\\!|\\\\^',\n    // boolean (unary) operators (used in data selectors)\n    string: '\"(?:\\\\\\\\\"|[^\"])*\"' + '|' + \"'(?:\\\\\\\\'|[^'])*'\",\n    // string literals (used in data selectors) -- doublequotes | singlequotes\n    number: number,\n    // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123\n    meta: 'degree|indegree|outdegree',\n    // allowed metadata fields (i.e. allowed functions to use from Collection)\n    separator: '\\\\s*,\\\\s*',\n    // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass\n    descendant: '\\\\s+',\n    child: '\\\\s+>\\\\s+',\n    subject: '\\\\$',\n    group: 'node|edge|\\\\*',\n    directedEdge: '\\\\s+->\\\\s+',\n    undirectedEdge: '\\\\s+<->\\\\s+'\n};\ntokens.variable = '(?:[\\\\w-.]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a variable name can have letters, numbers, dashes, and periods\ntokens.className = '(?:[\\\\w-]|(?:\\\\\\\\' + tokens.metaChar + '))+'; // a class name has the same rules as a variable except it can't have a '.' in the name\ntokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number\ntokens.id = tokens.variable; // an element id (follows variable conventions)\n(function() {\n    var ops, op, i;\n    // add @ variants to comparatorOp\n    ops = tokens.comparatorOp.split('|');\n    for(i = 0; i < ops.length; i++){\n        op = ops[i];\n        tokens.comparatorOp += '|@' + op;\n    }\n    // add ! variants to comparatorOp\n    ops = tokens.comparatorOp.split('|');\n    for(i = 0; i < ops.length; i++){\n        op = ops[i];\n        if (op.indexOf('!') >= 0) {\n            continue;\n        } // skip ops that explicitly contain !\n        if (op === '=') {\n            continue;\n        } // skip = b/c != is explicitly defined\n        tokens.comparatorOp += '|\\\\!' + op;\n    }\n})();\n/**\n * Make a new query object\n *\n * @prop type {Type} The type enum (int) of the query\n * @prop checks List of checks to make against an ele to test for a match\n */ var newQuery = function newQuery() {\n    return {\n        checks: []\n    };\n};\n/**\n * A check type enum-like object.  Uses integer values for fast match() lookup.\n * The ordering does not matter as long as the ints are unique.\n */ var Type = {\n    /** E.g. node */ GROUP: 0,\n    /** A collection of elements */ COLLECTION: 1,\n    /** A filter(ele) function */ FILTER: 2,\n    /** E.g. [foo > 1] */ DATA_COMPARE: 3,\n    /** E.g. [foo] */ DATA_EXIST: 4,\n    /** E.g. [?foo] */ DATA_BOOL: 5,\n    /** E.g. [[degree > 2]] */ META_COMPARE: 6,\n    /** E.g. :selected */ STATE: 7,\n    /** E.g. #foo */ ID: 8,\n    /** E.g. .foo */ CLASS: 9,\n    /** E.g. #foo <-> #bar */ UNDIRECTED_EDGE: 10,\n    /** E.g. #foo -> #bar */ DIRECTED_EDGE: 11,\n    /** E.g. $#foo -> #bar */ NODE_SOURCE: 12,\n    /** E.g. #foo -> $#bar */ NODE_TARGET: 13,\n    /** E.g. $#foo <-> #bar */ NODE_NEIGHBOR: 14,\n    /** E.g. #foo > #bar */ CHILD: 15,\n    /** E.g. #foo #bar */ DESCENDANT: 16,\n    /** E.g. $#foo > #bar */ PARENT: 17,\n    /** E.g. $#foo #bar */ ANCESTOR: 18,\n    /** E.g. #foo > $bar > #baz */ COMPOUND_SPLIT: 19,\n    /** Always matches, useful placeholder for subject in `COMPOUND_SPLIT` */ TRUE: 20\n};\nvar stateSelectors = [\n    {\n        selector: ':selected',\n        matches: function matches(ele) {\n            return ele.selected();\n        }\n    },\n    {\n        selector: ':unselected',\n        matches: function matches(ele) {\n            return !ele.selected();\n        }\n    },\n    {\n        selector: ':selectable',\n        matches: function matches(ele) {\n            return ele.selectable();\n        }\n    },\n    {\n        selector: ':unselectable',\n        matches: function matches(ele) {\n            return !ele.selectable();\n        }\n    },\n    {\n        selector: ':locked',\n        matches: function matches(ele) {\n            return ele.locked();\n        }\n    },\n    {\n        selector: ':unlocked',\n        matches: function matches(ele) {\n            return !ele.locked();\n        }\n    },\n    {\n        selector: ':visible',\n        matches: function matches(ele) {\n            return ele.visible();\n        }\n    },\n    {\n        selector: ':hidden',\n        matches: function matches(ele) {\n            return !ele.visible();\n        }\n    },\n    {\n        selector: ':transparent',\n        matches: function matches(ele) {\n            return ele.transparent();\n        }\n    },\n    {\n        selector: ':grabbed',\n        matches: function matches(ele) {\n            return ele.grabbed();\n        }\n    },\n    {\n        selector: ':free',\n        matches: function matches(ele) {\n            return !ele.grabbed();\n        }\n    },\n    {\n        selector: ':removed',\n        matches: function matches(ele) {\n            return ele.removed();\n        }\n    },\n    {\n        selector: ':inside',\n        matches: function matches(ele) {\n            return !ele.removed();\n        }\n    },\n    {\n        selector: ':grabbable',\n        matches: function matches(ele) {\n            return ele.grabbable();\n        }\n    },\n    {\n        selector: ':ungrabbable',\n        matches: function matches(ele) {\n            return !ele.grabbable();\n        }\n    },\n    {\n        selector: ':animated',\n        matches: function matches(ele) {\n            return ele.animated();\n        }\n    },\n    {\n        selector: ':unanimated',\n        matches: function matches(ele) {\n            return !ele.animated();\n        }\n    },\n    {\n        selector: ':parent',\n        matches: function matches(ele) {\n            return ele.isParent();\n        }\n    },\n    {\n        selector: ':childless',\n        matches: function matches(ele) {\n            return ele.isChildless();\n        }\n    },\n    {\n        selector: ':child',\n        matches: function matches(ele) {\n            return ele.isChild();\n        }\n    },\n    {\n        selector: ':orphan',\n        matches: function matches(ele) {\n            return ele.isOrphan();\n        }\n    },\n    {\n        selector: ':nonorphan',\n        matches: function matches(ele) {\n            return ele.isChild();\n        }\n    },\n    {\n        selector: ':compound',\n        matches: function matches(ele) {\n            if (ele.isNode()) {\n                return ele.isParent();\n            } else {\n                return ele.source().isParent() || ele.target().isParent();\n            }\n        }\n    },\n    {\n        selector: ':loop',\n        matches: function matches(ele) {\n            return ele.isLoop();\n        }\n    },\n    {\n        selector: ':simple',\n        matches: function matches(ele) {\n            return ele.isSimple();\n        }\n    },\n    {\n        selector: ':active',\n        matches: function matches(ele) {\n            return ele.active();\n        }\n    },\n    {\n        selector: ':inactive',\n        matches: function matches(ele) {\n            return !ele.active();\n        }\n    },\n    {\n        selector: ':backgrounding',\n        matches: function matches(ele) {\n            return ele.backgrounding();\n        }\n    },\n    {\n        selector: ':nonbackgrounding',\n        matches: function matches(ele) {\n            return !ele.backgrounding();\n        }\n    }\n].sort(function(a, b) {\n    // n.b. selectors that are starting substrings of others must have the longer ones first\n    return descending(a.selector, b.selector);\n});\nvar lookup = function() {\n    var selToFn = {};\n    var s;\n    for(var i = 0; i < stateSelectors.length; i++){\n        s = stateSelectors[i];\n        selToFn[s.selector] = s.matches;\n    }\n    return selToFn;\n}();\nvar stateSelectorMatches = function stateSelectorMatches(sel, ele) {\n    return lookup[sel](ele);\n};\nvar stateSelectorRegex = '(' + stateSelectors.map(function(s) {\n    return s.selector;\n}).join('|') + ')';\n// when a token like a variable has escaped meta characters, we need to clean the backslashes out\n// so that values get compared properly in Selector.filter()\nvar cleanMetaChars = function cleanMetaChars(str) {\n    return str.replace(new RegExp('\\\\\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1) {\n        return $1;\n    });\n};\nvar replaceLastQuery = function replaceLastQuery(selector, examiningQuery, replacementQuery) {\n    selector[selector.length - 1] = replacementQuery;\n};\n// NOTE: add new expression syntax here to have it recognised by the parser;\n// - a query contains all adjacent (i.e. no separator in between) expressions;\n// - the current query is stored in selector[i]\n// - you need to check the query objects in match() for it actually filter properly, but that's pretty straight forward\nvar exprs = [\n    {\n        name: 'group',\n        // just used for identifying when debugging\n        query: true,\n        regex: '(' + tokens.group + ')',\n        populate: function populate(selector, query, _ref) {\n            var _ref2 = _slicedToArray(_ref, 1), group = _ref2[0];\n            query.checks.push({\n                type: Type.GROUP,\n                value: group === '*' ? group : group + 's'\n            });\n        }\n    },\n    {\n        name: 'state',\n        query: true,\n        regex: stateSelectorRegex,\n        populate: function populate(selector, query, _ref3) {\n            var _ref4 = _slicedToArray(_ref3, 1), state = _ref4[0];\n            query.checks.push({\n                type: Type.STATE,\n                value: state\n            });\n        }\n    },\n    {\n        name: 'id',\n        query: true,\n        regex: '\\\\#(' + tokens.id + ')',\n        populate: function populate(selector, query, _ref5) {\n            var _ref6 = _slicedToArray(_ref5, 1), id = _ref6[0];\n            query.checks.push({\n                type: Type.ID,\n                value: cleanMetaChars(id)\n            });\n        }\n    },\n    {\n        name: 'className',\n        query: true,\n        regex: '\\\\.(' + tokens.className + ')',\n        populate: function populate(selector, query, _ref7) {\n            var _ref8 = _slicedToArray(_ref7, 1), className = _ref8[0];\n            query.checks.push({\n                type: Type.CLASS,\n                value: cleanMetaChars(className)\n            });\n        }\n    },\n    {\n        name: 'dataExists',\n        query: true,\n        regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n        populate: function populate(selector, query, _ref9) {\n            var _ref10 = _slicedToArray(_ref9, 1), variable = _ref10[0];\n            query.checks.push({\n                type: Type.DATA_EXIST,\n                field: cleanMetaChars(variable)\n            });\n        }\n    },\n    {\n        name: 'dataCompare',\n        query: true,\n        regex: '\\\\[\\\\s*(' + tokens.variable + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.value + ')\\\\s*\\\\]',\n        populate: function populate(selector, query, _ref11) {\n            var _ref12 = _slicedToArray(_ref11, 3), variable = _ref12[0], comparatorOp = _ref12[1], value = _ref12[2];\n            var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;\n            if (valueIsString) {\n                value = value.substring(1, value.length - 1);\n            } else {\n                value = parseFloat(value);\n            }\n            query.checks.push({\n                type: Type.DATA_COMPARE,\n                field: cleanMetaChars(variable),\n                operator: comparatorOp,\n                value: value\n            });\n        }\n    },\n    {\n        name: 'dataBool',\n        query: true,\n        regex: '\\\\[\\\\s*(' + tokens.boolOp + ')\\\\s*(' + tokens.variable + ')\\\\s*\\\\]',\n        populate: function populate(selector, query, _ref13) {\n            var _ref14 = _slicedToArray(_ref13, 2), boolOp = _ref14[0], variable = _ref14[1];\n            query.checks.push({\n                type: Type.DATA_BOOL,\n                field: cleanMetaChars(variable),\n                operator: boolOp\n            });\n        }\n    },\n    {\n        name: 'metaCompare',\n        query: true,\n        regex: '\\\\[\\\\[\\\\s*(' + tokens.meta + ')\\\\s*(' + tokens.comparatorOp + ')\\\\s*(' + tokens.number + ')\\\\s*\\\\]\\\\]',\n        populate: function populate(selector, query, _ref15) {\n            var _ref16 = _slicedToArray(_ref15, 3), meta = _ref16[0], comparatorOp = _ref16[1], number = _ref16[2];\n            query.checks.push({\n                type: Type.META_COMPARE,\n                field: cleanMetaChars(meta),\n                operator: comparatorOp,\n                value: parseFloat(number)\n            });\n        }\n    },\n    {\n        name: 'nextQuery',\n        separator: true,\n        regex: tokens.separator,\n        populate: function populate(selector, query) {\n            var currentSubject = selector.currentSubject;\n            var edgeCount = selector.edgeCount;\n            var compoundCount = selector.compoundCount;\n            var lastQ = selector[selector.length - 1];\n            if (currentSubject != null) {\n                lastQ.subject = currentSubject;\n                selector.currentSubject = null;\n            }\n            lastQ.edgeCount = edgeCount;\n            lastQ.compoundCount = compoundCount;\n            selector.edgeCount = 0;\n            selector.compoundCount = 0;\n            // go on to next query\n            var nextQuery = selector[selector.length++] = newQuery();\n            return nextQuery; // this is the new query to be filled by the following exprs\n        }\n    },\n    {\n        name: 'directedEdge',\n        separator: true,\n        regex: tokens.directedEdge,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // undirected edge\n                var edgeQuery = newQuery();\n                var source = query;\n                var target = newQuery();\n                edgeQuery.checks.push({\n                    type: Type.DIRECTED_EDGE,\n                    source: source,\n                    target: target\n                });\n                // the query in the selector should be the edge rather than the source\n                replaceLastQuery(selector, query, edgeQuery);\n                selector.edgeCount++;\n                // we're now populating the target query with expressions that follow\n                return target;\n            } else {\n                // source/target\n                var srcTgtQ = newQuery();\n                var _source = query;\n                var _target = newQuery();\n                srcTgtQ.checks.push({\n                    type: Type.NODE_SOURCE,\n                    source: _source,\n                    target: _target\n                });\n                // the query in the selector should be the neighbourhood rather than the node\n                replaceLastQuery(selector, query, srcTgtQ);\n                selector.edgeCount++;\n                return _target; // now populating the target with the following expressions\n            }\n        }\n    },\n    {\n        name: 'undirectedEdge',\n        separator: true,\n        regex: tokens.undirectedEdge,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // undirected edge\n                var edgeQuery = newQuery();\n                var source = query;\n                var target = newQuery();\n                edgeQuery.checks.push({\n                    type: Type.UNDIRECTED_EDGE,\n                    nodes: [\n                        source,\n                        target\n                    ]\n                });\n                // the query in the selector should be the edge rather than the source\n                replaceLastQuery(selector, query, edgeQuery);\n                selector.edgeCount++;\n                // we're now populating the target query with expressions that follow\n                return target;\n            } else {\n                // neighbourhood\n                var nhoodQ = newQuery();\n                var node = query;\n                var neighbor = newQuery();\n                nhoodQ.checks.push({\n                    type: Type.NODE_NEIGHBOR,\n                    node: node,\n                    neighbor: neighbor\n                });\n                // the query in the selector should be the neighbourhood rather than the node\n                replaceLastQuery(selector, query, nhoodQ);\n                return neighbor; // now populating the neighbor with following expressions\n            }\n        }\n    },\n    {\n        name: 'child',\n        separator: true,\n        regex: tokens.child,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // default: child query\n                var parentChildQuery = newQuery();\n                var child = newQuery();\n                var parent = selector[selector.length - 1];\n                parentChildQuery.checks.push({\n                    type: Type.CHILD,\n                    parent: parent,\n                    child: child\n                });\n                // the query in the selector should be the '>' itself\n                replaceLastQuery(selector, query, parentChildQuery);\n                selector.compoundCount++;\n                // we're now populating the child query with expressions that follow\n                return child;\n            } else if (selector.currentSubject === query) {\n                // compound split query\n                var compound = newQuery();\n                var left = selector[selector.length - 1];\n                var right = newQuery();\n                var subject = newQuery();\n                var _child = newQuery();\n                var _parent = newQuery();\n                // set up the root compound q\n                compound.checks.push({\n                    type: Type.COMPOUND_SPLIT,\n                    left: left,\n                    right: right,\n                    subject: subject\n                });\n                // populate the subject and replace the q at the old spot (within left) with TRUE\n                subject.checks = query.checks; // take the checks from the left\n                query.checks = [\n                    {\n                        type: Type.TRUE\n                    }\n                ]; // checks under left refs the subject implicitly\n                // set up the right q\n                _parent.checks.push({\n                    type: Type.TRUE\n                }); // parent implicitly refs the subject\n                right.checks.push({\n                    type: Type.PARENT,\n                    // type is swapped on right side queries\n                    parent: _parent,\n                    child: _child // empty for now\n                });\n                replaceLastQuery(selector, left, compound);\n                // update the ref since we moved things around for `query`\n                selector.currentSubject = subject;\n                selector.compoundCount++;\n                return _child; // now populating the right side's child\n            } else {\n                // parent query\n                // info for parent query\n                var _parent2 = newQuery();\n                var _child2 = newQuery();\n                var pcQChecks = [\n                    {\n                        type: Type.PARENT,\n                        parent: _parent2,\n                        child: _child2\n                    }\n                ];\n                // the parent-child query takes the place of the query previously being populated\n                _parent2.checks = query.checks; // the previous query contains the checks for the parent\n                query.checks = pcQChecks; // pc query takes over\n                selector.compoundCount++;\n                return _child2; // we're now populating the child\n            }\n        }\n    },\n    {\n        name: 'descendant',\n        separator: true,\n        regex: tokens.descendant,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject == null) {\n                // default: descendant query\n                var ancChQuery = newQuery();\n                var descendant = newQuery();\n                var ancestor = selector[selector.length - 1];\n                ancChQuery.checks.push({\n                    type: Type.DESCENDANT,\n                    ancestor: ancestor,\n                    descendant: descendant\n                });\n                // the query in the selector should be the '>' itself\n                replaceLastQuery(selector, query, ancChQuery);\n                selector.compoundCount++;\n                // we're now populating the descendant query with expressions that follow\n                return descendant;\n            } else if (selector.currentSubject === query) {\n                // compound split query\n                var compound = newQuery();\n                var left = selector[selector.length - 1];\n                var right = newQuery();\n                var subject = newQuery();\n                var _descendant = newQuery();\n                var _ancestor = newQuery();\n                // set up the root compound q\n                compound.checks.push({\n                    type: Type.COMPOUND_SPLIT,\n                    left: left,\n                    right: right,\n                    subject: subject\n                });\n                // populate the subject and replace the q at the old spot (within left) with TRUE\n                subject.checks = query.checks; // take the checks from the left\n                query.checks = [\n                    {\n                        type: Type.TRUE\n                    }\n                ]; // checks under left refs the subject implicitly\n                // set up the right q\n                _ancestor.checks.push({\n                    type: Type.TRUE\n                }); // ancestor implicitly refs the subject\n                right.checks.push({\n                    type: Type.ANCESTOR,\n                    // type is swapped on right side queries\n                    ancestor: _ancestor,\n                    descendant: _descendant // empty for now\n                });\n                replaceLastQuery(selector, left, compound);\n                // update the ref since we moved things around for `query`\n                selector.currentSubject = subject;\n                selector.compoundCount++;\n                return _descendant; // now populating the right side's descendant\n            } else {\n                // ancestor query\n                // info for parent query\n                var _ancestor2 = newQuery();\n                var _descendant2 = newQuery();\n                var adQChecks = [\n                    {\n                        type: Type.ANCESTOR,\n                        ancestor: _ancestor2,\n                        descendant: _descendant2\n                    }\n                ];\n                // the parent-child query takes the place of the query previously being populated\n                _ancestor2.checks = query.checks; // the previous query contains the checks for the parent\n                query.checks = adQChecks; // pc query takes over\n                selector.compoundCount++;\n                return _descendant2; // we're now populating the child\n            }\n        }\n    },\n    {\n        name: 'subject',\n        modifier: true,\n        regex: tokens.subject,\n        populate: function populate(selector, query) {\n            if (selector.currentSubject != null && selector.currentSubject !== query) {\n                warn('Redefinition of subject in selector `' + selector.toString() + '`');\n                return false;\n            }\n            selector.currentSubject = query;\n            var topQ = selector[selector.length - 1];\n            var topChk = topQ.checks[0];\n            var topType = topChk == null ? null : topChk.type;\n            if (topType === Type.DIRECTED_EDGE) {\n                // directed edge with subject on the target\n                // change to target node check\n                topChk.type = Type.NODE_TARGET;\n            } else if (topType === Type.UNDIRECTED_EDGE) {\n                // undirected edge with subject on the second node\n                // change to neighbor check\n                topChk.type = Type.NODE_NEIGHBOR;\n                topChk.node = topChk.nodes[1]; // second node is subject\n                topChk.neighbor = topChk.nodes[0];\n                // clean up unused fields for new type\n                topChk.nodes = null;\n            }\n        }\n    }\n];\nexprs.forEach(function(e) {\n    return e.regexObj = new RegExp('^' + e.regex);\n});\n/**\n * Of all the expressions, find the first match in the remaining text.\n * @param {string} remaining The remaining text to parse\n * @returns The matched expression and the newly remaining text `{ expr, match, name, remaining }`\n */ var consumeExpr = function consumeExpr(remaining) {\n    var expr;\n    var match;\n    var name;\n    for(var j = 0; j < exprs.length; j++){\n        var e = exprs[j];\n        var n = e.name;\n        var m1 = remaining.match(e.regexObj);\n        if (m1 != null) {\n            match = m1;\n            expr = e;\n            name = n;\n            var consumed = m1[0];\n            remaining = remaining.substring(consumed.length);\n            break; // we've consumed one expr, so we can return now\n        }\n    }\n    return {\n        expr: expr,\n        match: match,\n        name: name,\n        remaining: remaining\n    };\n};\n/**\n * Consume all the leading whitespace\n * @param {string} remaining The text to consume\n * @returns The text with the leading whitespace removed\n */ var consumeWhitespace = function consumeWhitespace(remaining) {\n    var match = remaining.match(/^\\s+/);\n    if (match) {\n        var consumed = match[0];\n        remaining = remaining.substring(consumed.length);\n    }\n    return remaining;\n};\n/**\n * Parse the string and store the parsed representation in the Selector.\n * @param {string} selector The selector string\n * @returns `true` if the selector was successfully parsed, `false` otherwise\n */ var parse = function parse(selector) {\n    var self1 = this;\n    var remaining = self1.inputText = selector;\n    var currentQuery = self1[0] = newQuery();\n    self1.length = 1;\n    remaining = consumeWhitespace(remaining); // get rid of leading whitespace\n    for(;;){\n        var exprInfo = consumeExpr(remaining);\n        if (exprInfo.expr == null) {\n            warn('The selector `' + selector + '`is invalid');\n            return false;\n        } else {\n            var args = exprInfo.match.slice(1);\n            // let the token populate the selector object in currentQuery\n            var ret = exprInfo.expr.populate(self1, currentQuery, args);\n            if (ret === false) {\n                return false; // exit if population failed\n            } else if (ret != null) {\n                currentQuery = ret; // change the current query to be filled if the expr specifies\n            }\n        }\n        remaining = exprInfo.remaining;\n        // we're done when there's nothing left to parse\n        if (remaining.match(/^\\s*$/)) {\n            break;\n        }\n    }\n    var lastQ = self1[self1.length - 1];\n    if (self1.currentSubject != null) {\n        lastQ.subject = self1.currentSubject;\n    }\n    lastQ.edgeCount = self1.edgeCount;\n    lastQ.compoundCount = self1.compoundCount;\n    for(var i = 0; i < self1.length; i++){\n        var q = self1[i];\n        // in future, this could potentially be allowed if there were operator precedence and detection of invalid combinations\n        if (q.compoundCount > 0 && q.edgeCount > 0) {\n            warn('The selector `' + selector + '` is invalid because it uses both a compound selector and an edge selector');\n            return false;\n        }\n        if (q.edgeCount > 1) {\n            warn('The selector `' + selector + '` is invalid because it uses multiple edge selectors');\n            return false;\n        } else if (q.edgeCount === 1) {\n            warn('The selector `' + selector + '` is deprecated.  Edge selectors do not take effect on changes to source and target nodes after an edge is added, for performance reasons.  Use a class or data selector on edges instead, updating the class or data of an edge when your app detects a change in source or target nodes.');\n        }\n    }\n    return true; // success\n};\n/**\n * Get the selector represented as a string.  This value uses default formatting,\n * so things like spacing may differ from the input text passed to the constructor.\n * @returns {string} The selector string\n */ var toString = function toString() {\n    if (this.toStringCache != null) {\n        return this.toStringCache;\n    }\n    var clean = function clean(obj) {\n        if (obj == null) {\n            return '';\n        } else {\n            return obj;\n        }\n    };\n    var cleanVal = function cleanVal(val) {\n        if (string(val)) {\n            return '\"' + val + '\"';\n        } else {\n            return clean(val);\n        }\n    };\n    var space = function space(val) {\n        return ' ' + val + ' ';\n    };\n    var checkToString = function checkToString(check, subject) {\n        var type = check.type, value = check.value;\n        switch(type){\n            case Type.GROUP:\n                {\n                    var group = clean(value);\n                    return group.substring(0, group.length - 1);\n                }\n            case Type.DATA_COMPARE:\n                {\n                    var field = check.field, operator = check.operator;\n                    return '[' + field + space(clean(operator)) + cleanVal(value) + ']';\n                }\n            case Type.DATA_BOOL:\n                {\n                    var _operator = check.operator, _field = check.field;\n                    return '[' + clean(_operator) + _field + ']';\n                }\n            case Type.DATA_EXIST:\n                {\n                    var _field2 = check.field;\n                    return '[' + _field2 + ']';\n                }\n            case Type.META_COMPARE:\n                {\n                    var _operator2 = check.operator, _field3 = check.field;\n                    return '[[' + _field3 + space(clean(_operator2)) + cleanVal(value) + ']]';\n                }\n            case Type.STATE:\n                {\n                    return value;\n                }\n            case Type.ID:\n                {\n                    return '#' + value;\n                }\n            case Type.CLASS:\n                {\n                    return '.' + value;\n                }\n            case Type.PARENT:\n            case Type.CHILD:\n                {\n                    return queryToString(check.parent, subject) + space('>') + queryToString(check.child, subject);\n                }\n            case Type.ANCESTOR:\n            case Type.DESCENDANT:\n                {\n                    return queryToString(check.ancestor, subject) + ' ' + queryToString(check.descendant, subject);\n                }\n            case Type.COMPOUND_SPLIT:\n                {\n                    var lhs = queryToString(check.left, subject);\n                    var sub = queryToString(check.subject, subject);\n                    var rhs = queryToString(check.right, subject);\n                    return lhs + (lhs.length > 0 ? ' ' : '') + sub + rhs;\n                }\n            case Type.TRUE:\n                {\n                    return '';\n                }\n        }\n    };\n    var queryToString = function queryToString(query, subject) {\n        return query.checks.reduce(function(str, chk, i) {\n            return str + (subject === query && i === 0 ? '$' : '') + checkToString(chk, subject);\n        }, '');\n    };\n    var str = '';\n    for(var i = 0; i < this.length; i++){\n        var query = this[i];\n        str += queryToString(query, query.subject);\n        if (this.length > 1 && i < this.length - 1) {\n            str += ', ';\n        }\n    }\n    this.toStringCache = str;\n    return str;\n};\nvar parse$1 = {\n    parse: parse,\n    toString: toString\n};\nvar valCmp = function valCmp(fieldVal, operator, value) {\n    var matches;\n    var isFieldStr = string(fieldVal);\n    var isFieldNum = number$1(fieldVal);\n    var isValStr = string(value);\n    var fieldStr, valStr;\n    var caseInsensitive = false;\n    var notExpr = false;\n    var isIneqCmp = false;\n    if (operator.indexOf('!') >= 0) {\n        operator = operator.replace('!', '');\n        notExpr = true;\n    }\n    if (operator.indexOf('@') >= 0) {\n        operator = operator.replace('@', '');\n        caseInsensitive = true;\n    }\n    if (isFieldStr || isValStr || caseInsensitive) {\n        fieldStr = !isFieldStr && !isFieldNum ? '' : '' + fieldVal;\n        valStr = '' + value;\n    }\n    // if we're doing a case insensitive comparison, then we're using a STRING comparison\n    // even if we're comparing numbers\n    if (caseInsensitive) {\n        fieldVal = fieldStr = fieldStr.toLowerCase();\n        value = valStr = valStr.toLowerCase();\n    }\n    switch(operator){\n        case '*=':\n            matches = fieldStr.indexOf(valStr) >= 0;\n            break;\n        case '$=':\n            matches = fieldStr.indexOf(valStr, fieldStr.length - valStr.length) >= 0;\n            break;\n        case '^=':\n            matches = fieldStr.indexOf(valStr) === 0;\n            break;\n        case '=':\n            matches = fieldVal === value;\n            break;\n        case '>':\n            isIneqCmp = true;\n            matches = fieldVal > value;\n            break;\n        case '>=':\n            isIneqCmp = true;\n            matches = fieldVal >= value;\n            break;\n        case '<':\n            isIneqCmp = true;\n            matches = fieldVal < value;\n            break;\n        case '<=':\n            isIneqCmp = true;\n            matches = fieldVal <= value;\n            break;\n        default:\n            matches = false;\n            break;\n    }\n    // apply the not op, but null vals for inequalities should always stay non-matching\n    if (notExpr && (fieldVal != null || !isIneqCmp)) {\n        matches = !matches;\n    }\n    return matches;\n};\nvar boolCmp = function boolCmp(fieldVal, operator) {\n    switch(operator){\n        case '?':\n            return fieldVal ? true : false;\n        case '!':\n            return fieldVal ? false : true;\n        case '^':\n            return fieldVal === undefined;\n    }\n};\nvar existCmp = function existCmp(fieldVal) {\n    return fieldVal !== undefined;\n};\nvar data$1 = function data(ele, field) {\n    return ele.data(field);\n};\nvar meta = function meta(ele, field) {\n    return ele[field]();\n};\n/** A lookup of `match(check, ele)` functions by `Type` int */ var match = [];\n/**\n * Returns whether the query matches for the element\n * @param query The `{ type, value, ... }` query object\n * @param ele The element to compare against\n*/ var matches$1 = function matches(query, ele) {\n    return query.checks.every(function(chk) {\n        return match[chk.type](chk, ele);\n    });\n};\nmatch[Type.GROUP] = function(check, ele) {\n    var group = check.value;\n    return group === '*' || group === ele.group();\n};\nmatch[Type.STATE] = function(check, ele) {\n    var stateSelector = check.value;\n    return stateSelectorMatches(stateSelector, ele);\n};\nmatch[Type.ID] = function(check, ele) {\n    var id = check.value;\n    return ele.id() === id;\n};\nmatch[Type.CLASS] = function(check, ele) {\n    var cls = check.value;\n    return ele.hasClass(cls);\n};\nmatch[Type.META_COMPARE] = function(check, ele) {\n    var field = check.field, operator = check.operator, value = check.value;\n    return valCmp(meta(ele, field), operator, value);\n};\nmatch[Type.DATA_COMPARE] = function(check, ele) {\n    var field = check.field, operator = check.operator, value = check.value;\n    return valCmp(data$1(ele, field), operator, value);\n};\nmatch[Type.DATA_BOOL] = function(check, ele) {\n    var field = check.field, operator = check.operator;\n    return boolCmp(data$1(ele, field), operator);\n};\nmatch[Type.DATA_EXIST] = function(check, ele) {\n    var field = check.field;\n    check.operator;\n    return existCmp(data$1(ele, field));\n};\nmatch[Type.UNDIRECTED_EDGE] = function(check, ele) {\n    var qA = check.nodes[0];\n    var qB = check.nodes[1];\n    var src = ele.source();\n    var tgt = ele.target();\n    return matches$1(qA, src) && matches$1(qB, tgt) || matches$1(qB, src) && matches$1(qA, tgt);\n};\nmatch[Type.NODE_NEIGHBOR] = function(check, ele) {\n    return matches$1(check.node, ele) && ele.neighborhood().some(function(n) {\n        return n.isNode() && matches$1(check.neighbor, n);\n    });\n};\nmatch[Type.DIRECTED_EDGE] = function(check, ele) {\n    return matches$1(check.source, ele.source()) && matches$1(check.target, ele.target());\n};\nmatch[Type.NODE_SOURCE] = function(check, ele) {\n    return matches$1(check.source, ele) && ele.outgoers().some(function(n) {\n        return n.isNode() && matches$1(check.target, n);\n    });\n};\nmatch[Type.NODE_TARGET] = function(check, ele) {\n    return matches$1(check.target, ele) && ele.incomers().some(function(n) {\n        return n.isNode() && matches$1(check.source, n);\n    });\n};\nmatch[Type.CHILD] = function(check, ele) {\n    return matches$1(check.child, ele) && matches$1(check.parent, ele.parent());\n};\nmatch[Type.PARENT] = function(check, ele) {\n    return matches$1(check.parent, ele) && ele.children().some(function(c) {\n        return matches$1(check.child, c);\n    });\n};\nmatch[Type.DESCENDANT] = function(check, ele) {\n    return matches$1(check.descendant, ele) && ele.ancestors().some(function(a) {\n        return matches$1(check.ancestor, a);\n    });\n};\nmatch[Type.ANCESTOR] = function(check, ele) {\n    return matches$1(check.ancestor, ele) && ele.descendants().some(function(d) {\n        return matches$1(check.descendant, d);\n    });\n};\nmatch[Type.COMPOUND_SPLIT] = function(check, ele) {\n    return matches$1(check.subject, ele) && matches$1(check.left, ele) && matches$1(check.right, ele);\n};\nmatch[Type.TRUE] = function() {\n    return true;\n};\nmatch[Type.COLLECTION] = function(check, ele) {\n    var collection = check.value;\n    return collection.has(ele);\n};\nmatch[Type.FILTER] = function(check, ele) {\n    var filter = check.value;\n    return filter(ele);\n};\n// filter an existing collection\nvar filter = function filter(collection) {\n    var self1 = this;\n    // for 1 id #foo queries, just get the element\n    if (self1.length === 1 && self1[0].checks.length === 1 && self1[0].checks[0].type === Type.ID) {\n        return collection.getElementById(self1[0].checks[0].value).collection();\n    }\n    var selectorFunction = function selectorFunction(element) {\n        for(var j = 0; j < self1.length; j++){\n            var query = self1[j];\n            if (matches$1(query, element)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (self1.text() == null) {\n        selectorFunction = function selectorFunction() {\n            return true;\n        };\n    }\n    return collection.filter(selectorFunction);\n}; // filter\n// does selector match a single element?\nvar matches = function matches(ele) {\n    var self1 = this;\n    for(var j = 0; j < self1.length; j++){\n        var query = self1[j];\n        if (matches$1(query, ele)) {\n            return true;\n        }\n    }\n    return false;\n}; // matches\nvar matching = {\n    matches: matches,\n    filter: filter\n};\nvar Selector = function Selector(selector) {\n    this.inputText = selector;\n    this.currentSubject = null;\n    this.compoundCount = 0;\n    this.edgeCount = 0;\n    this.length = 0;\n    if (selector == null || string(selector) && selector.match(/^\\s*$/)) ;\n    else if (elementOrCollection(selector)) {\n        this.addQuery({\n            checks: [\n                {\n                    type: Type.COLLECTION,\n                    value: selector.collection()\n                }\n            ]\n        });\n    } else if (fn$6(selector)) {\n        this.addQuery({\n            checks: [\n                {\n                    type: Type.FILTER,\n                    value: selector\n                }\n            ]\n        });\n    } else if (string(selector)) {\n        if (!this.parse(selector)) {\n            this.invalid = true;\n        }\n    } else {\n        error('A selector must be created from a string; found ');\n    }\n};\nvar selfn = Selector.prototype;\n[\n    parse$1,\n    matching\n].forEach(function(p) {\n    return extend(selfn, p);\n});\nselfn.text = function() {\n    return this.inputText;\n};\nselfn.size = function() {\n    return this.length;\n};\nselfn.eq = function(i) {\n    return this[i];\n};\nselfn.sameText = function(otherSel) {\n    return !this.invalid && !otherSel.invalid && this.text() === otherSel.text();\n};\nselfn.addQuery = function(q) {\n    this[this.length++] = q;\n};\nselfn.selector = selfn.toString;\nvar elesfn$g = {\n    allAre: function allAre(selector) {\n        var selObj = new Selector(selector);\n        return this.every(function(ele) {\n            return selObj.matches(ele);\n        });\n    },\n    is: function is(selector) {\n        var selObj = new Selector(selector);\n        return this.some(function(ele) {\n            return selObj.matches(ele);\n        });\n    },\n    some: function some(fn, thisArg) {\n        for(var i = 0; i < this.length; i++){\n            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [\n                this[i],\n                i,\n                this\n            ]);\n            if (ret) {\n                return true;\n            }\n        }\n        return false;\n    },\n    every: function every(fn, thisArg) {\n        for(var i = 0; i < this.length; i++){\n            var ret = !thisArg ? fn(this[i], i, this) : fn.apply(thisArg, [\n                this[i],\n                i,\n                this\n            ]);\n            if (!ret) {\n                return false;\n            }\n        }\n        return true;\n    },\n    same: function same(collection) {\n        // cheap collection ref check\n        if (this === collection) {\n            return true;\n        }\n        collection = this.cy().collection(collection);\n        var thisLength = this.length;\n        var collectionLength = collection.length;\n        // cheap length check\n        if (thisLength !== collectionLength) {\n            return false;\n        }\n        // cheap element ref check\n        if (thisLength === 1) {\n            return this[0] === collection[0];\n        }\n        return this.every(function(ele) {\n            return collection.hasElementWithId(ele.id());\n        });\n    },\n    anySame: function anySame(collection) {\n        collection = this.cy().collection(collection);\n        return this.some(function(ele) {\n            return collection.hasElementWithId(ele.id());\n        });\n    },\n    allAreNeighbors: function allAreNeighbors(collection) {\n        collection = this.cy().collection(collection);\n        var nhood = this.neighborhood();\n        return collection.every(function(ele) {\n            return nhood.hasElementWithId(ele.id());\n        });\n    },\n    contains: function contains(collection) {\n        collection = this.cy().collection(collection);\n        var self1 = this;\n        return collection.every(function(ele) {\n            return self1.hasElementWithId(ele.id());\n        });\n    }\n};\nelesfn$g.allAreNeighbours = elesfn$g.allAreNeighbors;\nelesfn$g.has = elesfn$g.contains;\nelesfn$g.equal = elesfn$g.equals = elesfn$g.same;\nvar cache = function cache(fn, name) {\n    return function traversalCache(arg1, arg2, arg3, arg4) {\n        var selectorOrEles = arg1;\n        var eles = this;\n        var key;\n        if (selectorOrEles == null) {\n            key = '';\n        } else if (elementOrCollection(selectorOrEles) && selectorOrEles.length === 1) {\n            key = selectorOrEles.id();\n        }\n        if (eles.length === 1 && key) {\n            var _p = eles[0]._private;\n            var tch = _p.traversalCache = _p.traversalCache || {};\n            var ch = tch[name] = tch[name] || [];\n            var hash = hashString(key);\n            var cacheHit = ch[hash];\n            if (cacheHit) {\n                return cacheHit;\n            } else {\n                return ch[hash] = fn.call(eles, arg1, arg2, arg3, arg4);\n            }\n        } else {\n            return fn.call(eles, arg1, arg2, arg3, arg4);\n        }\n    };\n};\nvar elesfn$f = {\n    parent: function parent(selector) {\n        var parents = [];\n        // optimisation for single ele call\n        if (this.length === 1) {\n            var parent = this[0]._private.parent;\n            if (parent) {\n                return parent;\n            }\n        }\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var _parent = ele._private.parent;\n            if (_parent) {\n                parents.push(_parent);\n            }\n        }\n        return this.spawn(parents, true).filter(selector);\n    },\n    parents: function parents(selector) {\n        var parents = [];\n        var eles = this.parent();\n        while(eles.nonempty()){\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                parents.push(ele);\n            }\n            eles = eles.parent();\n        }\n        return this.spawn(parents, true).filter(selector);\n    },\n    commonAncestors: function commonAncestors(selector) {\n        var ancestors;\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var parents = ele.parents();\n            ancestors = ancestors || parents;\n            ancestors = ancestors.intersect(parents); // current list must be common with current ele parents set\n        }\n        return ancestors.filter(selector);\n    },\n    orphans: function orphans(selector) {\n        return this.stdFilter(function(ele) {\n            return ele.isOrphan();\n        }).filter(selector);\n    },\n    nonorphans: function nonorphans(selector) {\n        return this.stdFilter(function(ele) {\n            return ele.isChild();\n        }).filter(selector);\n    },\n    children: cache(function(selector) {\n        var children = [];\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var eleChildren = ele._private.children;\n            for(var j = 0; j < eleChildren.length; j++){\n                children.push(eleChildren[j]);\n            }\n        }\n        return this.spawn(children, true).filter(selector);\n    }, 'children'),\n    siblings: function siblings(selector) {\n        return this.parent().children().not(this).filter(selector);\n    },\n    isParent: function isParent() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.children.length !== 0;\n        }\n    },\n    isChildless: function isChildless() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.children.length === 0;\n        }\n    },\n    isChild: function isChild() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.parent != null;\n        }\n    },\n    isOrphan: function isOrphan() {\n        var ele = this[0];\n        if (ele) {\n            return ele.isNode() && ele._private.parent == null;\n        }\n    },\n    descendants: function descendants(selector) {\n        var elements = [];\n        function add(eles) {\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                elements.push(ele);\n                if (ele.children().nonempty()) {\n                    add(ele.children());\n                }\n            }\n        }\n        add(this.children());\n        return this.spawn(elements, true).filter(selector);\n    }\n};\nfunction forEachCompound(eles, fn, includeSelf, recursiveStep) {\n    var q = [];\n    var did = new Set$1();\n    var cy = eles.cy();\n    var hasCompounds = cy.hasCompoundNodes();\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        if (includeSelf) {\n            q.push(ele);\n        } else if (hasCompounds) {\n            recursiveStep(q, did, ele);\n        }\n    }\n    while(q.length > 0){\n        var _ele = q.shift();\n        fn(_ele);\n        did.add(_ele.id());\n        if (hasCompounds) {\n            recursiveStep(q, did, _ele);\n        }\n    }\n    return eles;\n}\nfunction addChildren(q, did, ele) {\n    if (ele.isParent()) {\n        var children = ele._private.children;\n        for(var i = 0; i < children.length; i++){\n            var child = children[i];\n            if (!did.has(child.id())) {\n                q.push(child);\n            }\n        }\n    }\n}\n// very efficient version of eles.add( eles.descendants() ).forEach()\n// for internal use\nelesfn$f.forEachDown = function(fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addChildren);\n};\nfunction addParent(q, did, ele) {\n    if (ele.isChild()) {\n        var parent = ele._private.parent;\n        if (!did.has(parent.id())) {\n            q.push(parent);\n        }\n    }\n}\nelesfn$f.forEachUp = function(fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParent);\n};\nfunction addParentAndChildren(q, did, ele) {\n    addParent(q, did, ele);\n    addChildren(q, did, ele);\n}\nelesfn$f.forEachUpAndDown = function(fn) {\n    var includeSelf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return forEachCompound(this, fn, includeSelf, addParentAndChildren);\n};\n// aliases\nelesfn$f.ancestors = elesfn$f.parents;\nvar fn$5, elesfn$e;\nfn$5 = elesfn$e = {\n    data: define.data({\n        field: 'data',\n        bindingEvent: 'data',\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: 'data',\n        settingTriggersEvent: true,\n        triggerFnName: 'trigger',\n        allowGetting: true,\n        immutableKeys: {\n            'id': true,\n            'source': true,\n            'target': true,\n            'parent': true\n        },\n        updateStyle: true\n    }),\n    removeData: define.removeData({\n        field: 'data',\n        event: 'data',\n        triggerFnName: 'trigger',\n        triggerEvent: true,\n        immutableKeys: {\n            'id': true,\n            'source': true,\n            'target': true,\n            'parent': true\n        },\n        updateStyle: true\n    }),\n    scratch: define.data({\n        field: 'scratch',\n        bindingEvent: 'scratch',\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: 'scratch',\n        settingTriggersEvent: true,\n        triggerFnName: 'trigger',\n        allowGetting: true,\n        updateStyle: true\n    }),\n    removeScratch: define.removeData({\n        field: 'scratch',\n        event: 'scratch',\n        triggerFnName: 'trigger',\n        triggerEvent: true,\n        updateStyle: true\n    }),\n    rscratch: define.data({\n        field: 'rscratch',\n        allowBinding: false,\n        allowSetting: true,\n        settingTriggersEvent: false,\n        allowGetting: true\n    }),\n    removeRscratch: define.removeData({\n        field: 'rscratch',\n        triggerEvent: false\n    }),\n    id: function id() {\n        var ele = this[0];\n        if (ele) {\n            return ele._private.data.id;\n        }\n    }\n};\n// aliases\nfn$5.attr = fn$5.data;\nfn$5.removeAttr = fn$5.removeData;\nvar data = elesfn$e;\nvar elesfn$d = {};\nfunction defineDegreeFunction(callback) {\n    return function(includeLoops) {\n        var self1 = this;\n        if (includeLoops === undefined) {\n            includeLoops = true;\n        }\n        if (self1.length === 0) {\n            return;\n        }\n        if (self1.isNode() && !self1.removed()) {\n            var degree = 0;\n            var node = self1[0];\n            var connectedEdges = node._private.edges;\n            for(var i = 0; i < connectedEdges.length; i++){\n                var edge = connectedEdges[i];\n                if (!includeLoops && edge.isLoop()) {\n                    continue;\n                }\n                degree += callback(node, edge);\n            }\n            return degree;\n        } else {\n            return;\n        }\n    };\n}\nextend(elesfn$d, {\n    degree: defineDegreeFunction(function(node, edge) {\n        if (edge.source().same(edge.target())) {\n            return 2;\n        } else {\n            return 1;\n        }\n    }),\n    indegree: defineDegreeFunction(function(node, edge) {\n        if (edge.target().same(node)) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }),\n    outdegree: defineDegreeFunction(function(node, edge) {\n        if (edge.source().same(node)) {\n            return 1;\n        } else {\n            return 0;\n        }\n    })\n});\nfunction defineDegreeBoundsFunction(degreeFn, callback) {\n    return function(includeLoops) {\n        var ret;\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            var ele = nodes[i];\n            var degree = ele[degreeFn](includeLoops);\n            if (degree !== undefined && (ret === undefined || callback(degree, ret))) {\n                ret = degree;\n            }\n        }\n        return ret;\n    };\n}\nextend(elesfn$d, {\n    minDegree: defineDegreeBoundsFunction('degree', function(degree, min) {\n        return degree < min;\n    }),\n    maxDegree: defineDegreeBoundsFunction('degree', function(degree, max) {\n        return degree > max;\n    }),\n    minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min) {\n        return degree < min;\n    }),\n    maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max) {\n        return degree > max;\n    }),\n    minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min) {\n        return degree < min;\n    }),\n    maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max) {\n        return degree > max;\n    })\n});\nextend(elesfn$d, {\n    totalDegree: function totalDegree(includeLoops) {\n        var total = 0;\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            total += nodes[i].degree(includeLoops);\n        }\n        return total;\n    }\n});\nvar fn$4, elesfn$c;\nvar beforePositionSet = function beforePositionSet(eles, newPos, silent) {\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        if (!ele.locked()) {\n            var oldPos = ele._private.position;\n            var delta = {\n                x: newPos.x != null ? newPos.x - oldPos.x : 0,\n                y: newPos.y != null ? newPos.y - oldPos.y : 0\n            };\n            if (ele.isParent() && !(delta.x === 0 && delta.y === 0)) {\n                ele.children().shift(delta, silent);\n            }\n            ele.dirtyBoundingBoxCache();\n        }\n    }\n};\nvar positionDef = {\n    field: 'position',\n    bindingEvent: 'position',\n    allowBinding: true,\n    allowSetting: true,\n    settingEvent: 'position',\n    settingTriggersEvent: true,\n    triggerFnName: 'emitAndNotify',\n    allowGetting: true,\n    validKeys: [\n        'x',\n        'y'\n    ],\n    beforeGet: function beforeGet(ele) {\n        ele.updateCompoundBounds();\n    },\n    beforeSet: function beforeSet(eles, newPos) {\n        beforePositionSet(eles, newPos, false);\n    },\n    onSet: function onSet(eles) {\n        eles.dirtyCompoundBoundsCache();\n    },\n    canSet: function canSet(ele) {\n        return !ele.locked();\n    }\n};\nfn$4 = elesfn$c = {\n    position: define.data(positionDef),\n    // position but no notification to renderer\n    silentPosition: define.data(extend({}, positionDef, {\n        allowBinding: false,\n        allowSetting: true,\n        settingTriggersEvent: false,\n        allowGetting: false,\n        beforeSet: function beforeSet(eles, newPos) {\n            beforePositionSet(eles, newPos, true);\n        },\n        onSet: function onSet(eles) {\n            eles.dirtyCompoundBoundsCache();\n        }\n    })),\n    positions: function positions(pos, silent) {\n        if (plainObject(pos)) {\n            if (silent) {\n                this.silentPosition(pos);\n            } else {\n                this.position(pos);\n            }\n        } else if (fn$6(pos)) {\n            var _fn = pos;\n            var cy = this.cy();\n            cy.startBatch();\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var _pos = undefined;\n                if (_pos = _fn(ele, i)) {\n                    if (silent) {\n                        ele.silentPosition(_pos);\n                    } else {\n                        ele.position(_pos);\n                    }\n                }\n            }\n            cy.endBatch();\n        }\n        return this; // chaining\n    },\n    silentPositions: function silentPositions(pos) {\n        return this.positions(pos, true);\n    },\n    shift: function shift(dim, val, silent) {\n        var delta;\n        if (plainObject(dim)) {\n            delta = {\n                x: number$1(dim.x) ? dim.x : 0,\n                y: number$1(dim.y) ? dim.y : 0\n            };\n            silent = val;\n        } else if (string(dim) && number$1(val)) {\n            delta = {\n                x: 0,\n                y: 0\n            };\n            delta[dim] = val;\n        }\n        if (delta != null) {\n            var cy = this.cy();\n            cy.startBatch();\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                // exclude any node that is a descendant of the calling collection\n                if (cy.hasCompoundNodes() && ele.isChild() && ele.ancestors().anySame(this)) {\n                    continue;\n                }\n                var pos = ele.position();\n                var newPos = {\n                    x: pos.x + delta.x,\n                    y: pos.y + delta.y\n                };\n                if (silent) {\n                    ele.silentPosition(newPos);\n                } else {\n                    ele.position(newPos);\n                }\n            }\n            cy.endBatch();\n        }\n        return this;\n    },\n    silentShift: function silentShift(dim, val) {\n        if (plainObject(dim)) {\n            this.shift(dim, true);\n        } else if (string(dim) && number$1(val)) {\n            this.shift(dim, val, true);\n        }\n        return this;\n    },\n    // get/set the rendered (i.e. on screen) positon of the element\n    renderedPosition: function renderedPosition(dim, val) {\n        var ele = this[0];\n        var cy = this.cy();\n        var zoom = cy.zoom();\n        var pan = cy.pan();\n        var rpos = plainObject(dim) ? dim : undefined;\n        var setting = rpos !== undefined || val !== undefined && string(dim);\n        if (ele && ele.isNode()) {\n            // must have an element and must be a node to return position\n            if (setting) {\n                for(var i = 0; i < this.length; i++){\n                    var _ele = this[i];\n                    if (val !== undefined) {\n                        // set one dimension\n                        _ele.position(dim, (val - pan[dim]) / zoom);\n                    } else if (rpos !== undefined) {\n                        // set whole position\n                        _ele.position(renderedToModelPosition(rpos, zoom, pan));\n                    }\n                }\n            } else {\n                // getting\n                var pos = ele.position();\n                rpos = modelToRenderedPosition$1(pos, zoom, pan);\n                if (dim === undefined) {\n                    // then return the whole rendered position\n                    return rpos;\n                } else {\n                    // then return the specified dimension\n                    return rpos[dim];\n                }\n            }\n        } else if (!setting) {\n            return undefined; // for empty collection case\n        }\n        return this; // chaining\n    },\n    // get/set the position relative to the parent\n    relativePosition: function relativePosition(dim, val) {\n        var ele = this[0];\n        var cy = this.cy();\n        var ppos = plainObject(dim) ? dim : undefined;\n        var setting = ppos !== undefined || val !== undefined && string(dim);\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        if (ele && ele.isNode()) {\n            // must have an element and must be a node to return position\n            if (setting) {\n                for(var i = 0; i < this.length; i++){\n                    var _ele2 = this[i];\n                    var parent = hasCompoundNodes ? _ele2.parent() : null;\n                    var hasParent = parent && parent.length > 0;\n                    var relativeToParent = hasParent;\n                    if (hasParent) {\n                        parent = parent[0];\n                    }\n                    var origin = relativeToParent ? parent.position() : {\n                        x: 0,\n                        y: 0\n                    };\n                    if (val !== undefined) {\n                        // set one dimension\n                        _ele2.position(dim, val + origin[dim]);\n                    } else if (ppos !== undefined) {\n                        // set whole position\n                        _ele2.position({\n                            x: ppos.x + origin.x,\n                            y: ppos.y + origin.y\n                        });\n                    }\n                }\n            } else {\n                // getting\n                var pos = ele.position();\n                var _parent = hasCompoundNodes ? ele.parent() : null;\n                var _hasParent = _parent && _parent.length > 0;\n                var _relativeToParent = _hasParent;\n                if (_hasParent) {\n                    _parent = _parent[0];\n                }\n                var _origin = _relativeToParent ? _parent.position() : {\n                    x: 0,\n                    y: 0\n                };\n                ppos = {\n                    x: pos.x - _origin.x,\n                    y: pos.y - _origin.y\n                };\n                if (dim === undefined) {\n                    // then return the whole rendered position\n                    return ppos;\n                } else {\n                    // then return the specified dimension\n                    return ppos[dim];\n                }\n            }\n        } else if (!setting) {\n            return undefined; // for empty collection case\n        }\n        return this; // chaining\n    }\n};\n// aliases\nfn$4.modelPosition = fn$4.point = fn$4.position;\nfn$4.modelPositions = fn$4.points = fn$4.positions;\nfn$4.renderedPoint = fn$4.renderedPosition;\nfn$4.relativePoint = fn$4.relativePosition;\nvar position = elesfn$c;\nvar fn$3, elesfn$b;\nfn$3 = elesfn$b = {};\nelesfn$b.renderedBoundingBox = function(options) {\n    var bb = this.boundingBox(options);\n    var cy = this.cy();\n    var zoom = cy.zoom();\n    var pan = cy.pan();\n    var x1 = bb.x1 * zoom + pan.x;\n    var x2 = bb.x2 * zoom + pan.x;\n    var y1 = bb.y1 * zoom + pan.y;\n    var y2 = bb.y2 * zoom + pan.y;\n    return {\n        x1: x1,\n        x2: x2,\n        y1: y1,\n        y2: y2,\n        w: x2 - x1,\n        h: y2 - y1\n    };\n};\nelesfn$b.dirtyCompoundBoundsCache = function() {\n    var silent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy();\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n        return this;\n    }\n    this.forEachUp(function(ele) {\n        if (ele.isParent()) {\n            var _p = ele._private;\n            _p.compoundBoundsClean = false;\n            _p.bbCache = null;\n            if (!silent) {\n                ele.emitAndNotify('bounds');\n            }\n        }\n    });\n    return this;\n};\nelesfn$b.updateCompoundBounds = function() {\n    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var cy = this.cy();\n    // not possible to do on non-compound graphs or with the style disabled\n    if (!cy.styleEnabled() || !cy.hasCompoundNodes()) {\n        return this;\n    }\n    // save cycles when batching -- but bounds will be stale (or not exist yet)\n    if (!force && cy.batching()) {\n        return this;\n    }\n    function update(parent) {\n        if (!parent.isParent()) {\n            return;\n        }\n        var _p = parent._private;\n        var children = parent.children();\n        var includeLabels = parent.pstyle('compound-sizing-wrt-labels').value === 'include';\n        var min = {\n            width: {\n                val: parent.pstyle('min-width').pfValue,\n                left: parent.pstyle('min-width-bias-left'),\n                right: parent.pstyle('min-width-bias-right')\n            },\n            height: {\n                val: parent.pstyle('min-height').pfValue,\n                top: parent.pstyle('min-height-bias-top'),\n                bottom: parent.pstyle('min-height-bias-bottom')\n            }\n        };\n        var bb = children.boundingBox({\n            includeLabels: includeLabels,\n            includeOverlays: false,\n            // updating the compound bounds happens outside of the regular\n            // cache cycle (i.e. before fired events)\n            useCache: false\n        });\n        var pos = _p.position;\n        // if children take up zero area then keep position and fall back on stylesheet w/h\n        if (bb.w === 0 || bb.h === 0) {\n            bb = {\n                w: parent.pstyle('width').pfValue,\n                h: parent.pstyle('height').pfValue\n            };\n            bb.x1 = pos.x - bb.w / 2;\n            bb.x2 = pos.x + bb.w / 2;\n            bb.y1 = pos.y - bb.h / 2;\n            bb.y2 = pos.y + bb.h / 2;\n        }\n        function computeBiasValues(propDiff, propBias, propBiasComplement) {\n            var biasDiff = 0;\n            var biasComplementDiff = 0;\n            var biasTotal = propBias + propBiasComplement;\n            if (propDiff > 0 && biasTotal > 0) {\n                biasDiff = propBias / biasTotal * propDiff;\n                biasComplementDiff = propBiasComplement / biasTotal * propDiff;\n            }\n            return {\n                biasDiff: biasDiff,\n                biasComplementDiff: biasComplementDiff\n            };\n        }\n        function computePaddingValues(width, height, paddingObject, relativeTo) {\n            // Assuming percentage is number from 0 to 1\n            if (paddingObject.units === '%') {\n                switch(relativeTo){\n                    case 'width':\n                        return width > 0 ? paddingObject.pfValue * width : 0;\n                    case 'height':\n                        return height > 0 ? paddingObject.pfValue * height : 0;\n                    case 'average':\n                        return width > 0 && height > 0 ? paddingObject.pfValue * (width + height) / 2 : 0;\n                    case 'min':\n                        return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * height : paddingObject.pfValue * width : 0;\n                    case 'max':\n                        return width > 0 && height > 0 ? width > height ? paddingObject.pfValue * width : paddingObject.pfValue * height : 0;\n                    default:\n                        return 0;\n                }\n            } else if (paddingObject.units === 'px') {\n                return paddingObject.pfValue;\n            } else {\n                return 0;\n            }\n        }\n        var leftVal = min.width.left.value;\n        if (min.width.left.units === 'px' && min.width.val > 0) {\n            leftVal = leftVal * 100 / min.width.val;\n        }\n        var rightVal = min.width.right.value;\n        if (min.width.right.units === 'px' && min.width.val > 0) {\n            rightVal = rightVal * 100 / min.width.val;\n        }\n        var topVal = min.height.top.value;\n        if (min.height.top.units === 'px' && min.height.val > 0) {\n            topVal = topVal * 100 / min.height.val;\n        }\n        var bottomVal = min.height.bottom.value;\n        if (min.height.bottom.units === 'px' && min.height.val > 0) {\n            bottomVal = bottomVal * 100 / min.height.val;\n        }\n        var widthBiasDiffs = computeBiasValues(min.width.val - bb.w, leftVal, rightVal);\n        var diffLeft = widthBiasDiffs.biasDiff;\n        var diffRight = widthBiasDiffs.biasComplementDiff;\n        var heightBiasDiffs = computeBiasValues(min.height.val - bb.h, topVal, bottomVal);\n        var diffTop = heightBiasDiffs.biasDiff;\n        var diffBottom = heightBiasDiffs.biasComplementDiff;\n        _p.autoPadding = computePaddingValues(bb.w, bb.h, parent.pstyle('padding'), parent.pstyle('padding-relative-to').value);\n        _p.autoWidth = Math.max(bb.w, min.width.val);\n        pos.x = (-diffLeft + bb.x1 + bb.x2 + diffRight) / 2;\n        _p.autoHeight = Math.max(bb.h, min.height.val);\n        pos.y = (-diffTop + bb.y1 + bb.y2 + diffBottom) / 2;\n    }\n    for(var i = 0; i < this.length; i++){\n        var ele = this[i];\n        var _p = ele._private;\n        if (!_p.compoundBoundsClean || force) {\n            update(ele);\n            if (!cy.batching()) {\n                _p.compoundBoundsClean = true;\n            }\n        }\n    }\n    return this;\n};\nvar noninf = function noninf(x) {\n    if (x === Infinity || x === -Infinity) {\n        return 0;\n    }\n    return x;\n};\nvar updateBounds = function updateBounds(b, x1, y1, x2, y2) {\n    // don't update with zero area boxes\n    if (x2 - x1 === 0 || y2 - y1 === 0) {\n        return;\n    }\n    // don't update with null dim\n    if (x1 == null || y1 == null || x2 == null || y2 == null) {\n        return;\n    }\n    b.x1 = x1 < b.x1 ? x1 : b.x1;\n    b.x2 = x2 > b.x2 ? x2 : b.x2;\n    b.y1 = y1 < b.y1 ? y1 : b.y1;\n    b.y2 = y2 > b.y2 ? y2 : b.y2;\n    b.w = b.x2 - b.x1;\n    b.h = b.y2 - b.y1;\n};\nvar updateBoundsFromBox = function updateBoundsFromBox(b, b2) {\n    if (b2 == null) {\n        return b;\n    }\n    return updateBounds(b, b2.x1, b2.y1, b2.x2, b2.y2);\n};\nvar prefixedProperty = function prefixedProperty(obj, field, prefix) {\n    return getPrefixedProperty(obj, field, prefix);\n};\nvar updateBoundsFromArrow = function updateBoundsFromArrow(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var halfArW = rstyle.arrowWidth / 2;\n    var arrowType = ele.pstyle(prefix + '-arrow-shape').value;\n    var x;\n    var y;\n    if (arrowType !== 'none') {\n        if (prefix === 'source') {\n            x = rstyle.srcX;\n            y = rstyle.srcY;\n        } else if (prefix === 'target') {\n            x = rstyle.tgtX;\n            y = rstyle.tgtY;\n        } else {\n            x = rstyle.midX;\n            y = rstyle.midY;\n        }\n        // always store the individual arrow bounds\n        var bbs = _p.arrowBounds = _p.arrowBounds || {};\n        var bb = bbs[prefix] = bbs[prefix] || {};\n        bb.x1 = x - halfArW;\n        bb.y1 = y - halfArW;\n        bb.x2 = x + halfArW;\n        bb.y2 = y + halfArW;\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n        expandBoundingBox(bb, 1);\n        updateBounds(bounds, bb.x1, bb.y1, bb.x2, bb.y2);\n    }\n};\nvar updateBoundsFromLabel = function updateBoundsFromLabel(bounds, ele, prefix) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var prefixDash;\n    if (prefix) {\n        prefixDash = prefix + '-';\n    } else {\n        prefixDash = '';\n    }\n    var _p = ele._private;\n    var rstyle = _p.rstyle;\n    var label = ele.pstyle(prefixDash + 'label').strValue;\n    if (label) {\n        var halign = ele.pstyle('text-halign');\n        var valign = ele.pstyle('text-valign');\n        var labelWidth = prefixedProperty(rstyle, 'labelWidth', prefix);\n        var labelHeight = prefixedProperty(rstyle, 'labelHeight', prefix);\n        var labelX = prefixedProperty(rstyle, 'labelX', prefix);\n        var labelY = prefixedProperty(rstyle, 'labelY', prefix);\n        var marginX = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n        var marginY = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n        var isEdge = ele.isEdge();\n        var rotation = ele.pstyle(prefixDash + 'text-rotation');\n        var outlineWidth = ele.pstyle('text-outline-width').pfValue;\n        var borderWidth = ele.pstyle('text-border-width').pfValue;\n        var halfBorderWidth = borderWidth / 2;\n        var padding = ele.pstyle('text-background-padding').pfValue;\n        var marginOfError = 2; // expand to work around browser dimension inaccuracies\n        var lh = labelHeight;\n        var lw = labelWidth;\n        var lw_2 = lw / 2;\n        var lh_2 = lh / 2;\n        var lx1, lx2, ly1, ly2;\n        if (isEdge) {\n            lx1 = labelX - lw_2;\n            lx2 = labelX + lw_2;\n            ly1 = labelY - lh_2;\n            ly2 = labelY + lh_2;\n        } else {\n            switch(halign.value){\n                case 'left':\n                    lx1 = labelX - lw;\n                    lx2 = labelX;\n                    break;\n                case 'center':\n                    lx1 = labelX - lw_2;\n                    lx2 = labelX + lw_2;\n                    break;\n                case 'right':\n                    lx1 = labelX;\n                    lx2 = labelX + lw;\n                    break;\n            }\n            switch(valign.value){\n                case 'top':\n                    ly1 = labelY - lh;\n                    ly2 = labelY;\n                    break;\n                case 'center':\n                    ly1 = labelY - lh_2;\n                    ly2 = labelY + lh_2;\n                    break;\n                case 'bottom':\n                    ly1 = labelY;\n                    ly2 = labelY + lh;\n                    break;\n            }\n        }\n        // shift by margin and expand by outline and border\n        var leftPad = marginX - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n        var rightPad = marginX + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n        var topPad = marginY - Math.max(outlineWidth, halfBorderWidth) - padding - marginOfError;\n        var botPad = marginY + Math.max(outlineWidth, halfBorderWidth) + padding + marginOfError;\n        lx1 += leftPad;\n        lx2 += rightPad;\n        ly1 += topPad;\n        ly2 += botPad;\n        // always store the unrotated label bounds separately\n        var bbPrefix = prefix || 'main';\n        var bbs = _p.labelBounds;\n        var bb = bbs[bbPrefix] = bbs[bbPrefix] || {};\n        bb.x1 = lx1;\n        bb.y1 = ly1;\n        bb.x2 = lx2;\n        bb.y2 = ly2;\n        bb.w = lx2 - lx1;\n        bb.h = ly2 - ly1;\n        bb.leftPad = leftPad;\n        bb.rightPad = rightPad;\n        bb.topPad = topPad;\n        bb.botPad = botPad;\n        var isAutorotate = isEdge && rotation.strValue === 'autorotate';\n        var isPfValue = rotation.pfValue != null && rotation.pfValue !== 0;\n        if (isAutorotate || isPfValue) {\n            var theta = isAutorotate ? prefixedProperty(_p.rstyle, 'labelAngle', prefix) : rotation.pfValue;\n            var cos = Math.cos(theta);\n            var sin = Math.sin(theta);\n            // rotation point (default value for center-center)\n            var xo = (lx1 + lx2) / 2;\n            var yo = (ly1 + ly2) / 2;\n            if (!isEdge) {\n                switch(halign.value){\n                    case 'left':\n                        xo = lx2;\n                        break;\n                    case 'right':\n                        xo = lx1;\n                        break;\n                }\n                switch(valign.value){\n                    case 'top':\n                        yo = ly2;\n                        break;\n                    case 'bottom':\n                        yo = ly1;\n                        break;\n                }\n            }\n            var rotate = function rotate(x, y) {\n                x = x - xo;\n                y = y - yo;\n                return {\n                    x: x * cos - y * sin + xo,\n                    y: x * sin + y * cos + yo\n                };\n            };\n            var px1y1 = rotate(lx1, ly1);\n            var px1y2 = rotate(lx1, ly2);\n            var px2y1 = rotate(lx2, ly1);\n            var px2y2 = rotate(lx2, ly2);\n            lx1 = Math.min(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n            lx2 = Math.max(px1y1.x, px1y2.x, px2y1.x, px2y2.x);\n            ly1 = Math.min(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n            ly2 = Math.max(px1y1.y, px1y2.y, px2y1.y, px2y2.y);\n        }\n        var bbPrefixRot = bbPrefix + 'Rot';\n        var bbRot = bbs[bbPrefixRot] = bbs[bbPrefixRot] || {};\n        bbRot.x1 = lx1;\n        bbRot.y1 = ly1;\n        bbRot.x2 = lx2;\n        bbRot.y2 = ly2;\n        bbRot.w = lx2 - lx1;\n        bbRot.h = ly2 - ly1;\n        updateBounds(bounds, lx1, ly1, lx2, ly2);\n        updateBounds(_p.labelBounds.all, lx1, ly1, lx2, ly2);\n    }\n    return bounds;\n};\nvar updateBoundsFromOutline = function updateBoundsFromOutline(bounds, ele) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var outlineOpacity = ele.pstyle('outline-opacity').value;\n    var outlineWidth = ele.pstyle('outline-width').value;\n    var outlineOffset = ele.pstyle('outline-offset').value;\n    var expansion = outlineWidth + outlineOffset;\n    updateBoundsFromMiter(bounds, ele, outlineOpacity, expansion, 'outside', expansion / 2);\n};\nvar updateBoundsFromMiter = function updateBoundsFromMiter(bounds, ele, opacity, expansionSize, expansionPosition, useFallbackValue) {\n    if (opacity === 0 || expansionSize <= 0 || expansionPosition === 'inside') {\n        return;\n    }\n    var cy = ele.cy();\n    var shape = ele.pstyle('shape').value;\n    var rshape = cy.renderer().nodeShapes[shape];\n    var _ele$position = ele.position(), x = _ele$position.x, y = _ele$position.y;\n    var w = ele.width();\n    var h = ele.height();\n    if (rshape.hasMiterBounds) {\n        if (expansionPosition === 'center') {\n            expansionSize /= 2;\n        }\n        var mbb = rshape.miterBounds(x, y, w, h, expansionSize);\n        updateBoundsFromBox(bounds, mbb);\n    } else if (useFallbackValue != null && useFallbackValue > 0) {\n        expandBoundingBoxSides(bounds, [\n            useFallbackValue,\n            useFallbackValue,\n            useFallbackValue,\n            useFallbackValue\n        ]);\n    }\n};\nvar updateBoundsFromMiterBorder = function updateBoundsFromMiterBorder(bounds, ele) {\n    if (ele.cy().headless()) {\n        return;\n    }\n    var borderOpacity = ele.pstyle('border-opacity').value;\n    var borderWidth = ele.pstyle('border-width').pfValue;\n    var borderPosition = ele.pstyle('border-position').value;\n    updateBoundsFromMiter(bounds, ele, borderOpacity, borderWidth, borderPosition);\n};\n// get the bounding box of the elements (in raw model position)\nvar boundingBoxImpl = function boundingBoxImpl(ele, options) {\n    var cy = ele._private.cy;\n    var styleEnabled = cy.styleEnabled();\n    var headless = cy.headless();\n    var bounds = makeBoundingBox();\n    var _p = ele._private;\n    var isNode = ele.isNode();\n    var isEdge = ele.isEdge();\n    var ex1, ex2, ey1, ey2; // extrema of body / lines\n    var x, y; // node pos\n    var rstyle = _p.rstyle;\n    var manualExpansion = isNode && styleEnabled ? ele.pstyle('bounds-expansion').pfValue : [\n        0\n    ];\n    // must use `display` prop only, as reading `compound.width()` causes recursion\n    // (other factors like width values will be considered later in this function anyway)\n    var isDisplayed = function isDisplayed(ele) {\n        return ele.pstyle('display').value !== 'none';\n    };\n    var displayed = !styleEnabled || isDisplayed(ele) && (!isEdge || isDisplayed(ele.source()) && isDisplayed(ele.target()));\n    if (displayed) {\n        // displayed suffices, since we will find zero area eles anyway\n        var overlayOpacity = 0;\n        var overlayPadding = 0;\n        if (styleEnabled && options.includeOverlays) {\n            overlayOpacity = ele.pstyle('overlay-opacity').value;\n            if (overlayOpacity !== 0) {\n                overlayPadding = ele.pstyle('overlay-padding').value;\n            }\n        }\n        var underlayOpacity = 0;\n        var underlayPadding = 0;\n        if (styleEnabled && options.includeUnderlays) {\n            underlayOpacity = ele.pstyle('underlay-opacity').value;\n            if (underlayOpacity !== 0) {\n                underlayPadding = ele.pstyle('underlay-padding').value;\n            }\n        }\n        var padding = Math.max(overlayPadding, underlayPadding);\n        var w = 0;\n        var wHalf = 0;\n        if (styleEnabled) {\n            w = ele.pstyle('width').pfValue;\n            wHalf = w / 2;\n        }\n        if (isNode && options.includeNodes) {\n            var pos = ele.position();\n            x = pos.x;\n            y = pos.y;\n            var _w = ele.outerWidth();\n            var halfW = _w / 2;\n            var h = ele.outerHeight();\n            var halfH = h / 2;\n            // handle node dimensions\n            /////////////////////////\n            ex1 = x - halfW;\n            ex2 = x + halfW;\n            ey1 = y - halfH;\n            ey2 = y + halfH;\n            updateBounds(bounds, ex1, ey1, ex2, ey2);\n            if (styleEnabled) {\n                updateBoundsFromOutline(bounds, ele);\n            }\n            if (styleEnabled && options.includeOutlines && !headless) {\n                updateBoundsFromOutline(bounds, ele);\n            }\n            if (styleEnabled) {\n                updateBoundsFromMiterBorder(bounds, ele);\n            }\n        } else if (isEdge && options.includeEdges) {\n            if (styleEnabled && !headless) {\n                var curveStyle = ele.pstyle('curve-style').strValue;\n                // handle edge dimensions (rough box estimate)\n                //////////////////////////////////////////////\n                ex1 = Math.min(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n                ex2 = Math.max(rstyle.srcX, rstyle.midX, rstyle.tgtX);\n                ey1 = Math.min(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n                ey2 = Math.max(rstyle.srcY, rstyle.midY, rstyle.tgtY);\n                // take into account edge width\n                ex1 -= wHalf;\n                ex2 += wHalf;\n                ey1 -= wHalf;\n                ey2 += wHalf;\n                updateBounds(bounds, ex1, ey1, ex2, ey2);\n                // precise edges\n                ////////////////\n                if (curveStyle === 'haystack') {\n                    var hpts = rstyle.haystackPts;\n                    if (hpts && hpts.length === 2) {\n                        ex1 = hpts[0].x;\n                        ey1 = hpts[0].y;\n                        ex2 = hpts[1].x;\n                        ey2 = hpts[1].y;\n                        if (ex1 > ex2) {\n                            var temp = ex1;\n                            ex1 = ex2;\n                            ex2 = temp;\n                        }\n                        if (ey1 > ey2) {\n                            var _temp = ey1;\n                            ey1 = ey2;\n                            ey2 = _temp;\n                        }\n                        updateBounds(bounds, ex1 - wHalf, ey1 - wHalf, ex2 + wHalf, ey2 + wHalf);\n                    }\n                } else if (curveStyle === 'bezier' || curveStyle === 'unbundled-bezier' || endsWith(curveStyle, 'segments') || endsWith(curveStyle, 'taxi')) {\n                    var pts;\n                    switch(curveStyle){\n                        case 'bezier':\n                        case 'unbundled-bezier':\n                            pts = rstyle.bezierPts;\n                            break;\n                        case 'segments':\n                        case 'taxi':\n                        case 'round-segments':\n                        case 'round-taxi':\n                            pts = rstyle.linePts;\n                            break;\n                    }\n                    if (pts != null) {\n                        for(var j = 0; j < pts.length; j++){\n                            var pt = pts[j];\n                            ex1 = pt.x - wHalf;\n                            ex2 = pt.x + wHalf;\n                            ey1 = pt.y - wHalf;\n                            ey2 = pt.y + wHalf;\n                            updateBounds(bounds, ex1, ey1, ex2, ey2);\n                        }\n                    }\n                } // bezier-like or segment-like edge\n            } else {\n                // headless or style disabled\n                // fallback on source and target positions\n                //////////////////////////////////////////\n                var n1 = ele.source();\n                var n1pos = n1.position();\n                var n2 = ele.target();\n                var n2pos = n2.position();\n                ex1 = n1pos.x;\n                ex2 = n2pos.x;\n                ey1 = n1pos.y;\n                ey2 = n2pos.y;\n                if (ex1 > ex2) {\n                    var _temp2 = ex1;\n                    ex1 = ex2;\n                    ex2 = _temp2;\n                }\n                if (ey1 > ey2) {\n                    var _temp3 = ey1;\n                    ey1 = ey2;\n                    ey2 = _temp3;\n                }\n                // take into account edge width\n                ex1 -= wHalf;\n                ex2 += wHalf;\n                ey1 -= wHalf;\n                ey2 += wHalf;\n                updateBounds(bounds, ex1, ey1, ex2, ey2);\n            } // headless or style disabled\n        } // edges\n        // handle edge arrow size\n        /////////////////////////\n        if (styleEnabled && options.includeEdges && isEdge) {\n            updateBoundsFromArrow(bounds, ele, 'mid-source');\n            updateBoundsFromArrow(bounds, ele, 'mid-target');\n            updateBoundsFromArrow(bounds, ele, 'source');\n            updateBoundsFromArrow(bounds, ele, 'target');\n        }\n        // ghost\n        ////////\n        if (styleEnabled) {\n            var ghost = ele.pstyle('ghost').value === 'yes';\n            if (ghost) {\n                var gx = ele.pstyle('ghost-offset-x').pfValue;\n                var gy = ele.pstyle('ghost-offset-y').pfValue;\n                updateBounds(bounds, bounds.x1 + gx, bounds.y1 + gy, bounds.x2 + gx, bounds.y2 + gy);\n            }\n        }\n        // always store the body bounds separately from the labels\n        var bbBody = _p.bodyBounds = _p.bodyBounds || {};\n        assignBoundingBox(bbBody, bounds);\n        expandBoundingBoxSides(bbBody, manualExpansion);\n        expandBoundingBox(bbBody, 1); // expand to work around browser dimension inaccuracies\n        // overlay\n        //////////\n        if (styleEnabled) {\n            ex1 = bounds.x1;\n            ex2 = bounds.x2;\n            ey1 = bounds.y1;\n            ey2 = bounds.y2;\n            updateBounds(bounds, ex1 - padding, ey1 - padding, ex2 + padding, ey2 + padding);\n        }\n        // always store the body bounds separately from the labels\n        var bbOverlay = _p.overlayBounds = _p.overlayBounds || {};\n        assignBoundingBox(bbOverlay, bounds);\n        expandBoundingBoxSides(bbOverlay, manualExpansion);\n        expandBoundingBox(bbOverlay, 1); // expand to work around browser dimension inaccuracies\n        // handle label dimensions\n        //////////////////////////\n        var bbLabels = _p.labelBounds = _p.labelBounds || {};\n        if (bbLabels.all != null) {\n            clearBoundingBox(bbLabels.all);\n        } else {\n            bbLabels.all = makeBoundingBox();\n        }\n        if (styleEnabled && options.includeLabels) {\n            if (options.includeMainLabels) {\n                updateBoundsFromLabel(bounds, ele, null);\n            }\n            if (isEdge) {\n                if (options.includeSourceLabels) {\n                    updateBoundsFromLabel(bounds, ele, 'source');\n                }\n                if (options.includeTargetLabels) {\n                    updateBoundsFromLabel(bounds, ele, 'target');\n                }\n            }\n        } // style enabled for labels\n    } // if displayed\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n    if (bounds.w > 0 && bounds.h > 0 && displayed) {\n        expandBoundingBoxSides(bounds, manualExpansion);\n        // expand bounds by 1 because antialiasing can increase the visual/effective size by 1 on all sides\n        expandBoundingBox(bounds, 1);\n    }\n    return bounds;\n};\nvar getKey = function getKey(opts) {\n    var i = 0;\n    var tf = function tf(val) {\n        return (val ? 1 : 0) << i++;\n    };\n    var key = 0;\n    key += tf(opts.incudeNodes);\n    key += tf(opts.includeEdges);\n    key += tf(opts.includeLabels);\n    key += tf(opts.includeMainLabels);\n    key += tf(opts.includeSourceLabels);\n    key += tf(opts.includeTargetLabels);\n    key += tf(opts.includeOverlays);\n    key += tf(opts.includeOutlines);\n    return key;\n};\nvar getBoundingBoxPosKey = function getBoundingBoxPosKey(ele) {\n    var r = function r(x) {\n        return Math.round(x);\n    };\n    if (ele.isEdge()) {\n        var p1 = ele.source().position();\n        var p2 = ele.target().position();\n        return hashIntsArray([\n            r(p1.x),\n            r(p1.y),\n            r(p2.x),\n            r(p2.y)\n        ]);\n    } else {\n        var p = ele.position();\n        return hashIntsArray([\n            r(p.x),\n            r(p.y)\n        ]);\n    }\n};\nvar cachedBoundingBoxImpl = function cachedBoundingBoxImpl(ele, opts) {\n    var _p = ele._private;\n    var bb;\n    var isEdge = ele.isEdge();\n    var key = opts == null ? defBbOptsKey : getKey(opts);\n    var usingDefOpts = key === defBbOptsKey;\n    if (_p.bbCache == null) {\n        bb = boundingBoxImpl(ele, defBbOpts);\n        _p.bbCache = bb;\n        _p.bbCachePosKey = getBoundingBoxPosKey(ele);\n    } else {\n        bb = _p.bbCache;\n    }\n    // not using def opts => need to build up bb from combination of sub bbs\n    if (!usingDefOpts) {\n        var isNode = ele.isNode();\n        bb = makeBoundingBox();\n        if (opts.includeNodes && isNode || opts.includeEdges && !isNode) {\n            if (opts.includeOverlays) {\n                updateBoundsFromBox(bb, _p.overlayBounds);\n            } else {\n                updateBoundsFromBox(bb, _p.bodyBounds);\n            }\n        }\n        if (opts.includeLabels) {\n            if (opts.includeMainLabels && (!isEdge || opts.includeSourceLabels && opts.includeTargetLabels)) {\n                updateBoundsFromBox(bb, _p.labelBounds.all);\n            } else {\n                if (opts.includeMainLabels) {\n                    updateBoundsFromBox(bb, _p.labelBounds.mainRot);\n                }\n                if (opts.includeSourceLabels) {\n                    updateBoundsFromBox(bb, _p.labelBounds.sourceRot);\n                }\n                if (opts.includeTargetLabels) {\n                    updateBoundsFromBox(bb, _p.labelBounds.targetRot);\n                }\n            }\n        }\n        bb.w = bb.x2 - bb.x1;\n        bb.h = bb.y2 - bb.y1;\n    }\n    return bb;\n};\nvar defBbOpts = {\n    includeNodes: true,\n    includeEdges: true,\n    includeLabels: true,\n    includeMainLabels: true,\n    includeSourceLabels: true,\n    includeTargetLabels: true,\n    includeOverlays: true,\n    includeUnderlays: true,\n    includeOutlines: true,\n    useCache: true\n};\nvar defBbOptsKey = getKey(defBbOpts);\nvar filledBbOpts = defaults$g(defBbOpts);\nelesfn$b.boundingBox = function(options) {\n    var bounds;\n    var useCache = options === undefined || options.useCache === undefined || options.useCache === true;\n    var isDirty = memoize(function(ele) {\n        var _p = ele._private;\n        return _p.bbCache == null || _p.styleDirty || _p.bbCachePosKey !== getBoundingBoxPosKey(ele);\n    }, function(ele) {\n        return ele.id();\n    });\n    // the main usecase is ele.boundingBox() for a single element with no/def options\n    // specified s.t. the cache is used, so check for this case to make it faster by\n    // avoiding the overhead of the rest of the function\n    if (useCache && this.length === 1 && !isDirty(this[0])) {\n        if (options === undefined) {\n            options = defBbOpts;\n        } else {\n            options = filledBbOpts(options);\n        }\n        bounds = cachedBoundingBoxImpl(this[0], options);\n    } else {\n        bounds = makeBoundingBox();\n        options = options || defBbOpts;\n        var opts = filledBbOpts(options);\n        var eles = this;\n        var cy = eles.cy();\n        var styleEnabled = cy.styleEnabled();\n        // cache the isDirty state for all eles, edges first since they depend on node state\n        this.edges().forEach(isDirty);\n        this.nodes().forEach(isDirty);\n        if (styleEnabled) {\n            this.recalculateRenderedStyle(useCache);\n        }\n        this.updateCompoundBounds(!useCache);\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (isDirty(ele)) {\n                ele.dirtyBoundingBoxCache();\n            }\n            updateBoundsFromBox(bounds, cachedBoundingBoxImpl(ele, opts));\n        }\n    }\n    bounds.x1 = noninf(bounds.x1);\n    bounds.y1 = noninf(bounds.y1);\n    bounds.x2 = noninf(bounds.x2);\n    bounds.y2 = noninf(bounds.y2);\n    bounds.w = noninf(bounds.x2 - bounds.x1);\n    bounds.h = noninf(bounds.y2 - bounds.y1);\n    return bounds;\n};\nelesfn$b.dirtyBoundingBoxCache = function() {\n    for(var i = 0; i < this.length; i++){\n        var _p = this[i]._private;\n        _p.bbCache = null;\n        _p.bbCachePosKey = null;\n        _p.bodyBounds = null;\n        _p.overlayBounds = null;\n        _p.labelBounds.all = null;\n        _p.labelBounds.source = null;\n        _p.labelBounds.target = null;\n        _p.labelBounds.main = null;\n        _p.labelBounds.sourceRot = null;\n        _p.labelBounds.targetRot = null;\n        _p.labelBounds.mainRot = null;\n        _p.arrowBounds.source = null;\n        _p.arrowBounds.target = null;\n        _p.arrowBounds['mid-source'] = null;\n        _p.arrowBounds['mid-target'] = null;\n    }\n    this.emitAndNotify('bounds');\n    return this;\n};\n// private helper to get bounding box for custom node positions\n// - good for perf in certain cases but currently requires dirtying the rendered style\n// - would be better to not modify the nodes but the nodes are read directly everywhere in the renderer...\n// - try to use for only things like discrete layouts where the node position would change anyway\nelesfn$b.boundingBoxAt = function(fn) {\n    var nodes = this.nodes();\n    var cy = this.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var parents = cy.collection();\n    if (hasCompoundNodes) {\n        parents = nodes.filter(function(node) {\n            return node.isParent();\n        });\n        nodes = nodes.not(parents);\n    }\n    if (plainObject(fn)) {\n        var obj = fn;\n        fn = function fn() {\n            return obj;\n        };\n    }\n    var storeOldPos = function storeOldPos(node, i) {\n        return node._private.bbAtOldPos = fn(node, i);\n    };\n    var getOldPos = function getOldPos(node) {\n        return node._private.bbAtOldPos;\n    };\n    cy.startBatch();\n    nodes.forEach(storeOldPos).silentPositions(fn);\n    if (hasCompoundNodes) {\n        parents.dirtyCompoundBoundsCache();\n        parents.dirtyBoundingBoxCache();\n        parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n    var bb = copyBoundingBox(this.boundingBox({\n        useCache: false\n    }));\n    nodes.silentPositions(getOldPos);\n    if (hasCompoundNodes) {\n        parents.dirtyCompoundBoundsCache();\n        parents.dirtyBoundingBoxCache();\n        parents.updateCompoundBounds(true); // force update b/c we're inside a batch cycle\n    }\n    cy.endBatch();\n    return bb;\n};\nfn$3.boundingbox = fn$3.bb = fn$3.boundingBox;\nfn$3.renderedBoundingbox = fn$3.renderedBoundingBox;\nvar bounds = elesfn$b;\nvar fn$2, elesfn$a;\nfn$2 = elesfn$a = {};\nvar defineDimFns = function defineDimFns(opts) {\n    opts.uppercaseName = capitalize(opts.name);\n    opts.autoName = 'auto' + opts.uppercaseName;\n    opts.labelName = 'label' + opts.uppercaseName;\n    opts.outerName = 'outer' + opts.uppercaseName;\n    opts.uppercaseOuterName = capitalize(opts.outerName);\n    fn$2[opts.name] = function dimImpl() {\n        var ele = this[0];\n        var _p = ele._private;\n        var cy = _p.cy;\n        var styleEnabled = cy._private.styleEnabled;\n        if (ele) {\n            if (styleEnabled) {\n                if (ele.isParent()) {\n                    ele.updateCompoundBounds();\n                    return _p[opts.autoName] || 0;\n                }\n                var d = ele.pstyle(opts.name);\n                switch(d.strValue){\n                    case 'label':\n                        ele.recalculateRenderedStyle();\n                        return _p.rstyle[opts.labelName] || 0;\n                    default:\n                        return d.pfValue;\n                }\n            } else {\n                return 1;\n            }\n        }\n    };\n    fn$2['outer' + opts.uppercaseName] = function outerDimImpl() {\n        var ele = this[0];\n        var _p = ele._private;\n        var cy = _p.cy;\n        var styleEnabled = cy._private.styleEnabled;\n        if (ele) {\n            if (styleEnabled) {\n                var dim = ele[opts.name]();\n                var borderPos = ele.pstyle('border-position').value;\n                var border;\n                if (borderPos === 'center') {\n                    border = ele.pstyle('border-width').pfValue; // n.b. 1/2 each side\n                } else if (borderPos === 'outside') {\n                    border = 2 * ele.pstyle('border-width').pfValue;\n                } else {\n                    // 'inside'\n                    border = 0;\n                }\n                var padding = 2 * ele.padding();\n                return dim + border + padding;\n            } else {\n                return 1;\n            }\n        }\n    };\n    fn$2['rendered' + opts.uppercaseName] = function renderedDimImpl() {\n        var ele = this[0];\n        if (ele) {\n            var d = ele[opts.name]();\n            return d * this.cy().zoom();\n        }\n    };\n    fn$2['rendered' + opts.uppercaseOuterName] = function renderedOuterDimImpl() {\n        var ele = this[0];\n        if (ele) {\n            var od = ele[opts.outerName]();\n            return od * this.cy().zoom();\n        }\n    };\n};\ndefineDimFns({\n    name: 'width'\n});\ndefineDimFns({\n    name: 'height'\n});\nelesfn$a.padding = function() {\n    var ele = this[0];\n    var _p = ele._private;\n    if (ele.isParent()) {\n        ele.updateCompoundBounds();\n        if (_p.autoPadding !== undefined) {\n            return _p.autoPadding;\n        } else {\n            return ele.pstyle('padding').pfValue;\n        }\n    } else {\n        return ele.pstyle('padding').pfValue;\n    }\n};\nelesfn$a.paddedHeight = function() {\n    var ele = this[0];\n    return ele.height() + 2 * ele.padding();\n};\nelesfn$a.paddedWidth = function() {\n    var ele = this[0];\n    return ele.width() + 2 * ele.padding();\n};\nvar widthHeight = elesfn$a;\nvar ifEdge = function ifEdge(ele, getValue) {\n    if (ele.isEdge() && ele.takesUpSpace()) {\n        return getValue(ele);\n    }\n};\nvar ifEdgeRenderedPosition = function ifEdgeRenderedPosition(ele, getPoint) {\n    if (ele.isEdge() && ele.takesUpSpace()) {\n        var cy = ele.cy();\n        return modelToRenderedPosition$1(getPoint(ele), cy.zoom(), cy.pan());\n    }\n};\nvar ifEdgeRenderedPositions = function ifEdgeRenderedPositions(ele, getPoints) {\n    if (ele.isEdge() && ele.takesUpSpace()) {\n        var cy = ele.cy();\n        var pan = cy.pan();\n        var zoom = cy.zoom();\n        return getPoints(ele).map(function(p) {\n            return modelToRenderedPosition$1(p, zoom, pan);\n        });\n    }\n};\nvar controlPoints = function controlPoints(ele) {\n    return ele.renderer().getControlPoints(ele);\n};\nvar segmentPoints = function segmentPoints(ele) {\n    return ele.renderer().getSegmentPoints(ele);\n};\nvar sourceEndpoint = function sourceEndpoint(ele) {\n    return ele.renderer().getSourceEndpoint(ele);\n};\nvar targetEndpoint = function targetEndpoint(ele) {\n    return ele.renderer().getTargetEndpoint(ele);\n};\nvar midpoint = function midpoint(ele) {\n    return ele.renderer().getEdgeMidpoint(ele);\n};\nvar pts = {\n    controlPoints: {\n        get: controlPoints,\n        mult: true\n    },\n    segmentPoints: {\n        get: segmentPoints,\n        mult: true\n    },\n    sourceEndpoint: {\n        get: sourceEndpoint\n    },\n    targetEndpoint: {\n        get: targetEndpoint\n    },\n    midpoint: {\n        get: midpoint\n    }\n};\nvar renderedName = function renderedName(name) {\n    return 'rendered' + name[0].toUpperCase() + name.substr(1);\n};\nvar edgePoints = Object.keys(pts).reduce(function(obj, name) {\n    var spec = pts[name];\n    var rName = renderedName(name);\n    obj[name] = function() {\n        return ifEdge(this, spec.get);\n    };\n    if (spec.mult) {\n        obj[rName] = function() {\n            return ifEdgeRenderedPositions(this, spec.get);\n        };\n    } else {\n        obj[rName] = function() {\n            return ifEdgeRenderedPosition(this, spec.get);\n        };\n    }\n    return obj;\n}, {});\nvar dimensions = extend({}, position, bounds, widthHeight, edgePoints);\n/*!\nEvent object based on jQuery events, MIT license\n\nhttps://jquery.org/license/\nhttps://tldrlegal.com/license/mit-license\nhttps://github.com/jquery/jquery/blob/master/src/event.js\n*/ var Event = function Event(src, props) {\n    this.recycle(src, props);\n};\nfunction returnFalse() {\n    return false;\n}\nfunction returnTrue() {\n    return true;\n}\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\nEvent.prototype = {\n    instanceString: function instanceString() {\n        return 'event';\n    },\n    recycle: function recycle(src, props) {\n        this.isImmediatePropagationStopped = this.isPropagationStopped = this.isDefaultPrevented = returnFalse;\n        if (src != null && src.preventDefault) {\n            // Browser Event object\n            this.type = src.type;\n            // Events bubbling up the document may have been marked as prevented\n            // by a handler lower down the tree; reflect the correct value.\n            this.isDefaultPrevented = src.defaultPrevented ? returnTrue : returnFalse;\n        } else if (src != null && src.type) {\n            // Plain object containing all event details\n            props = src;\n        } else {\n            // Event string\n            this.type = src;\n        }\n        // Put explicitly provided properties onto the event object\n        if (props != null) {\n            // more efficient to manually copy fields we use\n            this.originalEvent = props.originalEvent;\n            this.type = props.type != null ? props.type : this.type;\n            this.cy = props.cy;\n            this.target = props.target;\n            this.position = props.position;\n            this.renderedPosition = props.renderedPosition;\n            this.namespace = props.namespace;\n            this.layout = props.layout;\n        }\n        if (this.cy != null && this.position != null && this.renderedPosition == null) {\n            // create a rendered position based on the passed position\n            var pos = this.position;\n            var zoom = this.cy.zoom();\n            var pan = this.cy.pan();\n            this.renderedPosition = {\n                x: pos.x * zoom + pan.x,\n                y: pos.y * zoom + pan.y\n            };\n        }\n        // Create a timestamp if incoming event doesn't have one\n        this.timeStamp = src && src.timeStamp || Date.now();\n    },\n    preventDefault: function preventDefault() {\n        this.isDefaultPrevented = returnTrue;\n        var e = this.originalEvent;\n        if (!e) {\n            return;\n        }\n        // if preventDefault exists run it on the original event\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n    },\n    stopPropagation: function stopPropagation() {\n        this.isPropagationStopped = returnTrue;\n        var e = this.originalEvent;\n        if (!e) {\n            return;\n        }\n        // if stopPropagation exists run it on the original event\n        if (e.stopPropagation) {\n            e.stopPropagation();\n        }\n    },\n    stopImmediatePropagation: function stopImmediatePropagation() {\n        this.isImmediatePropagationStopped = returnTrue;\n        this.stopPropagation();\n    },\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse\n};\nvar eventRegex = /^([^.]+)(\\.(?:[^.]+))?$/; // regex for matching event strings (e.g. \"click.namespace\")\nvar universalNamespace = '.*'; // matches as if no namespace specified and prevents users from unbinding accidentally\nvar defaults$8 = {\n    qualifierCompare: function qualifierCompare(q1, q2) {\n        return q1 === q2;\n    },\n    eventMatches: function eventMatches() {\n        return true;\n    },\n    addEventFields: function addEventFields() {},\n    callbackContext: function callbackContext(context /*, listener, eventObj*/ ) {\n        return context;\n    },\n    beforeEmit: function beforeEmit() {},\n    afterEmit: function afterEmit() {},\n    bubble: function bubble() {\n        return false;\n    },\n    parent: function parent() {\n        return null;\n    },\n    context: null\n};\nvar defaultsKeys = Object.keys(defaults$8);\nvar emptyOpts = {};\nfunction Emitter() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyOpts;\n    var context = arguments.length > 1 ? arguments[1] : undefined;\n    // micro-optimisation vs Object.assign() -- reduces Element instantiation time\n    for(var i = 0; i < defaultsKeys.length; i++){\n        var key = defaultsKeys[i];\n        this[key] = opts[key] || defaults$8[key];\n    }\n    this.context = context || this.context;\n    this.listeners = [];\n    this.emitting = 0;\n}\nvar p = Emitter.prototype;\nvar forEachEvent = function forEachEvent(self1, handler, events, qualifier, callback, conf, confOverrides) {\n    if (fn$6(qualifier)) {\n        callback = qualifier;\n        qualifier = null;\n    }\n    if (confOverrides) {\n        if (conf == null) {\n            conf = confOverrides;\n        } else {\n            conf = extend({}, conf, confOverrides);\n        }\n    }\n    var eventList = array(events) ? events : events.split(/\\s+/);\n    for(var i = 0; i < eventList.length; i++){\n        var evt = eventList[i];\n        if (emptyString(evt)) {\n            continue;\n        }\n        var match = evt.match(eventRegex); // type[.namespace]\n        if (match) {\n            var type = match[1];\n            var namespace = match[2] ? match[2] : null;\n            var ret = handler(self1, evt, type, namespace, qualifier, callback, conf);\n            if (ret === false) {\n                break;\n            } // allow exiting early\n        }\n    }\n};\nvar makeEventObj = function makeEventObj(self1, obj) {\n    self1.addEventFields(self1.context, obj);\n    return new Event(obj.type, obj);\n};\nvar forEachEventObj = function forEachEventObj(self1, handler, events) {\n    if (event(events)) {\n        handler(self1, events);\n        return;\n    } else if (plainObject(events)) {\n        handler(self1, makeEventObj(self1, events));\n        return;\n    }\n    var eventList = array(events) ? events : events.split(/\\s+/);\n    for(var i = 0; i < eventList.length; i++){\n        var evt = eventList[i];\n        if (emptyString(evt)) {\n            continue;\n        }\n        var match = evt.match(eventRegex); // type[.namespace]\n        if (match) {\n            var type = match[1];\n            var namespace = match[2] ? match[2] : null;\n            var eventObj = makeEventObj(self1, {\n                type: type,\n                namespace: namespace,\n                target: self1.context\n            });\n            handler(self1, eventObj);\n        }\n    }\n};\np.on = p.addListener = function(events, qualifier, callback, conf, confOverrides) {\n    forEachEvent(this, function(self1, event, type, namespace, qualifier, callback, conf) {\n        if (fn$6(callback)) {\n            self1.listeners.push({\n                event: event,\n                // full event string\n                callback: callback,\n                // callback to run\n                type: type,\n                // the event type (e.g. 'click')\n                namespace: namespace,\n                // the event namespace (e.g. \".foo\")\n                qualifier: qualifier,\n                // a restriction on whether to match this emitter\n                conf: conf // additional configuration\n            });\n        }\n    }, events, qualifier, callback, conf, confOverrides);\n    return this;\n};\np.one = function(events, qualifier, callback, conf) {\n    return this.on(events, qualifier, callback, conf, {\n        one: true\n    });\n};\np.removeListener = p.off = function(events, qualifier, callback, conf) {\n    var _this = this;\n    if (this.emitting !== 0) {\n        this.listeners = copyArray(this.listeners);\n    }\n    var listeners = this.listeners;\n    var _loop = function _loop(i) {\n        var listener = listeners[i];\n        forEachEvent(_this, function(self1, event, type, namespace, qualifier, callback /*, conf*/ ) {\n            if ((listener.type === type || events === '*') && (!namespace && listener.namespace !== '.*' || listener.namespace === namespace) && (!qualifier || self1.qualifierCompare(listener.qualifier, qualifier)) && (!callback || listener.callback === callback)) {\n                listeners.splice(i, 1);\n                return false;\n            }\n        }, events, qualifier, callback, conf);\n    };\n    for(var i = listeners.length - 1; i >= 0; i--){\n        _loop(i);\n    }\n    return this;\n};\np.removeAllListeners = function() {\n    return this.removeListener('*');\n};\np.emit = p.trigger = function(events, extraParams, manualCallback) {\n    var listeners = this.listeners;\n    var numListenersBeforeEmit = listeners.length;\n    this.emitting++;\n    if (!array(extraParams)) {\n        extraParams = [\n            extraParams\n        ];\n    }\n    forEachEventObj(this, function(self1, eventObj) {\n        if (manualCallback != null) {\n            listeners = [\n                {\n                    event: eventObj.event,\n                    type: eventObj.type,\n                    namespace: eventObj.namespace,\n                    callback: manualCallback\n                }\n            ];\n            numListenersBeforeEmit = listeners.length;\n        }\n        var _loop2 = function _loop2() {\n            var listener = listeners[i];\n            if (listener.type === eventObj.type && (!listener.namespace || listener.namespace === eventObj.namespace || listener.namespace === universalNamespace) && self1.eventMatches(self1.context, listener, eventObj)) {\n                var args = [\n                    eventObj\n                ];\n                if (extraParams != null) {\n                    push(args, extraParams);\n                }\n                self1.beforeEmit(self1.context, listener, eventObj);\n                if (listener.conf && listener.conf.one) {\n                    self1.listeners = self1.listeners.filter(function(l) {\n                        return l !== listener;\n                    });\n                }\n                var context = self1.callbackContext(self1.context, listener, eventObj);\n                var ret = listener.callback.apply(context, args);\n                self1.afterEmit(self1.context, listener, eventObj);\n                if (ret === false) {\n                    eventObj.stopPropagation();\n                    eventObj.preventDefault();\n                }\n            } // if listener matches\n        };\n        for(var i = 0; i < numListenersBeforeEmit; i++){\n            _loop2();\n        } // for listener\n        if (self1.bubble(self1.context) && !eventObj.isPropagationStopped()) {\n            self1.parent(self1.context).emit(eventObj, extraParams);\n        }\n    }, events);\n    this.emitting--;\n    return this;\n};\nvar emitterOptions$1 = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n        if (selector1 == null || selector2 == null) {\n            return selector1 == null && selector2 == null;\n        } else {\n            return selector1.sameText(selector2);\n        }\n    },\n    eventMatches: function eventMatches(ele, listener, eventObj) {\n        var selector = listener.qualifier;\n        if (selector != null) {\n            return ele !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n        }\n        return true;\n    },\n    addEventFields: function addEventFields(ele, evt) {\n        evt.cy = ele.cy();\n        evt.target = ele;\n    },\n    callbackContext: function callbackContext(ele, listener, eventObj) {\n        return listener.qualifier != null ? eventObj.target : ele;\n    },\n    beforeEmit: function beforeEmit(context, listener /*, eventObj*/ ) {\n        if (listener.conf && listener.conf.once) {\n            listener.conf.onceCollection.removeListener(listener.event, listener.qualifier, listener.callback);\n        }\n    },\n    bubble: function bubble() {\n        return true;\n    },\n    parent: function parent(ele) {\n        return ele.isChild() ? ele.parent() : ele.cy();\n    }\n};\nvar argSelector$1 = function argSelector(arg) {\n    if (string(arg)) {\n        return new Selector(arg);\n    } else {\n        return arg;\n    }\n};\nvar elesfn$9 = {\n    createEmitter: function createEmitter() {\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var _p = ele._private;\n            if (!_p.emitter) {\n                _p.emitter = new Emitter(emitterOptions$1, ele);\n            }\n        }\n        return this;\n    },\n    emitter: function emitter() {\n        return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().on(events, argSel, callback);\n        }\n        return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().removeListener(events, argSel, callback);\n        }\n        return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().removeAllListeners();\n        }\n        return this;\n    },\n    one: function one(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().one(events, argSel, callback);\n        }\n        return this;\n    },\n    once: function once(events, selector, callback) {\n        var argSel = argSelector$1(selector);\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().on(events, argSel, callback, {\n                once: true,\n                onceCollection: this\n            });\n        }\n    },\n    emit: function emit(events, extraParams) {\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            ele.emitter().emit(events, extraParams);\n        }\n        return this;\n    },\n    emitAndNotify: function emitAndNotify(event, extraParams) {\n        // for internal use only\n        if (this.length === 0) {\n            return;\n        } // empty collections don't need to notify anything\n        // notify renderer\n        this.cy().notify(event, this);\n        this.emit(event, extraParams);\n        return this;\n    }\n};\ndefine.eventAliasesOn(elesfn$9);\nvar elesfn$8 = {\n    nodes: function nodes(selector) {\n        return this.filter(function(ele) {\n            return ele.isNode();\n        }).filter(selector);\n    },\n    edges: function edges(selector) {\n        return this.filter(function(ele) {\n            return ele.isEdge();\n        }).filter(selector);\n    },\n    // internal helper to get nodes and edges as separate collections with single iteration over elements\n    byGroup: function byGroup() {\n        var nodes = this.spawn();\n        var edges = this.spawn();\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            if (ele.isNode()) {\n                nodes.push(ele);\n            } else {\n                edges.push(ele);\n            }\n        }\n        return {\n            nodes: nodes,\n            edges: edges\n        };\n    },\n    filter: function filter(_filter, thisArg) {\n        if (_filter === undefined) {\n            // check this first b/c it's the most common/performant case\n            return this;\n        } else if (string(_filter) || elementOrCollection(_filter)) {\n            return new Selector(_filter).filter(this);\n        } else if (fn$6(_filter)) {\n            var filterEles = this.spawn();\n            var eles = this;\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                var include = thisArg ? _filter.apply(thisArg, [\n                    ele,\n                    i,\n                    eles\n                ]) : _filter(ele, i, eles);\n                if (include) {\n                    filterEles.push(ele);\n                }\n            }\n            return filterEles;\n        }\n        return this.spawn(); // if not handled by above, give 'em an empty collection\n    },\n    not: function not(toRemove) {\n        if (!toRemove) {\n            return this;\n        } else {\n            if (string(toRemove)) {\n                toRemove = this.filter(toRemove);\n            }\n            var elements = this.spawn();\n            for(var i = 0; i < this.length; i++){\n                var element = this[i];\n                var remove = toRemove.has(element);\n                if (!remove) {\n                    elements.push(element);\n                }\n            }\n            return elements;\n        }\n    },\n    absoluteComplement: function absoluteComplement() {\n        var cy = this.cy();\n        return cy.mutableElements().not(this);\n    },\n    intersect: function intersect(other) {\n        // if a selector is specified, then filter by it instead\n        if (string(other)) {\n            var selector = other;\n            return this.filter(selector);\n        }\n        var elements = this.spawn();\n        var col1 = this;\n        var col2 = other;\n        var col1Smaller = this.length < other.length;\n        var colS = col1Smaller ? col1 : col2;\n        var colL = col1Smaller ? col2 : col1;\n        for(var i = 0; i < colS.length; i++){\n            var ele = colS[i];\n            if (colL.has(ele)) {\n                elements.push(ele);\n            }\n        }\n        return elements;\n    },\n    xor: function xor(other) {\n        var cy = this._private.cy;\n        if (string(other)) {\n            other = cy.$(other);\n        }\n        var elements = this.spawn();\n        var col1 = this;\n        var col2 = other;\n        var add = function add(col, other) {\n            for(var i = 0; i < col.length; i++){\n                var ele = col[i];\n                var id = ele._private.data.id;\n                var inOther = other.hasElementWithId(id);\n                if (!inOther) {\n                    elements.push(ele);\n                }\n            }\n        };\n        add(col1, col2);\n        add(col2, col1);\n        return elements;\n    },\n    diff: function diff(other) {\n        var cy = this._private.cy;\n        if (string(other)) {\n            other = cy.$(other);\n        }\n        var left = this.spawn();\n        var right = this.spawn();\n        var both = this.spawn();\n        var col1 = this;\n        var col2 = other;\n        var add = function add(col, other, retEles) {\n            for(var i = 0; i < col.length; i++){\n                var ele = col[i];\n                var id = ele._private.data.id;\n                var inOther = other.hasElementWithId(id);\n                if (inOther) {\n                    both.merge(ele);\n                } else {\n                    retEles.push(ele);\n                }\n            }\n        };\n        add(col1, col2, left);\n        add(col2, col1, right);\n        return {\n            left: left,\n            right: right,\n            both: both\n        };\n    },\n    add: function add(toAdd) {\n        var cy = this._private.cy;\n        if (!toAdd) {\n            return this;\n        }\n        if (string(toAdd)) {\n            var selector = toAdd;\n            toAdd = cy.mutableElements().filter(selector);\n        }\n        var elements = this.spawnSelf();\n        for(var i = 0; i < toAdd.length; i++){\n            var ele = toAdd[i];\n            var add = !this.has(ele);\n            if (add) {\n                elements.push(ele);\n            }\n        }\n        return elements;\n    },\n    // in place merge on calling collection\n    merge: function merge(toAdd) {\n        var _p = this._private;\n        var cy = _p.cy;\n        if (!toAdd) {\n            return this;\n        }\n        if (toAdd && string(toAdd)) {\n            var selector = toAdd;\n            toAdd = cy.mutableElements().filter(selector);\n        }\n        var map = _p.map;\n        for(var i = 0; i < toAdd.length; i++){\n            var toAddEle = toAdd[i];\n            var id = toAddEle._private.data.id;\n            var add = !map.has(id);\n            if (add) {\n                var index = this.length++;\n                this[index] = toAddEle;\n                map.set(id, {\n                    ele: toAddEle,\n                    index: index\n                });\n            }\n        }\n        return this; // chaining\n    },\n    unmergeAt: function unmergeAt(i) {\n        var ele = this[i];\n        var id = ele.id();\n        var _p = this._private;\n        var map = _p.map;\n        // remove ele\n        this[i] = undefined;\n        map[\"delete\"](id);\n        var unmergedLastEle = i === this.length - 1;\n        // replace empty spot with last ele in collection\n        if (this.length > 1 && !unmergedLastEle) {\n            var lastEleI = this.length - 1;\n            var lastEle = this[lastEleI];\n            var lastEleId = lastEle._private.data.id;\n            this[lastEleI] = undefined;\n            this[i] = lastEle;\n            map.set(lastEleId, {\n                ele: lastEle,\n                index: i\n            });\n        }\n        // the collection is now 1 ele smaller\n        this.length--;\n        return this;\n    },\n    // remove single ele in place in calling collection\n    unmergeOne: function unmergeOne(ele) {\n        ele = ele[0];\n        var _p = this._private;\n        var id = ele._private.data.id;\n        var map = _p.map;\n        var entry = map.get(id);\n        if (!entry) {\n            return this; // no need to remove\n        }\n        var i = entry.index;\n        this.unmergeAt(i);\n        return this;\n    },\n    // remove eles in place on calling collection\n    unmerge: function unmerge(toRemove) {\n        var cy = this._private.cy;\n        if (!toRemove) {\n            return this;\n        }\n        if (toRemove && string(toRemove)) {\n            var selector = toRemove;\n            toRemove = cy.mutableElements().filter(selector);\n        }\n        for(var i = 0; i < toRemove.length; i++){\n            this.unmergeOne(toRemove[i]);\n        }\n        return this; // chaining\n    },\n    unmergeBy: function unmergeBy(toRmFn) {\n        for(var i = this.length - 1; i >= 0; i--){\n            var ele = this[i];\n            if (toRmFn(ele)) {\n                this.unmergeAt(i);\n            }\n        }\n        return this;\n    },\n    map: function map(mapFn, thisArg) {\n        var arr = [];\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var ret = thisArg ? mapFn.apply(thisArg, [\n                ele,\n                i,\n                eles\n            ]) : mapFn(ele, i, eles);\n            arr.push(ret);\n        }\n        return arr;\n    },\n    reduce: function reduce(fn, initialValue) {\n        var val = initialValue;\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            val = fn(val, eles[i], i, eles);\n        }\n        return val;\n    },\n    max: function max(valFn, thisArg) {\n        var max = -Infinity;\n        var maxEle;\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var val = thisArg ? valFn.apply(thisArg, [\n                ele,\n                i,\n                eles\n            ]) : valFn(ele, i, eles);\n            if (val > max) {\n                max = val;\n                maxEle = ele;\n            }\n        }\n        return {\n            value: max,\n            ele: maxEle\n        };\n    },\n    min: function min(valFn, thisArg) {\n        var min = Infinity;\n        var minEle;\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            var val = thisArg ? valFn.apply(thisArg, [\n                ele,\n                i,\n                eles\n            ]) : valFn(ele, i, eles);\n            if (val < min) {\n                min = val;\n                minEle = ele;\n            }\n        }\n        return {\n            value: min,\n            ele: minEle\n        };\n    }\n};\n// aliases\nvar fn$1 = elesfn$8;\nfn$1['u'] = fn$1['|'] = fn$1['+'] = fn$1.union = fn$1.or = fn$1.add;\nfn$1['\\\\'] = fn$1['!'] = fn$1['-'] = fn$1.difference = fn$1.relativeComplement = fn$1.subtract = fn$1.not;\nfn$1['n'] = fn$1['&'] = fn$1['.'] = fn$1.and = fn$1.intersection = fn$1.intersect;\nfn$1['^'] = fn$1['(+)'] = fn$1['(-)'] = fn$1.symmetricDifference = fn$1.symdiff = fn$1.xor;\nfn$1.fnFilter = fn$1.filterFn = fn$1.stdFilter = fn$1.filter;\nfn$1.complement = fn$1.abscomp = fn$1.absoluteComplement;\nvar elesfn$7 = {\n    isNode: function isNode() {\n        return this.group() === 'nodes';\n    },\n    isEdge: function isEdge() {\n        return this.group() === 'edges';\n    },\n    isLoop: function isLoop() {\n        return this.isEdge() && this.source()[0] === this.target()[0];\n    },\n    isSimple: function isSimple() {\n        return this.isEdge() && this.source()[0] !== this.target()[0];\n    },\n    group: function group() {\n        var ele = this[0];\n        if (ele) {\n            return ele._private.group;\n        }\n    }\n};\n/**\n *  Elements are drawn in a specific order based on compound depth (low to high), the element type (nodes above edges),\n *  and z-index (low to high).  These styles affect how this applies:\n *\n *  z-compound-depth: May be `bottom | orphan | auto | top`.  The first drawn is `bottom`, then `orphan` which is the\n *      same depth as the root of the compound graph, followed by the default value `auto` which draws in order from\n *      root to leaves of the compound graph.  The last drawn is `top`.\n *  z-index-compare: May be `auto | manual`.  The default value is `auto` which always draws edges under nodes.\n *      `manual` ignores this convention and draws based on the `z-index` value setting.\n *  z-index: An integer value that affects the relative draw order of elements.  In general, an element with a higher\n *      `z-index` will be drawn on top of an element with a lower `z-index`.\n */ var zIndexSort = function zIndexSort(a, b) {\n    var cy = a.cy();\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    function getDepth(ele) {\n        var style = ele.pstyle('z-compound-depth');\n        if (style.value === 'auto') {\n            return hasCompoundNodes ? ele.zDepth() : 0;\n        } else if (style.value === 'bottom') {\n            return -1;\n        } else if (style.value === 'top') {\n            return MAX_INT$1;\n        }\n        // 'orphan'\n        return 0;\n    }\n    var depthDiff = getDepth(a) - getDepth(b);\n    if (depthDiff !== 0) {\n        return depthDiff;\n    }\n    function getEleDepth(ele) {\n        var style = ele.pstyle('z-index-compare');\n        if (style.value === 'auto') {\n            return ele.isNode() ? 1 : 0;\n        }\n        // 'manual'\n        return 0;\n    }\n    var eleDiff = getEleDepth(a) - getEleDepth(b);\n    if (eleDiff !== 0) {\n        return eleDiff;\n    }\n    var zDiff = a.pstyle('z-index').value - b.pstyle('z-index').value;\n    if (zDiff !== 0) {\n        return zDiff;\n    }\n    // compare indices in the core (order added to graph w/ last on top)\n    return a.poolIndex() - b.poolIndex();\n};\nvar elesfn$6 = {\n    forEach: function forEach(fn, thisArg) {\n        if (fn$6(fn)) {\n            var N = this.length;\n            for(var i = 0; i < N; i++){\n                var ele = this[i];\n                var ret = thisArg ? fn.apply(thisArg, [\n                    ele,\n                    i,\n                    this\n                ]) : fn(ele, i, this);\n                if (ret === false) {\n                    break;\n                } // exit each early on return false\n            }\n        }\n        return this;\n    },\n    toArray: function toArray() {\n        var array = [];\n        for(var i = 0; i < this.length; i++){\n            array.push(this[i]);\n        }\n        return array;\n    },\n    slice: function slice(start, end) {\n        var array = [];\n        var thisSize = this.length;\n        if (end == null) {\n            end = thisSize;\n        }\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start = thisSize + start;\n        }\n        if (end < 0) {\n            end = thisSize + end;\n        }\n        for(var i = start; i >= 0 && i < end && i < thisSize; i++){\n            array.push(this[i]);\n        }\n        return this.spawn(array);\n    },\n    size: function size() {\n        return this.length;\n    },\n    eq: function eq(i) {\n        return this[i] || this.spawn();\n    },\n    first: function first() {\n        return this[0] || this.spawn();\n    },\n    last: function last() {\n        return this[this.length - 1] || this.spawn();\n    },\n    empty: function empty() {\n        return this.length === 0;\n    },\n    nonempty: function nonempty() {\n        return !this.empty();\n    },\n    sort: function sort(sortFn) {\n        if (!fn$6(sortFn)) {\n            return this;\n        }\n        var sorted = this.toArray().sort(sortFn);\n        return this.spawn(sorted);\n    },\n    sortByZIndex: function sortByZIndex() {\n        return this.sort(zIndexSort);\n    },\n    zDepth: function zDepth() {\n        var ele = this[0];\n        if (!ele) {\n            return undefined;\n        }\n        // let cy = ele.cy();\n        var _p = ele._private;\n        var group = _p.group;\n        if (group === 'nodes') {\n            var depth = _p.data.parent ? ele.parents().size() : 0;\n            if (!ele.isParent()) {\n                return MAX_INT$1 - 1; // childless nodes always on top\n            }\n            return depth;\n        } else {\n            var src = _p.source;\n            var tgt = _p.target;\n            var srcDepth = src.zDepth();\n            var tgtDepth = tgt.zDepth();\n            return Math.max(srcDepth, tgtDepth, 0); // depth of deepest parent\n        }\n    }\n};\nelesfn$6.each = elesfn$6.forEach;\nvar defineSymbolIterator = function defineSymbolIterator() {\n    var typeofUndef = \"undefined\";\n    var isIteratorSupported = (typeof Symbol === \"undefined\" ? \"undefined\" : _typeof(Symbol)) != typeofUndef && _typeof(Symbol.iterator) != typeofUndef;\n    if (isIteratorSupported) {\n        elesfn$6[Symbol.iterator] = function() {\n            var _this = this;\n            var entry = {\n                value: undefined,\n                done: false\n            };\n            var i = 0;\n            var length = this.length;\n            return _defineProperty$1({\n                next: function next() {\n                    if (i < length) {\n                        entry.value = _this[i++];\n                    } else {\n                        entry.value = undefined;\n                        entry.done = true;\n                    }\n                    return entry;\n                }\n            }, Symbol.iterator, function() {\n                return this;\n            });\n        };\n    }\n};\ndefineSymbolIterator();\nvar getLayoutDimensionOptions = defaults$g({\n    nodeDimensionsIncludeLabels: false\n});\nvar elesfn$5 = {\n    // Calculates and returns node dimensions { x, y } based on options given\n    layoutDimensions: function layoutDimensions(options) {\n        options = getLayoutDimensionOptions(options);\n        var dims;\n        if (!this.takesUpSpace()) {\n            dims = {\n                w: 0,\n                h: 0\n            };\n        } else if (options.nodeDimensionsIncludeLabels) {\n            var bbDim = this.boundingBox();\n            dims = {\n                w: bbDim.w,\n                h: bbDim.h\n            };\n        } else {\n            dims = {\n                w: this.outerWidth(),\n                h: this.outerHeight()\n            };\n        }\n        // sanitise the dimensions for external layouts (avoid division by zero)\n        if (dims.w === 0 || dims.h === 0) {\n            dims.w = dims.h = 1;\n        }\n        return dims;\n    },\n    // using standard layout options, apply position function (w/ or w/o animation)\n    layoutPositions: function layoutPositions(layout, options, fn) {\n        var nodes = this.nodes().filter(function(n) {\n            return !n.isParent();\n        });\n        var cy = this.cy();\n        var layoutEles = options.eles; // nodes & edges\n        var getMemoizeKey = function getMemoizeKey(node) {\n            return node.id();\n        };\n        var fnMem = memoize(fn, getMemoizeKey); // memoized version of position function\n        layout.emit({\n            type: 'layoutstart',\n            layout: layout\n        });\n        layout.animations = [];\n        var calculateSpacing = function calculateSpacing(spacing, nodesBb, pos) {\n            var center = {\n                x: nodesBb.x1 + nodesBb.w / 2,\n                y: nodesBb.y1 + nodesBb.h / 2\n            };\n            var spacingVector = {\n                // scale from center of bounding box (not necessarily 0,0)\n                x: (pos.x - center.x) * spacing,\n                y: (pos.y - center.y) * spacing\n            };\n            return {\n                x: center.x + spacingVector.x,\n                y: center.y + spacingVector.y\n            };\n        };\n        var useSpacingFactor = options.spacingFactor && options.spacingFactor !== 1;\n        var spacingBb = function spacingBb() {\n            if (!useSpacingFactor) {\n                return null;\n            }\n            var bb = makeBoundingBox();\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                var pos = fnMem(node, i);\n                expandBoundingBoxByPoint(bb, pos.x, pos.y);\n            }\n            return bb;\n        };\n        var bb = spacingBb();\n        var getFinalPos = memoize(function(node, i) {\n            var newPos = fnMem(node, i);\n            if (useSpacingFactor) {\n                var spacing = Math.abs(options.spacingFactor);\n                newPos = calculateSpacing(spacing, bb, newPos);\n            }\n            if (options.transform != null) {\n                newPos = options.transform(node, newPos);\n            }\n            return newPos;\n        }, getMemoizeKey);\n        if (options.animate) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                var newPos = getFinalPos(node, i);\n                var animateNode = options.animateFilter == null || options.animateFilter(node, i);\n                if (animateNode) {\n                    var ani = node.animation({\n                        position: newPos,\n                        duration: options.animationDuration,\n                        easing: options.animationEasing\n                    });\n                    layout.animations.push(ani);\n                } else {\n                    node.position(newPos);\n                }\n            }\n            if (options.fit) {\n                var fitAni = cy.animation({\n                    fit: {\n                        boundingBox: layoutEles.boundingBoxAt(getFinalPos),\n                        padding: options.padding\n                    },\n                    duration: options.animationDuration,\n                    easing: options.animationEasing\n                });\n                layout.animations.push(fitAni);\n            } else if (options.zoom !== undefined && options.pan !== undefined) {\n                var zoomPanAni = cy.animation({\n                    zoom: options.zoom,\n                    pan: options.pan,\n                    duration: options.animationDuration,\n                    easing: options.animationEasing\n                });\n                layout.animations.push(zoomPanAni);\n            }\n            layout.animations.forEach(function(ani) {\n                return ani.play();\n            });\n            layout.one('layoutready', options.ready);\n            layout.emit({\n                type: 'layoutready',\n                layout: layout\n            });\n            Promise$1.all(layout.animations.map(function(ani) {\n                return ani.promise();\n            })).then(function() {\n                layout.one('layoutstop', options.stop);\n                layout.emit({\n                    type: 'layoutstop',\n                    layout: layout\n                });\n            });\n        } else {\n            nodes.positions(getFinalPos);\n            if (options.fit) {\n                cy.fit(options.eles, options.padding);\n            }\n            if (options.zoom != null) {\n                cy.zoom(options.zoom);\n            }\n            if (options.pan) {\n                cy.pan(options.pan);\n            }\n            layout.one('layoutready', options.ready);\n            layout.emit({\n                type: 'layoutready',\n                layout: layout\n            });\n            layout.one('layoutstop', options.stop);\n            layout.emit({\n                type: 'layoutstop',\n                layout: layout\n            });\n        }\n        return this; // chaining\n    },\n    layout: function layout(options) {\n        var cy = this.cy();\n        return cy.makeLayout(extend({}, options, {\n            eles: this\n        }));\n    }\n};\n// aliases:\nelesfn$5.createLayout = elesfn$5.makeLayout = elesfn$5.layout;\nfunction styleCache(key, fn, ele) {\n    var _p = ele._private;\n    var cache = _p.styleCache = _p.styleCache || [];\n    var val;\n    if ((val = cache[key]) != null) {\n        return val;\n    } else {\n        val = cache[key] = fn(ele);\n        return val;\n    }\n}\nfunction cacheStyleFunction(key, fn) {\n    key = hashString(key);\n    return function cachedStyleFunction(ele) {\n        return styleCache(key, fn, ele);\n    };\n}\nfunction cachePrototypeStyleFunction(key, fn) {\n    key = hashString(key);\n    var selfFn = function selfFn(ele) {\n        return fn.call(ele);\n    };\n    return function cachedPrototypeStyleFunction() {\n        var ele = this[0];\n        if (ele) {\n            return styleCache(key, selfFn, ele);\n        }\n    };\n}\nvar elesfn$4 = {\n    recalculateRenderedStyle: function recalculateRenderedStyle(useCache) {\n        var cy = this.cy();\n        var renderer = cy.renderer();\n        var styleEnabled = cy.styleEnabled();\n        if (renderer && styleEnabled) {\n            renderer.recalculateRenderedStyle(this, useCache);\n        }\n        return this;\n    },\n    dirtyStyleCache: function dirtyStyleCache() {\n        var cy = this.cy();\n        var dirty = function dirty(ele) {\n            return ele._private.styleCache = null;\n        };\n        if (cy.hasCompoundNodes()) {\n            var eles;\n            eles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n            eles.merge(eles.connectedEdges());\n            eles.forEach(dirty);\n        } else {\n            this.forEach(function(ele) {\n                dirty(ele);\n                ele.connectedEdges().forEach(dirty);\n            });\n        }\n        return this;\n    },\n    // fully updates (recalculates) the style for the elements\n    updateStyle: function updateStyle(notifyRenderer) {\n        var cy = this._private.cy;\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        if (cy.batching()) {\n            var bEles = cy._private.batchStyleEles;\n            bEles.merge(this);\n            return this; // chaining and exit early when batching\n        }\n        var hasCompounds = cy.hasCompoundNodes();\n        var updatedEles = this;\n        notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;\n        if (hasCompounds) {\n            // then add everything up and down for compound selector checks\n            updatedEles = this.spawnSelf().merge(this.descendants()).merge(this.parents());\n        }\n        // let changedEles = style.apply( updatedEles );\n        var changedEles = updatedEles;\n        if (notifyRenderer) {\n            changedEles.emitAndNotify('style'); // let renderer know we changed style\n        } else {\n            changedEles.emit('style'); // just fire the event\n        }\n        updatedEles.forEach(function(ele) {\n            return ele._private.styleDirty = true;\n        });\n        return this; // chaining\n    },\n    // private: clears dirty flag and recalculates style\n    cleanStyle: function cleanStyle() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return;\n        }\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            if (ele._private.styleDirty) {\n                // n.b. this flag should be set before apply() to avoid potential infinite recursion\n                ele._private.styleDirty = false;\n                cy.style().apply(ele);\n            }\n        }\n    },\n    // get the internal parsed style object for the specified property\n    parsedStyle: function parsedStyle(property) {\n        var includeNonDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var ele = this[0];\n        var cy = ele.cy();\n        if (!cy.styleEnabled()) {\n            return;\n        }\n        if (ele) {\n            // this.cleanStyle();\n            // Inline the important part of cleanStyle(), for raw performance\n            if (ele._private.styleDirty) {\n                // n.b. this flag should be set before apply() to avoid potential infinite recursion\n                ele._private.styleDirty = false;\n                cy.style().apply(ele);\n            }\n            var overriddenStyle = ele._private.style[property];\n            if (overriddenStyle != null) {\n                return overriddenStyle;\n            } else if (includeNonDefault) {\n                return cy.style().getDefaultProperty(property);\n            } else {\n                return null;\n            }\n        }\n    },\n    numericStyle: function numericStyle(property) {\n        var ele = this[0];\n        if (!ele.cy().styleEnabled()) {\n            return;\n        }\n        if (ele) {\n            var pstyle = ele.pstyle(property);\n            return pstyle.pfValue !== undefined ? pstyle.pfValue : pstyle.value;\n        }\n    },\n    numericStyleUnits: function numericStyleUnits(property) {\n        var ele = this[0];\n        if (!ele.cy().styleEnabled()) {\n            return;\n        }\n        if (ele) {\n            return ele.pstyle(property).units;\n        }\n    },\n    // get the specified css property as a rendered value (i.e. on-screen value)\n    // or get the whole rendered style if no property specified (NB doesn't allow setting)\n    renderedStyle: function renderedStyle(property) {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        var ele = this[0];\n        if (ele) {\n            return cy.style().getRenderedStyle(ele, property);\n        }\n    },\n    // read the calculated css style of the element or override the style (via a bypass)\n    style: function style(name, value) {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        var updateTransitions = false;\n        var style = cy.style();\n        if (plainObject(name)) {\n            // then extend the bypass\n            var props = name;\n            style.applyBypass(this, props, updateTransitions);\n            this.emitAndNotify('style'); // let the renderer know we've updated style\n        } else if (string(name)) {\n            if (value === undefined) {\n                // then get the property from the style\n                var ele = this[0];\n                if (ele) {\n                    return style.getStylePropertyValue(ele, name);\n                } else {\n                    // empty collection => can't get any value\n                    return;\n                }\n            } else {\n                // then set the bypass with the property value\n                style.applyBypass(this, name, value, updateTransitions);\n                this.emitAndNotify('style'); // let the renderer know we've updated style\n            }\n        } else if (name === undefined) {\n            var _ele = this[0];\n            if (_ele) {\n                return style.getRawStyle(_ele);\n            } else {\n                // empty collection => can't get any value\n                return;\n            }\n        }\n        return this; // chaining\n    },\n    removeStyle: function removeStyle(names) {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return this;\n        }\n        var updateTransitions = false;\n        var style = cy.style();\n        var eles = this;\n        if (names === undefined) {\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                style.removeAllBypasses(ele, updateTransitions);\n            }\n        } else {\n            names = names.split(/\\s+/);\n            for(var _i = 0; _i < eles.length; _i++){\n                var _ele2 = eles[_i];\n                style.removeBypasses(_ele2, names, updateTransitions);\n            }\n        }\n        this.emitAndNotify('style'); // let the renderer know we've updated style\n        return this; // chaining\n    },\n    show: function show() {\n        this.css('display', 'element');\n        return this; // chaining\n    },\n    hide: function hide() {\n        this.css('display', 'none');\n        return this; // chaining\n    },\n    effectiveOpacity: function effectiveOpacity() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return 1;\n        }\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        var ele = this[0];\n        if (ele) {\n            var _p = ele._private;\n            var parentOpacity = ele.pstyle('opacity').value;\n            if (!hasCompoundNodes) {\n                return parentOpacity;\n            }\n            var parents = !_p.data.parent ? null : ele.parents();\n            if (parents) {\n                for(var i = 0; i < parents.length; i++){\n                    var parent = parents[i];\n                    var opacity = parent.pstyle('opacity').value;\n                    parentOpacity = opacity * parentOpacity;\n                }\n            }\n            return parentOpacity;\n        }\n    },\n    transparent: function transparent() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return false;\n        }\n        var ele = this[0];\n        var hasCompoundNodes = ele.cy().hasCompoundNodes();\n        if (ele) {\n            if (!hasCompoundNodes) {\n                return ele.pstyle('opacity').value === 0;\n            } else {\n                return ele.effectiveOpacity() === 0;\n            }\n        }\n    },\n    backgrounding: function backgrounding() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return false;\n        }\n        var ele = this[0];\n        return ele._private.backgrounding ? true : false;\n    }\n};\nfunction checkCompound(ele, parentOk) {\n    var _p = ele._private;\n    var parents = _p.data.parent ? ele.parents() : null;\n    if (parents) {\n        for(var i = 0; i < parents.length; i++){\n            var parent = parents[i];\n            if (!parentOk(parent)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction defineDerivedStateFunction(specs) {\n    var ok = specs.ok;\n    var edgeOkViaNode = specs.edgeOkViaNode || specs.ok;\n    var parentOk = specs.parentOk || specs.ok;\n    return function() {\n        var cy = this.cy();\n        if (!cy.styleEnabled()) {\n            return true;\n        }\n        var ele = this[0];\n        var hasCompoundNodes = cy.hasCompoundNodes();\n        if (ele) {\n            var _p = ele._private;\n            if (!ok(ele)) {\n                return false;\n            }\n            if (ele.isNode()) {\n                return !hasCompoundNodes || checkCompound(ele, parentOk);\n            } else {\n                var src = _p.source;\n                var tgt = _p.target;\n                return edgeOkViaNode(src) && (!hasCompoundNodes || checkCompound(src, edgeOkViaNode)) && (src === tgt || edgeOkViaNode(tgt) && (!hasCompoundNodes || checkCompound(tgt, edgeOkViaNode)));\n            }\n        }\n    };\n}\nvar eleTakesUpSpace = cacheStyleFunction('eleTakesUpSpace', function(ele) {\n    return ele.pstyle('display').value === 'element' && ele.width() !== 0 && (ele.isNode() ? ele.height() !== 0 : true);\n});\nelesfn$4.takesUpSpace = cachePrototypeStyleFunction('takesUpSpace', defineDerivedStateFunction({\n    ok: eleTakesUpSpace\n}));\nvar eleInteractive = cacheStyleFunction('eleInteractive', function(ele) {\n    return ele.pstyle('events').value === 'yes' && ele.pstyle('visibility').value === 'visible' && eleTakesUpSpace(ele);\n});\nvar parentInteractive = cacheStyleFunction('parentInteractive', function(parent) {\n    return parent.pstyle('visibility').value === 'visible' && eleTakesUpSpace(parent);\n});\nelesfn$4.interactive = cachePrototypeStyleFunction('interactive', defineDerivedStateFunction({\n    ok: eleInteractive,\n    parentOk: parentInteractive,\n    edgeOkViaNode: eleTakesUpSpace\n}));\nelesfn$4.noninteractive = function() {\n    var ele = this[0];\n    if (ele) {\n        return !ele.interactive();\n    }\n};\nvar eleVisible = cacheStyleFunction('eleVisible', function(ele) {\n    return ele.pstyle('visibility').value === 'visible' && ele.pstyle('opacity').pfValue !== 0 && eleTakesUpSpace(ele);\n});\nvar edgeVisibleViaNode = eleTakesUpSpace;\nelesfn$4.visible = cachePrototypeStyleFunction('visible', defineDerivedStateFunction({\n    ok: eleVisible,\n    edgeOkViaNode: edgeVisibleViaNode\n}));\nelesfn$4.hidden = function() {\n    var ele = this[0];\n    if (ele) {\n        return !ele.visible();\n    }\n};\nelesfn$4.isBundledBezier = cachePrototypeStyleFunction('isBundledBezier', function() {\n    if (!this.cy().styleEnabled()) {\n        return false;\n    }\n    return !this.removed() && this.pstyle('curve-style').value === 'bezier' && this.takesUpSpace();\n});\nelesfn$4.bypass = elesfn$4.css = elesfn$4.style;\nelesfn$4.renderedCss = elesfn$4.renderedStyle;\nelesfn$4.removeBypass = elesfn$4.removeCss = elesfn$4.removeStyle;\nelesfn$4.pstyle = elesfn$4.parsedStyle;\nvar elesfn$3 = {};\nfunction defineSwitchFunction(params) {\n    return function() {\n        var args = arguments;\n        var changedEles = [];\n        // e.g. cy.nodes().select( data, handler )\n        if (args.length === 2) {\n            var data = args[0];\n            var handler = args[1];\n            this.on(params.event, data, handler);\n        } else if (args.length === 1 && fn$6(args[0])) {\n            var _handler = args[0];\n            this.on(params.event, _handler);\n        } else if (args.length === 0 || args.length === 1 && array(args[0])) {\n            var addlEvents = args.length === 1 ? args[0] : null;\n            for(var i = 0; i < this.length; i++){\n                var ele = this[i];\n                var able = !params.ableField || ele._private[params.ableField];\n                var changed = ele._private[params.field] != params.value;\n                if (params.overrideAble) {\n                    var overrideAble = params.overrideAble(ele);\n                    if (overrideAble !== undefined) {\n                        able = overrideAble;\n                        if (!overrideAble) {\n                            return this;\n                        } // to save cycles assume not able for all on override\n                    }\n                }\n                if (able) {\n                    ele._private[params.field] = params.value;\n                    if (changed) {\n                        changedEles.push(ele);\n                    }\n                }\n            }\n            var changedColl = this.spawn(changedEles);\n            changedColl.updateStyle(); // change of state => possible change of style\n            changedColl.emit(params.event);\n            if (addlEvents) {\n                changedColl.emit(addlEvents);\n            }\n        }\n        return this;\n    };\n}\nfunction defineSwitchSet(params) {\n    elesfn$3[params.field] = function() {\n        var ele = this[0];\n        if (ele) {\n            if (params.overrideField) {\n                var val = params.overrideField(ele);\n                if (val !== undefined) {\n                    return val;\n                }\n            }\n            return ele._private[params.field];\n        }\n    };\n    elesfn$3[params.on] = defineSwitchFunction({\n        event: params.on,\n        field: params.field,\n        ableField: params.ableField,\n        overrideAble: params.overrideAble,\n        value: true\n    });\n    elesfn$3[params.off] = defineSwitchFunction({\n        event: params.off,\n        field: params.field,\n        ableField: params.ableField,\n        overrideAble: params.overrideAble,\n        value: false\n    });\n}\ndefineSwitchSet({\n    field: 'locked',\n    overrideField: function overrideField(ele) {\n        return ele.cy().autolock() ? true : undefined;\n    },\n    on: 'lock',\n    off: 'unlock'\n});\ndefineSwitchSet({\n    field: 'grabbable',\n    overrideField: function overrideField(ele) {\n        return ele.cy().autoungrabify() || ele.pannable() ? false : undefined;\n    },\n    on: 'grabify',\n    off: 'ungrabify'\n});\ndefineSwitchSet({\n    field: 'selected',\n    ableField: 'selectable',\n    overrideAble: function overrideAble(ele) {\n        return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'select',\n    off: 'unselect'\n});\ndefineSwitchSet({\n    field: 'selectable',\n    overrideField: function overrideField(ele) {\n        return ele.cy().autounselectify() ? false : undefined;\n    },\n    on: 'selectify',\n    off: 'unselectify'\n});\nelesfn$3.deselect = elesfn$3.unselect;\nelesfn$3.grabbed = function() {\n    var ele = this[0];\n    if (ele) {\n        return ele._private.grabbed;\n    }\n};\ndefineSwitchSet({\n    field: 'active',\n    on: 'activate',\n    off: 'unactivate'\n});\ndefineSwitchSet({\n    field: 'pannable',\n    on: 'panify',\n    off: 'unpanify'\n});\nelesfn$3.inactive = function() {\n    var ele = this[0];\n    if (ele) {\n        return !ele._private.active;\n    }\n};\nvar elesfn$2 = {};\n// DAG functions\n////////////////\nvar defineDagExtremity = function defineDagExtremity(params) {\n    return function dagExtremityImpl(selector) {\n        var eles = this;\n        var ret = [];\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (!ele.isNode()) {\n                continue;\n            }\n            var disqualified = false;\n            var edges = ele.connectedEdges();\n            for(var j = 0; j < edges.length; j++){\n                var edge = edges[j];\n                var src = edge.source();\n                var tgt = edge.target();\n                if (params.noIncomingEdges && tgt === ele && src !== ele || params.noOutgoingEdges && src === ele && tgt !== ele) {\n                    disqualified = true;\n                    break;\n                }\n            }\n            if (!disqualified) {\n                ret.push(ele);\n            }\n        }\n        return this.spawn(ret, true).filter(selector);\n    };\n};\nvar defineDagOneHop = function defineDagOneHop(params) {\n    return function(selector) {\n        var eles = this;\n        var oEles = [];\n        for(var i = 0; i < eles.length; i++){\n            var ele = eles[i];\n            if (!ele.isNode()) {\n                continue;\n            }\n            var edges = ele.connectedEdges();\n            for(var j = 0; j < edges.length; j++){\n                var edge = edges[j];\n                var src = edge.source();\n                var tgt = edge.target();\n                if (params.outgoing && src === ele) {\n                    oEles.push(edge);\n                    oEles.push(tgt);\n                } else if (params.incoming && tgt === ele) {\n                    oEles.push(edge);\n                    oEles.push(src);\n                }\n            }\n        }\n        return this.spawn(oEles, true).filter(selector);\n    };\n};\nvar defineDagAllHops = function defineDagAllHops(params) {\n    return function(selector) {\n        var eles = this;\n        var sEles = [];\n        var sElesIds = {};\n        for(;;){\n            var next = params.outgoing ? eles.outgoers() : eles.incomers();\n            if (next.length === 0) {\n                break;\n            } // done if none left\n            var newNext = false;\n            for(var i = 0; i < next.length; i++){\n                var n = next[i];\n                var nid = n.id();\n                if (!sElesIds[nid]) {\n                    sElesIds[nid] = true;\n                    sEles.push(n);\n                    newNext = true;\n                }\n            }\n            if (!newNext) {\n                break;\n            } // done if touched all outgoers already\n            eles = next;\n        }\n        return this.spawn(sEles, true).filter(selector);\n    };\n};\nelesfn$2.clearTraversalCache = function() {\n    for(var i = 0; i < this.length; i++){\n        this[i]._private.traversalCache = null;\n    }\n};\nextend(elesfn$2, {\n    // get the root nodes in the DAG\n    roots: defineDagExtremity({\n        noIncomingEdges: true\n    }),\n    // get the leaf nodes in the DAG\n    leaves: defineDagExtremity({\n        noOutgoingEdges: true\n    }),\n    // normally called children in graph theory\n    // these nodes =edges=> outgoing nodes\n    outgoers: cache(defineDagOneHop({\n        outgoing: true\n    }), 'outgoers'),\n    // aka DAG descendants\n    successors: defineDagAllHops({\n        outgoing: true\n    }),\n    // normally called parents in graph theory\n    // these nodes <=edges= incoming nodes\n    incomers: cache(defineDagOneHop({\n        incoming: true\n    }), 'incomers'),\n    // aka DAG ancestors\n    predecessors: defineDagAllHops({})\n});\n// Neighbourhood functions\n//////////////////////////\nextend(elesfn$2, {\n    neighborhood: cache(function(selector) {\n        var elements = [];\n        var nodes = this.nodes();\n        for(var i = 0; i < nodes.length; i++){\n            // for all nodes\n            var node = nodes[i];\n            var connectedEdges = node.connectedEdges();\n            // for each connected edge, add the edge and the other node\n            for(var j = 0; j < connectedEdges.length; j++){\n                var edge = connectedEdges[j];\n                var src = edge.source();\n                var tgt = edge.target();\n                var otherNode = node === src ? tgt : src;\n                // need check in case of loop\n                if (otherNode.length > 0) {\n                    elements.push(otherNode[0]); // add node 1 hop away\n                }\n                // add connected edge\n                elements.push(edge[0]);\n            }\n        }\n        return this.spawn(elements, true).filter(selector);\n    }, 'neighborhood'),\n    closedNeighborhood: function closedNeighborhood(selector) {\n        return this.neighborhood().add(this).filter(selector);\n    },\n    openNeighborhood: function openNeighborhood(selector) {\n        return this.neighborhood(selector);\n    }\n});\n// aliases\nelesfn$2.neighbourhood = elesfn$2.neighborhood;\nelesfn$2.closedNeighbourhood = elesfn$2.closedNeighborhood;\nelesfn$2.openNeighbourhood = elesfn$2.openNeighborhood;\n// Edge functions\n/////////////////\nextend(elesfn$2, {\n    source: cache(function sourceImpl(selector) {\n        var ele = this[0];\n        var src;\n        if (ele) {\n            src = ele._private.source || ele.cy().collection();\n        }\n        return src && selector ? src.filter(selector) : src;\n    }, 'source'),\n    target: cache(function targetImpl(selector) {\n        var ele = this[0];\n        var tgt;\n        if (ele) {\n            tgt = ele._private.target || ele.cy().collection();\n        }\n        return tgt && selector ? tgt.filter(selector) : tgt;\n    }, 'target'),\n    sources: defineSourceFunction({\n        attr: 'source'\n    }),\n    targets: defineSourceFunction({\n        attr: 'target'\n    })\n});\nfunction defineSourceFunction(params) {\n    return function sourceImpl(selector) {\n        var sources = [];\n        for(var i = 0; i < this.length; i++){\n            var ele = this[i];\n            var src = ele._private[params.attr];\n            if (src) {\n                sources.push(src);\n            }\n        }\n        return this.spawn(sources, true).filter(selector);\n    };\n}\nextend(elesfn$2, {\n    edgesWith: cache(defineEdgesWithFunction(), 'edgesWith'),\n    edgesTo: cache(defineEdgesWithFunction({\n        thisIsSrc: true\n    }), 'edgesTo')\n});\nfunction defineEdgesWithFunction(params) {\n    return function edgesWithImpl(otherNodes) {\n        var elements = [];\n        var cy = this._private.cy;\n        var p = params || {};\n        // get elements if a selector is specified\n        if (string(otherNodes)) {\n            otherNodes = cy.$(otherNodes);\n        }\n        for(var h = 0; h < otherNodes.length; h++){\n            var edges = otherNodes[h]._private.edges;\n            for(var i = 0; i < edges.length; i++){\n                var edge = edges[i];\n                var edgeData = edge._private.data;\n                var thisToOther = this.hasElementWithId(edgeData.source) && otherNodes.hasElementWithId(edgeData.target);\n                var otherToThis = otherNodes.hasElementWithId(edgeData.source) && this.hasElementWithId(edgeData.target);\n                var edgeConnectsThisAndOther = thisToOther || otherToThis;\n                if (!edgeConnectsThisAndOther) {\n                    continue;\n                }\n                if (p.thisIsSrc || p.thisIsTgt) {\n                    if (p.thisIsSrc && !thisToOther) {\n                        continue;\n                    }\n                    if (p.thisIsTgt && !otherToThis) {\n                        continue;\n                    }\n                }\n                elements.push(edge);\n            }\n        }\n        return this.spawn(elements, true);\n    };\n}\nextend(elesfn$2, {\n    connectedEdges: cache(function(selector) {\n        var retEles = [];\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var node = eles[i];\n            if (!node.isNode()) {\n                continue;\n            }\n            var edges = node._private.edges;\n            for(var j = 0; j < edges.length; j++){\n                var edge = edges[j];\n                retEles.push(edge);\n            }\n        }\n        return this.spawn(retEles, true).filter(selector);\n    }, 'connectedEdges'),\n    connectedNodes: cache(function(selector) {\n        var retEles = [];\n        var eles = this;\n        for(var i = 0; i < eles.length; i++){\n            var edge = eles[i];\n            if (!edge.isEdge()) {\n                continue;\n            }\n            retEles.push(edge.source()[0]);\n            retEles.push(edge.target()[0]);\n        }\n        return this.spawn(retEles, true).filter(selector);\n    }, 'connectedNodes'),\n    parallelEdges: cache(defineParallelEdgesFunction(), 'parallelEdges'),\n    codirectedEdges: cache(defineParallelEdgesFunction({\n        codirected: true\n    }), 'codirectedEdges')\n});\nfunction defineParallelEdgesFunction(params) {\n    var defaults = {\n        codirected: false\n    };\n    params = extend({}, defaults, params);\n    return function parallelEdgesImpl(selector) {\n        // micro-optimised for renderer\n        var elements = [];\n        var edges = this.edges();\n        var p = params;\n        // look at all the edges in the collection\n        for(var i = 0; i < edges.length; i++){\n            var edge1 = edges[i];\n            var edge1_p = edge1._private;\n            var src1 = edge1_p.source;\n            var srcid1 = src1._private.data.id;\n            var tgtid1 = edge1_p.data.target;\n            var srcEdges1 = src1._private.edges;\n            // look at edges connected to the src node of this edge\n            for(var j = 0; j < srcEdges1.length; j++){\n                var edge2 = srcEdges1[j];\n                var edge2data = edge2._private.data;\n                var tgtid2 = edge2data.target;\n                var srcid2 = edge2data.source;\n                var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;\n                var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;\n                if (p.codirected && codirected || !p.codirected && (codirected || oppdirected)) {\n                    elements.push(edge2);\n                }\n            }\n        }\n        return this.spawn(elements, true).filter(selector);\n    };\n}\n// Misc functions\n/////////////////\nextend(elesfn$2, {\n    components: function components(root) {\n        var self1 = this;\n        var cy = self1.cy();\n        var visited = cy.collection();\n        var unvisited = root == null ? self1.nodes() : root.nodes();\n        var components = [];\n        if (root != null && unvisited.empty()) {\n            // root may contain only edges\n            unvisited = root.sources(); // doesn't matter which node to use (undirected), so just use the source sides\n        }\n        var visitInComponent = function visitInComponent(node, component) {\n            visited.merge(node);\n            unvisited.unmerge(node);\n            component.merge(node);\n        };\n        if (unvisited.empty()) {\n            return self1.spawn();\n        }\n        var _loop = function _loop() {\n            // each iteration yields a component\n            var cmpt = cy.collection();\n            components.push(cmpt);\n            var root = unvisited[0];\n            visitInComponent(root, cmpt);\n            self1.bfs({\n                directed: false,\n                roots: root,\n                visit: function visit(v) {\n                    return visitInComponent(v, cmpt);\n                }\n            });\n            cmpt.forEach(function(node) {\n                node.connectedEdges().forEach(function(e) {\n                    // connectedEdges() usually cached\n                    if (self1.has(e) && cmpt.has(e.source()) && cmpt.has(e.target())) {\n                        // has() is cheap\n                        cmpt.merge(e); // forEach() only considers nodes -- sets N at call time\n                    }\n                });\n            });\n        };\n        do {\n            _loop();\n        }while (unvisited.length > 0);\n        return components;\n    },\n    component: function component() {\n        var ele = this[0];\n        return ele.cy().mutableElements().components(ele)[0];\n    }\n});\nelesfn$2.componentsOf = elesfn$2.components;\n// represents a set of nodes, edges, or both together\nvar Collection = function Collection(cy, elements) {\n    var unique = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var removed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (cy === undefined) {\n        error('A collection must have a reference to the core');\n        return;\n    }\n    var map = new Map$1();\n    var createdElements = false;\n    if (!elements) {\n        elements = [];\n    } else if (elements.length > 0 && plainObject(elements[0]) && !element(elements[0])) {\n        createdElements = true;\n        // make elements from json and restore all at once later\n        var eles = [];\n        var elesIds = new Set$1();\n        for(var i = 0, l = elements.length; i < l; i++){\n            var json = elements[i];\n            if (json.data == null) {\n                json.data = {};\n            }\n            var _data = json.data;\n            // make sure newly created elements have valid ids\n            if (_data.id == null) {\n                _data.id = uuid();\n            } else if (cy.hasElementWithId(_data.id) || elesIds.has(_data.id)) {\n                continue; // can't create element if prior id already exists\n            }\n            var ele = new Element(cy, json, false);\n            eles.push(ele);\n            elesIds.add(_data.id);\n        }\n        elements = eles;\n    }\n    this.length = 0;\n    for(var _i = 0, _l = elements.length; _i < _l; _i++){\n        var element$1 = elements[_i][0]; // [0] in case elements is an array of collections, rather than array of elements\n        if (element$1 == null) {\n            continue;\n        }\n        var id = element$1._private.data.id;\n        if (!unique || !map.has(id)) {\n            if (unique) {\n                map.set(id, {\n                    index: this.length,\n                    ele: element$1\n                });\n            }\n            this[this.length] = element$1;\n            this.length++;\n        }\n    }\n    this._private = {\n        eles: this,\n        cy: cy,\n        get map () {\n            if (this.lazyMap == null) {\n                this.rebuildMap();\n            }\n            return this.lazyMap;\n        },\n        set map (m){\n            this.lazyMap = m;\n        },\n        rebuildMap: function rebuildMap() {\n            var m1 = this.lazyMap = new Map$1();\n            var eles = this.eles;\n            for(var _i2 = 0; _i2 < eles.length; _i2++){\n                var _ele = eles[_i2];\n                m1.set(_ele.id(), {\n                    index: _i2,\n                    ele: _ele\n                });\n            }\n        }\n    };\n    if (unique) {\n        this._private.map = map;\n    }\n    // restore the elements if we created them from json\n    if (createdElements && !removed) {\n        this.restore();\n    }\n};\n// Functions\n////////////////////////////////////////////////////////////////////////////////////////////////////\n// keep the prototypes in sync (an element has the same functions as a collection)\n// and use elefn and elesfn as shorthands to the prototypes\nvar elesfn$1 = Element.prototype = Collection.prototype = Object.create(Array.prototype);\nelesfn$1.instanceString = function() {\n    return 'collection';\n};\nelesfn$1.spawn = function(eles, unique) {\n    return new Collection(this.cy(), eles, unique);\n};\nelesfn$1.spawnSelf = function() {\n    return this.spawn(this);\n};\nelesfn$1.cy = function() {\n    return this._private.cy;\n};\nelesfn$1.renderer = function() {\n    return this._private.cy.renderer();\n};\nelesfn$1.element = function() {\n    return this[0];\n};\nelesfn$1.collection = function() {\n    if (collection(this)) {\n        return this;\n    } else {\n        // an element\n        return new Collection(this._private.cy, [\n            this\n        ]);\n    }\n};\nelesfn$1.unique = function() {\n    return new Collection(this._private.cy, this, true);\n};\nelesfn$1.hasElementWithId = function(id) {\n    id = '' + id; // id must be string\n    return this._private.map.has(id);\n};\nelesfn$1.getElementById = function(id) {\n    id = '' + id; // id must be string\n    var cy = this._private.cy;\n    var entry = this._private.map.get(id);\n    return entry ? entry.ele : new Collection(cy); // get ele or empty collection\n};\nelesfn$1.$id = elesfn$1.getElementById;\nelesfn$1.poolIndex = function() {\n    var cy = this._private.cy;\n    var eles = cy._private.elements;\n    var id = this[0]._private.data.id;\n    return eles._private.map.get(id).index;\n};\nelesfn$1.indexOf = function(ele) {\n    var id = ele[0]._private.data.id;\n    return this._private.map.get(id).index;\n};\nelesfn$1.indexOfId = function(id) {\n    id = '' + id; // id must be string\n    return this._private.map.get(id).index;\n};\nelesfn$1.json = function(obj) {\n    var ele = this.element();\n    var cy = this.cy();\n    if (ele == null && obj) {\n        return this;\n    } // can't set to no eles\n    if (ele == null) {\n        return undefined;\n    } // can't get from no eles\n    var p = ele._private;\n    if (plainObject(obj)) {\n        // set\n        cy.startBatch();\n        if (obj.data) {\n            ele.data(obj.data);\n            var _data2 = p.data;\n            if (ele.isEdge()) {\n                // source and target are immutable via data()\n                var move = false;\n                var spec = {};\n                var src = obj.data.source;\n                var tgt = obj.data.target;\n                if (src != null && src != _data2.source) {\n                    spec.source = '' + src; // id must be string\n                    move = true;\n                }\n                if (tgt != null && tgt != _data2.target) {\n                    spec.target = '' + tgt; // id must be string\n                    move = true;\n                }\n                if (move) {\n                    ele = ele.move(spec);\n                }\n            } else {\n                // parent is immutable via data()\n                var newParentValSpecd = 'parent' in obj.data;\n                var parent = obj.data.parent;\n                if (newParentValSpecd && (parent != null || _data2.parent != null) && parent != _data2.parent) {\n                    if (parent === undefined) {\n                        // can't set undefined imperatively, so use null\n                        parent = null;\n                    }\n                    if (parent != null) {\n                        parent = '' + parent; // id must be string\n                    }\n                    ele = ele.move({\n                        parent: parent\n                    });\n                }\n            }\n        }\n        if (obj.position) {\n            ele.position(obj.position);\n        }\n        // ignore group -- immutable\n        var checkSwitch = function checkSwitch(k, trueFnName, falseFnName) {\n            var obj_k = obj[k];\n            if (obj_k != null && obj_k !== p[k]) {\n                if (obj_k) {\n                    ele[trueFnName]();\n                } else {\n                    ele[falseFnName]();\n                }\n            }\n        };\n        checkSwitch('removed', 'remove', 'restore');\n        checkSwitch('selected', 'select', 'unselect');\n        checkSwitch('selectable', 'selectify', 'unselectify');\n        checkSwitch('locked', 'lock', 'unlock');\n        checkSwitch('grabbable', 'grabify', 'ungrabify');\n        checkSwitch('pannable', 'panify', 'unpanify');\n        if (obj.classes != null) {\n            ele.classes(obj.classes);\n        }\n        cy.endBatch();\n        return this;\n    } else if (obj === undefined) {\n        // get\n        var json = {\n            data: copy(p.data),\n            position: copy(p.position),\n            group: p.group,\n            removed: p.removed,\n            selected: p.selected,\n            selectable: p.selectable,\n            locked: p.locked,\n            grabbable: p.grabbable,\n            pannable: p.pannable,\n            classes: null\n        };\n        json.classes = '';\n        var i = 0;\n        p.classes.forEach(function(cls) {\n            return json.classes += i++ === 0 ? cls : ' ' + cls;\n        });\n        return json;\n    }\n};\nelesfn$1.jsons = function() {\n    var jsons = [];\n    for(var i = 0; i < this.length; i++){\n        var ele = this[i];\n        var json = ele.json();\n        jsons.push(json);\n    }\n    return jsons;\n};\nelesfn$1.clone = function() {\n    var cy = this.cy();\n    var elesArr = [];\n    for(var i = 0; i < this.length; i++){\n        var ele = this[i];\n        var json = ele.json();\n        var clone = new Element(cy, json, false); // NB no restore\n        elesArr.push(clone);\n    }\n    return new Collection(cy, elesArr);\n};\nelesfn$1.copy = elesfn$1.clone;\nelesfn$1.restore = function() {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var addToPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self1 = this;\n    var cy = self1.cy();\n    var cy_p = cy._private;\n    // create arrays of nodes and edges, since we need to\n    // restore the nodes first\n    var nodes = [];\n    var edges = [];\n    var elements;\n    for(var _i3 = 0, l = self1.length; _i3 < l; _i3++){\n        var ele = self1[_i3];\n        if (addToPool && !ele.removed()) {\n            continue;\n        }\n        // keep nodes first in the array and edges after\n        if (ele.isNode()) {\n            // put to front of array if node\n            nodes.push(ele);\n        } else {\n            // put to end of array if edge\n            edges.push(ele);\n        }\n    }\n    elements = nodes.concat(edges);\n    var i;\n    var removeFromElements = function removeFromElements() {\n        elements.splice(i, 1);\n        i--;\n    };\n    // now, restore each element\n    for(i = 0; i < elements.length; i++){\n        var _ele2 = elements[i];\n        var _private = _ele2._private;\n        var _data3 = _private.data;\n        // the traversal cache should start fresh when ele is added\n        _ele2.clearTraversalCache();\n        // set id and validate\n        if (!addToPool && !_private.removed) ;\n        else if (_data3.id === undefined) {\n            _data3.id = uuid();\n        } else if (number$1(_data3.id)) {\n            _data3.id = '' + _data3.id; // now it's a string\n        } else if (emptyString(_data3.id) || !string(_data3.id)) {\n            error('Can not create element with invalid string ID `' + _data3.id + '`');\n            // can't create element if it has empty string as id or non-string id\n            removeFromElements();\n            continue;\n        } else if (cy.hasElementWithId(_data3.id)) {\n            error('Can not create second element with ID `' + _data3.id + '`');\n            // can't create element if one already has that id\n            removeFromElements();\n            continue;\n        }\n        var id = _data3.id; // id is finalised, now let's keep a ref\n        if (_ele2.isNode()) {\n            // extra checks for nodes\n            var pos = _private.position;\n            // make sure the nodes have a defined position\n            if (pos.x == null) {\n                pos.x = 0;\n            }\n            if (pos.y == null) {\n                pos.y = 0;\n            }\n        }\n        if (_ele2.isEdge()) {\n            // extra checks for edges\n            var edge = _ele2;\n            var fields = [\n                'source',\n                'target'\n            ];\n            var fieldsLength = fields.length;\n            var badSourceOrTarget = false;\n            for(var j = 0; j < fieldsLength; j++){\n                var field = fields[j];\n                var val = _data3[field];\n                if (number$1(val)) {\n                    val = _data3[field] = '' + _data3[field]; // now string\n                }\n                if (val == null || val === '') {\n                    // can't create if source or target is not defined properly\n                    error('Can not create edge `' + id + '` with unspecified ' + field);\n                    badSourceOrTarget = true;\n                } else if (!cy.hasElementWithId(val)) {\n                    // can't create edge if one of its nodes doesn't exist\n                    error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');\n                    badSourceOrTarget = true;\n                }\n            }\n            if (badSourceOrTarget) {\n                removeFromElements();\n                continue;\n            } // can't create this\n            var src = cy.getElementById(_data3.source);\n            var tgt = cy.getElementById(_data3.target);\n            // only one edge in node if loop\n            if (src.same(tgt)) {\n                src._private.edges.push(edge);\n            } else {\n                src._private.edges.push(edge);\n                tgt._private.edges.push(edge);\n            }\n            edge._private.source = src;\n            edge._private.target = tgt;\n        } // if is edge\n        // create mock ids / indexes maps for element so it can be used like collections\n        _private.map = new Map$1();\n        _private.map.set(id, {\n            ele: _ele2,\n            index: 0\n        });\n        _private.removed = false;\n        if (addToPool) {\n            cy.addToPool(_ele2);\n        }\n    } // for each element\n    // do compound node sanity checks\n    for(var _i4 = 0; _i4 < nodes.length; _i4++){\n        // each node\n        var node = nodes[_i4];\n        var _data4 = node._private.data;\n        if (number$1(_data4.parent)) {\n            // then automake string\n            _data4.parent = '' + _data4.parent;\n        }\n        var parentId = _data4.parent;\n        var specifiedParent = parentId != null;\n        if (specifiedParent || node._private.parent) {\n            var parent = node._private.parent ? cy.collection().merge(node._private.parent) : cy.getElementById(parentId);\n            if (parent.empty()) {\n                // non-existant parent; just remove it\n                _data4.parent = undefined;\n            } else if (parent[0].removed()) {\n                warn('Node added with missing parent, reference to parent removed');\n                _data4.parent = undefined;\n                node._private.parent = null;\n            } else {\n                var selfAsParent = false;\n                var ancestor = parent;\n                while(!ancestor.empty()){\n                    if (node.same(ancestor)) {\n                        // mark self as parent and remove from data\n                        selfAsParent = true;\n                        _data4.parent = undefined; // remove parent reference\n                        break;\n                    }\n                    ancestor = ancestor.parent();\n                }\n                if (!selfAsParent) {\n                    // connect with children\n                    parent[0]._private.children.push(node);\n                    node._private.parent = parent[0];\n                    // let the core know we have a compound graph\n                    cy_p.hasCompoundNodes = true;\n                }\n            } // else\n        } // if specified parent\n    } // for each node\n    if (elements.length > 0) {\n        var restored = elements.length === self1.length ? self1 : new Collection(cy, elements);\n        for(var _i5 = 0; _i5 < restored.length; _i5++){\n            var _ele3 = restored[_i5];\n            if (_ele3.isNode()) {\n                continue;\n            }\n            // adding an edge invalidates the traversal caches for the parallel edges\n            _ele3.parallelEdges().clearTraversalCache();\n            // adding an edge invalidates the traversal cache for the connected nodes\n            _ele3.source().clearTraversalCache();\n            _ele3.target().clearTraversalCache();\n        }\n        var toUpdateStyle;\n        if (cy_p.hasCompoundNodes) {\n            toUpdateStyle = cy.collection().merge(restored).merge(restored.connectedNodes()).merge(restored.parent());\n        } else {\n            toUpdateStyle = restored;\n        }\n        toUpdateStyle.dirtyCompoundBoundsCache().dirtyBoundingBoxCache().updateStyle(notifyRenderer);\n        if (notifyRenderer) {\n            restored.emitAndNotify('add');\n        } else if (addToPool) {\n            restored.emit('add');\n        }\n    }\n    return self1; // chainability\n};\nelesfn$1.removed = function() {\n    var ele = this[0];\n    return ele && ele._private.removed;\n};\nelesfn$1.inside = function() {\n    var ele = this[0];\n    return ele && !ele._private.removed;\n};\nelesfn$1.remove = function() {\n    var notifyRenderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    var removeFromPool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var self1 = this;\n    var elesToRemove = [];\n    var elesToRemoveIds = {};\n    var cy = self1._private.cy;\n    // add connected edges\n    function addConnectedEdges(node) {\n        var edges = node._private.edges;\n        for(var i = 0; i < edges.length; i++){\n            add(edges[i]);\n        }\n    }\n    // add descendant nodes\n    function addChildren(node) {\n        var children = node._private.children;\n        for(var i = 0; i < children.length; i++){\n            add(children[i]);\n        }\n    }\n    function add(ele) {\n        var alreadyAdded = elesToRemoveIds[ele.id()];\n        if (removeFromPool && ele.removed() || alreadyAdded) {\n            return;\n        } else {\n            elesToRemoveIds[ele.id()] = true;\n        }\n        if (ele.isNode()) {\n            elesToRemove.push(ele); // nodes are removed last\n            addConnectedEdges(ele);\n            addChildren(ele);\n        } else {\n            elesToRemove.unshift(ele); // edges are removed first\n        }\n    }\n    // make the list of elements to remove\n    // (may be removing more than specified due to connected edges etc)\n    for(var i = 0, l = self1.length; i < l; i++){\n        var ele = self1[i];\n        add(ele);\n    }\n    function removeEdgeRef(node, edge) {\n        var connectedEdges = node._private.edges;\n        removeFromArray(connectedEdges, edge);\n        // removing an edges invalidates the traversal cache for its nodes\n        node.clearTraversalCache();\n    }\n    function removeParallelRef(pllEdge) {\n        // removing an edge invalidates the traversal caches for the parallel edges\n        pllEdge.clearTraversalCache();\n    }\n    var alteredParents = [];\n    alteredParents.ids = {};\n    function removeChildRef(parent, ele) {\n        ele = ele[0];\n        parent = parent[0];\n        var children = parent._private.children;\n        var pid = parent.id();\n        removeFromArray(children, ele); // remove parent => child ref\n        ele._private.parent = null; // remove child => parent ref\n        if (!alteredParents.ids[pid]) {\n            alteredParents.ids[pid] = true;\n            alteredParents.push(parent);\n        }\n    }\n    self1.dirtyCompoundBoundsCache();\n    if (removeFromPool) {\n        cy.removeFromPool(elesToRemove); // remove from core pool\n    }\n    for(var _i6 = 0; _i6 < elesToRemove.length; _i6++){\n        var _ele4 = elesToRemove[_i6];\n        if (_ele4.isEdge()) {\n            // remove references to this edge in its connected nodes\n            var src = _ele4.source()[0];\n            var tgt = _ele4.target()[0];\n            removeEdgeRef(src, _ele4);\n            removeEdgeRef(tgt, _ele4);\n            var pllEdges = _ele4.parallelEdges();\n            for(var j = 0; j < pllEdges.length; j++){\n                var pllEdge = pllEdges[j];\n                removeParallelRef(pllEdge);\n                if (pllEdge.isBundledBezier()) {\n                    pllEdge.dirtyBoundingBoxCache();\n                }\n            }\n        } else {\n            // remove reference to parent\n            var parent = _ele4.parent();\n            if (parent.length !== 0) {\n                removeChildRef(parent, _ele4);\n            }\n        }\n        if (removeFromPool) {\n            // mark as removed\n            _ele4._private.removed = true;\n        }\n    }\n    // check to see if we have a compound graph or not\n    var elesStillInside = cy._private.elements;\n    cy._private.hasCompoundNodes = false;\n    for(var _i7 = 0; _i7 < elesStillInside.length; _i7++){\n        var _ele5 = elesStillInside[_i7];\n        if (_ele5.isParent()) {\n            cy._private.hasCompoundNodes = true;\n            break;\n        }\n    }\n    var removedElements = new Collection(this.cy(), elesToRemove);\n    if (removedElements.size() > 0) {\n        // must manually notify since trigger won't do this automatically once removed\n        if (notifyRenderer) {\n            removedElements.emitAndNotify('remove');\n        } else if (removeFromPool) {\n            removedElements.emit('remove');\n        }\n    }\n    // the parents who were modified by the removal need their style updated\n    for(var _i8 = 0; _i8 < alteredParents.length; _i8++){\n        var _ele6 = alteredParents[_i8];\n        if (!removeFromPool || !_ele6.removed()) {\n            _ele6.updateStyle();\n        }\n    }\n    return removedElements;\n};\nelesfn$1.move = function(struct) {\n    var cy = this._private.cy;\n    var eles = this;\n    // just clean up refs, caches, etc. in the same way as when removing and then restoring\n    // (our calls to remove/restore do not remove from the graph or make events)\n    var notifyRenderer = false;\n    var modifyPool = false;\n    var toString = function toString(id) {\n        return id == null ? id : '' + id;\n    }; // id must be string\n    if (struct.source !== undefined || struct.target !== undefined) {\n        var srcId = toString(struct.source);\n        var tgtId = toString(struct.target);\n        var srcExists = srcId != null && cy.hasElementWithId(srcId);\n        var tgtExists = tgtId != null && cy.hasElementWithId(tgtId);\n        if (srcExists || tgtExists) {\n            cy.batch(function() {\n                // avoid duplicate style updates\n                eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n                eles.emitAndNotify('moveout');\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    var _data5 = ele._private.data;\n                    if (ele.isEdge()) {\n                        if (srcExists) {\n                            _data5.source = srcId;\n                        }\n                        if (tgtExists) {\n                            _data5.target = tgtId;\n                        }\n                    }\n                }\n                eles.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n            });\n            eles.emitAndNotify('move');\n        }\n    } else if (struct.parent !== undefined) {\n        // move node to new parent\n        var parentId = toString(struct.parent);\n        var parentExists = parentId === null || cy.hasElementWithId(parentId);\n        if (parentExists) {\n            var pidToAssign = parentId === null ? undefined : parentId;\n            cy.batch(function() {\n                // avoid duplicate style updates\n                var updated = eles.remove(notifyRenderer, modifyPool); // clean up refs etc.\n                updated.emitAndNotify('moveout');\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    var _data6 = ele._private.data;\n                    if (ele.isNode()) {\n                        _data6.parent = pidToAssign;\n                    }\n                }\n                updated.restore(notifyRenderer, modifyPool); // make new refs, style, etc.\n            });\n            eles.emitAndNotify('move');\n        }\n    }\n    return this;\n};\n[\n    elesfn$j,\n    elesfn$i,\n    elesfn$h,\n    elesfn$g,\n    elesfn$f,\n    data,\n    elesfn$d,\n    dimensions,\n    elesfn$9,\n    elesfn$8,\n    elesfn$7,\n    elesfn$6,\n    elesfn$5,\n    elesfn$4,\n    elesfn$3,\n    elesfn$2\n].forEach(function(props) {\n    extend(elesfn$1, props);\n});\nvar corefn$9 = {\n    add: function add(opts) {\n        var elements;\n        var cy = this;\n        // add the elements\n        if (elementOrCollection(opts)) {\n            var eles = opts;\n            if (eles._private.cy === cy) {\n                // same instance => just restore\n                elements = eles.restore();\n            } else {\n                // otherwise, copy from json\n                var jsons = [];\n                for(var i = 0; i < eles.length; i++){\n                    var ele = eles[i];\n                    jsons.push(ele.json());\n                }\n                elements = new Collection(cy, jsons);\n            }\n        } else if (array(opts)) {\n            var _jsons = opts;\n            elements = new Collection(cy, _jsons);\n        } else if (plainObject(opts) && (array(opts.nodes) || array(opts.edges))) {\n            var elesByGroup = opts;\n            var _jsons2 = [];\n            var grs = [\n                'nodes',\n                'edges'\n            ];\n            for(var _i = 0, il = grs.length; _i < il; _i++){\n                var group = grs[_i];\n                var elesArray = elesByGroup[group];\n                if (array(elesArray)) {\n                    for(var j = 0, jl = elesArray.length; j < jl; j++){\n                        var json = extend({\n                            group: group\n                        }, elesArray[j]);\n                        _jsons2.push(json);\n                    }\n                }\n            }\n            elements = new Collection(cy, _jsons2);\n        } else {\n            var _json = opts;\n            elements = new Element(cy, _json).collection();\n        }\n        return elements;\n    },\n    remove: function remove(collection) {\n        if (elementOrCollection(collection)) ;\n        else if (string(collection)) {\n            var selector = collection;\n            collection = this.$(selector);\n        }\n        return collection.remove();\n    }\n};\n/* global Float32Array */ /*! Bezier curve function generator. Copyright Gaetan Renaudeau. MIT License: http://en.wikipedia.org/wiki/MIT_License */ function generateCubicBezier(mX1, mY1, mX2, mY2) {\n    var NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = 0.001, SUBDIVISION_PRECISION = 0.0000001, SUBDIVISION_MAX_ITERATIONS = 10, kSplineTableSize = 11, kSampleStepSize = 1.0 / (kSplineTableSize - 1.0), float32ArraySupported = typeof Float32Array !== 'undefined';\n    /* Must contain four arguments. */ if (arguments.length !== 4) {\n        return false;\n    }\n    /* Arguments must be numbers. */ for(var i = 0; i < 4; ++i){\n        if (typeof arguments[i] !== \"number\" || isNaN(arguments[i]) || !isFinite(arguments[i])) {\n            return false;\n        }\n    }\n    /* X values must be in the [0, 1] range. */ mX1 = Math.min(mX1, 1);\n    mX2 = Math.min(mX2, 1);\n    mX1 = Math.max(mX1, 0);\n    mX2 = Math.max(mX2, 0);\n    var mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n    function A(aA1, aA2) {\n        return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n    }\n    function B(aA1, aA2) {\n        return 3.0 * aA2 - 6.0 * aA1;\n    }\n    function C(aA1) {\n        return 3.0 * aA1;\n    }\n    function calcBezier(aT, aA1, aA2) {\n        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n    }\n    function getSlope(aT, aA1, aA2) {\n        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n    }\n    function newtonRaphsonIterate(aX, aGuessT) {\n        for(var _i = 0; _i < NEWTON_ITERATIONS; ++_i){\n            var currentSlope = getSlope(aGuessT, mX1, mX2);\n            if (currentSlope === 0.0) {\n                return aGuessT;\n            }\n            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n            aGuessT -= currentX / currentSlope;\n        }\n        return aGuessT;\n    }\n    function calcSampleValues() {\n        for(var _i2 = 0; _i2 < kSplineTableSize; ++_i2){\n            mSampleValues[_i2] = calcBezier(_i2 * kSampleStepSize, mX1, mX2);\n        }\n    }\n    function binarySubdivide(aX, aA, aB) {\n        var currentX, currentT, i = 0;\n        do {\n            currentT = aA + (aB - aA) / 2.0;\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\n            if (currentX > 0.0) {\n                aB = currentT;\n            } else {\n                aA = currentT;\n            }\n        }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n        return currentT;\n    }\n    function getTForX(aX) {\n        var intervalStart = 0.0, currentSample = 1, lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]), guessForT = intervalStart + dist * kSampleStepSize, initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize);\n        }\n    }\n    var _precomputed = false;\n    function precompute() {\n        _precomputed = true;\n        if (mX1 !== mY1 || mX2 !== mY2) {\n            calcSampleValues();\n        }\n    }\n    var f = function f(aX) {\n        if (!_precomputed) {\n            precompute();\n        }\n        if (mX1 === mY1 && mX2 === mY2) {\n            return aX;\n        }\n        if (aX === 0) {\n            return 0;\n        }\n        if (aX === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(aX), mY1, mY2);\n    };\n    f.getControlPoints = function() {\n        return [\n            {\n                x: mX1,\n                y: mY1\n            },\n            {\n                x: mX2,\n                y: mY2\n            }\n        ];\n    };\n    var str = \"generateBezier(\" + [\n        mX1,\n        mY1,\n        mX2,\n        mY2\n    ] + \")\";\n    f.toString = function() {\n        return str;\n    };\n    return f;\n}\n/*! Runge-Kutta spring physics function generator. Adapted from Framer.js, copyright Koen Bok. MIT License: http://en.wikipedia.org/wiki/MIT_License */ /* Given a tension, friction, and duration, a simulation at 60FPS will first run without a defined duration in order to calculate the full path. A second pass\n   then adjusts the time delta -- using the relation between actual time and duration -- to calculate the path for the duration-constrained animation. */ var generateSpringRK4 = function() {\n    function springAccelerationForState(state) {\n        return -state.tension * state.x - state.friction * state.v;\n    }\n    function springEvaluateStateWithDerivative(initialState, dt, derivative) {\n        var state = {\n            x: initialState.x + derivative.dx * dt,\n            v: initialState.v + derivative.dv * dt,\n            tension: initialState.tension,\n            friction: initialState.friction\n        };\n        return {\n            dx: state.v,\n            dv: springAccelerationForState(state)\n        };\n    }\n    function springIntegrateState(state, dt) {\n        var a = {\n            dx: state.v,\n            dv: springAccelerationForState(state)\n        }, b = springEvaluateStateWithDerivative(state, dt * 0.5, a), c = springEvaluateStateWithDerivative(state, dt * 0.5, b), d = springEvaluateStateWithDerivative(state, dt, c), dxdt = 1.0 / 6.0 * (a.dx + 2.0 * (b.dx + c.dx) + d.dx), dvdt = 1.0 / 6.0 * (a.dv + 2.0 * (b.dv + c.dv) + d.dv);\n        state.x = state.x + dxdt * dt;\n        state.v = state.v + dvdt * dt;\n        return state;\n    }\n    return function springRK4Factory(tension, friction, duration) {\n        var initState = {\n            x: -1,\n            v: 0,\n            tension: null,\n            friction: null\n        }, path = [\n            0\n        ], time_lapsed = 0, tolerance = 1 / 10000, DT = 16 / 1000, have_duration, dt, last_state;\n        tension = parseFloat(tension) || 500;\n        friction = parseFloat(friction) || 20;\n        duration = duration || null;\n        initState.tension = tension;\n        initState.friction = friction;\n        have_duration = duration !== null;\n        /* Calculate the actual time it takes for this animation to complete with the provided conditions. */ if (have_duration) {\n            /* Run the simulation without a duration. */ time_lapsed = springRK4Factory(tension, friction);\n            /* Compute the adjusted time delta. */ dt = time_lapsed / duration * DT;\n        } else {\n            dt = DT;\n        }\n        for(;;){\n            /* Next/step function .*/ last_state = springIntegrateState(last_state || initState, dt);\n            /* Store the position. */ path.push(1 + last_state.x);\n            time_lapsed += 16;\n            /* If the change threshold is reached, break. */ if (!(Math.abs(last_state.x) > tolerance && Math.abs(last_state.v) > tolerance)) {\n                break;\n            }\n        }\n        /* If duration is not defined, return the actual time required for completing this animation. Otherwise, return a closure that holds the\n       computed path and returns a snapshot of the position according to a given percentComplete. */ return !have_duration ? time_lapsed : function(percentComplete) {\n            return path[percentComplete * (path.length - 1) | 0];\n        };\n    };\n}();\nvar cubicBezier = function cubicBezier(t1, p1, t2, p2) {\n    var bezier = generateCubicBezier(t1, p1, t2, p2);\n    return function(start, end, percent) {\n        return start + (end - start) * bezier(percent);\n    };\n};\nvar easings = {\n    'linear': function linear(start, end, percent) {\n        return start + (end - start) * percent;\n    },\n    // default easings\n    'ease': cubicBezier(0.25, 0.1, 0.25, 1),\n    'ease-in': cubicBezier(0.42, 0, 1, 1),\n    'ease-out': cubicBezier(0, 0, 0.58, 1),\n    'ease-in-out': cubicBezier(0.42, 0, 0.58, 1),\n    // sine\n    'ease-in-sine': cubicBezier(0.47, 0, 0.745, 0.715),\n    'ease-out-sine': cubicBezier(0.39, 0.575, 0.565, 1),\n    'ease-in-out-sine': cubicBezier(0.445, 0.05, 0.55, 0.95),\n    // quad\n    'ease-in-quad': cubicBezier(0.55, 0.085, 0.68, 0.53),\n    'ease-out-quad': cubicBezier(0.25, 0.46, 0.45, 0.94),\n    'ease-in-out-quad': cubicBezier(0.455, 0.03, 0.515, 0.955),\n    // cubic\n    'ease-in-cubic': cubicBezier(0.55, 0.055, 0.675, 0.19),\n    'ease-out-cubic': cubicBezier(0.215, 0.61, 0.355, 1),\n    'ease-in-out-cubic': cubicBezier(0.645, 0.045, 0.355, 1),\n    // quart\n    'ease-in-quart': cubicBezier(0.895, 0.03, 0.685, 0.22),\n    'ease-out-quart': cubicBezier(0.165, 0.84, 0.44, 1),\n    'ease-in-out-quart': cubicBezier(0.77, 0, 0.175, 1),\n    // quint\n    'ease-in-quint': cubicBezier(0.755, 0.05, 0.855, 0.06),\n    'ease-out-quint': cubicBezier(0.23, 1, 0.32, 1),\n    'ease-in-out-quint': cubicBezier(0.86, 0, 0.07, 1),\n    // expo\n    'ease-in-expo': cubicBezier(0.95, 0.05, 0.795, 0.035),\n    'ease-out-expo': cubicBezier(0.19, 1, 0.22, 1),\n    'ease-in-out-expo': cubicBezier(1, 0, 0, 1),\n    // circ\n    'ease-in-circ': cubicBezier(0.6, 0.04, 0.98, 0.335),\n    'ease-out-circ': cubicBezier(0.075, 0.82, 0.165, 1),\n    'ease-in-out-circ': cubicBezier(0.785, 0.135, 0.15, 0.86),\n    // user param easings...\n    'spring': function spring(tension, friction, duration) {\n        if (duration === 0) {\n            // can't get a spring w/ duration 0\n            return easings.linear; // duration 0 => jump to end so impl doesn't matter\n        }\n        var spring = generateSpringRK4(tension, friction, duration);\n        return function(start, end, percent) {\n            return start + (end - start) * spring(percent);\n        };\n    },\n    'cubic-bezier': cubicBezier\n};\nfunction getEasedValue(type, start, end, percent, easingFn) {\n    if (percent === 1) {\n        return end;\n    }\n    if (start === end) {\n        return end;\n    }\n    var val = easingFn(start, end, percent);\n    if (type == null) {\n        return val;\n    }\n    if (type.roundValue || type.color) {\n        val = Math.round(val);\n    }\n    if (type.min !== undefined) {\n        val = Math.max(val, type.min);\n    }\n    if (type.max !== undefined) {\n        val = Math.min(val, type.max);\n    }\n    return val;\n}\nfunction getValue(prop, spec) {\n    if (prop.pfValue != null || prop.value != null) {\n        if (prop.pfValue != null && (spec == null || spec.type.units !== '%')) {\n            return prop.pfValue;\n        } else {\n            return prop.value;\n        }\n    } else {\n        return prop;\n    }\n}\nfunction ease(startProp, endProp, percent, easingFn, propSpec) {\n    var type = propSpec != null ? propSpec.type : null;\n    if (percent < 0) {\n        percent = 0;\n    } else if (percent > 1) {\n        percent = 1;\n    }\n    var start = getValue(startProp, propSpec);\n    var end = getValue(endProp, propSpec);\n    if (number$1(start) && number$1(end)) {\n        return getEasedValue(type, start, end, percent, easingFn);\n    } else if (array(start) && array(end)) {\n        var easedArr = [];\n        for(var i = 0; i < end.length; i++){\n            var si = start[i];\n            var ei = end[i];\n            if (si != null && ei != null) {\n                var val = getEasedValue(type, si, ei, percent, easingFn);\n                easedArr.push(val);\n            } else {\n                easedArr.push(ei);\n            }\n        }\n        return easedArr;\n    }\n    return undefined;\n}\nfunction step$1(self1, ani, now, isCore) {\n    var isEles = !isCore;\n    var _p = self1._private;\n    var ani_p = ani._private;\n    var pEasing = ani_p.easing;\n    var startTime = ani_p.startTime;\n    var cy = isCore ? self1 : self1.cy();\n    var style = cy.style();\n    if (!ani_p.easingImpl) {\n        if (pEasing == null) {\n            // use default\n            ani_p.easingImpl = easings['linear'];\n        } else {\n            // then define w/ name\n            var easingVals;\n            if (string(pEasing)) {\n                var easingProp = style.parse('transition-timing-function', pEasing);\n                easingVals = easingProp.value;\n            } else {\n                // then assume preparsed array\n                easingVals = pEasing;\n            }\n            var name, args;\n            if (string(easingVals)) {\n                name = easingVals;\n                args = [];\n            } else {\n                name = easingVals[1];\n                args = easingVals.slice(2).map(function(n) {\n                    return +n;\n                });\n            }\n            if (args.length > 0) {\n                // create with args\n                if (name === 'spring') {\n                    args.push(ani_p.duration); // need duration to generate spring\n                }\n                ani_p.easingImpl = easings[name].apply(null, args);\n            } else {\n                // static impl by name\n                ani_p.easingImpl = easings[name];\n            }\n        }\n    }\n    var easing = ani_p.easingImpl;\n    var percent;\n    if (ani_p.duration === 0) {\n        percent = 1;\n    } else {\n        percent = (now - startTime) / ani_p.duration;\n    }\n    if (ani_p.applying) {\n        percent = ani_p.progress;\n    }\n    if (percent < 0) {\n        percent = 0;\n    } else if (percent > 1) {\n        percent = 1;\n    }\n    if (ani_p.delay == null) {\n        // then update\n        var startPos = ani_p.startPosition;\n        var endPos = ani_p.position;\n        if (endPos && isEles && !self1.locked()) {\n            var newPos = {};\n            if (valid(startPos.x, endPos.x)) {\n                newPos.x = ease(startPos.x, endPos.x, percent, easing);\n            }\n            if (valid(startPos.y, endPos.y)) {\n                newPos.y = ease(startPos.y, endPos.y, percent, easing);\n            }\n            self1.position(newPos);\n        }\n        var startPan = ani_p.startPan;\n        var endPan = ani_p.pan;\n        var pan = _p.pan;\n        var animatingPan = endPan != null && isCore;\n        if (animatingPan) {\n            if (valid(startPan.x, endPan.x)) {\n                pan.x = ease(startPan.x, endPan.x, percent, easing);\n            }\n            if (valid(startPan.y, endPan.y)) {\n                pan.y = ease(startPan.y, endPan.y, percent, easing);\n            }\n            self1.emit('pan');\n        }\n        var startZoom = ani_p.startZoom;\n        var endZoom = ani_p.zoom;\n        var animatingZoom = endZoom != null && isCore;\n        if (animatingZoom) {\n            if (valid(startZoom, endZoom)) {\n                _p.zoom = bound(_p.minZoom, ease(startZoom, endZoom, percent, easing), _p.maxZoom);\n            }\n            self1.emit('zoom');\n        }\n        if (animatingPan || animatingZoom) {\n            self1.emit('viewport');\n        }\n        var props = ani_p.style;\n        if (props && props.length > 0 && isEles) {\n            for(var i = 0; i < props.length; i++){\n                var prop = props[i];\n                var _name = prop.name;\n                var end = prop;\n                var start = ani_p.startStyle[_name];\n                var propSpec = style.properties[start.name];\n                var easedVal = ease(start, end, percent, easing, propSpec);\n                style.overrideBypass(self1, _name, easedVal);\n            } // for props\n            self1.emit('style');\n        } // if\n    }\n    ani_p.progress = percent;\n    return percent;\n}\nfunction valid(start, end) {\n    if (start == null || end == null) {\n        return false;\n    }\n    if (number$1(start) && number$1(end)) {\n        return true;\n    } else if (start && end) {\n        return true;\n    }\n    return false;\n}\nfunction startAnimation(self1, ani, now, isCore) {\n    var ani_p = ani._private;\n    ani_p.started = true;\n    ani_p.startTime = now - ani_p.progress * ani_p.duration;\n}\nfunction stepAll(now, cy) {\n    var eles = cy._private.aniEles;\n    var doneEles = [];\n    function stepOne(ele, isCore) {\n        var _p = ele._private;\n        var current = _p.animation.current;\n        var queue = _p.animation.queue;\n        var ranAnis = false;\n        // if nothing currently animating, get something from the queue\n        if (current.length === 0) {\n            var next = queue.shift();\n            if (next) {\n                current.push(next);\n            }\n        }\n        var callbacks = function callbacks(_callbacks) {\n            for(var j = _callbacks.length - 1; j >= 0; j--){\n                var cb = _callbacks[j];\n                cb();\n            }\n            _callbacks.splice(0, _callbacks.length);\n        };\n        // step and remove if done\n        for(var i = current.length - 1; i >= 0; i--){\n            var ani = current[i];\n            var ani_p = ani._private;\n            if (ani_p.stopped) {\n                current.splice(i, 1);\n                ani_p.hooked = false;\n                ani_p.playing = false;\n                ani_p.started = false;\n                callbacks(ani_p.frames);\n                continue;\n            }\n            if (!ani_p.playing && !ani_p.applying) {\n                continue;\n            }\n            // an apply() while playing shouldn't do anything\n            if (ani_p.playing && ani_p.applying) {\n                ani_p.applying = false;\n            }\n            if (!ani_p.started) {\n                startAnimation(ele, ani, now);\n            }\n            step$1(ele, ani, now, isCore);\n            if (ani_p.applying) {\n                ani_p.applying = false;\n            }\n            callbacks(ani_p.frames);\n            if (ani_p.step != null) {\n                ani_p.step(now);\n            }\n            if (ani.completed()) {\n                current.splice(i, 1);\n                ani_p.hooked = false;\n                ani_p.playing = false;\n                ani_p.started = false;\n                callbacks(ani_p.completes);\n            }\n            ranAnis = true;\n        }\n        if (!isCore && current.length === 0 && queue.length === 0) {\n            doneEles.push(ele);\n        }\n        return ranAnis;\n    } // stepElement\n    // handle all eles\n    var ranEleAni = false;\n    for(var e = 0; e < eles.length; e++){\n        var ele = eles[e];\n        var handledThisEle = stepOne(ele);\n        ranEleAni = ranEleAni || handledThisEle;\n    } // each element\n    var ranCoreAni = stepOne(cy, true);\n    // notify renderer\n    if (ranEleAni || ranCoreAni) {\n        if (eles.length > 0) {\n            cy.notify('draw', eles);\n        } else {\n            cy.notify('draw');\n        }\n    }\n    // remove elements from list of currently animating if its queues are empty\n    eles.unmerge(doneEles);\n    cy.emit('step');\n} // stepAll\nvar corefn$8 = {\n    // pull in animation functions\n    animate: define.animate(),\n    animation: define.animation(),\n    animated: define.animated(),\n    clearQueue: define.clearQueue(),\n    delay: define.delay(),\n    delayAnimation: define.delayAnimation(),\n    stop: define.stop(),\n    addToAnimationPool: function addToAnimationPool(eles) {\n        var cy = this;\n        if (!cy.styleEnabled()) {\n            return;\n        } // save cycles when no style used\n        cy._private.aniEles.merge(eles);\n    },\n    stopAnimationLoop: function stopAnimationLoop() {\n        this._private.animationsRunning = false;\n    },\n    startAnimationLoop: function startAnimationLoop() {\n        var cy = this;\n        cy._private.animationsRunning = true;\n        if (!cy.styleEnabled()) {\n            return;\n        } // save cycles when no style used\n        // NB the animation loop will exec in headless environments if style enabled\n        // and explicit cy.destroy() is necessary to stop the loop\n        function headlessStep() {\n            if (!cy._private.animationsRunning) {\n                return;\n            }\n            requestAnimationFrame(function animationStep(now) {\n                stepAll(now, cy);\n                headlessStep();\n            });\n        }\n        var renderer = cy.renderer();\n        if (renderer && renderer.beforeRender) {\n            // let the renderer schedule animations\n            renderer.beforeRender(function rendererAnimationStep(willDraw, now) {\n                stepAll(now, cy);\n            }, renderer.beforeRenderPriorities.animations);\n        } else {\n            // manage the animation loop ourselves\n            headlessStep(); // first call\n        }\n    }\n};\nvar emitterOptions = {\n    qualifierCompare: function qualifierCompare(selector1, selector2) {\n        if (selector1 == null || selector2 == null) {\n            return selector1 == null && selector2 == null;\n        } else {\n            return selector1.sameText(selector2);\n        }\n    },\n    eventMatches: function eventMatches(cy, listener, eventObj) {\n        var selector = listener.qualifier;\n        if (selector != null) {\n            return cy !== eventObj.target && element(eventObj.target) && selector.matches(eventObj.target);\n        }\n        return true;\n    },\n    addEventFields: function addEventFields(cy, evt) {\n        evt.cy = cy;\n        evt.target = cy;\n    },\n    callbackContext: function callbackContext(cy, listener, eventObj) {\n        return listener.qualifier != null ? eventObj.target : cy;\n    }\n};\nvar argSelector = function argSelector(arg) {\n    if (string(arg)) {\n        return new Selector(arg);\n    } else {\n        return arg;\n    }\n};\nvar elesfn = {\n    createEmitter: function createEmitter() {\n        var _p = this._private;\n        if (!_p.emitter) {\n            _p.emitter = new Emitter(emitterOptions, this);\n        }\n        return this;\n    },\n    emitter: function emitter() {\n        return this._private.emitter;\n    },\n    on: function on(events, selector, callback) {\n        this.emitter().on(events, argSelector(selector), callback);\n        return this;\n    },\n    removeListener: function removeListener(events, selector, callback) {\n        this.emitter().removeListener(events, argSelector(selector), callback);\n        return this;\n    },\n    removeAllListeners: function removeAllListeners() {\n        this.emitter().removeAllListeners();\n        return this;\n    },\n    one: function one(events, selector, callback) {\n        this.emitter().one(events, argSelector(selector), callback);\n        return this;\n    },\n    once: function once(events, selector, callback) {\n        this.emitter().one(events, argSelector(selector), callback);\n        return this;\n    },\n    emit: function emit(events, extraParams) {\n        this.emitter().emit(events, extraParams);\n        return this;\n    },\n    emitAndNotify: function emitAndNotify(event, eles) {\n        this.emit(event);\n        this.notify(event, eles);\n        return this;\n    }\n};\ndefine.eventAliasesOn(elesfn);\nvar corefn$7 = {\n    png: function png(options) {\n        var renderer = this._private.renderer;\n        options = options || {};\n        return renderer.png(options);\n    },\n    jpg: function jpg(options) {\n        var renderer = this._private.renderer;\n        options = options || {};\n        options.bg = options.bg || '#fff';\n        return renderer.jpg(options);\n    }\n};\ncorefn$7.jpeg = corefn$7.jpg;\nvar corefn$6 = {\n    layout: function layout(options) {\n        var cy = this;\n        if (options == null) {\n            error('Layout options must be specified to make a layout');\n            return;\n        }\n        if (options.name == null) {\n            error('A `name` must be specified to make a layout');\n            return;\n        }\n        var name = options.name;\n        var Layout = cy.extension('layout', name);\n        if (Layout == null) {\n            error('No such layout `' + name + '` found.  Did you forget to import it and `cytoscape.use()` it?');\n            return;\n        }\n        var eles;\n        if (string(options.eles)) {\n            eles = cy.$(options.eles);\n        } else {\n            eles = options.eles != null ? options.eles : cy.$();\n        }\n        var layout = new Layout(extend({}, options, {\n            cy: cy,\n            eles: eles\n        }));\n        return layout;\n    }\n};\ncorefn$6.createLayout = corefn$6.makeLayout = corefn$6.layout;\nvar corefn$5 = {\n    notify: function notify(eventName, eventEles) {\n        var _p = this._private;\n        if (this.batching()) {\n            _p.batchNotifications = _p.batchNotifications || {};\n            var eles = _p.batchNotifications[eventName] = _p.batchNotifications[eventName] || this.collection();\n            if (eventEles != null) {\n                eles.merge(eventEles);\n            }\n            return; // notifications are disabled during batching\n        }\n        if (!_p.notificationsEnabled) {\n            return;\n        } // exit on disabled\n        var renderer = this.renderer();\n        // exit if destroy() called on core or renderer in between frames #1499 #1528\n        if (this.destroyed() || !renderer) {\n            return;\n        }\n        renderer.notify(eventName, eventEles);\n    },\n    notifications: function notifications(bool) {\n        var p = this._private;\n        if (bool === undefined) {\n            return p.notificationsEnabled;\n        } else {\n            p.notificationsEnabled = bool ? true : false;\n        }\n        return this;\n    },\n    noNotifications: function noNotifications(callback) {\n        this.notifications(false);\n        callback();\n        this.notifications(true);\n    },\n    batching: function batching() {\n        return this._private.batchCount > 0;\n    },\n    startBatch: function startBatch() {\n        var _p = this._private;\n        if (_p.batchCount == null) {\n            _p.batchCount = 0;\n        }\n        if (_p.batchCount === 0) {\n            _p.batchStyleEles = this.collection();\n            _p.batchNotifications = {};\n        }\n        _p.batchCount++;\n        return this;\n    },\n    endBatch: function endBatch() {\n        var _p = this._private;\n        if (_p.batchCount === 0) {\n            return this;\n        }\n        _p.batchCount--;\n        if (_p.batchCount === 0) {\n            // update style for dirty eles\n            _p.batchStyleEles.updateStyle();\n            var renderer = this.renderer();\n            // notify the renderer of queued eles and event types\n            Object.keys(_p.batchNotifications).forEach(function(eventName) {\n                var eles = _p.batchNotifications[eventName];\n                if (eles.empty()) {\n                    renderer.notify(eventName);\n                } else {\n                    renderer.notify(eventName, eles);\n                }\n            });\n        }\n        return this;\n    },\n    batch: function batch(callback) {\n        this.startBatch();\n        callback();\n        this.endBatch();\n        return this;\n    },\n    // for backwards compatibility\n    batchData: function batchData(map) {\n        var cy = this;\n        return this.batch(function() {\n            var ids = Object.keys(map);\n            for(var i = 0; i < ids.length; i++){\n                var id = ids[i];\n                var data = map[id];\n                var ele = cy.getElementById(id);\n                ele.data(data);\n            }\n        });\n    }\n};\nvar rendererDefaults = defaults$g({\n    hideEdgesOnViewport: false,\n    textureOnViewport: false,\n    motionBlur: false,\n    motionBlurOpacity: 0.05,\n    pixelRatio: undefined,\n    desktopTapThreshold: 4,\n    touchTapThreshold: 8,\n    wheelSensitivity: 1,\n    debug: false,\n    showFps: false,\n    // webgl options\n    webgl: false,\n    webglDebug: false,\n    webglDebugShowAtlases: false,\n    // defaults good for mobile\n    webglTexSize: 2048,\n    webglTexRows: 36,\n    webglTexRowsNodes: 18,\n    webglBatchSize: 2048,\n    webglTexPerBatch: 14,\n    webglBgColor: [\n        255,\n        255,\n        255\n    ]\n});\nvar corefn$4 = {\n    renderTo: function renderTo(context, zoom, pan, pxRatio) {\n        var r = this._private.renderer;\n        r.renderTo(context, zoom, pan, pxRatio);\n        return this;\n    },\n    renderer: function renderer() {\n        return this._private.renderer;\n    },\n    forceRender: function forceRender() {\n        this.notify('draw');\n        return this;\n    },\n    resize: function resize() {\n        this.invalidateSize();\n        this.emitAndNotify('resize');\n        return this;\n    },\n    initRenderer: function initRenderer(options) {\n        var cy = this;\n        var RendererProto = cy.extension('renderer', options.name);\n        if (RendererProto == null) {\n            error(\"Can not initialise: No such renderer `\".concat(options.name, \"` found. Did you forget to import it and `cytoscape.use()` it?\"));\n            return;\n        }\n        if (options.wheelSensitivity !== undefined) {\n            warn(\"You have set a custom wheel sensitivity.  This will make your app zoom unnaturally when using mainstream mice.  You should change this value from the default only if you can guarantee that all your users will use the same hardware and OS configuration as your current machine.\");\n        }\n        var rOpts = rendererDefaults(options);\n        rOpts.cy = cy;\n        cy._private.renderer = new RendererProto(rOpts);\n        this.notify('init');\n    },\n    destroyRenderer: function destroyRenderer() {\n        var cy = this;\n        cy.notify('destroy'); // destroy the renderer\n        var domEle = cy.container();\n        if (domEle) {\n            domEle._cyreg = null;\n            while(domEle.childNodes.length > 0){\n                domEle.removeChild(domEle.childNodes[0]);\n            }\n        }\n        cy._private.renderer = null; // to be extra safe, remove the ref\n        cy.mutableElements().forEach(function(ele) {\n            var _p = ele._private;\n            _p.rscratch = {};\n            _p.rstyle = {};\n            _p.animation.current = [];\n            _p.animation.queue = [];\n        });\n    },\n    onRender: function onRender(fn) {\n        return this.on('render', fn);\n    },\n    offRender: function offRender(fn) {\n        return this.off('render', fn);\n    }\n};\ncorefn$4.invalidateDimensions = corefn$4.resize;\nvar corefn$3 = {\n    // get a collection\n    // - empty collection on no args\n    // - collection of elements in the graph on selector arg\n    // - guarantee a returned collection when elements or collection specified\n    collection: function collection(eles, opts) {\n        if (string(eles)) {\n            return this.$(eles);\n        } else if (elementOrCollection(eles)) {\n            return eles.collection();\n        } else if (array(eles)) {\n            if (!opts) {\n                opts = {};\n            }\n            return new Collection(this, eles, opts.unique, opts.removed);\n        }\n        return new Collection(this);\n    },\n    nodes: function nodes(selector) {\n        var nodes = this.$(function(ele) {\n            return ele.isNode();\n        });\n        if (selector) {\n            return nodes.filter(selector);\n        }\n        return nodes;\n    },\n    edges: function edges(selector) {\n        var edges = this.$(function(ele) {\n            return ele.isEdge();\n        });\n        if (selector) {\n            return edges.filter(selector);\n        }\n        return edges;\n    },\n    // search the graph like jQuery\n    $: function $(selector) {\n        var eles = this._private.elements;\n        if (selector) {\n            return eles.filter(selector);\n        } else {\n            return eles.spawnSelf();\n        }\n    },\n    mutableElements: function mutableElements() {\n        return this._private.elements;\n    }\n};\n// aliases\ncorefn$3.elements = corefn$3.filter = corefn$3.$;\nvar styfn$8 = {};\n// keys for style blocks, e.g. ttfftt\nvar TRUE = 't';\nvar FALSE = 'f';\n// (potentially expensive calculation)\n// apply the style to the element based on\n// - its bypass\n// - what selectors match it\nstyfn$8.apply = function(eles) {\n    var self1 = this;\n    var _p = self1._private;\n    var cy = _p.cy;\n    var updatedEles = cy.collection();\n    for(var ie = 0; ie < eles.length; ie++){\n        var ele = eles[ie];\n        var cxtMeta = self1.getContextMeta(ele);\n        if (cxtMeta.empty) {\n            continue;\n        }\n        var cxtStyle = self1.getContextStyle(cxtMeta);\n        var app = self1.applyContextStyle(cxtMeta, cxtStyle, ele);\n        if (ele._private.appliedInitStyle) {\n            self1.updateTransitions(ele, app.diffProps);\n        } else {\n            ele._private.appliedInitStyle = true;\n        }\n        var hintsDiff = self1.updateStyleHints(ele);\n        if (hintsDiff) {\n            updatedEles.push(ele);\n        }\n    } // for elements\n    return updatedEles;\n};\nstyfn$8.getPropertiesDiff = function(oldCxtKey, newCxtKey) {\n    var self1 = this;\n    var cache = self1._private.propDiffs = self1._private.propDiffs || {};\n    var dualCxtKey = oldCxtKey + '-' + newCxtKey;\n    var cachedVal = cache[dualCxtKey];\n    if (cachedVal) {\n        return cachedVal;\n    }\n    var diffProps = [];\n    var addedProp = {};\n    for(var i = 0; i < self1.length; i++){\n        var cxt = self1[i];\n        var oldHasCxt = oldCxtKey[i] === TRUE;\n        var newHasCxt = newCxtKey[i] === TRUE;\n        var cxtHasDiffed = oldHasCxt !== newHasCxt;\n        var cxtHasMappedProps = cxt.mappedProperties.length > 0;\n        if (cxtHasDiffed || newHasCxt && cxtHasMappedProps) {\n            var props = undefined;\n            if (cxtHasDiffed && cxtHasMappedProps) {\n                props = cxt.properties; // suffices b/c mappedProperties is a subset of properties\n            } else if (cxtHasDiffed) {\n                props = cxt.properties; // need to check them all\n            } else if (cxtHasMappedProps) {\n                props = cxt.mappedProperties; // only need to check mapped\n            }\n            for(var j = 0; j < props.length; j++){\n                var prop = props[j];\n                var name = prop.name;\n                // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter\n                // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result\n                // is cached)\n                var laterCxtOverrides = false;\n                for(var k = i + 1; k < self1.length; k++){\n                    var laterCxt = self1[k];\n                    var hasLaterCxt = newCxtKey[k] === TRUE;\n                    if (!hasLaterCxt) {\n                        continue;\n                    } // can't override unless the context is active\n                    laterCxtOverrides = laterCxt.properties[prop.name] != null;\n                    if (laterCxtOverrides) {\n                        break;\n                    } // exit early as long as one later context overrides\n                }\n                if (!addedProp[name] && !laterCxtOverrides) {\n                    addedProp[name] = true;\n                    diffProps.push(name);\n                }\n            } // for props\n        } // if\n    } // for contexts\n    cache[dualCxtKey] = diffProps;\n    return diffProps;\n};\nstyfn$8.getContextMeta = function(ele) {\n    var self1 = this;\n    var cxtKey = '';\n    var diffProps;\n    var prevKey = ele._private.styleCxtKey || '';\n    // get the cxt key\n    for(var i = 0; i < self1.length; i++){\n        var context = self1[i];\n        var contextSelectorMatches = context.selector && context.selector.matches(ele); // NB: context.selector may be null for 'core'\n        if (contextSelectorMatches) {\n            cxtKey += TRUE;\n        } else {\n            cxtKey += FALSE;\n        }\n    } // for context\n    diffProps = self1.getPropertiesDiff(prevKey, cxtKey);\n    ele._private.styleCxtKey = cxtKey;\n    return {\n        key: cxtKey,\n        diffPropNames: diffProps,\n        empty: diffProps.length === 0\n    };\n};\n// gets a computed ele style object based on matched contexts\nstyfn$8.getContextStyle = function(cxtMeta) {\n    var cxtKey = cxtMeta.key;\n    var self1 = this;\n    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};\n    // if already computed style, returned cached copy\n    if (cxtStyles[cxtKey]) {\n        return cxtStyles[cxtKey];\n    }\n    var style = {\n        _private: {\n            key: cxtKey\n        }\n    };\n    for(var i = 0; i < self1.length; i++){\n        var cxt = self1[i];\n        var hasCxt = cxtKey[i] === TRUE;\n        if (!hasCxt) {\n            continue;\n        }\n        for(var j = 0; j < cxt.properties.length; j++){\n            var prop = cxt.properties[j];\n            style[prop.name] = prop;\n        }\n    }\n    cxtStyles[cxtKey] = style;\n    return style;\n};\nstyfn$8.applyContextStyle = function(cxtMeta, cxtStyle, ele) {\n    var self1 = this;\n    var diffProps = cxtMeta.diffPropNames;\n    var retDiffProps = {};\n    var types = self1.types;\n    for(var i = 0; i < diffProps.length; i++){\n        var diffPropName = diffProps[i];\n        var cxtProp = cxtStyle[diffPropName];\n        var eleProp = ele.pstyle(diffPropName);\n        if (!cxtProp) {\n            // no context prop means delete\n            if (!eleProp) {\n                continue; // no existing prop means nothing needs to be removed\n            // nb affects initial application on mapped values like control-point-distances\n            } else if (eleProp.bypass) {\n                cxtProp = {\n                    name: diffPropName,\n                    deleteBypassed: true\n                };\n            } else {\n                cxtProp = {\n                    name: diffPropName,\n                    \"delete\": true\n                };\n            }\n        }\n        // save cycles when the context prop doesn't need to be applied\n        if (eleProp === cxtProp) {\n            continue;\n        }\n        // save cycles when a mapped context prop doesn't need to be applied\n        if (cxtProp.mapped === types.fn // context prop is function mapper\n         && eleProp != null // some props can be null even by default (e.g. a prop that overrides another one)\n         && eleProp.mapping != null // ele prop is a concrete value from from a mapper\n         && eleProp.mapping.value === cxtProp.value // the current prop on the ele is a flat prop value for the function mapper\n        ) {\n            // NB don't write to cxtProp, as it's shared among eles (stored in stylesheet)\n            var mapping = eleProp.mapping; // can write to mapping, as it's a per-ele copy\n            var fnValue = mapping.fnValue = cxtProp.value(ele); // temporarily cache the value in case of a miss\n            if (fnValue === mapping.prevFnValue) {\n                continue;\n            }\n        }\n        var retDiffProp = retDiffProps[diffPropName] = {\n            prev: eleProp\n        };\n        self1.applyParsedProperty(ele, cxtProp);\n        retDiffProp.next = ele.pstyle(diffPropName);\n        if (retDiffProp.next && retDiffProp.next.bypass) {\n            retDiffProp.next = retDiffProp.next.bypassed;\n        }\n    }\n    return {\n        diffProps: retDiffProps\n    };\n};\nstyfn$8.updateStyleHints = function(ele) {\n    var _p = ele._private;\n    var self1 = this;\n    var propNames = self1.propertyGroupNames;\n    var propGrKeys = self1.propertyGroupKeys;\n    var propHash = function propHash(ele, propNames, seedKey) {\n        return self1.getPropertiesHash(ele, propNames, seedKey);\n    };\n    var oldStyleKey = _p.styleKey;\n    if (ele.removed()) {\n        return false;\n    }\n    var isNode = _p.group === 'nodes';\n    // get the style key hashes per prop group\n    // but lazily -- only use non-default prop values to reduce the number of hashes\n    //\n    var overriddenStyles = ele._private.style;\n    propNames = Object.keys(overriddenStyles);\n    for(var i = 0; i < propGrKeys.length; i++){\n        var grKey = propGrKeys[i];\n        _p.styleKeys[grKey] = [\n            DEFAULT_HASH_SEED,\n            DEFAULT_HASH_SEED_ALT\n        ];\n    }\n    var updateGrKey1 = function updateGrKey1(val, grKey) {\n        return _p.styleKeys[grKey][0] = hashInt(val, _p.styleKeys[grKey][0]);\n    };\n    var updateGrKey2 = function updateGrKey2(val, grKey) {\n        return _p.styleKeys[grKey][1] = hashIntAlt(val, _p.styleKeys[grKey][1]);\n    };\n    var updateGrKey = function updateGrKey(val, grKey) {\n        updateGrKey1(val, grKey);\n        updateGrKey2(val, grKey);\n    };\n    var updateGrKeyWStr = function updateGrKeyWStr(strVal, grKey) {\n        for(var j = 0; j < strVal.length; j++){\n            var ch = strVal.charCodeAt(j);\n            updateGrKey1(ch, grKey);\n            updateGrKey2(ch, grKey);\n        }\n    };\n    // - hashing works on 32 bit ints b/c we use bitwise ops\n    // - small numbers get cut off (e.g. 0.123 is seen as 0 by the hashing function)\n    // - raise up small numbers so more significant digits are seen by hashing\n    // - make small numbers larger than a normal value to avoid collisions\n    // - works in practice and it's relatively cheap\n    var N = 2000000000;\n    var cleanNum = function cleanNum(val) {\n        return -128 < val && val < 128 && Math.floor(val) !== val ? N - (val * 1024 | 0) : val;\n    };\n    for(var _i = 0; _i < propNames.length; _i++){\n        var name = propNames[_i];\n        var parsedProp = overriddenStyles[name];\n        if (parsedProp == null) {\n            continue;\n        }\n        var propInfo = this.properties[name];\n        var type = propInfo.type;\n        var _grKey = propInfo.groupKey;\n        var normalizedNumberVal = undefined;\n        if (propInfo.hashOverride != null) {\n            normalizedNumberVal = propInfo.hashOverride(ele, parsedProp);\n        } else if (parsedProp.pfValue != null) {\n            normalizedNumberVal = parsedProp.pfValue;\n        }\n        // might not be a number if it allows enums\n        var numberVal = propInfo.enums == null ? parsedProp.value : null;\n        var haveNormNum = normalizedNumberVal != null;\n        var haveUnitedNum = numberVal != null;\n        var haveNum = haveNormNum || haveUnitedNum;\n        var units = parsedProp.units;\n        // numbers are cheaper to hash than strings\n        // 1 hash op vs n hash ops (for length n string)\n        if (type.number && haveNum && !type.multiple) {\n            var v = haveNormNum ? normalizedNumberVal : numberVal;\n            updateGrKey(cleanNum(v), _grKey);\n            if (!haveNormNum && units != null) {\n                updateGrKeyWStr(units, _grKey);\n            }\n        } else {\n            updateGrKeyWStr(parsedProp.strValue, _grKey);\n        }\n    }\n    // overall style key\n    //\n    var hash = [\n        DEFAULT_HASH_SEED,\n        DEFAULT_HASH_SEED_ALT\n    ];\n    for(var _i2 = 0; _i2 < propGrKeys.length; _i2++){\n        var _grKey2 = propGrKeys[_i2];\n        var grHash = _p.styleKeys[_grKey2];\n        hash[0] = hashInt(grHash[0], hash[0]);\n        hash[1] = hashIntAlt(grHash[1], hash[1]);\n    }\n    _p.styleKey = combineHashes(hash[0], hash[1]);\n    // label dims\n    //\n    var sk = _p.styleKeys;\n    _p.labelDimsKey = combineHashesArray(sk.labelDimensions);\n    var labelKeys = propHash(ele, [\n        'label'\n    ], sk.labelDimensions);\n    _p.labelKey = combineHashesArray(labelKeys);\n    _p.labelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, labelKeys));\n    if (!isNode) {\n        var sourceLabelKeys = propHash(ele, [\n            'source-label'\n        ], sk.labelDimensions);\n        _p.sourceLabelKey = combineHashesArray(sourceLabelKeys);\n        _p.sourceLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, sourceLabelKeys));\n        var targetLabelKeys = propHash(ele, [\n            'target-label'\n        ], sk.labelDimensions);\n        _p.targetLabelKey = combineHashesArray(targetLabelKeys);\n        _p.targetLabelStyleKey = combineHashesArray(hashArrays(sk.commonLabel, targetLabelKeys));\n    }\n    // node\n    //\n    if (isNode) {\n        var _p$styleKeys = _p.styleKeys, nodeBody = _p$styleKeys.nodeBody, nodeBorder = _p$styleKeys.nodeBorder, nodeOutline = _p$styleKeys.nodeOutline, backgroundImage = _p$styleKeys.backgroundImage, compound = _p$styleKeys.compound, pie = _p$styleKeys.pie, stripe = _p$styleKeys.stripe;\n        var nodeKeys = [\n            nodeBody,\n            nodeBorder,\n            nodeOutline,\n            backgroundImage,\n            compound,\n            pie,\n            stripe\n        ].filter(function(k) {\n            return k != null;\n        }).reduce(hashArrays, [\n            DEFAULT_HASH_SEED,\n            DEFAULT_HASH_SEED_ALT\n        ]);\n        _p.nodeKey = combineHashesArray(nodeKeys);\n        _p.hasPie = pie != null && pie[0] !== DEFAULT_HASH_SEED && pie[1] !== DEFAULT_HASH_SEED_ALT;\n        _p.hasStripe = stripe != null && stripe[0] !== DEFAULT_HASH_SEED && stripe[1] !== DEFAULT_HASH_SEED_ALT;\n    }\n    return oldStyleKey !== _p.styleKey;\n};\nstyfn$8.clearStyleHints = function(ele) {\n    var _p = ele._private;\n    _p.styleCxtKey = '';\n    _p.styleKeys = {};\n    _p.styleKey = null;\n    _p.labelKey = null;\n    _p.labelStyleKey = null;\n    _p.sourceLabelKey = null;\n    _p.sourceLabelStyleKey = null;\n    _p.targetLabelKey = null;\n    _p.targetLabelStyleKey = null;\n    _p.nodeKey = null;\n    _p.hasPie = null;\n    _p.hasStripe = null;\n};\n// apply a property to the style (for internal use)\n// returns whether application was successful\n//\n// now, this function flattens the property, and here's how:\n//\n// for parsedProp:{ bypass: true, deleteBypass: true }\n// no property is generated, instead the bypass property in the\n// element's style is replaced by what's pointed to by the `bypassed`\n// field in the bypass property (i.e. restoring the property the\n// bypass was overriding)\n//\n// for parsedProp:{ mapped: truthy }\n// the generated flattenedProp:{ mapping: prop }\n//\n// for parsedProp:{ bypass: true }\n// the generated flattenedProp:{ bypassed: parsedProp }\nstyfn$8.applyParsedProperty = function(ele, parsedProp) {\n    var self1 = this;\n    var prop = parsedProp;\n    var style = ele._private.style;\n    var flatProp;\n    var types = self1.types;\n    var type = self1.properties[prop.name].type;\n    var propIsBypass = prop.bypass;\n    var origProp = style[prop.name];\n    var origPropIsBypass = origProp && origProp.bypass;\n    var _p = ele._private;\n    var flatPropMapping = 'mapping';\n    var getVal = function getVal(p) {\n        if (p == null) {\n            return null;\n        } else if (p.pfValue != null) {\n            return p.pfValue;\n        } else {\n            return p.value;\n        }\n    };\n    var checkTriggers = function checkTriggers() {\n        var fromVal = getVal(origProp);\n        var toVal = getVal(prop);\n        self1.checkTriggers(ele, prop.name, fromVal, toVal);\n    };\n    // edge sanity checks to prevent the client from making serious mistakes\n    if (parsedProp.name === 'curve-style' && ele.isEdge() && // loops must be bundled beziers\n    (parsedProp.value !== 'bezier' && ele.isLoop() || // edges connected to compound nodes can not be haystacks\n    parsedProp.value === 'haystack' && (ele.source().isParent() || ele.target().isParent()))) {\n        prop = parsedProp = this.parse(parsedProp.name, 'bezier', propIsBypass);\n    }\n    if (prop[\"delete\"]) {\n        // delete the property and use the default value on falsey value\n        style[prop.name] = undefined;\n        checkTriggers();\n        return true;\n    }\n    if (prop.deleteBypassed) {\n        // delete the property that the\n        if (!origProp) {\n            checkTriggers();\n            return true; // can't delete if no prop\n        } else if (origProp.bypass) {\n            // delete bypassed\n            origProp.bypassed = undefined;\n            checkTriggers();\n            return true;\n        } else {\n            return false; // we're unsuccessful deleting the bypassed\n        }\n    }\n    // check if we need to delete the current bypass\n    if (prop.deleteBypass) {\n        // then this property is just here to indicate we need to delete\n        if (!origProp) {\n            checkTriggers();\n            return true; // property is already not defined\n        } else if (origProp.bypass) {\n            // then replace the bypass property with the original\n            // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)\n            style[prop.name] = origProp.bypassed;\n            checkTriggers();\n            return true;\n        } else {\n            return false; // we're unsuccessful deleting the bypass\n        }\n    }\n    var printMappingErr = function printMappingErr() {\n        warn('Do not assign mappings to elements without corresponding data (i.e. ele `' + ele.id() + '` has no mapping for property `' + prop.name + '` with data field `' + prop.field + '`); try a `[' + prop.field + ']` selector to limit scope to elements with `' + prop.field + '` defined');\n    };\n    // put the property in the style objects\n    switch(prop.mapped){\n        // flatten the property if mapped\n        case types.mapData:\n            {\n                // flatten the field (e.g. data.foo.bar)\n                var fields = prop.field.split('.');\n                var fieldVal = _p.data;\n                for(var i = 0; i < fields.length && fieldVal; i++){\n                    var field = fields[i];\n                    fieldVal = fieldVal[field];\n                }\n                if (fieldVal == null) {\n                    printMappingErr();\n                    return false;\n                }\n                var percent;\n                if (!number$1(fieldVal)) {\n                    // then don't apply and fall back on the existing style\n                    warn('Do not use continuous mappers without specifying numeric data (i.e. `' + prop.field + ': ' + fieldVal + '` for `' + ele.id() + '` is non-numeric)');\n                    return false;\n                } else {\n                    var fieldWidth = prop.fieldMax - prop.fieldMin;\n                    if (fieldWidth === 0) {\n                        // safety check -- not strictly necessary as no props of zero range should be passed here\n                        percent = 0;\n                    } else {\n                        percent = (fieldVal - prop.fieldMin) / fieldWidth;\n                    }\n                }\n                // make sure to bound percent value\n                if (percent < 0) {\n                    percent = 0;\n                } else if (percent > 1) {\n                    percent = 1;\n                }\n                if (type.color) {\n                    var r1 = prop.valueMin[0];\n                    var r2 = prop.valueMax[0];\n                    var g1 = prop.valueMin[1];\n                    var g2 = prop.valueMax[1];\n                    var b1 = prop.valueMin[2];\n                    var b2 = prop.valueMax[2];\n                    var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];\n                    var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];\n                    var clr = [\n                        Math.round(r1 + (r2 - r1) * percent),\n                        Math.round(g1 + (g2 - g1) * percent),\n                        Math.round(b1 + (b2 - b1) * percent),\n                        Math.round(a1 + (a2 - a1) * percent)\n                    ];\n                    flatProp = {\n                        // colours are simple, so just create the flat property instead of expensive string parsing\n                        bypass: prop.bypass,\n                        // we're a bypass if the mapping property is a bypass\n                        name: prop.name,\n                        value: clr,\n                        strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'\n                    };\n                } else if (type.number) {\n                    var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;\n                    flatProp = this.parse(prop.name, calcValue, prop.bypass, flatPropMapping);\n                } else {\n                    return false; // can only map to colours and numbers\n                }\n                if (!flatProp) {\n                    // if we can't flatten the property, then don't apply the property and fall back on the existing style\n                    printMappingErr();\n                    return false;\n                }\n                flatProp.mapping = prop; // keep a reference to the mapping\n                prop = flatProp; // the flattened (mapped) property is the one we want\n                break;\n            }\n        // direct mapping\n        case types.data:\n            {\n                // flatten the field (e.g. data.foo.bar)\n                var _fields = prop.field.split('.');\n                var _fieldVal = _p.data;\n                for(var _i3 = 0; _i3 < _fields.length && _fieldVal; _i3++){\n                    var _field = _fields[_i3];\n                    _fieldVal = _fieldVal[_field];\n                }\n                if (_fieldVal != null) {\n                    flatProp = this.parse(prop.name, _fieldVal, prop.bypass, flatPropMapping);\n                }\n                if (!flatProp) {\n                    // if we can't flatten the property, then don't apply and fall back on the existing style\n                    printMappingErr();\n                    return false;\n                }\n                flatProp.mapping = prop; // keep a reference to the mapping\n                prop = flatProp; // the flattened (mapped) property is the one we want\n                break;\n            }\n        case types.fn:\n            {\n                var fn = prop.value;\n                var fnRetVal = prop.fnValue != null ? prop.fnValue : fn(ele); // check for cached value before calling function\n                prop.prevFnValue = fnRetVal;\n                if (fnRetVal == null) {\n                    warn('Custom function mappers may not return null (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is null)');\n                    return false;\n                }\n                flatProp = this.parse(prop.name, fnRetVal, prop.bypass, flatPropMapping);\n                if (!flatProp) {\n                    warn('Custom function mappers may not return invalid values for the property type (i.e. `' + prop.name + '` for ele `' + ele.id() + '` is invalid)');\n                    return false;\n                }\n                flatProp.mapping = copy(prop); // keep a reference to the mapping\n                prop = flatProp; // the flattened (mapped) property is the one we want\n                break;\n            }\n        case undefined:\n            break;\n        // just set the property\n        default:\n            return false;\n    }\n    // if the property is a bypass property, then link the resultant property to the original one\n    if (propIsBypass) {\n        if (origPropIsBypass) {\n            // then this bypass overrides the existing one\n            prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass\n        } else {\n            // then link the orig prop to the new bypass\n            prop.bypassed = origProp;\n        }\n        style[prop.name] = prop; // and set\n    } else {\n        // prop is not bypass\n        if (origPropIsBypass) {\n            // then keep the orig prop (since it's a bypass) and link to the new prop\n            origProp.bypassed = prop;\n        } else {\n            // then just replace the old prop with the new one\n            style[prop.name] = prop;\n        }\n    }\n    checkTriggers();\n    return true;\n};\nstyfn$8.cleanElements = function(eles, keepBypasses) {\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        this.clearStyleHints(ele);\n        ele.dirtyCompoundBoundsCache();\n        ele.dirtyBoundingBoxCache();\n        if (!keepBypasses) {\n            ele._private.style = {};\n        } else {\n            var style = ele._private.style;\n            var propNames = Object.keys(style);\n            for(var j = 0; j < propNames.length; j++){\n                var propName = propNames[j];\n                var eleProp = style[propName];\n                if (eleProp != null) {\n                    if (eleProp.bypass) {\n                        eleProp.bypassed = null;\n                    } else {\n                        style[propName] = null;\n                    }\n                }\n            }\n        }\n    }\n};\n// updates the visual style for all elements (useful for manual style modification after init)\nstyfn$8.update = function() {\n    var cy = this._private.cy;\n    var eles = cy.mutableElements();\n    eles.updateStyle();\n};\n// diffProps : { name => { prev, next } }\nstyfn$8.updateTransitions = function(ele, diffProps) {\n    var self1 = this;\n    var _p = ele._private;\n    var props = ele.pstyle('transition-property').value;\n    var duration = ele.pstyle('transition-duration').pfValue;\n    var delay = ele.pstyle('transition-delay').pfValue;\n    if (props.length > 0 && duration > 0) {\n        var style = {};\n        // build up the style to animate towards\n        var anyPrev = false;\n        for(var i = 0; i < props.length; i++){\n            var prop = props[i];\n            var styProp = ele.pstyle(prop);\n            var diffProp = diffProps[prop];\n            if (!diffProp) {\n                continue;\n            }\n            var prevProp = diffProp.prev;\n            var fromProp = prevProp;\n            var toProp = diffProp.next != null ? diffProp.next : styProp;\n            var diff = false;\n            var initVal = undefined;\n            var initDt = 0.000001; // delta time % value for initVal (allows animating out of init zero opacity)\n            if (!fromProp) {\n                continue;\n            }\n            // consider px values\n            if (number$1(fromProp.pfValue) && number$1(toProp.pfValue)) {\n                diff = toProp.pfValue - fromProp.pfValue; // nonzero is truthy\n                initVal = fromProp.pfValue + initDt * diff;\n            // consider numerical values\n            } else if (number$1(fromProp.value) && number$1(toProp.value)) {\n                diff = toProp.value - fromProp.value; // nonzero is truthy\n                initVal = fromProp.value + initDt * diff;\n            // consider colour values\n            } else if (array(fromProp.value) && array(toProp.value)) {\n                diff = fromProp.value[0] !== toProp.value[0] || fromProp.value[1] !== toProp.value[1] || fromProp.value[2] !== toProp.value[2];\n                initVal = fromProp.strValue;\n            }\n            // the previous value is good for an animation only if it's different\n            if (diff) {\n                style[prop] = toProp.strValue; // to val\n                this.applyBypass(ele, prop, initVal); // from val\n                anyPrev = true;\n            }\n        } // end if props allow ani\n        // can't transition if there's nothing previous to transition from\n        if (!anyPrev) {\n            return;\n        }\n        _p.transitioning = true;\n        new Promise$1(function(resolve) {\n            if (delay > 0) {\n                ele.delayAnimation(delay).play().promise().then(resolve);\n            } else {\n                resolve();\n            }\n        }).then(function() {\n            return ele.animation({\n                style: style,\n                duration: duration,\n                easing: ele.pstyle('transition-timing-function').value,\n                queue: false\n            }).play().promise();\n        }).then(function() {\n            // if( !isBypass ){\n            self1.removeBypasses(ele, props);\n            ele.emitAndNotify('style');\n            // }\n            _p.transitioning = false;\n        });\n    } else if (_p.transitioning) {\n        this.removeBypasses(ele, props);\n        ele.emitAndNotify('style');\n        _p.transitioning = false;\n    }\n};\nstyfn$8.checkTrigger = function(ele, name, fromValue, toValue, getTrigger, onTrigger) {\n    var prop = this.properties[name];\n    var triggerCheck = getTrigger(prop);\n    if (ele.removed()) {\n        return;\n    }\n    if (triggerCheck != null && triggerCheck(fromValue, toValue, ele)) {\n        onTrigger(prop);\n    }\n};\nstyfn$8.checkZOrderTrigger = function(ele, name, fromValue, toValue) {\n    var _this = this;\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersZOrder;\n    }, function() {\n        _this._private.cy.notify('zorder', ele);\n    });\n};\nstyfn$8.checkBoundsTrigger = function(ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersBounds;\n    }, function(prop) {\n        ele.dirtyCompoundBoundsCache();\n        ele.dirtyBoundingBoxCache();\n    });\n};\nstyfn$8.checkConnectedEdgesBoundsTrigger = function(ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersBoundsOfConnectedEdges;\n    }, function(prop) {\n        ele.connectedEdges().forEach(function(edge) {\n            edge.dirtyBoundingBoxCache();\n        });\n    });\n};\nstyfn$8.checkParallelEdgesBoundsTrigger = function(ele, name, fromValue, toValue) {\n    this.checkTrigger(ele, name, fromValue, toValue, function(prop) {\n        return prop.triggersBoundsOfParallelEdges;\n    }, function(prop) {\n        ele.parallelEdges().forEach(function(pllEdge) {\n            pllEdge.dirtyBoundingBoxCache();\n        });\n    });\n};\nstyfn$8.checkTriggers = function(ele, name, fromValue, toValue) {\n    ele.dirtyStyleCache();\n    this.checkZOrderTrigger(ele, name, fromValue, toValue);\n    this.checkBoundsTrigger(ele, name, fromValue, toValue);\n    this.checkConnectedEdgesBoundsTrigger(ele, name, fromValue, toValue);\n    this.checkParallelEdgesBoundsTrigger(ele, name, fromValue, toValue);\n};\nvar styfn$7 = {};\n// bypasses are applied to an existing style on an element, and just tacked on temporarily\n// returns true iff application was successful for at least 1 specified property\nstyfn$7.applyBypass = function(eles, name, value, updateTransitions) {\n    var self1 = this;\n    var props = [];\n    var isBypass = true;\n    // put all the properties (can specify one or many) in an array after parsing them\n    if (name === '*' || name === '**') {\n        // apply to all property names\n        if (value !== undefined) {\n            for(var i = 0; i < self1.properties.length; i++){\n                var prop = self1.properties[i];\n                var _name = prop.name;\n                var parsedProp = this.parse(_name, value, true);\n                if (parsedProp) {\n                    props.push(parsedProp);\n                }\n            }\n        }\n    } else if (string(name)) {\n        // then parse the single property\n        var _parsedProp = this.parse(name, value, true);\n        if (_parsedProp) {\n            props.push(_parsedProp);\n        }\n    } else if (plainObject(name)) {\n        // then parse each property\n        var specifiedProps = name;\n        updateTransitions = value;\n        var names = Object.keys(specifiedProps);\n        for(var _i = 0; _i < names.length; _i++){\n            var _name2 = names[_i];\n            var _value = specifiedProps[_name2];\n            if (_value === undefined) {\n                // try camel case name too\n                _value = specifiedProps[dash2camel(_name2)];\n            }\n            if (_value !== undefined) {\n                var _parsedProp2 = this.parse(_name2, _value, true);\n                if (_parsedProp2) {\n                    props.push(_parsedProp2);\n                }\n            }\n        }\n    } else {\n        // can't do anything without well defined properties\n        return false;\n    }\n    // we've failed if there are no valid properties\n    if (props.length === 0) {\n        return false;\n    }\n    // now, apply the bypass properties on the elements\n    var ret = false; // return true if at least one succesful bypass applied\n    for(var _i2 = 0; _i2 < eles.length; _i2++){\n        // for each ele\n        var ele = eles[_i2];\n        var diffProps = {};\n        var diffProp = undefined;\n        for(var j = 0; j < props.length; j++){\n            // for each prop\n            var _prop = props[j];\n            if (updateTransitions) {\n                var prevProp = ele.pstyle(_prop.name);\n                diffProp = diffProps[_prop.name] = {\n                    prev: prevProp\n                };\n            }\n            ret = this.applyParsedProperty(ele, copy(_prop)) || ret;\n            if (updateTransitions) {\n                diffProp.next = ele.pstyle(_prop.name);\n            }\n        } // for props\n        if (ret) {\n            this.updateStyleHints(ele);\n        }\n        if (updateTransitions) {\n            this.updateTransitions(ele, diffProps, isBypass);\n        }\n    } // for eles\n    return ret;\n};\n// only useful in specific cases like animation\nstyfn$7.overrideBypass = function(eles, name, value) {\n    name = camel2dash(name);\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var prop = ele._private.style[name];\n        var type = this.properties[name].type;\n        var isColor = type.color;\n        var isMulti = type.mutiple;\n        var oldValue = !prop ? null : prop.pfValue != null ? prop.pfValue : prop.value;\n        if (!prop || !prop.bypass) {\n            // need a bypass if one doesn't exist\n            this.applyBypass(ele, name, value);\n        } else {\n            prop.value = value;\n            if (prop.pfValue != null) {\n                prop.pfValue = value;\n            }\n            if (isColor) {\n                prop.strValue = 'rgb(' + value.join(',') + ')';\n            } else if (isMulti) {\n                prop.strValue = value.join(' ');\n            } else {\n                prop.strValue = '' + value;\n            }\n            this.updateStyleHints(ele);\n        }\n        this.checkTriggers(ele, name, oldValue, value);\n    }\n};\nstyfn$7.removeAllBypasses = function(eles, updateTransitions) {\n    return this.removeBypasses(eles, this.propertyNames, updateTransitions);\n};\nstyfn$7.removeBypasses = function(eles, props, updateTransitions) {\n    var isBypass = true;\n    for(var j = 0; j < eles.length; j++){\n        var ele = eles[j];\n        var diffProps = {};\n        for(var i = 0; i < props.length; i++){\n            var name = props[i];\n            var prop = this.properties[name];\n            var prevProp = ele.pstyle(prop.name);\n            if (!prevProp || !prevProp.bypass) {\n                continue;\n            }\n            var value = ''; // empty => remove bypass\n            var parsedProp = this.parse(name, value, true);\n            var diffProp = diffProps[prop.name] = {\n                prev: prevProp\n            };\n            this.applyParsedProperty(ele, parsedProp);\n            diffProp.next = ele.pstyle(prop.name);\n        } // for props\n        this.updateStyleHints(ele);\n        if (updateTransitions) {\n            this.updateTransitions(ele, diffProps, isBypass);\n        }\n    } // for eles\n};\nvar styfn$6 = {};\n// gets what an em size corresponds to in pixels relative to a dom element\nstyfn$6.getEmSizeInPixels = function() {\n    var px = this.containerCss('font-size');\n    if (px != null) {\n        return parseFloat(px);\n    } else {\n        return 1; // for headless\n    }\n};\n// gets css property from the core container\nstyfn$6.containerCss = function(propName) {\n    var cy = this._private.cy;\n    var domElement = cy.container();\n    var containerWindow = cy.window();\n    if (containerWindow && domElement && containerWindow.getComputedStyle) {\n        return containerWindow.getComputedStyle(domElement).getPropertyValue(propName);\n    }\n};\nvar styfn$5 = {};\n// gets the rendered style for an element\nstyfn$5.getRenderedStyle = function(ele, prop) {\n    if (prop) {\n        return this.getStylePropertyValue(ele, prop, true);\n    } else {\n        return this.getRawStyle(ele, true);\n    }\n};\n// gets the raw style for an element\nstyfn$5.getRawStyle = function(ele, isRenderedVal) {\n    var self1 = this;\n    ele = ele[0]; // insure it's an element\n    if (ele) {\n        var rstyle = {};\n        for(var i = 0; i < self1.properties.length; i++){\n            var prop = self1.properties[i];\n            var val = self1.getStylePropertyValue(ele, prop.name, isRenderedVal);\n            if (val != null) {\n                rstyle[prop.name] = val;\n                rstyle[dash2camel(prop.name)] = val;\n            }\n        }\n        return rstyle;\n    }\n};\nstyfn$5.getIndexedStyle = function(ele, property, subproperty, index) {\n    var pstyle = ele.pstyle(property)[subproperty][index];\n    return pstyle != null ? pstyle : ele.cy().style().getDefaultProperty(property)[subproperty][0];\n};\nstyfn$5.getStylePropertyValue = function(ele, propName, isRenderedVal) {\n    var self1 = this;\n    ele = ele[0]; // insure it's an element\n    if (ele) {\n        var prop = self1.properties[propName];\n        if (prop.alias) {\n            prop = prop.pointsTo;\n        }\n        var type = prop.type;\n        var styleProp = ele.pstyle(prop.name);\n        if (styleProp) {\n            var value = styleProp.value, units = styleProp.units, strValue = styleProp.strValue;\n            if (isRenderedVal && type.number && value != null && number$1(value)) {\n                var zoom = ele.cy().zoom();\n                var getRenderedValue = function getRenderedValue(val) {\n                    return val * zoom;\n                };\n                var getValueStringWithUnits = function getValueStringWithUnits(val, units) {\n                    return getRenderedValue(val) + units;\n                };\n                var isArrayValue = array(value);\n                var haveUnits = isArrayValue ? units.every(function(u) {\n                    return u != null;\n                }) : units != null;\n                if (haveUnits) {\n                    if (isArrayValue) {\n                        return value.map(function(v, i) {\n                            return getValueStringWithUnits(v, units[i]);\n                        }).join(' ');\n                    } else {\n                        return getValueStringWithUnits(value, units);\n                    }\n                } else {\n                    if (isArrayValue) {\n                        return value.map(function(v) {\n                            return string(v) ? v : '' + getRenderedValue(v);\n                        }).join(' ');\n                    } else {\n                        return '' + getRenderedValue(value);\n                    }\n                }\n            } else if (strValue != null) {\n                return strValue;\n            }\n        }\n        return null;\n    }\n};\nstyfn$5.getAnimationStartStyle = function(ele, aniProps) {\n    var rstyle = {};\n    for(var i = 0; i < aniProps.length; i++){\n        var aniProp = aniProps[i];\n        var name = aniProp.name;\n        var styleProp = ele.pstyle(name);\n        if (styleProp !== undefined) {\n            // then make a prop of it\n            if (plainObject(styleProp)) {\n                styleProp = this.parse(name, styleProp.strValue);\n            } else {\n                styleProp = this.parse(name, styleProp);\n            }\n        }\n        if (styleProp) {\n            rstyle[name] = styleProp;\n        }\n    }\n    return rstyle;\n};\nstyfn$5.getPropsList = function(propsObj) {\n    var self1 = this;\n    var rstyle = [];\n    var style = propsObj;\n    var props = self1.properties;\n    if (style) {\n        var names = Object.keys(style);\n        for(var i = 0; i < names.length; i++){\n            var name = names[i];\n            var val = style[name];\n            var prop = props[name] || props[camel2dash(name)];\n            var styleProp = this.parse(prop.name, val);\n            if (styleProp) {\n                rstyle.push(styleProp);\n            }\n        }\n    }\n    return rstyle;\n};\nstyfn$5.getNonDefaultPropertiesHash = function(ele, propNames, seed) {\n    var hash = seed.slice();\n    var name, val, strVal, chVal;\n    var i, j;\n    for(i = 0; i < propNames.length; i++){\n        name = propNames[i];\n        val = ele.pstyle(name, false);\n        if (val == null) {\n            continue;\n        } else if (val.pfValue != null) {\n            hash[0] = hashInt(chVal, hash[0]);\n            hash[1] = hashIntAlt(chVal, hash[1]);\n        } else {\n            strVal = val.strValue;\n            for(j = 0; j < strVal.length; j++){\n                chVal = strVal.charCodeAt(j);\n                hash[0] = hashInt(chVal, hash[0]);\n                hash[1] = hashIntAlt(chVal, hash[1]);\n            }\n        }\n    }\n    return hash;\n};\nstyfn$5.getPropertiesHash = styfn$5.getNonDefaultPropertiesHash;\nvar styfn$4 = {};\nstyfn$4.appendFromJson = function(json) {\n    var style = this;\n    for(var i = 0; i < json.length; i++){\n        var context = json[i];\n        var selector = context.selector;\n        var props = context.style || context.css;\n        var names = Object.keys(props);\n        style.selector(selector); // apply selector\n        for(var j = 0; j < names.length; j++){\n            var name = names[j];\n            var value = props[name];\n            style.css(name, value); // apply property\n        }\n    }\n    return style;\n};\n// accessible cy.style() function\nstyfn$4.fromJson = function(json) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromJson(json);\n    return style;\n};\n// get json from cy.style() api\nstyfn$4.json = function() {\n    var json = [];\n    for(var i = this.defaultLength; i < this.length; i++){\n        var cxt = this[i];\n        var selector = cxt.selector;\n        var props = cxt.properties;\n        var css = {};\n        for(var j = 0; j < props.length; j++){\n            var prop = props[j];\n            css[prop.name] = prop.strValue;\n        }\n        json.push({\n            selector: !selector ? 'core' : selector.toString(),\n            style: css\n        });\n    }\n    return json;\n};\nvar styfn$3 = {};\nstyfn$3.appendFromString = function(string) {\n    var self1 = this;\n    var style = this;\n    var remaining = '' + string;\n    var selAndBlockStr;\n    var blockRem;\n    var propAndValStr;\n    // remove comments from the style string\n    remaining = remaining.replace(/[/][*](\\s|.)+?[*][/]/g, '');\n    function removeSelAndBlockFromRemaining() {\n        // remove the parsed selector and block from the remaining text to parse\n        if (remaining.length > selAndBlockStr.length) {\n            remaining = remaining.substr(selAndBlockStr.length);\n        } else {\n            remaining = '';\n        }\n    }\n    function removePropAndValFromRem() {\n        // remove the parsed property and value from the remaining block text to parse\n        if (blockRem.length > propAndValStr.length) {\n            blockRem = blockRem.substr(propAndValStr.length);\n        } else {\n            blockRem = '';\n        }\n    }\n    for(;;){\n        var nothingLeftToParse = remaining.match(/^\\s*$/);\n        if (nothingLeftToParse) {\n            break;\n        }\n        var selAndBlock = remaining.match(/^\\s*((?:.|\\s)+?)\\s*\\{((?:.|\\s)+?)\\}/);\n        if (!selAndBlock) {\n            warn('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);\n            break;\n        }\n        selAndBlockStr = selAndBlock[0];\n        // parse the selector\n        var selectorStr = selAndBlock[1];\n        if (selectorStr !== 'core') {\n            var selector = new Selector(selectorStr);\n            if (selector.invalid) {\n                warn('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);\n                // skip this selector and block\n                removeSelAndBlockFromRemaining();\n                continue;\n            }\n        }\n        // parse the block of properties and values\n        var blockStr = selAndBlock[2];\n        var invalidBlock = false;\n        blockRem = blockStr;\n        var props = [];\n        for(;;){\n            var _nothingLeftToParse = blockRem.match(/^\\s*$/);\n            if (_nothingLeftToParse) {\n                break;\n            }\n            var propAndVal = blockRem.match(/^\\s*(.+?)\\s*:\\s*(.+?)(?:\\s*;|\\s*$)/);\n            if (!propAndVal) {\n                warn('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);\n                invalidBlock = true;\n                break;\n            }\n            propAndValStr = propAndVal[0];\n            var propStr = propAndVal[1];\n            var valStr = propAndVal[2];\n            var prop = self1.properties[propStr];\n            if (!prop) {\n                warn('Skipping property: Invalid property name in: ' + propAndValStr);\n                // skip this property in the block\n                removePropAndValFromRem();\n                continue;\n            }\n            var parsedProp = style.parse(propStr, valStr);\n            if (!parsedProp) {\n                warn('Skipping property: Invalid property definition in: ' + propAndValStr);\n                // skip this property in the block\n                removePropAndValFromRem();\n                continue;\n            }\n            props.push({\n                name: propStr,\n                val: valStr\n            });\n            removePropAndValFromRem();\n        }\n        if (invalidBlock) {\n            removeSelAndBlockFromRemaining();\n            break;\n        }\n        // put the parsed block in the style\n        style.selector(selectorStr);\n        for(var i = 0; i < props.length; i++){\n            var _prop = props[i];\n            style.css(_prop.name, _prop.val);\n        }\n        removeSelAndBlockFromRemaining();\n    }\n    return style;\n};\nstyfn$3.fromString = function(string) {\n    var style = this;\n    style.resetToDefault();\n    style.appendFromString(string);\n    return style;\n};\nvar styfn$2 = {};\n(function() {\n    var number$1 = number;\n    var rgba = rgbaNoBackRefs;\n    var hsla = hslaNoBackRefs;\n    var hex3$1 = hex3;\n    var hex6$1 = hex6;\n    var data = function data(prefix) {\n        return '^' + prefix + '\\\\s*\\\\(\\\\s*([\\\\w\\\\.]+)\\\\s*\\\\)$';\n    };\n    var mapData = function mapData(prefix) {\n        var mapArg = number$1 + '|\\\\w+|' + rgba + '|' + hsla + '|' + hex3$1 + '|' + hex6$1;\n        return '^' + prefix + '\\\\s*\\\\(([\\\\w\\\\.]+)\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*\\\\,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + mapArg + ')\\\\s*\\\\,\\\\s*(' + mapArg + ')\\\\)$';\n    };\n    var urlRegexes = [\n        '^url\\\\s*\\\\(\\\\s*[\\'\"]?(.+?)[\\'\"]?\\\\s*\\\\)$',\n        '^(none)$',\n        '^(.+)$'\n    ];\n    // each visual style property has a type and needs to be validated according to it\n    styfn$2.types = {\n        time: {\n            number: true,\n            min: 0,\n            units: 's|ms',\n            implicitUnits: 'ms'\n        },\n        percent: {\n            number: true,\n            min: 0,\n            max: 100,\n            units: '%',\n            implicitUnits: '%'\n        },\n        percentages: {\n            number: true,\n            min: 0,\n            max: 100,\n            units: '%',\n            implicitUnits: '%',\n            multiple: true\n        },\n        zeroOneNumber: {\n            number: true,\n            min: 0,\n            max: 1,\n            unitless: true\n        },\n        zeroOneNumbers: {\n            number: true,\n            min: 0,\n            max: 1,\n            unitless: true,\n            multiple: true\n        },\n        nOneOneNumber: {\n            number: true,\n            min: -1,\n            max: 1,\n            unitless: true\n        },\n        nonNegativeInt: {\n            number: true,\n            min: 0,\n            integer: true,\n            unitless: true\n        },\n        nonNegativeNumber: {\n            number: true,\n            min: 0,\n            unitless: true\n        },\n        position: {\n            enums: [\n                'parent',\n                'origin'\n            ]\n        },\n        nodeSize: {\n            number: true,\n            min: 0,\n            enums: [\n                'label'\n            ]\n        },\n        number: {\n            number: true,\n            unitless: true\n        },\n        numbers: {\n            number: true,\n            unitless: true,\n            multiple: true\n        },\n        positiveNumber: {\n            number: true,\n            unitless: true,\n            min: 0,\n            strictMin: true\n        },\n        size: {\n            number: true,\n            min: 0\n        },\n        bidirectionalSize: {\n            number: true\n        },\n        // allows negative\n        bidirectionalSizeMaybePercent: {\n            number: true,\n            allowPercent: true\n        },\n        // allows negative\n        bidirectionalSizes: {\n            number: true,\n            multiple: true\n        },\n        // allows negative\n        sizeMaybePercent: {\n            number: true,\n            min: 0,\n            allowPercent: true\n        },\n        axisDirection: {\n            enums: [\n                'horizontal',\n                'leftward',\n                'rightward',\n                'vertical',\n                'upward',\n                'downward',\n                'auto'\n            ]\n        },\n        axisDirectionExplicit: {\n            enums: [\n                'leftward',\n                'rightward',\n                'upward',\n                'downward'\n            ]\n        },\n        axisDirectionPrimary: {\n            enums: [\n                'horizontal',\n                'vertical'\n            ]\n        },\n        paddingRelativeTo: {\n            enums: [\n                'width',\n                'height',\n                'average',\n                'min',\n                'max'\n            ]\n        },\n        bgWH: {\n            number: true,\n            min: 0,\n            allowPercent: true,\n            enums: [\n                'auto'\n            ],\n            multiple: true\n        },\n        bgPos: {\n            number: true,\n            allowPercent: true,\n            multiple: true\n        },\n        bgRelativeTo: {\n            enums: [\n                'inner',\n                'include-padding'\n            ],\n            multiple: true\n        },\n        bgRepeat: {\n            enums: [\n                'repeat',\n                'repeat-x',\n                'repeat-y',\n                'no-repeat'\n            ],\n            multiple: true\n        },\n        bgFit: {\n            enums: [\n                'none',\n                'contain',\n                'cover'\n            ],\n            multiple: true\n        },\n        bgCrossOrigin: {\n            enums: [\n                'anonymous',\n                'use-credentials',\n                'null'\n            ],\n            multiple: true\n        },\n        bgClip: {\n            enums: [\n                'none',\n                'node'\n            ],\n            multiple: true\n        },\n        bgContainment: {\n            enums: [\n                'inside',\n                'over'\n            ],\n            multiple: true\n        },\n        boxSelection: {\n            enums: [\n                'contain',\n                'overlap',\n                'none'\n            ]\n        },\n        color: {\n            color: true\n        },\n        colors: {\n            color: true,\n            multiple: true\n        },\n        fill: {\n            enums: [\n                'solid',\n                'linear-gradient',\n                'radial-gradient'\n            ]\n        },\n        bool: {\n            enums: [\n                'yes',\n                'no'\n            ]\n        },\n        bools: {\n            enums: [\n                'yes',\n                'no'\n            ],\n            multiple: true\n        },\n        lineStyle: {\n            enums: [\n                'solid',\n                'dotted',\n                'dashed'\n            ]\n        },\n        lineCap: {\n            enums: [\n                'butt',\n                'round',\n                'square'\n            ]\n        },\n        linePosition: {\n            enums: [\n                'center',\n                'inside',\n                'outside'\n            ]\n        },\n        lineJoin: {\n            enums: [\n                'round',\n                'bevel',\n                'miter'\n            ]\n        },\n        borderStyle: {\n            enums: [\n                'solid',\n                'dotted',\n                'dashed',\n                'double'\n            ]\n        },\n        curveStyle: {\n            enums: [\n                'bezier',\n                'unbundled-bezier',\n                'haystack',\n                'segments',\n                'straight',\n                'straight-triangle',\n                'taxi',\n                'round-segments',\n                'round-taxi'\n            ]\n        },\n        radiusType: {\n            enums: [\n                'arc-radius',\n                'influence-radius'\n            ],\n            multiple: true\n        },\n        fontFamily: {\n            regex: '^([\\\\w- \\\\\"]+(?:\\\\s*,\\\\s*[\\\\w- \\\\\"]+)*)$'\n        },\n        fontStyle: {\n            enums: [\n                'italic',\n                'normal',\n                'oblique'\n            ]\n        },\n        fontWeight: {\n            enums: [\n                'normal',\n                'bold',\n                'bolder',\n                'lighter',\n                '100',\n                '200',\n                '300',\n                '400',\n                '500',\n                '600',\n                '800',\n                '900',\n                100,\n                200,\n                300,\n                400,\n                500,\n                600,\n                700,\n                800,\n                900\n            ]\n        },\n        textDecoration: {\n            enums: [\n                'none',\n                'underline',\n                'overline',\n                'line-through'\n            ]\n        },\n        textTransform: {\n            enums: [\n                'none',\n                'uppercase',\n                'lowercase'\n            ]\n        },\n        textWrap: {\n            enums: [\n                'none',\n                'wrap',\n                'ellipsis'\n            ]\n        },\n        textOverflowWrap: {\n            enums: [\n                'whitespace',\n                'anywhere'\n            ]\n        },\n        textBackgroundShape: {\n            enums: [\n                'rectangle',\n                'roundrectangle',\n                'round-rectangle',\n                'circle'\n            ]\n        },\n        nodeShape: {\n            enums: [\n                'rectangle',\n                'roundrectangle',\n                'round-rectangle',\n                'cutrectangle',\n                'cut-rectangle',\n                'bottomroundrectangle',\n                'bottom-round-rectangle',\n                'barrel',\n                'ellipse',\n                'triangle',\n                'round-triangle',\n                'square',\n                'pentagon',\n                'round-pentagon',\n                'hexagon',\n                'round-hexagon',\n                'concavehexagon',\n                'concave-hexagon',\n                'heptagon',\n                'round-heptagon',\n                'octagon',\n                'round-octagon',\n                'tag',\n                'round-tag',\n                'star',\n                'diamond',\n                'round-diamond',\n                'vee',\n                'rhomboid',\n                'right-rhomboid',\n                'polygon'\n            ]\n        },\n        overlayShape: {\n            enums: [\n                'roundrectangle',\n                'round-rectangle',\n                'ellipse'\n            ]\n        },\n        cornerRadius: {\n            number: true,\n            min: 0,\n            units: 'px|em',\n            implicitUnits: 'px',\n            enums: [\n                'auto'\n            ]\n        },\n        compoundIncludeLabels: {\n            enums: [\n                'include',\n                'exclude'\n            ]\n        },\n        arrowShape: {\n            enums: [\n                'tee',\n                'triangle',\n                'triangle-tee',\n                'circle-triangle',\n                'triangle-cross',\n                'triangle-backcurve',\n                'vee',\n                'square',\n                'circle',\n                'diamond',\n                'chevron',\n                'none'\n            ]\n        },\n        arrowFill: {\n            enums: [\n                'filled',\n                'hollow'\n            ]\n        },\n        arrowWidth: {\n            number: true,\n            units: '%|px|em',\n            implicitUnits: 'px',\n            enums: [\n                'match-line'\n            ]\n        },\n        display: {\n            enums: [\n                'element',\n                'none'\n            ]\n        },\n        visibility: {\n            enums: [\n                'hidden',\n                'visible'\n            ]\n        },\n        zCompoundDepth: {\n            enums: [\n                'bottom',\n                'orphan',\n                'auto',\n                'top'\n            ]\n        },\n        zIndexCompare: {\n            enums: [\n                'auto',\n                'manual'\n            ]\n        },\n        valign: {\n            enums: [\n                'top',\n                'center',\n                'bottom'\n            ]\n        },\n        halign: {\n            enums: [\n                'left',\n                'center',\n                'right'\n            ]\n        },\n        justification: {\n            enums: [\n                'left',\n                'center',\n                'right',\n                'auto'\n            ]\n        },\n        text: {\n            string: true\n        },\n        data: {\n            mapping: true,\n            regex: data('data')\n        },\n        layoutData: {\n            mapping: true,\n            regex: data('layoutData')\n        },\n        scratch: {\n            mapping: true,\n            regex: data('scratch')\n        },\n        mapData: {\n            mapping: true,\n            regex: mapData('mapData')\n        },\n        mapLayoutData: {\n            mapping: true,\n            regex: mapData('mapLayoutData')\n        },\n        mapScratch: {\n            mapping: true,\n            regex: mapData('mapScratch')\n        },\n        fn: {\n            mapping: true,\n            fn: true\n        },\n        url: {\n            regexes: urlRegexes,\n            singleRegexMatchValue: true\n        },\n        urls: {\n            regexes: urlRegexes,\n            singleRegexMatchValue: true,\n            multiple: true\n        },\n        propList: {\n            propList: true\n        },\n        angle: {\n            number: true,\n            units: 'deg|rad',\n            implicitUnits: 'rad'\n        },\n        textRotation: {\n            number: true,\n            units: 'deg|rad',\n            implicitUnits: 'rad',\n            enums: [\n                'none',\n                'autorotate'\n            ]\n        },\n        polygonPointList: {\n            number: true,\n            multiple: true,\n            evenMultiple: true,\n            min: -1,\n            max: 1,\n            unitless: true\n        },\n        edgeDistances: {\n            enums: [\n                'intersection',\n                'node-position',\n                'endpoints'\n            ]\n        },\n        edgeEndpoint: {\n            number: true,\n            multiple: true,\n            units: '%|px|em|deg|rad',\n            implicitUnits: 'px',\n            enums: [\n                'inside-to-node',\n                'outside-to-node',\n                'outside-to-node-or-label',\n                'outside-to-line',\n                'outside-to-line-or-label'\n            ],\n            singleEnum: true,\n            validate: function validate(valArr, unitsArr) {\n                switch(valArr.length){\n                    case 2:\n                        // can be % or px only\n                        return unitsArr[0] !== 'deg' && unitsArr[0] !== 'rad' && unitsArr[1] !== 'deg' && unitsArr[1] !== 'rad';\n                    case 1:\n                        // can be enum, deg, or rad only\n                        return string(valArr[0]) || unitsArr[0] === 'deg' || unitsArr[0] === 'rad';\n                    default:\n                        return false;\n                }\n            }\n        },\n        easing: {\n            regexes: [\n                '^(spring)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$',\n                '^(cubic-bezier)\\\\s*\\\\(\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*,\\\\s*(' + number$1 + ')\\\\s*\\\\)$'\n            ],\n            enums: [\n                'linear',\n                'ease',\n                'ease-in',\n                'ease-out',\n                'ease-in-out',\n                'ease-in-sine',\n                'ease-out-sine',\n                'ease-in-out-sine',\n                'ease-in-quad',\n                'ease-out-quad',\n                'ease-in-out-quad',\n                'ease-in-cubic',\n                'ease-out-cubic',\n                'ease-in-out-cubic',\n                'ease-in-quart',\n                'ease-out-quart',\n                'ease-in-out-quart',\n                'ease-in-quint',\n                'ease-out-quint',\n                'ease-in-out-quint',\n                'ease-in-expo',\n                'ease-out-expo',\n                'ease-in-out-expo',\n                'ease-in-circ',\n                'ease-out-circ',\n                'ease-in-out-circ'\n            ]\n        },\n        gradientDirection: {\n            enums: [\n                'to-bottom',\n                'to-top',\n                'to-left',\n                'to-right',\n                'to-bottom-right',\n                'to-bottom-left',\n                'to-top-right',\n                'to-top-left',\n                'to-right-bottom',\n                'to-left-bottom',\n                'to-right-top',\n                'to-left-top' // different order\n            ]\n        },\n        boundsExpansion: {\n            number: true,\n            multiple: true,\n            min: 0,\n            validate: function validate(valArr) {\n                var length = valArr.length;\n                return length === 1 || length === 2 || length === 4;\n            }\n        }\n    };\n    var diff = {\n        zeroNonZero: function zeroNonZero(val1, val2) {\n            if ((val1 == null || val2 == null) && val1 !== val2) {\n                return true; // null cases could represent any value\n            }\n            if (val1 == 0 && val2 != 0) {\n                return true;\n            } else if (val1 != 0 && val2 == 0) {\n                return true;\n            } else {\n                return false;\n            }\n        },\n        any: function any(val1, val2) {\n            return val1 != val2;\n        },\n        emptyNonEmpty: function emptyNonEmpty(str1, str2) {\n            var empty1 = emptyString(str1);\n            var empty2 = emptyString(str2);\n            return empty1 && !empty2 || !empty1 && empty2;\n        }\n    };\n    // define visual style properties\n    //\n    // - n.b. adding a new group of props may require updates to updateStyleHints()\n    // - adding new props to an existing group gets handled automatically\n    var t = styfn$2.types;\n    var mainLabel = [\n        {\n            name: 'label',\n            type: t.text,\n            triggersBounds: diff.any,\n            triggersZOrder: diff.emptyNonEmpty\n        },\n        {\n            name: 'text-rotation',\n            type: t.textRotation,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-margin-x',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-margin-y',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        }\n    ];\n    var sourceLabel = [\n        {\n            name: 'source-label',\n            type: t.text,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-text-rotation',\n            type: t.textRotation,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-text-margin-x',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-text-margin-y',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-text-offset',\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var targetLabel = [\n        {\n            name: 'target-label',\n            type: t.text,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-text-rotation',\n            type: t.textRotation,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-text-margin-x',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-text-margin-y',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-text-offset',\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var labelDimensions = [\n        {\n            name: 'font-family',\n            type: t.fontFamily,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'font-style',\n            type: t.fontStyle,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'font-weight',\n            type: t.fontWeight,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'font-size',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-transform',\n            type: t.textTransform,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-wrap',\n            type: t.textWrap,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-overflow-wrap',\n            type: t.textOverflowWrap,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-max-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-outline-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'line-height',\n            type: t.positiveNumber,\n            triggersBounds: diff.any\n        }\n    ];\n    var commonLabel = [\n        {\n            name: 'text-valign',\n            type: t.valign,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-halign',\n            type: t.halign,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'color',\n            type: t.color\n        },\n        {\n            name: 'text-outline-color',\n            type: t.color\n        },\n        {\n            name: 'text-outline-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'text-background-color',\n            type: t.color\n        },\n        {\n            name: 'text-background-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'text-background-padding',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-border-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'text-border-color',\n            type: t.color\n        },\n        {\n            name: 'text-border-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-border-style',\n            type: t.borderStyle,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-background-shape',\n            type: t.textBackgroundShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'text-justification',\n            type: t.justification\n        },\n        {\n            name: 'box-select-labels',\n            type: t.bool,\n            triggersBounds: diff.any\n        }\n    ];\n    var behavior = [\n        {\n            name: 'events',\n            type: t.bool,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'text-events',\n            type: t.bool,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'box-selection',\n            type: t.boxSelection,\n            triggersZOrder: diff.any\n        }\n    ];\n    var visibility = [\n        {\n            name: 'display',\n            type: t.display,\n            triggersZOrder: diff.any,\n            triggersBounds: diff.any,\n            triggersBoundsOfConnectedEdges: diff.any,\n            triggersBoundsOfParallelEdges: function triggersBoundsOfParallelEdges(fromValue, toValue, ele) {\n                if (fromValue === toValue) {\n                    return false;\n                }\n                // only if edge is bundled bezier (so as not to affect performance of other edges)\n                return ele.pstyle('curve-style').value === 'bezier';\n            }\n        },\n        {\n            name: 'visibility',\n            type: t.visibility,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'opacity',\n            type: t.zeroOneNumber,\n            triggersZOrder: diff.zeroNonZero\n        },\n        {\n            name: 'text-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'min-zoomed-font-size',\n            type: t.size\n        },\n        {\n            name: 'z-compound-depth',\n            type: t.zCompoundDepth,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'z-index-compare',\n            type: t.zIndexCompare,\n            triggersZOrder: diff.any\n        },\n        {\n            name: 'z-index',\n            type: t.number,\n            triggersZOrder: diff.any\n        }\n    ];\n    var overlay = [\n        {\n            name: 'overlay-padding',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'overlay-color',\n            type: t.color\n        },\n        {\n            name: 'overlay-opacity',\n            type: t.zeroOneNumber,\n            triggersBounds: diff.zeroNonZero\n        },\n        {\n            name: 'overlay-shape',\n            type: t.overlayShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'overlay-corner-radius',\n            type: t.cornerRadius\n        }\n    ];\n    var underlay = [\n        {\n            name: 'underlay-padding',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'underlay-color',\n            type: t.color\n        },\n        {\n            name: 'underlay-opacity',\n            type: t.zeroOneNumber,\n            triggersBounds: diff.zeroNonZero\n        },\n        {\n            name: 'underlay-shape',\n            type: t.overlayShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'underlay-corner-radius',\n            type: t.cornerRadius\n        }\n    ];\n    var transition = [\n        {\n            name: 'transition-property',\n            type: t.propList\n        },\n        {\n            name: 'transition-duration',\n            type: t.time\n        },\n        {\n            name: 'transition-delay',\n            type: t.time\n        },\n        {\n            name: 'transition-timing-function',\n            type: t.easing\n        }\n    ];\n    var nodeSizeHashOverride = function nodeSizeHashOverride(ele, parsedProp) {\n        if (parsedProp.value === 'label') {\n            return -ele.poolIndex(); // no hash key hits is using label size (hitrate for perf probably low anyway)\n        } else {\n            return parsedProp.pfValue;\n        }\n    };\n    var nodeBody = [\n        {\n            name: 'height',\n            type: t.nodeSize,\n            triggersBounds: diff.any,\n            hashOverride: nodeSizeHashOverride\n        },\n        {\n            name: 'width',\n            type: t.nodeSize,\n            triggersBounds: diff.any,\n            hashOverride: nodeSizeHashOverride\n        },\n        {\n            name: 'shape',\n            type: t.nodeShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'shape-polygon-points',\n            type: t.polygonPointList,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'corner-radius',\n            type: t.cornerRadius\n        },\n        {\n            name: 'background-color',\n            type: t.color\n        },\n        {\n            name: 'background-fill',\n            type: t.fill\n        },\n        {\n            name: 'background-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'background-blacken',\n            type: t.nOneOneNumber\n        },\n        {\n            name: 'background-gradient-stop-colors',\n            type: t.colors\n        },\n        {\n            name: 'background-gradient-stop-positions',\n            type: t.percentages\n        },\n        {\n            name: 'background-gradient-direction',\n            type: t.gradientDirection\n        },\n        {\n            name: 'padding',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'padding-relative-to',\n            type: t.paddingRelativeTo,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'bounds-expansion',\n            type: t.boundsExpansion,\n            triggersBounds: diff.any\n        }\n    ];\n    var nodeBorder = [\n        {\n            name: 'border-color',\n            type: t.color\n        },\n        {\n            name: 'border-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'border-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'border-style',\n            type: t.borderStyle\n        },\n        {\n            name: 'border-cap',\n            type: t.lineCap\n        },\n        {\n            name: 'border-join',\n            type: t.lineJoin\n        },\n        {\n            name: 'border-dash-pattern',\n            type: t.numbers\n        },\n        {\n            name: 'border-dash-offset',\n            type: t.number\n        },\n        {\n            name: 'border-position',\n            type: t.linePosition\n        }\n    ];\n    var nodeOutline = [\n        {\n            name: 'outline-color',\n            type: t.color\n        },\n        {\n            name: 'outline-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'outline-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'outline-style',\n            type: t.borderStyle\n        },\n        {\n            name: 'outline-offset',\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var backgroundImage = [\n        {\n            name: 'background-image',\n            type: t.urls\n        },\n        {\n            name: 'background-image-crossorigin',\n            type: t.bgCrossOrigin\n        },\n        {\n            name: 'background-image-opacity',\n            type: t.zeroOneNumbers\n        },\n        {\n            name: 'background-image-containment',\n            type: t.bgContainment\n        },\n        {\n            name: 'background-image-smoothing',\n            type: t.bools\n        },\n        {\n            name: 'background-position-x',\n            type: t.bgPos\n        },\n        {\n            name: 'background-position-y',\n            type: t.bgPos\n        },\n        {\n            name: 'background-width-relative-to',\n            type: t.bgRelativeTo\n        },\n        {\n            name: 'background-height-relative-to',\n            type: t.bgRelativeTo\n        },\n        {\n            name: 'background-repeat',\n            type: t.bgRepeat\n        },\n        {\n            name: 'background-fit',\n            type: t.bgFit\n        },\n        {\n            name: 'background-clip',\n            type: t.bgClip\n        },\n        {\n            name: 'background-width',\n            type: t.bgWH\n        },\n        {\n            name: 'background-height',\n            type: t.bgWH\n        },\n        {\n            name: 'background-offset-x',\n            type: t.bgPos\n        },\n        {\n            name: 'background-offset-y',\n            type: t.bgPos\n        }\n    ];\n    var compound = [\n        {\n            name: 'position',\n            type: t.position,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'compound-sizing-wrt-labels',\n            type: t.compoundIncludeLabels,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-width',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-width-bias-left',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-width-bias-right',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-height',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-height-bias-top',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'min-height-bias-bottom',\n            type: t.sizeMaybePercent,\n            triggersBounds: diff.any\n        }\n    ];\n    var edgeLine = [\n        {\n            name: 'line-style',\n            type: t.lineStyle\n        },\n        {\n            name: 'line-color',\n            type: t.color\n        },\n        {\n            name: 'line-fill',\n            type: t.fill\n        },\n        {\n            name: 'line-cap',\n            type: t.lineCap\n        },\n        {\n            name: 'line-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'line-dash-pattern',\n            type: t.numbers\n        },\n        {\n            name: 'line-dash-offset',\n            type: t.number\n        },\n        {\n            name: 'line-outline-width',\n            type: t.size\n        },\n        {\n            name: 'line-outline-color',\n            type: t.color\n        },\n        {\n            name: 'line-gradient-stop-colors',\n            type: t.colors\n        },\n        {\n            name: 'line-gradient-stop-positions',\n            type: t.percentages\n        },\n        {\n            name: 'curve-style',\n            type: t.curveStyle,\n            triggersBounds: diff.any,\n            triggersBoundsOfParallelEdges: function triggersBoundsOfParallelEdges(fromValue, toValue) {\n                if (fromValue === toValue) {\n                    return false;\n                } // must have diff\n                return fromValue === 'bezier' || // remove from bundle\n                toValue === 'bezier'; // add to bundle\n            }\n        },\n        {\n            name: 'haystack-radius',\n            type: t.zeroOneNumber,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-endpoint',\n            type: t.edgeEndpoint,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-endpoint',\n            type: t.edgeEndpoint,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'control-point-step-size',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'control-point-distances',\n            type: t.bidirectionalSizes,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'control-point-weights',\n            type: t.numbers,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'segment-distances',\n            type: t.bidirectionalSizes,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'segment-weights',\n            type: t.numbers,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'segment-radii',\n            type: t.numbers,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'radius-type',\n            type: t.radiusType,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'taxi-turn',\n            type: t.bidirectionalSizeMaybePercent,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'taxi-turn-min-distance',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'taxi-direction',\n            type: t.axisDirection,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'taxi-radius',\n            type: t.number,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'edge-distances',\n            type: t.edgeDistances,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'arrow-scale',\n            type: t.positiveNumber,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'loop-direction',\n            type: t.angle,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'loop-sweep',\n            type: t.angle,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'source-distance-from-node',\n            type: t.size,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'target-distance-from-node',\n            type: t.size,\n            triggersBounds: diff.any\n        }\n    ];\n    var ghost = [\n        {\n            name: 'ghost',\n            type: t.bool,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'ghost-offset-x',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'ghost-offset-y',\n            type: t.bidirectionalSize,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'ghost-opacity',\n            type: t.zeroOneNumber\n        }\n    ];\n    var core = [\n        {\n            name: 'selection-box-color',\n            type: t.color\n        },\n        {\n            name: 'selection-box-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'selection-box-border-color',\n            type: t.color\n        },\n        {\n            name: 'selection-box-border-width',\n            type: t.size\n        },\n        {\n            name: 'active-bg-color',\n            type: t.color\n        },\n        {\n            name: 'active-bg-opacity',\n            type: t.zeroOneNumber\n        },\n        {\n            name: 'active-bg-size',\n            type: t.size\n        },\n        {\n            name: 'outside-texture-bg-color',\n            type: t.color\n        },\n        {\n            name: 'outside-texture-bg-opacity',\n            type: t.zeroOneNumber\n        }\n    ];\n    // pie backgrounds for nodes\n    var pie = [];\n    styfn$2.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)\n    pie.push({\n        name: 'pie-size',\n        type: t.sizeMaybePercent\n    });\n    pie.push({\n        name: 'pie-hole',\n        type: t.sizeMaybePercent\n    });\n    pie.push({\n        name: 'pie-start-angle',\n        type: t.angle\n    });\n    for(var i = 1; i <= styfn$2.pieBackgroundN; i++){\n        pie.push({\n            name: 'pie-' + i + '-background-color',\n            type: t.color\n        });\n        pie.push({\n            name: 'pie-' + i + '-background-size',\n            type: t.percent\n        });\n        pie.push({\n            name: 'pie-' + i + '-background-opacity',\n            type: t.zeroOneNumber\n        });\n    }\n    // stripe backgrounds for nodes\n    var stripe = [];\n    styfn$2.stripeBackgroundN = 16; // because the stripe properties are numbered, give access to a constant N (for renderer use)\n    stripe.push({\n        name: 'stripe-size',\n        type: t.sizeMaybePercent\n    });\n    stripe.push({\n        name: 'stripe-direction',\n        type: t.axisDirectionPrimary\n    });\n    for(var _i = 1; _i <= styfn$2.stripeBackgroundN; _i++){\n        stripe.push({\n            name: 'stripe-' + _i + '-background-color',\n            type: t.color\n        });\n        stripe.push({\n            name: 'stripe-' + _i + '-background-size',\n            type: t.percent\n        });\n        stripe.push({\n            name: 'stripe-' + _i + '-background-opacity',\n            type: t.zeroOneNumber\n        });\n    }\n    // edge arrows\n    var edgeArrow = [];\n    var arrowPrefixes = styfn$2.arrowPrefixes = [\n        'source',\n        'mid-source',\n        'target',\n        'mid-target'\n    ];\n    [\n        {\n            name: 'arrow-shape',\n            type: t.arrowShape,\n            triggersBounds: diff.any\n        },\n        {\n            name: 'arrow-color',\n            type: t.color\n        },\n        {\n            name: 'arrow-fill',\n            type: t.arrowFill\n        },\n        {\n            name: 'arrow-width',\n            type: t.arrowWidth\n        }\n    ].forEach(function(prop) {\n        arrowPrefixes.forEach(function(prefix) {\n            var name = prefix + '-' + prop.name;\n            var type = prop.type, triggersBounds = prop.triggersBounds;\n            edgeArrow.push({\n                name: name,\n                type: type,\n                triggersBounds: triggersBounds\n            });\n        });\n    }, {});\n    var props = styfn$2.properties = [].concat(behavior, transition, visibility, overlay, underlay, ghost, commonLabel, labelDimensions, mainLabel, sourceLabel, targetLabel, nodeBody, nodeBorder, nodeOutline, backgroundImage, pie, stripe, compound, edgeLine, edgeArrow, core);\n    var propGroups = styfn$2.propertyGroups = {\n        // common to all eles\n        behavior: behavior,\n        transition: transition,\n        visibility: visibility,\n        overlay: overlay,\n        underlay: underlay,\n        ghost: ghost,\n        // labels\n        commonLabel: commonLabel,\n        labelDimensions: labelDimensions,\n        mainLabel: mainLabel,\n        sourceLabel: sourceLabel,\n        targetLabel: targetLabel,\n        // node props\n        nodeBody: nodeBody,\n        nodeBorder: nodeBorder,\n        nodeOutline: nodeOutline,\n        backgroundImage: backgroundImage,\n        pie: pie,\n        stripe: stripe,\n        compound: compound,\n        // edge props\n        edgeLine: edgeLine,\n        edgeArrow: edgeArrow,\n        core: core\n    };\n    var propGroupNames = styfn$2.propertyGroupNames = {};\n    var propGroupKeys = styfn$2.propertyGroupKeys = Object.keys(propGroups);\n    propGroupKeys.forEach(function(key) {\n        propGroupNames[key] = propGroups[key].map(function(prop) {\n            return prop.name;\n        });\n        propGroups[key].forEach(function(prop) {\n            return prop.groupKey = key;\n        });\n    });\n    // define aliases\n    var aliases = styfn$2.aliases = [\n        {\n            name: 'content',\n            pointsTo: 'label'\n        },\n        {\n            name: 'control-point-distance',\n            pointsTo: 'control-point-distances'\n        },\n        {\n            name: 'control-point-weight',\n            pointsTo: 'control-point-weights'\n        },\n        {\n            name: 'segment-distance',\n            pointsTo: 'segment-distances'\n        },\n        {\n            name: 'segment-weight',\n            pointsTo: 'segment-weights'\n        },\n        {\n            name: 'segment-radius',\n            pointsTo: 'segment-radii'\n        },\n        {\n            name: 'edge-text-rotation',\n            pointsTo: 'text-rotation'\n        },\n        {\n            name: 'padding-left',\n            pointsTo: 'padding'\n        },\n        {\n            name: 'padding-right',\n            pointsTo: 'padding'\n        },\n        {\n            name: 'padding-top',\n            pointsTo: 'padding'\n        },\n        {\n            name: 'padding-bottom',\n            pointsTo: 'padding'\n        }\n    ];\n    // list of property names\n    styfn$2.propertyNames = props.map(function(p) {\n        return p.name;\n    });\n    // allow access of properties by name ( e.g. style.properties.height )\n    for(var _i2 = 0; _i2 < props.length; _i2++){\n        var prop = props[_i2];\n        props[prop.name] = prop; // allow lookup by name\n    }\n    // map aliases\n    for(var _i3 = 0; _i3 < aliases.length; _i3++){\n        var alias = aliases[_i3];\n        var pointsToProp = props[alias.pointsTo];\n        var aliasProp = {\n            name: alias.name,\n            alias: true,\n            pointsTo: pointsToProp\n        };\n        // add alias prop for parsing\n        props.push(aliasProp);\n        props[alias.name] = aliasProp; // allow lookup by name\n    }\n})();\nstyfn$2.getDefaultProperty = function(name) {\n    return this.getDefaultProperties()[name];\n};\nstyfn$2.getDefaultProperties = function() {\n    var _p = this._private;\n    if (_p.defaultProperties != null) {\n        return _p.defaultProperties;\n    }\n    var rawProps = extend({\n        // core props\n        'selection-box-color': '#ddd',\n        'selection-box-opacity': 0.65,\n        'selection-box-border-color': '#aaa',\n        'selection-box-border-width': 1,\n        'active-bg-color': 'black',\n        'active-bg-opacity': 0.15,\n        'active-bg-size': 30,\n        'outside-texture-bg-color': '#000',\n        'outside-texture-bg-opacity': 0.125,\n        // common node/edge props\n        'events': 'yes',\n        'text-events': 'no',\n        'text-valign': 'top',\n        'text-halign': 'center',\n        'text-justification': 'auto',\n        'line-height': 1,\n        'color': '#000',\n        'box-selection': 'contain',\n        'text-outline-color': '#000',\n        'text-outline-width': 0,\n        'text-outline-opacity': 1,\n        'text-opacity': 1,\n        'text-decoration': 'none',\n        'text-transform': 'none',\n        'text-wrap': 'none',\n        'text-overflow-wrap': 'whitespace',\n        'text-max-width': 9999,\n        'text-background-color': '#000',\n        'text-background-opacity': 0,\n        'text-background-shape': 'rectangle',\n        'text-background-padding': 0,\n        'text-border-opacity': 0,\n        'text-border-width': 0,\n        'text-border-style': 'solid',\n        'text-border-color': '#000',\n        'font-family': 'Helvetica Neue, Helvetica, sans-serif',\n        'font-style': 'normal',\n        'font-weight': 'normal',\n        'font-size': 16,\n        'min-zoomed-font-size': 0,\n        'text-rotation': 'none',\n        'source-text-rotation': 'none',\n        'target-text-rotation': 'none',\n        'visibility': 'visible',\n        'display': 'element',\n        'opacity': 1,\n        'z-compound-depth': 'auto',\n        'z-index-compare': 'auto',\n        'z-index': 0,\n        'label': '',\n        'text-margin-x': 0,\n        'text-margin-y': 0,\n        'source-label': '',\n        'source-text-offset': 0,\n        'source-text-margin-x': 0,\n        'source-text-margin-y': 0,\n        'target-label': '',\n        'target-text-offset': 0,\n        'target-text-margin-x': 0,\n        'target-text-margin-y': 0,\n        'overlay-opacity': 0,\n        'overlay-color': '#000',\n        'overlay-padding': 10,\n        'overlay-shape': 'round-rectangle',\n        'overlay-corner-radius': 'auto',\n        'underlay-opacity': 0,\n        'underlay-color': '#000',\n        'underlay-padding': 10,\n        'underlay-shape': 'round-rectangle',\n        'underlay-corner-radius': 'auto',\n        'transition-property': 'none',\n        'transition-duration': 0,\n        'transition-delay': 0,\n        'transition-timing-function': 'linear',\n        'box-select-labels': 'no',\n        // node props\n        'background-blacken': 0,\n        'background-color': '#999',\n        'background-fill': 'solid',\n        'background-opacity': 1,\n        'background-image': 'none',\n        'background-image-crossorigin': 'anonymous',\n        'background-image-opacity': 1,\n        'background-image-containment': 'inside',\n        'background-image-smoothing': 'yes',\n        'background-position-x': '50%',\n        'background-position-y': '50%',\n        'background-offset-x': 0,\n        'background-offset-y': 0,\n        'background-width-relative-to': 'include-padding',\n        'background-height-relative-to': 'include-padding',\n        'background-repeat': 'no-repeat',\n        'background-fit': 'none',\n        'background-clip': 'node',\n        'background-width': 'auto',\n        'background-height': 'auto',\n        'border-color': '#000',\n        'border-opacity': 1,\n        'border-width': 0,\n        'border-style': 'solid',\n        'border-dash-pattern': [\n            4,\n            2\n        ],\n        'border-dash-offset': 0,\n        'border-cap': 'butt',\n        'border-join': 'miter',\n        'border-position': 'center',\n        'outline-color': '#999',\n        'outline-opacity': 1,\n        'outline-width': 0,\n        'outline-offset': 0,\n        'outline-style': 'solid',\n        'height': 30,\n        'width': 30,\n        'shape': 'ellipse',\n        'shape-polygon-points': '-1, -1,   1, -1,   1, 1,   -1, 1',\n        'corner-radius': 'auto',\n        'bounds-expansion': 0,\n        // node gradient\n        'background-gradient-direction': 'to-bottom',\n        'background-gradient-stop-colors': '#999',\n        'background-gradient-stop-positions': '0%',\n        // ghost props\n        'ghost': 'no',\n        'ghost-offset-y': 0,\n        'ghost-offset-x': 0,\n        'ghost-opacity': 0,\n        // compound props\n        'padding': 0,\n        'padding-relative-to': 'width',\n        'position': 'origin',\n        'compound-sizing-wrt-labels': 'include',\n        'min-width': 0,\n        'min-width-bias-left': 0,\n        'min-width-bias-right': 0,\n        'min-height': 0,\n        'min-height-bias-top': 0,\n        'min-height-bias-bottom': 0\n    }, {\n        // node pie bg\n        'pie-size': '100%',\n        'pie-hole': 0,\n        'pie-start-angle': '0deg'\n    }, [\n        {\n            name: 'pie-{{i}}-background-color',\n            value: 'black'\n        },\n        {\n            name: 'pie-{{i}}-background-size',\n            value: '0%'\n        },\n        {\n            name: 'pie-{{i}}-background-opacity',\n            value: 1\n        }\n    ].reduce(function(css, prop) {\n        for(var i = 1; i <= styfn$2.pieBackgroundN; i++){\n            var name = prop.name.replace('{{i}}', i);\n            var val = prop.value;\n            css[name] = val;\n        }\n        return css;\n    }, {}), {\n        // node stripes bg\n        'stripe-size': '100%',\n        'stripe-direction': 'horizontal'\n    }, [\n        {\n            name: 'stripe-{{i}}-background-color',\n            value: 'black'\n        },\n        {\n            name: 'stripe-{{i}}-background-size',\n            value: '0%'\n        },\n        {\n            name: 'stripe-{{i}}-background-opacity',\n            value: 1\n        }\n    ].reduce(function(css, prop) {\n        for(var i = 1; i <= styfn$2.stripeBackgroundN; i++){\n            var name = prop.name.replace('{{i}}', i);\n            var val = prop.value;\n            css[name] = val;\n        }\n        return css;\n    }, {}), {\n        // edge props\n        'line-style': 'solid',\n        'line-color': '#999',\n        'line-fill': 'solid',\n        'line-cap': 'butt',\n        'line-opacity': 1,\n        'line-outline-width': 0,\n        'line-outline-color': '#000',\n        'line-gradient-stop-colors': '#999',\n        'line-gradient-stop-positions': '0%',\n        'control-point-step-size': 40,\n        'control-point-weights': 0.5,\n        'segment-weights': 0.5,\n        'segment-distances': 20,\n        'segment-radii': 15,\n        'radius-type': 'arc-radius',\n        'taxi-turn': '50%',\n        'taxi-radius': 15,\n        'taxi-turn-min-distance': 10,\n        'taxi-direction': 'auto',\n        'edge-distances': 'intersection',\n        'curve-style': 'haystack',\n        'haystack-radius': 0,\n        'arrow-scale': 1,\n        'loop-direction': '-45deg',\n        'loop-sweep': '-90deg',\n        'source-distance-from-node': 0,\n        'target-distance-from-node': 0,\n        'source-endpoint': 'outside-to-node',\n        'target-endpoint': 'outside-to-node',\n        'line-dash-pattern': [\n            6,\n            3\n        ],\n        'line-dash-offset': 0\n    }, [\n        {\n            name: 'arrow-shape',\n            value: 'none'\n        },\n        {\n            name: 'arrow-color',\n            value: '#999'\n        },\n        {\n            name: 'arrow-fill',\n            value: 'filled'\n        },\n        {\n            name: 'arrow-width',\n            value: 1\n        }\n    ].reduce(function(css, prop) {\n        styfn$2.arrowPrefixes.forEach(function(prefix) {\n            var name = prefix + '-' + prop.name;\n            var val = prop.value;\n            css[name] = val;\n        });\n        return css;\n    }, {}));\n    var parsedProps = {};\n    for(var i = 0; i < this.properties.length; i++){\n        var prop = this.properties[i];\n        if (prop.pointsTo) {\n            continue;\n        }\n        var name = prop.name;\n        var val = rawProps[name];\n        var parsedProp = this.parse(name, val);\n        parsedProps[name] = parsedProp;\n    }\n    _p.defaultProperties = parsedProps;\n    return _p.defaultProperties;\n};\nstyfn$2.addDefaultStylesheet = function() {\n    this.selector(':parent').css({\n        'shape': 'rectangle',\n        'padding': 10,\n        'background-color': '#eee',\n        'border-color': '#ccc',\n        'border-width': 1\n    }).selector('edge').css({\n        'width': 3\n    }).selector(':loop').css({\n        'curve-style': 'bezier'\n    }).selector('edge:compound').css({\n        'curve-style': 'bezier',\n        'source-endpoint': 'outside-to-line',\n        'target-endpoint': 'outside-to-line'\n    }).selector(':selected').css({\n        'background-color': '#0169D9',\n        'line-color': '#0169D9',\n        'source-arrow-color': '#0169D9',\n        'target-arrow-color': '#0169D9',\n        'mid-source-arrow-color': '#0169D9',\n        'mid-target-arrow-color': '#0169D9'\n    }).selector(':parent:selected').css({\n        'background-color': '#CCE1F9',\n        'border-color': '#aec8e5'\n    }).selector(':active').css({\n        'overlay-color': 'black',\n        'overlay-padding': 10,\n        'overlay-opacity': 0.25\n    });\n    this.defaultLength = this.length;\n};\nvar styfn$1 = {};\n// a caching layer for property parsing\nstyfn$1.parse = function(name, value, propIsBypass, propIsFlat) {\n    var self1 = this;\n    // function values can't be cached in all cases, and there isn't much benefit of caching them anyway\n    if (fn$6(value)) {\n        return self1.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    }\n    var flatKey = propIsFlat === 'mapping' || propIsFlat === true || propIsFlat === false || propIsFlat == null ? 'dontcare' : propIsFlat;\n    var bypassKey = propIsBypass ? 't' : 'f';\n    var valueKey = '' + value;\n    var argHash = hashStrings(name, valueKey, bypassKey, flatKey);\n    var propCache = self1.propCache = self1.propCache || [];\n    var ret;\n    if (!(ret = propCache[argHash])) {\n        ret = propCache[argHash] = self1.parseImplWarn(name, value, propIsBypass, propIsFlat);\n    }\n    // - bypasses can't be shared b/c the value can be changed by animations or otherwise overridden\n    // - mappings can't be shared b/c mappings are per-element\n    if (propIsBypass || propIsFlat === 'mapping') {\n        // need a copy since props are mutated later in their lifecycles\n        ret = copy(ret);\n        if (ret) {\n            ret.value = copy(ret.value); // because it could be an array, e.g. colour\n        }\n    }\n    return ret;\n};\nstyfn$1.parseImplWarn = function(name, value, propIsBypass, propIsFlat) {\n    var prop = this.parseImpl(name, value, propIsBypass, propIsFlat);\n    if (!prop && value != null) {\n        warn(\"The style property `\".concat(name, \": \").concat(value, \"` is invalid\"));\n    }\n    if (prop && (prop.name === 'width' || prop.name === 'height') && value === 'label') {\n        warn('The style value of `label` is deprecated for `' + prop.name + '`');\n    }\n    return prop;\n};\n// parse a property; return null on invalid; return parsed property otherwise\n// fields :\n// - name : the name of the property\n// - value : the parsed, native-typed value of the property\n// - strValue : a string value that represents the property value in valid css\n// - bypass : true iff the property is a bypass property\nstyfn$1.parseImpl = function(name, value, propIsBypass, propIsFlat) {\n    var self1 = this;\n    name = camel2dash(name); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')\n    var property = self1.properties[name];\n    var passedValue = value;\n    var types = self1.types;\n    if (!property) {\n        return null;\n    } // return null on property of unknown name\n    if (value === undefined) {\n        return null;\n    } // can't assign undefined\n    // the property may be an alias\n    if (property.alias) {\n        property = property.pointsTo;\n        name = property.name;\n    }\n    var valueIsString = string(value);\n    if (valueIsString) {\n        // trim the value to make parsing easier\n        value = value.trim();\n    }\n    var type = property.type;\n    if (!type) {\n        return null;\n    } // no type, no luck\n    // check if bypass is null or empty string (i.e. indication to delete bypass property)\n    if (propIsBypass && (value === '' || value === null)) {\n        return {\n            name: name,\n            value: value,\n            bypass: true,\n            deleteBypass: true\n        };\n    }\n    // check if value is a function used as a mapper\n    if (fn$6(value)) {\n        return {\n            name: name,\n            value: value,\n            strValue: 'fn',\n            mapped: types.fn,\n            bypass: propIsBypass\n        };\n    }\n    // check if value is mapped\n    var data, mapData;\n    if (!valueIsString || propIsFlat || value.length < 7 || value[1] !== 'a') ;\n    else if (value.length >= 7 && value[0] === 'd' && (data = new RegExp(types.data.regex).exec(value))) {\n        if (propIsBypass) {\n            return false;\n        } // mappers not allowed in bypass\n        var mapped = types.data;\n        return {\n            name: name,\n            value: data,\n            strValue: '' + value,\n            mapped: mapped,\n            field: data[1],\n            bypass: propIsBypass\n        };\n    } else if (value.length >= 10 && value[0] === 'm' && (mapData = new RegExp(types.mapData.regex).exec(value))) {\n        if (propIsBypass) {\n            return false;\n        } // mappers not allowed in bypass\n        if (type.multiple) {\n            return false;\n        } // impossible to map to num\n        var _mapped = types.mapData;\n        // we can map only if the type is a colour or a number\n        if (!(type.color || type.number)) {\n            return false;\n        }\n        var valueMin = this.parse(name, mapData[4]); // parse to validate\n        if (!valueMin || valueMin.mapped) {\n            return false;\n        } // can't be invalid or mapped\n        var valueMax = this.parse(name, mapData[5]); // parse to validate\n        if (!valueMax || valueMax.mapped) {\n            return false;\n        } // can't be invalid or mapped\n        // check if valueMin and valueMax are the same\n        if (valueMin.pfValue === valueMax.pfValue || valueMin.strValue === valueMax.strValue) {\n            warn('`' + name + ': ' + value + '` is not a valid mapper because the output range is zero; converting to `' + name + ': ' + valueMin.strValue + '`');\n            return this.parse(name, valueMin.strValue); // can't make much of a mapper without a range\n        } else if (type.color) {\n            var c1 = valueMin.value;\n            var c2 = valueMax.value;\n            var same = c1[0] === c2[0] // red\n             && c1[1] === c2[1] // green\n             && c1[2] === c2[2] // blue\n             && // optional alpha\n            (c1[3] === c2[3] // same alpha outright\n             || (c1[3] == null || c1[3] === 1 // full opacity for colour 1?\n            ) && (c2[3] == null || c2[3] === 1 // full opacity for colour 2?\n            ));\n            if (same) {\n                return false;\n            } // can't make a mapper without a range\n        }\n        return {\n            name: name,\n            value: mapData,\n            strValue: '' + value,\n            mapped: _mapped,\n            field: mapData[1],\n            fieldMin: parseFloat(mapData[2]),\n            // min & max are numeric\n            fieldMax: parseFloat(mapData[3]),\n            valueMin: valueMin.value,\n            valueMax: valueMax.value,\n            bypass: propIsBypass\n        };\n    }\n    if (type.multiple && propIsFlat !== 'multiple') {\n        var vals;\n        if (valueIsString) {\n            vals = value.split(/\\s+/);\n        } else if (array(value)) {\n            vals = value;\n        } else {\n            vals = [\n                value\n            ];\n        }\n        if (type.evenMultiple && vals.length % 2 !== 0) {\n            return null;\n        }\n        var valArr = [];\n        var unitsArr = [];\n        var pfValArr = [];\n        var strVal = '';\n        var hasEnum = false;\n        for(var i = 0; i < vals.length; i++){\n            var p = self1.parse(name, vals[i], propIsBypass, 'multiple');\n            hasEnum = hasEnum || string(p.value);\n            valArr.push(p.value);\n            pfValArr.push(p.pfValue != null ? p.pfValue : p.value);\n            unitsArr.push(p.units);\n            strVal += (i > 0 ? ' ' : '') + p.strValue;\n        }\n        if (type.validate && !type.validate(valArr, unitsArr)) {\n            return null;\n        }\n        if (type.singleEnum && hasEnum) {\n            if (valArr.length === 1 && string(valArr[0])) {\n                return {\n                    name: name,\n                    value: valArr[0],\n                    strValue: valArr[0],\n                    bypass: propIsBypass\n                };\n            } else {\n                return null;\n            }\n        }\n        return {\n            name: name,\n            value: valArr,\n            pfValue: pfValArr,\n            strValue: strVal,\n            bypass: propIsBypass,\n            units: unitsArr\n        };\n    }\n    // several types also allow enums\n    var checkEnums = function checkEnums() {\n        for(var _i = 0; _i < type.enums.length; _i++){\n            var en = type.enums[_i];\n            if (en === value) {\n                return {\n                    name: name,\n                    value: value,\n                    strValue: '' + value,\n                    bypass: propIsBypass\n                };\n            }\n        }\n        return null;\n    };\n    // check the type and return the appropriate object\n    if (type.number) {\n        var units;\n        var implicitUnits = 'px'; // not set => px\n        if (type.units) {\n            // use specified units if set\n            units = type.units;\n        }\n        if (type.implicitUnits) {\n            implicitUnits = type.implicitUnits;\n        }\n        if (!type.unitless) {\n            if (valueIsString) {\n                var unitsRegex = 'px|em' + (type.allowPercent ? '|\\\\%' : '');\n                if (units) {\n                    unitsRegex = units;\n                } // only allow explicit units if so set\n                var match = value.match('^(' + number + ')(' + unitsRegex + ')?' + '$');\n                if (match) {\n                    value = match[1];\n                    units = match[2] || implicitUnits;\n                }\n            } else if (!units || type.implicitUnits) {\n                units = implicitUnits; // implicitly px if unspecified\n            }\n        }\n        value = parseFloat(value);\n        // if not a number and enums not allowed, then the value is invalid\n        if (isNaN(value) && type.enums === undefined) {\n            return null;\n        }\n        // check if this number type also accepts special keywords in place of numbers\n        // (i.e. `left`, `auto`, etc)\n        if (isNaN(value) && type.enums !== undefined) {\n            value = passedValue;\n            return checkEnums();\n        }\n        // check if value must be an integer\n        if (type.integer && !integer(value)) {\n            return null;\n        }\n        // check value is within range\n        if (type.min !== undefined && (value < type.min || type.strictMin && value === type.min) || type.max !== undefined && (value > type.max || type.strictMax && value === type.max)) {\n            return null;\n        }\n        var ret = {\n            name: name,\n            value: value,\n            strValue: '' + value + (units ? units : ''),\n            units: units,\n            bypass: propIsBypass\n        };\n        // normalise value in pixels\n        if (type.unitless || units !== 'px' && units !== 'em') {\n            ret.pfValue = value;\n        } else {\n            ret.pfValue = units === 'px' || !units ? value : this.getEmSizeInPixels() * value;\n        }\n        // normalise value in ms\n        if (units === 'ms' || units === 's') {\n            ret.pfValue = units === 'ms' ? value : 1000 * value;\n        }\n        // normalise value in rad\n        if (units === 'deg' || units === 'rad') {\n            ret.pfValue = units === 'rad' ? value : deg2rad(value);\n        }\n        // normalize value in %\n        if (units === '%') {\n            ret.pfValue = value / 100;\n        }\n        return ret;\n    } else if (type.propList) {\n        var props = [];\n        var propsStr = '' + value;\n        if (propsStr === 'none') ;\n        else {\n            // go over each prop\n            var propsSplit = propsStr.split(/\\s*,\\s*|\\s+/);\n            for(var _i2 = 0; _i2 < propsSplit.length; _i2++){\n                var propName = propsSplit[_i2].trim();\n                if (self1.properties[propName]) {\n                    props.push(propName);\n                } else {\n                    warn('`' + propName + '` is not a valid property name');\n                }\n            }\n            if (props.length === 0) {\n                return null;\n            }\n        }\n        return {\n            name: name,\n            value: props,\n            strValue: props.length === 0 ? 'none' : props.join(' '),\n            bypass: propIsBypass\n        };\n    } else if (type.color) {\n        var tuple = color2tuple(value);\n        if (!tuple) {\n            return null;\n        }\n        return {\n            name: name,\n            value: tuple,\n            pfValue: tuple,\n            strValue: 'rgb(' + tuple[0] + ',' + tuple[1] + ',' + tuple[2] + ')',\n            // n.b. no spaces b/c of multiple support\n            bypass: propIsBypass\n        };\n    } else if (type.regex || type.regexes) {\n        // first check enums\n        if (type.enums) {\n            var enumProp = checkEnums();\n            if (enumProp) {\n                return enumProp;\n            }\n        }\n        var regexes = type.regexes ? type.regexes : [\n            type.regex\n        ];\n        for(var _i3 = 0; _i3 < regexes.length; _i3++){\n            var regex = new RegExp(regexes[_i3]); // make a regex from the type string\n            var m1 = regex.exec(value);\n            if (m1) {\n                // regex matches\n                return {\n                    name: name,\n                    value: type.singleRegexMatchValue ? m1[1] : m1,\n                    strValue: '' + value,\n                    bypass: propIsBypass\n                };\n            }\n        }\n        return null; // didn't match any\n    } else if (type.string) {\n        // just return\n        return {\n            name: name,\n            value: '' + value,\n            strValue: '' + value,\n            bypass: propIsBypass\n        };\n    } else if (type.enums) {\n        // check enums last because it's a combo type in others\n        return checkEnums();\n    } else {\n        return null; // not a type we can handle\n    }\n};\nvar _Style = function Style(cy) {\n    if (!(this instanceof _Style)) {\n        return new _Style(cy);\n    }\n    if (!core(cy)) {\n        error('A style must have a core reference');\n        return;\n    }\n    this._private = {\n        cy: cy,\n        coreStyle: {}\n    };\n    this.length = 0;\n    this.resetToDefault();\n};\nvar styfn = _Style.prototype;\nstyfn.instanceString = function() {\n    return 'style';\n};\n// remove all contexts\nstyfn.clear = function() {\n    var _p = this._private;\n    var cy = _p.cy;\n    var eles = cy.elements();\n    for(var i = 0; i < this.length; i++){\n        this[i] = undefined;\n    }\n    this.length = 0;\n    _p.contextStyles = {};\n    _p.propDiffs = {};\n    this.cleanElements(eles, true);\n    eles.forEach(function(ele) {\n        var ele_p = ele[0]._private;\n        ele_p.styleDirty = true;\n        ele_p.appliedInitStyle = false;\n    });\n    return this; // chaining\n};\nstyfn.resetToDefault = function() {\n    this.clear();\n    this.addDefaultStylesheet();\n    return this;\n};\n// builds a style object for the 'core' selector\nstyfn.core = function(propName) {\n    return this._private.coreStyle[propName] || this.getDefaultProperty(propName);\n};\n// create a new context from the specified selector string and switch to that context\nstyfn.selector = function(selectorStr) {\n    // 'core' is a special case and does not need a selector\n    var selector = selectorStr === 'core' ? null : new Selector(selectorStr);\n    var i = this.length++; // new context means new index\n    this[i] = {\n        selector: selector,\n        properties: [],\n        mappedProperties: [],\n        index: i\n    };\n    return this; // chaining\n};\n// add one or many css rules to the current context\nstyfn.css = function() {\n    var self1 = this;\n    var args = arguments;\n    if (args.length === 1) {\n        var map = args[0];\n        for(var i = 0; i < self1.properties.length; i++){\n            var prop = self1.properties[i];\n            var mapVal = map[prop.name];\n            if (mapVal === undefined) {\n                mapVal = map[dash2camel(prop.name)];\n            }\n            if (mapVal !== undefined) {\n                this.cssRule(prop.name, mapVal);\n            }\n        }\n    } else if (args.length === 2) {\n        this.cssRule(args[0], args[1]);\n    }\n    // do nothing if args are invalid\n    return this; // chaining\n};\nstyfn.style = styfn.css;\n// add a single css rule to the current context\nstyfn.cssRule = function(name, value) {\n    // name-value pair\n    var property = this.parse(name, value);\n    // add property to current context if valid\n    if (property) {\n        var i = this.length - 1;\n        this[i].properties.push(property);\n        this[i].properties[property.name] = property; // allow access by name as well\n        if (property.name.match(/pie-(\\d+)-background-size/) && property.value) {\n            this._private.hasPie = true;\n        }\n        if (property.name.match(/stripe-(\\d+)-background-size/) && property.value) {\n            this._private.hasStripe = true;\n        }\n        if (property.mapped) {\n            this[i].mappedProperties.push(property);\n        }\n        // add to core style if necessary\n        var currentSelectorIsCore = !this[i].selector;\n        if (currentSelectorIsCore) {\n            this._private.coreStyle[property.name] = property;\n        }\n    }\n    return this; // chaining\n};\nstyfn.append = function(style) {\n    if (stylesheet(style)) {\n        style.appendToStyle(this);\n    } else if (array(style)) {\n        this.appendFromJson(style);\n    } else if (string(style)) {\n        this.appendFromString(style);\n    } // you probably wouldn't want to append a Style, since you'd duplicate the default parts\n    return this;\n};\n// static function\n_Style.fromJson = function(cy, json) {\n    var style = new _Style(cy);\n    style.fromJson(json);\n    return style;\n};\n_Style.fromString = function(cy, string) {\n    return new _Style(cy).fromString(string);\n};\n[\n    styfn$8,\n    styfn$7,\n    styfn$6,\n    styfn$5,\n    styfn$4,\n    styfn$3,\n    styfn$2,\n    styfn$1\n].forEach(function(props) {\n    extend(styfn, props);\n});\n_Style.types = styfn.types;\n_Style.properties = styfn.properties;\n_Style.propertyGroups = styfn.propertyGroups;\n_Style.propertyGroupNames = styfn.propertyGroupNames;\n_Style.propertyGroupKeys = styfn.propertyGroupKeys;\nvar corefn$2 = {\n    style: function style(newStyle) {\n        if (newStyle) {\n            var s = this.setStyle(newStyle);\n            s.update();\n        }\n        return this._private.style;\n    },\n    setStyle: function setStyle(style) {\n        var _p = this._private;\n        if (stylesheet(style)) {\n            _p.style = style.generateStyle(this);\n        } else if (array(style)) {\n            _p.style = _Style.fromJson(this, style);\n        } else if (string(style)) {\n            _p.style = _Style.fromString(this, style);\n        } else {\n            _p.style = _Style(this);\n        }\n        return _p.style;\n    },\n    // e.g. cy.data() changed => recalc ele mappers\n    updateStyle: function updateStyle() {\n        this.mutableElements().updateStyle(); // just send to all eles\n    }\n};\nvar defaultSelectionType = 'single';\nvar corefn$1 = {\n    autolock: function autolock(bool) {\n        if (bool !== undefined) {\n            this._private.autolock = bool ? true : false;\n        } else {\n            return this._private.autolock;\n        }\n        return this; // chaining\n    },\n    autoungrabify: function autoungrabify(bool) {\n        if (bool !== undefined) {\n            this._private.autoungrabify = bool ? true : false;\n        } else {\n            return this._private.autoungrabify;\n        }\n        return this; // chaining\n    },\n    autounselectify: function autounselectify(bool) {\n        if (bool !== undefined) {\n            this._private.autounselectify = bool ? true : false;\n        } else {\n            return this._private.autounselectify;\n        }\n        return this; // chaining\n    },\n    selectionType: function selectionType(selType) {\n        var _p = this._private;\n        if (_p.selectionType == null) {\n            _p.selectionType = defaultSelectionType;\n        }\n        if (selType !== undefined) {\n            if (selType === 'additive' || selType === 'single') {\n                _p.selectionType = selType;\n            }\n        } else {\n            return _p.selectionType;\n        }\n        return this;\n    },\n    panningEnabled: function panningEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.panningEnabled = bool ? true : false;\n        } else {\n            return this._private.panningEnabled;\n        }\n        return this; // chaining\n    },\n    userPanningEnabled: function userPanningEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.userPanningEnabled = bool ? true : false;\n        } else {\n            return this._private.userPanningEnabled;\n        }\n        return this; // chaining\n    },\n    zoomingEnabled: function zoomingEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.zoomingEnabled = bool ? true : false;\n        } else {\n            return this._private.zoomingEnabled;\n        }\n        return this; // chaining\n    },\n    userZoomingEnabled: function userZoomingEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.userZoomingEnabled = bool ? true : false;\n        } else {\n            return this._private.userZoomingEnabled;\n        }\n        return this; // chaining\n    },\n    boxSelectionEnabled: function boxSelectionEnabled(bool) {\n        if (bool !== undefined) {\n            this._private.boxSelectionEnabled = bool ? true : false;\n        } else {\n            return this._private.boxSelectionEnabled;\n        }\n        return this; // chaining\n    },\n    pan: function pan() {\n        var args = arguments;\n        var pan = this._private.pan;\n        var dim, val, dims, x, y;\n        switch(args.length){\n            case 0:\n                // .pan()\n                return pan;\n            case 1:\n                if (string(args[0])) {\n                    // .pan('x')\n                    dim = args[0];\n                    return pan[dim];\n                } else if (plainObject(args[0])) {\n                    // .pan({ x: 0, y: 100 })\n                    if (!this._private.panningEnabled) {\n                        return this;\n                    }\n                    dims = args[0];\n                    x = dims.x;\n                    y = dims.y;\n                    if (number$1(x)) {\n                        pan.x = x;\n                    }\n                    if (number$1(y)) {\n                        pan.y = y;\n                    }\n                    this.emit('pan viewport');\n                }\n                break;\n            case 2:\n                // .pan('x', 100)\n                if (!this._private.panningEnabled) {\n                    return this;\n                }\n                dim = args[0];\n                val = args[1];\n                if ((dim === 'x' || dim === 'y') && number$1(val)) {\n                    pan[dim] = val;\n                }\n                this.emit('pan viewport');\n                break;\n        }\n        this.notify('viewport');\n        return this; // chaining\n    },\n    panBy: function panBy(arg0, arg1) {\n        var args = arguments;\n        var pan = this._private.pan;\n        var dim, val, dims, x, y;\n        if (!this._private.panningEnabled) {\n            return this;\n        }\n        switch(args.length){\n            case 1:\n                if (plainObject(arg0)) {\n                    // .panBy({ x: 0, y: 100 })\n                    dims = args[0];\n                    x = dims.x;\n                    y = dims.y;\n                    if (number$1(x)) {\n                        pan.x += x;\n                    }\n                    if (number$1(y)) {\n                        pan.y += y;\n                    }\n                    this.emit('pan viewport');\n                }\n                break;\n            case 2:\n                // .panBy('x', 100)\n                dim = arg0;\n                val = arg1;\n                if ((dim === 'x' || dim === 'y') && number$1(val)) {\n                    pan[dim] += val;\n                }\n                this.emit('pan viewport');\n                break;\n        }\n        this.notify('viewport');\n        return this; // chaining\n    },\n    gc: function gc() {\n        this.notify('gc');\n    },\n    fit: function fit(elements, padding) {\n        var viewportState = this.getFitViewport(elements, padding);\n        if (viewportState) {\n            var _p = this._private;\n            _p.zoom = viewportState.zoom;\n            _p.pan = viewportState.pan;\n            this.emit('pan zoom viewport');\n            this.notify('viewport');\n        }\n        return this; // chaining\n    },\n    getFitViewport: function getFitViewport(elements, padding) {\n        if (number$1(elements) && padding === undefined) {\n            // elements is optional\n            padding = elements;\n            elements = undefined;\n        }\n        if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n            return;\n        }\n        var bb;\n        if (string(elements)) {\n            var sel = elements;\n            elements = this.$(sel);\n        } else if (boundingBox(elements)) {\n            // assume bb\n            var bbe = elements;\n            bb = {\n                x1: bbe.x1,\n                y1: bbe.y1,\n                x2: bbe.x2,\n                y2: bbe.y2\n            };\n            bb.w = bb.x2 - bb.x1;\n            bb.h = bb.y2 - bb.y1;\n        } else if (!elementOrCollection(elements)) {\n            elements = this.mutableElements();\n        }\n        if (elementOrCollection(elements) && elements.empty()) {\n            return;\n        } // can't fit to nothing\n        bb = bb || elements.boundingBox();\n        var w = this.width();\n        var h = this.height();\n        var zoom;\n        padding = number$1(padding) ? padding : 0;\n        if (!isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) && bb.w > 0 && bb.h > 0) {\n            zoom = Math.min((w - 2 * padding) / bb.w, (h - 2 * padding) / bb.h);\n            // crop zoom\n            zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;\n            zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;\n            var pan = {\n                // now pan to middle\n                x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n                y: (h - zoom * (bb.y1 + bb.y2)) / 2\n            };\n            return {\n                zoom: zoom,\n                pan: pan\n            };\n        }\n        return;\n    },\n    zoomRange: function zoomRange(min, max) {\n        var _p = this._private;\n        if (max == null) {\n            var opts = min;\n            min = opts.min;\n            max = opts.max;\n        }\n        if (number$1(min) && number$1(max) && min <= max) {\n            _p.minZoom = min;\n            _p.maxZoom = max;\n        } else if (number$1(min) && max === undefined && min <= _p.maxZoom) {\n            _p.minZoom = min;\n        } else if (number$1(max) && min === undefined && max >= _p.minZoom) {\n            _p.maxZoom = max;\n        }\n        return this;\n    },\n    minZoom: function minZoom(zoom) {\n        if (zoom === undefined) {\n            return this._private.minZoom;\n        } else {\n            return this.zoomRange({\n                min: zoom\n            });\n        }\n    },\n    maxZoom: function maxZoom(zoom) {\n        if (zoom === undefined) {\n            return this._private.maxZoom;\n        } else {\n            return this.zoomRange({\n                max: zoom\n            });\n        }\n    },\n    getZoomedViewport: function getZoomedViewport(params) {\n        var _p = this._private;\n        var currentPan = _p.pan;\n        var currentZoom = _p.zoom;\n        var pos; // in rendered px\n        var zoom;\n        var bail = false;\n        if (!_p.zoomingEnabled) {\n            // zooming disabled\n            bail = true;\n        }\n        if (number$1(params)) {\n            // then set the zoom\n            zoom = params;\n        } else if (plainObject(params)) {\n            // then zoom about a point\n            zoom = params.level;\n            if (params.position != null) {\n                pos = modelToRenderedPosition$1(params.position, currentZoom, currentPan);\n            } else if (params.renderedPosition != null) {\n                pos = params.renderedPosition;\n            }\n            if (pos != null && !_p.panningEnabled) {\n                // panning disabled\n                bail = true;\n            }\n        }\n        // crop zoom\n        zoom = zoom > _p.maxZoom ? _p.maxZoom : zoom;\n        zoom = zoom < _p.minZoom ? _p.minZoom : zoom;\n        // can't zoom with invalid params\n        if (bail || !number$1(zoom) || zoom === currentZoom || pos != null && (!number$1(pos.x) || !number$1(pos.y))) {\n            return null;\n        }\n        if (pos != null) {\n            // set zoom about position\n            var pan1 = currentPan;\n            var zoom1 = currentZoom;\n            var zoom2 = zoom;\n            var pan2 = {\n                x: -zoom2 / zoom1 * (pos.x - pan1.x) + pos.x,\n                y: -zoom2 / zoom1 * (pos.y - pan1.y) + pos.y\n            };\n            return {\n                zoomed: true,\n                panned: true,\n                zoom: zoom2,\n                pan: pan2\n            };\n        } else {\n            // just set the zoom\n            return {\n                zoomed: true,\n                panned: false,\n                zoom: zoom,\n                pan: currentPan\n            };\n        }\n    },\n    zoom: function zoom(params) {\n        if (params === undefined) {\n            // get\n            return this._private.zoom;\n        } else {\n            // set\n            var vp = this.getZoomedViewport(params);\n            var _p = this._private;\n            if (vp == null || !vp.zoomed) {\n                return this;\n            }\n            _p.zoom = vp.zoom;\n            if (vp.panned) {\n                _p.pan.x = vp.pan.x;\n                _p.pan.y = vp.pan.y;\n            }\n            this.emit('zoom' + (vp.panned ? ' pan' : '') + ' viewport');\n            this.notify('viewport');\n            return this; // chaining\n        }\n    },\n    viewport: function viewport(opts) {\n        var _p = this._private;\n        var zoomDefd = true;\n        var panDefd = true;\n        var events = []; // to trigger\n        var zoomFailed = false;\n        var panFailed = false;\n        if (!opts) {\n            return this;\n        }\n        if (!number$1(opts.zoom)) {\n            zoomDefd = false;\n        }\n        if (!plainObject(opts.pan)) {\n            panDefd = false;\n        }\n        if (!zoomDefd && !panDefd) {\n            return this;\n        }\n        if (zoomDefd) {\n            var z = opts.zoom;\n            if (z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled) {\n                zoomFailed = true;\n            } else {\n                _p.zoom = z;\n                events.push('zoom');\n            }\n        }\n        if (panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled) {\n            var p = opts.pan;\n            if (number$1(p.x)) {\n                _p.pan.x = p.x;\n                panFailed = false;\n            }\n            if (number$1(p.y)) {\n                _p.pan.y = p.y;\n                panFailed = false;\n            }\n            if (!panFailed) {\n                events.push('pan');\n            }\n        }\n        if (events.length > 0) {\n            events.push('viewport');\n            this.emit(events.join(' '));\n            this.notify('viewport');\n        }\n        return this; // chaining\n    },\n    center: function center(elements) {\n        var pan = this.getCenterPan(elements);\n        if (pan) {\n            this._private.pan = pan;\n            this.emit('pan viewport');\n            this.notify('viewport');\n        }\n        return this; // chaining\n    },\n    getCenterPan: function getCenterPan(elements, zoom) {\n        if (!this._private.panningEnabled) {\n            return;\n        }\n        if (string(elements)) {\n            var selector = elements;\n            elements = this.mutableElements().filter(selector);\n        } else if (!elementOrCollection(elements)) {\n            elements = this.mutableElements();\n        }\n        if (elements.length === 0) {\n            return;\n        } // can't centre pan to nothing\n        var bb = elements.boundingBox();\n        var w = this.width();\n        var h = this.height();\n        zoom = zoom === undefined ? this._private.zoom : zoom;\n        var pan = {\n            // middle\n            x: (w - zoom * (bb.x1 + bb.x2)) / 2,\n            y: (h - zoom * (bb.y1 + bb.y2)) / 2\n        };\n        return pan;\n    },\n    reset: function reset() {\n        if (!this._private.panningEnabled || !this._private.zoomingEnabled) {\n            return this;\n        }\n        this.viewport({\n            pan: {\n                x: 0,\n                y: 0\n            },\n            zoom: 1\n        });\n        return this; // chaining\n    },\n    invalidateSize: function invalidateSize() {\n        this._private.sizeCache = null;\n    },\n    size: function size() {\n        var _p = this._private;\n        var container = _p.container;\n        var cy = this;\n        return _p.sizeCache = _p.sizeCache || (container ? function() {\n            var style = cy.window().getComputedStyle(container);\n            var val = function val(name) {\n                return parseFloat(style.getPropertyValue(name));\n            };\n            return {\n                width: container.clientWidth - val('padding-left') - val('padding-right'),\n                height: container.clientHeight - val('padding-top') - val('padding-bottom')\n            };\n        }() : {\n            // fallback if no container (not 0 b/c can be used for dividing etc)\n            width: 1,\n            height: 1\n        });\n    },\n    width: function width() {\n        return this.size().width;\n    },\n    height: function height() {\n        return this.size().height;\n    },\n    extent: function extent() {\n        var pan = this._private.pan;\n        var zoom = this._private.zoom;\n        var rb = this.renderedExtent();\n        var b = {\n            x1: (rb.x1 - pan.x) / zoom,\n            x2: (rb.x2 - pan.x) / zoom,\n            y1: (rb.y1 - pan.y) / zoom,\n            y2: (rb.y2 - pan.y) / zoom\n        };\n        b.w = b.x2 - b.x1;\n        b.h = b.y2 - b.y1;\n        return b;\n    },\n    renderedExtent: function renderedExtent() {\n        var width = this.width();\n        var height = this.height();\n        return {\n            x1: 0,\n            y1: 0,\n            x2: width,\n            y2: height,\n            w: width,\n            h: height\n        };\n    },\n    multiClickDebounceTime: function multiClickDebounceTime(_int) {\n        if (_int) this._private.multiClickDebounceTime = _int;\n        else return this._private.multiClickDebounceTime;\n        return this; // chaining\n    }\n};\n// aliases\ncorefn$1.centre = corefn$1.center;\n// backwards compatibility\ncorefn$1.autolockNodes = corefn$1.autolock;\ncorefn$1.autoungrabifyNodes = corefn$1.autoungrabify;\nvar fn = {\n    data: define.data({\n        field: 'data',\n        bindingEvent: 'data',\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: 'data',\n        settingTriggersEvent: true,\n        triggerFnName: 'trigger',\n        allowGetting: true,\n        updateStyle: true\n    }),\n    removeData: define.removeData({\n        field: 'data',\n        event: 'data',\n        triggerFnName: 'trigger',\n        triggerEvent: true,\n        updateStyle: true\n    }),\n    scratch: define.data({\n        field: 'scratch',\n        bindingEvent: 'scratch',\n        allowBinding: true,\n        allowSetting: true,\n        settingEvent: 'scratch',\n        settingTriggersEvent: true,\n        triggerFnName: 'trigger',\n        allowGetting: true,\n        updateStyle: true\n    }),\n    removeScratch: define.removeData({\n        field: 'scratch',\n        event: 'scratch',\n        triggerFnName: 'trigger',\n        triggerEvent: true,\n        updateStyle: true\n    })\n};\n// aliases\nfn.attr = fn.data;\nfn.removeAttr = fn.removeData;\nvar Core = function Core(opts) {\n    var cy = this;\n    opts = extend({}, opts);\n    var container = opts.container;\n    // allow for passing a wrapped jquery object\n    // e.g. cytoscape({ container: $('#cy') })\n    if (container && !htmlElement(container) && htmlElement(container[0])) {\n        container = container[0];\n    }\n    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery\n    reg = reg || {};\n    if (reg && reg.cy) {\n        reg.cy.destroy();\n        reg = {}; // old instance => replace reg completely\n    }\n    var readies = reg.readies = reg.readies || [];\n    if (container) {\n        container._cyreg = reg;\n    } // make sure container assoc'd reg points to this cy\n    reg.cy = cy;\n    var head = _window !== undefined && container !== undefined && !opts.headless;\n    var options = opts;\n    options.layout = extend({\n        name: head ? 'grid' : 'null'\n    }, options.layout);\n    options.renderer = extend({\n        name: head ? 'canvas' : 'null'\n    }, options.renderer);\n    var defVal = function defVal(def, val, altVal) {\n        if (val !== undefined) {\n            return val;\n        } else if (altVal !== undefined) {\n            return altVal;\n        } else {\n            return def;\n        }\n    };\n    var _p = this._private = {\n        container: container,\n        // html dom ele container\n        ready: false,\n        // whether ready has been triggered\n        options: options,\n        // cached options\n        elements: new Collection(this),\n        // elements in the graph\n        listeners: [],\n        // list of listeners\n        aniEles: new Collection(this),\n        // elements being animated\n        data: options.data || {},\n        // data for the core\n        scratch: {},\n        // scratch object for core\n        layout: null,\n        renderer: null,\n        destroyed: false,\n        // whether destroy was called\n        notificationsEnabled: true,\n        // whether notifications are sent to the renderer\n        minZoom: 1e-50,\n        maxZoom: 1e50,\n        zoomingEnabled: defVal(true, options.zoomingEnabled),\n        userZoomingEnabled: defVal(true, options.userZoomingEnabled),\n        panningEnabled: defVal(true, options.panningEnabled),\n        userPanningEnabled: defVal(true, options.userPanningEnabled),\n        boxSelectionEnabled: defVal(true, options.boxSelectionEnabled),\n        autolock: defVal(false, options.autolock, options.autolockNodes),\n        autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),\n        autounselectify: defVal(false, options.autounselectify),\n        styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,\n        zoom: number$1(options.zoom) ? options.zoom : 1,\n        pan: {\n            x: plainObject(options.pan) && number$1(options.pan.x) ? options.pan.x : 0,\n            y: plainObject(options.pan) && number$1(options.pan.y) ? options.pan.y : 0\n        },\n        animation: {\n            // object for currently-running animations\n            current: [],\n            queue: []\n        },\n        hasCompoundNodes: false,\n        multiClickDebounceTime: defVal(250, options.multiClickDebounceTime)\n    };\n    this.createEmitter();\n    // set selection type\n    this.selectionType(options.selectionType);\n    // init zoom bounds\n    this.zoomRange({\n        min: options.minZoom,\n        max: options.maxZoom\n    });\n    var loadExtData = function loadExtData(extData, next) {\n        var anyIsPromise = extData.some(promise);\n        if (anyIsPromise) {\n            return Promise$1.all(extData).then(next); // load all data asynchronously, then exec rest of init\n        } else {\n            next(extData); // exec synchronously for convenience\n        }\n    };\n    // start with the default stylesheet so we have something before loading an external stylesheet\n    if (_p.styleEnabled) {\n        cy.setStyle([]);\n    }\n    // create the renderer\n    var rendererOptions = extend({}, options, options.renderer); // allow rendering hints in top level options\n    cy.initRenderer(rendererOptions);\n    var setElesAndLayout = function setElesAndLayout(elements, onload, ondone) {\n        cy.notifications(false);\n        // remove old elements\n        var oldEles = cy.mutableElements();\n        if (oldEles.length > 0) {\n            oldEles.remove();\n        }\n        if (elements != null) {\n            if (plainObject(elements) || array(elements)) {\n                cy.add(elements);\n            }\n        }\n        cy.one('layoutready', function(e) {\n            cy.notifications(true);\n            cy.emit(e); // we missed this event by turning notifications off, so pass it on\n            cy.one('load', onload);\n            cy.emitAndNotify('load');\n        }).one('layoutstop', function() {\n            cy.one('done', ondone);\n            cy.emit('done');\n        });\n        var layoutOpts = extend({}, cy._private.options.layout);\n        layoutOpts.eles = cy.elements();\n        cy.layout(layoutOpts).run();\n    };\n    loadExtData([\n        options.style,\n        options.elements\n    ], function(thens) {\n        var initStyle = thens[0];\n        var initEles = thens[1];\n        // init style\n        if (_p.styleEnabled) {\n            cy.style().append(initStyle);\n        }\n        // initial load\n        setElesAndLayout(initEles, function() {\n            // onready\n            cy.startAnimationLoop();\n            _p.ready = true;\n            // if a ready callback is specified as an option, the bind it\n            if (fn$6(options.ready)) {\n                cy.on('ready', options.ready);\n            }\n            // bind all the ready handlers registered before creating this instance\n            for(var i = 0; i < readies.length; i++){\n                var fn = readies[i];\n                cy.on('ready', fn);\n            }\n            if (reg) {\n                reg.readies = [];\n            } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc\n            cy.emit('ready');\n        }, options.done);\n    });\n};\nvar corefn = Core.prototype; // short alias\nextend(corefn, {\n    instanceString: function instanceString() {\n        return 'core';\n    },\n    isReady: function isReady() {\n        return this._private.ready;\n    },\n    destroyed: function destroyed() {\n        return this._private.destroyed;\n    },\n    ready: function ready(fn) {\n        if (this.isReady()) {\n            this.emitter().emit('ready', [], fn); // just calls fn as though triggered via ready event\n        } else {\n            this.on('ready', fn);\n        }\n        return this;\n    },\n    destroy: function destroy() {\n        var cy = this;\n        if (cy.destroyed()) return;\n        cy.stopAnimationLoop();\n        cy.destroyRenderer();\n        this.emit('destroy');\n        cy._private.destroyed = true;\n        return cy;\n    },\n    hasElementWithId: function hasElementWithId(id) {\n        return this._private.elements.hasElementWithId(id);\n    },\n    getElementById: function getElementById(id) {\n        return this._private.elements.getElementById(id);\n    },\n    hasCompoundNodes: function hasCompoundNodes() {\n        return this._private.hasCompoundNodes;\n    },\n    headless: function headless() {\n        return this._private.renderer.isHeadless();\n    },\n    styleEnabled: function styleEnabled() {\n        return this._private.styleEnabled;\n    },\n    addToPool: function addToPool(eles) {\n        this._private.elements.merge(eles);\n        return this; // chaining\n    },\n    removeFromPool: function removeFromPool(eles) {\n        this._private.elements.unmerge(eles);\n        return this;\n    },\n    container: function container() {\n        return this._private.container || null;\n    },\n    window: function window1() {\n        var container = this._private.container;\n        if (container == null) return _window;\n        var ownerDocument = this._private.container.ownerDocument;\n        if (ownerDocument === undefined || ownerDocument == null) {\n            return _window;\n        }\n        return ownerDocument.defaultView || _window;\n    },\n    mount: function mount(container) {\n        if (container == null) {\n            return;\n        }\n        var cy = this;\n        var _p = cy._private;\n        var options = _p.options;\n        if (!htmlElement(container) && htmlElement(container[0])) {\n            container = container[0];\n        }\n        cy.stopAnimationLoop();\n        cy.destroyRenderer();\n        _p.container = container;\n        _p.styleEnabled = true;\n        cy.invalidateSize();\n        cy.initRenderer(extend({}, options, options.renderer, {\n            // allow custom renderer name to be re-used, otherwise use canvas\n            name: options.renderer.name === 'null' ? 'canvas' : options.renderer.name\n        }));\n        cy.startAnimationLoop();\n        cy.style(options.style);\n        cy.emit('mount');\n        return cy;\n    },\n    unmount: function unmount() {\n        var cy = this;\n        cy.stopAnimationLoop();\n        cy.destroyRenderer();\n        cy.initRenderer({\n            name: 'null'\n        });\n        cy.emit('unmount');\n        return cy;\n    },\n    options: function options() {\n        return copy(this._private.options);\n    },\n    json: function json(obj) {\n        var cy = this;\n        var _p = cy._private;\n        var eles = cy.mutableElements();\n        var getFreshRef = function getFreshRef(ele) {\n            return cy.getElementById(ele.id());\n        };\n        if (plainObject(obj)) {\n            // set\n            cy.startBatch();\n            if (obj.elements) {\n                var idInJson = {};\n                var updateEles = function updateEles(jsons, gr) {\n                    var toAdd = [];\n                    var toMod = [];\n                    for(var i = 0; i < jsons.length; i++){\n                        var json = jsons[i];\n                        if (!json.data.id) {\n                            warn('cy.json() cannot handle elements without an ID attribute');\n                            continue;\n                        }\n                        var id = '' + json.data.id; // id must be string\n                        var ele = cy.getElementById(id);\n                        idInJson[id] = true;\n                        if (ele.length !== 0) {\n                            // existing element should be updated\n                            toMod.push({\n                                ele: ele,\n                                json: json\n                            });\n                        } else {\n                            // otherwise should be added\n                            if (gr) {\n                                json.group = gr;\n                                toAdd.push(json);\n                            } else {\n                                toAdd.push(json);\n                            }\n                        }\n                    }\n                    cy.add(toAdd);\n                    for(var _i = 0; _i < toMod.length; _i++){\n                        var _toMod$_i = toMod[_i], _ele = _toMod$_i.ele, _json = _toMod$_i.json;\n                        _ele.json(_json);\n                    }\n                };\n                if (array(obj.elements)) {\n                    // elements: []\n                    updateEles(obj.elements);\n                } else {\n                    // elements: { nodes: [], edges: [] }\n                    var grs = [\n                        'nodes',\n                        'edges'\n                    ];\n                    for(var i = 0; i < grs.length; i++){\n                        var gr = grs[i];\n                        var elements = obj.elements[gr];\n                        if (array(elements)) {\n                            updateEles(elements, gr);\n                        }\n                    }\n                }\n                var parentsToRemove = cy.collection();\n                eles.filter(function(ele) {\n                    return !idInJson[ele.id()];\n                }).forEach(function(ele) {\n                    if (ele.isParent()) {\n                        parentsToRemove.merge(ele);\n                    } else {\n                        ele.remove();\n                    }\n                });\n                // so that children are not removed w/parent\n                parentsToRemove.forEach(function(ele) {\n                    return ele.children().move({\n                        parent: null\n                    });\n                });\n                // intermediate parents may be moved by prior line, so make sure we remove by fresh refs\n                parentsToRemove.forEach(function(ele) {\n                    return getFreshRef(ele).remove();\n                });\n            }\n            if (obj.style) {\n                cy.style(obj.style);\n            }\n            if (obj.zoom != null && obj.zoom !== _p.zoom) {\n                cy.zoom(obj.zoom);\n            }\n            if (obj.pan) {\n                if (obj.pan.x !== _p.pan.x || obj.pan.y !== _p.pan.y) {\n                    cy.pan(obj.pan);\n                }\n            }\n            if (obj.data) {\n                cy.data(obj.data);\n            }\n            var fields = [\n                'minZoom',\n                'maxZoom',\n                'zoomingEnabled',\n                'userZoomingEnabled',\n                'panningEnabled',\n                'userPanningEnabled',\n                'boxSelectionEnabled',\n                'autolock',\n                'autoungrabify',\n                'autounselectify',\n                'multiClickDebounceTime'\n            ];\n            for(var _i2 = 0; _i2 < fields.length; _i2++){\n                var f = fields[_i2];\n                if (obj[f] != null) {\n                    cy[f](obj[f]);\n                }\n            }\n            cy.endBatch();\n            return this; // chaining\n        } else {\n            // get\n            var flat = !!obj;\n            var json = {};\n            if (flat) {\n                json.elements = this.elements().map(function(ele) {\n                    return ele.json();\n                });\n            } else {\n                json.elements = {};\n                eles.forEach(function(ele) {\n                    var group = ele.group();\n                    if (!json.elements[group]) {\n                        json.elements[group] = [];\n                    }\n                    json.elements[group].push(ele.json());\n                });\n            }\n            if (this._private.styleEnabled) {\n                json.style = cy.style().json();\n            }\n            json.data = copy(cy.data());\n            var options = _p.options;\n            json.zoomingEnabled = _p.zoomingEnabled;\n            json.userZoomingEnabled = _p.userZoomingEnabled;\n            json.zoom = _p.zoom;\n            json.minZoom = _p.minZoom;\n            json.maxZoom = _p.maxZoom;\n            json.panningEnabled = _p.panningEnabled;\n            json.userPanningEnabled = _p.userPanningEnabled;\n            json.pan = copy(_p.pan);\n            json.boxSelectionEnabled = _p.boxSelectionEnabled;\n            json.renderer = copy(options.renderer);\n            json.hideEdgesOnViewport = options.hideEdgesOnViewport;\n            json.textureOnViewport = options.textureOnViewport;\n            json.wheelSensitivity = options.wheelSensitivity;\n            json.motionBlur = options.motionBlur;\n            json.multiClickDebounceTime = options.multiClickDebounceTime;\n            return json;\n        }\n    }\n});\ncorefn.$id = corefn.getElementById;\n[\n    corefn$9,\n    corefn$8,\n    elesfn,\n    corefn$7,\n    corefn$6,\n    corefn$5,\n    corefn$4,\n    corefn$3,\n    corefn$2,\n    corefn$1,\n    fn\n].forEach(function(props) {\n    extend(corefn, props);\n});\n/* eslint-disable no-unused-vars */ var defaults$7 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    directed: false,\n    // whether the tree is directed downwards (or edges can point in any direction if false)\n    direction: 'downward',\n    // determines the direction in which the tree structure is drawn.  The possible values are 'downward', 'upward', 'rightward', or 'leftward'.\n    padding: 30,\n    // padding on fit\n    circle: false,\n    // put depths in concentric circles if true, put depths top down if false\n    grid: false,\n    // whether to create an even grid into which the DAG is placed (circle:false only)\n    spacingFactor: 1.75,\n    // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    roots: undefined,\n    // the roots of the trees\n    depthSort: undefined,\n    // a sorting function to order nodes at equal depth. e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled,\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\nvar deprecatedOptionDefaults = {\n    maximal: false,\n    // whether to shift nodes down their natural BFS depths in order to avoid upwards edges (DAGS only); setting acyclic to true sets maximal to true also\n    acyclic: false // whether the tree is acyclic and thus a node could be shifted (due to the maximal option) multiple times without causing an infinite loop; setting to true sets maximal to true also; if you are uncertain whether a tree is acyclic, set to false to avoid potential infinite loops\n};\n/* eslint-enable */ var getInfo = function getInfo(ele) {\n    return ele.scratch('breadthfirst');\n};\nvar setInfo = function setInfo(ele, obj) {\n    return ele.scratch('breadthfirst', obj);\n};\nfunction BreadthFirstLayout(options) {\n    this.options = extend({}, defaults$7, deprecatedOptionDefaults, options);\n}\nBreadthFirstLayout.prototype.run = function() {\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().filter(function(n) {\n        return n.isChildless();\n    });\n    var graph = eles;\n    var directed = options.directed;\n    var maximal = options.acyclic || options.maximal || options.maximalAdjustments > 0; // maximalAdjustments for compat. w/ old code; also, setting acyclic to true sets maximal to true\n    var hasBoundingBox = !!options.boundingBox;\n    var bb = makeBoundingBox(hasBoundingBox ? options.boundingBox : structuredClone(cy.extent()));\n    var roots;\n    if (elementOrCollection(options.roots)) {\n        roots = options.roots;\n    } else if (array(options.roots)) {\n        var rootsArray = [];\n        for(var i = 0; i < options.roots.length; i++){\n            var id = options.roots[i];\n            var ele = cy.getElementById(id);\n            rootsArray.push(ele);\n        }\n        roots = cy.collection(rootsArray);\n    } else if (string(options.roots)) {\n        roots = cy.$(options.roots);\n    } else {\n        if (directed) {\n            roots = nodes.roots();\n        } else {\n            var components = eles.components();\n            roots = cy.collection();\n            var _loop = function _loop() {\n                var comp = components[_i];\n                var maxDegree = comp.maxDegree(false);\n                var compRoots = comp.filter(function(ele) {\n                    return ele.degree(false) === maxDegree;\n                });\n                roots = roots.add(compRoots);\n            };\n            for(var _i = 0; _i < components.length; _i++){\n                _loop();\n            }\n        }\n    }\n    var depths = [];\n    var foundByBfs = {};\n    var addToDepth = function addToDepth(ele, d) {\n        if (depths[d] == null) {\n            depths[d] = [];\n        }\n        var i = depths[d].length;\n        depths[d].push(ele);\n        setInfo(ele, {\n            index: i,\n            depth: d\n        });\n    };\n    var changeDepth = function changeDepth(ele, newDepth) {\n        var _getInfo = getInfo(ele), depth = _getInfo.depth, index = _getInfo.index;\n        depths[depth][index] = null;\n        // add only childless nodes\n        if (ele.isChildless()) addToDepth(ele, newDepth);\n    };\n    // find the depths of the nodes\n    graph.bfs({\n        roots: roots,\n        directed: options.directed,\n        visit: function visit(node, edge, pNode, i, depth) {\n            var ele = node[0];\n            var id = ele.id();\n            // add only childless nodes\n            if (ele.isChildless()) addToDepth(ele, depth);\n            foundByBfs[id] = true;\n        }\n    });\n    // check for nodes not found by bfs\n    var orphanNodes = [];\n    for(var _i2 = 0; _i2 < nodes.length; _i2++){\n        var _ele = nodes[_i2];\n        if (foundByBfs[_ele.id()]) {\n            continue;\n        } else {\n            orphanNodes.push(_ele);\n        }\n    }\n    // assign the nodes a depth and index\n    var assignDepthsAt = function assignDepthsAt(i) {\n        var eles = depths[i];\n        for(var j = 0; j < eles.length; j++){\n            var _ele2 = eles[j];\n            if (_ele2 == null) {\n                eles.splice(j, 1);\n                j--;\n                continue;\n            }\n            setInfo(_ele2, {\n                depth: i,\n                index: j\n            });\n        }\n    };\n    var adjustMaximally = function adjustMaximally(ele, shifted) {\n        var eInfo = getInfo(ele);\n        var incomers = ele.incomers().filter(function(el) {\n            return el.isNode() && eles.has(el);\n        });\n        var maxDepth = -1;\n        var id = ele.id();\n        for(var k = 0; k < incomers.length; k++){\n            var incmr = incomers[k];\n            var iInfo = getInfo(incmr);\n            maxDepth = Math.max(maxDepth, iInfo.depth);\n        }\n        if (eInfo.depth <= maxDepth) {\n            if (!options.acyclic && shifted[id]) {\n                return null;\n            }\n            var newDepth = maxDepth + 1;\n            changeDepth(ele, newDepth);\n            shifted[id] = newDepth;\n            return true;\n        }\n        return false;\n    };\n    // for the directed case, try to make the edges all go down (i.e. depth i => depth i + 1)\n    if (directed && maximal) {\n        var Q = [];\n        var shifted = {};\n        var enqueue = function enqueue(n) {\n            return Q.push(n);\n        };\n        var dequeue = function dequeue() {\n            return Q.shift();\n        };\n        nodes.forEach(function(n) {\n            return Q.push(n);\n        });\n        while(Q.length > 0){\n            var _ele3 = dequeue();\n            var didShift = adjustMaximally(_ele3, shifted);\n            if (didShift) {\n                _ele3.outgoers().filter(function(el) {\n                    return el.isNode() && eles.has(el);\n                }).forEach(enqueue);\n            } else if (didShift === null) {\n                warn('Detected double maximal shift for node `' + _ele3.id() + '`.  Bailing maximal adjustment due to cycle.  Use `options.maximal: true` only on DAGs.');\n                break; // exit on failure\n            }\n        }\n    }\n    // find min distance we need to leave between nodes\n    var minDistance = 0;\n    if (options.avoidOverlap) {\n        for(var _i3 = 0; _i3 < nodes.length; _i3++){\n            var n = nodes[_i3];\n            var nbb = n.layoutDimensions(options);\n            var w = nbb.w;\n            var h = nbb.h;\n            minDistance = Math.max(minDistance, w, h);\n        }\n    }\n    // get the weighted percent for an element based on its connectivity to other levels\n    var cachedWeightedPercent = {};\n    var getWeightedPercent = function getWeightedPercent(ele) {\n        if (cachedWeightedPercent[ele.id()]) {\n            return cachedWeightedPercent[ele.id()];\n        }\n        var eleDepth = getInfo(ele).depth;\n        var neighbors = ele.neighborhood();\n        var percent = 0;\n        var samples = 0;\n        for(var _i4 = 0; _i4 < neighbors.length; _i4++){\n            var neighbor = neighbors[_i4];\n            if (neighbor.isEdge() || neighbor.isParent() || !nodes.has(neighbor)) {\n                continue;\n            }\n            var bf = getInfo(neighbor);\n            if (bf == null) {\n                continue;\n            }\n            var index = bf.index;\n            var depth = bf.depth;\n            // unassigned neighbours shouldn't affect the ordering\n            if (index == null || depth == null) {\n                continue;\n            }\n            var nDepth = depths[depth].length;\n            if (depth < eleDepth) {\n                // only get influenced by elements above\n                percent += index / nDepth;\n                samples++;\n            }\n        }\n        samples = Math.max(1, samples);\n        percent = percent / samples;\n        if (samples === 0) {\n            // put lone nodes at the start\n            percent = 0;\n        }\n        cachedWeightedPercent[ele.id()] = percent;\n        return percent;\n    };\n    // rearrange the indices in each depth level based on connectivity\n    var sortFn = function sortFn(a, b) {\n        var apct = getWeightedPercent(a);\n        var bpct = getWeightedPercent(b);\n        var diff = apct - bpct;\n        if (diff === 0) {\n            return ascending(a.id(), b.id()); // make sure sort doesn't have don't-care comparisons\n        } else {\n            return diff;\n        }\n    };\n    if (options.depthSort !== undefined) {\n        sortFn = options.depthSort;\n    }\n    var depthsLen = depths.length;\n    // sort each level to make connected nodes closer\n    for(var _i5 = 0; _i5 < depthsLen; _i5++){\n        depths[_i5].sort(sortFn);\n        assignDepthsAt(_i5);\n    }\n    // assign orphan nodes to a new top-level depth\n    var orphanDepth = [];\n    for(var _i6 = 0; _i6 < orphanNodes.length; _i6++){\n        orphanDepth.push(orphanNodes[_i6]);\n    }\n    var assignDepths = function assignDepths() {\n        for(var _i7 = 0; _i7 < depthsLen; _i7++){\n            assignDepthsAt(_i7);\n        }\n    };\n    // add a new top-level depth only when there are orphan nodes\n    if (orphanDepth.length) {\n        depths.unshift(orphanDepth);\n        depthsLen = depths.length;\n        assignDepths();\n    }\n    var biggestDepthSize = 0;\n    for(var _i8 = 0; _i8 < depthsLen; _i8++){\n        biggestDepthSize = Math.max(depths[_i8].length, biggestDepthSize);\n    }\n    var center = {\n        x: bb.x1 + bb.w / 2,\n        y: bb.y1 + bb.h / 2\n    };\n    // average node size\n    var aveNodeSize = nodes.reduce(function(acc, node) {\n        return function(box) {\n            return {\n                w: acc.w === -1 ? box.w : (acc.w + box.w) / 2,\n                h: acc.h === -1 ? box.h : (acc.h + box.h) / 2\n            };\n        }(node.boundingBox({\n            includeLabels: options.nodeDimensionsIncludeLabels\n        }));\n    }, {\n        w: -1,\n        h: -1\n    });\n    var distanceY = Math.max(// only one depth\n    depthsLen === 1 ? 0 : // inside a bounding box, no need for top & bottom padding\n    hasBoundingBox ? (bb.h - options.padding * 2 - aveNodeSize.h) / (depthsLen - 1) : (bb.h - options.padding * 2 - aveNodeSize.h) / (depthsLen + 1), minDistance);\n    var maxDepthSize = depths.reduce(function(max, eles) {\n        return Math.max(max, eles.length);\n    }, 0);\n    var getPositionTopBottom = function getPositionTopBottom(ele) {\n        var _getInfo2 = getInfo(ele), depth = _getInfo2.depth, index = _getInfo2.index;\n        if (options.circle) {\n            var radiusStepSize = Math.min(bb.w / 2 / depthsLen, bb.h / 2 / depthsLen);\n            radiusStepSize = Math.max(radiusStepSize, minDistance);\n            var radius = radiusStepSize * depth + radiusStepSize - (depthsLen > 0 && depths[0].length <= 3 ? radiusStepSize / 2 : 0);\n            var theta = 2 * Math.PI / depths[depth].length * index;\n            if (depth === 0 && depths[0].length === 1) {\n                radius = 1;\n            }\n            return {\n                x: center.x + radius * Math.cos(theta),\n                y: center.y + radius * Math.sin(theta)\n            };\n        } else {\n            var depthSize = depths[depth].length;\n            var distanceX = Math.max(// only one depth\n            depthSize === 1 ? 0 : // inside a bounding box, no need for left & right padding\n            hasBoundingBox ? (bb.w - options.padding * 2 - aveNodeSize.w) / ((options.grid ? maxDepthSize : depthSize) - 1) : (bb.w - options.padding * 2 - aveNodeSize.w) / ((options.grid ? maxDepthSize : depthSize) + 1), minDistance);\n            var epos = {\n                x: center.x + (index + 1 - (depthSize + 1) / 2) * distanceX,\n                y: center.y + (depth + 1 - (depthsLen + 1) / 2) * distanceY\n            };\n            return epos;\n        }\n    };\n    var rotateDegrees = {\n        'downward': 0,\n        'leftward': 90,\n        'upward': 180,\n        'rightward': -90\n    };\n    if (Object.keys(rotateDegrees).indexOf(options.direction) === -1) {\n        error(\"Invalid direction '\".concat(options.direction, \"' specified for breadthfirst layout. Valid values are: \").concat(Object.keys(rotateDegrees).join(', ')));\n    }\n    var getPosition = function getPosition(ele) {\n        return rotatePosAndSkewByBox(getPositionTopBottom(ele), bb, rotateDegrees[options.direction]);\n    };\n    eles.nodes().layoutPositions(this, options, getPosition);\n    return this; // chaining\n};\nvar defaults$6 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox and radius if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    radius: undefined,\n    // the radius of the circle\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\nfunction CircleLayout(options) {\n    this.options = extend({}, defaults$6, options);\n}\nCircleLayout.prototype.run = function() {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var nodes = eles.nodes().not(':parent');\n    if (options.sort) {\n        nodes = nodes.sort(options.sort);\n    }\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var center = {\n        x: bb.x1 + bb.w / 2,\n        y: bb.y1 + bb.h / 2\n    };\n    var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / nodes.length : options.sweep;\n    var dTheta = sweep / Math.max(1, nodes.length - 1);\n    var r;\n    var minDistance = 0;\n    for(var i = 0; i < nodes.length; i++){\n        var n = nodes[i];\n        var nbb = n.layoutDimensions(options);\n        var w = nbb.w;\n        var h = nbb.h;\n        minDistance = Math.max(minDistance, w, h);\n    }\n    if (number$1(options.radius)) {\n        r = options.radius;\n    } else if (nodes.length <= 1) {\n        r = 0;\n    } else {\n        r = Math.min(bb.h, bb.w) / 2 - minDistance;\n    }\n    // calculate the radius\n    if (nodes.length > 1 && options.avoidOverlap) {\n        // but only if more than one node (can't overlap)\n        minDistance *= 1.75; // just to have some nice spacing\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt(minDistance * minDistance / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n        r = Math.max(rMin, r);\n    }\n    var getPos = function getPos(ele, i) {\n        var theta = options.startAngle + i * dTheta * (clockwise ? 1 : -1);\n        var rx = r * Math.cos(theta);\n        var ry = r * Math.sin(theta);\n        var pos = {\n            x: center.x + rx,\n            y: center.y + ry\n        };\n        return pos;\n    };\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n};\nvar defaults$5 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // the padding on fit\n    startAngle: 3 / 2 * Math.PI,\n    // where nodes start in radians\n    sweep: undefined,\n    // how many radians should be between the first and last node (defaults to full circle)\n    clockwise: true,\n    // whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false)\n    equidistant: false,\n    // whether levels have an equal radial distance betwen them, may cause bounding box overflow\n    minNodeSpacing: 10,\n    // min spacing between outside of nodes (used for radius adjustment)\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    height: undefined,\n    // height of layout area (overrides container height)\n    width: undefined,\n    // width of layout area (overrides container width)\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    concentric: function concentric(node) {\n        // returns numeric value for each node, placing higher nodes in levels towards the centre\n        return node.degree();\n    },\n    levelWidth: function levelWidth(nodes) {\n        // the variation of concentric values in each level\n        return nodes.maxDegree() / 4;\n    },\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\nfunction ConcentricLayout(options) {\n    this.options = extend({}, defaults$5, options);\n}\nConcentricLayout.prototype.run = function() {\n    var params = this.options;\n    var options = params;\n    var clockwise = options.counterclockwise !== undefined ? !options.counterclockwise : options.clockwise;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var center = {\n        x: bb.x1 + bb.w / 2,\n        y: bb.y1 + bb.h / 2\n    };\n    var nodeValues = []; // { node, value }\n    var maxNodeSize = 0;\n    for(var i = 0; i < nodes.length; i++){\n        var node = nodes[i];\n        var value = undefined;\n        // calculate the node value\n        value = options.concentric(node);\n        nodeValues.push({\n            value: value,\n            node: node\n        });\n        // for style mapping\n        node._private.scratch.concentric = value;\n    }\n    // in case we used the `concentric` in style\n    nodes.updateStyle();\n    // calculate max size now based on potentially updated mappers\n    for(var _i = 0; _i < nodes.length; _i++){\n        var _node = nodes[_i];\n        var nbb = _node.layoutDimensions(options);\n        maxNodeSize = Math.max(maxNodeSize, nbb.w, nbb.h);\n    }\n    // sort node values in descreasing order\n    nodeValues.sort(function(a, b) {\n        return b.value - a.value;\n    });\n    var levelWidth = options.levelWidth(nodes);\n    // put the values into levels\n    var levels = [\n        []\n    ];\n    var currentLevel = levels[0];\n    for(var _i2 = 0; _i2 < nodeValues.length; _i2++){\n        var val = nodeValues[_i2];\n        if (currentLevel.length > 0) {\n            var diff = Math.abs(currentLevel[0].value - val.value);\n            if (diff >= levelWidth) {\n                currentLevel = [];\n                levels.push(currentLevel);\n            }\n        }\n        currentLevel.push(val);\n    }\n    // create positions from levels\n    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes\n    if (!options.avoidOverlap) {\n        // then strictly constrain to bb\n        var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n        var maxR = Math.min(bb.w, bb.h) / 2 - minDist;\n        var rStep = maxR / (levels.length + firstLvlHasMulti ? 1 : 0);\n        minDist = Math.min(minDist, rStep);\n    }\n    // find the metrics for each level\n    var r = 0;\n    for(var _i3 = 0; _i3 < levels.length; _i3++){\n        var level = levels[_i3];\n        var sweep = options.sweep === undefined ? 2 * Math.PI - 2 * Math.PI / level.length : options.sweep;\n        var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1);\n        // calculate the radius\n        if (level.length > 1 && options.avoidOverlap) {\n            // but only if more than one node (can't overlap)\n            var dcos = Math.cos(dTheta) - Math.cos(0);\n            var dsin = Math.sin(dTheta) - Math.sin(0);\n            var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n            r = Math.max(rMin, r);\n        }\n        level.r = r;\n        r += minDist;\n    }\n    if (options.equidistant) {\n        var rDeltaMax = 0;\n        var _r = 0;\n        for(var _i4 = 0; _i4 < levels.length; _i4++){\n            var _level = levels[_i4];\n            var rDelta = _level.r - _r;\n            rDeltaMax = Math.max(rDeltaMax, rDelta);\n        }\n        _r = 0;\n        for(var _i5 = 0; _i5 < levels.length; _i5++){\n            var _level2 = levels[_i5];\n            if (_i5 === 0) {\n                _r = _level2.r;\n            }\n            _level2.r = _r;\n            _r += rDeltaMax;\n        }\n    }\n    // calculate the node positions\n    var pos = {}; // id => position\n    for(var _i6 = 0; _i6 < levels.length; _i6++){\n        var _level3 = levels[_i6];\n        var _dTheta = _level3.dTheta;\n        var _r2 = _level3.r;\n        for(var j = 0; j < _level3.length; j++){\n            var _val = _level3[j];\n            var theta = options.startAngle + (clockwise ? 1 : -1) * _dTheta * j;\n            var p = {\n                x: center.x + _r2 * Math.cos(theta),\n                y: center.y + _r2 * Math.sin(theta)\n            };\n            pos[_val.node.id()] = p;\n        }\n    }\n    // position the nodes\n    eles.nodes().layoutPositions(this, options, function(ele) {\n        var id = ele.id();\n        return pos[id];\n    });\n    return this; // chaining\n};\n/*\nThe CoSE layout was written by Gerardo Huck.\nhttps://www.linkedin.com/in/gerardohuck/\n\nBased on the following article:\nhttp://dl.acm.org/citation.cfm?id=1498047\n\nModifications tracked on Github.\n*/ var DEBUG;\n/**\n * @brief :  default layout options\n */ var defaults$4 = {\n    // Called on `layoutready`\n    ready: function ready() {},\n    // Called on `layoutstop`\n    stop: function stop() {},\n    // Whether to animate while running the layout\n    // true : Animate continuously as the layout is running\n    // false : Just show the end result\n    // 'end' : Animate with the end result, from the initial positions to the end positions\n    animate: true,\n    // Easing of the animation for animate:'end'\n    animationEasing: undefined,\n    // The duration of the animation for animate:'end'\n    animationDuration: undefined,\n    // A function that determines whether the node should be animated\n    // All nodes animated by default on animate enabled\n    // Non-animated nodes are positioned immediately when the layout starts\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // The layout animates only after this many milliseconds for animate:true\n    // (prevents flashing on fast runs)\n    animationThreshold: 250,\n    // Number of iterations between consecutive screen positions update\n    refresh: 20,\n    // Whether to fit the network view after when done\n    fit: true,\n    // Padding on fit\n    padding: 30,\n    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    boundingBox: undefined,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    nodeDimensionsIncludeLabels: false,\n    // Randomize the initial positions of the nodes (true) or use existing positions (false)\n    randomize: false,\n    // Extra spacing between components in non-compound graphs\n    componentSpacing: 40,\n    // Node repulsion (non overlapping) multiplier\n    nodeRepulsion: function nodeRepulsion(node) {\n        return 2048;\n    },\n    // Node repulsion (overlapping) multiplier\n    nodeOverlap: 4,\n    // Ideal edge (non nested) length\n    idealEdgeLength: function idealEdgeLength(edge) {\n        return 32;\n    },\n    // Divisor to compute edge forces\n    edgeElasticity: function edgeElasticity(edge) {\n        return 32;\n    },\n    // Nesting factor (multiplier) to compute ideal edge length for nested edges\n    nestingFactor: 1.2,\n    // Gravity force (constant)\n    gravity: 1,\n    // Maximum number of iterations to perform\n    numIter: 1000,\n    // Initial temperature (maximum node displacement)\n    initialTemp: 1000,\n    // Cooling factor (how the temperature is reduced between consecutive iterations\n    coolingFactor: 0.99,\n    // Lower temperature threshold (below this point the layout will end)\n    minTemp: 1.0\n};\n/**\n * @brief       : constructor\n * @arg options : object containing layout options\n */ function CoseLayout(options) {\n    this.options = extend({}, defaults$4, options);\n    this.options.layout = this;\n    // Exclude any edge that has a source or target node that is not in the set of passed-in nodes\n    var nodes = this.options.eles.nodes();\n    var edges = this.options.eles.edges();\n    var notEdges = edges.filter(function(e) {\n        var sourceId = e.source().data('id');\n        var targetId = e.target().data('id');\n        var hasSource = nodes.some(function(n) {\n            return n.data('id') === sourceId;\n        });\n        var hasTarget = nodes.some(function(n) {\n            return n.data('id') === targetId;\n        });\n        return !hasSource || !hasTarget;\n    });\n    this.options.eles = this.options.eles.not(notEdges);\n}\n/**\n * @brief : runs the layout\n */ CoseLayout.prototype.run = function() {\n    var options = this.options;\n    var cy = options.cy;\n    var layout = this;\n    layout.stopped = false;\n    if (options.animate === true || options.animate === false) {\n        layout.emit({\n            type: 'layoutstart',\n            layout: layout\n        });\n    }\n    // Set DEBUG - Global variable\n    if (true === options.debug) {\n        DEBUG = true;\n    } else {\n        DEBUG = false;\n    }\n    // Initialize layout info\n    var layoutInfo = createLayoutInfo(cy, layout, options);\n    // Show LayoutInfo contents if debugging\n    if (DEBUG) {\n        printLayoutInfo(layoutInfo);\n    }\n    // If required, randomize node positions\n    if (options.randomize) {\n        randomizePositions(layoutInfo);\n    }\n    var startTime = performanceNow();\n    var refresh = function refresh() {\n        refreshPositions(layoutInfo, cy, options);\n        // Fit the graph if necessary\n        if (true === options.fit) {\n            cy.fit(options.padding);\n        }\n    };\n    var mainLoop = function mainLoop(i) {\n        if (layout.stopped || i >= options.numIter) {\n            // logDebug(\"Layout manually stopped. Stopping computation in step \" + i);\n            return false;\n        }\n        // Do one step in the phisical simulation\n        step(layoutInfo, options);\n        // Update temperature\n        layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;\n        // logDebug(\"New temperature: \" + layoutInfo.temperature);\n        if (layoutInfo.temperature < options.minTemp) {\n            // logDebug(\"Temperature drop below minimum threshold. Stopping computation in step \" + i);\n            return false;\n        }\n        return true;\n    };\n    var done = function done() {\n        if (options.animate === true || options.animate === false) {\n            refresh();\n            // Layout has finished\n            layout.one('layoutstop', options.stop);\n            layout.emit({\n                type: 'layoutstop',\n                layout: layout\n            });\n        } else {\n            var nodes = options.eles.nodes();\n            var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n            nodes.layoutPositions(layout, options, getScaledPos);\n        }\n    };\n    var i = 0;\n    var loopRet = true;\n    if (options.animate === true) {\n        var _frame = function frame() {\n            var f = 0;\n            while(loopRet && f < options.refresh){\n                loopRet = mainLoop(i);\n                i++;\n                f++;\n            }\n            if (!loopRet) {\n                // it's done\n                separateComponents(layoutInfo, options);\n                done();\n            } else {\n                var now = performanceNow();\n                if (now - startTime >= options.animationThreshold) {\n                    refresh();\n                }\n                requestAnimationFrame(_frame);\n            }\n        };\n        _frame();\n    } else {\n        while(loopRet){\n            loopRet = mainLoop(i);\n            i++;\n        }\n        separateComponents(layoutInfo, options);\n        done();\n    }\n    return this; // chaining\n};\n/**\n * @brief : called on continuous layouts to stop them before they finish\n */ CoseLayout.prototype.stop = function() {\n    this.stopped = true;\n    if (this.thread) {\n        this.thread.stop();\n    }\n    this.emit('layoutstop');\n    return this; // chaining\n};\nCoseLayout.prototype.destroy = function() {\n    if (this.thread) {\n        this.thread.stop();\n    }\n    return this; // chaining\n};\n/**\n * @brief     : Creates an object which is contains all the data\n *              used in the layout process\n * @arg cy    : cytoscape.js object\n * @return    : layoutInfo object initialized\n */ var createLayoutInfo = function createLayoutInfo(cy, layout, options) {\n    // Shortcut\n    var edges = options.eles.edges();\n    var nodes = options.eles.nodes();\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var layoutInfo = {\n        isCompound: cy.hasCompoundNodes(),\n        layoutNodes: [],\n        idToIndex: {},\n        nodeSize: nodes.size(),\n        graphSet: [],\n        indexToGraph: [],\n        layoutEdges: [],\n        edgeSize: edges.size(),\n        temperature: options.initialTemp,\n        clientWidth: bb.w,\n        clientHeight: bb.h,\n        boundingBox: bb\n    };\n    var components = options.eles.components();\n    var id2cmptId = {};\n    for(var i = 0; i < components.length; i++){\n        var component = components[i];\n        for(var j = 0; j < component.length; j++){\n            var node = component[j];\n            id2cmptId[node.id()] = i;\n        }\n    }\n    // Iterate over all nodes, creating layout nodes\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = nodes[i];\n        var nbb = n.layoutDimensions(options);\n        var tempNode = {};\n        tempNode.isLocked = n.locked();\n        tempNode.id = n.data('id');\n        tempNode.parentId = n.data('parent');\n        tempNode.cmptId = id2cmptId[n.id()];\n        tempNode.children = [];\n        tempNode.positionX = n.position('x');\n        tempNode.positionY = n.position('y');\n        tempNode.offsetX = 0;\n        tempNode.offsetY = 0;\n        tempNode.height = nbb.w;\n        tempNode.width = nbb.h;\n        tempNode.maxX = tempNode.positionX + tempNode.width / 2;\n        tempNode.minX = tempNode.positionX - tempNode.width / 2;\n        tempNode.maxY = tempNode.positionY + tempNode.height / 2;\n        tempNode.minY = tempNode.positionY - tempNode.height / 2;\n        tempNode.padLeft = parseFloat(n.style('padding'));\n        tempNode.padRight = parseFloat(n.style('padding'));\n        tempNode.padTop = parseFloat(n.style('padding'));\n        tempNode.padBottom = parseFloat(n.style('padding'));\n        // forces\n        tempNode.nodeRepulsion = fn$6(options.nodeRepulsion) ? options.nodeRepulsion(n) : options.nodeRepulsion;\n        // Add new node\n        layoutInfo.layoutNodes.push(tempNode);\n        // Add entry to id-index map\n        layoutInfo.idToIndex[tempNode.id] = i;\n    }\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0; // Points to the start the queue\n    var end = -1; // Points to the end of the queue\n    var tempGraph = [];\n    // Second pass to add child information and\n    // initialize queue for hierarchical traversal\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        var p_id = n.parentId;\n        // Check if node n has a parent node\n        if (null != p_id) {\n            // Add node Id to parent's list of children\n            layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);\n        } else {\n            // If a node doesn't have a parent, then it's in the root graph\n            queue[++end] = n.id;\n            tempGraph.push(n.id);\n        }\n    }\n    // Add root graph to graphSet\n    layoutInfo.graphSet.push(tempGraph);\n    // Traverse the graph, level by level,\n    while(start <= end){\n        // Get the node to visit and remove it from queue\n        var node_id = queue[start++];\n        var node_ix = layoutInfo.idToIndex[node_id];\n        var node = layoutInfo.layoutNodes[node_ix];\n        var children = node.children;\n        if (children.length > 0) {\n            // Add children nodes as a new graph to graph set\n            layoutInfo.graphSet.push(children);\n            // Add children to que queue to be visited\n            for(var i = 0; i < children.length; i++){\n                queue[++end] = children[i];\n            }\n        }\n    }\n    // Create indexToGraph map\n    for(var i = 0; i < layoutInfo.graphSet.length; i++){\n        var graph = layoutInfo.graphSet[i];\n        for(var j = 0; j < graph.length; j++){\n            var index = layoutInfo.idToIndex[graph[j]];\n            layoutInfo.indexToGraph[index] = i;\n        }\n    }\n    // Iterate over all edges, creating Layout Edges\n    for(var i = 0; i < layoutInfo.edgeSize; i++){\n        var e = edges[i];\n        var tempEdge = {};\n        tempEdge.id = e.data('id');\n        tempEdge.sourceId = e.data('source');\n        tempEdge.targetId = e.data('target');\n        // Compute ideal length\n        var idealLength = fn$6(options.idealEdgeLength) ? options.idealEdgeLength(e) : options.idealEdgeLength;\n        var elasticity = fn$6(options.edgeElasticity) ? options.edgeElasticity(e) : options.edgeElasticity;\n        // Check if it's an inter graph edge\n        var sourceIx = layoutInfo.idToIndex[tempEdge.sourceId];\n        var targetIx = layoutInfo.idToIndex[tempEdge.targetId];\n        var sourceGraph = layoutInfo.indexToGraph[sourceIx];\n        var targetGraph = layoutInfo.indexToGraph[targetIx];\n        if (sourceGraph != targetGraph) {\n            // Find lowest common graph ancestor\n            var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);\n            // Compute sum of node depths, relative to lca graph\n            var lcaGraph = layoutInfo.graphSet[lca];\n            var depth = 0;\n            // Source depth\n            var tempNode = layoutInfo.layoutNodes[sourceIx];\n            while(-1 === lcaGraph.indexOf(tempNode.id)){\n                tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n                depth++;\n            }\n            // Target depth\n            tempNode = layoutInfo.layoutNodes[targetIx];\n            while(-1 === lcaGraph.indexOf(tempNode.id)){\n                tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];\n                depth++;\n            }\n            // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +\n            //  \". Index: \" + lca + \" Contents: \" + lcaGraph.toString() +\n            //  \". Depth: \" + depth);\n            // Update idealLength\n            idealLength *= depth * options.nestingFactor;\n        }\n        tempEdge.idealLength = idealLength;\n        tempEdge.elasticity = elasticity;\n        layoutInfo.layoutEdges.push(tempEdge);\n    }\n    // Finally, return layoutInfo object\n    return layoutInfo;\n};\n/**\n * @brief : This function finds the index of the lowest common\n *          graph ancestor between 2 nodes in the subtree\n *          (from the graph hierarchy induced tree) whose\n *          root is graphIx\n *\n * @arg node1: node1's ID\n * @arg node2: node2's ID\n * @arg layoutInfo: layoutInfo object\n *\n */ var findLCA = function findLCA(node1, node2, layoutInfo) {\n    // Find their common ancester, starting from the root graph\n    var res = _findLCA_aux(node1, node2, 0, layoutInfo);\n    if (2 > res.count) {\n        // If aux function couldn't find the common ancester,\n        // then it is the root graph\n        return 0;\n    } else {\n        return res.graph;\n    }\n};\n/**\n * @brief          : Auxiliary function used for LCA computation\n *\n * @arg node1      : node1's ID\n * @arg node2      : node2's ID\n * @arg graphIx    : subgraph index\n * @arg layoutInfo : layoutInfo object\n *\n * @return         : object of the form {count: X, graph: Y}, where:\n *                   X is the number of ancestors (max: 2) found in\n *                   graphIx (and it's subgraphs),\n *                   Y is the graph index of the lowest graph containing\n *                   all X nodes\n */ var _findLCA_aux = function findLCA_aux(node1, node2, graphIx, layoutInfo) {\n    var graph = layoutInfo.graphSet[graphIx];\n    // If both nodes belongs to graphIx\n    if (-1 < graph.indexOf(node1) && -1 < graph.indexOf(node2)) {\n        return {\n            count: 2,\n            graph: graphIx\n        };\n    }\n    // Make recursive calls for all subgraphs\n    var c = 0;\n    for(var i = 0; i < graph.length; i++){\n        var nodeId = graph[i];\n        var nodeIx = layoutInfo.idToIndex[nodeId];\n        var children = layoutInfo.layoutNodes[nodeIx].children;\n        // If the node has no child, skip it\n        if (0 === children.length) {\n            continue;\n        }\n        var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];\n        var result = _findLCA_aux(node1, node2, childGraphIx, layoutInfo);\n        if (0 === result.count) {\n            continue;\n        } else if (1 === result.count) {\n            // One of (node1, node2) is present in this subgraph\n            c++;\n            if (2 === c) {\n                break;\n            }\n        } else {\n            // Both nodes are present in this subgraph\n            return result;\n        }\n    }\n    return {\n        count: c,\n        graph: graphIx\n    };\n};\n/**\n * @brief: printsLayoutInfo into js console\n *         Only used for debbuging\n */ var printLayoutInfo;\n/**\n * @brief : Randomizes the position of all nodes\n */ var randomizePositions = function randomizePositions(layoutInfo, cy) {\n    var width = layoutInfo.clientWidth;\n    var height = layoutInfo.clientHeight;\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        // No need to randomize compound nodes or locked nodes\n        if (0 === n.children.length && !n.isLocked) {\n            n.positionX = Math.random() * width;\n            n.positionY = Math.random() * height;\n        }\n    }\n};\nvar getScaleInBoundsFn = function getScaleInBoundsFn(layoutInfo, options, nodes) {\n    var bb = layoutInfo.boundingBox;\n    var coseBB = {\n        x1: Infinity,\n        x2: -Infinity,\n        y1: Infinity,\n        y2: -Infinity\n    };\n    if (options.boundingBox) {\n        nodes.forEach(function(node) {\n            var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];\n            coseBB.x1 = Math.min(coseBB.x1, lnode.positionX);\n            coseBB.x2 = Math.max(coseBB.x2, lnode.positionX);\n            coseBB.y1 = Math.min(coseBB.y1, lnode.positionY);\n            coseBB.y2 = Math.max(coseBB.y2, lnode.positionY);\n        });\n        coseBB.w = coseBB.x2 - coseBB.x1;\n        coseBB.h = coseBB.y2 - coseBB.y1;\n    }\n    return function(ele, i) {\n        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];\n        if (options.boundingBox) {\n            // then add extra bounding box constraint\n            // Handle single node case where coseBB.w or coseBB.h is 0\n            var pctX = coseBB.w === 0 ? 0.5 : (lnode.positionX - coseBB.x1) / coseBB.w;\n            var pctY = coseBB.h === 0 ? 0.5 : (lnode.positionY - coseBB.y1) / coseBB.h;\n            return {\n                x: bb.x1 + pctX * bb.w,\n                y: bb.y1 + pctY * bb.h\n            };\n        } else {\n            return {\n                x: lnode.positionX,\n                y: lnode.positionY\n            };\n        }\n    };\n};\n/**\n * @brief          : Updates the positions of nodes in the network\n * @arg layoutInfo : LayoutInfo object\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */ var refreshPositions = function refreshPositions(layoutInfo, cy, options) {\n    // var s = 'Refreshing positions';\n    // logDebug(s);\n    var layout = options.layout;\n    var nodes = options.eles.nodes();\n    var getScaledPos = getScaleInBoundsFn(layoutInfo, options, nodes);\n    nodes.positions(getScaledPos);\n    // Trigger layoutReady only on first call\n    if (true !== layoutInfo.ready) {\n        // s = 'Triggering layoutready';\n        // logDebug(s);\n        layoutInfo.ready = true;\n        layout.one('layoutready', options.ready);\n        layout.emit({\n            type: 'layoutready',\n            layout: this\n        });\n    }\n};\n/**\n * @brief : Logs a debug message in JS console, if DEBUG is ON\n */ // var logDebug = function(text) {\n//   if (DEBUG) {\n//     console.debug(text);\n//   }\n// };\n/**\n * @brief          : Performs one iteration of the physical simulation\n * @arg layoutInfo : LayoutInfo object already initialized\n * @arg cy         : Cytoscape object\n * @arg options    : Layout options\n */ var step = function step(layoutInfo, options, _step) {\n    // var s = \"\\n\\n###############################\";\n    // s += \"\\nSTEP: \" + step;\n    // s += \"\\n###############################\\n\";\n    // logDebug(s);\n    // Calculate node repulsions\n    calculateNodeForces(layoutInfo, options);\n    // Calculate edge forces\n    calculateEdgeForces(layoutInfo);\n    // Calculate gravity forces\n    calculateGravityForces(layoutInfo, options);\n    // Propagate forces from parent to child\n    propagateForces(layoutInfo);\n    // Update positions based on calculated forces\n    updatePositions(layoutInfo);\n};\n/**\n * @brief : Computes the node repulsion forces\n */ var calculateNodeForces = function calculateNodeForces(layoutInfo, options) {\n    // Go through each of the graphs in graphSet\n    // Nodes only repel each other if they belong to the same graph\n    // var s = 'calculateNodeForces';\n    // logDebug(s);\n    for(var i = 0; i < layoutInfo.graphSet.length; i++){\n        var graph = layoutInfo.graphSet[i];\n        var numNodes = graph.length;\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n        // Now get all the pairs of nodes\n        // Only get each pair once, (A, B) = (B, A)\n        for(var j = 0; j < numNodes; j++){\n            var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n            for(var k = j + 1; k < numNodes; k++){\n                var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];\n                nodeRepulsion(node1, node2, layoutInfo, options);\n            }\n        }\n    }\n};\nvar randomDistance = function randomDistance(max) {\n    return -1 + 2 * max * Math.random();\n};\n/**\n * @brief : Compute the node repulsion forces between a pair of nodes\n */ var nodeRepulsion = function nodeRepulsion(node1, node2, layoutInfo, options) {\n    // var s = \"Node repulsion. Node1: \" + node1.id + \" Node2: \" + node2.id;\n    var cmptId1 = node1.cmptId;\n    var cmptId2 = node2.cmptId;\n    if (cmptId1 !== cmptId2 && !layoutInfo.isCompound) {\n        return;\n    }\n    // Get direction of line connecting both node centers\n    var directionX = node2.positionX - node1.positionX;\n    var directionY = node2.positionY - node1.positionY;\n    var maxRandDist = 1;\n    // s += \"\\ndirectionX: \" + directionX + \", directionY: \" + directionY;\n    // If both centers are the same, apply a random force\n    if (0 === directionX && 0 === directionY) {\n        directionX = randomDistance(maxRandDist);\n        directionY = randomDistance(maxRandDist);\n    }\n    var overlap = nodesOverlap(node1, node2, directionX, directionY);\n    if (overlap > 0) {\n        // s += \"\\nNodes DO overlap.\";\n        // s += \"\\nOverlap: \" + overlap;\n        // If nodes overlap, repulsion force is proportional\n        // to the overlap\n        var force = options.nodeOverlap * overlap;\n        // Compute the module and components of the force vector\n        var distance = Math.sqrt(directionX * directionX + directionY * directionY);\n        // s += \"\\nDistance: \" + distance;\n        var forceX = force * directionX / distance;\n        var forceY = force * directionY / distance;\n    } else {\n        // s += \"\\nNodes do NOT overlap.\";\n        // If there's no overlap, force is inversely proportional\n        // to squared distance\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint(node1, directionX, directionY);\n        var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);\n        // Use clipping points to compute distance\n        var distanceX = point2.x - point1.x;\n        var distanceY = point2.y - point1.y;\n        var distanceSqr = distanceX * distanceX + distanceY * distanceY;\n        var distance = Math.sqrt(distanceSqr);\n        // s += \"\\nDistance: \" + distance;\n        // Compute the module and components of the force vector\n        var force = (node1.nodeRepulsion + node2.nodeRepulsion) / distanceSqr;\n        var forceX = force * distanceX / distance;\n        var forceY = force * distanceY / distance;\n    }\n    // Apply force\n    if (!node1.isLocked) {\n        node1.offsetX -= forceX;\n        node1.offsetY -= forceY;\n    }\n    if (!node2.isLocked) {\n        node2.offsetX += forceX;\n        node2.offsetY += forceY;\n    }\n    // s += \"\\nForceX: \" + forceX + \" ForceY: \" + forceY;\n    // logDebug(s);\n    return;\n};\n/**\n * @brief  : Determines whether two nodes overlap or not\n * @return : Amount of overlapping (0 => no overlap)\n */ var nodesOverlap = function nodesOverlap(node1, node2, dX, dY) {\n    if (dX > 0) {\n        var overlapX = node1.maxX - node2.minX;\n    } else {\n        var overlapX = node2.maxX - node1.minX;\n    }\n    if (dY > 0) {\n        var overlapY = node1.maxY - node2.minY;\n    } else {\n        var overlapY = node2.maxY - node1.minY;\n    }\n    if (overlapX >= 0 && overlapY >= 0) {\n        return Math.sqrt(overlapX * overlapX + overlapY * overlapY);\n    } else {\n        return 0;\n    }\n};\n/**\n * @brief : Finds the point in which an edge (direction dX, dY) intersects\n *          the rectangular bounding box of it's source/target node\n */ var findClippingPoint = function findClippingPoint(node, dX, dY) {\n    // Shorcuts\n    var X = node.positionX;\n    var Y = node.positionY;\n    var H = node.height || 1;\n    var W = node.width || 1;\n    var dirSlope = dY / dX;\n    var nodeSlope = H / W;\n    // var s = 'Computing clipping point of node ' + node.id +\n    //   \" . Height:  \" + H + \", Width: \" + W +\n    //   \"\\nDirection \" + dX + \", \" + dY;\n    //\n    // Compute intersection\n    var res = {};\n    // Case: Vertical direction (up)\n    if (0 === dX && 0 < dY) {\n        res.x = X;\n        // s += \"\\nUp direction\";\n        res.y = Y + H / 2;\n        return res;\n    }\n    // Case: Vertical direction (down)\n    if (0 === dX && 0 > dY) {\n        res.x = X;\n        res.y = Y + H / 2;\n        // s += \"\\nDown direction\";\n        return res;\n    }\n    // Case: Intersects the right border\n    if (0 < dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n        res.x = X + W / 2;\n        res.y = Y + W * dY / 2 / dX;\n        // s += \"\\nRightborder\";\n        return res;\n    }\n    // Case: Intersects the left border\n    if (0 > dX && -1 * nodeSlope <= dirSlope && dirSlope <= nodeSlope) {\n        res.x = X - W / 2;\n        res.y = Y - W * dY / 2 / dX;\n        // s += \"\\nLeftborder\";\n        return res;\n    }\n    // Case: Intersects the top border\n    if (0 < dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n        res.x = X + H * dX / 2 / dY;\n        res.y = Y + H / 2;\n        // s += \"\\nTop border\";\n        return res;\n    }\n    // Case: Intersects the bottom border\n    if (0 > dY && (dirSlope <= -1 * nodeSlope || dirSlope >= nodeSlope)) {\n        res.x = X - H * dX / 2 / dY;\n        res.y = Y - H / 2;\n        // s += \"\\nBottom border\";\n        return res;\n    }\n    // s += \"\\nClipping point found at \" + res.x + \", \" + res.y;\n    // logDebug(s);\n    return res;\n};\n/**\n * @brief : Calculates all edge forces\n */ var calculateEdgeForces = function calculateEdgeForces(layoutInfo, options) {\n    // Iterate over all edges\n    for(var i = 0; i < layoutInfo.edgeSize; i++){\n        // Get edge, source & target nodes\n        var edge = layoutInfo.layoutEdges[i];\n        var sourceIx = layoutInfo.idToIndex[edge.sourceId];\n        var source = layoutInfo.layoutNodes[sourceIx];\n        var targetIx = layoutInfo.idToIndex[edge.targetId];\n        var target = layoutInfo.layoutNodes[targetIx];\n        // Get direction of line connecting both node centers\n        var directionX = target.positionX - source.positionX;\n        var directionY = target.positionY - source.positionY;\n        // If both centers are the same, do nothing.\n        // A random force has already been applied as node repulsion\n        if (0 === directionX && 0 === directionY) {\n            continue;\n        }\n        // Get clipping points for both nodes\n        var point1 = findClippingPoint(source, directionX, directionY);\n        var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);\n        var lx = point2.x - point1.x;\n        var ly = point2.y - point1.y;\n        var l = Math.sqrt(lx * lx + ly * ly);\n        var force = Math.pow(edge.idealLength - l, 2) / edge.elasticity;\n        if (0 !== l) {\n            var forceX = force * lx / l;\n            var forceY = force * ly / l;\n        } else {\n            var forceX = 0;\n            var forceY = 0;\n        }\n        // Add this force to target and source nodes\n        if (!source.isLocked) {\n            source.offsetX += forceX;\n            source.offsetY += forceY;\n        }\n        if (!target.isLocked) {\n            target.offsetX -= forceX;\n            target.offsetY -= forceY;\n        }\n    // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;\n    // s += \"\\nDistance: \" + l + \" Force: (\" + forceX + \", \" + forceY + \")\";\n    // logDebug(s);\n    }\n};\n/**\n * @brief : Computes gravity forces for all nodes\n */ var calculateGravityForces = function calculateGravityForces(layoutInfo, options) {\n    if (options.gravity === 0) {\n        return;\n    }\n    var distThreshold = 1;\n    // var s = 'calculateGravityForces';\n    // logDebug(s);\n    for(var i = 0; i < layoutInfo.graphSet.length; i++){\n        var graph = layoutInfo.graphSet[i];\n        var numNodes = graph.length;\n        // s = \"Set: \" + graph.toString();\n        // logDebug(s);\n        // Compute graph center\n        if (0 === i) {\n            var centerX = layoutInfo.clientHeight / 2;\n            var centerY = layoutInfo.clientWidth / 2;\n        } else {\n            // Get Parent node for this graph, and use its position as center\n            var temp = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];\n            var parent = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];\n            var centerX = parent.positionX;\n            var centerY = parent.positionY;\n        }\n        // s = \"Center found at: \" + centerX + \", \" + centerY;\n        // logDebug(s);\n        // Apply force to all nodes in graph\n        for(var j = 0; j < numNodes; j++){\n            var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];\n            // s = \"Node: \" + node.id;\n            if (node.isLocked) {\n                continue;\n            }\n            var dx = centerX - node.positionX;\n            var dy = centerY - node.positionY;\n            var d = Math.sqrt(dx * dx + dy * dy);\n            if (d > distThreshold) {\n                var fx = options.gravity * dx / d;\n                var fy = options.gravity * dy / d;\n                node.offsetX += fx;\n                node.offsetY += fy;\n            // s += \": Applied force: \" + fx + \", \" + fy;\n            }\n        // logDebug(s);\n        }\n    }\n};\n/**\n * @brief          : This function propagates the existing offsets from\n *                   parent nodes to its descendents.\n * @arg layoutInfo : layoutInfo Object\n * @arg cy         : cytoscape Object\n * @arg options    : Layout options\n */ var propagateForces = function propagateForces(layoutInfo, options) {\n    // Inline implementation of a queue, used for traversing the graph in BFS order\n    var queue = [];\n    var start = 0; // Points to the start the queue\n    var end = -1; // Points to the end of the queue\n    // logDebug('propagateForces');\n    // Start by visiting the nodes in the root graph\n    queue.push.apply(queue, layoutInfo.graphSet[0]);\n    end += layoutInfo.graphSet[0].length;\n    // Traverse the graph, level by level,\n    while(start <= end){\n        // Get the node to visit and remove it from queue\n        var nodeId = queue[start++];\n        var nodeIndex = layoutInfo.idToIndex[nodeId];\n        var node = layoutInfo.layoutNodes[nodeIndex];\n        var children = node.children;\n        // We only need to process the node if it's compound\n        if (0 < children.length && !node.isLocked) {\n            var offX = node.offsetX;\n            var offY = node.offsetY;\n            // var s = \"Propagating offset from parent node : \" + node.id +\n            //   \". OffsetX: \" + offX + \". OffsetY: \" + offY;\n            // s += \"\\n Children: \" + children.toString();\n            // logDebug(s);\n            for(var i = 0; i < children.length; i++){\n                var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];\n                // Propagate offset\n                childNode.offsetX += offX;\n                childNode.offsetY += offY;\n                // Add children to queue to be visited\n                queue[++end] = children[i];\n            }\n            // Reset parent offsets\n            node.offsetX = 0;\n            node.offsetY = 0;\n        }\n    }\n};\n/**\n * @brief : Updates the layout model positions, based on\n *          the accumulated forces\n */ var updatePositions = function updatePositions(layoutInfo, options) {\n    // var s = 'Updating positions';\n    // logDebug(s);\n    // Reset boundaries for compound nodes\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length) {\n            // logDebug(\"Resetting boundaries of compound node: \" + n.id);\n            n.maxX = undefined;\n            n.minX = undefined;\n            n.maxY = undefined;\n            n.minY = undefined;\n        }\n    }\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length || n.isLocked) {\n            continue;\n        }\n        // s = \"Node: \" + n.id + \" Previous position: (\" +\n        // n.positionX + \", \" + n.positionY + \").\";\n        // Limit displacement in order to improve stability\n        var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);\n        n.positionX += tempForce.x;\n        n.positionY += tempForce.y;\n        n.offsetX = 0;\n        n.offsetY = 0;\n        n.minX = n.positionX - n.width;\n        n.maxX = n.positionX + n.width;\n        n.minY = n.positionY - n.height;\n        n.maxY = n.positionY + n.height;\n        // s += \" New Position: (\" + n.positionX + \", \" + n.positionY + \").\";\n        // logDebug(s);\n        // Update ancestry boudaries\n        _updateAncestryBoundaries(n, layoutInfo);\n    }\n    // Update size, position of compund nodes\n    for(var i = 0; i < layoutInfo.nodeSize; i++){\n        var n = layoutInfo.layoutNodes[i];\n        if (0 < n.children.length && !n.isLocked) {\n            n.positionX = (n.maxX + n.minX) / 2;\n            n.positionY = (n.maxY + n.minY) / 2;\n            n.width = n.maxX - n.minX;\n            n.height = n.maxY - n.minY;\n        // s = \"Updating position, size of compound node \" + n.id;\n        // s += \"\\nPositionX: \" + n.positionX + \", PositionY: \" + n.positionY;\n        // s += \"\\nWidth: \" + n.width + \", Height: \" + n.height;\n        // logDebug(s);\n        }\n    }\n};\n/**\n * @brief : Limits a force (forceX, forceY) to be not\n *          greater (in modulo) than max.\n 8          Preserves force direction.\n  */ var limitForce = function limitForce(forceX, forceY, max) {\n    // var s = \"Limiting force: (\" + forceX + \", \" + forceY + \"). Max: \" + max;\n    var force = Math.sqrt(forceX * forceX + forceY * forceY);\n    if (force > max) {\n        var res = {\n            x: max * forceX / force,\n            y: max * forceY / force\n        };\n    } else {\n        var res = {\n            x: forceX,\n            y: forceY\n        };\n    }\n    // s += \".\\nResult: (\" + res.x + \", \" + res.y + \")\";\n    // logDebug(s);\n    return res;\n};\n/**\n * @brief : Function used for keeping track of compound node\n *          sizes, since they should bound all their subnodes.\n */ var _updateAncestryBoundaries = function updateAncestryBoundaries(node, layoutInfo) {\n    // var s = \"Propagating new position/size of node \" + node.id;\n    var parentId = node.parentId;\n    if (null == parentId) {\n        // If there's no parent, we are done\n        // s += \". No parent node.\";\n        // logDebug(s);\n        return;\n    }\n    // Get Parent Node\n    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];\n    var flag = false;\n    // MaxX\n    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {\n        p.maxX = node.maxX + p.padRight;\n        flag = true;\n    // s += \"\\nNew maxX for parent node \" + p.id + \": \" + p.maxX;\n    }\n    // MinX\n    if (null == p.minX || node.minX - p.padLeft < p.minX) {\n        p.minX = node.minX - p.padLeft;\n        flag = true;\n    // s += \"\\nNew minX for parent node \" + p.id + \": \" + p.minX;\n    }\n    // MaxY\n    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {\n        p.maxY = node.maxY + p.padBottom;\n        flag = true;\n    // s += \"\\nNew maxY for parent node \" + p.id + \": \" + p.maxY;\n    }\n    // MinY\n    if (null == p.minY || node.minY - p.padTop < p.minY) {\n        p.minY = node.minY - p.padTop;\n        flag = true;\n    // s += \"\\nNew minY for parent node \" + p.id + \": \" + p.minY;\n    }\n    // If updated boundaries, propagate changes upward\n    if (flag) {\n        // logDebug(s);\n        return _updateAncestryBoundaries(p, layoutInfo);\n    }\n    // s += \". No changes in boundaries/position of parent node \" + p.id;\n    // logDebug(s);\n    return;\n};\nvar separateComponents = function separateComponents(layoutInfo, options) {\n    var nodes = layoutInfo.layoutNodes;\n    var components = [];\n    for(var i = 0; i < nodes.length; i++){\n        var node = nodes[i];\n        var cid = node.cmptId;\n        var component = components[cid] = components[cid] || [];\n        component.push(node);\n    }\n    var totalA = 0;\n    for(var i = 0; i < components.length; i++){\n        var c = components[i];\n        if (!c) {\n            continue;\n        }\n        c.x1 = Infinity;\n        c.x2 = -Infinity;\n        c.y1 = Infinity;\n        c.y2 = -Infinity;\n        for(var j = 0; j < c.length; j++){\n            var n = c[j];\n            c.x1 = Math.min(c.x1, n.positionX - n.width / 2);\n            c.x2 = Math.max(c.x2, n.positionX + n.width / 2);\n            c.y1 = Math.min(c.y1, n.positionY - n.height / 2);\n            c.y2 = Math.max(c.y2, n.positionY + n.height / 2);\n        }\n        c.w = c.x2 - c.x1;\n        c.h = c.y2 - c.y1;\n        totalA += c.w * c.h;\n    }\n    components.sort(function(c1, c2) {\n        return c2.w * c2.h - c1.w * c1.h;\n    });\n    var x = 0;\n    var y = 0;\n    var usedW = 0;\n    var rowH = 0;\n    var maxRowW = Math.sqrt(totalA) * layoutInfo.clientWidth / layoutInfo.clientHeight;\n    for(var i = 0; i < components.length; i++){\n        var c = components[i];\n        if (!c) {\n            continue;\n        }\n        for(var j = 0; j < c.length; j++){\n            var n = c[j];\n            if (!n.isLocked) {\n                n.positionX += x - c.x1;\n                n.positionY += y - c.y1;\n            }\n        }\n        x += c.w + options.componentSpacing;\n        usedW += c.w + options.componentSpacing;\n        rowH = Math.max(rowH, c.h);\n        if (usedW > maxRowW) {\n            y += rowH + options.componentSpacing;\n            x = 0;\n            usedW = 0;\n            rowH = 0;\n        }\n    }\n};\nvar defaults$3 = {\n    fit: true,\n    // whether to fit the viewport to the graph\n    padding: 30,\n    // padding used on fit\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    avoidOverlap: true,\n    // prevents node overlap, may overflow boundingBox if not enough space\n    avoidOverlapPadding: 10,\n    // extra spacing around nodes when avoidOverlap: true\n    nodeDimensionsIncludeLabels: false,\n    // Excludes the label when calculating node bounding boxes for the layout algorithm\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    condense: false,\n    // uses all available space on false, uses minimal space on true\n    rows: undefined,\n    // force num of rows in the grid\n    cols: undefined,\n    // force num of columns in the grid\n    position: function position(node) {},\n    // returns { row, col } for element\n    sort: undefined,\n    // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\nfunction GridLayout(options) {\n    this.options = extend({}, defaults$3, options);\n}\nGridLayout.prototype.run = function() {\n    var params = this.options;\n    var options = params;\n    var cy = params.cy;\n    var eles = options.eles;\n    var nodes = eles.nodes().not(':parent');\n    if (options.sort) {\n        nodes = nodes.sort(options.sort);\n    }\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    if (bb.h === 0 || bb.w === 0) {\n        eles.nodes().layoutPositions(this, options, function(ele) {\n            return {\n                x: bb.x1,\n                y: bb.y1\n            };\n        });\n    } else {\n        // width/height * splits^2 = cells where splits is number of times to split width\n        var cells = nodes.size();\n        var splits = Math.sqrt(cells * bb.h / bb.w);\n        var rows = Math.round(splits);\n        var cols = Math.round(bb.w / bb.h * splits);\n        var small = function small(val) {\n            if (val == null) {\n                return Math.min(rows, cols);\n            } else {\n                var min = Math.min(rows, cols);\n                if (min == rows) {\n                    rows = val;\n                } else {\n                    cols = val;\n                }\n            }\n        };\n        var large = function large(val) {\n            if (val == null) {\n                return Math.max(rows, cols);\n            } else {\n                var max = Math.max(rows, cols);\n                if (max == rows) {\n                    rows = val;\n                } else {\n                    cols = val;\n                }\n            }\n        };\n        var oRows = options.rows;\n        var oCols = options.cols != null ? options.cols : options.columns;\n        // if rows or columns were set in options, use those values\n        if (oRows != null && oCols != null) {\n            rows = oRows;\n            cols = oCols;\n        } else if (oRows != null && oCols == null) {\n            rows = oRows;\n            cols = Math.ceil(cells / rows);\n        } else if (oRows == null && oCols != null) {\n            cols = oCols;\n            rows = Math.ceil(cells / cols);\n        } else if (cols * rows > cells) {\n            var sm = small();\n            var lg = large();\n            // reducing the small side takes away the most cells, so try it first\n            if ((sm - 1) * lg >= cells) {\n                small(sm - 1);\n            } else if ((lg - 1) * sm >= cells) {\n                large(lg - 1);\n            }\n        } else {\n            // if rounding was too low, add rows or columns\n            while(cols * rows < cells){\n                var _sm = small();\n                var _lg = large();\n                // try to add to larger side first (adds less in multiplication)\n                if ((_lg + 1) * _sm >= cells) {\n                    large(_lg + 1);\n                } else {\n                    small(_sm + 1);\n                }\n            }\n        }\n        var cellWidth = bb.w / cols;\n        var cellHeight = bb.h / rows;\n        if (options.condense) {\n            cellWidth = 0;\n            cellHeight = 0;\n        }\n        if (options.avoidOverlap) {\n            for(var i = 0; i < nodes.length; i++){\n                var node = nodes[i];\n                var pos = node._private.position;\n                if (pos.x == null || pos.y == null) {\n                    // for bb\n                    pos.x = 0;\n                    pos.y = 0;\n                }\n                var nbb = node.layoutDimensions(options);\n                var p = options.avoidOverlapPadding;\n                var w = nbb.w + p;\n                var h = nbb.h + p;\n                cellWidth = Math.max(cellWidth, w);\n                cellHeight = Math.max(cellHeight, h);\n            }\n        }\n        var cellUsed = {}; // e.g. 'c-0-2' => true\n        var used = function used(row, col) {\n            return cellUsed['c-' + row + '-' + col] ? true : false;\n        };\n        var use = function use(row, col) {\n            cellUsed['c-' + row + '-' + col] = true;\n        };\n        // to keep track of current cell position\n        var row = 0;\n        var col = 0;\n        var moveToNextCell = function moveToNextCell() {\n            col++;\n            if (col >= cols) {\n                col = 0;\n                row++;\n            }\n        };\n        // get a cache of all the manual positions\n        var id2manPos = {};\n        for(var _i = 0; _i < nodes.length; _i++){\n            var _node = nodes[_i];\n            var rcPos = options.position(_node);\n            if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n                // must have at least row or col def'd\n                var _pos = {\n                    row: rcPos.row,\n                    col: rcPos.col\n                };\n                if (_pos.col === undefined) {\n                    // find unused col\n                    _pos.col = 0;\n                    while(used(_pos.row, _pos.col)){\n                        _pos.col++;\n                    }\n                } else if (_pos.row === undefined) {\n                    // find unused row\n                    _pos.row = 0;\n                    while(used(_pos.row, _pos.col)){\n                        _pos.row++;\n                    }\n                }\n                id2manPos[_node.id()] = _pos;\n                use(_pos.row, _pos.col);\n            }\n        }\n        var getPos = function getPos(element, i) {\n            var x, y;\n            if (element.locked() || element.isParent()) {\n                return false;\n            }\n            // see if we have a manual position set\n            var rcPos = id2manPos[element.id()];\n            if (rcPos) {\n                x = rcPos.col * cellWidth + cellWidth / 2 + bb.x1;\n                y = rcPos.row * cellHeight + cellHeight / 2 + bb.y1;\n            } else {\n                // otherwise set automatically\n                while(used(row, col)){\n                    moveToNextCell();\n                }\n                x = col * cellWidth + cellWidth / 2 + bb.x1;\n                y = row * cellHeight + cellHeight / 2 + bb.y1;\n                use(row, col);\n                moveToNextCell();\n            }\n            return {\n                x: x,\n                y: y\n            };\n        };\n        nodes.layoutPositions(this, options, getPos);\n    }\n    return this; // chaining\n};\n// default layout options\nvar defaults$2 = {\n    ready: function ready() {},\n    // on layoutready\n    stop: function stop() {} // on layoutstop\n};\n// constructor\n// options : object containing layout options\nfunction NullLayout(options) {\n    this.options = extend({}, defaults$2, options);\n}\n// runs the layout\nNullLayout.prototype.run = function() {\n    var options = this.options;\n    var eles = options.eles; // elements to consider in the layout\n    var layout = this;\n    // cy is automatically populated for us in the constructor\n    // (disable eslint for next line as this serves as example layout code to external developers)\n    // eslint-disable-next-line no-unused-vars\n    options.cy;\n    layout.emit('layoutstart');\n    // puts all nodes at (0, 0)\n    // n.b. most layouts would use layoutPositions(), instead of positions() and manual events\n    eles.nodes().positions(function() {\n        return {\n            x: 0,\n            y: 0\n        };\n    });\n    // trigger layoutready when each node has had its position set at least once\n    layout.one('layoutready', options.ready);\n    layout.emit('layoutready');\n    // trigger layoutstop when the layout stops (e.g. finishes)\n    layout.one('layoutstop', options.stop);\n    layout.emit('layoutstop');\n    return this; // chaining\n};\n// called on continuous layouts to stop them before they finish\nNullLayout.prototype.stop = function() {\n    return this; // chaining\n};\nvar defaults$1 = {\n    positions: undefined,\n    // map of (node id) => (position obj); or function(node){ return somPos; }\n    zoom: undefined,\n    // the zoom level to set (prob want fit = false if set)\n    pan: undefined,\n    // the pan level to set (prob want fit = false if set)\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // padding on fit\n    spacingFactor: undefined,\n    // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts\n};\nfunction PresetLayout(options) {\n    this.options = extend({}, defaults$1, options);\n}\nPresetLayout.prototype.run = function() {\n    var options = this.options;\n    var eles = options.eles;\n    var nodes = eles.nodes();\n    var posIsFn = fn$6(options.positions);\n    function getPosition(node) {\n        if (options.positions == null) {\n            return copyPosition(node.position());\n        }\n        if (posIsFn) {\n            return options.positions(node);\n        }\n        var pos = options.positions[node._private.data.id];\n        if (pos == null) {\n            return null;\n        }\n        return pos;\n    }\n    nodes.layoutPositions(this, options, function(node, i) {\n        var position = getPosition(node);\n        if (node.locked() || position == null) {\n            return false;\n        }\n        return position;\n    });\n    return this; // chaining\n};\nvar defaults = {\n    fit: true,\n    // whether to fit to viewport\n    padding: 30,\n    // fit padding\n    boundingBox: undefined,\n    // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }\n    animate: false,\n    // whether to transition the node positions\n    animationDuration: 500,\n    // duration of animation in ms if enabled\n    animationEasing: undefined,\n    // easing of animation if enabled\n    animateFilter: function animateFilter(node, i) {\n        return true;\n    },\n    // a function that determines whether the node should be animated.  All nodes animated by default on animate enabled.  Non-animated nodes are positioned immediately when the layout starts\n    ready: undefined,\n    // callback on layoutready\n    stop: undefined,\n    // callback on layoutstop\n    transform: function transform(node, position) {\n        return position;\n    } // transform a given node position. Useful for changing flow direction in discrete layouts \n};\nfunction RandomLayout(options) {\n    this.options = extend({}, defaults, options);\n}\nRandomLayout.prototype.run = function() {\n    var options = this.options;\n    var cy = options.cy;\n    var eles = options.eles;\n    var bb = makeBoundingBox(options.boundingBox ? options.boundingBox : {\n        x1: 0,\n        y1: 0,\n        w: cy.width(),\n        h: cy.height()\n    });\n    var getPos = function getPos(node, i) {\n        return {\n            x: bb.x1 + Math.round(Math.random() * bb.w),\n            y: bb.y1 + Math.round(Math.random() * bb.h)\n        };\n    };\n    eles.nodes().layoutPositions(this, options, getPos);\n    return this; // chaining\n};\nvar layout = [\n    {\n        name: 'breadthfirst',\n        impl: BreadthFirstLayout\n    },\n    {\n        name: 'circle',\n        impl: CircleLayout\n    },\n    {\n        name: 'concentric',\n        impl: ConcentricLayout\n    },\n    {\n        name: 'cose',\n        impl: CoseLayout\n    },\n    {\n        name: 'grid',\n        impl: GridLayout\n    },\n    {\n        name: 'null',\n        impl: NullLayout\n    },\n    {\n        name: 'preset',\n        impl: PresetLayout\n    },\n    {\n        name: 'random',\n        impl: RandomLayout\n    }\n];\nfunction NullRenderer(options) {\n    this.options = options;\n    this.notifications = 0; // for testing\n}\nvar noop = function noop() {};\nvar throwImgErr = function throwImgErr() {\n    throw new Error('A headless instance can not render images');\n};\nNullRenderer.prototype = {\n    recalculateRenderedStyle: noop,\n    notify: function notify() {\n        this.notifications++;\n    },\n    init: noop,\n    isHeadless: function isHeadless() {\n        return true;\n    },\n    png: throwImgErr,\n    jpg: throwImgErr\n};\nvar BRp$f = {};\nBRp$f.arrowShapeWidth = 0.3;\nBRp$f.registerArrowShapes = function() {\n    var arrowShapes = this.arrowShapes = {};\n    var renderer = this;\n    // Contract for arrow shapes:\n    // 0, 0 is arrow tip\n    // (0, 1) is direction towards node\n    // (1, 0) is right\n    //\n    // functional api:\n    // collide: check x, y in shape\n    // roughCollide: called before collide, no false negatives\n    // draw: draw\n    // spacing: dist(arrowTip, nodeBoundary)\n    // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip\n    var bbCollide = function bbCollide(x, y, size, angle, translation, edgeWidth, padding) {\n        var x1 = translation.x - size / 2 - padding;\n        var x2 = translation.x + size / 2 + padding;\n        var y1 = translation.y - size / 2 - padding;\n        var y2 = translation.y + size / 2 + padding;\n        var inside = x1 <= x && x <= x2 && y1 <= y && y <= y2;\n        return inside;\n    };\n    var transform = function transform(x, y, size, angle, translation) {\n        var xRotated = x * Math.cos(angle) - y * Math.sin(angle);\n        var yRotated = x * Math.sin(angle) + y * Math.cos(angle);\n        var xScaled = xRotated * size;\n        var yScaled = yRotated * size;\n        var xTranslated = xScaled + translation.x;\n        var yTranslated = yScaled + translation.y;\n        return {\n            x: xTranslated,\n            y: yTranslated\n        };\n    };\n    var transformPoints = function transformPoints(pts, size, angle, translation) {\n        var retPts = [];\n        for(var i = 0; i < pts.length; i += 2){\n            var x = pts[i];\n            var y = pts[i + 1];\n            retPts.push(transform(x, y, size, angle, translation));\n        }\n        return retPts;\n    };\n    var pointsToArr = function pointsToArr(pts) {\n        var ret = [];\n        for(var i = 0; i < pts.length; i++){\n            var p = pts[i];\n            ret.push(p.x, p.y);\n        }\n        return ret;\n    };\n    var standardGap = function standardGap(edge) {\n        return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').pfValue * 2;\n    };\n    var defineArrowShape = function defineArrowShape(name, defn) {\n        if (string(defn)) {\n            defn = arrowShapes[defn];\n        }\n        arrowShapes[name] = extend({\n            name: name,\n            points: [\n                -0.15,\n                -0.3,\n                0.15,\n                -0.3,\n                0.15,\n                0.3,\n                -0.15,\n                0.3\n            ],\n            collide: function collide(x, y, size, angle, translation, padding) {\n                var points = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n                var inside = pointInsidePolygonPoints(x, y, points);\n                return inside;\n            },\n            roughCollide: bbCollide,\n            draw: function draw(context, size, angle, translation) {\n                var points = transformPoints(this.points, size, angle, translation);\n                renderer.arrowShapeImpl('polygon')(context, points);\n            },\n            spacing: function spacing(edge) {\n                return 0;\n            },\n            gap: standardGap\n        }, defn);\n    };\n    defineArrowShape('none', {\n        collide: falsify,\n        roughCollide: falsify,\n        draw: noop$1,\n        spacing: zeroify,\n        gap: zeroify\n    });\n    defineArrowShape('triangle', {\n        points: [\n            -0.15,\n            -0.3,\n            0,\n            0,\n            0.15,\n            -0.3\n        ]\n    });\n    defineArrowShape('arrow', 'triangle');\n    defineArrowShape('triangle-backcurve', {\n        points: arrowShapes['triangle'].points,\n        controlPoint: [\n            0,\n            -0.15\n        ],\n        roughCollide: bbCollide,\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var ptsTrans = transformPoints(this.points, size, angle, translation);\n            var ctrlPt = this.controlPoint;\n            var ctrlPtTrans = transform(ctrlPt[0], ctrlPt[1], size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, ptsTrans, ctrlPtTrans);\n        },\n        gap: function gap(edge) {\n            return standardGap(edge) * 0.8;\n        }\n    });\n    defineArrowShape('triangle-tee', {\n        points: [\n            0,\n            0,\n            0.15,\n            -0.3,\n            -0.15,\n            -0.3,\n            0,\n            0\n        ],\n        pointsTee: [\n            -0.15,\n            -0.4,\n            -0.15,\n            -0.5,\n            0.15,\n            -0.5,\n            0.15,\n            -0.4\n        ],\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n            var teePts = pointsToArr(transformPoints(this.pointsTee, size + 2 * padding, angle, translation));\n            var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n            return inside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var triPts = transformPoints(this.points, size, angle, translation);\n            var teePts = transformPoints(this.pointsTee, size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, triPts, teePts);\n        }\n    });\n    defineArrowShape('circle-triangle', {\n        radius: 0.15,\n        pointsTr: [\n            0,\n            -0.15,\n            0.15,\n            -0.45,\n            -0.15,\n            -0.45,\n            0,\n            -0.15\n        ],\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var t = translation;\n            var circleInside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n            return pointInsidePolygonPoints(x, y, triPts) || circleInside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var triPts = transformPoints(this.pointsTr, size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, triPts, translation.x, translation.y, this.radius * size);\n        },\n        spacing: function spacing(edge) {\n            return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n        }\n    });\n    defineArrowShape('triangle-cross', {\n        points: [\n            0,\n            0,\n            0.15,\n            -0.3,\n            -0.15,\n            -0.3,\n            0,\n            0\n        ],\n        baseCrossLinePts: [\n            -0.15,\n            -0.4,\n            // first half of the rectangle\n            -0.15,\n            -0.4,\n            0.15,\n            -0.4,\n            // second half of the rectangle\n            0.15,\n            -0.4\n        ],\n        crossLinePts: function crossLinePts(size, edgeWidth) {\n            // shift points so that the distance between the cross points matches edge width\n            var p = this.baseCrossLinePts.slice();\n            var shiftFactor = edgeWidth / size;\n            var y0 = 3;\n            var y1 = 5;\n            p[y0] = p[y0] - shiftFactor;\n            p[y1] = p[y1] - shiftFactor;\n            return p;\n        },\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var triPts = pointsToArr(transformPoints(this.points, size + 2 * padding, angle, translation));\n            var teePts = pointsToArr(transformPoints(this.crossLinePts(size, edgeWidth), size + 2 * padding, angle, translation));\n            var inside = pointInsidePolygonPoints(x, y, triPts) || pointInsidePolygonPoints(x, y, teePts);\n            return inside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            var triPts = transformPoints(this.points, size, angle, translation);\n            var crossLinePts = transformPoints(this.crossLinePts(size, edgeWidth), size, angle, translation);\n            renderer.arrowShapeImpl(this.name)(context, triPts, crossLinePts);\n        }\n    });\n    defineArrowShape('vee', {\n        points: [\n            -0.15,\n            -0.3,\n            0,\n            0,\n            0.15,\n            -0.3,\n            0,\n            -0.15\n        ],\n        gap: function gap(edge) {\n            return standardGap(edge) * 0.525;\n        }\n    });\n    defineArrowShape('circle', {\n        radius: 0.15,\n        collide: function collide(x, y, size, angle, translation, edgeWidth, padding) {\n            var t = translation;\n            var inside = Math.pow(t.x - x, 2) + Math.pow(t.y - y, 2) <= Math.pow((size + 2 * padding) * this.radius, 2);\n            return inside;\n        },\n        draw: function draw(context, size, angle, translation, edgeWidth) {\n            renderer.arrowShapeImpl(this.name)(context, translation.x, translation.y, this.radius * size);\n        },\n        spacing: function spacing(edge) {\n            return renderer.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.radius;\n        }\n    });\n    defineArrowShape('tee', {\n        points: [\n            -0.15,\n            0,\n            -0.15,\n            -0.1,\n            0.15,\n            -0.1,\n            0.15,\n            0\n        ],\n        spacing: function spacing(edge) {\n            return 1;\n        },\n        gap: function gap(edge) {\n            return 1;\n        }\n    });\n    defineArrowShape('square', {\n        points: [\n            -0.15,\n            0.00,\n            0.15,\n            0.00,\n            0.15,\n            -0.3,\n            -0.15,\n            -0.3\n        ]\n    });\n    defineArrowShape('diamond', {\n        points: [\n            -0.15,\n            -0.15,\n            0,\n            -0.3,\n            0.15,\n            -0.15,\n            0,\n            0\n        ],\n        gap: function gap(edge) {\n            return edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n        }\n    });\n    defineArrowShape('chevron', {\n        points: [\n            0,\n            0,\n            -0.15,\n            -0.15,\n            -0.1,\n            -0.2,\n            0,\n            -0.1,\n            0.1,\n            -0.2,\n            0.15,\n            -0.15\n        ],\n        gap: function gap(edge) {\n            return 0.95 * edge.pstyle('width').pfValue * edge.pstyle('arrow-scale').value;\n        }\n    });\n};\nvar BRp$e = {};\n// Project mouse\nBRp$e.projectIntoViewport = function(clientX, clientY) {\n    var cy = this.cy;\n    var offsets = this.findContainerClientCoords();\n    var offsetLeft = offsets[0];\n    var offsetTop = offsets[1];\n    var scale = offsets[4];\n    var pan = cy.pan();\n    var zoom = cy.zoom();\n    var x = ((clientX - offsetLeft) / scale - pan.x) / zoom;\n    var y = ((clientY - offsetTop) / scale - pan.y) / zoom;\n    return [\n        x,\n        y\n    ];\n};\nBRp$e.findContainerClientCoords = function() {\n    if (this.containerBB) {\n        return this.containerBB;\n    }\n    var container = this.container;\n    var rect = container.getBoundingClientRect();\n    var style = this.cy.window().getComputedStyle(container);\n    var styleValue = function styleValue(name) {\n        return parseFloat(style.getPropertyValue(name));\n    };\n    var padding = {\n        left: styleValue('padding-left'),\n        right: styleValue('padding-right'),\n        top: styleValue('padding-top'),\n        bottom: styleValue('padding-bottom')\n    };\n    var border = {\n        left: styleValue('border-left-width'),\n        right: styleValue('border-right-width'),\n        top: styleValue('border-top-width'),\n        bottom: styleValue('border-bottom-width')\n    };\n    var clientWidth = container.clientWidth;\n    var clientHeight = container.clientHeight;\n    var paddingHor = padding.left + padding.right;\n    var paddingVer = padding.top + padding.bottom;\n    var borderHor = border.left + border.right;\n    var scale = rect.width / (clientWidth + borderHor);\n    var unscaledW = clientWidth - paddingHor;\n    var unscaledH = clientHeight - paddingVer;\n    var left = rect.left + padding.left + border.left;\n    var top = rect.top + padding.top + border.top;\n    return this.containerBB = [\n        left,\n        top,\n        unscaledW,\n        unscaledH,\n        scale\n    ];\n};\nBRp$e.invalidateContainerClientCoordsCache = function() {\n    this.containerBB = null;\n};\nBRp$e.findNearestElement = function(x, y, interactiveElementsOnly, isTouch) {\n    return this.findNearestElements(x, y, interactiveElementsOnly, isTouch)[0];\n};\nBRp$e.findNearestElements = function(x, y, interactiveElementsOnly, isTouch) {\n    var self1 = this;\n    var r = this;\n    var eles = r.getCachedZSortedEles();\n    var near = []; // 1 node max, 1 edge max\n    var zoom = r.cy.zoom();\n    var hasCompounds = r.cy.hasCompoundNodes();\n    var edgeThreshold = (isTouch ? 24 : 8) / zoom;\n    var nodeThreshold = (isTouch ? 8 : 2) / zoom;\n    var labelThreshold = (isTouch ? 8 : 2) / zoom;\n    var minSqDist = Infinity;\n    var nearEdge;\n    var nearNode;\n    if (interactiveElementsOnly) {\n        eles = eles.interactive;\n    }\n    function addEle(ele, sqDist) {\n        if (ele.isNode()) {\n            if (nearNode) {\n                return; // can't replace node\n            } else {\n                nearNode = ele;\n                near.push(ele);\n            }\n        }\n        if (ele.isEdge() && (sqDist == null || sqDist < minSqDist)) {\n            if (nearEdge) {\n                // then replace existing edge\n                // can replace only if same z-index\n                if (nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value && nearEdge.pstyle('z-compound-depth').value === ele.pstyle('z-compound-depth').value) {\n                    for(var i = 0; i < near.length; i++){\n                        if (near[i].isEdge()) {\n                            near[i] = ele;\n                            nearEdge = ele;\n                            minSqDist = sqDist != null ? sqDist : minSqDist;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                near.push(ele);\n                nearEdge = ele;\n                minSqDist = sqDist != null ? sqDist : minSqDist;\n            }\n        }\n    }\n    function checkNode(node) {\n        var width = node.outerWidth() + 2 * nodeThreshold;\n        var height = node.outerHeight() + 2 * nodeThreshold;\n        var hw = width / 2;\n        var hh = height / 2;\n        var pos = node.position();\n        var cornerRadius = node.pstyle('corner-radius').value === 'auto' ? 'auto' : node.pstyle('corner-radius').pfValue;\n        var rs = node._private.rscratch;\n        if (pos.x - hw <= x && x <= pos.x + hw // bb check x\n         && pos.y - hh <= y && y <= pos.y + hh // bb check y\n        ) {\n            var shape = r.nodeShapes[self1.getNodeShape(node)];\n            if (shape.checkPoint(x, y, 0, width, height, pos.x, pos.y, cornerRadius, rs)) {\n                addEle(node, 0);\n                return true;\n            }\n        }\n    }\n    function checkEdge(edge) {\n        var _p = edge._private;\n        var rs = _p.rscratch;\n        var styleWidth = edge.pstyle('width').pfValue;\n        var scale = edge.pstyle('arrow-scale').value;\n        var width = styleWidth / 2 + edgeThreshold; // more like a distance radius from centre\n        var widthSq = width * width;\n        var width2 = width * 2;\n        var src = _p.source;\n        var tgt = _p.target;\n        var sqDist;\n        if (rs.edgeType === 'segments' || rs.edgeType === 'straight' || rs.edgeType === 'haystack') {\n            var pts = rs.allpts;\n            for(var i = 0; i + 3 < pts.length; i += 2){\n                if (inLineVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], width2) && widthSq > (sqDist = sqdistToFiniteLine(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3]))) {\n                    addEle(edge, sqDist);\n                    return true;\n                }\n            }\n        } else if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n            var pts = rs.allpts;\n            for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n                if (inBezierVicinity(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5], width2) && widthSq > (sqDist = sqdistToQuadraticBezier(x, y, pts[i], pts[i + 1], pts[i + 2], pts[i + 3], pts[i + 4], pts[i + 5]))) {\n                    addEle(edge, sqDist);\n                    return true;\n                }\n            }\n        }\n        // if we're close to the edge but didn't hit it, maybe we hit its arrows\n        var src = src || _p.source;\n        var tgt = tgt || _p.target;\n        var arSize = self1.getArrowWidth(styleWidth, scale);\n        var arrows = [\n            {\n                name: 'source',\n                x: rs.arrowStartX,\n                y: rs.arrowStartY,\n                angle: rs.srcArrowAngle\n            },\n            {\n                name: 'target',\n                x: rs.arrowEndX,\n                y: rs.arrowEndY,\n                angle: rs.tgtArrowAngle\n            },\n            {\n                name: 'mid-source',\n                x: rs.midX,\n                y: rs.midY,\n                angle: rs.midsrcArrowAngle\n            },\n            {\n                name: 'mid-target',\n                x: rs.midX,\n                y: rs.midY,\n                angle: rs.midtgtArrowAngle\n            }\n        ];\n        for(var i = 0; i < arrows.length; i++){\n            var ar = arrows[i];\n            var shape = r.arrowShapes[edge.pstyle(ar.name + '-arrow-shape').value];\n            var edgeWidth = edge.pstyle('width').pfValue;\n            if (shape.roughCollide(x, y, arSize, ar.angle, {\n                x: ar.x,\n                y: ar.y\n            }, edgeWidth, edgeThreshold) && shape.collide(x, y, arSize, ar.angle, {\n                x: ar.x,\n                y: ar.y\n            }, edgeWidth, edgeThreshold)) {\n                addEle(edge);\n                return true;\n            }\n        }\n        // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)\n        if (hasCompounds && near.length > 0) {\n            checkNode(src);\n            checkNode(tgt);\n        }\n    }\n    function preprop(obj, name, pre) {\n        return getPrefixedProperty(obj, name, pre);\n    }\n    function checkLabel(ele, prefix) {\n        var _p = ele._private;\n        var th = labelThreshold;\n        var prefixDash;\n        if (prefix) {\n            prefixDash = prefix + '-';\n        } else {\n            prefixDash = '';\n        }\n        ele.boundingBox();\n        var bb = _p.labelBounds[prefix || 'main'];\n        var text = ele.pstyle(prefixDash + 'label').value;\n        var eventsEnabled = ele.pstyle('text-events').strValue === 'yes';\n        if (!eventsEnabled || !text) {\n            return;\n        }\n        var lx = preprop(_p.rscratch, 'labelX', prefix);\n        var ly = preprop(_p.rscratch, 'labelY', prefix);\n        var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n        var ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n        var oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n        var lx1 = bb.x1 - th - ox; // (-ox, -oy) as bb already includes margin\n        var lx2 = bb.x2 + th - ox; // and rotation is about (lx, ly)\n        var ly1 = bb.y1 - th - oy;\n        var ly2 = bb.y2 + th - oy;\n        if (theta) {\n            var cos = Math.cos(theta);\n            var sin = Math.sin(theta);\n            var rotate = function rotate(x, y) {\n                x = x - lx;\n                y = y - ly;\n                return {\n                    x: x * cos - y * sin + lx,\n                    y: x * sin + y * cos + ly\n                };\n            };\n            var px1y1 = rotate(lx1, ly1);\n            var px1y2 = rotate(lx1, ly2);\n            var px2y1 = rotate(lx2, ly1);\n            var px2y2 = rotate(lx2, ly2);\n            var points = [\n                // with the margin added after the rotation is applied\n                px1y1.x + ox,\n                px1y1.y + oy,\n                px2y1.x + ox,\n                px2y1.y + oy,\n                px2y2.x + ox,\n                px2y2.y + oy,\n                px1y2.x + ox,\n                px1y2.y + oy\n            ];\n            if (pointInsidePolygonPoints(x, y, points)) {\n                addEle(ele);\n                return true;\n            }\n        } else {\n            // do a cheaper bb check\n            if (inBoundingBox(bb, x, y)) {\n                addEle(ele);\n                return true;\n            }\n        }\n    }\n    for(var i = eles.length - 1; i >= 0; i--){\n        // reverse order for precedence\n        var ele = eles[i];\n        if (ele.isNode()) {\n            checkNode(ele) || checkLabel(ele);\n        } else {\n            // then edge\n            checkEdge(ele) || checkLabel(ele) || checkLabel(ele, 'source') || checkLabel(ele, 'target');\n        }\n    }\n    return near;\n};\n// 'Give me everything from this box'\nBRp$e.getAllInBox = function(x1, y1, x2, y2) {\n    var eles = this.getCachedZSortedEles().interactive;\n    var zoom = this.cy.zoom();\n    var labelThreshold = 2 / zoom;\n    var box = [];\n    var x1c = Math.min(x1, x2);\n    var x2c = Math.max(x1, x2);\n    var y1c = Math.min(y1, y2);\n    var y2c = Math.max(y1, y2);\n    x1 = x1c;\n    x2 = x2c;\n    y1 = y1c;\n    y2 = y2c;\n    var boxBb = makeBoundingBox({\n        x1: x1,\n        y1: y1,\n        x2: x2,\n        y2: y2\n    });\n    var selectionBox = [\n        {\n            x: boxBb.x1,\n            y: boxBb.y1\n        },\n        {\n            x: boxBb.x2,\n            y: boxBb.y1\n        },\n        {\n            x: boxBb.x2,\n            y: boxBb.y2\n        },\n        {\n            x: boxBb.x1,\n            y: boxBb.y2\n        }\n    ];\n    var boxEdges = [\n        [\n            selectionBox[0],\n            selectionBox[1]\n        ],\n        [\n            selectionBox[1],\n            selectionBox[2]\n        ],\n        [\n            selectionBox[2],\n            selectionBox[3]\n        ],\n        [\n            selectionBox[3],\n            selectionBox[0]\n        ]\n    ];\n    function preprop(obj, name, pre) {\n        return getPrefixedProperty(obj, name, pre);\n    }\n    function getRotatedLabelBox(ele, prefix) {\n        var _p = ele._private;\n        var th = labelThreshold;\n        var prefixDash = '';\n        ele.boundingBox();\n        var bb = _p.labelBounds['main'];\n        // If the bounding box is not available, return null.\n        // This indicates that the label box cannot be calculated, which is consistent\n        // with the expected behavior of this function. Returning null allows the caller\n        // to handle the absence of a bounding box explicitly.\n        if (!bb) {\n            return null;\n        }\n        var lx = preprop(_p.rscratch, 'labelX', prefix);\n        var ly = preprop(_p.rscratch, 'labelY', prefix);\n        var theta = preprop(_p.rscratch, 'labelAngle', prefix);\n        var ox = ele.pstyle(prefixDash + 'text-margin-x').pfValue;\n        var oy = ele.pstyle(prefixDash + 'text-margin-y').pfValue;\n        var lx1 = bb.x1 - th - ox;\n        var lx2 = bb.x2 + th - ox;\n        var ly1 = bb.y1 - th - oy;\n        var ly2 = bb.y2 + th - oy;\n        if (theta) {\n            var cos = Math.cos(theta);\n            var sin = Math.sin(theta);\n            var rotate = function rotate(x, y) {\n                x = x - lx;\n                y = y - ly;\n                return {\n                    x: x * cos - y * sin + lx,\n                    y: x * sin + y * cos + ly\n                };\n            };\n            return [\n                rotate(lx1, ly1),\n                rotate(lx2, ly1),\n                rotate(lx2, ly2),\n                rotate(lx1, ly2)\n            ];\n        } else {\n            return [\n                {\n                    x: lx1,\n                    y: ly1\n                },\n                {\n                    x: lx2,\n                    y: ly1\n                },\n                {\n                    x: lx2,\n                    y: ly2\n                },\n                {\n                    x: lx1,\n                    y: ly2\n                }\n            ];\n        }\n    }\n    function doLinesIntersect(p1, p2, q1, q2) {\n        function ccw(a, b, c) {\n            return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);\n        }\n        return ccw(p1, q1, q2) !== ccw(p2, q1, q2) && ccw(p1, p2, q1) !== ccw(p1, p2, q2);\n    }\n    for(var e = 0; e < eles.length; e++){\n        var ele = eles[e];\n        if (ele.isNode()) {\n            var node = ele;\n            var textEvents = node.pstyle('text-events').strValue === 'yes';\n            var nodeBoxSelectMode = node.pstyle('box-selection').strValue;\n            var labelBoxSelectEnabled = node.pstyle('box-select-labels').strValue === 'yes';\n            if (nodeBoxSelectMode === 'none') {\n                continue;\n            }\n            var includeLabels = (nodeBoxSelectMode === 'overlap' || labelBoxSelectEnabled) && textEvents;\n            var nodeBb = node.boundingBox({\n                includeNodes: true,\n                includeEdges: false,\n                includeLabels: includeLabels\n            });\n            if (nodeBoxSelectMode === 'contain') {\n                var selected = false;\n                if (labelBoxSelectEnabled && textEvents) {\n                    var rotatedLabelBox = getRotatedLabelBox(node);\n                    if (rotatedLabelBox && satPolygonIntersection(rotatedLabelBox, selectionBox)) {\n                        box.push(node);\n                        selected = true;\n                    }\n                }\n                if (!selected && boundingBoxInBoundingBox(boxBb, nodeBb)) {\n                    box.push(node);\n                }\n            } else if (nodeBoxSelectMode === 'overlap') {\n                if (boundingBoxesIntersect(boxBb, nodeBb)) {\n                    var nodeBodyBb = node.boundingBox({\n                        includeNodes: true,\n                        includeEdges: true,\n                        includeLabels: false,\n                        includeMainLabels: false,\n                        includeSourceLabels: false,\n                        includeTargetLabels: false\n                    });\n                    var nodeBodyCorners = [\n                        {\n                            x: nodeBodyBb.x1,\n                            y: nodeBodyBb.y1\n                        },\n                        {\n                            x: nodeBodyBb.x2,\n                            y: nodeBodyBb.y1\n                        },\n                        {\n                            x: nodeBodyBb.x2,\n                            y: nodeBodyBb.y2\n                        },\n                        {\n                            x: nodeBodyBb.x1,\n                            y: nodeBodyBb.y2\n                        }\n                    ];\n                    // if node body intersects, no need to check label\n                    if (satPolygonIntersection(nodeBodyCorners, selectionBox)) {\n                        box.push(node);\n                    } else {\n                        // only check label if node body didn't intersect\n                        var _rotatedLabelBox = getRotatedLabelBox(node);\n                        if (_rotatedLabelBox && satPolygonIntersection(_rotatedLabelBox, selectionBox)) {\n                            box.push(node);\n                        }\n                    }\n                }\n            }\n        } else {\n            var edge = ele;\n            var _p = edge._private;\n            var rs = _p.rscratch;\n            var edgeBoxSelectMode = edge.pstyle('box-selection').strValue;\n            if (edgeBoxSelectMode === 'none') {\n                continue;\n            }\n            if (edgeBoxSelectMode === 'contain') {\n                if (rs.startX != null && rs.startY != null && !inBoundingBox(boxBb, rs.startX, rs.startY)) {\n                    continue;\n                }\n                if (rs.endX != null && rs.endY != null && !inBoundingBox(boxBb, rs.endX, rs.endY)) {\n                    continue;\n                }\n                if (rs.edgeType === 'bezier' || rs.edgeType === 'multibezier' || rs.edgeType === 'self' || rs.edgeType === 'compound' || rs.edgeType === 'segments' || rs.edgeType === 'haystack') {\n                    var pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n                    var allInside = true;\n                    for(var i = 0; i < pts.length; i++){\n                        if (!pointInBoundingBox(boxBb, pts[i])) {\n                            allInside = false;\n                            break;\n                        }\n                    }\n                    if (allInside) {\n                        box.push(edge);\n                    }\n                } else if (rs.edgeType === 'straight') {\n                    box.push(edge);\n                }\n            } else if (edgeBoxSelectMode === 'overlap') {\n                var _selected = false;\n                // Check: either endpoint inside box\n                if (rs.startX != null && rs.startY != null && rs.endX != null && rs.endY != null && (inBoundingBox(boxBb, rs.startX, rs.startY) || inBoundingBox(boxBb, rs.endX, rs.endY))) {\n                    box.push(edge);\n                    _selected = true;\n                } else if (!_selected && rs.edgeType === 'haystack') {\n                    var haystackPts = _p.rstyle.haystackPts;\n                    for(var _i = 0; _i < haystackPts.length; _i++){\n                        if (pointInBoundingBox(boxBb, haystackPts[_i])) {\n                            box.push(edge);\n                            _selected = true;\n                            break;\n                        }\n                    }\n                }\n                // Segment intersection check (only if not already selected)\n                if (!_selected) {\n                    var _pts = _p.rstyle.bezierPts || _p.rstyle.linePts || _p.rstyle.haystackPts;\n                    // straight edges\n                    if ((!_pts || _pts.length < 2) && rs.edgeType === 'straight') {\n                        if (rs.startX != null && rs.startY != null && rs.endX != null && rs.endY != null) {\n                            _pts = [\n                                {\n                                    x: rs.startX,\n                                    y: rs.startY\n                                },\n                                {\n                                    x: rs.endX,\n                                    y: rs.endY\n                                }\n                            ];\n                        }\n                    }\n                    if (!_pts || _pts.length < 2) continue;\n                    for(var _i2 = 0; _i2 < _pts.length - 1; _i2++){\n                        var segStart = _pts[_i2];\n                        var segEnd = _pts[_i2 + 1];\n                        for(var b = 0; b < boxEdges.length; b++){\n                            var _boxEdges$b = _slicedToArray(boxEdges[b], 2), boxStart = _boxEdges$b[0], boxEnd = _boxEdges$b[1];\n                            if (doLinesIntersect(segStart, segEnd, boxStart, boxEnd)) {\n                                box.push(edge);\n                                _selected = true;\n                                break;\n                            }\n                        }\n                        if (_selected) break;\n                    }\n                }\n            }\n        }\n    }\n    return box;\n};\nvar BRp$d = {};\nBRp$d.calculateArrowAngles = function(edge) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === 'haystack';\n    var isBezier = rs.edgeType === 'bezier';\n    var isMultibezier = rs.edgeType === 'multibezier';\n    var isSegments = rs.edgeType === 'segments';\n    var isCompound = rs.edgeType === 'compound';\n    var isSelf = rs.edgeType === 'self';\n    // Displacement gives direction for arrowhead orientation\n    var dispX, dispY;\n    var startX, startY, endX, endY, midX, midY;\n    if (isHaystack) {\n        startX = rs.haystackPts[0];\n        startY = rs.haystackPts[1];\n        endX = rs.haystackPts[2];\n        endY = rs.haystackPts[3];\n    } else {\n        startX = rs.arrowStartX;\n        startY = rs.arrowStartY;\n        endX = rs.arrowEndX;\n        endY = rs.arrowEndY;\n    }\n    midX = rs.midX;\n    midY = rs.midY;\n    // source\n    //\n    if (isSegments) {\n        dispX = startX - rs.segpts[0];\n        dispY = startY - rs.segpts[1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n        var pts = rs.allpts;\n        var bX = qbezierAt(pts[0], pts[2], pts[4], 0.1);\n        var bY = qbezierAt(pts[1], pts[3], pts[5], 0.1);\n        dispX = startX - bX;\n        dispY = startY - bY;\n    } else {\n        dispX = startX - midX;\n        dispY = startY - midY;\n    }\n    rs.srcArrowAngle = getAngleFromDisp(dispX, dispY);\n    // mid target\n    //\n    var midX = rs.midX;\n    var midY = rs.midY;\n    if (isHaystack) {\n        midX = (startX + endX) / 2;\n        midY = (startY + endY) / 2;\n    }\n    dispX = endX - startX;\n    dispY = endY - startY;\n    if (isSegments) {\n        var pts = rs.allpts;\n        if (pts.length / 2 % 2 === 0) {\n            var i2 = pts.length / 2;\n            var i1 = i2 - 2;\n            dispX = pts[i2] - pts[i1];\n            dispY = pts[i2 + 1] - pts[i1 + 1];\n        } else if (rs.isRound) {\n            dispX = rs.midVector[1];\n            dispY = -rs.midVector[0];\n        } else {\n            var i2 = pts.length / 2 - 1;\n            var i1 = i2 - 2;\n            dispX = pts[i2] - pts[i1];\n            dispY = pts[i2 + 1] - pts[i1 + 1];\n        }\n    } else if (isMultibezier || isCompound || isSelf) {\n        var pts = rs.allpts;\n        var cpts = rs.ctrlpts;\n        var bp0x, bp0y;\n        var bp1x, bp1y;\n        if (cpts.length / 2 % 2 === 0) {\n            var p0 = pts.length / 2 - 1; // startpt\n            var ic = p0 + 2;\n            var p1 = ic + 2;\n            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0);\n            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0);\n            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.0001);\n            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.0001);\n        } else {\n            var ic = pts.length / 2 - 1; // ctrpt\n            var p0 = ic - 2; // startpt\n            var p1 = ic + 2; // endpt\n            bp0x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.4999);\n            bp0y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.4999);\n            bp1x = qbezierAt(pts[p0], pts[ic], pts[p1], 0.5);\n            bp1y = qbezierAt(pts[p0 + 1], pts[ic + 1], pts[p1 + 1], 0.5);\n        }\n        dispX = bp1x - bp0x;\n        dispY = bp1y - bp0y;\n    }\n    rs.midtgtArrowAngle = getAngleFromDisp(dispX, dispY);\n    rs.midDispX = dispX;\n    rs.midDispY = dispY;\n    // mid source\n    //\n    dispX *= -1;\n    dispY *= -1;\n    if (isSegments) {\n        var pts = rs.allpts;\n        if (pts.length / 2 % 2 === 0) ;\n        else if (!rs.isRound) {\n            var i2 = pts.length / 2 - 1;\n            var i3 = i2 + 2;\n            dispX = -(pts[i3] - pts[i2]);\n            dispY = -(pts[i3 + 1] - pts[i2 + 1]);\n        }\n    }\n    rs.midsrcArrowAngle = getAngleFromDisp(dispX, dispY);\n    // target\n    //\n    if (isSegments) {\n        dispX = endX - rs.segpts[rs.segpts.length - 2];\n        dispY = endY - rs.segpts[rs.segpts.length - 1];\n    } else if (isMultibezier || isCompound || isSelf || isBezier) {\n        var pts = rs.allpts;\n        var l = pts.length;\n        var bX = qbezierAt(pts[l - 6], pts[l - 4], pts[l - 2], 0.9);\n        var bY = qbezierAt(pts[l - 5], pts[l - 3], pts[l - 1], 0.9);\n        dispX = endX - bX;\n        dispY = endY - bY;\n    } else {\n        dispX = endX - midX;\n        dispY = endY - midY;\n    }\n    rs.tgtArrowAngle = getAngleFromDisp(dispX, dispY);\n};\nBRp$d.getArrowWidth = BRp$d.getArrowHeight = function(edgeWidth, scale) {\n    var cache = this.arrowWidthCache = this.arrowWidthCache || {};\n    var cachedVal = cache[edgeWidth + ', ' + scale];\n    if (cachedVal) {\n        return cachedVal;\n    }\n    cachedVal = Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29) * scale;\n    cache[edgeWidth + ', ' + scale] = cachedVal;\n    return cachedVal;\n};\n/**\n * Explained by Blindman67 at https://stackoverflow.com/a/44856925/11028828\n */ // Declare reused variable to avoid reallocating variables every time the function is called\nvar x, y, v1 = {}, v2 = {}, sinA, sinA90, radDirection, drawDirection, angle, halfAngle, cRadius, lenOut, radius, limit;\nvar startX, startY, stopX, stopY;\nvar lastPoint;\n// convert 2 points into vector form, polar form, and normalised\nvar asVec = function asVec(p, pp, v) {\n    v.x = pp.x - p.x;\n    v.y = pp.y - p.y;\n    v.len = Math.sqrt(v.x * v.x + v.y * v.y);\n    v.nx = v.x / v.len;\n    v.ny = v.y / v.len;\n    v.ang = Math.atan2(v.ny, v.nx);\n};\nvar invertVec = function invertVec(originalV, invertedV) {\n    invertedV.x = originalV.x * -1;\n    invertedV.y = originalV.y * -1;\n    invertedV.nx = originalV.nx * -1;\n    invertedV.ny = originalV.ny * -1;\n    invertedV.ang = originalV.ang > 0 ? -(Math.PI - originalV.ang) : Math.PI + originalV.ang;\n};\nvar calcCornerArc = function calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius) {\n    //-----------------------------------------\n    // Part 1\n    previousPoint !== lastPoint ? asVec(currentPoint, previousPoint, v1) : invertVec(v2, v1); // Avoid recalculating vec if it is the invert of the last one calculated\n    asVec(currentPoint, nextPoint, v2);\n    sinA = v1.nx * v2.ny - v1.ny * v2.nx;\n    sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;\n    angle = Math.asin(Math.max(-1, Math.min(1, sinA)));\n    if (Math.abs(angle) < 1e-6) {\n        x = currentPoint.x;\n        y = currentPoint.y;\n        cRadius = radius = 0;\n        return;\n    }\n    //-----------------------------------------\n    radDirection = 1;\n    drawDirection = false;\n    if (sinA90 < 0) {\n        if (angle < 0) {\n            angle = Math.PI + angle;\n        } else {\n            angle = Math.PI - angle;\n            radDirection = -1;\n            drawDirection = true;\n        }\n    } else {\n        if (angle > 0) {\n            radDirection = -1;\n            drawDirection = true;\n        }\n    }\n    if (currentPoint.radius !== undefined) {\n        radius = currentPoint.radius;\n    } else {\n        radius = radiusMax;\n    }\n    //-----------------------------------------\n    // Part 2\n    halfAngle = angle / 2;\n    //-----------------------------------------\n    limit = Math.min(v1.len / 2, v2.len / 2);\n    if (isArcRadius) {\n        //-----------------------------------------\n        // Part 3\n        lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));\n        //-----------------------------------------\n        // Special part A\n        if (lenOut > limit) {\n            lenOut = limit;\n            cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n        } else {\n            cRadius = radius;\n        }\n    } else {\n        lenOut = Math.min(limit, radius);\n        cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));\n    }\n    //-----------------------------------------\n    //-----------------------------------------\n    // Part 4\n    stopX = currentPoint.x + v2.nx * lenOut;\n    stopY = currentPoint.y + v2.ny * lenOut;\n    //-----------------------------------------\n    // Part 5\n    x = stopX - v2.ny * cRadius * radDirection;\n    y = stopY + v2.nx * cRadius * radDirection;\n    //-----------------------------------------\n    // Additional Part : calculate start point E\n    startX = currentPoint.x + v1.nx * lenOut;\n    startY = currentPoint.y + v1.ny * lenOut;\n    // Save last point to avoid recalculating vector when not needed\n    lastPoint = currentPoint;\n};\n/**\n * Draw corner provided by {@link getRoundCorner}\n *\n * @param ctx :CanvasRenderingContext2D\n * @param roundCorner {{cx:number, cy:number, radius:number, endAngle: number, startAngle: number, counterClockwise: boolean}}\n */ function drawPreparedRoundCorner(ctx, roundCorner) {\n    if (roundCorner.radius === 0) ctx.lineTo(roundCorner.cx, roundCorner.cy);\n    else ctx.arc(roundCorner.cx, roundCorner.cy, roundCorner.radius, roundCorner.startAngle, roundCorner.endAngle, roundCorner.counterClockwise);\n}\n/**\n * Get round corner from a point and its previous and next neighbours in a path\n *\n * @param previousPoint {{x: number, y:number, radius: number?}}\n * @param currentPoint {{x: number, y:number, radius: number?}}\n * @param nextPoint {{x: number, y:number, radius: number?}}\n * @param radiusMax :number\n * @param isArcRadius :boolean\n * @return {{\n * cx:number, cy:number, radius:number,\n * startX:number, startY:number,\n * stopX:number, stopY: number,\n * endAngle: number, startAngle: number, counterClockwise: boolean\n * }}\n */ function getRoundCorner(previousPoint, currentPoint, nextPoint, radiusMax) {\n    var isArcRadius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    if (radiusMax === 0 || currentPoint.radius === 0) return {\n        cx: currentPoint.x,\n        cy: currentPoint.y,\n        radius: 0,\n        startX: currentPoint.x,\n        startY: currentPoint.y,\n        stopX: currentPoint.x,\n        stopY: currentPoint.y,\n        startAngle: undefined,\n        endAngle: undefined,\n        counterClockwise: undefined\n    };\n    calcCornerArc(previousPoint, currentPoint, nextPoint, radiusMax, isArcRadius);\n    return {\n        cx: x,\n        cy: y,\n        radius: cRadius,\n        startX: startX,\n        startY: startY,\n        stopX: stopX,\n        stopY: stopY,\n        startAngle: v1.ang + Math.PI / 2 * radDirection,\n        endAngle: v2.ang - Math.PI / 2 * radDirection,\n        counterClockwise: drawDirection\n    };\n}\nvar AVOID_IMPOSSIBLE_BEZIER_CONSTANT = 0.01;\nvar AVOID_IMPOSSIBLE_BEZIER_CONSTANT_L = Math.sqrt(2 * AVOID_IMPOSSIBLE_BEZIER_CONSTANT);\nvar BRp$c = {};\nBRp$c.findMidptPtsEtc = function(edge, pairInfo) {\n    var posPts = pairInfo.posPts, intersectionPts = pairInfo.intersectionPts, vectorNormInverse = pairInfo.vectorNormInverse;\n    var midptPts;\n    // n.b. assumes all edges in bezier bundle have same endpoints specified\n    var srcManEndpt = edge.pstyle('source-endpoint');\n    var tgtManEndpt = edge.pstyle('target-endpoint');\n    var haveManualEndPts = srcManEndpt.units != null && tgtManEndpt.units != null;\n    var recalcVectorNormInverse = function recalcVectorNormInverse(x1, y1, x2, y2) {\n        var dy = y2 - y1;\n        var dx = x2 - x1;\n        var l = Math.sqrt(dx * dx + dy * dy);\n        return {\n            x: -dy / l,\n            y: dx / l\n        };\n    };\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    switch(edgeDistances){\n        case 'node-position':\n            midptPts = posPts;\n            break;\n        case 'intersection':\n            midptPts = intersectionPts;\n            break;\n        case 'endpoints':\n            {\n                if (haveManualEndPts) {\n                    var _this$manualEndptToPx = this.manualEndptToPx(edge.source()[0], srcManEndpt), _this$manualEndptToPx2 = _slicedToArray(_this$manualEndptToPx, 2), x1 = _this$manualEndptToPx2[0], y1 = _this$manualEndptToPx2[1];\n                    var _this$manualEndptToPx3 = this.manualEndptToPx(edge.target()[0], tgtManEndpt), _this$manualEndptToPx4 = _slicedToArray(_this$manualEndptToPx3, 2), x2 = _this$manualEndptToPx4[0], y2 = _this$manualEndptToPx4[1];\n                    var endPts = {\n                        x1: x1,\n                        y1: y1,\n                        x2: x2,\n                        y2: y2\n                    };\n                    vectorNormInverse = recalcVectorNormInverse(x1, y1, x2, y2);\n                    midptPts = endPts;\n                } else {\n                    warn(\"Edge \".concat(edge.id(), \" has edge-distances:endpoints specified without manual endpoints specified via source-endpoint and target-endpoint.  Falling back on edge-distances:intersection (default).\"));\n                    midptPts = intersectionPts; // back to default\n                }\n                break;\n            }\n    }\n    return {\n        midptPts: midptPts,\n        vectorNormInverse: vectorNormInverse\n    };\n};\nBRp$c.findHaystackPoints = function(edges) {\n    for(var i = 0; i < edges.length; i++){\n        var edge = edges[i];\n        var _p = edge._private;\n        var rs = _p.rscratch;\n        if (!rs.haystack) {\n            var angle = Math.random() * 2 * Math.PI;\n            rs.source = {\n                x: Math.cos(angle),\n                y: Math.sin(angle)\n            };\n            angle = Math.random() * 2 * Math.PI;\n            rs.target = {\n                x: Math.cos(angle),\n                y: Math.sin(angle)\n            };\n        }\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcPos = src.position();\n        var tgtPos = tgt.position();\n        var srcW = src.width();\n        var tgtW = tgt.width();\n        var srcH = src.height();\n        var tgtH = tgt.height();\n        var radius = edge.pstyle('haystack-radius').value;\n        var halfRadius = radius / 2; // b/c have to half width/height\n        rs.haystackPts = rs.allpts = [\n            rs.source.x * srcW * halfRadius + srcPos.x,\n            rs.source.y * srcH * halfRadius + srcPos.y,\n            rs.target.x * tgtW * halfRadius + tgtPos.x,\n            rs.target.y * tgtH * halfRadius + tgtPos.y\n        ];\n        rs.midX = (rs.allpts[0] + rs.allpts[2]) / 2;\n        rs.midY = (rs.allpts[1] + rs.allpts[3]) / 2;\n        // always override as haystack in case set to different type previously\n        rs.edgeType = 'haystack';\n        rs.haystack = true;\n        this.storeEdgeProjections(edge);\n        this.calculateArrowAngles(edge);\n        this.recalculateEdgeLabelProjections(edge);\n        this.calculateLabelAngles(edge);\n    }\n};\nBRp$c.findSegmentsPoints = function(edge, pairInfo) {\n    // Segments (multiple straight lines)\n    var rs = edge._private.rscratch;\n    var segmentWs = edge.pstyle('segment-weights');\n    var segmentDs = edge.pstyle('segment-distances');\n    var segmentRs = edge.pstyle('segment-radii');\n    var segmentTs = edge.pstyle('radius-type');\n    var segmentsN = Math.min(segmentWs.pfValue.length, segmentDs.pfValue.length);\n    var lastRadius = segmentRs.pfValue[segmentRs.pfValue.length - 1];\n    var lastRadiusType = segmentTs.pfValue[segmentTs.pfValue.length - 1];\n    rs.edgeType = 'segments';\n    rs.segpts = [];\n    rs.radii = [];\n    rs.isArcRadius = [];\n    for(var s = 0; s < segmentsN; s++){\n        var w = segmentWs.pfValue[s];\n        var d = segmentDs.pfValue[s];\n        var w1 = 1 - w;\n        var w2 = w;\n        var _this$findMidptPtsEtc = this.findMidptPtsEtc(edge, pairInfo), midptPts = _this$findMidptPtsEtc.midptPts, vectorNormInverse = _this$findMidptPtsEtc.vectorNormInverse;\n        var adjustedMidpt = {\n            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n            y: midptPts.y1 * w1 + midptPts.y2 * w2\n        };\n        rs.segpts.push(adjustedMidpt.x + vectorNormInverse.x * d, adjustedMidpt.y + vectorNormInverse.y * d);\n        rs.radii.push(segmentRs.pfValue[s] !== undefined ? segmentRs.pfValue[s] : lastRadius);\n        rs.isArcRadius.push((segmentTs.pfValue[s] !== undefined ? segmentTs.pfValue[s] : lastRadiusType) === 'arc-radius');\n    }\n};\nBRp$c.findLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {\n    // Self-edge\n    var rs = edge._private.rscratch;\n    var dirCounts = pairInfo.dirCounts, srcPos = pairInfo.srcPos;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var loopDir = edge.pstyle('loop-direction').pfValue;\n    var loopSwp = edge.pstyle('loop-sweep').pfValue;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    rs.edgeType = 'self';\n    var j = i;\n    var loopDist = stepSize;\n    if (edgeIsUnbundled) {\n        j = 0;\n        loopDist = ctrlptDist;\n    }\n    var loopAngle = loopDir - Math.PI / 2;\n    var outAngle = loopAngle - loopSwp / 2;\n    var inAngle = loopAngle + loopSwp / 2;\n    // increase by step size for overlapping loops, keyed on direction and sweep values\n    var dc = String(loopDir + '_' + loopSwp);\n    j = dirCounts[dc] === undefined ? dirCounts[dc] = 0 : ++dirCounts[dc];\n    rs.ctrlpts = [\n        srcPos.x + Math.cos(outAngle) * 1.4 * loopDist * (j / 3 + 1),\n        srcPos.y + Math.sin(outAngle) * 1.4 * loopDist * (j / 3 + 1),\n        srcPos.x + Math.cos(inAngle) * 1.4 * loopDist * (j / 3 + 1),\n        srcPos.y + Math.sin(inAngle) * 1.4 * loopDist * (j / 3 + 1)\n    ];\n};\nBRp$c.findCompoundLoopPoints = function(edge, pairInfo, i, edgeIsUnbundled) {\n    // Compound edge\n    var rs = edge._private.rscratch;\n    rs.edgeType = 'compound';\n    var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var j = i;\n    var loopDist = stepSize;\n    if (edgeIsUnbundled) {\n        j = 0;\n        loopDist = ctrlptDist;\n    }\n    var loopW = 50;\n    var loopaPos = {\n        x: srcPos.x - srcW / 2,\n        y: srcPos.y - srcH / 2\n    };\n    var loopbPos = {\n        x: tgtPos.x - tgtW / 2,\n        y: tgtPos.y - tgtH / 2\n    };\n    var loopPos = {\n        x: Math.min(loopaPos.x, loopbPos.x),\n        y: Math.min(loopaPos.y, loopbPos.y)\n    };\n    // avoids cases with impossible beziers\n    var minCompoundStretch = 0.5;\n    var compoundStretchA = Math.max(minCompoundStretch, Math.log(srcW * AVOID_IMPOSSIBLE_BEZIER_CONSTANT));\n    var compoundStretchB = Math.max(minCompoundStretch, Math.log(tgtW * AVOID_IMPOSSIBLE_BEZIER_CONSTANT));\n    rs.ctrlpts = [\n        loopPos.x,\n        loopPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchA,\n        loopPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * compoundStretchB,\n        loopPos.y\n    ];\n};\nBRp$c.findStraightEdgePoints = function(edge) {\n    // Straight edge within bundle\n    edge._private.rscratch.edgeType = 'straight';\n};\nBRp$c.findBezierPoints = function(edge, pairInfo, i, edgeIsUnbundled, edgeIsSwapped) {\n    var rs = edge._private.rscratch;\n    var stepSize = edge.pstyle('control-point-step-size').pfValue;\n    var ctrlptDists = edge.pstyle('control-point-distances');\n    var ctrlptWs = edge.pstyle('control-point-weights');\n    var bezierN = ctrlptDists && ctrlptWs ? Math.min(ctrlptDists.value.length, ctrlptWs.value.length) : 1;\n    var ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[0] : undefined;\n    var ctrlptWeight = ctrlptWs.value[0];\n    // (Multi)bezier\n    var multi = edgeIsUnbundled;\n    rs.edgeType = multi ? 'multibezier' : 'bezier';\n    rs.ctrlpts = [];\n    for(var b = 0; b < bezierN; b++){\n        var normctrlptDist = (0.5 - pairInfo.eles.length / 2 + i) * stepSize * (edgeIsSwapped ? -1 : 1);\n        var manctrlptDist = undefined;\n        var sign = signum(normctrlptDist);\n        if (multi) {\n            ctrlptDist = ctrlptDists ? ctrlptDists.pfValue[b] : stepSize; // fall back on step size\n            ctrlptWeight = ctrlptWs.value[b];\n        }\n        if (edgeIsUnbundled) {\n            // multi or single unbundled\n            manctrlptDist = ctrlptDist;\n        } else {\n            manctrlptDist = ctrlptDist !== undefined ? sign * ctrlptDist : undefined;\n        }\n        var distanceFromMidpoint = manctrlptDist !== undefined ? manctrlptDist : normctrlptDist;\n        var w1 = 1 - ctrlptWeight;\n        var w2 = ctrlptWeight;\n        var _this$findMidptPtsEtc2 = this.findMidptPtsEtc(edge, pairInfo), midptPts = _this$findMidptPtsEtc2.midptPts, vectorNormInverse = _this$findMidptPtsEtc2.vectorNormInverse;\n        var adjustedMidpt = {\n            x: midptPts.x1 * w1 + midptPts.x2 * w2,\n            y: midptPts.y1 * w1 + midptPts.y2 * w2\n        };\n        rs.ctrlpts.push(adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint, adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint);\n    }\n};\nBRp$c.findTaxiPoints = function(edge, pairInfo) {\n    // Taxicab geometry with two turns maximum\n    var rs = edge._private.rscratch;\n    rs.edgeType = 'segments';\n    var VERTICAL = 'vertical';\n    var HORIZONTAL = 'horizontal';\n    var LEFTWARD = 'leftward';\n    var RIGHTWARD = 'rightward';\n    var DOWNWARD = 'downward';\n    var UPWARD = 'upward';\n    var AUTO = 'auto';\n    var posPts = pairInfo.posPts, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH;\n    var edgeDistances = edge.pstyle('edge-distances').value;\n    var dIncludesNodeBody = edgeDistances !== 'node-position';\n    var taxiDir = edge.pstyle('taxi-direction').value;\n    var rawTaxiDir = taxiDir; // unprocessed value\n    var taxiTurn = edge.pstyle('taxi-turn');\n    var turnIsPercent = taxiTurn.units === '%';\n    var taxiTurnPfVal = taxiTurn.pfValue;\n    var turnIsNegative = taxiTurnPfVal < 0; // i.e. from target side\n    var minD = edge.pstyle('taxi-turn-min-distance').pfValue;\n    var dw = dIncludesNodeBody ? (srcW + tgtW) / 2 : 0;\n    var dh = dIncludesNodeBody ? (srcH + tgtH) / 2 : 0;\n    var pdx = posPts.x2 - posPts.x1;\n    var pdy = posPts.y2 - posPts.y1;\n    // take away the effective w/h from the magnitude of the delta value\n    var subDWH = function subDWH(dxy, dwh) {\n        if (dxy > 0) {\n            return Math.max(dxy - dwh, 0);\n        } else {\n            return Math.min(dxy + dwh, 0);\n        }\n    };\n    var dx = subDWH(pdx, dw);\n    var dy = subDWH(pdy, dh);\n    var isExplicitDir = false;\n    if (rawTaxiDir === AUTO) {\n        taxiDir = Math.abs(dx) > Math.abs(dy) ? HORIZONTAL : VERTICAL;\n    } else if (rawTaxiDir === UPWARD || rawTaxiDir === DOWNWARD) {\n        taxiDir = VERTICAL;\n        isExplicitDir = true;\n    } else if (rawTaxiDir === LEFTWARD || rawTaxiDir === RIGHTWARD) {\n        taxiDir = HORIZONTAL;\n        isExplicitDir = true;\n    }\n    var isVert = taxiDir === VERTICAL;\n    var l = isVert ? dy : dx;\n    var pl = isVert ? pdy : pdx;\n    var sgnL = signum(pl);\n    var forcedDir = false;\n    if (!(isExplicitDir && (turnIsPercent || turnIsNegative) // forcing in this case would cause weird growing in the opposite direction\n    ) && (rawTaxiDir === DOWNWARD && pl < 0 || rawTaxiDir === UPWARD && pl > 0 || rawTaxiDir === LEFTWARD && pl > 0 || rawTaxiDir === RIGHTWARD && pl < 0)) {\n        sgnL *= -1;\n        l = sgnL * Math.abs(l);\n        forcedDir = true;\n    }\n    var d;\n    if (turnIsPercent) {\n        var p = taxiTurnPfVal < 0 ? 1 + taxiTurnPfVal : taxiTurnPfVal;\n        d = p * l;\n    } else {\n        var k = taxiTurnPfVal < 0 ? l : 0;\n        d = k + taxiTurnPfVal * sgnL;\n    }\n    var getIsTooClose = function getIsTooClose(d) {\n        return Math.abs(d) < minD || Math.abs(d) >= Math.abs(l);\n    };\n    var isTooCloseSrc = getIsTooClose(d);\n    var isTooCloseTgt = getIsTooClose(Math.abs(l) - Math.abs(d));\n    var isTooClose = isTooCloseSrc || isTooCloseTgt;\n    if (isTooClose && !forcedDir) {\n        // non-ideal routing\n        if (isVert) {\n            // vertical fallbacks\n            var lShapeInsideSrc = Math.abs(pl) <= srcH / 2;\n            var lShapeInsideTgt = Math.abs(pdx) <= tgtW / 2;\n            if (lShapeInsideSrc) {\n                // horizontal Z-shape (direction not respected)\n                var x = (posPts.x1 + posPts.x2) / 2;\n                var y1 = posPts.y1, y2 = posPts.y2;\n                rs.segpts = [\n                    x,\n                    y1,\n                    x,\n                    y2\n                ];\n            } else if (lShapeInsideTgt) {\n                // vertical Z-shape (distance not respected)\n                var y = (posPts.y1 + posPts.y2) / 2;\n                var x1 = posPts.x1, x2 = posPts.x2;\n                rs.segpts = [\n                    x1,\n                    y,\n                    x2,\n                    y\n                ];\n            } else {\n                // L-shape fallback (turn distance not respected, but works well with tree siblings)\n                rs.segpts = [\n                    posPts.x1,\n                    posPts.y2\n                ];\n            }\n        } else {\n            // horizontal fallbacks\n            var _lShapeInsideSrc = Math.abs(pl) <= srcW / 2;\n            var _lShapeInsideTgt = Math.abs(pdy) <= tgtH / 2;\n            if (_lShapeInsideSrc) {\n                // vertical Z-shape (direction not respected)\n                var _y = (posPts.y1 + posPts.y2) / 2;\n                var _x = posPts.x1, _x2 = posPts.x2;\n                rs.segpts = [\n                    _x,\n                    _y,\n                    _x2,\n                    _y\n                ];\n            } else if (_lShapeInsideTgt) {\n                // horizontal Z-shape (turn distance not respected)\n                var _x3 = (posPts.x1 + posPts.x2) / 2;\n                var _y2 = posPts.y1, _y3 = posPts.y2;\n                rs.segpts = [\n                    _x3,\n                    _y2,\n                    _x3,\n                    _y3\n                ];\n            } else {\n                // L-shape (turn distance not respected, but works well for tree siblings)\n                rs.segpts = [\n                    posPts.x2,\n                    posPts.y1\n                ];\n            }\n        }\n    } else {\n        // ideal routing\n        if (isVert) {\n            var _y4 = posPts.y1 + d + (dIncludesNodeBody ? srcH / 2 * sgnL : 0);\n            var _x4 = posPts.x1, _x5 = posPts.x2;\n            rs.segpts = [\n                _x4,\n                _y4,\n                _x5,\n                _y4\n            ];\n        } else {\n            // horizontal\n            var _x6 = posPts.x1 + d + (dIncludesNodeBody ? srcW / 2 * sgnL : 0);\n            var _y5 = posPts.y1, _y6 = posPts.y2;\n            rs.segpts = [\n                _x6,\n                _y5,\n                _x6,\n                _y6\n            ];\n        }\n    }\n    if (rs.isRound) {\n        var radius = edge.pstyle('taxi-radius').value;\n        var isArcRadius = edge.pstyle('radius-type').value[0] === 'arc-radius';\n        rs.radii = new Array(rs.segpts.length / 2).fill(radius);\n        rs.isArcRadius = new Array(rs.segpts.length / 2).fill(isArcRadius);\n    }\n};\nBRp$c.tryToCorrectInvalidPoints = function(edge, pairInfo) {\n    var rs = edge._private.rscratch;\n    // can only correct beziers for now...\n    if (rs.edgeType === 'bezier') {\n        var srcPos = pairInfo.srcPos, tgtPos = pairInfo.tgtPos, srcW = pairInfo.srcW, srcH = pairInfo.srcH, tgtW = pairInfo.tgtW, tgtH = pairInfo.tgtH, srcShape = pairInfo.srcShape, tgtShape = pairInfo.tgtShape, srcCornerRadius = pairInfo.srcCornerRadius, tgtCornerRadius = pairInfo.tgtCornerRadius, srcRs = pairInfo.srcRs, tgtRs = pairInfo.tgtRs;\n        var badStart = !number$1(rs.startX) || !number$1(rs.startY);\n        var badAStart = !number$1(rs.arrowStartX) || !number$1(rs.arrowStartY);\n        var badEnd = !number$1(rs.endX) || !number$1(rs.endY);\n        var badAEnd = !number$1(rs.arrowEndX) || !number$1(rs.arrowEndY);\n        var minCpADistFactor = 3;\n        var arrowW = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n        var minCpADist = minCpADistFactor * arrowW;\n        var startACpDist = dist({\n            x: rs.ctrlpts[0],\n            y: rs.ctrlpts[1]\n        }, {\n            x: rs.startX,\n            y: rs.startY\n        });\n        var closeStartACp = startACpDist < minCpADist;\n        var endACpDist = dist({\n            x: rs.ctrlpts[0],\n            y: rs.ctrlpts[1]\n        }, {\n            x: rs.endX,\n            y: rs.endY\n        });\n        var closeEndACp = endACpDist < minCpADist;\n        var overlapping = false;\n        if (badStart || badAStart || closeStartACp) {\n            overlapping = true;\n            // project control point along line from src centre to outside the src shape\n            // (otherwise intersection will yield nothing)\n            var cpD = {\n                // delta\n                x: rs.ctrlpts[0] - srcPos.x,\n                y: rs.ctrlpts[1] - srcPos.y\n            };\n            var cpL = Math.sqrt(cpD.x * cpD.x + cpD.y * cpD.y); // length of line\n            var cpM = {\n                // normalised delta\n                x: cpD.x / cpL,\n                y: cpD.y / cpL\n            };\n            var radius = Math.max(srcW, srcH);\n            var cpProj = {\n                // *2 radius guarantees outside shape\n                x: rs.ctrlpts[0] + cpM.x * 2 * radius,\n                y: rs.ctrlpts[1] + cpM.y * 2 * radius\n            };\n            var srcCtrlPtIntn = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, cpProj.x, cpProj.y, 0, srcCornerRadius, srcRs);\n            if (closeStartACp) {\n                rs.ctrlpts[0] = rs.ctrlpts[0] + cpM.x * (minCpADist - startACpDist);\n                rs.ctrlpts[1] = rs.ctrlpts[1] + cpM.y * (minCpADist - startACpDist);\n            } else {\n                rs.ctrlpts[0] = srcCtrlPtIntn[0] + cpM.x * minCpADist;\n                rs.ctrlpts[1] = srcCtrlPtIntn[1] + cpM.y * minCpADist;\n            }\n        }\n        if (badEnd || badAEnd || closeEndACp) {\n            overlapping = true;\n            // project control point along line from tgt centre to outside the tgt shape\n            // (otherwise intersection will yield nothing)\n            var _cpD = {\n                // delta\n                x: rs.ctrlpts[0] - tgtPos.x,\n                y: rs.ctrlpts[1] - tgtPos.y\n            };\n            var _cpL = Math.sqrt(_cpD.x * _cpD.x + _cpD.y * _cpD.y); // length of line\n            var _cpM = {\n                // normalised delta\n                x: _cpD.x / _cpL,\n                y: _cpD.y / _cpL\n            };\n            var _radius = Math.max(srcW, srcH);\n            var _cpProj = {\n                // *2 radius guarantees outside shape\n                x: rs.ctrlpts[0] + _cpM.x * 2 * _radius,\n                y: rs.ctrlpts[1] + _cpM.y * 2 * _radius\n            };\n            var tgtCtrlPtIntn = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, _cpProj.x, _cpProj.y, 0, tgtCornerRadius, tgtRs);\n            if (closeEndACp) {\n                rs.ctrlpts[0] = rs.ctrlpts[0] + _cpM.x * (minCpADist - endACpDist);\n                rs.ctrlpts[1] = rs.ctrlpts[1] + _cpM.y * (minCpADist - endACpDist);\n            } else {\n                rs.ctrlpts[0] = tgtCtrlPtIntn[0] + _cpM.x * minCpADist;\n                rs.ctrlpts[1] = tgtCtrlPtIntn[1] + _cpM.y * minCpADist;\n            }\n        }\n        if (overlapping) {\n            // recalc endpts\n            this.findEndpoints(edge);\n        }\n    }\n};\nBRp$c.storeAllpts = function(edge) {\n    var rs = edge._private.rscratch;\n    if (rs.edgeType === 'multibezier' || rs.edgeType === 'bezier' || rs.edgeType === 'self' || rs.edgeType === 'compound') {\n        rs.allpts = [];\n        rs.allpts.push(rs.startX, rs.startY);\n        for(var b = 0; b + 1 < rs.ctrlpts.length; b += 2){\n            // ctrl pt itself\n            rs.allpts.push(rs.ctrlpts[b], rs.ctrlpts[b + 1]);\n            // the midpt between ctrlpts as intermediate destination pts\n            if (b + 3 < rs.ctrlpts.length) {\n                rs.allpts.push((rs.ctrlpts[b] + rs.ctrlpts[b + 2]) / 2, (rs.ctrlpts[b + 1] + rs.ctrlpts[b + 3]) / 2);\n            }\n        }\n        rs.allpts.push(rs.endX, rs.endY);\n        var m1, mt;\n        if (rs.ctrlpts.length / 2 % 2 === 0) {\n            m1 = rs.allpts.length / 2 - 1;\n            rs.midX = rs.allpts[m1];\n            rs.midY = rs.allpts[m1 + 1];\n        } else {\n            m1 = rs.allpts.length / 2 - 3;\n            mt = 0.5;\n            rs.midX = qbezierAt(rs.allpts[m1], rs.allpts[m1 + 2], rs.allpts[m1 + 4], mt);\n            rs.midY = qbezierAt(rs.allpts[m1 + 1], rs.allpts[m1 + 3], rs.allpts[m1 + 5], mt);\n        }\n    } else if (rs.edgeType === 'straight') {\n        // need to calc these after endpts\n        rs.allpts = [\n            rs.startX,\n            rs.startY,\n            rs.endX,\n            rs.endY\n        ];\n        // default midpt for labels etc\n        rs.midX = (rs.startX + rs.endX + rs.arrowStartX + rs.arrowEndX) / 4;\n        rs.midY = (rs.startY + rs.endY + rs.arrowStartY + rs.arrowEndY) / 4;\n    } else if (rs.edgeType === 'segments') {\n        rs.allpts = [];\n        rs.allpts.push(rs.startX, rs.startY);\n        rs.allpts.push.apply(rs.allpts, rs.segpts);\n        rs.allpts.push(rs.endX, rs.endY);\n        if (rs.isRound) {\n            rs.roundCorners = [];\n            for(var i = 2; i + 3 < rs.allpts.length; i += 2){\n                var radius = rs.radii[i / 2 - 1];\n                var isArcRadius = rs.isArcRadius[i / 2 - 1];\n                rs.roundCorners.push(getRoundCorner({\n                    x: rs.allpts[i - 2],\n                    y: rs.allpts[i - 1]\n                }, {\n                    x: rs.allpts[i],\n                    y: rs.allpts[i + 1],\n                    radius: radius\n                }, {\n                    x: rs.allpts[i + 2],\n                    y: rs.allpts[i + 3]\n                }, radius, isArcRadius));\n            }\n        }\n        if (rs.segpts.length % 4 === 0) {\n            var i2 = rs.segpts.length / 2;\n            var i1 = i2 - 2;\n            rs.midX = (rs.segpts[i1] + rs.segpts[i2]) / 2;\n            rs.midY = (rs.segpts[i1 + 1] + rs.segpts[i2 + 1]) / 2;\n        } else {\n            var _i = rs.segpts.length / 2 - 1;\n            if (!rs.isRound) {\n                rs.midX = rs.segpts[_i];\n                rs.midY = rs.segpts[_i + 1];\n            } else {\n                var point = {\n                    x: rs.segpts[_i],\n                    y: rs.segpts[_i + 1]\n                };\n                var corner = rs.roundCorners[_i / 2];\n                if (corner.radius === 0) {\n                    // On collinear points\n                    var nextPoint = {\n                        x: rs.segpts[_i + 2],\n                        y: rs.segpts[_i + 3]\n                    };\n                    rs.midX = point.x;\n                    rs.midY = point.y;\n                    rs.midVector = [\n                        point.y - nextPoint.y,\n                        nextPoint.x - point.x\n                    ];\n                } else {\n                    // On rounded points\n                    var v = [\n                        point.x - corner.cx,\n                        point.y - corner.cy\n                    ];\n                    var factor = corner.radius / Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n                    v = v.map(function(c) {\n                        return c * factor;\n                    });\n                    rs.midX = corner.cx + v[0];\n                    rs.midY = corner.cy + v[1];\n                    rs.midVector = v;\n                }\n            }\n        }\n    }\n};\nBRp$c.checkForInvalidEdgeWarning = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    if (rs.nodesOverlap || number$1(rs.startX) && number$1(rs.startY) && number$1(rs.endX) && number$1(rs.endY)) {\n        rs.loggedErr = false;\n    } else {\n        if (!rs.loggedErr) {\n            rs.loggedErr = true;\n            warn('Edge `' + edge.id() + '` has invalid endpoints and so it is impossible to draw.  Adjust your edge style (e.g. control points) accordingly or use an alternative edge type.  This is expected behaviour when the source node and the target node overlap.');\n        }\n    }\n};\nBRp$c.findEdgeControlPoints = function(edges) {\n    var _this = this;\n    if (!edges || edges.length === 0) {\n        return;\n    }\n    var r = this;\n    var cy = r.cy;\n    var hasCompounds = cy.hasCompoundNodes();\n    var hashTable = new Map$1();\n    var getKey = function getKey(pairId, edgeIsUnbundled) {\n        return [].concat(_toConsumableArray(pairId), [\n            edgeIsUnbundled ? 1 : 0\n        ]).join('-');\n    };\n    var pairIds = [];\n    var haystackEdges = [];\n    // create a table of edge (src, tgt) => list of edges between them\n    for(var i = 0; i < edges.length; i++){\n        var edge = edges[i];\n        var _p = edge._private;\n        var curveStyle = edge.pstyle('curve-style').value;\n        // ignore edges who are not to be displayed\n        // they shouldn't take up space\n        if (edge.removed() || !edge.takesUpSpace()) {\n            continue;\n        }\n        if (curveStyle === 'haystack') {\n            haystackEdges.push(edge);\n            continue;\n        }\n        var edgeIsUnbundled = curveStyle === 'unbundled-bezier' || endsWith(curveStyle, 'segments') || curveStyle === 'straight' || curveStyle === 'straight-triangle' || endsWith(curveStyle, 'taxi');\n        var edgeIsBezier = curveStyle === 'unbundled-bezier' || curveStyle === 'bezier';\n        var src = _p.source;\n        var tgt = _p.target;\n        var srcIndex = src.poolIndex();\n        var tgtIndex = tgt.poolIndex();\n        var pairId = [\n            srcIndex,\n            tgtIndex\n        ].sort();\n        var key = getKey(pairId, edgeIsUnbundled);\n        var tableEntry = hashTable.get(key);\n        if (tableEntry == null) {\n            tableEntry = {\n                eles: []\n            };\n            pairIds.push({\n                pairId: pairId,\n                edgeIsUnbundled: edgeIsUnbundled\n            });\n            hashTable.set(key, tableEntry);\n        }\n        tableEntry.eles.push(edge);\n        if (edgeIsUnbundled) {\n            tableEntry.hasUnbundled = true;\n        }\n        if (edgeIsBezier) {\n            tableEntry.hasBezier = true;\n        }\n    }\n    // for each pair (src, tgt), create the ctrl pts\n    // Nested for loop is OK; total number of iterations for both loops = edgeCount\n    var _loop = function _loop() {\n        var _pairIds$p = pairIds[p], pairId = _pairIds$p.pairId, edgeIsUnbundled = _pairIds$p.edgeIsUnbundled;\n        var key = getKey(pairId, edgeIsUnbundled);\n        var pairInfo = hashTable.get(key);\n        var swappedpairInfo;\n        if (!pairInfo.hasUnbundled) {\n            var pllEdges = pairInfo.eles[0].parallelEdges().filter(function(e) {\n                return e.isBundledBezier();\n            });\n            clearArray(pairInfo.eles);\n            pllEdges.forEach(function(edge) {\n                return pairInfo.eles.push(edge);\n            });\n            // for each pair id, the edges should be sorted by index\n            pairInfo.eles.sort(function(edge1, edge2) {\n                return edge1.poolIndex() - edge2.poolIndex();\n            });\n        }\n        var firstEdge = pairInfo.eles[0];\n        var src = firstEdge.source();\n        var tgt = firstEdge.target();\n        // make sure src/tgt distinction is consistent w.r.t. pairId\n        if (src.poolIndex() > tgt.poolIndex()) {\n            var temp = src;\n            src = tgt;\n            tgt = temp;\n        }\n        var srcPos = pairInfo.srcPos = src.position();\n        var tgtPos = pairInfo.tgtPos = tgt.position();\n        var srcW = pairInfo.srcW = src.outerWidth();\n        var srcH = pairInfo.srcH = src.outerHeight();\n        var tgtW = pairInfo.tgtW = tgt.outerWidth();\n        var tgtH = pairInfo.tgtH = tgt.outerHeight();\n        var srcShape = pairInfo.srcShape = r.nodeShapes[_this.getNodeShape(src)];\n        var tgtShape = pairInfo.tgtShape = r.nodeShapes[_this.getNodeShape(tgt)];\n        var srcCornerRadius = pairInfo.srcCornerRadius = src.pstyle('corner-radius').value === 'auto' ? 'auto' : src.pstyle('corner-radius').pfValue;\n        var tgtCornerRadius = pairInfo.tgtCornerRadius = tgt.pstyle('corner-radius').value === 'auto' ? 'auto' : tgt.pstyle('corner-radius').pfValue;\n        var tgtRs = pairInfo.tgtRs = tgt._private.rscratch;\n        var srcRs = pairInfo.srcRs = src._private.rscratch;\n        pairInfo.dirCounts = {\n            'north': 0,\n            'west': 0,\n            'south': 0,\n            'east': 0,\n            'northwest': 0,\n            'southwest': 0,\n            'northeast': 0,\n            'southeast': 0\n        };\n        for(var _i2 = 0; _i2 < pairInfo.eles.length; _i2++){\n            var _edge = pairInfo.eles[_i2];\n            var rs = _edge[0]._private.rscratch;\n            var _curveStyle = _edge.pstyle('curve-style').value;\n            var _edgeIsUnbundled = _curveStyle === 'unbundled-bezier' || endsWith(_curveStyle, 'segments') || endsWith(_curveStyle, 'taxi');\n            // whether the normalised pair order is the reverse of the edge's src-tgt order\n            var edgeIsSwapped = !src.same(_edge.source());\n            if (!pairInfo.calculatedIntersection && src !== tgt && (pairInfo.hasBezier || pairInfo.hasUnbundled)) {\n                pairInfo.calculatedIntersection = true;\n                // pt outside src shape to calc distance/displacement from src to tgt\n                var srcOutside = srcShape.intersectLine(srcPos.x, srcPos.y, srcW, srcH, tgtPos.x, tgtPos.y, 0, srcCornerRadius, srcRs);\n                var srcIntn = pairInfo.srcIntn = srcOutside;\n                // pt outside tgt shape to calc distance/displacement from src to tgt\n                var tgtOutside = tgtShape.intersectLine(tgtPos.x, tgtPos.y, tgtW, tgtH, srcPos.x, srcPos.y, 0, tgtCornerRadius, tgtRs);\n                var tgtIntn = pairInfo.tgtIntn = tgtOutside;\n                var intersectionPts = pairInfo.intersectionPts = {\n                    x1: srcOutside[0],\n                    x2: tgtOutside[0],\n                    y1: srcOutside[1],\n                    y2: tgtOutside[1]\n                };\n                var posPts = pairInfo.posPts = {\n                    x1: srcPos.x,\n                    x2: tgtPos.x,\n                    y1: srcPos.y,\n                    y2: tgtPos.y\n                };\n                var dy = tgtOutside[1] - srcOutside[1];\n                var dx = tgtOutside[0] - srcOutside[0];\n                var l = Math.sqrt(dx * dx + dy * dy);\n                if (number$1(l) && l >= AVOID_IMPOSSIBLE_BEZIER_CONSTANT_L) ;\n                else {\n                    l = Math.sqrt(Math.max(dx * dx, AVOID_IMPOSSIBLE_BEZIER_CONSTANT) + Math.max(dy * dy, AVOID_IMPOSSIBLE_BEZIER_CONSTANT));\n                }\n                var vector = pairInfo.vector = {\n                    x: dx,\n                    y: dy\n                };\n                var vectorNorm = pairInfo.vectorNorm = {\n                    x: vector.x / l,\n                    y: vector.y / l\n                };\n                var vectorNormInverse = {\n                    x: -vectorNorm.y,\n                    y: vectorNorm.x\n                };\n                // if node shapes overlap, then no ctrl pts to draw\n                pairInfo.nodesOverlap = !number$1(l) || tgtShape.checkPoint(srcOutside[0], srcOutside[1], 0, tgtW, tgtH, tgtPos.x, tgtPos.y, tgtCornerRadius, tgtRs) || srcShape.checkPoint(tgtOutside[0], tgtOutside[1], 0, srcW, srcH, srcPos.x, srcPos.y, srcCornerRadius, srcRs);\n                pairInfo.vectorNormInverse = vectorNormInverse;\n                swappedpairInfo = {\n                    nodesOverlap: pairInfo.nodesOverlap,\n                    dirCounts: pairInfo.dirCounts,\n                    calculatedIntersection: true,\n                    hasBezier: pairInfo.hasBezier,\n                    hasUnbundled: pairInfo.hasUnbundled,\n                    eles: pairInfo.eles,\n                    srcPos: tgtPos,\n                    srcRs: tgtRs,\n                    tgtPos: srcPos,\n                    tgtRs: srcRs,\n                    srcW: tgtW,\n                    srcH: tgtH,\n                    tgtW: srcW,\n                    tgtH: srcH,\n                    srcIntn: tgtIntn,\n                    tgtIntn: srcIntn,\n                    srcShape: tgtShape,\n                    tgtShape: srcShape,\n                    posPts: {\n                        x1: posPts.x2,\n                        y1: posPts.y2,\n                        x2: posPts.x1,\n                        y2: posPts.y1\n                    },\n                    intersectionPts: {\n                        x1: intersectionPts.x2,\n                        y1: intersectionPts.y2,\n                        x2: intersectionPts.x1,\n                        y2: intersectionPts.y1\n                    },\n                    vector: {\n                        x: -vector.x,\n                        y: -vector.y\n                    },\n                    vectorNorm: {\n                        x: -vectorNorm.x,\n                        y: -vectorNorm.y\n                    },\n                    vectorNormInverse: {\n                        x: -vectorNormInverse.x,\n                        y: -vectorNormInverse.y\n                    }\n                };\n            }\n            var passedPairInfo = edgeIsSwapped ? swappedpairInfo : pairInfo;\n            rs.nodesOverlap = passedPairInfo.nodesOverlap;\n            rs.srcIntn = passedPairInfo.srcIntn;\n            rs.tgtIntn = passedPairInfo.tgtIntn;\n            rs.isRound = _curveStyle.startsWith('round');\n            if (hasCompounds && (src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild()) && (src.parents().anySame(tgt) || tgt.parents().anySame(src) || src.same(tgt) && src.isParent())) {\n                _this.findCompoundLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n            } else if (src === tgt) {\n                _this.findLoopPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled);\n            } else if (_curveStyle.endsWith('segments')) {\n                _this.findSegmentsPoints(_edge, passedPairInfo);\n            } else if (_curveStyle.endsWith('taxi')) {\n                _this.findTaxiPoints(_edge, passedPairInfo);\n            } else if (_curveStyle === 'straight' || !_edgeIsUnbundled && pairInfo.eles.length % 2 === 1 && _i2 === Math.floor(pairInfo.eles.length / 2)) {\n                _this.findStraightEdgePoints(_edge);\n            } else {\n                _this.findBezierPoints(_edge, passedPairInfo, _i2, _edgeIsUnbundled, edgeIsSwapped);\n            }\n            _this.findEndpoints(_edge);\n            _this.tryToCorrectInvalidPoints(_edge, passedPairInfo);\n            _this.checkForInvalidEdgeWarning(_edge);\n            _this.storeAllpts(_edge);\n            _this.storeEdgeProjections(_edge);\n            _this.calculateArrowAngles(_edge);\n            _this.recalculateEdgeLabelProjections(_edge);\n            _this.calculateLabelAngles(_edge);\n        } // for pair edges\n    };\n    for(var p = 0; p < pairIds.length; p++){\n        _loop();\n    } // for pair ids\n    // haystacks avoid the expense of pairInfo stuff (intersections etc.)\n    this.findHaystackPoints(haystackEdges);\n};\nfunction getPts(pts) {\n    var retPts = [];\n    if (pts == null) {\n        return;\n    }\n    for(var i = 0; i < pts.length; i += 2){\n        var x = pts[i];\n        var y = pts[i + 1];\n        retPts.push({\n            x: x,\n            y: y\n        });\n    }\n    return retPts;\n}\nBRp$c.getSegmentPoints = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    var type = rs.edgeType;\n    if (type === 'segments') {\n        return getPts(rs.segpts);\n    }\n};\nBRp$c.getControlPoints = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    var type = rs.edgeType;\n    if (type === 'bezier' || type === 'multibezier' || type === 'self' || type === 'compound') {\n        return getPts(rs.ctrlpts);\n    }\n};\nBRp$c.getEdgeMidpoint = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    return {\n        x: rs.midX,\n        y: rs.midY\n    };\n};\nvar BRp$b = {};\nBRp$b.manualEndptToPx = function(node, prop) {\n    var r = this;\n    var npos = node.position();\n    var w = node.outerWidth();\n    var h = node.outerHeight();\n    var rs = node._private.rscratch;\n    if (prop.value.length === 2) {\n        var p = [\n            prop.pfValue[0],\n            prop.pfValue[1]\n        ];\n        if (prop.units[0] === '%') {\n            p[0] = p[0] * w;\n        }\n        if (prop.units[1] === '%') {\n            p[1] = p[1] * h;\n        }\n        p[0] += npos.x;\n        p[1] += npos.y;\n        return p;\n    } else {\n        var angle = prop.pfValue[0];\n        angle = -Math.PI / 2 + angle; // start at 12 o'clock\n        var l = 2 * Math.max(w, h);\n        var _p = [\n            npos.x + Math.cos(angle) * l,\n            npos.y + Math.sin(angle) * l\n        ];\n        return r.nodeShapes[this.getNodeShape(node)].intersectLine(npos.x, npos.y, w, h, _p[0], _p[1], 0, node.pstyle('corner-radius').value === 'auto' ? 'auto' : node.pstyle('corner-radius').pfValue, rs);\n    }\n};\nBRp$b.findEndpoints = function(edge) {\n    var _ref, _tgtManEndpt$pfValue, _ref2, _srcManEndpt$pfValue;\n    var r = this;\n    var intersect;\n    var source = edge.source()[0];\n    var target = edge.target()[0];\n    var srcPos = source.position();\n    var tgtPos = target.position();\n    var tgtArShape = edge.pstyle('target-arrow-shape').value;\n    var srcArShape = edge.pstyle('source-arrow-shape').value;\n    var tgtDist = edge.pstyle('target-distance-from-node').pfValue;\n    var srcDist = edge.pstyle('source-distance-from-node').pfValue;\n    var srcRs = source._private.rscratch;\n    var tgtRs = target._private.rscratch;\n    var curveStyle = edge.pstyle('curve-style').value;\n    var rs = edge._private.rscratch;\n    var et = rs.edgeType;\n    var taxi = endsWith(curveStyle, 'taxi'); // Covers taxi and round-taxi\n    var self1 = et === 'self' || et === 'compound';\n    var bezier = et === 'bezier' || et === 'multibezier' || self1;\n    var multi = et !== 'bezier';\n    var lines = et === 'straight' || et === 'segments';\n    var segments = et === 'segments';\n    var hasEndpts = bezier || multi || lines;\n    var overrideEndpts = self1 || taxi;\n    var srcManEndpt = edge.pstyle('source-endpoint');\n    var srcManEndptVal = overrideEndpts ? 'outside-to-node' : srcManEndpt.value;\n    var srcCornerRadius = source.pstyle('corner-radius').value === 'auto' ? 'auto' : source.pstyle('corner-radius').pfValue;\n    var tgtManEndpt = edge.pstyle('target-endpoint');\n    var tgtManEndptVal = overrideEndpts ? 'outside-to-node' : tgtManEndpt.value;\n    var tgtCornerRadius = target.pstyle('corner-radius').value === 'auto' ? 'auto' : target.pstyle('corner-radius').pfValue;\n    rs.srcManEndpt = srcManEndpt;\n    rs.tgtManEndpt = tgtManEndpt;\n    var p1; // last known point of edge on target side\n    var p2; // last known point of edge on source side\n    var p1_i; // point to intersect with target shape\n    var p2_i; // point to intersect with source shape\n    var tgtManEndptPt = (_ref = (tgtManEndpt === null || tgtManEndpt === undefined || (_tgtManEndpt$pfValue = tgtManEndpt.pfValue) === null || _tgtManEndpt$pfValue === undefined ? undefined : _tgtManEndpt$pfValue.length) === 2 ? tgtManEndpt.pfValue : null) !== null && _ref !== undefined ? _ref : [\n        0,\n        0\n    ];\n    var srcManEndptPt = (_ref2 = (srcManEndpt === null || srcManEndpt === undefined || (_srcManEndpt$pfValue = srcManEndpt.pfValue) === null || _srcManEndpt$pfValue === undefined ? undefined : _srcManEndpt$pfValue.length) === 2 ? srcManEndpt.pfValue : null) !== null && _ref2 !== undefined ? _ref2 : [\n        0,\n        0\n    ];\n    if (bezier) {\n        var cpStart = [\n            rs.ctrlpts[0],\n            rs.ctrlpts[1]\n        ];\n        var cpEnd = multi ? [\n            rs.ctrlpts[rs.ctrlpts.length - 2],\n            rs.ctrlpts[rs.ctrlpts.length - 1]\n        ] : cpStart;\n        p1 = cpEnd;\n        p2 = cpStart;\n    } else if (lines) {\n        var srcArrowFromPt = !segments ? [\n            tgtPos.x + tgtManEndptPt[0],\n            tgtPos.y + tgtManEndptPt[1]\n        ] : rs.segpts.slice(0, 2);\n        var tgtArrowFromPt = !segments ? [\n            srcPos.x + srcManEndptPt[0],\n            srcPos.y + srcManEndptPt[1]\n        ] : rs.segpts.slice(rs.segpts.length - 2);\n        p1 = tgtArrowFromPt;\n        p2 = srcArrowFromPt;\n    }\n    if (tgtManEndptVal === 'inside-to-node') {\n        intersect = [\n            tgtPos.x,\n            tgtPos.y\n        ];\n    } else if (tgtManEndpt.units) {\n        intersect = this.manualEndptToPx(target, tgtManEndpt);\n    } else if (tgtManEndptVal === 'outside-to-line') {\n        intersect = rs.tgtIntn; // use cached value from ctrlpt calc\n    } else {\n        if (tgtManEndptVal === 'outside-to-node' || tgtManEndptVal === 'outside-to-node-or-label') {\n            p1_i = p1;\n        } else if (tgtManEndptVal === 'outside-to-line' || tgtManEndptVal === 'outside-to-line-or-label') {\n            p1_i = [\n                srcPos.x,\n                srcPos.y\n            ];\n        }\n        intersect = r.nodeShapes[this.getNodeShape(target)].intersectLine(tgtPos.x, tgtPos.y, target.outerWidth(), target.outerHeight(), p1_i[0], p1_i[1], 0, tgtCornerRadius, tgtRs);\n        if (tgtManEndptVal === 'outside-to-node-or-label' || tgtManEndptVal === 'outside-to-line-or-label') {\n            var trs = target._private.rscratch;\n            var lw = trs.labelWidth;\n            var lh = trs.labelHeight;\n            var lx = trs.labelX;\n            var ly = trs.labelY;\n            var lw2 = lw / 2;\n            var lh2 = lh / 2;\n            var va = target.pstyle('text-valign').value;\n            if (va === 'top') {\n                ly -= lh2;\n            } else if (va === 'bottom') {\n                ly += lh2;\n            }\n            var ha = target.pstyle('text-halign').value;\n            if (ha === 'left') {\n                lx -= lw2;\n            } else if (ha === 'right') {\n                lx += lw2;\n            }\n            var labelIntersect = polygonIntersectLine(p1_i[0], p1_i[1], [\n                lx - lw2,\n                ly - lh2,\n                lx + lw2,\n                ly - lh2,\n                lx + lw2,\n                ly + lh2,\n                lx - lw2,\n                ly + lh2\n            ], tgtPos.x, tgtPos.y);\n            if (labelIntersect.length > 0) {\n                var refPt = srcPos;\n                var intSqdist = sqdist(refPt, array2point(intersect));\n                var labIntSqdist = sqdist(refPt, array2point(labelIntersect));\n                var minSqDist = intSqdist;\n                if (labIntSqdist < intSqdist) {\n                    intersect = labelIntersect;\n                    minSqDist = labIntSqdist;\n                }\n                if (labelIntersect.length > 2) {\n                    var labInt2SqDist = sqdist(refPt, {\n                        x: labelIntersect[2],\n                        y: labelIntersect[3]\n                    });\n                    if (labInt2SqDist < minSqDist) {\n                        intersect = [\n                            labelIntersect[2],\n                            labelIntersect[3]\n                        ];\n                    }\n                }\n            }\n        }\n    }\n    var arrowEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].spacing(edge) + tgtDist);\n    var edgeEnd = shortenIntersection(intersect, p1, r.arrowShapes[tgtArShape].gap(edge) + tgtDist);\n    rs.endX = edgeEnd[0];\n    rs.endY = edgeEnd[1];\n    rs.arrowEndX = arrowEnd[0];\n    rs.arrowEndY = arrowEnd[1];\n    if (srcManEndptVal === 'inside-to-node') {\n        intersect = [\n            srcPos.x,\n            srcPos.y\n        ];\n    } else if (srcManEndpt.units) {\n        intersect = this.manualEndptToPx(source, srcManEndpt);\n    } else if (srcManEndptVal === 'outside-to-line') {\n        intersect = rs.srcIntn; // use cached value from ctrlpt calc\n    } else {\n        if (srcManEndptVal === 'outside-to-node' || srcManEndptVal === 'outside-to-node-or-label') {\n            p2_i = p2;\n        } else if (srcManEndptVal === 'outside-to-line' || srcManEndptVal === 'outside-to-line-or-label') {\n            p2_i = [\n                tgtPos.x,\n                tgtPos.y\n            ];\n        }\n        intersect = r.nodeShapes[this.getNodeShape(source)].intersectLine(srcPos.x, srcPos.y, source.outerWidth(), source.outerHeight(), p2_i[0], p2_i[1], 0, srcCornerRadius, srcRs);\n        if (srcManEndptVal === 'outside-to-node-or-label' || srcManEndptVal === 'outside-to-line-or-label') {\n            var srs = source._private.rscratch;\n            var _lw = srs.labelWidth;\n            var _lh = srs.labelHeight;\n            var _lx = srs.labelX;\n            var _ly = srs.labelY;\n            var _lw2 = _lw / 2;\n            var _lh2 = _lh / 2;\n            var _va = source.pstyle('text-valign').value;\n            if (_va === 'top') {\n                _ly -= _lh2;\n            } else if (_va === 'bottom') {\n                _ly += _lh2;\n            }\n            var _ha = source.pstyle('text-halign').value;\n            if (_ha === 'left') {\n                _lx -= _lw2;\n            } else if (_ha === 'right') {\n                _lx += _lw2;\n            }\n            var _labelIntersect = polygonIntersectLine(p2_i[0], p2_i[1], [\n                _lx - _lw2,\n                _ly - _lh2,\n                _lx + _lw2,\n                _ly - _lh2,\n                _lx + _lw2,\n                _ly + _lh2,\n                _lx - _lw2,\n                _ly + _lh2\n            ], srcPos.x, srcPos.y);\n            if (_labelIntersect.length > 0) {\n                var _refPt = tgtPos;\n                var _intSqdist = sqdist(_refPt, array2point(intersect));\n                var _labIntSqdist = sqdist(_refPt, array2point(_labelIntersect));\n                var _minSqDist = _intSqdist;\n                if (_labIntSqdist < _intSqdist) {\n                    intersect = [\n                        _labelIntersect[0],\n                        _labelIntersect[1]\n                    ];\n                    _minSqDist = _labIntSqdist;\n                }\n                if (_labelIntersect.length > 2) {\n                    var _labInt2SqDist = sqdist(_refPt, {\n                        x: _labelIntersect[2],\n                        y: _labelIntersect[3]\n                    });\n                    if (_labInt2SqDist < _minSqDist) {\n                        intersect = [\n                            _labelIntersect[2],\n                            _labelIntersect[3]\n                        ];\n                    }\n                }\n            }\n        }\n    }\n    var arrowStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].spacing(edge) + srcDist);\n    var edgeStart = shortenIntersection(intersect, p2, r.arrowShapes[srcArShape].gap(edge) + srcDist);\n    rs.startX = edgeStart[0];\n    rs.startY = edgeStart[1];\n    rs.arrowStartX = arrowStart[0];\n    rs.arrowStartY = arrowStart[1];\n    if (hasEndpts) {\n        if (!number$1(rs.startX) || !number$1(rs.startY) || !number$1(rs.endX) || !number$1(rs.endY)) {\n            rs.badLine = true;\n        } else {\n            rs.badLine = false;\n        }\n    }\n};\nBRp$b.getSourceEndpoint = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    switch(rs.edgeType){\n        case 'haystack':\n            return {\n                x: rs.haystackPts[0],\n                y: rs.haystackPts[1]\n            };\n        default:\n            return {\n                x: rs.arrowStartX,\n                y: rs.arrowStartY\n            };\n    }\n};\nBRp$b.getTargetEndpoint = function(edge) {\n    var rs = edge[0]._private.rscratch;\n    this.recalculateRenderedStyle(edge);\n    switch(rs.edgeType){\n        case 'haystack':\n            return {\n                x: rs.haystackPts[2],\n                y: rs.haystackPts[3]\n            };\n        default:\n            return {\n                x: rs.arrowEndX,\n                y: rs.arrowEndY\n            };\n    }\n};\nvar BRp$a = {};\nfunction pushBezierPts(r, edge, pts) {\n    var qbezierAt$1 = function qbezierAt$1(p1, p2, p3, t) {\n        return qbezierAt(p1, p2, p3, t);\n    };\n    var _p = edge._private;\n    var bpts = _p.rstyle.bezierPts;\n    for(var i = 0; i < r.bezierProjPcts.length; i++){\n        var p = r.bezierProjPcts[i];\n        bpts.push({\n            x: qbezierAt$1(pts[0], pts[2], pts[4], p),\n            y: qbezierAt$1(pts[1], pts[3], pts[5], p)\n        });\n    }\n}\nBRp$a.storeEdgeProjections = function(edge) {\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var et = rs.edgeType;\n    // clear the cached points state\n    _p.rstyle.bezierPts = null;\n    _p.rstyle.linePts = null;\n    _p.rstyle.haystackPts = null;\n    if (et === 'multibezier' || et === 'bezier' || et === 'self' || et === 'compound') {\n        _p.rstyle.bezierPts = [];\n        for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n            pushBezierPts(this, edge, rs.allpts.slice(i, i + 6));\n        }\n    } else if (et === 'segments') {\n        var lpts = _p.rstyle.linePts = [];\n        for(var i = 0; i + 1 < rs.allpts.length; i += 2){\n            lpts.push({\n                x: rs.allpts[i],\n                y: rs.allpts[i + 1]\n            });\n        }\n    } else if (et === 'haystack') {\n        var hpts = rs.haystackPts;\n        _p.rstyle.haystackPts = [\n            {\n                x: hpts[0],\n                y: hpts[1]\n            },\n            {\n                x: hpts[2],\n                y: hpts[3]\n            }\n        ];\n    }\n    _p.rstyle.arrowWidth = this.getArrowWidth(edge.pstyle('width').pfValue, edge.pstyle('arrow-scale').value) * this.arrowShapeWidth;\n};\nBRp$a.recalculateEdgeProjections = function(edges) {\n    this.findEdgeControlPoints(edges);\n};\nvar BRp$9 = {};\nBRp$9.recalculateNodeLabelProjection = function(node) {\n    var content = node.pstyle('label').strValue;\n    if (emptyString(content)) {\n        return;\n    }\n    var textX, textY;\n    var _p = node._private;\n    var nodeWidth = node.width();\n    var nodeHeight = node.height();\n    var padding = node.padding();\n    var nodePos = node.position();\n    var textHalign = node.pstyle('text-halign').strValue;\n    var textValign = node.pstyle('text-valign').strValue;\n    var rs = _p.rscratch;\n    var rstyle = _p.rstyle;\n    switch(textHalign){\n        case 'left':\n            textX = nodePos.x - nodeWidth / 2 - padding;\n            break;\n        case 'right':\n            textX = nodePos.x + nodeWidth / 2 + padding;\n            break;\n        default:\n            // e.g. center\n            textX = nodePos.x;\n    }\n    switch(textValign){\n        case 'top':\n            textY = nodePos.y - nodeHeight / 2 - padding;\n            break;\n        case 'bottom':\n            textY = nodePos.y + nodeHeight / 2 + padding;\n            break;\n        default:\n            // e.g. middle\n            textY = nodePos.y;\n    }\n    rs.labelX = textX;\n    rs.labelY = textY;\n    rstyle.labelX = textX;\n    rstyle.labelY = textY;\n    this.calculateLabelAngles(node);\n    this.applyLabelDimensions(node);\n};\nvar lineAngleFromDelta = function lineAngleFromDelta(dx, dy) {\n    var angle = Math.atan(dy / dx);\n    if (dx === 0 && angle < 0) {\n        angle = angle * -1;\n    }\n    return angle;\n};\nvar lineAngle = function lineAngle(p0, p1) {\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    return lineAngleFromDelta(dx, dy);\n};\nvar bezierAngle = function bezierAngle(p0, p1, p2, t) {\n    var t0 = bound(0, t - 0.001, 1);\n    var t1 = bound(0, t + 0.001, 1);\n    var lp0 = qbezierPtAt(p0, p1, p2, t0);\n    var lp1 = qbezierPtAt(p0, p1, p2, t1);\n    return lineAngle(lp0, lp1);\n};\nBRp$9.recalculateEdgeLabelProjections = function(edge) {\n    var p;\n    var _p = edge._private;\n    var rs = _p.rscratch;\n    var r = this;\n    var content = {\n        mid: edge.pstyle('label').strValue,\n        source: edge.pstyle('source-label').strValue,\n        target: edge.pstyle('target-label').strValue\n    };\n    if (content.mid || content.source || content.target) ;\n    else {\n        return; // no labels => no calcs\n    }\n    // add center point to style so bounding box calculations can use it\n    //\n    p = {\n        x: rs.midX,\n        y: rs.midY\n    };\n    var setRs = function setRs(propName, prefix, value) {\n        setPrefixedProperty(_p.rscratch, propName, prefix, value);\n        setPrefixedProperty(_p.rstyle, propName, prefix, value);\n    };\n    setRs('labelX', null, p.x);\n    setRs('labelY', null, p.y);\n    var midAngle = lineAngleFromDelta(rs.midDispX, rs.midDispY);\n    setRs('labelAutoAngle', null, midAngle);\n    var _createControlPointInfo = function createControlPointInfo() {\n        if (_createControlPointInfo.cache) {\n            return _createControlPointInfo.cache;\n        } // use cache so only 1x per edge\n        var ctrlpts = [];\n        // store each ctrlpt info init\n        for(var i = 0; i + 5 < rs.allpts.length; i += 4){\n            var p0 = {\n                x: rs.allpts[i],\n                y: rs.allpts[i + 1]\n            };\n            var p1 = {\n                x: rs.allpts[i + 2],\n                y: rs.allpts[i + 3]\n            }; // ctrlpt\n            var p2 = {\n                x: rs.allpts[i + 4],\n                y: rs.allpts[i + 5]\n            };\n            ctrlpts.push({\n                p0: p0,\n                p1: p1,\n                p2: p2,\n                startDist: 0,\n                length: 0,\n                segments: []\n            });\n        }\n        var bpts = _p.rstyle.bezierPts;\n        var nProjs = r.bezierProjPcts.length;\n        function addSegment(cp, p0, p1, t0, t1) {\n            var length = dist(p0, p1);\n            var prevSegment = cp.segments[cp.segments.length - 1];\n            var segment = {\n                p0: p0,\n                p1: p1,\n                t0: t0,\n                t1: t1,\n                startDist: prevSegment ? prevSegment.startDist + prevSegment.length : 0,\n                length: length\n            };\n            cp.segments.push(segment);\n            cp.length += length;\n        }\n        // update each ctrlpt with segment info\n        for(var _i = 0; _i < ctrlpts.length; _i++){\n            var cp = ctrlpts[_i];\n            var prevCp = ctrlpts[_i - 1];\n            if (prevCp) {\n                cp.startDist = prevCp.startDist + prevCp.length;\n            }\n            addSegment(cp, cp.p0, bpts[_i * nProjs], 0, r.bezierProjPcts[0]); // first\n            for(var j = 0; j < nProjs - 1; j++){\n                addSegment(cp, bpts[_i * nProjs + j], bpts[_i * nProjs + j + 1], r.bezierProjPcts[j], r.bezierProjPcts[j + 1]);\n            }\n            addSegment(cp, bpts[_i * nProjs + nProjs - 1], cp.p2, r.bezierProjPcts[nProjs - 1], 1); // last\n        }\n        return _createControlPointInfo.cache = ctrlpts;\n    };\n    var calculateEndProjection = function calculateEndProjection(prefix) {\n        var angle;\n        var isSrc = prefix === 'source';\n        if (!content[prefix]) {\n            return;\n        }\n        var offset = edge.pstyle(prefix + '-text-offset').pfValue;\n        switch(rs.edgeType){\n            case 'self':\n            case 'compound':\n            case 'bezier':\n            case 'multibezier':\n                {\n                    var cps = _createControlPointInfo();\n                    var selected;\n                    var startDist = 0;\n                    var totalDist = 0;\n                    // find the segment we're on\n                    for(var i = 0; i < cps.length; i++){\n                        var _cp = cps[isSrc ? i : cps.length - 1 - i];\n                        for(var j = 0; j < _cp.segments.length; j++){\n                            var _seg = _cp.segments[isSrc ? j : _cp.segments.length - 1 - j];\n                            var lastSeg = i === cps.length - 1 && j === _cp.segments.length - 1;\n                            startDist = totalDist;\n                            totalDist += _seg.length;\n                            if (totalDist >= offset || lastSeg) {\n                                selected = {\n                                    cp: _cp,\n                                    segment: _seg\n                                };\n                                break;\n                            }\n                        }\n                        if (selected) {\n                            break;\n                        }\n                    }\n                    var cp = selected.cp;\n                    var seg = selected.segment;\n                    var tSegment = (offset - startDist) / seg.length;\n                    var segDt = seg.t1 - seg.t0;\n                    var t = isSrc ? seg.t0 + segDt * tSegment : seg.t1 - segDt * tSegment;\n                    t = bound(0, t, 1);\n                    p = qbezierPtAt(cp.p0, cp.p1, cp.p2, t);\n                    angle = bezierAngle(cp.p0, cp.p1, cp.p2, t);\n                    break;\n                }\n            case 'straight':\n            case 'segments':\n            case 'haystack':\n                {\n                    var d = 0, di, d0;\n                    var p0, p1;\n                    var l = rs.allpts.length;\n                    for(var _i2 = 0; _i2 + 3 < l; _i2 += 2){\n                        if (isSrc) {\n                            p0 = {\n                                x: rs.allpts[_i2],\n                                y: rs.allpts[_i2 + 1]\n                            };\n                            p1 = {\n                                x: rs.allpts[_i2 + 2],\n                                y: rs.allpts[_i2 + 3]\n                            };\n                        } else {\n                            p0 = {\n                                x: rs.allpts[l - 2 - _i2],\n                                y: rs.allpts[l - 1 - _i2]\n                            };\n                            p1 = {\n                                x: rs.allpts[l - 4 - _i2],\n                                y: rs.allpts[l - 3 - _i2]\n                            };\n                        }\n                        di = dist(p0, p1);\n                        d0 = d;\n                        d += di;\n                        if (d >= offset) {\n                            break;\n                        }\n                    }\n                    var pD = offset - d0;\n                    var _t = pD / di;\n                    _t = bound(0, _t, 1);\n                    p = lineAt(p0, p1, _t);\n                    angle = lineAngle(p0, p1);\n                    break;\n                }\n        }\n        setRs('labelX', prefix, p.x);\n        setRs('labelY', prefix, p.y);\n        setRs('labelAutoAngle', prefix, angle);\n    };\n    calculateEndProjection('source');\n    calculateEndProjection('target');\n    this.applyLabelDimensions(edge);\n};\nBRp$9.applyLabelDimensions = function(ele) {\n    this.applyPrefixedLabelDimensions(ele);\n    if (ele.isEdge()) {\n        this.applyPrefixedLabelDimensions(ele, 'source');\n        this.applyPrefixedLabelDimensions(ele, 'target');\n    }\n};\nBRp$9.applyPrefixedLabelDimensions = function(ele, prefix) {\n    var _p = ele._private;\n    var text = this.getLabelText(ele, prefix);\n    var cacheKey = hashString(text, ele._private.labelDimsKey);\n    // save recalc if the label is the same as before\n    if (getPrefixedProperty(_p.rscratch, 'prefixedLabelDimsKey', prefix) === cacheKey) {\n        return; // then the label dimensions + text are the same\n    }\n    // save the key\n    setPrefixedProperty(_p.rscratch, 'prefixedLabelDimsKey', prefix, cacheKey);\n    var labelDims = this.calculateLabelDimensions(ele, text);\n    var lineHeight = ele.pstyle('line-height').pfValue;\n    var textWrap = ele.pstyle('text-wrap').strValue;\n    var lines = getPrefixedProperty(_p.rscratch, 'labelWrapCachedLines', prefix) || [];\n    var numLines = textWrap !== 'wrap' ? 1 : Math.max(lines.length, 1);\n    var normPerLineHeight = labelDims.height / numLines;\n    var labelLineHeight = normPerLineHeight * lineHeight;\n    var width = labelDims.width;\n    var height = labelDims.height + (numLines - 1) * (lineHeight - 1) * normPerLineHeight;\n    setPrefixedProperty(_p.rstyle, 'labelWidth', prefix, width);\n    setPrefixedProperty(_p.rscratch, 'labelWidth', prefix, width);\n    setPrefixedProperty(_p.rstyle, 'labelHeight', prefix, height);\n    setPrefixedProperty(_p.rscratch, 'labelHeight', prefix, height);\n    setPrefixedProperty(_p.rscratch, 'labelLineHeight', prefix, labelLineHeight);\n};\nBRp$9.getLabelText = function(ele, prefix) {\n    var _p = ele._private;\n    var pfd = prefix ? prefix + '-' : '';\n    var text = ele.pstyle(pfd + 'label').strValue;\n    var textTransform = ele.pstyle('text-transform').value;\n    var rscratch = function rscratch(propName, value) {\n        if (value) {\n            setPrefixedProperty(_p.rscratch, propName, prefix, value);\n            return value;\n        } else {\n            return getPrefixedProperty(_p.rscratch, propName, prefix);\n        }\n    };\n    // for empty text, skip all processing\n    if (!text) {\n        return '';\n    }\n    if (textTransform == 'none') ;\n    else if (textTransform == 'uppercase') {\n        text = text.toUpperCase();\n    } else if (textTransform == 'lowercase') {\n        text = text.toLowerCase();\n    }\n    var wrapStyle = ele.pstyle('text-wrap').value;\n    if (wrapStyle === 'wrap') {\n        var labelKey = rscratch('labelKey');\n        // save recalc if the label is the same as before\n        if (labelKey != null && rscratch('labelWrapKey') === labelKey) {\n            return rscratch('labelWrapCachedText');\n        }\n        var zwsp = \"\\u200B\";\n        var lines = text.split('\\n');\n        var maxW = ele.pstyle('text-max-width').pfValue;\n        var overflow = ele.pstyle('text-overflow-wrap').value;\n        var overflowAny = overflow === 'anywhere';\n        var wrappedLines = [];\n        var separatorRegex = /[\\s\\u200b]+|$/g; // Include end of string to add last word\n        for(var l = 0; l < lines.length; l++){\n            var line = lines[l];\n            var lineDims = this.calculateLabelDimensions(ele, line);\n            var lineW = lineDims.width;\n            if (overflowAny) {\n                var processedLine = line.split('').join(zwsp);\n                line = processedLine;\n            }\n            if (lineW > maxW) {\n                // line is too long\n                var separatorMatches = line.matchAll(separatorRegex);\n                var subline = '';\n                var previousIndex = 0;\n                // Add fake match\n                var _iterator = _createForOfIteratorHelper(separatorMatches), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var separatorMatch = _step.value;\n                        var wordSeparator = separatorMatch[0];\n                        var word = line.substring(previousIndex, separatorMatch.index);\n                        previousIndex = separatorMatch.index + wordSeparator.length;\n                        var testLine = subline.length === 0 ? word : subline + word + wordSeparator;\n                        var testDims = this.calculateLabelDimensions(ele, testLine);\n                        var testW = testDims.width;\n                        if (testW <= maxW) {\n                            // word fits on current line\n                            subline += word + wordSeparator;\n                        } else {\n                            // word starts new line\n                            if (subline) {\n                                wrappedLines.push(subline);\n                            }\n                            subline = word + wordSeparator;\n                        }\n                    }\n                // if there's remaining text, put it in a wrapped line\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                if (!subline.match(/^[\\s\\u200b]+$/)) {\n                    wrappedLines.push(subline);\n                }\n            } else {\n                // line is already short enough\n                wrappedLines.push(line);\n            }\n        } // for\n        rscratch('labelWrapCachedLines', wrappedLines);\n        text = rscratch('labelWrapCachedText', wrappedLines.join('\\n'));\n        rscratch('labelWrapKey', labelKey);\n    } else if (wrapStyle === 'ellipsis') {\n        var _maxW = ele.pstyle('text-max-width').pfValue;\n        var ellipsized = '';\n        var ellipsis = \"\\u2026\";\n        var incLastCh = false;\n        if (this.calculateLabelDimensions(ele, text).width < _maxW) {\n            // the label already fits\n            return text;\n        }\n        for(var i = 0; i < text.length; i++){\n            var widthWithNextCh = this.calculateLabelDimensions(ele, ellipsized + text[i] + ellipsis).width;\n            if (widthWithNextCh > _maxW) {\n                break;\n            }\n            ellipsized += text[i];\n            if (i === text.length - 1) {\n                incLastCh = true;\n            }\n        }\n        if (!incLastCh) {\n            ellipsized += ellipsis;\n        }\n        return ellipsized;\n    } // if ellipsize\n    return text;\n};\nBRp$9.getLabelJustification = function(ele) {\n    var justification = ele.pstyle('text-justification').strValue;\n    var textHalign = ele.pstyle('text-halign').strValue;\n    if (justification === 'auto') {\n        if (ele.isNode()) {\n            switch(textHalign){\n                case 'left':\n                    return 'right';\n                case 'right':\n                    return 'left';\n                default:\n                    return 'center';\n            }\n        } else {\n            return 'center';\n        }\n    } else {\n        return justification;\n    }\n};\nBRp$9.calculateLabelDimensions = function(ele, text) {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var document1 = containerWindow.document;\n    var padding = 0; // add padding around text dims, as the measurement isn't that accurate\n    var fStyle = ele.pstyle('font-style').strValue;\n    var size = ele.pstyle('font-size').pfValue;\n    var family = ele.pstyle('font-family').strValue;\n    var weight = ele.pstyle('font-weight').strValue;\n    var canvas = this.labelCalcCanvas;\n    var c2d = this.labelCalcCanvasContext;\n    if (!canvas) {\n        canvas = this.labelCalcCanvas = document1.createElement('canvas');\n        c2d = this.labelCalcCanvasContext = canvas.getContext('2d');\n        var ds = canvas.style;\n        ds.position = 'absolute';\n        ds.left = '-9999px';\n        ds.top = '-9999px';\n        ds.zIndex = '-1';\n        ds.visibility = 'hidden';\n        ds.pointerEvents = 'none';\n    }\n    c2d.font = \"\".concat(fStyle, \" \").concat(weight, \" \").concat(size, \"px \").concat(family);\n    var width = 0;\n    var height = 0;\n    var lines = text.split('\\n');\n    for(var i = 0; i < lines.length; i++){\n        var line = lines[i];\n        var metrics = c2d.measureText(line);\n        var w = Math.ceil(metrics.width);\n        var h = size;\n        width = Math.max(w, width);\n        height += h;\n    }\n    width += padding;\n    height += padding;\n    return {\n        width: width,\n        height: height\n    };\n};\nBRp$9.calculateLabelAngle = function(ele, prefix) {\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    var isEdge = ele.isEdge();\n    var prefixDash = prefix ? prefix + '-' : '';\n    var rot = ele.pstyle(prefixDash + 'text-rotation');\n    var rotStr = rot.strValue;\n    if (rotStr === 'none') {\n        return 0;\n    } else if (isEdge && rotStr === 'autorotate') {\n        return rs.labelAutoAngle;\n    } else if (rotStr === 'autorotate') {\n        return 0;\n    } else {\n        return rot.pfValue;\n    }\n};\nBRp$9.calculateLabelAngles = function(ele) {\n    var r = this;\n    var isEdge = ele.isEdge();\n    var _p = ele._private;\n    var rs = _p.rscratch;\n    rs.labelAngle = r.calculateLabelAngle(ele);\n    if (isEdge) {\n        rs.sourceLabelAngle = r.calculateLabelAngle(ele, 'source');\n        rs.targetLabelAngle = r.calculateLabelAngle(ele, 'target');\n    }\n};\nvar BRp$8 = {};\nvar TOO_SMALL_CUT_RECT = 28;\nvar warnedCutRect = false;\nBRp$8.getNodeShape = function(node) {\n    var r = this;\n    var shape = node.pstyle('shape').value;\n    if (shape === 'cutrectangle' && (node.width() < TOO_SMALL_CUT_RECT || node.height() < TOO_SMALL_CUT_RECT)) {\n        if (!warnedCutRect) {\n            warn('The `cutrectangle` node shape can not be used at small sizes so `rectangle` is used instead');\n            warnedCutRect = true;\n        }\n        return 'rectangle';\n    }\n    if (node.isParent()) {\n        if (shape === 'rectangle' || shape === 'roundrectangle' || shape === 'round-rectangle' || shape === 'cutrectangle' || shape === 'cut-rectangle' || shape === 'barrel') {\n            return shape;\n        } else {\n            return 'rectangle';\n        }\n    }\n    if (shape === 'polygon') {\n        var points = node.pstyle('shape-polygon-points').value;\n        return r.nodeShapes.makePolygon(points).name;\n    }\n    return shape;\n};\nvar BRp$7 = {};\nBRp$7.registerCalculationListeners = function() {\n    var cy = this.cy;\n    var elesToUpdate = cy.collection();\n    var r = this;\n    var enqueue = function enqueue(eles) {\n        var dirtyStyleCaches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        elesToUpdate.merge(eles);\n        if (dirtyStyleCaches) {\n            for(var i = 0; i < eles.length; i++){\n                var ele = eles[i];\n                var _p = ele._private;\n                var rstyle = _p.rstyle;\n                rstyle.clean = false;\n                rstyle.cleanConnected = false;\n            }\n        }\n    };\n    r.binder(cy).on('bounds.* dirty.*', function onDirtyBounds(e) {\n        var ele = e.target;\n        enqueue(ele);\n    }).on('style.* background.*', function onDirtyStyle(e) {\n        var ele = e.target;\n        enqueue(ele, false);\n    });\n    var updateEleCalcs = function updateEleCalcs(willDraw) {\n        if (willDraw) {\n            var fns = r.onUpdateEleCalcsFns;\n            // because we need to have up-to-date style (e.g. stylesheet mappers)\n            // before calculating rendered style (and pstyle might not be called yet)\n            elesToUpdate.cleanStyle();\n            for(var i = 0; i < elesToUpdate.length; i++){\n                var ele = elesToUpdate[i];\n                var rstyle = ele._private.rstyle;\n                if (ele.isNode() && !rstyle.cleanConnected) {\n                    enqueue(ele.connectedEdges());\n                    rstyle.cleanConnected = true;\n                }\n            }\n            if (fns) {\n                for(var _i = 0; _i < fns.length; _i++){\n                    var fn = fns[_i];\n                    fn(willDraw, elesToUpdate);\n                }\n            }\n            r.recalculateRenderedStyle(elesToUpdate);\n            elesToUpdate = cy.collection();\n        }\n    };\n    r.flushRenderedStyleQueue = function() {\n        updateEleCalcs(true);\n    };\n    r.beforeRender(updateEleCalcs, r.beforeRenderPriorities.eleCalcs);\n};\nBRp$7.onUpdateEleCalcs = function(fn) {\n    var fns = this.onUpdateEleCalcsFns = this.onUpdateEleCalcsFns || [];\n    fns.push(fn);\n};\nBRp$7.recalculateRenderedStyle = function(eles, useCache) {\n    var isCleanConnected = function isCleanConnected(ele) {\n        return ele._private.rstyle.cleanConnected;\n    };\n    if (eles.length === 0) {\n        return;\n    }\n    var edges = [];\n    var nodes = [];\n    // the renderer can't be used for calcs when destroyed, e.g. ele.boundingBox()\n    if (this.destroyed) {\n        return;\n    }\n    // use cache by default for perf\n    if (useCache === undefined) {\n        useCache = true;\n    }\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var _p = ele._private;\n        var rstyle = _p.rstyle;\n        // an edge may be implicitly dirty b/c of one of its connected nodes\n        // (and a request for recalc may come in between frames)\n        if (ele.isEdge() && (!isCleanConnected(ele.source()) || !isCleanConnected(ele.target()))) {\n            rstyle.clean = false;\n        }\n        if (ele.isEdge() && ele.isBundledBezier()) {\n            if (ele.parallelEdges().some(function(ele) {\n                return !ele._private.rstyle.clean && ele.isBundledBezier();\n            })) {\n                rstyle.clean = false;\n            }\n        }\n        // only update if dirty and in graph\n        if (useCache && rstyle.clean || ele.removed()) {\n            continue;\n        }\n        // only update if not display: none\n        if (ele.pstyle('display').value === 'none') {\n            continue;\n        }\n        if (_p.group === 'nodes') {\n            nodes.push(ele);\n        } else {\n            // edges\n            edges.push(ele);\n        }\n        rstyle.clean = true;\n    }\n    // update node data from projections\n    for(var _i2 = 0; _i2 < nodes.length; _i2++){\n        var _ele = nodes[_i2];\n        var _p2 = _ele._private;\n        var _rstyle = _p2.rstyle;\n        var pos = _ele.position();\n        this.recalculateNodeLabelProjection(_ele);\n        _rstyle.nodeX = pos.x;\n        _rstyle.nodeY = pos.y;\n        _rstyle.nodeW = _ele.pstyle('width').pfValue;\n        _rstyle.nodeH = _ele.pstyle('height').pfValue;\n    }\n    this.recalculateEdgeProjections(edges);\n    // update edge data from projections\n    for(var _i3 = 0; _i3 < edges.length; _i3++){\n        var _ele2 = edges[_i3];\n        var _p3 = _ele2._private;\n        var _rstyle2 = _p3.rstyle;\n        var rs = _p3.rscratch;\n        // update rstyle positions\n        _rstyle2.srcX = rs.arrowStartX;\n        _rstyle2.srcY = rs.arrowStartY;\n        _rstyle2.tgtX = rs.arrowEndX;\n        _rstyle2.tgtY = rs.arrowEndY;\n        _rstyle2.midX = rs.midX;\n        _rstyle2.midY = rs.midY;\n        _rstyle2.labelAngle = rs.labelAngle;\n        _rstyle2.sourceLabelAngle = rs.sourceLabelAngle;\n        _rstyle2.targetLabelAngle = rs.targetLabelAngle;\n    }\n};\nvar BRp$6 = {};\nBRp$6.updateCachedGrabbedEles = function() {\n    var eles = this.cachedZSortedEles;\n    if (!eles) {\n        // just let this be recalculated on the next z sort tick\n        return;\n    }\n    eles.drag = [];\n    eles.nondrag = [];\n    var grabTargets = [];\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var rs = ele._private.rscratch;\n        if (ele.grabbed() && !ele.isParent()) {\n            grabTargets.push(ele);\n        } else if (rs.inDragLayer) {\n            eles.drag.push(ele);\n        } else {\n            eles.nondrag.push(ele);\n        }\n    }\n    // put the grab target nodes last so it's on top of its neighbourhood\n    for(var i = 0; i < grabTargets.length; i++){\n        var ele = grabTargets[i];\n        eles.drag.push(ele);\n    }\n};\nBRp$6.invalidateCachedZSortedEles = function() {\n    this.cachedZSortedEles = null;\n};\nBRp$6.getCachedZSortedEles = function(forceRecalc) {\n    if (forceRecalc || !this.cachedZSortedEles) {\n        var eles = this.cy.mutableElements().toArray();\n        eles.sort(zIndexSort);\n        eles.interactive = eles.filter(function(ele) {\n            return ele.interactive();\n        });\n        this.cachedZSortedEles = eles;\n        this.updateCachedGrabbedEles();\n    } else {\n        eles = this.cachedZSortedEles;\n    }\n    return eles;\n};\nvar BRp$5 = {};\n[\n    BRp$e,\n    BRp$d,\n    BRp$c,\n    BRp$b,\n    BRp$a,\n    BRp$9,\n    BRp$8,\n    BRp$7,\n    BRp$6\n].forEach(function(props) {\n    extend(BRp$5, props);\n});\nvar BRp$4 = {};\nBRp$4.getCachedImage = function(url, crossOrigin, onLoad) {\n    var r = this;\n    var imageCache = r.imageCache = r.imageCache || {};\n    var cache = imageCache[url];\n    if (cache) {\n        if (!cache.image.complete) {\n            cache.image.addEventListener('load', onLoad);\n        }\n        return cache.image;\n    } else {\n        cache = imageCache[url] = imageCache[url] || {};\n        var image = cache.image = new Image(); // eslint-disable-line no-undef\n        image.addEventListener('load', onLoad);\n        image.addEventListener('error', function() {\n            image.error = true;\n        });\n        // #1582 safari doesn't load data uris with crossOrigin properly\n        // https://bugs.webkit.org/show_bug.cgi?id=123978\n        var dataUriPrefix = 'data:';\n        var isDataUri = url.substring(0, dataUriPrefix.length).toLowerCase() === dataUriPrefix;\n        if (!isDataUri) {\n            // if crossorigin is 'null'(stringified), then manually set it to null \n            crossOrigin = crossOrigin === 'null' ? null : crossOrigin;\n            image.crossOrigin = crossOrigin; // prevent tainted canvas\n        }\n        image.src = url;\n        return image;\n    }\n};\nvar BRp$3 = {};\n/* global document, ResizeObserver, MutationObserver */ BRp$3.registerBinding = function(target, event, handler, useCapture) {\n    // eslint-disable-line no-unused-vars\n    var args = Array.prototype.slice.apply(arguments, [\n        1\n    ]); // copy\n    if (Array.isArray(target)) {\n        var res = [];\n        for(var i = 0; i < target.length; i++){\n            var t = target[i];\n            if (t !== undefined) {\n                var b = this.binder(t);\n                res.push(b.on.apply(b, args));\n            }\n        }\n        return res;\n    }\n    var b = this.binder(target);\n    return b.on.apply(b, args);\n};\nBRp$3.binder = function(tgt) {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var tgtIsDom = tgt === containerWindow || tgt === containerWindow.document || tgt === containerWindow.document.body || domElement(tgt);\n    if (r.supportsPassiveEvents == null) {\n        // from https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n        var supportsPassive = false;\n        try {\n            var opts = Object.defineProperty({}, 'passive', {\n                get: function get() {\n                    supportsPassive = true;\n                    return true;\n                }\n            });\n            containerWindow.addEventListener('test', null, opts);\n        } catch (err) {\n        // not supported\n        }\n        r.supportsPassiveEvents = supportsPassive;\n    }\n    var on = function on(event, handler, useCapture) {\n        var args = Array.prototype.slice.call(arguments);\n        if (tgtIsDom && r.supportsPassiveEvents) {\n            // replace useCapture w/ opts obj\n            args[2] = {\n                capture: useCapture != null ? useCapture : false,\n                passive: false,\n                once: false\n            };\n        }\n        r.bindings.push({\n            target: tgt,\n            args: args\n        });\n        (tgt.addEventListener || tgt.on).apply(tgt, args);\n        return this;\n    };\n    return {\n        on: on,\n        addEventListener: on,\n        addListener: on,\n        bind: on\n    };\n};\nBRp$3.nodeIsDraggable = function(node) {\n    return node && node.isNode() && !node.locked() && node.grabbable();\n};\nBRp$3.nodeIsGrabbable = function(node) {\n    return this.nodeIsDraggable(node) && node.interactive();\n};\nBRp$3.load = function() {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var isSelected = function isSelected(ele) {\n        return ele.selected();\n    };\n    var getShadowRoot = function getShadowRoot(element) {\n        var rootNode = element.getRootNode();\n        // Check if the root node is a shadow root\n        if (rootNode && rootNode.nodeType === 11 && rootNode.host !== undefined) {\n            return rootNode;\n        }\n    };\n    var triggerEvents = function triggerEvents(target, names, e, position) {\n        if (target == null) {\n            target = r.cy;\n        }\n        for(var i = 0; i < names.length; i++){\n            var name = names[i];\n            target.emit({\n                originalEvent: e,\n                type: name,\n                position: position\n            });\n        }\n    };\n    var isMultSelKeyDown = function isMultSelKeyDown(e) {\n        return e.shiftKey || e.metaKey || e.ctrlKey; // maybe e.altKey\n    };\n    var allowPanningPassthrough = function allowPanningPassthrough(down, downs) {\n        var allowPassthrough = true;\n        if (r.cy.hasCompoundNodes() && down && down.pannable()) {\n            // a grabbable compound node below the ele => no passthrough panning\n            for(var i = 0; downs && i < downs.length; i++){\n                var down = downs[i];\n                //if any parent node in event hierarchy isn't pannable, reject passthrough\n                if (down.isNode() && down.isParent() && !down.pannable()) {\n                    allowPassthrough = false;\n                    break;\n                }\n            }\n        } else {\n            allowPassthrough = true;\n        }\n        return allowPassthrough;\n    };\n    var setGrabbed = function setGrabbed(ele) {\n        ele[0]._private.grabbed = true;\n    };\n    var setFreed = function setFreed(ele) {\n        ele[0]._private.grabbed = false;\n    };\n    var setInDragLayer = function setInDragLayer(ele) {\n        ele[0]._private.rscratch.inDragLayer = true;\n    };\n    var setOutDragLayer = function setOutDragLayer(ele) {\n        ele[0]._private.rscratch.inDragLayer = false;\n    };\n    var setGrabTarget = function setGrabTarget(ele) {\n        ele[0]._private.rscratch.isGrabTarget = true;\n    };\n    var removeGrabTarget = function removeGrabTarget(ele) {\n        ele[0]._private.rscratch.isGrabTarget = false;\n    };\n    var addToDragList = function addToDragList(ele, opts) {\n        var list = opts.addToList;\n        var listHasEle = list.has(ele);\n        if (!listHasEle && ele.grabbable() && !ele.locked()) {\n            list.merge(ele);\n            setGrabbed(ele);\n        }\n    };\n    // helper function to determine which child nodes and inner edges\n    // of a compound node to be dragged as well as the grabbed and selected nodes\n    var addDescendantsToDrag = function addDescendantsToDrag(node, opts) {\n        if (!node.cy().hasCompoundNodes()) {\n            return;\n        }\n        if (opts.inDragLayer == null && opts.addToList == null) {\n            return;\n        } // nothing to do\n        var innerNodes = node.descendants();\n        if (opts.inDragLayer) {\n            innerNodes.forEach(setInDragLayer);\n            innerNodes.connectedEdges().forEach(setInDragLayer);\n        }\n        if (opts.addToList) {\n            addToDragList(innerNodes, opts);\n        }\n    };\n    // adds the given nodes and its neighbourhood to the drag layer\n    var addNodesToDrag = function addNodesToDrag(nodes, opts) {\n        opts = opts || {};\n        var hasCompoundNodes = nodes.cy().hasCompoundNodes();\n        if (opts.inDragLayer) {\n            nodes.forEach(setInDragLayer);\n            nodes.neighborhood().stdFilter(function(ele) {\n                return !hasCompoundNodes || ele.isEdge();\n            }).forEach(setInDragLayer);\n        }\n        if (opts.addToList) {\n            nodes.forEach(function(ele) {\n                addToDragList(ele, opts);\n            });\n        }\n        addDescendantsToDrag(nodes, opts); // always add to drag\n        // also add nodes and edges related to the topmost ancestor\n        updateAncestorsInDragLayer(nodes, {\n            inDragLayer: opts.inDragLayer\n        });\n        r.updateCachedGrabbedEles();\n    };\n    var addNodeToDrag = addNodesToDrag;\n    var freeDraggedElements = function freeDraggedElements(grabbedEles) {\n        if (!grabbedEles) {\n            return;\n        }\n        // just go over all elements rather than doing a bunch of (possibly expensive) traversals\n        r.getCachedZSortedEles().forEach(function(ele) {\n            setFreed(ele);\n            setOutDragLayer(ele);\n            removeGrabTarget(ele);\n        });\n        r.updateCachedGrabbedEles();\n    };\n    // helper function to determine which ancestor nodes and edges should go\n    // to the drag layer (or should be removed from drag layer).\n    var updateAncestorsInDragLayer = function updateAncestorsInDragLayer(node, opts) {\n        if (opts.inDragLayer == null && opts.addToList == null) {\n            return;\n        } // nothing to do\n        if (!node.cy().hasCompoundNodes()) {\n            return;\n        }\n        // find top-level parent\n        var parent = node.ancestors().orphans();\n        // no parent node: no nodes to add to the drag layer\n        if (parent.same(node)) {\n            return;\n        }\n        var nodes = parent.descendants().spawnSelf().merge(parent).unmerge(node).unmerge(node.descendants());\n        var edges = nodes.connectedEdges();\n        if (opts.inDragLayer) {\n            edges.forEach(setInDragLayer);\n            nodes.forEach(setInDragLayer);\n        }\n        if (opts.addToList) {\n            nodes.forEach(function(ele) {\n                addToDragList(ele, opts);\n            });\n        }\n    };\n    var blurActiveDomElement = function blurActiveDomElement() {\n        if (document.activeElement != null && document.activeElement.blur != null) {\n            document.activeElement.blur();\n        }\n    };\n    var haveMutationsApi = typeof MutationObserver !== 'undefined';\n    var haveResizeObserverApi = typeof ResizeObserver !== 'undefined';\n    // watch for when the cy container is removed from the dom\n    if (haveMutationsApi) {\n        r.removeObserver = new MutationObserver(function(mutns) {\n            // eslint-disable-line no-undef\n            for(var i = 0; i < mutns.length; i++){\n                var mutn = mutns[i];\n                var rNodes = mutn.removedNodes;\n                if (rNodes) {\n                    for(var j = 0; j < rNodes.length; j++){\n                        var rNode = rNodes[j];\n                        if (rNode === r.container) {\n                            r.destroy();\n                            break;\n                        }\n                    }\n                }\n            }\n        });\n        if (r.container.parentNode) {\n            r.removeObserver.observe(r.container.parentNode, {\n                childList: true\n            });\n        }\n    } else {\n        r.registerBinding(r.container, 'DOMNodeRemoved', function(e) {\n            // eslint-disable-line no-unused-vars\n            r.destroy();\n        });\n    }\n    var onResize = debounce(function() {\n        r.cy.resize();\n    }, 100);\n    if (haveMutationsApi) {\n        r.styleObserver = new MutationObserver(onResize); // eslint-disable-line no-undef\n        r.styleObserver.observe(r.container, {\n            attributes: true\n        });\n    }\n    // auto resize\n    r.registerBinding(containerWindow, 'resize', onResize); // eslint-disable-line no-undef\n    if (haveResizeObserverApi) {\n        r.resizeObserver = new ResizeObserver(onResize); // eslint-disable-line no-undef\n        r.resizeObserver.observe(r.container);\n    }\n    var forEachUp = function forEachUp(domEle, fn) {\n        while(domEle != null){\n            fn(domEle);\n            domEle = domEle.parentNode;\n        }\n    };\n    var invalidateCoords = function invalidateCoords() {\n        r.invalidateContainerClientCoordsCache();\n    };\n    forEachUp(r.container, function(domEle) {\n        r.registerBinding(domEle, 'transitionend', invalidateCoords);\n        r.registerBinding(domEle, 'animationend', invalidateCoords);\n        r.registerBinding(domEle, 'scroll', invalidateCoords);\n    });\n    // stop right click menu from appearing on cy\n    r.registerBinding(r.container, 'contextmenu', function(e) {\n        e.preventDefault();\n    });\n    var inBoxSelection = function inBoxSelection() {\n        return r.selection[4] !== 0;\n    };\n    var eventInContainer = function eventInContainer(e) {\n        // save cycles if mouse events aren't to be captured\n        var containerPageCoords = r.findContainerClientCoords();\n        var x = containerPageCoords[0];\n        var y = containerPageCoords[1];\n        var width = containerPageCoords[2];\n        var height = containerPageCoords[3];\n        var positions = e.touches ? e.touches : [\n            e\n        ];\n        var atLeastOnePosInside = false;\n        for(var i = 0; i < positions.length; i++){\n            var p = positions[i];\n            if (x <= p.clientX && p.clientX <= x + width && y <= p.clientY && p.clientY <= y + height) {\n                atLeastOnePosInside = true;\n                break;\n            }\n        }\n        if (!atLeastOnePosInside) {\n            return false;\n        }\n        var container = r.container;\n        var target = e.target;\n        var tParent = target.parentNode;\n        var containerIsTarget = false;\n        while(tParent){\n            if (tParent === container) {\n                containerIsTarget = true;\n                break;\n            }\n            tParent = tParent.parentNode;\n        }\n        if (!containerIsTarget) {\n            return false;\n        } // if target is outisde cy container, then this event is not for us\n        return true;\n    };\n    // Primary key\n    r.registerBinding(r.container, 'mousedown', function mousedownHandler(e) {\n        if (!eventInContainer(e)) {\n            return;\n        }\n        // during left mouse button gestures, ignore other buttons\n        if (r.hoverData.which === 1 && e.which !== 1) {\n            return;\n        }\n        e.preventDefault();\n        blurActiveDomElement();\n        r.hoverData.capture = true;\n        r.hoverData.which = e.which;\n        var cy = r.cy;\n        var gpos = [\n            e.clientX,\n            e.clientY\n        ];\n        var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n        var select = r.selection;\n        var nears = r.findNearestElements(pos[0], pos[1], true, false);\n        var near = nears[0];\n        var draggedElements = r.dragData.possibleDragElements;\n        r.hoverData.mdownPos = pos;\n        r.hoverData.mdownGPos = gpos;\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n        };\n        var checkForTaphold = function checkForTaphold() {\n            r.hoverData.tapholdCancelled = false;\n            clearTimeout(r.hoverData.tapholdTimeout);\n            r.hoverData.tapholdTimeout = setTimeout(function() {\n                if (r.hoverData.tapholdCancelled) {\n                    return;\n                } else {\n                    var ele = r.hoverData.down;\n                    if (ele) {\n                        ele.emit(makeEvent('taphold'));\n                    } else {\n                        cy.emit(makeEvent('taphold'));\n                    }\n                }\n            }, r.tapholdDuration);\n        };\n        // Right click button\n        if (e.which == 3) {\n            r.hoverData.cxtStarted = true;\n            var cxtEvt = {\n                originalEvent: e,\n                type: 'cxttapstart',\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n            if (near) {\n                near.activate();\n                near.emit(cxtEvt);\n                r.hoverData.down = near;\n            } else {\n                cy.emit(cxtEvt);\n            }\n            r.hoverData.downTime = new Date().getTime();\n            r.hoverData.cxtDragged = false;\n        // Primary button\n        } else if (e.which == 1) {\n            if (near) {\n                near.activate();\n            }\n            // Element dragging\n            {\n                // If something is under the cursor and it is draggable, prepare to grab it\n                if (near != null) {\n                    if (r.nodeIsGrabbable(near)) {\n                        var triggerGrab = function triggerGrab(ele) {\n                            ele.emit(makeEvent('grab'));\n                        };\n                        setGrabTarget(near);\n                        if (!near.selected()) {\n                            draggedElements = r.dragData.possibleDragElements = cy.collection();\n                            addNodeToDrag(near, {\n                                addToList: draggedElements\n                            });\n                            near.emit(makeEvent('grabon')).emit(makeEvent('grab'));\n                        } else {\n                            draggedElements = r.dragData.possibleDragElements = cy.collection();\n                            var selectedNodes = cy.$(function(ele) {\n                                return ele.isNode() && ele.selected() && r.nodeIsGrabbable(ele);\n                            });\n                            addNodesToDrag(selectedNodes, {\n                                addToList: draggedElements\n                            });\n                            near.emit(makeEvent('grabon'));\n                            selectedNodes.forEach(triggerGrab);\n                        }\n                        r.redrawHint('eles', true);\n                        r.redrawHint('drag', true);\n                    }\n                }\n                r.hoverData.down = near;\n                r.hoverData.downs = nears;\n                r.hoverData.downTime = new Date().getTime();\n            }\n            triggerEvents(near, [\n                'mousedown',\n                'tapstart',\n                'vmousedown'\n            ], e, {\n                x: pos[0],\n                y: pos[1]\n            });\n            if (near == null) {\n                select[4] = 1;\n                r.data.bgActivePosistion = {\n                    x: pos[0],\n                    y: pos[1]\n                };\n                r.redrawHint('select', true);\n                r.redraw();\n            } else if (near.pannable()) {\n                select[4] = 1; // for future pan\n            }\n            checkForTaphold();\n        }\n        // Initialize selection box coordinates\n        select[0] = select[2] = pos[0];\n        select[1] = select[3] = pos[1];\n    }, false);\n    var shadowRoot = getShadowRoot(r.container);\n    r.registerBinding([\n        containerWindow,\n        shadowRoot\n    ], 'mousemove', function mousemoveHandler(e) {\n        // eslint-disable-line no-undef\n        var capture = r.hoverData.capture;\n        if (!capture && !eventInContainer(e)) {\n            return;\n        }\n        var preventDefault = false;\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var gpos = [\n            e.clientX,\n            e.clientY\n        ];\n        var pos = r.projectIntoViewport(gpos[0], gpos[1]);\n        var mdownPos = r.hoverData.mdownPos;\n        var mdownGPos = r.hoverData.mdownGPos;\n        var select = r.selection;\n        var near = null;\n        if (!r.hoverData.draggingEles && !r.hoverData.dragging && !r.hoverData.selecting) {\n            near = r.findNearestElement(pos[0], pos[1], true, false);\n        }\n        var last = r.hoverData.last;\n        var down = r.hoverData.down;\n        var disp = [\n            pos[0] - select[2],\n            pos[1] - select[3]\n        ];\n        var draggedElements = r.dragData.possibleDragElements;\n        var isOverThresholdDrag;\n        if (mdownGPos) {\n            var dx = gpos[0] - mdownGPos[0];\n            var dx2 = dx * dx;\n            var dy = gpos[1] - mdownGPos[1];\n            var dy2 = dy * dy;\n            var dist2 = dx2 + dy2;\n            r.hoverData.isOverThresholdDrag = isOverThresholdDrag = dist2 >= r.desktopTapThreshold2;\n        }\n        var multSelKeyDown = isMultSelKeyDown(e);\n        if (isOverThresholdDrag) {\n            r.hoverData.tapholdCancelled = true;\n        }\n        var updateDragDelta = function updateDragDelta() {\n            var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];\n            if (dragDelta.length === 0) {\n                dragDelta.push(disp[0]);\n                dragDelta.push(disp[1]);\n            } else {\n                dragDelta[0] += disp[0];\n                dragDelta[1] += disp[1];\n            }\n        };\n        preventDefault = true;\n        triggerEvents(near, [\n            'mousemove',\n            'vmousemove',\n            'tapdrag'\n        ], e, {\n            x: pos[0],\n            y: pos[1]\n        });\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n        };\n        var goIntoBoxMode = function goIntoBoxMode() {\n            r.data.bgActivePosistion = undefined;\n            if (!r.hoverData.selecting) {\n                cy.emit(makeEvent('boxstart'));\n            }\n            select[4] = 1;\n            r.hoverData.selecting = true;\n            r.redrawHint('select', true);\n            r.redraw();\n        };\n        // trigger context drag if rmouse down\n        if (r.hoverData.which === 3) {\n            // but only if over threshold\n            if (isOverThresholdDrag) {\n                var cxtEvt = makeEvent('cxtdrag');\n                if (down) {\n                    down.emit(cxtEvt);\n                } else {\n                    cy.emit(cxtEvt);\n                }\n                r.hoverData.cxtDragged = true;\n                if (!r.hoverData.cxtOver || near !== r.hoverData.cxtOver) {\n                    if (r.hoverData.cxtOver) {\n                        r.hoverData.cxtOver.emit(makeEvent('cxtdragout'));\n                    }\n                    r.hoverData.cxtOver = near;\n                    if (near) {\n                        near.emit(makeEvent('cxtdragover'));\n                    }\n                }\n            }\n        // Check if we are drag panning the entire graph\n        } else if (r.hoverData.dragging) {\n            preventDefault = true;\n            if (cy.panningEnabled() && cy.userPanningEnabled()) {\n                var deltaP;\n                if (r.hoverData.justStartedPan) {\n                    var mdPos = r.hoverData.mdownPos;\n                    deltaP = {\n                        x: (pos[0] - mdPos[0]) * zoom,\n                        y: (pos[1] - mdPos[1]) * zoom\n                    };\n                    r.hoverData.justStartedPan = false;\n                } else {\n                    deltaP = {\n                        x: disp[0] * zoom,\n                        y: disp[1] * zoom\n                    };\n                }\n                cy.panBy(deltaP);\n                cy.emit(makeEvent('dragpan'));\n                r.hoverData.dragged = true;\n            }\n            // Needs reproject due to pan changing viewport\n            pos = r.projectIntoViewport(e.clientX, e.clientY);\n        // Checks primary button down & out of time & mouse not moved much\n        } else if (select[4] == 1 && (down == null || down.pannable())) {\n            if (isOverThresholdDrag) {\n                if (!r.hoverData.dragging && cy.boxSelectionEnabled() && (multSelKeyDown || !cy.panningEnabled() || !cy.userPanningEnabled())) {\n                    goIntoBoxMode();\n                } else if (!r.hoverData.selecting && cy.panningEnabled() && cy.userPanningEnabled()) {\n                    var allowPassthrough = allowPanningPassthrough(down, r.hoverData.downs);\n                    if (allowPassthrough) {\n                        r.hoverData.dragging = true;\n                        r.hoverData.justStartedPan = true;\n                        select[4] = 0;\n                        r.data.bgActivePosistion = array2point(mdownPos);\n                        r.redrawHint('select', true);\n                        r.redraw();\n                    }\n                }\n                if (down && down.pannable() && down.active()) {\n                    down.unactivate();\n                }\n            }\n        } else {\n            if (down && down.pannable() && down.active()) {\n                down.unactivate();\n            }\n            if ((!down || !down.grabbed()) && near != last) {\n                if (last) {\n                    triggerEvents(last, [\n                        'mouseout',\n                        'tapdragout'\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                }\n                if (near) {\n                    triggerEvents(near, [\n                        'mouseover',\n                        'tapdragover'\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                }\n                r.hoverData.last = near;\n            }\n            if (down) {\n                if (isOverThresholdDrag) {\n                    // then we can take action\n                    if (cy.boxSelectionEnabled() && multSelKeyDown) {\n                        // then selection overrides\n                        if (down && down.grabbed()) {\n                            freeDraggedElements(draggedElements);\n                            down.emit(makeEvent('freeon'));\n                            draggedElements.emit(makeEvent('free'));\n                            if (r.dragData.didDrag) {\n                                down.emit(makeEvent('dragfreeon'));\n                                draggedElements.emit(makeEvent('dragfree'));\n                            }\n                        }\n                        goIntoBoxMode();\n                    } else if (down && down.grabbed() && r.nodeIsDraggable(down)) {\n                        // drag node\n                        var justStartedDrag = !r.dragData.didDrag;\n                        if (justStartedDrag) {\n                            r.redrawHint('eles', true);\n                        }\n                        r.dragData.didDrag = true; // indicate that we actually did drag the node\n                        // now, add the elements to the drag layer if not done already\n                        if (!r.hoverData.draggingEles) {\n                            addNodesToDrag(draggedElements, {\n                                inDragLayer: true\n                            });\n                        }\n                        var totalShift = {\n                            x: 0,\n                            y: 0\n                        };\n                        if (number$1(disp[0]) && number$1(disp[1])) {\n                            totalShift.x += disp[0];\n                            totalShift.y += disp[1];\n                            if (justStartedDrag) {\n                                var dragDelta = r.hoverData.dragDelta;\n                                if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                                    totalShift.x += dragDelta[0];\n                                    totalShift.y += dragDelta[1];\n                                }\n                            }\n                        }\n                        r.hoverData.draggingEles = true;\n                        draggedElements.silentShift(totalShift).emit(makeEvent('position')).emit(makeEvent('drag'));\n                        r.redrawHint('drag', true);\n                        r.redraw();\n                    }\n                } else {\n                    // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant\n                    updateDragDelta();\n                }\n            }\n            // prevent the dragging from triggering text selection on the page\n            preventDefault = true;\n        }\n        select[2] = pos[0];\n        select[3] = pos[1];\n        if (preventDefault) {\n            if (e.stopPropagation) e.stopPropagation();\n            if (e.preventDefault) e.preventDefault();\n            return false;\n        }\n    }, false);\n    var clickTimeout, didDoubleClick, prevClickTimeStamp;\n    r.registerBinding(containerWindow, 'mouseup', function mouseupHandler(e) {\n        // eslint-disable-line no-undef\n        // during left mouse button gestures, ignore other buttons\n        if (r.hoverData.which === 1 && e.which !== 1 && r.hoverData.capture) {\n            return;\n        }\n        var capture = r.hoverData.capture;\n        if (!capture) {\n            return;\n        }\n        r.hoverData.capture = false;\n        var cy = r.cy;\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        var select = r.selection;\n        var near = r.findNearestElement(pos[0], pos[1], true, false);\n        var draggedElements = r.dragData.possibleDragElements;\n        var down = r.hoverData.down;\n        var multSelKeyDown = isMultSelKeyDown(e);\n        if (r.data.bgActivePosistion) {\n            r.redrawHint('select', true);\n            r.redraw();\n        }\n        r.hoverData.tapholdCancelled = true;\n        r.data.bgActivePosistion = undefined; // not active bg now\n        if (down) {\n            down.unactivate();\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            };\n        };\n        if (r.hoverData.which === 3) {\n            var cxtEvt = makeEvent('cxttapend');\n            if (down) {\n                down.emit(cxtEvt);\n            } else {\n                cy.emit(cxtEvt);\n            }\n            if (!r.hoverData.cxtDragged) {\n                var cxtTap = makeEvent('cxttap');\n                if (down) {\n                    down.emit(cxtTap);\n                } else {\n                    cy.emit(cxtTap);\n                }\n            }\n            r.hoverData.cxtDragged = false;\n            r.hoverData.which = null;\n        } else if (r.hoverData.which === 1) {\n            triggerEvents(near, [\n                'mouseup',\n                'tapend',\n                'vmouseup'\n            ], e, {\n                x: pos[0],\n                y: pos[1]\n            });\n            if (!r.dragData.didDrag && // didn't move a node around\n            !r.hoverData.dragged && // didn't pan\n            !r.hoverData.selecting && // not box selection\n            !r.hoverData.isOverThresholdDrag // didn't move too much\n            ) {\n                triggerEvents(down, [\n                    \"click\",\n                    \"tap\",\n                    \"vclick\"\n                ], e, {\n                    x: pos[0],\n                    y: pos[1]\n                });\n                didDoubleClick = false;\n                if (e.timeStamp - prevClickTimeStamp <= cy.multiClickDebounceTime()) {\n                    clickTimeout && clearTimeout(clickTimeout);\n                    didDoubleClick = true;\n                    prevClickTimeStamp = null;\n                    triggerEvents(down, [\n                        \"dblclick\",\n                        \"dbltap\",\n                        \"vdblclick\"\n                    ], e, {\n                        x: pos[0],\n                        y: pos[1]\n                    });\n                } else {\n                    clickTimeout = setTimeout(function() {\n                        if (didDoubleClick) return;\n                        triggerEvents(down, [\n                            \"oneclick\",\n                            \"onetap\",\n                            \"voneclick\"\n                        ], e, {\n                            x: pos[0],\n                            y: pos[1]\n                        });\n                    }, cy.multiClickDebounceTime());\n                    prevClickTimeStamp = e.timeStamp;\n                }\n            }\n            // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something\n            if (down == null // not mousedown on node\n             && !r.dragData.didDrag // didn't move the node around\n             && !r.hoverData.selecting // not box selection\n             && !r.hoverData.dragged // didn't pan\n             && !isMultSelKeyDown(e)) {\n                cy.$(isSelected).unselect([\n                    'tapunselect'\n                ]);\n                if (draggedElements.length > 0) {\n                    r.redrawHint('eles', true);\n                }\n                r.dragData.possibleDragElements = draggedElements = cy.collection();\n            }\n            // Single selection\n            if (near == down && !r.dragData.didDrag && !r.hoverData.selecting) {\n                if (near != null && near._private.selectable) {\n                    if (r.hoverData.dragging) ;\n                    else if (cy.selectionType() === 'additive' || multSelKeyDown) {\n                        if (near.selected()) {\n                            near.unselect([\n                                'tapunselect'\n                            ]);\n                        } else {\n                            near.select([\n                                'tapselect'\n                            ]);\n                        }\n                    } else {\n                        if (!multSelKeyDown) {\n                            cy.$(isSelected).unmerge(near).unselect([\n                                'tapunselect'\n                            ]);\n                            near.select([\n                                'tapselect'\n                            ]);\n                        }\n                    }\n                    r.redrawHint('eles', true);\n                }\n            }\n            if (r.hoverData.selecting) {\n                var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n                r.redrawHint('select', true);\n                if (box.length > 0) {\n                    r.redrawHint('eles', true);\n                }\n                cy.emit(makeEvent('boxend'));\n                var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n                    return ele.selectable() && !ele.selected();\n                };\n                if (cy.selectionType() === 'additive') {\n                    box.emit(makeEvent('box')).stdFilter(eleWouldBeSelected).select().emit(makeEvent('boxselect'));\n                } else {\n                    if (!multSelKeyDown) {\n                        cy.$(isSelected).unmerge(box).unselect();\n                    }\n                    box.emit(makeEvent('box')).stdFilter(eleWouldBeSelected).select().emit(makeEvent('boxselect'));\n                }\n                // always need redraw in case eles unselectable\n                r.redraw();\n            }\n            // Cancel drag pan\n            if (r.hoverData.dragging) {\n                r.hoverData.dragging = false;\n                r.redrawHint('select', true);\n                r.redrawHint('eles', true);\n                r.redraw();\n            }\n            if (!select[4]) {\n                r.redrawHint('drag', true);\n                r.redrawHint('eles', true);\n                var downWasGrabbed = down && down.grabbed();\n                freeDraggedElements(draggedElements);\n                if (downWasGrabbed) {\n                    down.emit(makeEvent('freeon'));\n                    draggedElements.emit(makeEvent('free'));\n                    if (r.dragData.didDrag) {\n                        down.emit(makeEvent('dragfreeon'));\n                        draggedElements.emit(makeEvent('dragfree'));\n                    }\n                }\n            }\n        } // else not right mouse\n        select[4] = 0;\n        r.hoverData.down = null;\n        r.hoverData.cxtStarted = false;\n        r.hoverData.draggingEles = false;\n        r.hoverData.selecting = false;\n        r.hoverData.isOverThresholdDrag = false;\n        r.dragData.didDrag = false;\n        r.hoverData.dragged = false;\n        r.hoverData.dragDelta = [];\n        r.hoverData.mdownPos = null;\n        r.hoverData.mdownGPos = null;\n        r.hoverData.which = null;\n    }, false);\n    var wheelDeltas = []; // log of first N wheel deltas\n    var wheelDeltaN = 4; // how many events to log\n    var inaccurateScrollDevice;\n    var inaccurateScrollFactor = 100000; // base of inaccurate wheel deltas (e.g. base 5 could yield wheels of 10, 25, 50, etc.)\n    var allAreDivisibleBy = function allAreDivisibleBy(list, factor) {\n        for(var i = 0; i < list.length; i++){\n            if (list[i] % factor !== 0) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var allAreSameMagnitude = function allAreSameMagnitude(list) {\n        var firstMag = Math.abs(list[0]);\n        for(var i = 1; i < list.length; i++){\n            if (Math.abs(list[i]) !== firstMag) {\n                return false;\n            }\n        }\n        return true;\n    };\n    var wheelHandler = function wheelHandler(e) {\n        var clamp = false;\n        var delta = e.deltaY;\n        if (delta == null) {\n            // compatibility with old browsers\n            if (e.wheelDeltaY != null) {\n                delta = e.wheelDeltaY / 4;\n            } else if (e.wheelDelta != null) {\n                delta = e.wheelDelta / 4;\n            }\n        }\n        if (delta === 0) {\n            return; // no change in zoom (Bug: Zoom becomes erratic on rapid scroll due to deltaY: 0 event #3394)\n        }\n        if (inaccurateScrollDevice == null) {\n            if (wheelDeltas.length >= wheelDeltaN) {\n                // use log to determine if inaccurate\n                var wds = wheelDeltas;\n                inaccurateScrollDevice = allAreDivisibleBy(wds, 5);\n                if (!inaccurateScrollDevice) {\n                    // check for all large values of exact same magnitude\n                    var firstMag = Math.abs(wds[0]);\n                    inaccurateScrollDevice = allAreSameMagnitude(wds) && firstMag > 5;\n                }\n                if (inaccurateScrollDevice) {\n                    for(var i = 0; i < wds.length; i++){\n                        inaccurateScrollFactor = Math.min(Math.abs(wds[i]), inaccurateScrollFactor);\n                    }\n                }\n            // console.log('Sampled wheel deltas:', wds);\n            // console.log('inaccurateScrollDevice:', inaccurateScrollDevice);\n            // console.log('inaccurateScrollFactor:', inaccurateScrollFactor);\n            } else {\n                // clamp and log until we reach N\n                wheelDeltas.push(delta);\n                clamp = true;\n            // console.log('Clamping initial wheel events until we get a good sample');\n            }\n        } else if (inaccurateScrollDevice) {\n            // keep updating\n            inaccurateScrollFactor = Math.min(Math.abs(delta), inaccurateScrollFactor);\n        // console.log('Keep updating inaccurateScrollFactor beyond sample in case we did not get the smallest possible val:', inaccurateScrollFactor);\n        }\n        if (r.scrollingPage) {\n            return;\n        } // while scrolling, ignore wheel-to-zoom\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var pan = cy.pan();\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        var rpos = [\n            pos[0] * zoom + pan.x,\n            pos[1] * zoom + pan.y\n        ];\n        if (r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection()) {\n            // if pan dragging or cxt dragging, wheel movements make no zoom\n            e.preventDefault();\n            return;\n        }\n        if (cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled()) {\n            e.preventDefault();\n            r.data.wheelZooming = true;\n            clearTimeout(r.data.wheelTimeout);\n            r.data.wheelTimeout = setTimeout(function() {\n                r.data.wheelZooming = false;\n                r.redrawHint('eles', true);\n                r.redraw();\n            }, 150);\n            var diff;\n            if (clamp && Math.abs(delta) > 5) {\n                delta = signum(delta) * 5;\n            }\n            diff = delta / -250;\n            if (inaccurateScrollDevice) {\n                diff /= inaccurateScrollFactor;\n                diff *= 3;\n            }\n            diff = diff * r.wheelSensitivity;\n            // console.log(`delta = ${delta}, diff = ${diff}, mode = ${e.deltaMode}`)\n            var needsWheelFix = e.deltaMode === 1;\n            if (needsWheelFix) {\n                // fixes slow wheel events on ff/linux and ff/windows\n                diff *= 33;\n            }\n            var newZoom = cy.zoom() * Math.pow(10, diff);\n            if (e.type === 'gesturechange') {\n                newZoom = r.gestureStartZoom * e.scale;\n            }\n            cy.zoom({\n                level: newZoom,\n                renderedPosition: {\n                    x: rpos[0],\n                    y: rpos[1]\n                }\n            });\n            cy.emit({\n                type: e.type === 'gesturechange' ? 'pinchzoom' : 'scrollzoom',\n                originalEvent: e,\n                position: {\n                    x: pos[0],\n                    y: pos[1]\n                }\n            });\n        }\n    };\n    // Functions to help with whether mouse wheel should trigger zooming\n    // --\n    r.registerBinding(r.container, 'wheel', wheelHandler, true);\n    // disable nonstandard wheel events\n    // r.registerBinding(r.container, 'mousewheel', wheelHandler, true);\n    // r.registerBinding(r.container, 'DOMMouseScroll', wheelHandler, true);\n    // r.registerBinding(r.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox\n    r.registerBinding(containerWindow, 'scroll', function scrollHandler(e) {\n        // eslint-disable-line no-unused-vars\n        r.scrollingPage = true;\n        clearTimeout(r.scrollingPageTimeout);\n        r.scrollingPageTimeout = setTimeout(function() {\n            r.scrollingPage = false;\n        }, 250);\n    }, true);\n    // desktop safari pinch to zoom start\n    r.registerBinding(r.container, 'gesturestart', function gestureStartHandler(e) {\n        r.gestureStartZoom = r.cy.zoom();\n        if (!r.hasTouchStarted) {\n            // don't affect touch devices like iphone\n            e.preventDefault();\n        }\n    }, true);\n    r.registerBinding(r.container, 'gesturechange', function(e) {\n        if (!r.hasTouchStarted) {\n            // don't affect touch devices like iphone\n            wheelHandler(e);\n        }\n    }, true);\n    // Functions to help with handling mouseout/mouseover on the Cytoscape container\n    // Handle mouseout on Cytoscape container\n    r.registerBinding(r.container, 'mouseout', function mouseOutHandler(e) {\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        r.cy.emit({\n            originalEvent: e,\n            type: 'mouseout',\n            position: {\n                x: pos[0],\n                y: pos[1]\n            }\n        });\n    }, false);\n    r.registerBinding(r.container, 'mouseover', function mouseOverHandler(e) {\n        var pos = r.projectIntoViewport(e.clientX, e.clientY);\n        r.cy.emit({\n            originalEvent: e,\n            type: 'mouseover',\n            position: {\n                x: pos[0],\n                y: pos[1]\n            }\n        });\n    }, false);\n    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom\n    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom\n    var center1, modelCenter1; // center point on start pinch to zoom\n    var offsetLeft, offsetTop;\n    var containerWidth, containerHeight;\n    var twoFingersStartInside;\n    var distance = function distance(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    };\n    var distanceSq = function distanceSq(x1, y1, x2, y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    };\n    var touchstartHandler;\n    r.registerBinding(r.container, 'touchstart', touchstartHandler = function touchstartHandler(e) {\n        r.hasTouchStarted = true;\n        if (!eventInContainer(e)) {\n            return;\n        }\n        blurActiveDomElement();\n        r.touchData.capture = true;\n        r.data.bgActivePosistion = undefined;\n        var cy = r.cy;\n        var now = r.touchData.now;\n        var earlier = r.touchData.earlier;\n        if (e.touches[0]) {\n            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n            now[0] = pos[0];\n            now[1] = pos[1];\n        }\n        if (e.touches[1]) {\n            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n            now[2] = pos[0];\n            now[3] = pos[1];\n        }\n        if (e.touches[2]) {\n            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n            now[4] = pos[0];\n            now[5] = pos[1];\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: now[0],\n                    y: now[1]\n                }\n            };\n        };\n        // record starting points for pinch-to-zoom\n        if (e.touches[1]) {\n            r.touchData.singleTouchMoved = true;\n            freeDraggedElements(r.dragData.touchDragEles);\n            var offsets = r.findContainerClientCoords();\n            offsetLeft = offsets[0];\n            offsetTop = offsets[1];\n            containerWidth = offsets[2];\n            containerHeight = offsets[3];\n            f1x1 = e.touches[0].clientX - offsetLeft;\n            f1y1 = e.touches[0].clientY - offsetTop;\n            f2x1 = e.touches[1].clientX - offsetLeft;\n            f2y1 = e.touches[1].clientY - offsetTop;\n            twoFingersStartInside = 0 <= f1x1 && f1x1 <= containerWidth && 0 <= f2x1 && f2x1 <= containerWidth && 0 <= f1y1 && f1y1 <= containerHeight && 0 <= f2y1 && f2y1 <= containerHeight;\n            var pan = cy.pan();\n            var zoom = cy.zoom();\n            distance1 = distance(f1x1, f1y1, f2x1, f2y1);\n            distance1Sq = distanceSq(f1x1, f1y1, f2x1, f2y1);\n            center1 = [\n                (f1x1 + f2x1) / 2,\n                (f1y1 + f2y1) / 2\n            ];\n            modelCenter1 = [\n                (center1[0] - pan.x) / zoom,\n                (center1[1] - pan.y) / zoom\n            ];\n            // consider context tap\n            var cxtDistThreshold = 200;\n            var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;\n            if (distance1Sq < cxtDistThresholdSq && !e.touches[2]) {\n                var near1 = r.findNearestElement(now[0], now[1], true, true);\n                var near2 = r.findNearestElement(now[2], now[3], true, true);\n                if (near1 && near1.isNode()) {\n                    near1.activate().emit(makeEvent('cxttapstart'));\n                    r.touchData.start = near1;\n                } else if (near2 && near2.isNode()) {\n                    near2.activate().emit(makeEvent('cxttapstart'));\n                    r.touchData.start = near2;\n                } else {\n                    cy.emit(makeEvent('cxttapstart'));\n                }\n                if (r.touchData.start) {\n                    r.touchData.start._private.grabbed = false;\n                }\n                r.touchData.cxt = true;\n                r.touchData.cxtDragged = false;\n                r.data.bgActivePosistion = undefined;\n                r.redraw();\n                return;\n            }\n        }\n        if (e.touches[2]) {\n            // ignore\n            // safari on ios pans the page otherwise (normally you should be able to preventdefault on touchmove...)\n            if (cy.boxSelectionEnabled()) {\n                e.preventDefault();\n            }\n        } else if (e.touches[1]) ;\n        else if (e.touches[0]) {\n            var nears = r.findNearestElements(now[0], now[1], true, true);\n            var near = nears[0];\n            if (near != null) {\n                near.activate();\n                r.touchData.start = near;\n                r.touchData.starts = nears;\n                if (r.nodeIsGrabbable(near)) {\n                    var draggedEles = r.dragData.touchDragEles = cy.collection();\n                    var selectedNodes = null;\n                    r.redrawHint('eles', true);\n                    r.redrawHint('drag', true);\n                    if (near.selected()) {\n                        // reset drag elements, since near will be added again\n                        selectedNodes = cy.$(function(ele) {\n                            return ele.selected() && r.nodeIsGrabbable(ele);\n                        });\n                        addNodesToDrag(selectedNodes, {\n                            addToList: draggedEles\n                        });\n                    } else {\n                        addNodeToDrag(near, {\n                            addToList: draggedEles\n                        });\n                    }\n                    setGrabTarget(near);\n                    near.emit(makeEvent('grabon'));\n                    if (selectedNodes) {\n                        selectedNodes.forEach(function(n) {\n                            n.emit(makeEvent('grab'));\n                        });\n                    } else {\n                        near.emit(makeEvent('grab'));\n                    }\n                }\n            }\n            triggerEvents(near, [\n                'touchstart',\n                'tapstart',\n                'vmousedown'\n            ], e, {\n                x: now[0],\n                y: now[1]\n            });\n            if (near == null) {\n                r.data.bgActivePosistion = {\n                    x: pos[0],\n                    y: pos[1]\n                };\n                r.redrawHint('select', true);\n                r.redraw();\n            }\n            // Tap, taphold\n            // -----\n            r.touchData.singleTouchMoved = false;\n            r.touchData.singleTouchStartTime = +new Date();\n            clearTimeout(r.touchData.tapholdTimeout);\n            r.touchData.tapholdTimeout = setTimeout(function() {\n                if (r.touchData.singleTouchMoved === false && !r.pinching // if pinching, then taphold unselect shouldn't take effect\n                 && !r.touchData.selecting // box selection shouldn't allow taphold through\n                ) {\n                    triggerEvents(r.touchData.start, [\n                        'taphold'\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                }\n            }, r.tapholdDuration);\n        }\n        if (e.touches.length >= 1) {\n            var sPos = r.touchData.startPosition = [\n                null,\n                null,\n                null,\n                null,\n                null,\n                null\n            ];\n            for(var i = 0; i < now.length; i++){\n                sPos[i] = earlier[i] = now[i];\n            }\n            var touch0 = e.touches[0];\n            r.touchData.startGPosition = [\n                touch0.clientX,\n                touch0.clientY\n            ];\n        }\n    }, false);\n    var touchmoveHandler;\n    r.registerBinding(containerWindow, 'touchmove', touchmoveHandler = function touchmoveHandler(e) {\n        // eslint-disable-line no-undef\n        var capture = r.touchData.capture;\n        if (!capture && !eventInContainer(e)) {\n            return;\n        }\n        var select = r.selection;\n        var cy = r.cy;\n        var now = r.touchData.now;\n        var earlier = r.touchData.earlier;\n        var zoom = cy.zoom();\n        if (e.touches[0]) {\n            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n            now[0] = pos[0];\n            now[1] = pos[1];\n        }\n        if (e.touches[1]) {\n            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n            now[2] = pos[0];\n            now[3] = pos[1];\n        }\n        if (e.touches[2]) {\n            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n            now[4] = pos[0];\n            now[5] = pos[1];\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: now[0],\n                    y: now[1]\n                }\n            };\n        };\n        var startGPos = r.touchData.startGPosition;\n        var isOverThresholdDrag;\n        if (capture && e.touches[0] && startGPos) {\n            var disp = [];\n            for(var j = 0; j < now.length; j++){\n                disp[j] = now[j] - earlier[j];\n            }\n            var dx = e.touches[0].clientX - startGPos[0];\n            var dx2 = dx * dx;\n            var dy = e.touches[0].clientY - startGPos[1];\n            var dy2 = dy * dy;\n            var dist2 = dx2 + dy2;\n            isOverThresholdDrag = dist2 >= r.touchTapThreshold2;\n        }\n        // context swipe cancelling\n        if (capture && r.touchData.cxt) {\n            e.preventDefault();\n            var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n            var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n            // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );\n            var distance2Sq = distanceSq(f1x2, f1y2, f2x2, f2y2);\n            var factorSq = distance2Sq / distance1Sq;\n            var distThreshold = 150;\n            var distThresholdSq = distThreshold * distThreshold;\n            var factorThreshold = 1.5;\n            var factorThresholdSq = factorThreshold * factorThreshold;\n            // cancel ctx gestures if the distance b/t the fingers increases\n            if (factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq) {\n                r.touchData.cxt = false;\n                r.data.bgActivePosistion = undefined;\n                r.redrawHint('select', true);\n                var cxtEvt = makeEvent('cxttapend');\n                if (r.touchData.start) {\n                    r.touchData.start.unactivate().emit(cxtEvt);\n                    r.touchData.start = null;\n                } else {\n                    cy.emit(cxtEvt);\n                }\n            }\n        }\n        // context swipe\n        if (capture && r.touchData.cxt) {\n            var cxtEvt = makeEvent('cxtdrag');\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n            if (r.touchData.start) {\n                r.touchData.start.emit(cxtEvt);\n            } else {\n                cy.emit(cxtEvt);\n            }\n            if (r.touchData.start) {\n                r.touchData.start._private.grabbed = false;\n            }\n            r.touchData.cxtDragged = true;\n            var near = r.findNearestElement(now[0], now[1], true, true);\n            if (!r.touchData.cxtOver || near !== r.touchData.cxtOver) {\n                if (r.touchData.cxtOver) {\n                    r.touchData.cxtOver.emit(makeEvent('cxtdragout'));\n                }\n                r.touchData.cxtOver = near;\n                if (near) {\n                    near.emit(makeEvent('cxtdragover'));\n                }\n            }\n        // box selection\n        } else if (capture && e.touches[2] && cy.boxSelectionEnabled()) {\n            e.preventDefault();\n            r.data.bgActivePosistion = undefined;\n            this.lastThreeTouch = +new Date();\n            if (!r.touchData.selecting) {\n                cy.emit(makeEvent('boxstart'));\n            }\n            r.touchData.selecting = true;\n            r.touchData.didSelect = true;\n            select[4] = 1;\n            if (!select || select.length === 0 || select[0] === undefined) {\n                select[0] = (now[0] + now[2] + now[4]) / 3;\n                select[1] = (now[1] + now[3] + now[5]) / 3;\n                select[2] = (now[0] + now[2] + now[4]) / 3 + 1;\n                select[3] = (now[1] + now[3] + now[5]) / 3 + 1;\n            } else {\n                select[2] = (now[0] + now[2] + now[4]) / 3;\n                select[3] = (now[1] + now[3] + now[5]) / 3;\n            }\n            r.redrawHint('select', true);\n            r.redraw();\n        // pinch to zoom\n        } else if (capture && e.touches[1] && !r.touchData.didSelect // don't allow box selection to degrade to pinch-to-zoom\n         && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled()) {\n            // two fingers => pinch to zoom\n            e.preventDefault();\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n            var draggedEles = r.dragData.touchDragEles;\n            if (draggedEles) {\n                r.redrawHint('drag', true);\n                for(var i = 0; i < draggedEles.length; i++){\n                    var de_p = draggedEles[i]._private;\n                    de_p.grabbed = false;\n                    de_p.rscratch.inDragLayer = false;\n                }\n            }\n            var _start = r.touchData.start;\n            // (x2, y2) for fingers 1 and 2\n            var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;\n            var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;\n            var distance2 = distance(f1x2, f1y2, f2x2, f2y2);\n            // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );\n            // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );\n            var factor = distance2 / distance1;\n            if (twoFingersStartInside) {\n                // delta finger1\n                var df1x = f1x2 - f1x1;\n                var df1y = f1y2 - f1y1;\n                // delta finger 2\n                var df2x = f2x2 - f2x1;\n                var df2y = f2y2 - f2y1;\n                // translation is the normalised vector of the two fingers movement\n                // i.e. so pinching cancels out and moving together pans\n                var tx = (df1x + df2x) / 2;\n                var ty = (df1y + df2y) / 2;\n                // now calculate the zoom\n                var zoom1 = cy.zoom();\n                var zoom2 = zoom1 * factor;\n                var pan1 = cy.pan();\n                // the model center point converted to the current rendered pos\n                var ctrx = modelCenter1[0] * zoom1 + pan1.x;\n                var ctry = modelCenter1[1] * zoom1 + pan1.y;\n                var pan2 = {\n                    x: -zoom2 / zoom1 * (ctrx - pan1.x - tx) + ctrx,\n                    y: -zoom2 / zoom1 * (ctry - pan1.y - ty) + ctry\n                };\n                // remove dragged eles\n                if (_start && _start.active()) {\n                    var draggedEles = r.dragData.touchDragEles;\n                    freeDraggedElements(draggedEles);\n                    r.redrawHint('drag', true);\n                    r.redrawHint('eles', true);\n                    _start.unactivate().emit(makeEvent('freeon'));\n                    draggedEles.emit(makeEvent('free'));\n                    if (r.dragData.didDrag) {\n                        _start.emit(makeEvent('dragfreeon'));\n                        draggedEles.emit(makeEvent('dragfree'));\n                    }\n                }\n                cy.viewport({\n                    zoom: zoom2,\n                    pan: pan2,\n                    cancelOnFailedZoom: true\n                });\n                cy.emit(makeEvent('pinchzoom'));\n                distance1 = distance2;\n                f1x1 = f1x2;\n                f1y1 = f1y2;\n                f2x1 = f2x2;\n                f2y1 = f2y2;\n                r.pinching = true;\n            }\n            // Re-project\n            if (e.touches[0]) {\n                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                now[0] = pos[0];\n                now[1] = pos[1];\n            }\n            if (e.touches[1]) {\n                var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n                now[2] = pos[0];\n                now[3] = pos[1];\n            }\n            if (e.touches[2]) {\n                var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n                now[4] = pos[0];\n                now[5] = pos[1];\n            }\n        } else if (e.touches[0] && !r.touchData.didSelect // don't allow box selection to degrade to single finger events like panning\n        ) {\n            var start = r.touchData.start;\n            var last = r.touchData.last;\n            var near;\n            if (!r.hoverData.draggingEles && !r.swipePanning) {\n                near = r.findNearestElement(now[0], now[1], true, true);\n            }\n            if (capture && start != null) {\n                e.preventDefault();\n            }\n            // dragging nodes\n            if (capture && start != null && r.nodeIsDraggable(start)) {\n                if (isOverThresholdDrag) {\n                    // then dragging can happen\n                    var draggedEles = r.dragData.touchDragEles;\n                    var justStartedDrag = !r.dragData.didDrag;\n                    if (justStartedDrag) {\n                        addNodesToDrag(draggedEles, {\n                            inDragLayer: true\n                        });\n                    }\n                    r.dragData.didDrag = true;\n                    var totalShift = {\n                        x: 0,\n                        y: 0\n                    };\n                    if (number$1(disp[0]) && number$1(disp[1])) {\n                        totalShift.x += disp[0];\n                        totalShift.y += disp[1];\n                        if (justStartedDrag) {\n                            r.redrawHint('eles', true);\n                            var dragDelta = r.touchData.dragDelta;\n                            if (dragDelta && number$1(dragDelta[0]) && number$1(dragDelta[1])) {\n                                totalShift.x += dragDelta[0];\n                                totalShift.y += dragDelta[1];\n                            }\n                        }\n                    }\n                    r.hoverData.draggingEles = true;\n                    draggedEles.silentShift(totalShift).emit(makeEvent('position')).emit(makeEvent('drag'));\n                    r.redrawHint('drag', true);\n                    if (r.touchData.startPosition[0] == earlier[0] && r.touchData.startPosition[1] == earlier[1]) {\n                        r.redrawHint('eles', true);\n                    }\n                    r.redraw();\n                } else {\n                    // otherwise keep track of drag delta for later\n                    var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];\n                    if (dragDelta.length === 0) {\n                        dragDelta.push(disp[0]);\n                        dragDelta.push(disp[1]);\n                    } else {\n                        dragDelta[0] += disp[0];\n                        dragDelta[1] += disp[1];\n                    }\n                }\n            }\n            // touchmove\n            {\n                triggerEvents(start || near, [\n                    'touchmove',\n                    'tapdrag',\n                    'vmousemove'\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                if ((!start || !start.grabbed()) && near != last) {\n                    if (last) {\n                        last.emit(makeEvent('tapdragout'));\n                    }\n                    if (near) {\n                        near.emit(makeEvent('tapdragover'));\n                    }\n                }\n                r.touchData.last = near;\n            }\n            // check to cancel taphold\n            if (capture) {\n                for(var i = 0; i < now.length; i++){\n                    if (now[i] && r.touchData.startPosition[i] && isOverThresholdDrag) {\n                        r.touchData.singleTouchMoved = true;\n                    }\n                }\n            }\n            // panning\n            if (capture && (start == null || start.pannable()) && cy.panningEnabled() && cy.userPanningEnabled()) {\n                var allowPassthrough = allowPanningPassthrough(start, r.touchData.starts);\n                if (allowPassthrough) {\n                    e.preventDefault();\n                    if (!r.data.bgActivePosistion) {\n                        r.data.bgActivePosistion = array2point(r.touchData.startPosition);\n                    }\n                    if (r.swipePanning) {\n                        cy.panBy({\n                            x: disp[0] * zoom,\n                            y: disp[1] * zoom\n                        });\n                        cy.emit(makeEvent('dragpan'));\n                    } else if (isOverThresholdDrag) {\n                        r.swipePanning = true;\n                        cy.panBy({\n                            x: dx * zoom,\n                            y: dy * zoom\n                        });\n                        cy.emit(makeEvent('dragpan'));\n                        if (start) {\n                            start.unactivate();\n                            r.redrawHint('select', true);\n                            r.touchData.start = null;\n                        }\n                    }\n                }\n                // Re-project\n                var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n                now[0] = pos[0];\n                now[1] = pos[1];\n            }\n        }\n        for(var j = 0; j < now.length; j++){\n            earlier[j] = now[j];\n        }\n        // the active bg indicator should be removed when making a swipe that is neither for dragging nodes or panning\n        if (capture && e.touches.length > 0 && !r.hoverData.draggingEles && !r.swipePanning && r.data.bgActivePosistion != null) {\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n            r.redraw();\n        }\n    }, false);\n    var touchcancelHandler;\n    r.registerBinding(containerWindow, 'touchcancel', touchcancelHandler = function touchcancelHandler(e) {\n        // eslint-disable-line no-unused-vars\n        var start = r.touchData.start;\n        r.touchData.capture = false;\n        if (start) {\n            start.unactivate();\n        }\n    });\n    var touchendHandler, didDoubleTouch, touchTimeout, prevTouchTimeStamp;\n    r.registerBinding(containerWindow, 'touchend', touchendHandler = function touchendHandler(e) {\n        // eslint-disable-line no-unused-vars\n        var start = r.touchData.start;\n        var capture = r.touchData.capture;\n        if (capture) {\n            if (e.touches.length === 0) {\n                r.touchData.capture = false;\n            }\n            e.preventDefault();\n        } else {\n            return;\n        }\n        var select = r.selection;\n        r.swipePanning = false;\n        r.hoverData.draggingEles = false;\n        var cy = r.cy;\n        var zoom = cy.zoom();\n        var now = r.touchData.now;\n        var earlier = r.touchData.earlier;\n        if (e.touches[0]) {\n            var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);\n            now[0] = pos[0];\n            now[1] = pos[1];\n        }\n        if (e.touches[1]) {\n            var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY);\n            now[2] = pos[0];\n            now[3] = pos[1];\n        }\n        if (e.touches[2]) {\n            var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY);\n            now[4] = pos[0];\n            now[5] = pos[1];\n        }\n        var makeEvent = function makeEvent(type) {\n            return {\n                originalEvent: e,\n                type: type,\n                position: {\n                    x: now[0],\n                    y: now[1]\n                }\n            };\n        };\n        if (start) {\n            start.unactivate();\n        }\n        var ctxTapend;\n        if (r.touchData.cxt) {\n            ctxTapend = makeEvent('cxttapend');\n            if (start) {\n                start.emit(ctxTapend);\n            } else {\n                cy.emit(ctxTapend);\n            }\n            if (!r.touchData.cxtDragged) {\n                var ctxTap = makeEvent('cxttap');\n                if (start) {\n                    start.emit(ctxTap);\n                } else {\n                    cy.emit(ctxTap);\n                }\n            }\n            if (r.touchData.start) {\n                r.touchData.start._private.grabbed = false;\n            }\n            r.touchData.cxt = false;\n            r.touchData.start = null;\n            r.redraw();\n            return;\n        }\n        // no more box selection if we don't have three fingers\n        if (!e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting) {\n            r.touchData.selecting = false;\n            var box = cy.collection(r.getAllInBox(select[0], select[1], select[2], select[3]));\n            select[0] = undefined;\n            select[1] = undefined;\n            select[2] = undefined;\n            select[3] = undefined;\n            select[4] = 0;\n            r.redrawHint('select', true);\n            cy.emit(makeEvent('boxend'));\n            var eleWouldBeSelected = function eleWouldBeSelected(ele) {\n                return ele.selectable() && !ele.selected();\n            };\n            box.emit(makeEvent('box')).stdFilter(eleWouldBeSelected).select().emit(makeEvent('boxselect'));\n            if (box.nonempty()) {\n                r.redrawHint('eles', true);\n            }\n            r.redraw();\n        }\n        if (start != null) {\n            start.unactivate();\n        }\n        if (e.touches[2]) {\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n        } else if (e.touches[1]) ;\n        else if (e.touches[0]) ;\n        else if (!e.touches[0]) {\n            r.data.bgActivePosistion = undefined;\n            r.redrawHint('select', true);\n            var draggedEles = r.dragData.touchDragEles;\n            if (start != null) {\n                var startWasGrabbed = start._private.grabbed;\n                freeDraggedElements(draggedEles);\n                r.redrawHint('drag', true);\n                r.redrawHint('eles', true);\n                if (startWasGrabbed) {\n                    start.emit(makeEvent('freeon'));\n                    draggedEles.emit(makeEvent('free'));\n                    if (r.dragData.didDrag) {\n                        start.emit(makeEvent('dragfreeon'));\n                        draggedEles.emit(makeEvent('dragfree'));\n                    }\n                }\n                triggerEvents(start, [\n                    'touchend',\n                    'tapend',\n                    'vmouseup',\n                    'tapdragout'\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                start.unactivate();\n                r.touchData.start = null;\n            } else {\n                var near = r.findNearestElement(now[0], now[1], true, true);\n                triggerEvents(near, [\n                    'touchend',\n                    'tapend',\n                    'vmouseup',\n                    'tapdragout'\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n            }\n            var dx = r.touchData.startPosition[0] - now[0];\n            var dx2 = dx * dx;\n            var dy = r.touchData.startPosition[1] - now[1];\n            var dy2 = dy * dy;\n            var dist2 = dx2 + dy2;\n            var rdist2 = dist2 * zoom * zoom;\n            // Tap event, roughly same as mouse click event for touch\n            if (!r.touchData.singleTouchMoved) {\n                if (!start) {\n                    cy.$(':selected').unselect([\n                        'tapunselect'\n                    ]);\n                }\n                triggerEvents(start, [\n                    'tap',\n                    'vclick'\n                ], e, {\n                    x: now[0],\n                    y: now[1]\n                });\n                didDoubleTouch = false;\n                if (e.timeStamp - prevTouchTimeStamp <= cy.multiClickDebounceTime()) {\n                    touchTimeout && clearTimeout(touchTimeout);\n                    didDoubleTouch = true;\n                    prevTouchTimeStamp = null;\n                    triggerEvents(start, [\n                        'dbltap',\n                        'vdblclick'\n                    ], e, {\n                        x: now[0],\n                        y: now[1]\n                    });\n                } else {\n                    touchTimeout = setTimeout(function() {\n                        if (didDoubleTouch) return;\n                        triggerEvents(start, [\n                            'onetap',\n                            'voneclick'\n                        ], e, {\n                            x: now[0],\n                            y: now[1]\n                        });\n                    }, cy.multiClickDebounceTime());\n                    prevTouchTimeStamp = e.timeStamp;\n                }\n            }\n            // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance\n            if (start != null && !r.dragData.didDrag // didn't drag nodes around\n             && start._private.selectable && rdist2 < r.touchTapThreshold2 && !r.pinching // pinch to zoom should not affect selection\n            ) {\n                if (cy.selectionType() === 'single') {\n                    cy.$(isSelected).unmerge(start).unselect([\n                        'tapunselect'\n                    ]);\n                    start.select([\n                        'tapselect'\n                    ]);\n                } else {\n                    if (start.selected()) {\n                        start.unselect([\n                            'tapunselect'\n                        ]);\n                    } else {\n                        start.select([\n                            'tapselect'\n                        ]);\n                    }\n                }\n                r.redrawHint('eles', true);\n            }\n            r.touchData.singleTouchMoved = true;\n        }\n        for(var j = 0; j < now.length; j++){\n            earlier[j] = now[j];\n        }\n        r.dragData.didDrag = false; // reset for next touchstart\n        if (e.touches.length === 0) {\n            r.touchData.dragDelta = [];\n            r.touchData.startPosition = [\n                null,\n                null,\n                null,\n                null,\n                null,\n                null\n            ];\n            r.touchData.startGPosition = null;\n            r.touchData.didSelect = false;\n        }\n        if (e.touches.length < 2) {\n            if (e.touches.length === 1) {\n                // the old start global pos'n may not be the same finger that remains\n                r.touchData.startGPosition = [\n                    e.touches[0].clientX,\n                    e.touches[0].clientY\n                ];\n            }\n            r.pinching = false;\n            r.redrawHint('eles', true);\n            r.redraw();\n        }\n    //r.redraw();\n    }, false);\n    // fallback compatibility layer for ms pointer events\n    if (typeof TouchEvent === 'undefined') {\n        var pointers = [];\n        var makeTouch = function makeTouch(e) {\n            return {\n                clientX: e.clientX,\n                clientY: e.clientY,\n                force: 1,\n                identifier: e.pointerId,\n                pageX: e.pageX,\n                pageY: e.pageY,\n                radiusX: e.width / 2,\n                radiusY: e.height / 2,\n                screenX: e.screenX,\n                screenY: e.screenY,\n                target: e.target\n            };\n        };\n        var makePointer = function makePointer(e) {\n            return {\n                event: e,\n                touch: makeTouch(e)\n            };\n        };\n        var addPointer = function addPointer(e) {\n            pointers.push(makePointer(e));\n        };\n        var removePointer = function removePointer(e) {\n            for(var i = 0; i < pointers.length; i++){\n                var p = pointers[i];\n                if (p.event.pointerId === e.pointerId) {\n                    pointers.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var updatePointer = function updatePointer(e) {\n            var p = pointers.filter(function(p) {\n                return p.event.pointerId === e.pointerId;\n            })[0];\n            p.event = e;\n            p.touch = makeTouch(e);\n        };\n        var addTouchesToEvent = function addTouchesToEvent(e) {\n            e.touches = pointers.map(function(p) {\n                return p.touch;\n            });\n        };\n        var pointerIsMouse = function pointerIsMouse(e) {\n            return e.pointerType === 'mouse' || e.pointerType === 4;\n        };\n        r.registerBinding(r.container, 'pointerdown', function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            e.preventDefault();\n            addPointer(e);\n            addTouchesToEvent(e);\n            touchstartHandler(e);\n        });\n        r.registerBinding(r.container, 'pointerup', function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            removePointer(e);\n            addTouchesToEvent(e);\n            touchendHandler(e);\n        });\n        r.registerBinding(r.container, 'pointercancel', function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            removePointer(e);\n            addTouchesToEvent(e);\n            touchcancelHandler(e);\n        });\n        r.registerBinding(r.container, 'pointermove', function(e) {\n            if (pointerIsMouse(e)) {\n                return;\n            } // mouse already handled\n            e.preventDefault();\n            updatePointer(e);\n            addTouchesToEvent(e);\n            touchmoveHandler(e);\n        });\n    }\n};\nvar BRp$2 = {};\nBRp$2.generatePolygon = function(name, points) {\n    return this.nodeShapes[name] = {\n        renderer: this,\n        name: name,\n        points: points,\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl('polygon', context, centerX, centerY, width, height, this.points);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            return polygonIntersectLine(x, y, this.points, nodeX, nodeY, width / 2, height / 2, padding);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            return pointInsidePolygon(x, y, this.points, centerX, centerY, width, height, [\n                0,\n                -1\n            ], padding);\n        },\n        hasMiterBounds: name !== 'rectangle',\n        miterBounds: function miterBounds(centerX, centerY, width, height, strokeWidth, strokePosition) {\n            return miterBox(this.points, centerX, centerY, width, height, strokeWidth);\n        }\n    };\n};\nBRp$2.generateEllipse = function() {\n    return this.nodeShapes['ellipse'] = {\n        renderer: this,\n        name: 'ellipse',\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            return intersectLineEllipse(x, y, nodeX, nodeY, width / 2 + padding, height / 2 + padding);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            return checkInEllipse(x, y, width, height, centerX, centerY, padding);\n        }\n    };\n};\nBRp$2.generateRoundPolygon = function(name, points) {\n    return this.nodeShapes[name] = {\n        renderer: this,\n        name: name,\n        points: points,\n        getOrCreateCorners: function getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, field) {\n            if (rs[field] !== undefined && rs[field + '-cx'] === centerX && rs[field + '-cy'] === centerY) {\n                return rs[field];\n            }\n            rs[field] = new Array(points.length / 2);\n            rs[field + '-cx'] = centerX;\n            rs[field + '-cy'] = centerY;\n            var halfW = width / 2;\n            var halfH = height / 2;\n            cornerRadius = cornerRadius === 'auto' ? getRoundPolygonRadius(width, height) : cornerRadius;\n            var p = new Array(points.length / 2);\n            for(var _i = 0; _i < points.length / 2; _i++){\n                p[_i] = {\n                    x: centerX + halfW * points[_i * 2],\n                    y: centerY + halfH * points[_i * 2 + 1]\n                };\n            }\n            var i, p1, p2, p3, len = p.length;\n            p1 = p[len - 1];\n            // for each point\n            for(i = 0; i < len; i++){\n                p2 = p[i % len];\n                p3 = p[(i + 1) % len];\n                rs[field][i] = getRoundCorner(p1, p2, p3, cornerRadius);\n                p1 = p2;\n                p2 = p3;\n            }\n            return rs[field];\n        },\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius, rs) {\n            this.renderer.nodeShapeImpl('round-polygon', context, centerX, centerY, width, height, this.points, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, 'drawCorners'));\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius, rs) {\n            return roundPolygonIntersectLine(x, y, this.points, nodeX, nodeY, width, height, padding, this.getOrCreateCorners(nodeX, nodeY, width, height, cornerRadius, rs, 'corners'));\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius, rs) {\n            return pointInsideRoundPolygon(x, y, this.points, centerX, centerY, width, height, this.getOrCreateCorners(centerX, centerY, width, height, cornerRadius, rs, 'corners'));\n        }\n    };\n};\nBRp$2.generateRoundRectangle = function() {\n    return this.nodeShapes['round-rectangle'] = this.nodeShapes['roundrectangle'] = {\n        renderer: this,\n        name: 'round-rectangle',\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            var halfWidth = width / 2;\n            var halfHeight = height / 2;\n            cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(width, height) : cornerRadius;\n            cornerRadius = Math.min(halfWidth, halfHeight, cornerRadius);\n            var diam = cornerRadius * 2;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check top left quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY - halfHeight + cornerRadius, padding)) {\n                return true;\n            }\n            // Check top right quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY - halfHeight + cornerRadius, padding)) {\n                return true;\n            }\n            // Check bottom right quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX + halfWidth - cornerRadius, centerY + halfHeight - cornerRadius, padding)) {\n                return true;\n            }\n            // Check bottom left quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX - halfWidth + cornerRadius, centerY + halfHeight - cornerRadius, padding)) {\n                return true;\n            }\n            return false;\n        }\n    };\n};\nBRp$2.generateCutRectangle = function() {\n    return this.nodeShapes['cut-rectangle'] = this.nodeShapes['cutrectangle'] = {\n        renderer: this,\n        name: 'cut-rectangle',\n        cornerLength: getCutRectangleCornerLength(),\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, null, cornerRadius);\n        },\n        generateCutTrianglePts: function generateCutTrianglePts(width, height, centerX, centerY, cornerRadius) {\n            var cl = cornerRadius === 'auto' ? this.cornerLength : cornerRadius;\n            var hh = height / 2;\n            var hw = width / 2;\n            var xBegin = centerX - hw;\n            var xEnd = centerX + hw;\n            var yBegin = centerY - hh;\n            var yEnd = centerY + hh;\n            // points are in clockwise order, inner (imaginary) triangle pt on [4, 5]\n            return {\n                topLeft: [\n                    xBegin,\n                    yBegin + cl,\n                    xBegin + cl,\n                    yBegin,\n                    xBegin + cl,\n                    yBegin + cl\n                ],\n                topRight: [\n                    xEnd - cl,\n                    yBegin,\n                    xEnd,\n                    yBegin + cl,\n                    xEnd - cl,\n                    yBegin + cl\n                ],\n                bottomRight: [\n                    xEnd,\n                    yEnd - cl,\n                    xEnd - cl,\n                    yEnd,\n                    xEnd - cl,\n                    yEnd - cl\n                ],\n                bottomLeft: [\n                    xBegin + cl,\n                    yEnd,\n                    xBegin,\n                    yEnd - cl,\n                    xBegin + cl,\n                    yEnd - cl\n                ]\n            };\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            var cPts = this.generateCutTrianglePts(width + 2 * padding, height + 2 * padding, nodeX, nodeY, cornerRadius);\n            var pts = [].concat.apply([], [\n                cPts.topLeft.splice(0, 4),\n                cPts.topRight.splice(0, 4),\n                cPts.bottomRight.splice(0, 4),\n                cPts.bottomLeft.splice(0, 4)\n            ]);\n            return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            var cl = cornerRadius === 'auto' ? this.cornerLength : cornerRadius;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * cl, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * cl, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            var cutTrianglePts = this.generateCutTrianglePts(width, height, centerX, centerY);\n            return pointInsidePolygonPoints(x, y, cutTrianglePts.topLeft) || pointInsidePolygonPoints(x, y, cutTrianglePts.topRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomRight) || pointInsidePolygonPoints(x, y, cutTrianglePts.bottomLeft);\n        }\n    };\n};\nBRp$2.generateBarrel = function() {\n    return this.nodeShapes['barrel'] = {\n        renderer: this,\n        name: 'barrel',\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            // use two fixed t values for the bezier curve approximation\n            var t0 = 0.15;\n            var t1 = 0.5;\n            var t2 = 0.85;\n            var bPts = this.generateBarrelBezierPts(width + 2 * padding, height + 2 * padding, nodeX, nodeY);\n            var approximateBarrelCurvePts = function approximateBarrelCurvePts(pts) {\n                // approximate curve pts based on the two t values\n                var m0 = qbezierPtAt({\n                    x: pts[0],\n                    y: pts[1]\n                }, {\n                    x: pts[2],\n                    y: pts[3]\n                }, {\n                    x: pts[4],\n                    y: pts[5]\n                }, t0);\n                var m1 = qbezierPtAt({\n                    x: pts[0],\n                    y: pts[1]\n                }, {\n                    x: pts[2],\n                    y: pts[3]\n                }, {\n                    x: pts[4],\n                    y: pts[5]\n                }, t1);\n                var m2 = qbezierPtAt({\n                    x: pts[0],\n                    y: pts[1]\n                }, {\n                    x: pts[2],\n                    y: pts[3]\n                }, {\n                    x: pts[4],\n                    y: pts[5]\n                }, t2);\n                return [\n                    pts[0],\n                    pts[1],\n                    m0.x,\n                    m0.y,\n                    m1.x,\n                    m1.y,\n                    m2.x,\n                    m2.y,\n                    pts[4],\n                    pts[5]\n                ];\n            };\n            var pts = [].concat(approximateBarrelCurvePts(bPts.topLeft), approximateBarrelCurvePts(bPts.topRight), approximateBarrelCurvePts(bPts.bottomRight), approximateBarrelCurvePts(bPts.bottomLeft));\n            return polygonIntersectLine(x, y, pts, nodeX, nodeY);\n        },\n        generateBarrelBezierPts: function generateBarrelBezierPts(width, height, centerX, centerY) {\n            var hh = height / 2;\n            var hw = width / 2;\n            var xBegin = centerX - hw;\n            var xEnd = centerX + hw;\n            var yBegin = centerY - hh;\n            var yEnd = centerY + hh;\n            var curveConstants = getBarrelCurveConstants(width, height);\n            var hOffset = curveConstants.heightOffset;\n            var wOffset = curveConstants.widthOffset;\n            var ctrlPtXOffset = curveConstants.ctrlPtOffsetPct * width;\n            // points are in clockwise order, inner (imaginary) control pt on [4, 5]\n            var pts = {\n                topLeft: [\n                    xBegin,\n                    yBegin + hOffset,\n                    xBegin + ctrlPtXOffset,\n                    yBegin,\n                    xBegin + wOffset,\n                    yBegin\n                ],\n                topRight: [\n                    xEnd - wOffset,\n                    yBegin,\n                    xEnd - ctrlPtXOffset,\n                    yBegin,\n                    xEnd,\n                    yBegin + hOffset\n                ],\n                bottomRight: [\n                    xEnd,\n                    yEnd - hOffset,\n                    xEnd - ctrlPtXOffset,\n                    yEnd,\n                    xEnd - wOffset,\n                    yEnd\n                ],\n                bottomLeft: [\n                    xBegin + wOffset,\n                    yEnd,\n                    xBegin + ctrlPtXOffset,\n                    yEnd,\n                    xBegin,\n                    yEnd - hOffset\n                ]\n            };\n            pts.topLeft.isTop = true;\n            pts.topRight.isTop = true;\n            pts.bottomLeft.isBottom = true;\n            pts.bottomRight.isBottom = true;\n            return pts;\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            var curveConstants = getBarrelCurveConstants(width, height);\n            var hOffset = curveConstants.heightOffset;\n            var wOffset = curveConstants.widthOffset;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - 2 * hOffset, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - 2 * wOffset, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            var barrelCurvePts = this.generateBarrelBezierPts(width, height, centerX, centerY);\n            var getCurveT = function getCurveT(x, y, curvePts) {\n                var x0 = curvePts[4];\n                var x1 = curvePts[2];\n                var x2 = curvePts[0];\n                var y0 = curvePts[5];\n                // var y1 = curvePts[ 3 ];\n                var y2 = curvePts[1];\n                var xMin = Math.min(x0, x2);\n                var xMax = Math.max(x0, x2);\n                var yMin = Math.min(y0, y2);\n                var yMax = Math.max(y0, y2);\n                if (xMin <= x && x <= xMax && yMin <= y && y <= yMax) {\n                    var coeff = bezierPtsToQuadCoeff(x0, x1, x2);\n                    var roots = solveQuadratic(coeff[0], coeff[1], coeff[2], x);\n                    var validRoots = roots.filter(function(r) {\n                        return 0 <= r && r <= 1;\n                    });\n                    if (validRoots.length > 0) {\n                        return validRoots[0];\n                    }\n                }\n                return null;\n            };\n            var curveRegions = Object.keys(barrelCurvePts);\n            for(var i = 0; i < curveRegions.length; i++){\n                var corner = curveRegions[i];\n                var cornerPts = barrelCurvePts[corner];\n                var t = getCurveT(x, y, cornerPts);\n                if (t == null) {\n                    continue;\n                }\n                var y0 = cornerPts[5];\n                var y1 = cornerPts[3];\n                var y2 = cornerPts[1];\n                var bezY = qbezierAt(y0, y1, y2, t);\n                if (cornerPts.isTop && bezY <= y) {\n                    return true;\n                }\n                if (cornerPts.isBottom && y <= bezY) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    };\n};\nBRp$2.generateBottomRoundrectangle = function() {\n    return this.nodeShapes['bottom-round-rectangle'] = this.nodeShapes['bottomroundrectangle'] = {\n        renderer: this,\n        name: 'bottom-round-rectangle',\n        points: generateUnitNgonPointsFitToSquare(4, 0),\n        draw: function draw(context, centerX, centerY, width, height, cornerRadius) {\n            this.renderer.nodeShapeImpl(this.name, context, centerX, centerY, width, height, this.points, cornerRadius);\n        },\n        intersectLine: function intersectLine(nodeX, nodeY, width, height, x, y, padding, cornerRadius) {\n            var topStartX = nodeX - (width / 2 + padding);\n            var topStartY = nodeY - (height / 2 + padding);\n            var topEndY = topStartY;\n            var topEndX = nodeX + (width / 2 + padding);\n            var topIntersections = finiteLinesIntersect(x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);\n            if (topIntersections.length > 0) {\n                return topIntersections;\n            }\n            return roundRectangleIntersectLine(x, y, nodeX, nodeY, width, height, padding, cornerRadius);\n        },\n        checkPoint: function checkPoint(x, y, padding, width, height, centerX, centerY, cornerRadius) {\n            cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(width, height) : cornerRadius;\n            var diam = 2 * cornerRadius;\n            // Check hBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width, height - diam, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // Check vBox\n            if (pointInsidePolygon(x, y, this.points, centerX, centerY, width - diam, height, [\n                0,\n                -1\n            ], padding)) {\n                return true;\n            }\n            // check non-rounded top side\n            var outerWidth = width / 2 + 2 * padding;\n            var outerHeight = height / 2 + 2 * padding;\n            var points = [\n                centerX - outerWidth,\n                centerY - outerHeight,\n                centerX - outerWidth,\n                centerY,\n                centerX + outerWidth,\n                centerY,\n                centerX + outerWidth,\n                centerY - outerHeight\n            ];\n            if (pointInsidePolygonPoints(x, y, points)) {\n                return true;\n            }\n            // Check bottom right quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX + width / 2 - cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                return true;\n            }\n            // Check bottom left quarter circle\n            if (checkInEllipse(x, y, diam, diam, centerX - width / 2 + cornerRadius, centerY + height / 2 - cornerRadius, padding)) {\n                return true;\n            }\n            return false;\n        }\n    };\n};\nBRp$2.registerNodeShapes = function() {\n    var nodeShapes = this.nodeShapes = {};\n    var renderer = this;\n    this.generateEllipse();\n    this.generatePolygon('triangle', generateUnitNgonPointsFitToSquare(3, 0));\n    this.generateRoundPolygon('round-triangle', generateUnitNgonPointsFitToSquare(3, 0));\n    this.generatePolygon('rectangle', generateUnitNgonPointsFitToSquare(4, 0));\n    nodeShapes['square'] = nodeShapes['rectangle'];\n    this.generateRoundRectangle();\n    this.generateCutRectangle();\n    this.generateBarrel();\n    this.generateBottomRoundrectangle();\n    {\n        var diamondPoints = [\n            0,\n            1,\n            1,\n            0,\n            0,\n            -1,\n            -1,\n            0\n        ];\n        this.generatePolygon('diamond', diamondPoints);\n        this.generateRoundPolygon('round-diamond', diamondPoints);\n    }\n    this.generatePolygon('pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n    this.generateRoundPolygon('round-pentagon', generateUnitNgonPointsFitToSquare(5, 0));\n    this.generatePolygon('hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n    this.generateRoundPolygon('round-hexagon', generateUnitNgonPointsFitToSquare(6, 0));\n    this.generatePolygon('heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n    this.generateRoundPolygon('round-heptagon', generateUnitNgonPointsFitToSquare(7, 0));\n    this.generatePolygon('octagon', generateUnitNgonPointsFitToSquare(8, 0));\n    this.generateRoundPolygon('round-octagon', generateUnitNgonPointsFitToSquare(8, 0));\n    var star5Points = new Array(20);\n    {\n        var outerPoints = generateUnitNgonPoints(5, 0);\n        var innerPoints = generateUnitNgonPoints(5, Math.PI / 5);\n        // Outer radius is 1; inner radius of star is smaller\n        var innerRadius = 0.5 * (3 - Math.sqrt(5));\n        innerRadius *= 1.57;\n        for(var i = 0; i < innerPoints.length / 2; i++){\n            innerPoints[i * 2] *= innerRadius;\n            innerPoints[i * 2 + 1] *= innerRadius;\n        }\n        for(var i = 0; i < 20 / 4; i++){\n            star5Points[i * 4] = outerPoints[i * 2];\n            star5Points[i * 4 + 1] = outerPoints[i * 2 + 1];\n            star5Points[i * 4 + 2] = innerPoints[i * 2];\n            star5Points[i * 4 + 3] = innerPoints[i * 2 + 1];\n        }\n    }\n    star5Points = fitPolygonToSquare(star5Points);\n    this.generatePolygon('star', star5Points);\n    this.generatePolygon('vee', [\n        -1,\n        -1,\n        0,\n        -0.333,\n        1,\n        -1,\n        0,\n        1\n    ]);\n    this.generatePolygon('rhomboid', [\n        -1,\n        -1,\n        0.333,\n        -1,\n        1,\n        1,\n        -0.333,\n        1\n    ]);\n    this.generatePolygon('right-rhomboid', [\n        -0.333,\n        -1,\n        1,\n        -1,\n        0.333,\n        1,\n        -1,\n        1\n    ]);\n    this.nodeShapes['concavehexagon'] = this.generatePolygon('concave-hexagon', [\n        -1,\n        -0.95,\n        -0.75,\n        0,\n        -1,\n        0.95,\n        1,\n        0.95,\n        0.75,\n        0,\n        1,\n        -0.95\n    ]);\n    {\n        var tagPoints = [\n            -1,\n            -1,\n            0.25,\n            -1,\n            1,\n            0,\n            0.25,\n            1,\n            -1,\n            1\n        ];\n        this.generatePolygon('tag', tagPoints);\n        this.generateRoundPolygon('round-tag', tagPoints);\n    }\n    nodeShapes.makePolygon = function(points) {\n        // use caching on user-specified polygons so they are as fast as native shapes\n        var key = points.join('$');\n        var name = 'polygon-' + key;\n        var shape;\n        if (shape = this[name]) {\n            // got cached shape\n            return shape;\n        }\n        // create and cache new shape\n        return renderer.generatePolygon(name, points);\n    };\n};\nvar BRp$1 = {};\nBRp$1.timeToRender = function() {\n    return this.redrawTotalTime / this.redrawCount;\n};\nBRp$1.redraw = function(options) {\n    options = options || staticEmptyObject();\n    var r = this;\n    if (r.averageRedrawTime === undefined) {\n        r.averageRedrawTime = 0;\n    }\n    if (r.lastRedrawTime === undefined) {\n        r.lastRedrawTime = 0;\n    }\n    if (r.lastDrawTime === undefined) {\n        r.lastDrawTime = 0;\n    }\n    r.requestedFrame = true;\n    r.renderOptions = options;\n};\nBRp$1.beforeRender = function(fn, priority) {\n    // the renderer can't add tick callbacks when destroyed\n    if (this.destroyed) {\n        return;\n    }\n    if (priority == null) {\n        error('Priority is not optional for beforeRender');\n    }\n    var cbs = this.beforeRenderCallbacks;\n    cbs.push({\n        fn: fn,\n        priority: priority\n    });\n    // higher priority callbacks executed first\n    cbs.sort(function(a, b) {\n        return b.priority - a.priority;\n    });\n};\nvar beforeRenderCallbacks = function beforeRenderCallbacks(r, willDraw, startTime) {\n    var cbs = r.beforeRenderCallbacks;\n    for(var i = 0; i < cbs.length; i++){\n        cbs[i].fn(willDraw, startTime);\n    }\n};\nBRp$1.startRenderLoop = function() {\n    var r = this;\n    var cy = r.cy;\n    if (r.renderLoopStarted) {\n        return;\n    } else {\n        r.renderLoopStarted = true;\n    }\n    var _renderFn = function renderFn(requestTime) {\n        if (r.destroyed) {\n            return;\n        }\n        if (cy.batching()) ;\n        else if (r.requestedFrame && !r.skipFrame) {\n            beforeRenderCallbacks(r, true, requestTime);\n            var startTime = performanceNow();\n            r.render(r.renderOptions);\n            var endTime = r.lastDrawTime = performanceNow();\n            if (r.averageRedrawTime === undefined) {\n                r.averageRedrawTime = endTime - startTime;\n            }\n            if (r.redrawCount === undefined) {\n                r.redrawCount = 0;\n            }\n            r.redrawCount++;\n            if (r.redrawTotalTime === undefined) {\n                r.redrawTotalTime = 0;\n            }\n            var duration = endTime - startTime;\n            r.redrawTotalTime += duration;\n            r.lastRedrawTime = duration;\n            // use a weighted average with a bias from the previous average so we don't spike so easily\n            r.averageRedrawTime = r.averageRedrawTime / 2 + duration / 2;\n            r.requestedFrame = false;\n        } else {\n            beforeRenderCallbacks(r, false, requestTime);\n        }\n        r.skipFrame = false;\n        requestAnimationFrame(_renderFn);\n    };\n    requestAnimationFrame(_renderFn);\n};\nvar BaseRenderer = function BaseRenderer(options) {\n    this.init(options);\n};\nvar BR = BaseRenderer;\nvar BRp = BR.prototype;\nBRp.clientFunctions = [\n    'redrawHint',\n    'render',\n    'renderTo',\n    'matchCanvasSize',\n    'nodeShapeImpl',\n    'arrowShapeImpl'\n];\nBRp.init = function(options) {\n    var r = this;\n    r.options = options;\n    r.cy = options.cy;\n    var ctr = r.container = options.cy.container();\n    var containerWindow = r.cy.window();\n    // prepend a stylesheet in the head such that\n    if (containerWindow) {\n        var document1 = containerWindow.document;\n        var head = document1.head;\n        var stylesheetId = '__________cytoscape_stylesheet';\n        var className = '__________cytoscape_container';\n        var stylesheetAlreadyExists = document1.getElementById(stylesheetId) != null;\n        if (ctr.className.indexOf(className) < 0) {\n            ctr.className = (ctr.className || '') + ' ' + className;\n        }\n        if (!stylesheetAlreadyExists) {\n            var stylesheet = document1.createElement('style');\n            stylesheet.id = stylesheetId;\n            stylesheet.textContent = '.' + className + ' { position: relative; }';\n            head.insertBefore(stylesheet, head.children[0]); // first so lowest priority\n        }\n        var computedStyle = containerWindow.getComputedStyle(ctr);\n        var position = computedStyle.getPropertyValue('position');\n        if (position === 'static') {\n            warn('A Cytoscape container has style position:static and so can not use UI extensions properly');\n        }\n    }\n    r.selection = [\n        undefined,\n        undefined,\n        undefined,\n        undefined,\n        0\n    ]; // Coordinates for selection box, plus enabled flag\n    r.bezierProjPcts = [\n        0.05,\n        0.225,\n        0.4,\n        0.5,\n        0.6,\n        0.775,\n        0.95\n    ];\n    //--Pointer-related data\n    r.hoverData = {\n        down: null,\n        last: null,\n        downTime: null,\n        triggerMode: null,\n        dragging: false,\n        initialPan: [\n            null,\n            null\n        ],\n        capture: false\n    };\n    r.dragData = {\n        possibleDragElements: []\n    };\n    r.touchData = {\n        start: null,\n        capture: false,\n        // These 3 fields related to tap, taphold events\n        startPosition: [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ],\n        singleTouchStartTime: null,\n        singleTouchMoved: true,\n        now: [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ],\n        earlier: [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ]\n    };\n    r.redraws = 0;\n    r.showFps = options.showFps;\n    r.debug = options.debug;\n    r.webgl = options.webgl;\n    r.hideEdgesOnViewport = options.hideEdgesOnViewport;\n    r.textureOnViewport = options.textureOnViewport;\n    r.wheelSensitivity = options.wheelSensitivity;\n    r.motionBlurEnabled = options.motionBlur; // on by default\n    r.forcedPixelRatio = number$1(options.pixelRatio) ? options.pixelRatio : null;\n    r.motionBlur = options.motionBlur; // for initial kick off\n    r.motionBlurOpacity = options.motionBlurOpacity;\n    r.motionBlurTransparency = 1 - r.motionBlurOpacity;\n    r.motionBlurPxRatio = 1;\n    r.mbPxRBlurry = 1; //0.8;\n    r.minMbLowQualFrames = 4;\n    r.fullQualityMb = false;\n    r.clearedForMotionBlur = [];\n    r.desktopTapThreshold = options.desktopTapThreshold;\n    r.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;\n    r.touchTapThreshold = options.touchTapThreshold;\n    r.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;\n    r.tapholdDuration = 500;\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.beforeRenderPriorities = {\n        // higher priority execs before lower one\n        animations: 400,\n        eleCalcs: 300,\n        eleTxrDeq: 200,\n        lyrTxrDeq: 150,\n        lyrTxrSkip: 100\n    };\n    r.registerNodeShapes();\n    r.registerArrowShapes();\n    r.registerCalculationListeners();\n};\nBRp.notify = function(eventName, eles) {\n    var r = this;\n    var cy = r.cy;\n    // the renderer can't be notified after it's destroyed\n    if (this.destroyed) {\n        return;\n    }\n    if (eventName === 'init') {\n        r.load();\n        return;\n    }\n    if (eventName === 'destroy') {\n        r.destroy();\n        return;\n    }\n    if (eventName === 'add' || eventName === 'remove' || eventName === 'move' && cy.hasCompoundNodes() || eventName === 'load' || eventName === 'zorder' || eventName === 'mount') {\n        r.invalidateCachedZSortedEles();\n    }\n    if (eventName === 'viewport') {\n        r.redrawHint('select', true);\n    }\n    if (eventName === 'gc') {\n        r.redrawHint('gc', true);\n    }\n    if (eventName === 'load' || eventName === 'resize' || eventName === 'mount') {\n        r.invalidateContainerClientCoordsCache();\n        r.matchCanvasSize(r.container);\n    }\n    r.redrawHint('eles', true);\n    r.redrawHint('drag', true);\n    this.startRenderLoop();\n    this.redraw();\n};\nBRp.destroy = function() {\n    var r = this;\n    r.destroyed = true;\n    r.cy.stopAnimationLoop();\n    for(var i = 0; i < r.bindings.length; i++){\n        var binding = r.bindings[i];\n        var b = binding;\n        var tgt = b.target;\n        (tgt.off || tgt.removeEventListener).apply(tgt, b.args);\n    }\n    r.bindings = [];\n    r.beforeRenderCallbacks = [];\n    r.onUpdateEleCalcsFns = [];\n    if (r.removeObserver) {\n        r.removeObserver.disconnect();\n    }\n    if (r.styleObserver) {\n        r.styleObserver.disconnect();\n    }\n    if (r.resizeObserver) {\n        r.resizeObserver.disconnect();\n    }\n    if (r.labelCalcDiv) {\n        try {\n            document.body.removeChild(r.labelCalcDiv); // eslint-disable-line no-undef\n        } catch (e) {\n        // ie10 issue #1014\n        }\n    }\n};\nBRp.isHeadless = function() {\n    return false;\n};\n[\n    BRp$f,\n    BRp$5,\n    BRp$4,\n    BRp$3,\n    BRp$2,\n    BRp$1\n].forEach(function(props) {\n    extend(BRp, props);\n});\nvar fullFpsTime = 1000 / 60; // assume 60 frames per second\nvar defs = {\n    setupDequeueing: function setupDequeueing(opts) {\n        return function setupDequeueingImpl() {\n            var self1 = this;\n            var r = this.renderer;\n            if (self1.dequeueingSetup) {\n                return;\n            } else {\n                self1.dequeueingSetup = true;\n            }\n            var queueRedraw = debounce(function() {\n                r.redrawHint('eles', true);\n                r.redrawHint('drag', true);\n                r.redraw();\n            }, opts.deqRedrawThreshold);\n            var dequeue = function dequeue(willDraw, frameStartTime) {\n                var startTime = performanceNow();\n                var avgRenderTime = r.averageRedrawTime;\n                var renderTime = r.lastRedrawTime;\n                var deqd = [];\n                var extent = r.cy.extent();\n                var pixelRatio = r.getPixelRatio();\n                // if we aren't in a tick that causes a draw, then the rendered style\n                // queue won't automatically be flushed before dequeueing starts\n                if (!willDraw) {\n                    r.flushRenderedStyleQueue();\n                }\n                while(true){\n                    // eslint-disable-line no-constant-condition\n                    var now = performanceNow();\n                    var duration = now - startTime;\n                    var frameDuration = now - frameStartTime;\n                    if (renderTime < fullFpsTime) {\n                        // if we're rendering faster than the ideal fps, then do dequeueing\n                        // during all of the remaining frame time\n                        var timeAvailable = fullFpsTime - (willDraw ? avgRenderTime : 0);\n                        if (frameDuration >= opts.deqFastCost * timeAvailable) {\n                            break;\n                        }\n                    } else {\n                        if (willDraw) {\n                            if (duration >= opts.deqCost * renderTime || duration >= opts.deqAvgCost * avgRenderTime) {\n                                break;\n                            }\n                        } else if (frameDuration >= opts.deqNoDrawCost * fullFpsTime) {\n                            break;\n                        }\n                    }\n                    var thisDeqd = opts.deq(self1, pixelRatio, extent);\n                    if (thisDeqd.length > 0) {\n                        for(var i = 0; i < thisDeqd.length; i++){\n                            deqd.push(thisDeqd[i]);\n                        }\n                    } else {\n                        break;\n                    }\n                }\n                // callbacks on dequeue\n                if (deqd.length > 0) {\n                    opts.onDeqd(self1, deqd);\n                    if (!willDraw && opts.shouldRedraw(self1, deqd, pixelRatio, extent)) {\n                        queueRedraw();\n                    }\n                }\n            };\n            var priority = opts.priority || noop$1;\n            r.beforeRender(dequeue, priority(self1));\n        };\n    }\n};\n// Allows lookups for (ele, lvl) => cache.\n// Uses keys so elements may share the same cache.\nvar ElementTextureCacheLookup = /*#__PURE__*/ function() {\n    function ElementTextureCacheLookup(getKey) {\n        var doesEleInvalidateKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : falsify;\n        _classCallCheck(this, ElementTextureCacheLookup);\n        this.idsByKey = new Map$1();\n        this.keyForId = new Map$1();\n        this.cachesByLvl = new Map$1();\n        this.lvls = [];\n        this.getKey = getKey;\n        this.doesEleInvalidateKey = doesEleInvalidateKey;\n    }\n    return _createClass(ElementTextureCacheLookup, [\n        {\n            key: \"getIdsFor\",\n            value: function getIdsFor(key) {\n                if (key == null) {\n                    error(\"Can not get id list for null key\");\n                }\n                var idsByKey = this.idsByKey;\n                var ids = this.idsByKey.get(key);\n                if (!ids) {\n                    ids = new Set$1();\n                    idsByKey.set(key, ids);\n                }\n                return ids;\n            }\n        },\n        {\n            key: \"addIdForKey\",\n            value: function addIdForKey(key, id) {\n                if (key != null) {\n                    this.getIdsFor(key).add(id);\n                }\n            }\n        },\n        {\n            key: \"deleteIdForKey\",\n            value: function deleteIdForKey(key, id) {\n                if (key != null) {\n                    this.getIdsFor(key)[\"delete\"](id);\n                }\n            }\n        },\n        {\n            key: \"getNumberOfIdsForKey\",\n            value: function getNumberOfIdsForKey(key) {\n                if (key == null) {\n                    return 0;\n                } else {\n                    return this.getIdsFor(key).size;\n                }\n            }\n        },\n        {\n            key: \"updateKeyMappingFor\",\n            value: function updateKeyMappingFor(ele) {\n                var id = ele.id();\n                var prevKey = this.keyForId.get(id);\n                var currKey = this.getKey(ele);\n                this.deleteIdForKey(prevKey, id);\n                this.addIdForKey(currKey, id);\n                this.keyForId.set(id, currKey);\n            }\n        },\n        {\n            key: \"deleteKeyMappingFor\",\n            value: function deleteKeyMappingFor(ele) {\n                var id = ele.id();\n                var prevKey = this.keyForId.get(id);\n                this.deleteIdForKey(prevKey, id);\n                this.keyForId[\"delete\"](id);\n            }\n        },\n        {\n            key: \"keyHasChangedFor\",\n            value: function keyHasChangedFor(ele) {\n                var id = ele.id();\n                var prevKey = this.keyForId.get(id);\n                var newKey = this.getKey(ele);\n                return prevKey !== newKey;\n            }\n        },\n        {\n            key: \"isInvalid\",\n            value: function isInvalid(ele) {\n                return this.keyHasChangedFor(ele) || this.doesEleInvalidateKey(ele);\n            }\n        },\n        {\n            key: \"getCachesAt\",\n            value: function getCachesAt(lvl) {\n                var cachesByLvl = this.cachesByLvl, lvls = this.lvls;\n                var caches = cachesByLvl.get(lvl);\n                if (!caches) {\n                    caches = new Map$1();\n                    cachesByLvl.set(lvl, caches);\n                    lvls.push(lvl);\n                }\n                return caches;\n            }\n        },\n        {\n            key: \"getCache\",\n            value: function getCache(key, lvl) {\n                return this.getCachesAt(lvl).get(key);\n            }\n        },\n        {\n            key: \"get\",\n            value: function get(ele, lvl) {\n                var key = this.getKey(ele);\n                var cache = this.getCache(key, lvl);\n                // getting for an element may need to add to the id list b/c eles can share keys\n                if (cache != null) {\n                    this.updateKeyMappingFor(ele);\n                }\n                return cache;\n            }\n        },\n        {\n            key: \"getForCachedKey\",\n            value: function getForCachedKey(ele, lvl) {\n                var key = this.keyForId.get(ele.id()); // n.b. use cached key, not newly computed key\n                var cache = this.getCache(key, lvl);\n                return cache;\n            }\n        },\n        {\n            key: \"hasCache\",\n            value: function hasCache(key, lvl) {\n                return this.getCachesAt(lvl).has(key);\n            }\n        },\n        {\n            key: \"has\",\n            value: function has(ele, lvl) {\n                var key = this.getKey(ele);\n                return this.hasCache(key, lvl);\n            }\n        },\n        {\n            key: \"setCache\",\n            value: function setCache(key, lvl, cache) {\n                cache.key = key;\n                this.getCachesAt(lvl).set(key, cache);\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(ele, lvl, cache) {\n                var key = this.getKey(ele);\n                this.setCache(key, lvl, cache);\n                this.updateKeyMappingFor(ele);\n            }\n        },\n        {\n            key: \"deleteCache\",\n            value: function deleteCache(key, lvl) {\n                this.getCachesAt(lvl)[\"delete\"](key);\n            }\n        },\n        {\n            key: \"delete\",\n            value: function _delete(ele, lvl) {\n                var key = this.getKey(ele);\n                this.deleteCache(key, lvl);\n            }\n        },\n        {\n            key: \"invalidateKey\",\n            value: function invalidateKey(key) {\n                var _this = this;\n                this.lvls.forEach(function(lvl) {\n                    return _this.deleteCache(key, lvl);\n                });\n            }\n        },\n        {\n            key: \"invalidate\",\n            value: function invalidate(ele) {\n                var id = ele.id();\n                var key = this.keyForId.get(id); // n.b. use stored key rather than current (potential key)\n                this.deleteKeyMappingFor(ele);\n                var entireKeyInvalidated = this.doesEleInvalidateKey(ele);\n                if (entireKeyInvalidated) {\n                    // clear mapping for current key\n                    this.invalidateKey(key);\n                }\n                return entireKeyInvalidated || this.getNumberOfIdsForKey(key) === 0;\n            }\n        }\n    ]);\n}();\nvar minTxrH = 25; // the size of the texture cache for small height eles (special case)\nvar txrStepH = 50; // the min size of the regular cache, and the size it increases with each step up\nvar minLvl$1 = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl$1 = 3; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom$1 = 7.99; // beyond this zoom level, layered textures are not used\nvar eleTxrSpacing = 8; // spacing between elements on textures to avoid blitting overlaps\nvar defTxrWidth = 1024; // default/minimum texture width\nvar maxTxrW = 1024; // the maximum width of a texture\nvar maxTxrH = 1024; // the maximum height of a texture\nvar minUtility = 0.2; // if usage of texture is less than this, it is retired\nvar maxFullness = 0.8; // fullness of texture after which queue removal is checked\nvar maxFullnessChecks = 10; // dequeued after this many checks\nvar deqCost$1 = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost$1 = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost$1 = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost$1 = 0.9; // % of frame time to be used when >60fps\nvar deqRedrawThreshold$1 = 100; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar maxDeqSize$1 = 1; // number of eles to dequeue and render at higher texture in each batch\nvar getTxrReasons = {\n    dequeue: 'dequeue',\n    downscale: 'downscale',\n    highQuality: 'highQuality'\n};\nvar initDefaults = defaults$g({\n    getKey: null,\n    doesEleInvalidateKey: falsify,\n    drawElement: null,\n    getBoundingBox: null,\n    getRotationPoint: null,\n    getRotationOffset: null,\n    isVisible: trueify,\n    allowEdgeTxrCaching: true,\n    allowParentTxrCaching: true\n});\nvar ElementTextureCache = function ElementTextureCache(renderer, initOptions) {\n    var self1 = this;\n    self1.renderer = renderer;\n    self1.onDequeues = [];\n    var opts = initDefaults(initOptions);\n    extend(self1, opts);\n    self1.lookup = new ElementTextureCacheLookup(opts.getKey, opts.doesEleInvalidateKey);\n    self1.setupDequeueing();\n};\nvar ETCp = ElementTextureCache.prototype;\nETCp.reasons = getTxrReasons;\n// the list of textures in which new subtextures for elements can be placed\nETCp.getTextureQueue = function(txrH) {\n    var self1 = this;\n    self1.eleImgCaches = self1.eleImgCaches || {};\n    return self1.eleImgCaches[txrH] = self1.eleImgCaches[txrH] || [];\n};\n// the list of usused textures which can be recycled (in use in texture queue)\nETCp.getRetiredTextureQueue = function(txrH) {\n    var self1 = this;\n    var rtxtrQs = self1.eleImgCaches.retired = self1.eleImgCaches.retired || {};\n    var rtxtrQ = rtxtrQs[txrH] = rtxtrQs[txrH] || [];\n    return rtxtrQ;\n};\n// queue of element draw requests at different scale levels\nETCp.getElementQueue = function() {\n    var self1 = this;\n    var q = self1.eleCacheQueue = self1.eleCacheQueue || new Heap(function(a, b) {\n        return b.reqs - a.reqs;\n    });\n    return q;\n};\n// queue of element draw requests at different scale levels (element id lookup)\nETCp.getElementKeyToQueue = function() {\n    var self1 = this;\n    var k2q = self1.eleKeyToCacheQueue = self1.eleKeyToCacheQueue || {};\n    return k2q;\n};\nETCp.getElement = function(ele, bb, pxRatio, lvl, reason) {\n    var self1 = this;\n    var r = this.renderer;\n    var zoom = r.cy.zoom();\n    var lookup = this.lookup;\n    if (!bb || bb.w === 0 || bb.h === 0 || isNaN(bb.w) || isNaN(bb.h) || !ele.visible() || ele.removed()) {\n        return null;\n    }\n    if (!self1.allowEdgeTxrCaching && ele.isEdge() || !self1.allowParentTxrCaching && ele.isParent()) {\n        return null;\n    }\n    if (lvl == null) {\n        lvl = Math.ceil(log2(zoom * pxRatio));\n    }\n    if (lvl < minLvl$1) {\n        lvl = minLvl$1;\n    } else if (zoom >= maxZoom$1 || lvl > maxLvl$1) {\n        return null;\n    }\n    var scale = Math.pow(2, lvl);\n    var eleScaledH = bb.h * scale;\n    var eleScaledW = bb.w * scale;\n    var scaledLabelShown = r.eleTextBiggerThanMin(ele, scale);\n    if (!this.isVisible(ele, scaledLabelShown)) {\n        return null;\n    }\n    var eleCache = lookup.get(ele, lvl);\n    // if this get was on an unused/invalidated cache, then restore the texture usage metric\n    if (eleCache && eleCache.invalidated) {\n        eleCache.invalidated = false;\n        eleCache.texture.invalidatedWidth -= eleCache.width;\n    }\n    if (eleCache) {\n        return eleCache;\n    }\n    var txrH; // which texture height this ele belongs to\n    if (eleScaledH <= minTxrH) {\n        txrH = minTxrH;\n    } else if (eleScaledH <= txrStepH) {\n        txrH = txrStepH;\n    } else {\n        txrH = Math.ceil(eleScaledH / txrStepH) * txrStepH;\n    }\n    if (eleScaledH > maxTxrH || eleScaledW > maxTxrW) {\n        return null; // caching large elements is not efficient\n    }\n    var txrQ = self1.getTextureQueue(txrH);\n    // first try the second last one in case it has space at the end\n    var txr = txrQ[txrQ.length - 2];\n    var addNewTxr = function addNewTxr() {\n        return self1.recycleTexture(txrH, eleScaledW) || self1.addTexture(txrH, eleScaledW);\n    };\n    // try the last one if there is no second last one\n    if (!txr) {\n        txr = txrQ[txrQ.length - 1];\n    }\n    // if the last one doesn't exist, we need a first one\n    if (!txr) {\n        txr = addNewTxr();\n    }\n    // if there's no room in the current texture, we need a new one\n    if (txr.width - txr.usedWidth < eleScaledW) {\n        txr = addNewTxr();\n    }\n    var scalableFrom = function scalableFrom(otherCache) {\n        return otherCache && otherCache.scaledLabelShown === scaledLabelShown;\n    };\n    var deqing = reason && reason === getTxrReasons.dequeue;\n    var highQualityReq = reason && reason === getTxrReasons.highQuality;\n    var downscaleReq = reason && reason === getTxrReasons.downscale;\n    var higherCache; // the nearest cache with a higher level\n    for(var l = lvl + 1; l <= maxLvl$1; l++){\n        var c = lookup.get(ele, l);\n        if (c) {\n            higherCache = c;\n            break;\n        }\n    }\n    var oneUpCache = higherCache && higherCache.level === lvl + 1 ? higherCache : null;\n    var downscale = function downscale() {\n        txr.context.drawImage(oneUpCache.texture.canvas, oneUpCache.x, 0, oneUpCache.width, oneUpCache.height, txr.usedWidth, 0, eleScaledW, eleScaledH);\n    };\n    // reset ele area in texture\n    txr.context.setTransform(1, 0, 0, 1, 0, 0);\n    txr.context.clearRect(txr.usedWidth, 0, eleScaledW, txrH);\n    if (scalableFrom(oneUpCache)) {\n        // then we can relatively cheaply rescale the existing image w/o rerendering\n        downscale();\n    } else if (scalableFrom(higherCache)) {\n        // then use the higher cache for now and queue the next level down\n        // to cheaply scale towards the smaller level\n        if (highQualityReq) {\n            for(var _l = higherCache.level; _l > lvl; _l--){\n                oneUpCache = self1.getElement(ele, bb, pxRatio, _l, getTxrReasons.downscale);\n            }\n            downscale();\n        } else {\n            self1.queueElement(ele, higherCache.level - 1);\n            return higherCache;\n        }\n    } else {\n        var lowerCache; // the nearest cache with a lower level\n        if (!deqing && !highQualityReq && !downscaleReq) {\n            for(var _l2 = lvl - 1; _l2 >= minLvl$1; _l2--){\n                var _c = lookup.get(ele, _l2);\n                if (_c) {\n                    lowerCache = _c;\n                    break;\n                }\n            }\n        }\n        if (scalableFrom(lowerCache)) {\n            // then use the lower quality cache for now and queue the better one for later\n            self1.queueElement(ele, lvl);\n            return lowerCache;\n        }\n        txr.context.translate(txr.usedWidth, 0);\n        txr.context.scale(scale, scale);\n        this.drawElement(txr.context, ele, bb, scaledLabelShown, false);\n        txr.context.scale(1 / scale, 1 / scale);\n        txr.context.translate(-txr.usedWidth, 0);\n    }\n    eleCache = {\n        x: txr.usedWidth,\n        texture: txr,\n        level: lvl,\n        scale: scale,\n        width: eleScaledW,\n        height: eleScaledH,\n        scaledLabelShown: scaledLabelShown\n    };\n    txr.usedWidth += Math.ceil(eleScaledW + eleTxrSpacing);\n    txr.eleCaches.push(eleCache);\n    lookup.set(ele, lvl, eleCache);\n    self1.checkTextureFullness(txr);\n    return eleCache;\n};\nETCp.invalidateElements = function(eles) {\n    for(var i = 0; i < eles.length; i++){\n        this.invalidateElement(eles[i]);\n    }\n};\nETCp.invalidateElement = function(ele) {\n    var self1 = this;\n    var lookup = self1.lookup;\n    var caches = [];\n    var invalid = lookup.isInvalid(ele);\n    if (!invalid) {\n        return; // override the invalidation request if the element key has not changed\n    }\n    for(var lvl = minLvl$1; lvl <= maxLvl$1; lvl++){\n        var cache = lookup.getForCachedKey(ele, lvl);\n        if (cache) {\n            caches.push(cache);\n        }\n    }\n    var noOtherElesUseCache = lookup.invalidate(ele);\n    if (noOtherElesUseCache) {\n        for(var i = 0; i < caches.length; i++){\n            var _cache = caches[i];\n            var txr = _cache.texture;\n            // remove space from the texture it belongs to\n            txr.invalidatedWidth += _cache.width;\n            // mark the cache as invalidated\n            _cache.invalidated = true;\n            // retire the texture if its utility is low\n            self1.checkTextureUtility(txr);\n        }\n    }\n    // remove from queue since the old req was for the old state\n    self1.removeFromQueue(ele);\n};\nETCp.checkTextureUtility = function(txr) {\n    // invalidate all entries in the cache if the cache size is small\n    if (txr.invalidatedWidth >= minUtility * txr.width) {\n        this.retireTexture(txr);\n    }\n};\nETCp.checkTextureFullness = function(txr) {\n    // if texture has been mostly filled and passed over several times, remove\n    // it from the queue so we don't need to waste time looking at it to put new things\n    var self1 = this;\n    var txrQ = self1.getTextureQueue(txr.height);\n    if (txr.usedWidth / txr.width > maxFullness && txr.fullnessChecks >= maxFullnessChecks) {\n        removeFromArray(txrQ, txr);\n    } else {\n        txr.fullnessChecks++;\n    }\n};\nETCp.retireTexture = function(txr) {\n    var self1 = this;\n    var txrH = txr.height;\n    var txrQ = self1.getTextureQueue(txrH);\n    var lookup = this.lookup;\n    // retire the texture from the active / searchable queue:\n    removeFromArray(txrQ, txr);\n    txr.retired = true;\n    // remove the refs from the eles to the caches:\n    var eleCaches = txr.eleCaches;\n    for(var i = 0; i < eleCaches.length; i++){\n        var eleCache = eleCaches[i];\n        lookup.deleteCache(eleCache.key, eleCache.level);\n    }\n    clearArray(eleCaches);\n    // add the texture to a retired queue so it can be recycled in future:\n    var rtxtrQ = self1.getRetiredTextureQueue(txrH);\n    rtxtrQ.push(txr);\n};\nETCp.addTexture = function(txrH, minW) {\n    var self1 = this;\n    var txrQ = self1.getTextureQueue(txrH);\n    var txr = {};\n    txrQ.push(txr);\n    txr.eleCaches = [];\n    txr.height = txrH;\n    txr.width = Math.max(defTxrWidth, minW);\n    txr.usedWidth = 0;\n    txr.invalidatedWidth = 0;\n    txr.fullnessChecks = 0;\n    txr.canvas = self1.renderer.makeOffscreenCanvas(txr.width, txr.height);\n    txr.context = txr.canvas.getContext('2d');\n    return txr;\n};\nETCp.recycleTexture = function(txrH, minW) {\n    var self1 = this;\n    var txrQ = self1.getTextureQueue(txrH);\n    var rtxtrQ = self1.getRetiredTextureQueue(txrH);\n    for(var i = 0; i < rtxtrQ.length; i++){\n        var txr = rtxtrQ[i];\n        if (txr.width >= minW) {\n            txr.retired = false;\n            txr.usedWidth = 0;\n            txr.invalidatedWidth = 0;\n            txr.fullnessChecks = 0;\n            clearArray(txr.eleCaches);\n            txr.context.setTransform(1, 0, 0, 1, 0, 0);\n            txr.context.clearRect(0, 0, txr.width, txr.height);\n            removeFromArray(rtxtrQ, txr);\n            txrQ.push(txr);\n            return txr;\n        }\n    }\n};\nETCp.queueElement = function(ele, lvl) {\n    var self1 = this;\n    var q = self1.getElementQueue();\n    var k2q = self1.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var existingReq = k2q[key];\n    if (existingReq) {\n        // use the max lvl b/c in between lvls are cheap to make\n        existingReq.level = Math.max(existingReq.level, lvl);\n        existingReq.eles.merge(ele);\n        existingReq.reqs++;\n        q.updateItem(existingReq);\n    } else {\n        var req = {\n            eles: ele.spawn().merge(ele),\n            level: lvl,\n            reqs: 1,\n            key: key\n        };\n        q.push(req);\n        k2q[key] = req;\n    }\n};\nETCp.dequeue = function(pxRatio /*, extent*/ ) {\n    var self1 = this;\n    var q = self1.getElementQueue();\n    var k2q = self1.getElementKeyToQueue();\n    var dequeued = [];\n    var lookup = self1.lookup;\n    for(var i = 0; i < maxDeqSize$1; i++){\n        if (q.size() > 0) {\n            var req = q.pop();\n            var key = req.key;\n            var ele = req.eles[0]; // all eles have the same key\n            var cacheExists = lookup.hasCache(ele, req.level);\n            // clear out the key to req lookup\n            k2q[key] = null;\n            // dequeueing isn't necessary with an existing cache\n            if (cacheExists) {\n                continue;\n            }\n            dequeued.push(req);\n            var bb = self1.getBoundingBox(ele);\n            self1.getElement(ele, bb, pxRatio, req.level, getTxrReasons.dequeue);\n        } else {\n            break;\n        }\n    }\n    return dequeued;\n};\nETCp.removeFromQueue = function(ele) {\n    var self1 = this;\n    var q = self1.getElementQueue();\n    var k2q = self1.getElementKeyToQueue();\n    var key = this.getKey(ele);\n    var req = k2q[key];\n    if (req != null) {\n        if (req.eles.length === 1) {\n            // remove if last ele in the req\n            // bring to front of queue\n            req.reqs = MAX_INT$1;\n            q.updateItem(req);\n            q.pop(); // remove from queue\n            k2q[key] = null; // remove from lookup map\n        } else {\n            // otherwise just remove ele from req\n            req.eles.unmerge(ele);\n        }\n    }\n};\nETCp.onDequeue = function(fn) {\n    this.onDequeues.push(fn);\n};\nETCp.offDequeue = function(fn) {\n    removeFromArray(this.onDequeues, fn);\n};\nETCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold$1,\n    deqCost: deqCost$1,\n    deqAvgCost: deqAvgCost$1,\n    deqNoDrawCost: deqNoDrawCost$1,\n    deqFastCost: deqFastCost$1,\n    deq: function deq(self1, pxRatio, extent) {\n        return self1.dequeue(pxRatio, extent);\n    },\n    onDeqd: function onDeqd(self1, deqd) {\n        for(var i = 0; i < self1.onDequeues.length; i++){\n            var fn = self1.onDequeues[i];\n            fn(deqd);\n        }\n    },\n    shouldRedraw: function shouldRedraw(self1, deqd, pxRatio, extent) {\n        for(var i = 0; i < deqd.length; i++){\n            var eles = deqd[i].eles;\n            for(var j = 0; j < eles.length; j++){\n                var bb = eles[j].boundingBox();\n                if (boundingBoxesIntersect(bb, extent)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n    priority: function priority(self1) {\n        return self1.renderer.beforeRenderPriorities.eleTxrDeq;\n    }\n});\nvar defNumLayers = 1; // default number of layers to use\nvar minLvl = -4; // when scaling smaller than that we don't need to re-render\nvar maxLvl = 2; // when larger than this scale just render directly (caching is not helpful)\nvar maxZoom = 3.99; // beyond this zoom level, layered textures are not used\nvar deqRedrawThreshold = 50; // time to batch redraws together from dequeueing to allow more dequeueing calcs to happen in the meanwhile\nvar refineEleDebounceTime = 50; // time to debounce sharper ele texture updates\nvar deqCost = 0.15; // % of add'l rendering cost allowed for dequeuing ele caches each frame\nvar deqAvgCost = 0.1; // % of add'l rendering cost compared to average overall redraw time\nvar deqNoDrawCost = 0.9; // % of avg frame time that can be used for dequeueing when not drawing\nvar deqFastCost = 0.9; // % of frame time to be used when >60fps\nvar maxDeqSize = 1; // number of eles to dequeue and render at higher texture in each batch\nvar invalidThreshold = 250; // time threshold for disabling b/c of invalidations\nvar maxLayerArea = 4000 * 4000; // layers can't be bigger than this\nvar maxLayerDim = 32767; // maximum size for the width/height of layer canvases\nvar useHighQualityEleTxrReqs = true; // whether to use high quality ele txr requests (generally faster and cheaper in the longterm)\n// var log = function(){ console.log.apply( console, arguments ); };\nvar LayeredTextureCache = function LayeredTextureCache(renderer) {\n    var self1 = this;\n    var r = self1.renderer = renderer;\n    var cy = r.cy;\n    self1.layersByLevel = {}; // e.g. 2 => [ layer1, layer2, ..., layerN ]\n    self1.firstGet = true;\n    self1.lastInvalidationTime = performanceNow() - 2 * invalidThreshold;\n    self1.skipping = false;\n    self1.eleTxrDeqs = cy.collection();\n    self1.scheduleElementRefinement = debounce(function() {\n        self1.refineElementTextures(self1.eleTxrDeqs);\n        self1.eleTxrDeqs.unmerge(self1.eleTxrDeqs);\n    }, refineEleDebounceTime);\n    r.beforeRender(function(willDraw, now) {\n        if (now - self1.lastInvalidationTime <= invalidThreshold) {\n            self1.skipping = true;\n        } else {\n            self1.skipping = false;\n        }\n    }, r.beforeRenderPriorities.lyrTxrSkip);\n    var qSort = function qSort(a, b) {\n        return b.reqs - a.reqs;\n    };\n    self1.layersQueue = new Heap(qSort);\n    self1.setupDequeueing();\n};\nvar LTCp = LayeredTextureCache.prototype;\nvar layerIdPool = 0;\nvar MAX_INT = Math.pow(2, 53) - 1;\nLTCp.makeLayer = function(bb, lvl) {\n    var scale = Math.pow(2, lvl);\n    var w = Math.ceil(bb.w * scale);\n    var h = Math.ceil(bb.h * scale);\n    var canvas = this.renderer.makeOffscreenCanvas(w, h);\n    var layer = {\n        id: layerIdPool = ++layerIdPool % MAX_INT,\n        bb: bb,\n        level: lvl,\n        width: w,\n        height: h,\n        canvas: canvas,\n        context: canvas.getContext('2d'),\n        eles: [],\n        elesQueue: [],\n        reqs: 0\n    };\n    // log('make layer %s with w %s and h %s and lvl %s', layer.id, layer.width, layer.height, layer.level);\n    var cxt = layer.context;\n    var dx = -layer.bb.x1;\n    var dy = -layer.bb.y1;\n    // do the transform on creation to save cycles (it's the same for all eles)\n    cxt.scale(scale, scale);\n    cxt.translate(dx, dy);\n    return layer;\n};\nLTCp.getLayers = function(eles, pxRatio, lvl) {\n    var self1 = this;\n    var r = self1.renderer;\n    var cy = r.cy;\n    var zoom = cy.zoom();\n    var firstGet = self1.firstGet;\n    self1.firstGet = false;\n    // log('--\\nget layers with %s eles', eles.length);\n    //log eles.map(function(ele){ return ele.id() }) );\n    if (lvl == null) {\n        lvl = Math.ceil(log2(zoom * pxRatio));\n        if (lvl < minLvl) {\n            lvl = minLvl;\n        } else if (zoom >= maxZoom || lvl > maxLvl) {\n            return null;\n        }\n    }\n    self1.validateLayersElesOrdering(lvl, eles);\n    var layersByLvl = self1.layersByLevel;\n    var scale = Math.pow(2, lvl);\n    var layers = layersByLvl[lvl] = layersByLvl[lvl] || [];\n    var bb;\n    var lvlComplete = self1.levelIsComplete(lvl, eles);\n    var tmpLayers;\n    var checkTempLevels = function checkTempLevels() {\n        var canUseAsTmpLvl = function canUseAsTmpLvl(l) {\n            self1.validateLayersElesOrdering(l, eles);\n            if (self1.levelIsComplete(l, eles)) {\n                tmpLayers = layersByLvl[l];\n                return true;\n            }\n        };\n        var checkLvls = function checkLvls(dir) {\n            if (tmpLayers) {\n                return;\n            }\n            for(var l = lvl + dir; minLvl <= l && l <= maxLvl; l += dir){\n                if (canUseAsTmpLvl(l)) {\n                    break;\n                }\n            }\n        };\n        checkLvls(1);\n        checkLvls(-1);\n        // remove the invalid layers; they will be replaced as needed later in this function\n        for(var i = layers.length - 1; i >= 0; i--){\n            var layer = layers[i];\n            if (layer.invalid) {\n                removeFromArray(layers, layer);\n            }\n        }\n    };\n    if (!lvlComplete) {\n        // if the current level is incomplete, then use the closest, best quality layerset temporarily\n        // and later queue the current layerset so we can get the proper quality level soon\n        checkTempLevels();\n    } else {\n        // log('level complete, using existing layers\\n--');\n        return layers;\n    }\n    var getBb = function getBb() {\n        if (!bb) {\n            bb = makeBoundingBox();\n            for(var i = 0; i < eles.length; i++){\n                updateBoundingBox(bb, eles[i].boundingBox());\n            }\n        }\n        return bb;\n    };\n    var makeLayer = function makeLayer(opts) {\n        opts = opts || {};\n        var after = opts.after;\n        getBb();\n        var w = Math.ceil(bb.w * scale);\n        var h = Math.ceil(bb.h * scale);\n        if (w > maxLayerDim || h > maxLayerDim) {\n            return null;\n        }\n        var area = w * h;\n        if (area > maxLayerArea) {\n            return null;\n        }\n        var layer = self1.makeLayer(bb, lvl);\n        if (after != null) {\n            var index = layers.indexOf(after) + 1;\n            layers.splice(index, 0, layer);\n        } else if (opts.insert === undefined || opts.insert) {\n            // no after specified => first layer made so put at start\n            layers.unshift(layer);\n        }\n        // if( tmpLayers ){\n        //self.queueLayer( layer );\n        // }\n        return layer;\n    };\n    if (self1.skipping && !firstGet) {\n        // log('skip layers');\n        return null;\n    }\n    // log('do layers');\n    var layer = null;\n    var maxElesPerLayer = eles.length / defNumLayers;\n    var allowLazyQueueing = !firstGet;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        var rs = ele._private.rscratch;\n        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n        // log('look at ele', ele.id());\n        var existingLayer = caches[lvl];\n        if (existingLayer) {\n            // reuse layer for later eles\n            // log('reuse layer for', ele.id());\n            layer = existingLayer;\n            continue;\n        }\n        if (!layer || layer.eles.length >= maxElesPerLayer || !boundingBoxInBoundingBox(layer.bb, ele.boundingBox())) {\n            // log('make new layer for ele %s', ele.id());\n            layer = makeLayer({\n                insert: true,\n                after: layer\n            });\n            // if now layer can be built then we can't use layers at this level\n            if (!layer) {\n                return null;\n            }\n        // log('new layer with id %s', layer.id);\n        }\n        if (tmpLayers || allowLazyQueueing) {\n            // log('queue ele %s in layer %s', ele.id(), layer.id);\n            self1.queueLayer(layer, ele);\n        } else {\n            // log('draw ele %s in layer %s', ele.id(), layer.id);\n            self1.drawEleInLayer(layer, ele, lvl, pxRatio);\n        }\n        layer.eles.push(ele);\n        caches[lvl] = layer;\n    }\n    // log('--');\n    if (tmpLayers) {\n        // then we only queued the current layerset and can't draw it yet\n        return tmpLayers;\n    }\n    if (allowLazyQueueing) {\n        // log('lazy queue level', lvl);\n        return null;\n    }\n    return layers;\n};\n// a layer may want to use an ele cache of a higher level to avoid blurriness\n// so the layer level might not equal the ele level\nLTCp.getEleLevelForLayerLevel = function(lvl, pxRatio) {\n    return lvl;\n};\nLTCp.drawEleInLayer = function(layer, ele, lvl, pxRatio) {\n    var self1 = this;\n    var r = this.renderer;\n    var context = layer.context;\n    var bb = ele.boundingBox();\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n        return;\n    }\n    lvl = self1.getEleLevelForLayerLevel(lvl, pxRatio);\n    {\n        r.setImgSmoothing(context, false);\n    }\n    {\n        r.drawCachedElement(context, ele, null, null, lvl, useHighQualityEleTxrReqs);\n    }\n    {\n        r.setImgSmoothing(context, true);\n    }\n};\nLTCp.levelIsComplete = function(lvl, eles) {\n    var self1 = this;\n    var layers = self1.layersByLevel[lvl];\n    if (!layers || layers.length === 0) {\n        return false;\n    }\n    var numElesInLayers = 0;\n    for(var i = 0; i < layers.length; i++){\n        var layer = layers[i];\n        // if there are any eles needed to be drawn yet, the level is not complete\n        if (layer.reqs > 0) {\n            return false;\n        }\n        // if the layer is invalid, the level is not complete\n        if (layer.invalid) {\n            return false;\n        }\n        numElesInLayers += layer.eles.length;\n    }\n    // we should have exactly the number of eles passed in to be complete\n    if (numElesInLayers !== eles.length) {\n        return false;\n    }\n    return true;\n};\nLTCp.validateLayersElesOrdering = function(lvl, eles) {\n    var layers = this.layersByLevel[lvl];\n    if (!layers) {\n        return;\n    }\n    // if in a layer the eles are not in the same order, then the layer is invalid\n    // (i.e. there is an ele in between the eles in the layer)\n    for(var i = 0; i < layers.length; i++){\n        var layer = layers[i];\n        var offset = -1;\n        // find the offset\n        for(var j = 0; j < eles.length; j++){\n            if (layer.eles[0] === eles[j]) {\n                offset = j;\n                break;\n            }\n        }\n        if (offset < 0) {\n            // then the layer has nonexistent elements and is invalid\n            this.invalidateLayer(layer);\n            continue;\n        }\n        // the eles in the layer must be in the same continuous order, else the layer is invalid\n        var o = offset;\n        for(var j = 0; j < layer.eles.length; j++){\n            if (layer.eles[j] !== eles[o + j]) {\n                // log('invalidate based on ordering', layer.id);\n                this.invalidateLayer(layer);\n                break;\n            }\n        }\n    }\n};\nLTCp.updateElementsInLayers = function(eles, update) {\n    var self1 = this;\n    var isEles = element(eles[0]);\n    // collect udpated elements (cascaded from the layers) and update each\n    // layer itself along the way\n    for(var i = 0; i < eles.length; i++){\n        var req = isEles ? null : eles[i];\n        var ele = isEles ? eles[i] : eles[i].ele;\n        var rs = ele._private.rscratch;\n        var caches = rs.imgLayerCaches = rs.imgLayerCaches || {};\n        for(var l = minLvl; l <= maxLvl; l++){\n            var layer = caches[l];\n            if (!layer) {\n                continue;\n            }\n            // if update is a request from the ele cache, then it affects only\n            // the matching level\n            if (req && self1.getEleLevelForLayerLevel(layer.level) !== req.level) {\n                continue;\n            }\n            update(layer, ele, req);\n        }\n    }\n};\nLTCp.haveLayers = function() {\n    var self1 = this;\n    var haveLayers = false;\n    for(var l = minLvl; l <= maxLvl; l++){\n        var layers = self1.layersByLevel[l];\n        if (layers && layers.length > 0) {\n            haveLayers = true;\n            break;\n        }\n    }\n    return haveLayers;\n};\nLTCp.invalidateElements = function(eles) {\n    var self1 = this;\n    if (eles.length === 0) {\n        return;\n    }\n    self1.lastInvalidationTime = performanceNow();\n    // log('update invalidate layer time from eles');\n    if (eles.length === 0 || !self1.haveLayers()) {\n        return;\n    }\n    self1.updateElementsInLayers(eles, function invalAssocLayers(layer, ele, req) {\n        self1.invalidateLayer(layer);\n    });\n};\nLTCp.invalidateLayer = function(layer) {\n    // log('update invalidate layer time');\n    this.lastInvalidationTime = performanceNow();\n    if (layer.invalid) {\n        return;\n    } // save cycles\n    var lvl = layer.level;\n    var eles = layer.eles;\n    var layers = this.layersByLevel[lvl];\n    // log('invalidate layer', layer.id );\n    removeFromArray(layers, layer);\n    // layer.eles = [];\n    layer.elesQueue = [];\n    layer.invalid = true;\n    if (layer.replacement) {\n        layer.replacement.invalid = true;\n    }\n    for(var i = 0; i < eles.length; i++){\n        var caches = eles[i]._private.rscratch.imgLayerCaches;\n        if (caches) {\n            caches[lvl] = null;\n        }\n    }\n};\nLTCp.refineElementTextures = function(eles) {\n    var self1 = this;\n    // log('refine', eles.length);\n    self1.updateElementsInLayers(eles, function refineEachEle(layer, ele, req) {\n        var rLyr = layer.replacement;\n        if (!rLyr) {\n            rLyr = layer.replacement = self1.makeLayer(layer.bb, layer.level);\n            rLyr.replaces = layer;\n            rLyr.eles = layer.eles;\n        // log('make replacement layer %s for %s with level %s', rLyr.id, layer.id, rLyr.level);\n        }\n        if (!rLyr.reqs) {\n            for(var i = 0; i < rLyr.eles.length; i++){\n                self1.queueLayer(rLyr, rLyr.eles[i]);\n            }\n        // log('queue replacement layer refinement', rLyr.id);\n        }\n    });\n};\nLTCp.enqueueElementRefinement = function(ele) {\n    this.eleTxrDeqs.merge(ele);\n    this.scheduleElementRefinement();\n};\nLTCp.queueLayer = function(layer, ele) {\n    var self1 = this;\n    var q = self1.layersQueue;\n    var elesQ = layer.elesQueue;\n    var hasId = elesQ.hasId = elesQ.hasId || {};\n    // if a layer is going to be replaced, queuing is a waste of time\n    if (layer.replacement) {\n        return;\n    }\n    if (ele) {\n        if (hasId[ele.id()]) {\n            return;\n        }\n        elesQ.push(ele);\n        hasId[ele.id()] = true;\n    }\n    if (layer.reqs) {\n        layer.reqs++;\n        q.updateItem(layer);\n    } else {\n        layer.reqs = 1;\n        q.push(layer);\n    }\n};\nLTCp.dequeue = function(pxRatio) {\n    var self1 = this;\n    var q = self1.layersQueue;\n    var deqd = [];\n    var eleDeqs = 0;\n    while(eleDeqs < maxDeqSize){\n        if (q.size() === 0) {\n            break;\n        }\n        var layer = q.peek();\n        // if a layer has been or will be replaced, then don't waste time with it\n        if (layer.replacement) {\n            // log('layer %s in queue skipped b/c it already has a replacement', layer.id);\n            q.pop();\n            continue;\n        }\n        // if this is a replacement layer that has been superceded, then forget it\n        if (layer.replaces && layer !== layer.replaces.replacement) {\n            // log('layer is no longer the most uptodate replacement; dequeued', layer.id)\n            q.pop();\n            continue;\n        }\n        if (layer.invalid) {\n            // log('replacement layer %s is invalid; dequeued', layer.id);\n            q.pop();\n            continue;\n        }\n        var ele = layer.elesQueue.shift();\n        if (ele) {\n            // log('dequeue layer %s', layer.id);\n            self1.drawEleInLayer(layer, ele, layer.level, pxRatio);\n            eleDeqs++;\n        }\n        if (deqd.length === 0) {\n            // we need only one entry in deqd to queue redrawing etc\n            deqd.push(true);\n        }\n        // if the layer has all its eles done, then remove from the queue\n        if (layer.elesQueue.length === 0) {\n            q.pop();\n            layer.reqs = 0;\n            // log('dequeue of layer %s complete', layer.id);\n            // when a replacement layer is dequeued, it replaces the old layer in the level\n            if (layer.replaces) {\n                self1.applyLayerReplacement(layer);\n            }\n            self1.requestRedraw();\n        }\n    }\n    return deqd;\n};\nLTCp.applyLayerReplacement = function(layer) {\n    var self1 = this;\n    var layersInLevel = self1.layersByLevel[layer.level];\n    var replaced = layer.replaces;\n    var index = layersInLevel.indexOf(replaced);\n    // if the replaced layer is not in the active list for the level, then replacing\n    // refs would be a mistake (i.e. overwriting the true active layer)\n    if (index < 0 || replaced.invalid) {\n        // log('replacement layer would have no effect', layer.id);\n        return;\n    }\n    layersInLevel[index] = layer; // replace level ref\n    // replace refs in eles\n    for(var i = 0; i < layer.eles.length; i++){\n        var _p = layer.eles[i]._private;\n        var cache = _p.imgLayerCaches = _p.imgLayerCaches || {};\n        if (cache) {\n            cache[layer.level] = layer;\n        }\n    }\n    // log('apply replacement layer %s over %s', layer.id, replaced.id);\n    self1.requestRedraw();\n};\nLTCp.requestRedraw = debounce(function() {\n    var r = this.renderer;\n    r.redrawHint('eles', true);\n    r.redrawHint('drag', true);\n    r.redraw();\n}, 100);\nLTCp.setupDequeueing = defs.setupDequeueing({\n    deqRedrawThreshold: deqRedrawThreshold,\n    deqCost: deqCost,\n    deqAvgCost: deqAvgCost,\n    deqNoDrawCost: deqNoDrawCost,\n    deqFastCost: deqFastCost,\n    deq: function deq(self1, pxRatio) {\n        return self1.dequeue(pxRatio);\n    },\n    onDeqd: noop$1,\n    shouldRedraw: trueify,\n    priority: function priority(self1) {\n        return self1.renderer.beforeRenderPriorities.lyrTxrDeq;\n    }\n});\nvar CRp$b = {};\nvar impl;\nfunction polygon(context, points) {\n    for(var i = 0; i < points.length; i++){\n        var pt = points[i];\n        context.lineTo(pt.x, pt.y);\n    }\n}\nfunction triangleBackcurve(context, points, controlPoint) {\n    var firstPt;\n    for(var i = 0; i < points.length; i++){\n        var pt = points[i];\n        if (i === 0) {\n            firstPt = pt;\n        }\n        context.lineTo(pt.x, pt.y);\n    }\n    context.quadraticCurveTo(controlPoint.x, controlPoint.y, firstPt.x, firstPt.y);\n}\nfunction triangleTee(context, trianglePoints, teePoints) {\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    var triPts = trianglePoints;\n    for(var i = 0; i < triPts.length; i++){\n        var pt = triPts[i];\n        context.lineTo(pt.x, pt.y);\n    }\n    var teePts = teePoints;\n    var firstTeePt = teePoints[0];\n    context.moveTo(firstTeePt.x, firstTeePt.y);\n    for(var i = 1; i < teePts.length; i++){\n        var pt = teePts[i];\n        context.lineTo(pt.x, pt.y);\n    }\n    if (context.closePath) {\n        context.closePath();\n    }\n}\nfunction circleTriangle(context, trianglePoints, rx, ry, r) {\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n    var triPts = trianglePoints;\n    var firstTrPt = triPts[0];\n    context.moveTo(firstTrPt.x, firstTrPt.y);\n    for(var i = 0; i < triPts.length; i++){\n        var pt = triPts[i];\n        context.lineTo(pt.x, pt.y);\n    }\n    if (context.closePath) {\n        context.closePath();\n    }\n}\nfunction circle$1(context, rx, ry, r) {\n    context.arc(rx, ry, r, 0, Math.PI * 2, false);\n}\nCRp$b.arrowShapeImpl = function(name) {\n    return (impl || (impl = {\n        'polygon': polygon,\n        'triangle-backcurve': triangleBackcurve,\n        'triangle-tee': triangleTee,\n        'circle-triangle': circleTriangle,\n        'triangle-cross': triangleTee,\n        'circle': circle$1\n    }))[name];\n};\nvar CRp$a = {};\nCRp$a.drawElement = function(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity) {\n    var r = this;\n    if (ele.isNode()) {\n        r.drawNode(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    } else {\n        r.drawEdge(context, ele, shiftToOriginWithBb, showLabel, showOverlay, showOpacity);\n    }\n};\nCRp$a.drawElementOverlay = function(context, ele) {\n    var r = this;\n    if (ele.isNode()) {\n        r.drawNodeOverlay(context, ele);\n    } else {\n        r.drawEdgeOverlay(context, ele);\n    }\n};\nCRp$a.drawElementUnderlay = function(context, ele) {\n    var r = this;\n    if (ele.isNode()) {\n        r.drawNodeUnderlay(context, ele);\n    } else {\n        r.drawEdgeUnderlay(context, ele);\n    }\n};\nCRp$a.drawCachedElementPortion = function(context, ele, eleTxrCache, pxRatio, lvl, reason, getRotation, getOpacity) {\n    var r = this;\n    var bb = eleTxrCache.getBoundingBox(ele);\n    if (bb.w === 0 || bb.h === 0) {\n        return;\n    } // ignore zero size case\n    var eleCache = eleTxrCache.getElement(ele, bb, pxRatio, lvl, reason);\n    if (eleCache != null) {\n        var opacity = getOpacity(r, ele);\n        if (opacity === 0) {\n            return;\n        }\n        var theta = getRotation(r, ele);\n        var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h;\n        var x, y, sx, sy, smooth;\n        if (theta !== 0) {\n            var rotPt = eleTxrCache.getRotationPoint(ele);\n            sx = rotPt.x;\n            sy = rotPt.y;\n            context.translate(sx, sy);\n            context.rotate(theta);\n            smooth = r.getImgSmoothing(context);\n            if (!smooth) {\n                r.setImgSmoothing(context, true);\n            }\n            var off = eleTxrCache.getRotationOffset(ele);\n            x = off.x;\n            y = off.y;\n        } else {\n            x = x1;\n            y = y1;\n        }\n        var oldGlobalAlpha;\n        if (opacity !== 1) {\n            oldGlobalAlpha = context.globalAlpha;\n            context.globalAlpha = oldGlobalAlpha * opacity;\n        }\n        context.drawImage(eleCache.texture.canvas, eleCache.x, 0, eleCache.width, eleCache.height, x, y, w, h);\n        if (opacity !== 1) {\n            context.globalAlpha = oldGlobalAlpha;\n        }\n        if (theta !== 0) {\n            context.rotate(-theta);\n            context.translate(-sx, -sy);\n            if (!smooth) {\n                r.setImgSmoothing(context, false);\n            }\n        }\n    } else {\n        eleTxrCache.drawElement(context, ele); // direct draw fallback\n    }\n};\nvar getZeroRotation = function getZeroRotation() {\n    return 0;\n};\nvar getLabelRotation = function getLabelRotation(r, ele) {\n    return r.getTextAngle(ele, null);\n};\nvar getSourceLabelRotation = function getSourceLabelRotation(r, ele) {\n    return r.getTextAngle(ele, 'source');\n};\nvar getTargetLabelRotation = function getTargetLabelRotation(r, ele) {\n    return r.getTextAngle(ele, 'target');\n};\nvar getOpacity = function getOpacity(r, ele) {\n    return ele.effectiveOpacity();\n};\nvar getTextOpacity = function getTextOpacity(e, ele) {\n    return ele.pstyle('text-opacity').pfValue * ele.effectiveOpacity();\n};\nCRp$a.drawCachedElement = function(context, ele, pxRatio, extent, lvl, requestHighQuality) {\n    var r = this;\n    var _r$data = r.data, eleTxrCache = _r$data.eleTxrCache, lblTxrCache = _r$data.lblTxrCache, slbTxrCache = _r$data.slbTxrCache, tlbTxrCache = _r$data.tlbTxrCache;\n    var bb = ele.boundingBox();\n    var reason = requestHighQuality === true ? eleTxrCache.reasons.highQuality : null;\n    if (bb.w === 0 || bb.h === 0 || !ele.visible()) {\n        return;\n    }\n    if (!extent || boundingBoxesIntersect(bb, extent)) {\n        var isEdge = ele.isEdge();\n        var badLine = ele.element()._private.rscratch.badLine;\n        r.drawElementUnderlay(context, ele);\n        r.drawCachedElementPortion(context, ele, eleTxrCache, pxRatio, lvl, reason, getZeroRotation, getOpacity);\n        if (!isEdge || !badLine) {\n            r.drawCachedElementPortion(context, ele, lblTxrCache, pxRatio, lvl, reason, getLabelRotation, getTextOpacity);\n        }\n        if (isEdge && !badLine) {\n            r.drawCachedElementPortion(context, ele, slbTxrCache, pxRatio, lvl, reason, getSourceLabelRotation, getTextOpacity);\n            r.drawCachedElementPortion(context, ele, tlbTxrCache, pxRatio, lvl, reason, getTargetLabelRotation, getTextOpacity);\n        }\n        r.drawElementOverlay(context, ele);\n    }\n};\nCRp$a.drawElements = function(context, eles) {\n    var r = this;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        r.drawElement(context, ele);\n    }\n};\nCRp$a.drawCachedElements = function(context, eles, pxRatio, extent) {\n    var r = this;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n};\nCRp$a.drawCachedNodes = function(context, eles, pxRatio, extent) {\n    var r = this;\n    for(var i = 0; i < eles.length; i++){\n        var ele = eles[i];\n        if (!ele.isNode()) {\n            continue;\n        }\n        r.drawCachedElement(context, ele, pxRatio, extent);\n    }\n};\nCRp$a.drawLayeredElements = function(context, eles, pxRatio, extent) {\n    var r = this;\n    var layers = r.data.lyrTxrCache.getLayers(eles, pxRatio);\n    if (layers) {\n        for(var i = 0; i < layers.length; i++){\n            var layer = layers[i];\n            var bb = layer.bb;\n            if (bb.w === 0 || bb.h === 0) {\n                continue;\n            }\n            context.drawImage(layer.canvas, bb.x1, bb.y1, bb.w, bb.h);\n        }\n    } else {\n        // fall back on plain caching if no layers\n        r.drawCachedElements(context, eles, pxRatio, extent);\n    }\n};\nvar CRp$9 = {};\nCRp$9.drawEdge = function(context, edge, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var rs = edge._private.rscratch;\n    if (shouldDrawOpacity && !edge.visible()) {\n        return;\n    }\n    // if bezier ctrl pts can not be calculated, then die\n    if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n        // isNaN in case edge is impossible and browser bugs (e.g. safari)\n        return;\n    }\n    var bb;\n    if (shiftToOriginWithBb) {\n        bb = shiftToOriginWithBb;\n        context.translate(-bb.x1, -bb.y1);\n    }\n    var opacity = shouldDrawOpacity ? edge.pstyle('opacity').value : 1;\n    var lineOpacity = shouldDrawOpacity ? edge.pstyle('line-opacity').value : 1;\n    var curveStyle = edge.pstyle('curve-style').value;\n    var lineStyle = edge.pstyle('line-style').value;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    var lineCap = edge.pstyle('line-cap').value;\n    var lineOutlineWidth = edge.pstyle('line-outline-width').value;\n    var lineOutlineColor = edge.pstyle('line-outline-color').value;\n    var effectiveLineOpacity = opacity * lineOpacity;\n    // separate arrow opacity would require arrow-opacity property\n    var effectiveArrowOpacity = opacity * lineOpacity;\n    var drawLine = function drawLine() {\n        var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n        if (curveStyle === 'straight-triangle') {\n            r.eleStrokeStyle(context, edge, strokeOpacity);\n            r.drawEdgeTrianglePath(edge, context, rs.allpts);\n        } else {\n            context.lineWidth = edgeWidth;\n            context.lineCap = lineCap;\n            r.eleStrokeStyle(context, edge, strokeOpacity);\n            r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n            context.lineCap = 'butt'; // reset for other drawing functions\n        }\n    };\n    var drawLineOutline = function drawLineOutline() {\n        var strokeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveLineOpacity;\n        context.lineWidth = edgeWidth + lineOutlineWidth;\n        context.lineCap = lineCap;\n        if (lineOutlineWidth > 0) {\n            r.colorStrokeStyle(context, lineOutlineColor[0], lineOutlineColor[1], lineOutlineColor[2], strokeOpacity);\n        } else {\n            // do not draw any lineOutline\n            context.lineCap = 'butt'; // reset for other drawing functions\n            return;\n        }\n        if (curveStyle === 'straight-triangle') {\n            r.drawEdgeTrianglePath(edge, context, rs.allpts);\n        } else {\n            r.drawEdgePath(edge, context, rs.allpts, lineStyle);\n            context.lineCap = 'butt'; // reset for other drawing functions\n        }\n    };\n    var drawOverlay = function drawOverlay() {\n        if (!shouldDrawOverlay) {\n            return;\n        }\n        r.drawEdgeOverlay(context, edge);\n    };\n    var drawUnderlay = function drawUnderlay() {\n        if (!shouldDrawOverlay) {\n            return;\n        }\n        r.drawEdgeUnderlay(context, edge);\n    };\n    var drawArrows = function drawArrows() {\n        var arrowOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : effectiveArrowOpacity;\n        r.drawArrowheads(context, edge, arrowOpacity);\n    };\n    var drawText = function drawText() {\n        r.drawElementText(context, edge, null, drawLabel);\n    };\n    context.lineJoin = 'round';\n    var ghost = edge.pstyle('ghost').value === 'yes';\n    if (ghost) {\n        var gx = edge.pstyle('ghost-offset-x').pfValue;\n        var gy = edge.pstyle('ghost-offset-y').pfValue;\n        var ghostOpacity = edge.pstyle('ghost-opacity').value;\n        var effectiveGhostOpacity = effectiveLineOpacity * ghostOpacity;\n        context.translate(gx, gy);\n        drawLine(effectiveGhostOpacity);\n        drawArrows(effectiveGhostOpacity);\n        context.translate(-gx, -gy);\n    } else {\n        drawLineOutline();\n    }\n    drawUnderlay();\n    drawLine();\n    drawArrows();\n    drawOverlay();\n    drawText();\n    if (shiftToOriginWithBb) {\n        context.translate(bb.x1, bb.y1);\n    }\n};\nvar drawEdgeOverlayUnderlay = function drawEdgeOverlayUnderlay(overlayOrUnderlay) {\n    if (![\n        'overlay',\n        'underlay'\n    ].includes(overlayOrUnderlay)) {\n        throw new Error('Invalid state');\n    }\n    return function(context, edge) {\n        if (!edge.visible()) {\n            return;\n        }\n        var opacity = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n        if (opacity === 0) {\n            return;\n        }\n        var r = this;\n        var usePaths = r.usePaths();\n        var rs = edge._private.rscratch;\n        var padding = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n        var width = 2 * padding;\n        var color = edge.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n        context.lineWidth = width;\n        if (rs.edgeType === 'self' && !usePaths) {\n            context.lineCap = 'butt';\n        } else {\n            context.lineCap = 'round';\n        }\n        r.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n        r.drawEdgePath(edge, context, rs.allpts, 'solid');\n    };\n};\nCRp$9.drawEdgeOverlay = drawEdgeOverlayUnderlay('overlay');\nCRp$9.drawEdgeUnderlay = drawEdgeOverlayUnderlay('underlay');\nCRp$9.drawEdgePath = function(edge, context, pts, type) {\n    var rs = edge._private.rscratch;\n    var canvasCxt = context;\n    var path;\n    var pathCacheHit = false;\n    var usePaths = this.usePaths();\n    var lineDashPattern = edge.pstyle('line-dash-pattern').pfValue;\n    var lineDashOffset = edge.pstyle('line-dash-offset').pfValue;\n    if (usePaths) {\n        var pathCacheKey = pts.join('$');\n        var keyMatches = rs.pathCacheKey && rs.pathCacheKey === pathCacheKey;\n        if (keyMatches) {\n            path = context = rs.pathCache;\n            pathCacheHit = true;\n        } else {\n            path = context = new Path2D();\n            rs.pathCacheKey = pathCacheKey;\n            rs.pathCache = path;\n        }\n    }\n    if (canvasCxt.setLineDash) {\n        // for very outofdate browsers\n        switch(type){\n            case 'dotted':\n                canvasCxt.setLineDash([\n                    1,\n                    1\n                ]);\n                break;\n            case 'dashed':\n                canvasCxt.setLineDash(lineDashPattern);\n                canvasCxt.lineDashOffset = lineDashOffset;\n                break;\n            case 'solid':\n                canvasCxt.setLineDash([]);\n                break;\n        }\n    }\n    if (!pathCacheHit && !rs.badLine) {\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        context.moveTo(pts[0], pts[1]);\n        switch(rs.edgeType){\n            case 'bezier':\n            case 'self':\n            case 'compound':\n            case 'multibezier':\n                for(var i = 2; i + 3 < pts.length; i += 4){\n                    context.quadraticCurveTo(pts[i], pts[i + 1], pts[i + 2], pts[i + 3]);\n                }\n                break;\n            case 'straight':\n            case 'haystack':\n                for(var _i = 2; _i + 1 < pts.length; _i += 2){\n                    context.lineTo(pts[_i], pts[_i + 1]);\n                }\n                break;\n            case 'segments':\n                if (rs.isRound) {\n                    var _iterator = _createForOfIteratorHelper(rs.roundCorners), _step;\n                    try {\n                        for(_iterator.s(); !(_step = _iterator.n()).done;){\n                            var corner = _step.value;\n                            drawPreparedRoundCorner(context, corner);\n                        }\n                    } catch (err) {\n                        _iterator.e(err);\n                    } finally{\n                        _iterator.f();\n                    }\n                    context.lineTo(pts[pts.length - 2], pts[pts.length - 1]);\n                } else {\n                    for(var _i2 = 2; _i2 + 1 < pts.length; _i2 += 2){\n                        context.lineTo(pts[_i2], pts[_i2 + 1]);\n                    }\n                }\n                break;\n        }\n    }\n    context = canvasCxt;\n    if (usePaths) {\n        context.stroke(path);\n    } else {\n        context.stroke();\n    }\n    // reset any line dashes\n    if (context.setLineDash) {\n        // for very outofdate browsers\n        context.setLineDash([]);\n    }\n};\nCRp$9.drawEdgeTrianglePath = function(edge, context, pts) {\n    // use line stroke style for triangle fill style\n    context.fillStyle = context.strokeStyle;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    for(var i = 0; i + 1 < pts.length; i += 2){\n        var vector = [\n            pts[i + 2] - pts[i],\n            pts[i + 3] - pts[i + 1]\n        ];\n        var length = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);\n        var normal = [\n            vector[1] / length,\n            -vector[0] / length\n        ];\n        var triangleHead = [\n            normal[0] * edgeWidth / 2,\n            normal[1] * edgeWidth / 2\n        ];\n        context.beginPath();\n        context.moveTo(pts[i] - triangleHead[0], pts[i + 1] - triangleHead[1]);\n        context.lineTo(pts[i] + triangleHead[0], pts[i + 1] + triangleHead[1]);\n        context.lineTo(pts[i + 2], pts[i + 3]);\n        context.closePath();\n        context.fill();\n    }\n};\nCRp$9.drawArrowheads = function(context, edge, opacity) {\n    var rs = edge._private.rscratch;\n    var isHaystack = rs.edgeType === 'haystack';\n    if (!isHaystack) {\n        this.drawArrowhead(context, edge, 'source', rs.arrowStartX, rs.arrowStartY, rs.srcArrowAngle, opacity);\n    }\n    this.drawArrowhead(context, edge, 'mid-target', rs.midX, rs.midY, rs.midtgtArrowAngle, opacity);\n    this.drawArrowhead(context, edge, 'mid-source', rs.midX, rs.midY, rs.midsrcArrowAngle, opacity);\n    if (!isHaystack) {\n        this.drawArrowhead(context, edge, 'target', rs.arrowEndX, rs.arrowEndY, rs.tgtArrowAngle, opacity);\n    }\n};\nCRp$9.drawArrowhead = function(context, edge, prefix, x, y, angle, opacity) {\n    if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n        return;\n    }\n    var self1 = this;\n    var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n    if (arrowShape === 'none') {\n        return;\n    }\n    var arrowClearFill = edge.pstyle(prefix + '-arrow-fill').value === 'hollow' ? 'both' : 'filled';\n    var arrowFill = edge.pstyle(prefix + '-arrow-fill').value;\n    var edgeWidth = edge.pstyle('width').pfValue;\n    var pArrowWidth = edge.pstyle(prefix + '-arrow-width');\n    var arrowWidth = pArrowWidth.value === 'match-line' ? edgeWidth : pArrowWidth.pfValue;\n    if (pArrowWidth.units === '%') arrowWidth *= edgeWidth;\n    var edgeOpacity = edge.pstyle('opacity').value;\n    if (opacity === undefined) {\n        opacity = edgeOpacity;\n    }\n    var gco = context.globalCompositeOperation;\n    if (opacity !== 1 || arrowFill === 'hollow') {\n        // then extra clear is needed\n        context.globalCompositeOperation = 'destination-out';\n        self1.colorFillStyle(context, 255, 255, 255, 1);\n        self1.colorStrokeStyle(context, 255, 255, 255, 1);\n        self1.drawArrowShape(edge, context, arrowClearFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);\n        context.globalCompositeOperation = gco;\n    } // otherwise, the opaque arrow clears it for free :)\n    var color = edge.pstyle(prefix + '-arrow-color').value;\n    self1.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    self1.colorStrokeStyle(context, color[0], color[1], color[2], opacity);\n    self1.drawArrowShape(edge, context, arrowFill, edgeWidth, arrowShape, arrowWidth, x, y, angle);\n};\nCRp$9.drawArrowShape = function(edge, context, fill, edgeWidth, shape, shapeWidth, x, y, angle) {\n    var r = this;\n    var usePaths = this.usePaths() && shape !== 'triangle-cross';\n    var pathCacheHit = false;\n    var path;\n    var canvasContext = context;\n    var translation = {\n        x: x,\n        y: y\n    };\n    var scale = edge.pstyle('arrow-scale').value;\n    var size = this.getArrowWidth(edgeWidth, scale);\n    var shapeImpl = r.arrowShapes[shape];\n    if (usePaths) {\n        var cache = r.arrowPathCache = r.arrowPathCache || [];\n        var key = hashString(shape);\n        var cachedPath = cache[key];\n        if (cachedPath != null) {\n            path = context = cachedPath;\n            pathCacheHit = true;\n        } else {\n            path = context = new Path2D();\n            cache[key] = path;\n        }\n    }\n    if (!pathCacheHit) {\n        if (context.beginPath) {\n            context.beginPath();\n        }\n        if (usePaths) {\n            // store in the path cache with values easily manipulated later\n            shapeImpl.draw(context, 1, 0, {\n                x: 0,\n                y: 0\n            }, 1);\n        } else {\n            shapeImpl.draw(context, size, angle, translation, edgeWidth);\n        }\n        if (context.closePath) {\n            context.closePath();\n        }\n    }\n    context = canvasContext;\n    if (usePaths) {\n        // set transform to arrow position/orientation\n        context.translate(x, y);\n        context.rotate(angle);\n        context.scale(size, size);\n    }\n    if (fill === 'filled' || fill === 'both') {\n        if (usePaths) {\n            context.fill(path);\n        } else {\n            context.fill();\n        }\n    }\n    if (fill === 'hollow' || fill === 'both') {\n        context.lineWidth = shapeWidth / (usePaths ? size : 1);\n        context.lineJoin = 'miter';\n        if (usePaths) {\n            context.stroke(path);\n        } else {\n            context.stroke();\n        }\n    }\n    if (usePaths) {\n        // reset transform by applying inverse\n        context.scale(1 / size, 1 / size);\n        context.rotate(-angle);\n        context.translate(-x, -y);\n    }\n};\nvar CRp$8 = {};\nCRp$8.safeDrawImage = function(context, img, ix, iy, iw, ih, x, y, w, h) {\n    // detect problematic cases for old browsers with bad images (cheaper than try-catch)\n    if (iw <= 0 || ih <= 0 || w <= 0 || h <= 0) {\n        return;\n    }\n    try {\n        context.drawImage(img, ix, iy, iw, ih, x, y, w, h);\n    } catch (e) {\n        warn(e);\n    }\n};\nCRp$8.drawInscribedImage = function(context, img, node, index, nodeOpacity) {\n    var r = this;\n    var pos = node.position();\n    var nodeX = pos.x;\n    var nodeY = pos.y;\n    var styleObj = node.cy().style();\n    var getIndexedStyle = styleObj.getIndexedStyle.bind(styleObj);\n    var fit = getIndexedStyle(node, 'background-fit', 'value', index);\n    var repeat = getIndexedStyle(node, 'background-repeat', 'value', index);\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var paddingX2 = node.padding() * 2;\n    var nodeTW = nodeW + (getIndexedStyle(node, 'background-width-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n    var nodeTH = nodeH + (getIndexedStyle(node, 'background-height-relative-to', 'value', index) === 'inner' ? 0 : paddingX2);\n    var rs = node._private.rscratch;\n    var clip = getIndexedStyle(node, 'background-clip', 'value', index);\n    var shouldClip = clip === 'node';\n    var imgOpacity = getIndexedStyle(node, 'background-image-opacity', 'value', index) * nodeOpacity;\n    var smooth = getIndexedStyle(node, 'background-image-smoothing', 'value', index);\n    var cornerRadius = node.pstyle('corner-radius').value;\n    if (cornerRadius !== 'auto') cornerRadius = node.pstyle('corner-radius').pfValue;\n    var imgW = img.width || img.cachedW;\n    var imgH = img.height || img.cachedH;\n    // workaround for broken browsers like ie\n    if (null == imgW || null == imgH) {\n        document.body.appendChild(img); // eslint-disable-line no-undef\n        imgW = img.cachedW = img.width || img.offsetWidth;\n        imgH = img.cachedH = img.height || img.offsetHeight;\n        document.body.removeChild(img); // eslint-disable-line no-undef\n    }\n    var w = imgW;\n    var h = imgH;\n    if (getIndexedStyle(node, 'background-width', 'value', index) !== 'auto') {\n        if (getIndexedStyle(node, 'background-width', 'units', index) === '%') {\n            w = getIndexedStyle(node, 'background-width', 'pfValue', index) * nodeTW;\n        } else {\n            w = getIndexedStyle(node, 'background-width', 'pfValue', index);\n        }\n    }\n    if (getIndexedStyle(node, 'background-height', 'value', index) !== 'auto') {\n        if (getIndexedStyle(node, 'background-height', 'units', index) === '%') {\n            h = getIndexedStyle(node, 'background-height', 'pfValue', index) * nodeTH;\n        } else {\n            h = getIndexedStyle(node, 'background-height', 'pfValue', index);\n        }\n    }\n    if (w === 0 || h === 0) {\n        return; // no point in drawing empty image (and chrome is broken in this case)\n    }\n    if (fit === 'contain') {\n        var scale = Math.min(nodeTW / w, nodeTH / h);\n        w *= scale;\n        h *= scale;\n    } else if (fit === 'cover') {\n        var scale = Math.max(nodeTW / w, nodeTH / h);\n        w *= scale;\n        h *= scale;\n    }\n    var x = nodeX - nodeTW / 2; // left\n    var posXUnits = getIndexedStyle(node, 'background-position-x', 'units', index);\n    var posXPfVal = getIndexedStyle(node, 'background-position-x', 'pfValue', index);\n    if (posXUnits === '%') {\n        x += (nodeTW - w) * posXPfVal;\n    } else {\n        x += posXPfVal;\n    }\n    var offXUnits = getIndexedStyle(node, 'background-offset-x', 'units', index);\n    var offXPfVal = getIndexedStyle(node, 'background-offset-x', 'pfValue', index);\n    if (offXUnits === '%') {\n        x += (nodeTW - w) * offXPfVal;\n    } else {\n        x += offXPfVal;\n    }\n    var y = nodeY - nodeTH / 2; // top\n    var posYUnits = getIndexedStyle(node, 'background-position-y', 'units', index);\n    var posYPfVal = getIndexedStyle(node, 'background-position-y', 'pfValue', index);\n    if (posYUnits === '%') {\n        y += (nodeTH - h) * posYPfVal;\n    } else {\n        y += posYPfVal;\n    }\n    var offYUnits = getIndexedStyle(node, 'background-offset-y', 'units', index);\n    var offYPfVal = getIndexedStyle(node, 'background-offset-y', 'pfValue', index);\n    if (offYUnits === '%') {\n        y += (nodeTH - h) * offYPfVal;\n    } else {\n        y += offYPfVal;\n    }\n    if (rs.pathCache) {\n        x -= nodeX;\n        y -= nodeY;\n        nodeX = 0;\n        nodeY = 0;\n    }\n    var gAlpha = context.globalAlpha;\n    context.globalAlpha = imgOpacity;\n    var smoothingEnabled = r.getImgSmoothing(context);\n    var isSmoothingSwitched = false;\n    if (smooth === 'no' && smoothingEnabled) {\n        r.setImgSmoothing(context, false);\n        isSmoothingSwitched = true;\n    } else if (smooth === 'yes' && !smoothingEnabled) {\n        r.setImgSmoothing(context, true);\n        isSmoothingSwitched = true;\n    }\n    if (repeat === 'no-repeat') {\n        if (shouldClip) {\n            context.save();\n            if (rs.pathCache) {\n                context.clip(rs.pathCache);\n            } else {\n                r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);\n                context.clip();\n            }\n        }\n        r.safeDrawImage(context, img, 0, 0, imgW, imgH, x, y, w, h);\n        if (shouldClip) {\n            context.restore();\n        }\n    } else {\n        var pattern = context.createPattern(img, repeat);\n        context.fillStyle = pattern;\n        r.nodeShapes[r.getNodeShape(node)].draw(context, nodeX, nodeY, nodeTW, nodeTH, cornerRadius, rs);\n        context.translate(x, y);\n        context.fill();\n        context.translate(-x, -y);\n    }\n    context.globalAlpha = gAlpha;\n    if (isSmoothingSwitched) {\n        r.setImgSmoothing(context, smoothingEnabled);\n    }\n};\nvar CRp$7 = {};\nCRp$7.eleTextBiggerThanMin = function(ele, scale) {\n    if (!scale) {\n        var zoom = ele.cy().zoom();\n        var pxRatio = this.getPixelRatio();\n        var lvl = Math.ceil(log2(zoom * pxRatio)); // the effective texture level\n        scale = Math.pow(2, lvl);\n    }\n    var computedSize = ele.pstyle('font-size').pfValue * scale;\n    var minSize = ele.pstyle('min-zoomed-font-size').pfValue;\n    if (computedSize < minSize) {\n        return false;\n    }\n    return true;\n};\nCRp$7.drawElementText = function(context, ele, shiftToOriginWithBb, force, prefix) {\n    var useEleOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    if (force == null) {\n        if (useEleOpacity && !r.eleTextBiggerThanMin(ele)) {\n            return;\n        }\n    } else if (force === false) {\n        return;\n    }\n    if (ele.isNode()) {\n        var label = ele.pstyle('label');\n        if (!label || !label.value) {\n            return;\n        }\n        var justification = r.getLabelJustification(ele);\n        context.textAlign = justification;\n        context.textBaseline = 'bottom';\n    } else {\n        var badLine = ele.element()._private.rscratch.badLine;\n        var _label = ele.pstyle('label');\n        var srcLabel = ele.pstyle('source-label');\n        var tgtLabel = ele.pstyle('target-label');\n        if (badLine || (!_label || !_label.value) && (!srcLabel || !srcLabel.value) && (!tgtLabel || !tgtLabel.value)) {\n            return;\n        }\n        context.textAlign = 'center';\n        context.textBaseline = 'bottom';\n    }\n    var applyRotation = !shiftToOriginWithBb;\n    var bb;\n    if (shiftToOriginWithBb) {\n        bb = shiftToOriginWithBb;\n        context.translate(-bb.x1, -bb.y1);\n    }\n    if (prefix == null) {\n        r.drawText(context, ele, null, applyRotation, useEleOpacity);\n        if (ele.isEdge()) {\n            r.drawText(context, ele, 'source', applyRotation, useEleOpacity);\n            r.drawText(context, ele, 'target', applyRotation, useEleOpacity);\n        }\n    } else {\n        r.drawText(context, ele, prefix, applyRotation, useEleOpacity);\n    }\n    if (shiftToOriginWithBb) {\n        context.translate(bb.x1, bb.y1);\n    }\n};\nCRp$7.getFontCache = function(context) {\n    var cache;\n    this.fontCaches = this.fontCaches || [];\n    for(var i = 0; i < this.fontCaches.length; i++){\n        cache = this.fontCaches[i];\n        if (cache.context === context) {\n            return cache;\n        }\n    }\n    cache = {\n        context: context\n    };\n    this.fontCaches.push(cache);\n    return cache;\n};\n// set up canvas context with font\n// returns transformed text string\nCRp$7.setupTextStyle = function(context, ele) {\n    var useEleOpacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // Font style\n    var labelStyle = ele.pstyle('font-style').strValue;\n    var labelSize = ele.pstyle('font-size').pfValue + 'px';\n    var labelFamily = ele.pstyle('font-family').strValue;\n    var labelWeight = ele.pstyle('font-weight').strValue;\n    var opacity = useEleOpacity ? ele.effectiveOpacity() * ele.pstyle('text-opacity').value : 1;\n    var outlineOpacity = ele.pstyle('text-outline-opacity').value * opacity;\n    var color = ele.pstyle('color').value;\n    var outlineColor = ele.pstyle('text-outline-color').value;\n    context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;\n    context.lineJoin = 'round'; // so text outlines aren't jagged\n    this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n    this.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);\n};\nfunction circle(ctx, x, y, width, height) {\n    var diameter = Math.min(width, height);\n    var radius = diameter / 2;\n    var centerX = x + width / 2;\n    var centerY = y + height / 2;\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n    ctx.closePath();\n}\nfunction roundRect(ctx, x, y, width, height) {\n    var radius = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 5;\n    var r = Math.min(radius, width / 2, height / 2); // prevent overflow\n    ctx.beginPath();\n    ctx.moveTo(x + r, y);\n    ctx.lineTo(x + width - r, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + r);\n    ctx.lineTo(x + width, y + height - r);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);\n    ctx.lineTo(x + r, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - r);\n    ctx.lineTo(x, y + r);\n    ctx.quadraticCurveTo(x, y, x + r, y);\n    ctx.closePath();\n}\nCRp$7.getTextAngle = function(ele, prefix) {\n    var theta;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var pdash = prefix ? prefix + '-' : '';\n    var rotation = ele.pstyle(pdash + 'text-rotation');\n    if (rotation.strValue === 'autorotate') {\n        var textAngle = getPrefixedProperty(rscratch, 'labelAngle', prefix);\n        theta = ele.isEdge() ? textAngle : 0;\n    } else if (rotation.strValue === 'none') {\n        theta = 0;\n    } else {\n        theta = rotation.pfValue;\n    }\n    return theta;\n};\nCRp$7.drawText = function(context, ele, prefix) {\n    var applyRotation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var useEleOpacity = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var _p = ele._private;\n    var rscratch = _p.rscratch;\n    var parentOpacity = useEleOpacity ? ele.effectiveOpacity() : 1;\n    if (useEleOpacity && (parentOpacity === 0 || ele.pstyle('text-opacity').value === 0)) {\n        return;\n    }\n    // use 'main' as an alias for the main label (i.e. null prefix)\n    if (prefix === 'main') {\n        prefix = null;\n    }\n    var textX = getPrefixedProperty(rscratch, 'labelX', prefix);\n    var textY = getPrefixedProperty(rscratch, 'labelY', prefix);\n    var orgTextX, orgTextY; // used for rotation\n    var text = this.getLabelText(ele, prefix);\n    if (text != null && text !== '' && !isNaN(textX) && !isNaN(textY)) {\n        this.setupTextStyle(context, ele, useEleOpacity);\n        var pdash = prefix ? prefix + '-' : '';\n        var textW = getPrefixedProperty(rscratch, 'labelWidth', prefix);\n        var textH = getPrefixedProperty(rscratch, 'labelHeight', prefix);\n        var marginX = ele.pstyle(pdash + 'text-margin-x').pfValue;\n        var marginY = ele.pstyle(pdash + 'text-margin-y').pfValue;\n        var isEdge = ele.isEdge();\n        var halign = ele.pstyle('text-halign').value;\n        var valign = ele.pstyle('text-valign').value;\n        if (isEdge) {\n            halign = 'center';\n            valign = 'center';\n        }\n        textX += marginX;\n        textY += marginY;\n        var theta;\n        if (!applyRotation) {\n            theta = 0;\n        } else {\n            theta = this.getTextAngle(ele, prefix);\n        }\n        if (theta !== 0) {\n            orgTextX = textX;\n            orgTextY = textY;\n            context.translate(orgTextX, orgTextY);\n            context.rotate(theta);\n            textX = 0;\n            textY = 0;\n        }\n        switch(valign){\n            case 'top':\n                break;\n            case 'center':\n                textY += textH / 2;\n                break;\n            case 'bottom':\n                textY += textH;\n                break;\n        }\n        var backgroundOpacity = ele.pstyle('text-background-opacity').value;\n        var borderOpacity = ele.pstyle('text-border-opacity').value;\n        var textBorderWidth = ele.pstyle('text-border-width').pfValue;\n        var backgroundPadding = ele.pstyle('text-background-padding').pfValue;\n        var styleShape = ele.pstyle('text-background-shape').strValue;\n        var rounded = styleShape === 'round-rectangle' || styleShape === 'roundrectangle';\n        var circled = styleShape === 'circle';\n        var roundRadius = 2;\n        if (backgroundOpacity > 0 || textBorderWidth > 0 && borderOpacity > 0) {\n            var textFill = context.fillStyle;\n            var textStroke = context.strokeStyle;\n            var textLineWidth = context.lineWidth;\n            var textBackgroundColor = ele.pstyle('text-background-color').value;\n            var textBorderColor = ele.pstyle('text-border-color').value;\n            var textBorderStyle = ele.pstyle('text-border-style').value;\n            var doFill = backgroundOpacity > 0;\n            var doStroke = textBorderWidth > 0 && borderOpacity > 0;\n            var bgX = textX - backgroundPadding;\n            switch(halign){\n                case 'left':\n                    bgX -= textW;\n                    break;\n                case 'center':\n                    bgX -= textW / 2;\n                    break;\n            }\n            var bgY = textY - textH - backgroundPadding;\n            var bgW = textW + 2 * backgroundPadding;\n            var bgH = textH + 2 * backgroundPadding;\n            if (doFill) {\n                context.fillStyle = \"rgba(\".concat(textBackgroundColor[0], \",\").concat(textBackgroundColor[1], \",\").concat(textBackgroundColor[2], \",\").concat(backgroundOpacity * parentOpacity, \")\");\n            }\n            if (doStroke) {\n                context.strokeStyle = \"rgba(\".concat(textBorderColor[0], \",\").concat(textBorderColor[1], \",\").concat(textBorderColor[2], \",\").concat(borderOpacity * parentOpacity, \")\");\n                context.lineWidth = textBorderWidth;\n                if (context.setLineDash) {\n                    switch(textBorderStyle){\n                        case 'dotted':\n                            context.setLineDash([\n                                1,\n                                1\n                            ]);\n                            break;\n                        case 'dashed':\n                            context.setLineDash([\n                                4,\n                                2\n                            ]);\n                            break;\n                        case 'double':\n                            context.lineWidth = textBorderWidth / 4;\n                            context.setLineDash([]);\n                            break;\n                        case 'solid':\n                        default:\n                            context.setLineDash([]);\n                            break;\n                    }\n                }\n            }\n            if (rounded) {\n                context.beginPath();\n                roundRect(context, bgX, bgY, bgW, bgH, roundRadius);\n            } else if (circled) {\n                context.beginPath();\n                circle(context, bgX, bgY, bgW, bgH);\n            } else {\n                context.beginPath();\n                context.rect(bgX, bgY, bgW, bgH);\n            }\n            if (doFill) context.fill();\n            if (doStroke) context.stroke();\n            // Double border pass for 'double' style\n            if (doStroke && textBorderStyle === 'double') {\n                var whiteWidth = textBorderWidth / 2;\n                context.beginPath();\n                if (rounded) {\n                    roundRect(context, bgX + whiteWidth, bgY + whiteWidth, bgW - 2 * whiteWidth, bgH - 2 * whiteWidth, roundRadius);\n                } else {\n                    context.rect(bgX + whiteWidth, bgY + whiteWidth, bgW - 2 * whiteWidth, bgH - 2 * whiteWidth);\n                }\n                context.stroke();\n            }\n            context.fillStyle = textFill;\n            context.strokeStyle = textStroke;\n            context.lineWidth = textLineWidth;\n            if (context.setLineDash) context.setLineDash([]);\n        }\n        var lineWidth = 2 * ele.pstyle('text-outline-width').pfValue; // *2 b/c the stroke is drawn centred on the middle\n        if (lineWidth > 0) {\n            context.lineWidth = lineWidth;\n        }\n        if (ele.pstyle('text-wrap').value === 'wrap') {\n            var lines = getPrefixedProperty(rscratch, 'labelWrapCachedLines', prefix);\n            var lineHeight = getPrefixedProperty(rscratch, 'labelLineHeight', prefix);\n            var halfTextW = textW / 2;\n            var justification = this.getLabelJustification(ele);\n            if (justification === 'auto') ;\n            else if (halign === 'left') {\n                // auto justification : right\n                if (justification === 'left') {\n                    textX += -textW;\n                } else if (justification === 'center') {\n                    textX += -halfTextW;\n                } // else same as auto\n            } else if (halign === 'center') {\n                // auto justfication : center\n                if (justification === 'left') {\n                    textX += -halfTextW;\n                } else if (justification === 'right') {\n                    textX += halfTextW;\n                } // else same as auto\n            } else if (halign === 'right') {\n                // auto justification : left\n                if (justification === 'center') {\n                    textX += halfTextW;\n                } else if (justification === 'right') {\n                    textX += textW;\n                } // else same as auto\n            }\n            switch(valign){\n                case 'top':\n                    textY -= (lines.length - 1) * lineHeight;\n                    break;\n                case 'center':\n                case 'bottom':\n                    textY -= (lines.length - 1) * lineHeight;\n                    break;\n            }\n            for(var l = 0; l < lines.length; l++){\n                if (lineWidth > 0) {\n                    context.strokeText(lines[l], textX, textY);\n                }\n                context.fillText(lines[l], textX, textY);\n                textY += lineHeight;\n            }\n        } else {\n            if (lineWidth > 0) {\n                context.strokeText(text, textX, textY);\n            }\n            context.fillText(text, textX, textY);\n        }\n        if (theta !== 0) {\n            context.rotate(-theta);\n            context.translate(-orgTextX, -orgTextY);\n        }\n    }\n};\n/* global Path2D */ var CRp$6 = {};\nCRp$6.drawNode = function(context, node, shiftToOriginWithBb) {\n    var drawLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    var shouldDrawOverlay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    var shouldDrawOpacity = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n    var r = this;\n    var nodeWidth, nodeHeight;\n    var _p = node._private;\n    var rs = _p.rscratch;\n    var pos = node.position();\n    if (!number$1(pos.x) || !number$1(pos.y)) {\n        return; // can't draw node with undefined position\n    }\n    if (shouldDrawOpacity && !node.visible()) {\n        return;\n    }\n    var eleOpacity = shouldDrawOpacity ? node.effectiveOpacity() : 1;\n    var usePaths = r.usePaths();\n    var path;\n    var pathCacheHit = false;\n    var padding = node.padding();\n    nodeWidth = node.width() + 2 * padding;\n    nodeHeight = node.height() + 2 * padding;\n    //\n    // setup shift\n    var bb;\n    if (shiftToOriginWithBb) {\n        bb = shiftToOriginWithBb;\n        context.translate(-bb.x1, -bb.y1);\n    }\n    //\n    // load bg image\n    var bgImgProp = node.pstyle('background-image');\n    var urls = bgImgProp.value;\n    var urlDefined = new Array(urls.length);\n    var image = new Array(urls.length);\n    var numImages = 0;\n    for(var i = 0; i < urls.length; i++){\n        var url = urls[i];\n        var defd = urlDefined[i] = url != null && url !== 'none';\n        if (defd) {\n            var bgImgCrossOrigin = node.cy().style().getIndexedStyle(node, 'background-image-crossorigin', 'value', i);\n            numImages++;\n            // get image, and if not loaded then ask to redraw when later loaded\n            image[i] = r.getCachedImage(url, bgImgCrossOrigin, function() {\n                _p.backgroundTimestamp = Date.now();\n                node.emitAndNotify('background');\n            });\n        }\n    }\n    //\n    // setup styles\n    var darkness = node.pstyle('background-blacken').value;\n    var borderWidth = node.pstyle('border-width').pfValue;\n    var bgOpacity = node.pstyle('background-opacity').value * eleOpacity;\n    var borderColor = node.pstyle('border-color').value;\n    var borderStyle = node.pstyle('border-style').value;\n    var borderJoin = node.pstyle('border-join').value;\n    var borderCap = node.pstyle('border-cap').value;\n    var borderPosition = node.pstyle('border-position').value;\n    var borderPattern = node.pstyle('border-dash-pattern').pfValue;\n    var borderOffset = node.pstyle('border-dash-offset').pfValue;\n    var borderOpacity = node.pstyle('border-opacity').value * eleOpacity;\n    var outlineWidth = node.pstyle('outline-width').pfValue;\n    var outlineColor = node.pstyle('outline-color').value;\n    var outlineStyle = node.pstyle('outline-style').value;\n    var outlineOpacity = node.pstyle('outline-opacity').value * eleOpacity;\n    var outlineOffset = node.pstyle('outline-offset').value;\n    var cornerRadius = node.pstyle('corner-radius').value;\n    if (cornerRadius !== 'auto') cornerRadius = node.pstyle('corner-radius').pfValue;\n    var setupShapeColor = function setupShapeColor() {\n        var bgOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bgOpacity;\n        r.eleFillStyle(context, node, bgOpy);\n    };\n    var setupBorderColor = function setupBorderColor() {\n        var bdrOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : borderOpacity;\n        r.colorStrokeStyle(context, borderColor[0], borderColor[1], borderColor[2], bdrOpy);\n    };\n    var setupOutlineColor = function setupOutlineColor() {\n        var otlnOpy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : outlineOpacity;\n        r.colorStrokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], otlnOpy);\n    };\n    //\n    // setup shape\n    var getPath = function getPath(width, height, shape, points) {\n        var pathCache = r.nodePathCache = r.nodePathCache || [];\n        var key = hashStrings(shape === 'polygon' ? shape + ',' + points.join(',') : shape, '' + height, '' + width, '' + cornerRadius);\n        var cachedPath = pathCache[key];\n        var path;\n        var cacheHit = false;\n        if (cachedPath != null) {\n            path = cachedPath;\n            cacheHit = true;\n            rs.pathCache = path;\n        } else {\n            path = new Path2D();\n            pathCache[key] = rs.pathCache = path;\n        }\n        return {\n            path: path,\n            cacheHit: cacheHit\n        };\n    };\n    var styleShape = node.pstyle('shape').strValue;\n    var shapePts = node.pstyle('shape-polygon-points').pfValue;\n    if (usePaths) {\n        context.translate(pos.x, pos.y);\n        var shapePath = getPath(nodeWidth, nodeHeight, styleShape, shapePts);\n        path = shapePath.path;\n        pathCacheHit = shapePath.cacheHit;\n    }\n    var drawShape = function drawShape() {\n        if (!pathCacheHit) {\n            var npos = pos;\n            if (usePaths) {\n                npos = {\n                    x: 0,\n                    y: 0\n                };\n            }\n            r.nodeShapes[r.getNodeShape(node)].draw(path || context, npos.x, npos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n        }\n        if (usePaths) {\n            context.fill(path);\n        } else {\n            context.fill();\n        }\n    };\n    var drawImages = function drawImages() {\n        var nodeOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n        var inside = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var prevBging = _p.backgrounding;\n        var totalCompleted = 0;\n        for(var _i = 0; _i < image.length; _i++){\n            var bgContainment = node.cy().style().getIndexedStyle(node, 'background-image-containment', 'value', _i);\n            if (inside && bgContainment === 'over' || !inside && bgContainment === 'inside') {\n                totalCompleted++;\n                continue;\n            }\n            if (urlDefined[_i] && image[_i].complete && !image[_i].error) {\n                totalCompleted++;\n                r.drawInscribedImage(context, image[_i], node, _i, nodeOpacity);\n            }\n        }\n        _p.backgrounding = !(totalCompleted === numImages);\n        if (prevBging !== _p.backgrounding) {\n            // update style b/c :backgrounding state changed\n            node.updateStyle(false);\n        }\n    };\n    var drawPie = function drawPie() {\n        var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var pieOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n        if (r.hasPie(node)) {\n            r.drawPie(context, node, pieOpacity);\n            // redraw/restore path if steps after pie need it\n            if (redrawShape) {\n                if (!usePaths) {\n                    r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n                }\n            }\n        }\n    };\n    var drawStripe = function drawStripe() {\n        var redrawShape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        var stripeOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : eleOpacity;\n        if (r.hasStripe(node)) {\n            context.save();\n            if (usePaths) {\n                context.clip(rs.pathCache);\n            } else {\n                r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n                context.clip();\n            }\n            r.drawStripe(context, node, stripeOpacity);\n            context.restore();\n            // redraw/restore path if steps after stripes need it\n            if (redrawShape) {\n                if (!usePaths) {\n                    r.nodeShapes[r.getNodeShape(node)].draw(context, pos.x, pos.y, nodeWidth, nodeHeight, cornerRadius, rs);\n                }\n            }\n        }\n    };\n    var darken = function darken() {\n        var darkenOpacity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : eleOpacity;\n        var opacity = (darkness > 0 ? darkness : -darkness) * darkenOpacity;\n        var c = darkness > 0 ? 0 : 255;\n        if (darkness !== 0) {\n            r.colorFillStyle(context, c, c, c, opacity);\n            if (usePaths) {\n                context.fill(path);\n            } else {\n                context.fill();\n            }\n        }\n    };\n    var drawBorder = function drawBorder() {\n        if (borderWidth > 0) {\n            context.lineWidth = borderWidth;\n            context.lineCap = borderCap;\n            context.lineJoin = borderJoin;\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                switch(borderStyle){\n                    case 'dotted':\n                        context.setLineDash([\n                            1,\n                            1\n                        ]);\n                        break;\n                    case 'dashed':\n                        context.setLineDash(borderPattern);\n                        context.lineDashOffset = borderOffset;\n                        break;\n                    case 'solid':\n                    case 'double':\n                        context.setLineDash([]);\n                        break;\n                }\n            }\n            if (borderPosition !== 'center') {\n                context.save();\n                context.lineWidth *= 2;\n                if (borderPosition === 'inside') {\n                    usePaths ? context.clip(path) : context.clip();\n                } else {\n                    var region = new Path2D();\n                    region.rect(-nodeWidth / 2 - borderWidth, -nodeHeight / 2 - borderWidth, nodeWidth + 2 * borderWidth, nodeHeight + 2 * borderWidth);\n                    region.addPath(path);\n                    context.clip(region, 'evenodd');\n                }\n                usePaths ? context.stroke(path) : context.stroke();\n                context.restore();\n            } else {\n                usePaths ? context.stroke(path) : context.stroke();\n            }\n            if (borderStyle === 'double') {\n                context.lineWidth = borderWidth / 3;\n                var gco = context.globalCompositeOperation;\n                context.globalCompositeOperation = 'destination-out';\n                if (usePaths) {\n                    context.stroke(path);\n                } else {\n                    context.stroke();\n                }\n                context.globalCompositeOperation = gco;\n            }\n            // reset in case we changed the border style\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                context.setLineDash([]);\n            }\n        }\n    };\n    var drawOutline = function drawOutline() {\n        if (outlineWidth > 0) {\n            context.lineWidth = outlineWidth;\n            context.lineCap = 'butt';\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                switch(outlineStyle){\n                    case 'dotted':\n                        context.setLineDash([\n                            1,\n                            1\n                        ]);\n                        break;\n                    case 'dashed':\n                        context.setLineDash([\n                            4,\n                            2\n                        ]);\n                        break;\n                    case 'solid':\n                    case 'double':\n                        context.setLineDash([]);\n                        break;\n                }\n            }\n            var npos = pos;\n            if (usePaths) {\n                npos = {\n                    x: 0,\n                    y: 0\n                };\n            }\n            var shape = r.getNodeShape(node);\n            var bWidth = borderWidth;\n            if (borderPosition === 'inside') bWidth = 0;\n            if (borderPosition === 'outside') bWidth *= 2;\n            var scaleX = (nodeWidth + bWidth + (outlineWidth + outlineOffset)) / nodeWidth;\n            var scaleY = (nodeHeight + bWidth + (outlineWidth + outlineOffset)) / nodeHeight;\n            var sWidth = nodeWidth * scaleX;\n            var sHeight = nodeHeight * scaleY;\n            var points = r.nodeShapes[shape].points;\n            var _path;\n            if (usePaths) {\n                var outlinePath = getPath(sWidth, sHeight, shape, points);\n                _path = outlinePath.path;\n            }\n            // draw the outline path, either by using expanded points or by scaling \n            // the dimensions, depending on shape\n            if (shape === \"ellipse\") {\n                r.drawEllipsePath(_path || context, npos.x, npos.y, sWidth, sHeight);\n            } else if ([\n                'round-diamond',\n                'round-heptagon',\n                'round-hexagon',\n                'round-octagon',\n                'round-pentagon',\n                'round-polygon',\n                'round-triangle',\n                'round-tag'\n            ].includes(shape)) {\n                var sMult = 0;\n                var offsetX = 0;\n                var offsetY = 0;\n                if (shape === 'round-diamond') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.4;\n                } else if (shape === 'round-heptagon') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.075;\n                    offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 35;\n                } else if (shape === 'round-hexagon') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;\n                } else if (shape === 'round-pentagon') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.13;\n                    offsetY = -(bWidth / 2 + outlineOffset + outlineWidth) / 15;\n                } else if (shape === 'round-tag') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * 1.12;\n                    offsetX = (bWidth / 2 + outlineWidth + outlineOffset) * .07;\n                } else if (shape === 'round-triangle') {\n                    sMult = (bWidth + outlineOffset + outlineWidth) * (Math.PI / 2);\n                    offsetY = -(bWidth + outlineOffset / 2 + outlineWidth) / Math.PI;\n                }\n                if (sMult !== 0) {\n                    scaleX = (nodeWidth + sMult) / nodeWidth;\n                    sWidth = nodeWidth * scaleX;\n                    if (![\n                        'round-hexagon',\n                        'round-tag'\n                    ].includes(shape)) {\n                        scaleY = (nodeHeight + sMult) / nodeHeight;\n                        sHeight = nodeHeight * scaleY;\n                    }\n                }\n                cornerRadius = cornerRadius === 'auto' ? getRoundPolygonRadius(sWidth, sHeight) : cornerRadius;\n                var halfW = sWidth / 2;\n                var halfH = sHeight / 2;\n                var radius = cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2;\n                var p = new Array(points.length / 2);\n                var corners = new Array(points.length / 2);\n                for(var _i2 = 0; _i2 < points.length / 2; _i2++){\n                    p[_i2] = {\n                        x: npos.x + offsetX + halfW * points[_i2 * 2],\n                        y: npos.y + offsetY + halfH * points[_i2 * 2 + 1]\n                    };\n                }\n                var _i3, p1, p2, p3, len = p.length;\n                p1 = p[len - 1];\n                // for each point\n                for(_i3 = 0; _i3 < len; _i3++){\n                    p2 = p[_i3 % len];\n                    p3 = p[(_i3 + 1) % len];\n                    corners[_i3] = getRoundCorner(p1, p2, p3, radius);\n                    p1 = p2;\n                    p2 = p3;\n                }\n                r.drawRoundPolygonPath(_path || context, npos.x + offsetX, npos.y + offsetY, nodeWidth * scaleX, nodeHeight * scaleY, points, corners);\n            } else if ([\n                'roundrectangle',\n                'round-rectangle'\n            ].includes(shape)) {\n                cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;\n                r.drawRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);\n            } else if ([\n                'cutrectangle',\n                'cut-rectangle'\n            ].includes(shape)) {\n                cornerRadius = cornerRadius === 'auto' ? getCutRectangleCornerLength() : cornerRadius;\n                r.drawCutRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, null, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 4);\n            } else if ([\n                'bottomroundrectangle',\n                'bottom-round-rectangle'\n            ].includes(shape)) {\n                cornerRadius = cornerRadius === 'auto' ? getRoundRectangleRadius(sWidth, sHeight) : cornerRadius;\n                r.drawBottomRoundRectanglePath(_path || context, npos.x, npos.y, sWidth, sHeight, cornerRadius + (bWidth + outlineWidth + outlineOffset) / 2);\n            } else if (shape === \"barrel\") {\n                r.drawBarrelPath(_path || context, npos.x, npos.y, sWidth, sHeight);\n            } else if (shape.startsWith(\"polygon\") || [\n                'rhomboid',\n                'right-rhomboid',\n                'round-tag',\n                'tag',\n                'vee'\n            ].includes(shape)) {\n                var pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;\n                points = joinLines(expandPolygon(points, pad));\n                r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);\n            } else {\n                var _pad = (bWidth + outlineWidth + outlineOffset) / nodeWidth;\n                points = joinLines(expandPolygon(points, -_pad));\n                r.drawPolygonPath(_path || context, npos.x, npos.y, nodeWidth, nodeHeight, points);\n            }\n            if (usePaths) {\n                context.stroke(_path);\n            } else {\n                context.stroke();\n            }\n            if (outlineStyle === 'double') {\n                context.lineWidth = bWidth / 3;\n                var gco = context.globalCompositeOperation;\n                context.globalCompositeOperation = 'destination-out';\n                if (usePaths) {\n                    context.stroke(_path);\n                } else {\n                    context.stroke();\n                }\n                context.globalCompositeOperation = gco;\n            }\n            // reset in case we changed the border style\n            if (context.setLineDash) {\n                // for very outofdate browsers\n                context.setLineDash([]);\n            }\n        }\n    };\n    var drawOverlay = function drawOverlay() {\n        if (shouldDrawOverlay) {\n            r.drawNodeOverlay(context, node, pos, nodeWidth, nodeHeight);\n        }\n    };\n    var drawUnderlay = function drawUnderlay() {\n        if (shouldDrawOverlay) {\n            r.drawNodeUnderlay(context, node, pos, nodeWidth, nodeHeight);\n        }\n    };\n    var drawText = function drawText() {\n        r.drawElementText(context, node, null, drawLabel);\n    };\n    var ghost = node.pstyle('ghost').value === 'yes';\n    if (ghost) {\n        var gx = node.pstyle('ghost-offset-x').pfValue;\n        var gy = node.pstyle('ghost-offset-y').pfValue;\n        var ghostOpacity = node.pstyle('ghost-opacity').value;\n        var effGhostOpacity = ghostOpacity * eleOpacity;\n        context.translate(gx, gy);\n        setupOutlineColor();\n        drawOutline();\n        setupShapeColor(ghostOpacity * bgOpacity);\n        drawShape();\n        drawImages(effGhostOpacity, true);\n        setupBorderColor(ghostOpacity * borderOpacity);\n        drawBorder();\n        drawPie(darkness !== 0 || borderWidth !== 0);\n        drawStripe(darkness !== 0 || borderWidth !== 0);\n        drawImages(effGhostOpacity, false);\n        darken(effGhostOpacity);\n        context.translate(-gx, -gy);\n    }\n    if (usePaths) {\n        context.translate(-pos.x, -pos.y);\n    }\n    drawUnderlay();\n    if (usePaths) {\n        context.translate(pos.x, pos.y);\n    }\n    setupOutlineColor();\n    drawOutline();\n    setupShapeColor();\n    drawShape();\n    drawImages(eleOpacity, true);\n    setupBorderColor();\n    drawBorder();\n    drawPie(darkness !== 0 || borderWidth !== 0);\n    drawStripe(darkness !== 0 || borderWidth !== 0);\n    drawImages(eleOpacity, false);\n    darken();\n    if (usePaths) {\n        context.translate(-pos.x, -pos.y);\n    }\n    drawText();\n    drawOverlay();\n    //\n    // clean up shift\n    if (shiftToOriginWithBb) {\n        context.translate(bb.x1, bb.y1);\n    }\n};\nvar drawNodeOverlayUnderlay = function drawNodeOverlayUnderlay(overlayOrUnderlay) {\n    if (![\n        'overlay',\n        'underlay'\n    ].includes(overlayOrUnderlay)) {\n        throw new Error('Invalid state');\n    }\n    return function(context, node, pos, nodeWidth, nodeHeight) {\n        var r = this;\n        if (!node.visible()) {\n            return;\n        }\n        var padding = node.pstyle(\"\".concat(overlayOrUnderlay, \"-padding\")).pfValue;\n        var opacity = node.pstyle(\"\".concat(overlayOrUnderlay, \"-opacity\")).value;\n        var color = node.pstyle(\"\".concat(overlayOrUnderlay, \"-color\")).value;\n        var shape = node.pstyle(\"\".concat(overlayOrUnderlay, \"-shape\")).value;\n        var radius = node.pstyle(\"\".concat(overlayOrUnderlay, \"-corner-radius\")).value;\n        if (opacity > 0) {\n            pos = pos || node.position();\n            if (nodeWidth == null || nodeHeight == null) {\n                var _padding = node.padding();\n                nodeWidth = node.width() + 2 * _padding;\n                nodeHeight = node.height() + 2 * _padding;\n            }\n            r.colorFillStyle(context, color[0], color[1], color[2], opacity);\n            r.nodeShapes[shape].draw(context, pos.x, pos.y, nodeWidth + padding * 2, nodeHeight + padding * 2, radius);\n            context.fill();\n        }\n    };\n};\nCRp$6.drawNodeOverlay = drawNodeOverlayUnderlay('overlay');\nCRp$6.drawNodeUnderlay = drawNodeOverlayUnderlay('underlay');\n// does the node have at least one pie piece?\nCRp$6.hasPie = function(node) {\n    node = node[0]; // ensure ele ref\n    return node._private.hasPie;\n};\nCRp$6.hasStripe = function(node) {\n    node = node[0]; // ensure ele ref\n    return node._private.hasStripe;\n};\nCRp$6.drawPie = function(context, node, nodeOpacity, pos) {\n    node = node[0]; // ensure ele ref\n    pos = pos || node.position();\n    var cyStyle = node.cy().style();\n    var pieSize = node.pstyle('pie-size');\n    var hole = node.pstyle('pie-hole');\n    var overallStartAngle = node.pstyle('pie-start-angle').pfValue;\n    var x = pos.x;\n    var y = pos.y;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var radius = Math.min(nodeW, nodeH) / 2; // must fit in node\n    var holeRadius;\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n    var usePaths = this.usePaths();\n    if (usePaths) {\n        x = 0;\n        y = 0;\n    }\n    if (pieSize.units === '%') {\n        radius = radius * pieSize.pfValue;\n    } else if (pieSize.pfValue !== undefined) {\n        radius = pieSize.pfValue / 2; // diameter in pixels => radius\n    }\n    if (hole.units === '%') {\n        holeRadius = radius * hole.pfValue;\n    } else if (hole.pfValue !== undefined) {\n        holeRadius = hole.pfValue / 2; // diameter in pixels => radius\n    }\n    if (holeRadius >= radius) {\n        return; // the pie would be invisible anyway\n    }\n    for(var i = 1; i <= cyStyle.pieBackgroundN; i++){\n        // 1..N\n        var size = node.pstyle('pie-' + i + '-background-size').value;\n        var color = node.pstyle('pie-' + i + '-background-color').value;\n        var opacity = node.pstyle('pie-' + i + '-background-opacity').value * nodeOpacity;\n        var percent = size / 100; // map integer range [0, 100] to [0, 1]\n        // percent can't push beyond 1\n        if (percent + lastPercent > 1) {\n            percent = 1 - lastPercent;\n        }\n        var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise\n        angleStart += overallStartAngle; // shift by the overall pie start angle\n        var angleDelta = 2 * Math.PI * percent;\n        var angleEnd = angleStart + angleDelta;\n        // ignore if\n        // - zero size\n        // - we're already beyond the full circle\n        // - adding the current slice would go beyond the full circle\n        if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n            continue;\n        }\n        if (holeRadius === 0) {\n            // make a pie slice\n            context.beginPath();\n            context.moveTo(x, y);\n            context.arc(x, y, radius, angleStart, angleEnd);\n            context.closePath();\n        } else {\n            // make a pie slice that's like the above but with a hole in the middle\n            context.beginPath();\n            context.arc(x, y, radius, angleStart, angleEnd);\n            context.arc(x, y, holeRadius, angleEnd, angleStart, true); // true for anticlockwise\n            context.closePath();\n        }\n        this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        context.fill();\n        lastPercent += percent;\n    }\n};\nCRp$6.drawStripe = function(context, node, nodeOpacity, pos) {\n    node = node[0]; // ensure ele ref\n    pos = pos || node.position();\n    var cyStyle = node.cy().style();\n    var x = pos.x;\n    var y = pos.y;\n    var nodeW = node.width();\n    var nodeH = node.height();\n    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]\n    var usePaths = this.usePaths();\n    context.save();\n    var direction = node.pstyle('stripe-direction').value;\n    var stripeSize = node.pstyle('stripe-size');\n    switch(direction){\n        case 'vertical':\n            break;\n        // default\n        case 'righward':\n            context.rotate(-Math.PI / 2);\n            break;\n    }\n    var stripeW = nodeW;\n    var stripeH = nodeH;\n    if (stripeSize.units === '%') {\n        stripeW = stripeW * stripeSize.pfValue;\n        stripeH = stripeH * stripeSize.pfValue;\n    } else if (stripeSize.pfValue !== undefined) {\n        stripeW = stripeSize.pfValue;\n        stripeH = stripeSize.pfValue;\n    }\n    if (usePaths) {\n        x = 0;\n        y = 0;\n    }\n    // shift up from the centre of the node to the top-left corner\n    y -= stripeW / 2;\n    x -= stripeH / 2;\n    for(var i = 1; i <= cyStyle.stripeBackgroundN; i++){\n        // 1..N\n        var size = node.pstyle('stripe-' + i + '-background-size').value;\n        var color = node.pstyle('stripe-' + i + '-background-color').value;\n        var opacity = node.pstyle('stripe-' + i + '-background-opacity').value * nodeOpacity;\n        var percent = size / 100; // map integer range [0, 100] to [0, 1]\n        // percent can't push beyond 1\n        if (percent + lastPercent > 1) {\n            percent = 1 - lastPercent;\n        }\n        // ignore if\n        // - zero size\n        // - we're already beyond the full chart\n        // - adding the current slice would go beyond the full chart\n        if (size === 0 || lastPercent >= 1 || lastPercent + percent > 1) {\n            continue;\n        }\n        // draw rect for the current stripe\n        context.beginPath();\n        context.rect(x, y + stripeH * lastPercent, stripeW, stripeH * percent);\n        context.closePath();\n        this.colorFillStyle(context, color[0], color[1], color[2], opacity);\n        context.fill();\n        lastPercent += percent;\n    }\n    context.restore();\n};\nvar CRp$5 = {};\nvar motionBlurDelay = 100;\n// var isFirefox = typeof InstallTrigger !== 'undefined';\nCRp$5.getPixelRatio = function() {\n    var context = this.data.contexts[0];\n    if (this.forcedPixelRatio != null) {\n        return this.forcedPixelRatio;\n    }\n    var containerWindow = this.cy.window();\n    var backingStore = context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;\n    return (containerWindow.devicePixelRatio || 1) / backingStore; // eslint-disable-line no-undef\n};\nCRp$5.paintCache = function(context) {\n    var caches = this.paintCaches = this.paintCaches || [];\n    var needToCreateCache = true;\n    var cache;\n    for(var i = 0; i < caches.length; i++){\n        cache = caches[i];\n        if (cache.context === context) {\n            needToCreateCache = false;\n            break;\n        }\n    }\n    if (needToCreateCache) {\n        cache = {\n            context: context\n        };\n        caches.push(cache);\n    }\n    return cache;\n};\nCRp$5.createGradientStyleFor = function(context, shapeStyleName, ele, fill, opacity) {\n    var gradientStyle;\n    var usePaths = this.usePaths();\n    var colors = ele.pstyle(shapeStyleName + '-gradient-stop-colors').value, positions = ele.pstyle(shapeStyleName + '-gradient-stop-positions').pfValue;\n    if (fill === 'radial-gradient') {\n        if (ele.isEdge()) {\n            var start = ele.sourceEndpoint(), end = ele.targetEndpoint(), mid = ele.midpoint();\n            var d1 = dist(start, mid);\n            var d2 = dist(end, mid);\n            gradientStyle = context.createRadialGradient(mid.x, mid.y, 0, mid.x, mid.y, Math.max(d1, d2));\n        } else {\n            var pos = usePaths ? {\n                x: 0,\n                y: 0\n            } : ele.position(), width = ele.paddedWidth(), height = ele.paddedHeight();\n            gradientStyle = context.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, Math.max(width, height));\n        }\n    } else {\n        if (ele.isEdge()) {\n            var _start = ele.sourceEndpoint(), _end = ele.targetEndpoint();\n            gradientStyle = context.createLinearGradient(_start.x, _start.y, _end.x, _end.y);\n        } else {\n            var _pos = usePaths ? {\n                x: 0,\n                y: 0\n            } : ele.position(), _width = ele.paddedWidth(), _height = ele.paddedHeight(), halfWidth = _width / 2, halfHeight = _height / 2;\n            var direction = ele.pstyle('background-gradient-direction').value;\n            switch(direction){\n                case 'to-bottom':\n                    gradientStyle = context.createLinearGradient(_pos.x, _pos.y - halfHeight, _pos.x, _pos.y + halfHeight);\n                    break;\n                case 'to-top':\n                    gradientStyle = context.createLinearGradient(_pos.x, _pos.y + halfHeight, _pos.x, _pos.y - halfHeight);\n                    break;\n                case 'to-left':\n                    gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y, _pos.x - halfWidth, _pos.y);\n                    break;\n                case 'to-right':\n                    gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y, _pos.x + halfWidth, _pos.y);\n                    break;\n                case 'to-bottom-right':\n                case 'to-right-bottom':\n                    gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y - halfHeight, _pos.x + halfWidth, _pos.y + halfHeight);\n                    break;\n                case 'to-top-right':\n                case 'to-right-top':\n                    gradientStyle = context.createLinearGradient(_pos.x - halfWidth, _pos.y + halfHeight, _pos.x + halfWidth, _pos.y - halfHeight);\n                    break;\n                case 'to-bottom-left':\n                case 'to-left-bottom':\n                    gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y - halfHeight, _pos.x - halfWidth, _pos.y + halfHeight);\n                    break;\n                case 'to-top-left':\n                case 'to-left-top':\n                    gradientStyle = context.createLinearGradient(_pos.x + halfWidth, _pos.y + halfHeight, _pos.x - halfWidth, _pos.y - halfHeight);\n                    break;\n            }\n        }\n    }\n    if (!gradientStyle) return null; // invalid gradient style\n    var hasPositions = positions.length === colors.length;\n    var length = colors.length;\n    for(var i = 0; i < length; i++){\n        gradientStyle.addColorStop(hasPositions ? positions[i] : i / (length - 1), 'rgba(' + colors[i][0] + ',' + colors[i][1] + ',' + colors[i][2] + ',' + opacity + ')');\n    }\n    return gradientStyle;\n};\nCRp$5.gradientFillStyle = function(context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, 'background', ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n    context.fillStyle = gradientStyle;\n};\nCRp$5.colorFillStyle = function(context, r, g, b, a) {\n    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// turn off for now, seems context does its own caching\n// var cache = this.paintCache(context);\n// var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// if( cache.fillStyle !== fillStyle ){\n//   context.fillStyle = cache.fillStyle = fillStyle;\n// }\n};\nCRp$5.eleFillStyle = function(context, ele, opacity) {\n    var backgroundFill = ele.pstyle('background-fill').value;\n    if (backgroundFill === 'linear-gradient' || backgroundFill === 'radial-gradient') {\n        this.gradientFillStyle(context, ele, backgroundFill, opacity);\n    } else {\n        var backgroundColor = ele.pstyle('background-color').value;\n        this.colorFillStyle(context, backgroundColor[0], backgroundColor[1], backgroundColor[2], opacity);\n    }\n};\nCRp$5.gradientStrokeStyle = function(context, ele, fill, opacity) {\n    var gradientStyle = this.createGradientStyleFor(context, 'line', ele, fill, opacity);\n    if (!gradientStyle) return null; // error\n    context.strokeStyle = gradientStyle;\n};\nCRp$5.colorStrokeStyle = function(context, r, g, b, a) {\n    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// turn off for now, seems context does its own caching\n// var cache = this.paintCache(context);\n// var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n// if( cache.strokeStyle !== strokeStyle ){\n//   context.strokeStyle = cache.strokeStyle = strokeStyle;\n// }\n};\nCRp$5.eleStrokeStyle = function(context, ele, opacity) {\n    var lineFill = ele.pstyle('line-fill').value;\n    if (lineFill === 'linear-gradient' || lineFill === 'radial-gradient') {\n        this.gradientStrokeStyle(context, ele, lineFill, opacity);\n    } else {\n        var lineColor = ele.pstyle('line-color').value;\n        this.colorStrokeStyle(context, lineColor[0], lineColor[1], lineColor[2], opacity);\n    }\n};\n// Resize canvas\nCRp$5.matchCanvasSize = function(container) {\n    var r = this;\n    var data = r.data;\n    var bb = r.findContainerClientCoords();\n    var width = bb[2];\n    var height = bb[3];\n    var pixelRatio = r.getPixelRatio();\n    var mbPxRatio = r.motionBlurPxRatio;\n    if (container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE] || container === r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG]) {\n        pixelRatio = mbPxRatio;\n    }\n    var canvasWidth = width * pixelRatio;\n    var canvasHeight = height * pixelRatio;\n    var canvas;\n    if (canvasWidth === r.canvasWidth && canvasHeight === r.canvasHeight) {\n        return; // save cycles if same\n    }\n    r.fontCaches = null; // resizing resets the style\n    var canvasContainer = data.canvasContainer;\n    canvasContainer.style.width = width + 'px';\n    canvasContainer.style.height = height + 'px';\n    for(var i = 0; i < r.CANVAS_LAYERS; i++){\n        canvas = data.canvases[i];\n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n    }\n    for(var i = 0; i < r.BUFFER_COUNT; i++){\n        canvas = data.bufferCanvases[i];\n        canvas.width = canvasWidth;\n        canvas.height = canvasHeight;\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n    }\n    r.textureMult = 1;\n    if (pixelRatio <= 1) {\n        canvas = data.bufferCanvases[r.TEXTURE_BUFFER];\n        r.textureMult = 2;\n        canvas.width = canvasWidth * r.textureMult;\n        canvas.height = canvasHeight * r.textureMult;\n    }\n    r.canvasWidth = canvasWidth;\n    r.canvasHeight = canvasHeight;\n    r.pixelRatio = pixelRatio;\n};\nCRp$5.renderTo = function(cxt, zoom, pan, pxRatio) {\n    this.render({\n        forcedContext: cxt,\n        forcedZoom: zoom,\n        forcedPan: pan,\n        drawAllLayers: true,\n        forcedPxRatio: pxRatio\n    });\n};\nCRp$5.clearCanvas = function() {\n    var r = this;\n    var data = r.data;\n    function clear(context) {\n        context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n    }\n    clear(data.contexts[r.NODE]);\n    clear(data.contexts[r.DRAG]);\n};\nCRp$5.render = function(options) {\n    var r = this;\n    options = options || staticEmptyObject();\n    var cy = r.cy;\n    var forcedContext = options.forcedContext;\n    var drawAllLayers = options.drawAllLayers;\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var forcedZoom = options.forcedZoom;\n    var forcedPan = options.forcedPan;\n    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;\n    var data = r.data;\n    var needDraw = data.canvasNeedsRedraw;\n    var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);\n    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;\n    var mbPxRatio = r.motionBlurPxRatio;\n    var hasCompoundNodes = cy.hasCompoundNodes();\n    var inNodeDragGesture = r.hoverData.draggingEles;\n    var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;\n    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;\n    var motionBlurFadeEffect = motionBlur;\n    if (!forcedContext) {\n        if (r.prevPxRatio !== pixelRatio) {\n            r.invalidateContainerClientCoordsCache();\n            r.matchCanvasSize(r.container);\n            r.redrawHint('eles', true);\n            r.redrawHint('drag', true);\n        }\n        r.prevPxRatio = pixelRatio;\n    }\n    if (!forcedContext && r.motionBlurTimeout) {\n        clearTimeout(r.motionBlurTimeout);\n    }\n    if (motionBlur) {\n        if (r.mbFrames == null) {\n            r.mbFrames = 0;\n        }\n        r.mbFrames++;\n        if (r.mbFrames < 3) {\n            // need several frames before even high quality motionblur\n            motionBlurFadeEffect = false;\n        }\n        // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)\n        if (r.mbFrames > r.minMbLowQualFrames) {\n            //r.fullQualityMb = false;\n            r.motionBlurPxRatio = r.mbPxRBlurry;\n        }\n    }\n    if (r.clearingMotionBlur) {\n        r.motionBlurPxRatio = 1;\n    }\n    // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame\n    // because a rogue async texture frame would clear needDraw\n    if (r.textureDrawLastFrame && !textureDraw) {\n        needDraw[r.NODE] = true;\n        needDraw[r.SELECT_BOX] = true;\n    }\n    var style = cy.style();\n    var zoom = cy.zoom();\n    var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;\n    var pan = cy.pan();\n    var effectivePan = {\n        x: pan.x,\n        y: pan.y\n    };\n    var vp = {\n        zoom: zoom,\n        pan: {\n            x: pan.x,\n            y: pan.y\n        }\n    };\n    var prevVp = r.prevViewport;\n    var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;\n    // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)\n    if (!viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes)) {\n        r.motionBlurPxRatio = 1;\n    }\n    if (forcedPan) {\n        effectivePan = forcedPan;\n    }\n    // apply pixel ratio\n    effectiveZoom *= pixelRatio;\n    effectivePan.x *= pixelRatio;\n    effectivePan.y *= pixelRatio;\n    var eles = r.getCachedZSortedEles();\n    function mbclear(context, x, y, w, h) {\n        var gco = context.globalCompositeOperation;\n        context.globalCompositeOperation = 'destination-out';\n        r.colorFillStyle(context, 255, 255, 255, r.motionBlurTransparency);\n        context.fillRect(x, y, w, h);\n        context.globalCompositeOperation = gco;\n    }\n    function setContextTransform(context, clear) {\n        var ePan, eZoom, w, h;\n        if (!r.clearingMotionBlur && (context === data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG])) {\n            ePan = {\n                x: pan.x * mbPxRatio,\n                y: pan.y * mbPxRatio\n            };\n            eZoom = zoom * mbPxRatio;\n            w = r.canvasWidth * mbPxRatio;\n            h = r.canvasHeight * mbPxRatio;\n        } else {\n            ePan = effectivePan;\n            eZoom = effectiveZoom;\n            w = r.canvasWidth;\n            h = r.canvasHeight;\n        }\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        if (clear === 'motionBlur') {\n            mbclear(context, 0, 0, w, h);\n        } else if (!forcedContext && (clear === undefined || clear)) {\n            context.clearRect(0, 0, w, h);\n        }\n        if (!drawAllLayers) {\n            context.translate(ePan.x, ePan.y);\n            context.scale(eZoom, eZoom);\n        }\n        if (forcedPan) {\n            context.translate(forcedPan.x, forcedPan.y);\n        }\n        if (forcedZoom) {\n            context.scale(forcedZoom, forcedZoom);\n        }\n    }\n    if (!textureDraw) {\n        r.textureDrawLastFrame = false;\n    }\n    if (textureDraw) {\n        r.textureDrawLastFrame = true;\n        if (!r.textureCache) {\n            r.textureCache = {};\n            r.textureCache.bb = cy.mutableElements().boundingBox();\n            r.textureCache.texture = r.data.bufferCanvases[r.TEXTURE_BUFFER];\n            var cxt = r.data.bufferContexts[r.TEXTURE_BUFFER];\n            cxt.setTransform(1, 0, 0, 1, 0, 0);\n            cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);\n            r.render({\n                forcedContext: cxt,\n                drawOnlyNodeLayer: true,\n                forcedPxRatio: pixelRatio * r.textureMult\n            });\n            var vp = r.textureCache.viewport = {\n                zoom: cy.zoom(),\n                pan: cy.pan(),\n                width: r.canvasWidth,\n                height: r.canvasHeight\n            };\n            vp.mpan = {\n                x: (0 - vp.pan.x) / vp.zoom,\n                y: (0 - vp.pan.y) / vp.zoom\n            };\n        }\n        needDraw[r.DRAG] = false;\n        needDraw[r.NODE] = false;\n        var context = data.contexts[r.NODE];\n        var texture = r.textureCache.texture;\n        var vp = r.textureCache.viewport;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        if (motionBlur) {\n            mbclear(context, 0, 0, vp.width, vp.height);\n        } else {\n            context.clearRect(0, 0, vp.width, vp.height);\n        }\n        var outsideBgColor = style.core('outside-texture-bg-color').value;\n        var outsideBgOpacity = style.core('outside-texture-bg-opacity').value;\n        r.colorFillStyle(context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity);\n        context.fillRect(0, 0, vp.width, vp.height);\n        var zoom = cy.zoom();\n        setContextTransform(context, false);\n        context.clearRect(vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n        context.drawImage(texture, vp.mpan.x, vp.mpan.y, vp.width / vp.zoom / pixelRatio, vp.height / vp.zoom / pixelRatio);\n    } else if (r.textureOnViewport && !forcedContext) {\n        // clear the cache since we don't need it\n        r.textureCache = null;\n    }\n    var extent = cy.extent();\n    var vpManip = r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles || r.cy.animated();\n    var hideEdges = r.hideEdgesOnViewport && vpManip;\n    var needMbClear = [];\n    needMbClear[r.NODE] = !needDraw[r.NODE] && motionBlur && !r.clearedForMotionBlur[r.NODE] || r.clearingMotionBlur;\n    if (needMbClear[r.NODE]) {\n        r.clearedForMotionBlur[r.NODE] = true;\n    }\n    needMbClear[r.DRAG] = !needDraw[r.DRAG] && motionBlur && !r.clearedForMotionBlur[r.DRAG] || r.clearingMotionBlur;\n    if (needMbClear[r.DRAG]) {\n        r.clearedForMotionBlur[r.DRAG] = true;\n    }\n    if (needDraw[r.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[r.NODE]) {\n        var useBuffer = motionBlur && !needMbClear[r.NODE] && mbPxRatio !== 1;\n        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_NODE] : data.contexts[r.NODE]);\n        var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;\n        setContextTransform(context, clear);\n        if (hideEdges) {\n            r.drawCachedNodes(context, eles.nondrag, pixelRatio, extent);\n        } else {\n            r.drawLayeredElements(context, eles.nondrag, pixelRatio, extent);\n        }\n        if (r.debug) {\n            r.drawDebugPoints(context, eles.nondrag);\n        }\n        if (!drawAllLayers && !motionBlur) {\n            needDraw[r.NODE] = false;\n        }\n    }\n    if (!drawOnlyNodeLayer && (needDraw[r.DRAG] || drawAllLayers || needMbClear[r.DRAG])) {\n        var useBuffer = motionBlur && !needMbClear[r.DRAG] && mbPxRatio !== 1;\n        var context = forcedContext || (useBuffer ? r.data.bufferContexts[r.MOTIONBLUR_BUFFER_DRAG] : data.contexts[r.DRAG]);\n        setContextTransform(context, motionBlur && !useBuffer ? 'motionBlur' : undefined);\n        if (hideEdges) {\n            r.drawCachedNodes(context, eles.drag, pixelRatio, extent);\n        } else {\n            r.drawCachedElements(context, eles.drag, pixelRatio, extent);\n        }\n        if (r.debug) {\n            r.drawDebugPoints(context, eles.drag);\n        }\n        if (!drawAllLayers && !motionBlur) {\n            needDraw[r.DRAG] = false;\n        }\n    }\n    this.drawSelectionRectangle(options, setContextTransform);\n    // motionblur: blit rendered blurry frames\n    if (motionBlur && mbPxRatio !== 1) {\n        var cxtNode = data.contexts[r.NODE];\n        var txtNode = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_NODE];\n        var cxtDrag = data.contexts[r.DRAG];\n        var txtDrag = r.data.bufferCanvases[r.MOTIONBLUR_BUFFER_DRAG];\n        var drawMotionBlur = function drawMotionBlur(cxt, txt, needClear) {\n            cxt.setTransform(1, 0, 0, 1, 0, 0);\n            if (needClear || !motionBlurFadeEffect) {\n                cxt.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n            } else {\n                mbclear(cxt, 0, 0, r.canvasWidth, r.canvasHeight);\n            }\n            var pxr = mbPxRatio;\n            cxt.drawImage(txt, // img\n            0, 0, // sx, sy\n            r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh\n            0, 0, // x, y\n            r.canvasWidth, r.canvasHeight // w, h\n            );\n        };\n        if (needDraw[r.NODE] || needMbClear[r.NODE]) {\n            drawMotionBlur(cxtNode, txtNode, needMbClear[r.NODE]);\n            needDraw[r.NODE] = false;\n        }\n        if (needDraw[r.DRAG] || needMbClear[r.DRAG]) {\n            drawMotionBlur(cxtDrag, txtDrag, needMbClear[r.DRAG]);\n            needDraw[r.DRAG] = false;\n        }\n    }\n    r.prevViewport = vp;\n    if (r.clearingMotionBlur) {\n        r.clearingMotionBlur = false;\n        r.motionBlurCleared = true;\n        r.motionBlur = true;\n    }\n    if (motionBlur) {\n        r.motionBlurTimeout = setTimeout(function() {\n            r.motionBlurTimeout = null;\n            r.clearedForMotionBlur[r.NODE] = false;\n            r.clearedForMotionBlur[r.DRAG] = false;\n            r.motionBlur = false;\n            r.clearingMotionBlur = !textureDraw;\n            r.mbFrames = 0;\n            needDraw[r.NODE] = true;\n            needDraw[r.DRAG] = true;\n            r.redraw();\n        }, motionBlurDelay);\n    }\n    if (!forcedContext) {\n        cy.emit('render');\n    }\n};\nvar fpsHeight;\nCRp$5.drawSelectionRectangle = function(options, setContextTransform) {\n    var r = this;\n    var cy = r.cy;\n    var data = r.data;\n    var style = cy.style();\n    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;\n    var drawAllLayers = options.drawAllLayers;\n    var needDraw = data.canvasNeedsRedraw;\n    var forcedContext = options.forcedContext;\n    if (r.showFps || !drawOnlyNodeLayer && needDraw[r.SELECT_BOX] && !drawAllLayers) {\n        var context = forcedContext || data.contexts[r.SELECT_BOX];\n        setContextTransform(context);\n        if (r.selection[4] == 1 && (r.hoverData.selecting || r.touchData.selecting)) {\n            var zoom = r.cy.zoom();\n            var borderWidth = style.core('selection-box-border-width').value / zoom;\n            context.lineWidth = borderWidth;\n            context.fillStyle = 'rgba(' + style.core('selection-box-color').value[0] + ',' + style.core('selection-box-color').value[1] + ',' + style.core('selection-box-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n            context.fillRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n            if (borderWidth > 0) {\n                context.strokeStyle = 'rgba(' + style.core('selection-box-border-color').value[0] + ',' + style.core('selection-box-border-color').value[1] + ',' + style.core('selection-box-border-color').value[2] + ',' + style.core('selection-box-opacity').value + ')';\n                context.strokeRect(r.selection[0], r.selection[1], r.selection[2] - r.selection[0], r.selection[3] - r.selection[1]);\n            }\n        }\n        if (data.bgActivePosistion && !r.hoverData.selecting) {\n            var zoom = r.cy.zoom();\n            var pos = data.bgActivePosistion;\n            context.fillStyle = 'rgba(' + style.core('active-bg-color').value[0] + ',' + style.core('active-bg-color').value[1] + ',' + style.core('active-bg-color').value[2] + ',' + style.core('active-bg-opacity').value + ')';\n            context.beginPath();\n            context.arc(pos.x, pos.y, style.core('active-bg-size').pfValue / zoom, 0, 2 * Math.PI);\n            context.fill();\n        }\n        var timeToRender = r.lastRedrawTime;\n        if (r.showFps && timeToRender) {\n            timeToRender = Math.round(timeToRender);\n            var fps = Math.round(1000 / timeToRender);\n            var text = '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps';\n            context.setTransform(1, 0, 0, 1, 0, 0);\n            context.fillStyle = 'rgba(255, 0, 0, 0.75)';\n            context.strokeStyle = 'rgba(255, 0, 0, 0.75)';\n            // context.lineWidth = 1;\n            context.font = '30px Arial';\n            if (!fpsHeight) {\n                var dims = context.measureText(text);\n                fpsHeight = dims.actualBoundingBoxAscent;\n            }\n            context.fillText(text, 0, fpsHeight);\n            var maxFps = 60;\n            context.strokeRect(0, fpsHeight + 10, 250, 20);\n            context.fillRect(0, fpsHeight + 10, 250 * Math.min(fps / maxFps, 1), 20);\n        }\n        if (!drawAllLayers) {\n            needDraw[r.SELECT_BOX] = false;\n        }\n    }\n};\n/**\n * Notes:\n * - All colors have premultiplied alpha. Very important for textues and \n *   blending to work correctly.\n */ function compileShader(gl, type, source) {\n    var shader = gl.createShader(type);\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        throw new Error(gl.getShaderInfoLog(shader));\n    }\n    // console.log(gl.getShaderInfoLog(shader));\n    return shader;\n}\nfunction createProgram(gl, vertexSource, fragementSource) {\n    var vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSource);\n    var fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragementSource);\n    var program = gl.createProgram();\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        throw new Error('Could not initialize shaders');\n    }\n    return program;\n}\n/**\n * Creates an offscren canvas with a 2D context, for the\n * canvas renderer to use for drawing textures.\n */ function createTextureCanvas(r, width, height) {\n    if (height === undefined) {\n        height = width;\n    }\n    var canvas = r.makeOffscreenCanvas(width, height);\n    var ctx = canvas.context = canvas.getContext('2d');\n    canvas.clear = function() {\n        return ctx.clearRect(0, 0, canvas.width, canvas.height);\n    };\n    canvas.clear();\n    return canvas;\n}\n/**\n * Returns the current pan & zoom values, scaled by the pixel ratio.\n */ function getEffectivePanZoom(r) {\n    var pixelRatio = r.pixelRatio;\n    var zoom = r.cy.zoom();\n    var pan = r.cy.pan();\n    return {\n        zoom: zoom * pixelRatio,\n        pan: {\n            x: pan.x * pixelRatio,\n            y: pan.y * pixelRatio\n        }\n    };\n}\n/**\n * Returns the zoom value, scaled by the pixel ratio.\n */ function getEffectiveZoom(r) {\n    var pixelRatio = r.pixelRatio;\n    var zoom = r.cy.zoom();\n    return zoom * pixelRatio;\n}\nfunction modelToRenderedPosition(r, pan, zoom, x, y) {\n    var rx = x * zoom + pan.x;\n    var ry = y * zoom + pan.y;\n    ry = Math.round(r.canvasHeight - ry); // adjust for webgl\n    return [\n        rx,\n        ry\n    ];\n}\nfunction isSimpleShape(node) {\n    // the actual shape is checked in ElementDrawingWebGL._getVertTypeForShape()\n    // no need to check it twice, this just checks other visual properties\n    if (node.pstyle('background-fill').value !== 'solid') return false;\n    if (node.pstyle('background-image').strValue !== 'none') return false;\n    if (node.pstyle('border-width').value === 0) return true;\n    if (node.pstyle('border-opacity').value === 0) return true;\n    // we have a border but it must be simple\n    if (node.pstyle('border-style').value !== 'solid') return false;\n    // TODO ignoring 'border-cap', 'border-join' and 'border-position' for now\n    return true;\n}\nfunction arrayEqual(a1, a2) {\n    if (a1.length !== a2.length) {\n        return false;\n    }\n    for(var i = 0; i < a1.length; i++){\n        if (a1[i] !== a2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Takes color & opacity style values and converts them to WebGL format. \n * Alpha is premultiplied.\n */ function toWebGLColor(color, opacity, outArray) {\n    var r = color[0] / 255;\n    var g = color[1] / 255;\n    var b = color[2] / 255;\n    var a = opacity;\n    var arr = outArray || new Array(4);\n    arr[0] = r * a;\n    arr[1] = g * a;\n    arr[2] = b * a;\n    arr[3] = a;\n    return arr;\n}\nfunction indexToVec4(index, outArray) {\n    var arr = outArray || new Array(4);\n    arr[0] = (index >> 0 & 0xFF) / 0xFF;\n    arr[1] = (index >> 8 & 0xFF) / 0xFF;\n    arr[2] = (index >> 16 & 0xFF) / 0xFF;\n    arr[3] = (index >> 24 & 0xFF) / 0xFF;\n    return arr;\n}\nfunction vec4ToIndex(vec4) {\n    return vec4[0] + (vec4[1] << 8) + (vec4[2] << 16) + (vec4[3] << 24);\n}\nfunction createTexture(gl, debugID) {\n    var texture = gl.createTexture();\n    texture.buffer = function(offscreenCanvas) {\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n        // very important, this tells webgl to premultiply colors by the alpha channel\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, offscreenCanvas);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    };\n    texture.deleteTexture = function() {\n        gl.deleteTexture(texture);\n    };\n    return texture;\n}\nfunction getTypeInfo(gl, glslType) {\n    switch(glslType){\n        case 'float':\n            return [\n                1,\n                gl.FLOAT,\n                4\n            ];\n        case 'vec2':\n            return [\n                2,\n                gl.FLOAT,\n                4\n            ];\n        case 'vec3':\n            return [\n                3,\n                gl.FLOAT,\n                4\n            ];\n        case 'vec4':\n            return [\n                4,\n                gl.FLOAT,\n                4\n            ];\n        case 'int':\n            return [\n                1,\n                gl.INT,\n                4\n            ];\n        case 'ivec2':\n            return [\n                2,\n                gl.INT,\n                4\n            ];\n    }\n}\nfunction createTypedArray(gl, glType, dataOrSize) {\n    switch(glType){\n        case gl.FLOAT:\n            return new Float32Array(dataOrSize);\n        case gl.INT:\n            return new Int32Array(dataOrSize);\n    }\n}\nfunction createTypedArrayView(gl, glType, array, stride, size, i) {\n    switch(glType){\n        case gl.FLOAT:\n            return new Float32Array(array.buffer, i * stride, size);\n        case gl.INT:\n            return new Int32Array(array.buffer, i * stride, size);\n    }\n}\n/** @param {WebGLRenderingContext} gl */ function createBufferStaticDraw(gl, type, attributeLoc, dataArray) {\n    var _getTypeInfo = getTypeInfo(gl, type), _getTypeInfo2 = _slicedToArray(_getTypeInfo, 2), size = _getTypeInfo2[0], glType = _getTypeInfo2[1];\n    var data = createTypedArray(gl, glType, dataArray);\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n    if (glType === gl.FLOAT) {\n        gl.vertexAttribPointer(attributeLoc, size, glType, false, 0, 0);\n    } else if (glType === gl.INT) {\n        gl.vertexAttribIPointer(attributeLoc, size, glType, 0, 0);\n    }\n    gl.enableVertexAttribArray(attributeLoc);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    return buffer;\n}\n/** \n * Creates a float buffer with gl.DYNAMIC_DRAW.\n * The returned buffer object contains functions to easily set instance data and buffer the data before a draw call.\n * @param {WebGLRenderingContext} gl \n */ function createBufferDynamicDraw(gl, instances, type, attributeLoc) {\n    var _getTypeInfo3 = getTypeInfo(gl, type), _getTypeInfo4 = _slicedToArray(_getTypeInfo3, 3), size = _getTypeInfo4[0], glType = _getTypeInfo4[1], bytes = _getTypeInfo4[2];\n    var dataArray = createTypedArray(gl, glType, instances * size);\n    var stride = size * bytes;\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, instances * stride, gl.DYNAMIC_DRAW);\n    gl.enableVertexAttribArray(attributeLoc);\n    if (glType === gl.FLOAT) {\n        gl.vertexAttribPointer(attributeLoc, size, glType, false, stride, 0);\n    } else if (glType === gl.INT) {\n        gl.vertexAttribIPointer(attributeLoc, size, glType, stride, 0);\n    }\n    gl.vertexAttribDivisor(attributeLoc, 1);\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    // use array views to set values directly into the buffer array\n    var views = new Array(instances);\n    for(var i = 0; i < instances; i++){\n        views[i] = createTypedArrayView(gl, glType, dataArray, stride, size, i);\n    }\n    buffer.dataArray = dataArray;\n    buffer.stride = stride;\n    buffer.size = size;\n    buffer.getView = function(i) {\n        return views[i];\n    };\n    buffer.setPoint = function(i, x, y) {\n        var view = views[i];\n        view[0] = x;\n        view[1] = y;\n    };\n    buffer.bufferSubData = function(count) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        if (count) {\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray, 0, count * size);\n        } else {\n            gl.bufferSubData(gl.ARRAY_BUFFER, 0, dataArray);\n        }\n    };\n    return buffer;\n}\n/** \n * Creates a buffer of 3x3 matrix data for use as attribute data.\n * @param {WebGLRenderingContext} gl \n */ function create3x3MatrixBufferDynamicDraw(gl, instances, attributeLoc) {\n    var matrixSize = 9; // 3x3 matrix\n    var matrixData = new Float32Array(instances * matrixSize);\n    // use matrix views to set values directly into the matrixData array\n    var matrixViews = new Array(instances);\n    for(var i = 0; i < instances; i++){\n        var byteOffset = i * matrixSize * 4; // 4 bytes per float\n        matrixViews[i] = new Float32Array(matrixData.buffer, byteOffset, matrixSize); // array view\n    }\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);\n    // each row of the matrix needs to be a separate attribute\n    for(var _i = 0; _i < 3; _i++){\n        var loc = attributeLoc + _i;\n        gl.enableVertexAttribArray(loc);\n        gl.vertexAttribPointer(loc, 3, gl.FLOAT, false, 3 * 12, _i * 12);\n        gl.vertexAttribDivisor(loc, 1);\n    }\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    buffer.getMatrixView = function(i) {\n        return matrixViews[i];\n    };\n    // TODO this is too slow, use getMatrixView and pass the view directly to the glmatrix library\n    buffer.setData = function(matrix, i) {\n        matrixViews[i].set(matrix, 0);\n    };\n    buffer.bufferSubData = function() {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);\n    };\n    return buffer;\n}\n/** \n * Creates a Frame Buffer to use for offscreen rendering.\n * @param {WebGLRenderingContext} gl \n */ function createPickingFrameBuffer(gl) {\n    // Create and bind the framebuffer\n    var fb = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    // Create a texture to render to\n    var targetTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    // attach the texture as the first color attachment\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, targetTexture, 0);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    fb.setFramebufferAttachmentSizes = function(width, height) {\n        gl.bindTexture(gl.TEXTURE_2D, targetTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    };\n    return fb;\n}\n/**\n * Common utilities\n * @module glMatrix\n */ // Configuration Constants\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\nif (!Math.hypot) Math.hypot = function() {\n    var y = 0, i = arguments.length;\n    while(i--){\n        y += arguments[i] * arguments[i];\n    }\n    return Math.sqrt(y);\n};\n/**\n * 3x3 Matrix\n * @module mat3\n */ /**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */ function create() {\n    var out = new ARRAY_TYPE(9);\n    if (ARRAY_TYPE != Float32Array) {\n        out[1] = 0;\n        out[2] = 0;\n        out[3] = 0;\n        out[5] = 0;\n        out[6] = 0;\n        out[7] = 0;\n    }\n    out[0] = 1;\n    out[4] = 1;\n    out[8] = 1;\n    return out;\n}\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */ function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the first operand\n * @param {ReadonlyMat3} b the second operand\n * @returns {mat3} out\n */ function multiply(out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2];\n    var a10 = a[3], a11 = a[4], a12 = a[5];\n    var a20 = a[6], a21 = a[7], a22 = a[8];\n    var b00 = b[0], b01 = b[1], b02 = b[2];\n    var b10 = b[3], b11 = b[4], b12 = b[5];\n    var b20 = b[6], b21 = b[7], b22 = b[8];\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n}\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to translate\n * @param {ReadonlyVec2} v vector to translate by\n * @returns {mat3} out\n */ function translate(out, a, v) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n}\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */ function rotate(out, a, rad) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n}\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {ReadonlyMat3} a the matrix to rotate\n * @param {ReadonlyVec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/ function scale(out, a, v) {\n    var x = v[0], y = v[1];\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */ function projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n// A \"texture atlas\" is a big canvas, and sections of it are used as textures for nodes/labels.\n/**\n * A single square texture atlas (also known as a \"sprite sheet\").\n */ var Atlas = /*#__PURE__*/ function() {\n    function Atlas(r, texSize, texRows, createTextureCanvas) {\n        _classCallCheck(this, Atlas);\n        this.debugID = Math.floor(Math.random() * 10000);\n        this.r = r;\n        this.texSize = texSize;\n        this.texRows = texRows;\n        this.texHeight = Math.floor(texSize / texRows);\n        this.enableWrapping = true; // hardcoded for now, can be made an option\n        this.locked = false; // once an atlas is locked it can no longer be drawn to\n        this.texture = null; // WebGLTexture object\n        this.needsBuffer = true;\n        // a \"location\" is an pointer into the atlas with a 'row' and 'x' fields\n        this.freePointer = {\n            x: 0,\n            row: 0\n        };\n        // map from the style key to the row/x where the texture starts\n        // if the texture wraps then there's a second location\n        this.keyToLocation = new Map(); // styleKey -> [ location, location ]\n        this.canvas = createTextureCanvas(r, texSize, texSize);\n        this.scratch = createTextureCanvas(r, texSize, this.texHeight, 'scratch');\n    }\n    return _createClass(Atlas, [\n        {\n            key: \"lock\",\n            value: function lock() {\n                this.locked = true;\n            }\n        },\n        {\n            key: \"getKeys\",\n            value: function getKeys() {\n                return new Set(this.keyToLocation.keys());\n            }\n        },\n        {\n            key: \"getScale\",\n            value: function getScale(_ref) {\n                var w = _ref.w, h = _ref.h;\n                var texHeight = this.texHeight, maxTexWidth = this.texSize;\n                // try to fit to the height of a row\n                var scale = texHeight / h; // TODO what about pixelRatio?\n                var texW = w * scale;\n                var texH = h * scale;\n                // if the scaled width is too wide then scale to fit max width instead\n                if (texW > maxTexWidth) {\n                    scale = maxTexWidth / w;\n                    texW = w * scale;\n                    texH = h * scale;\n                }\n                return {\n                    scale: scale,\n                    texW: texW,\n                    texH: texH\n                };\n            }\n        },\n        {\n            key: \"draw\",\n            value: function draw(key, bb, doDrawing) {\n                var _this = this;\n                if (this.locked) throw new Error('can\\'t draw, atlas is locked');\n                var texSize = this.texSize, texRows = this.texRows, texHeight = this.texHeight;\n                var _this$getScale = this.getScale(bb), scale = _this$getScale.scale, texW = _this$getScale.texW, texH = _this$getScale.texH;\n                var drawAt = function drawAt(location, canvas) {\n                    if (doDrawing && canvas) {\n                        var context = canvas.context;\n                        var x = location.x, row = location.row;\n                        var xOffset = x;\n                        var yOffset = texHeight * row;\n                        context.save();\n                        context.translate(xOffset, yOffset);\n                        context.scale(scale, scale);\n                        doDrawing(context, bb);\n                        context.restore();\n                    }\n                };\n                var locations = [\n                    null,\n                    null\n                ];\n                var drawNormal = function drawNormal() {\n                    // don't need to wrap, draw directly on the canvas\n                    drawAt(_this.freePointer, _this.canvas);\n                    locations[0] = {\n                        x: _this.freePointer.x,\n                        y: _this.freePointer.row * texHeight,\n                        w: texW,\n                        h: texH\n                    };\n                    locations[1] = {\n                        // create a second location with a width of 0, for convenience\n                        x: _this.freePointer.x + texW,\n                        y: _this.freePointer.row * texHeight,\n                        w: 0,\n                        h: texH\n                    };\n                    // move the pointer to the end of the texture\n                    _this.freePointer.x += texW;\n                    if (_this.freePointer.x == texSize) {\n                        _this.freePointer.x = 0;\n                        _this.freePointer.row++;\n                    }\n                };\n                var drawWrapped = function drawWrapped() {\n                    var scratch = _this.scratch, canvas = _this.canvas;\n                    // Draw to the scratch canvas\n                    scratch.clear();\n                    drawAt({\n                        x: 0,\n                        row: 0\n                    }, scratch);\n                    var firstTexW = texSize - _this.freePointer.x;\n                    var secondTexW = texW - firstTexW;\n                    var h = texHeight;\n                    {\n                        // copy first part of scratch to the first texture\n                        var dx = _this.freePointer.x;\n                        var dy = _this.freePointer.row * texHeight;\n                        var w = firstTexW;\n                        canvas.context.drawImage(scratch, 0, 0, w, h, dx, dy, w, h);\n                        locations[0] = {\n                            x: dx,\n                            y: dy,\n                            w: w,\n                            h: texH\n                        };\n                    }\n                    {\n                        // copy second part of scratch to the second texture\n                        var sx = firstTexW;\n                        var _dy = (_this.freePointer.row + 1) * texHeight;\n                        var _w = secondTexW;\n                        if (canvas) {\n                            canvas.context.drawImage(scratch, sx, 0, _w, h, 0, _dy, _w, h);\n                        }\n                        locations[1] = {\n                            x: 0,\n                            y: _dy,\n                            w: _w,\n                            h: texH\n                        };\n                    }\n                    _this.freePointer.x = secondTexW;\n                    _this.freePointer.row++;\n                };\n                var moveToStartOfNextRow = function moveToStartOfNextRow() {\n                    _this.freePointer.x = 0;\n                    _this.freePointer.row++;\n                };\n                if (this.freePointer.x + texW <= texSize) {\n                    // There's enough space in the current row\n                    drawNormal();\n                } else if (this.freePointer.row >= texRows - 1) {\n                    // Need to move to the next row, but there are no more rows, atlas is full.\n                    return false;\n                } else if (this.freePointer.x === texSize) {\n                    // happen to be right at end of current row\n                    moveToStartOfNextRow();\n                    drawNormal();\n                } else if (this.enableWrapping) {\n                    // draw part of the texture to the end of the curent row, then wrap to the next row\n                    drawWrapped();\n                } else {\n                    // move to the start of the next row, then draw normally\n                    moveToStartOfNextRow();\n                    drawNormal();\n                }\n                this.keyToLocation.set(key, locations);\n                this.needsBuffer = true;\n                return locations;\n            }\n        },\n        {\n            key: \"getOffsets\",\n            value: function getOffsets(key) {\n                return this.keyToLocation.get(key);\n            }\n        },\n        {\n            key: \"isEmpty\",\n            value: function isEmpty() {\n                return this.freePointer.x === 0 && this.freePointer.row === 0;\n            }\n        },\n        {\n            key: \"canFit\",\n            value: function canFit(bb) {\n                if (this.locked) return false;\n                var texSize = this.texSize, texRows = this.texRows;\n                var _this$getScale2 = this.getScale(bb), texW = _this$getScale2.texW;\n                if (this.freePointer.x + texW > texSize) {\n                    // need to wrap\n                    return this.freePointer.row < texRows - 1; // return true if there's a row to wrap to\n                }\n                return true;\n            }\n        },\n        {\n            key: \"bufferIfNeeded\",\n            value: function bufferIfNeeded(gl) {\n                if (!this.texture) {\n                    this.texture = createTexture(gl, this.debugID);\n                }\n                if (this.needsBuffer) {\n                    this.texture.buffer(this.canvas);\n                    this.needsBuffer = false;\n                    if (this.locked) {\n                        this.canvas = null;\n                        this.scratch = null;\n                    }\n                }\n            }\n        },\n        {\n            key: \"dispose\",\n            value: function dispose() {\n                if (this.texture) {\n                    this.texture.deleteTexture();\n                    this.texture = null;\n                }\n                this.canvas = null;\n                this.scratch = null;\n                this.locked = true;\n            }\n        }\n    ]);\n}();\n/**\n * A collection of texture atlases, all of the same \"render type\". \n * ('node-body' is an example of a render type.)\n * An AtlasCollection can also be notified when a texture is no longer needed, \n * and it can garbage collect the unused textures.\n */ var AtlasCollection = /*#__PURE__*/ function() {\n    function AtlasCollection(r, texSize, texRows, createTextureCanvas) {\n        _classCallCheck(this, AtlasCollection);\n        this.r = r;\n        this.texSize = texSize;\n        this.texRows = texRows;\n        this.createTextureCanvas = createTextureCanvas;\n        this.atlases = [];\n        this.styleKeyToAtlas = new Map();\n        this.markedKeys = new Set(); // marked for garbage collection\n    }\n    return _createClass(AtlasCollection, [\n        {\n            key: \"getKeys\",\n            value: function getKeys() {\n                return new Set(this.styleKeyToAtlas.keys());\n            }\n        },\n        {\n            key: \"_createAtlas\",\n            value: function _createAtlas() {\n                var r = this.r, texSize = this.texSize, texRows = this.texRows, createTextureCanvas = this.createTextureCanvas;\n                return new Atlas(r, texSize, texRows, createTextureCanvas);\n            }\n        },\n        {\n            key: \"_getScratchCanvas\",\n            value: function _getScratchCanvas() {\n                if (!this.scratch) {\n                    var r = this.r, texSize = this.texSize, texRows = this.texRows, createTextureCanvas = this.createTextureCanvas;\n                    var texHeight = Math.floor(texSize / texRows);\n                    this.scratch = createTextureCanvas(r, texSize, texHeight, 'scratch');\n                }\n                return this.scratch;\n            }\n        },\n        {\n            key: \"draw\",\n            value: function draw(key, bb, doDrawing) {\n                var atlas = this.styleKeyToAtlas.get(key);\n                if (!atlas) {\n                    // check for space at the end of the last atlas\n                    atlas = this.atlases[this.atlases.length - 1];\n                    if (!atlas || !atlas.canFit(bb)) {\n                        if (atlas) atlas.lock();\n                        // create a new atlas\n                        atlas = this._createAtlas();\n                        this.atlases.push(atlas);\n                    }\n                    atlas.draw(key, bb, doDrawing);\n                    this.styleKeyToAtlas.set(key, atlas);\n                }\n                return atlas;\n            }\n        },\n        {\n            key: \"getAtlas\",\n            value: function getAtlas(key) {\n                return this.styleKeyToAtlas.get(key);\n            }\n        },\n        {\n            key: \"hasAtlas\",\n            value: function hasAtlas(key) {\n                return this.styleKeyToAtlas.has(key);\n            }\n        },\n        {\n            key: \"markKeyForGC\",\n            value: function markKeyForGC(key) {\n                this.markedKeys.add(key);\n            }\n        },\n        {\n            key: \"gc\",\n            value: function gc() {\n                var _this2 = this;\n                var markedKeys = this.markedKeys;\n                if (markedKeys.size === 0) {\n                    console.log('nothing to garbage collect');\n                    return;\n                }\n                var newAtlases = [];\n                var newStyleKeyToAtlas = new Map();\n                var newAtlas = null;\n                var _iterator = _createForOfIteratorHelper(this.atlases), _step;\n                try {\n                    var _loop = function _loop() {\n                        var atlas = _step.value;\n                        var keys = atlas.getKeys();\n                        var keysToCollect = intersection(markedKeys, keys);\n                        if (keysToCollect.size === 0) {\n                            // this atlas can still be used\n                            newAtlases.push(atlas);\n                            keys.forEach(function(k) {\n                                return newStyleKeyToAtlas.set(k, atlas);\n                            });\n                            return 1; // continue\n                        }\n                        if (!newAtlas) {\n                            newAtlas = _this2._createAtlas();\n                            newAtlases.push(newAtlas);\n                        }\n                        var _iterator2 = _createForOfIteratorHelper(keys), _step2;\n                        try {\n                            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                                var key = _step2.value;\n                                if (!keysToCollect.has(key)) {\n                                    var _atlas$getOffsets = atlas.getOffsets(key), _atlas$getOffsets2 = _slicedToArray(_atlas$getOffsets, 2), s1 = _atlas$getOffsets2[0], s2 = _atlas$getOffsets2[1];\n                                    if (!newAtlas.canFit({\n                                        w: s1.w + s2.w,\n                                        h: s1.h\n                                    })) {\n                                        newAtlas.lock();\n                                        newAtlas = _this2._createAtlas();\n                                        newAtlases.push(newAtlas);\n                                    }\n                                    if (atlas.canvas) {\n                                        // if the texture can't be copied then it will have to be redrawn on the next frame\n                                        _this2._copyTextureToNewAtlas(key, atlas, newAtlas);\n                                        newStyleKeyToAtlas.set(key, newAtlas);\n                                    }\n                                }\n                            }\n                        } catch (err) {\n                            _iterator2.e(err);\n                        } finally{\n                            _iterator2.f();\n                        }\n                        atlas.dispose();\n                    };\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        if (_loop()) continue;\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n                this.atlases = newAtlases;\n                this.styleKeyToAtlas = newStyleKeyToAtlas;\n                this.markedKeys = new Set();\n            }\n        },\n        {\n            key: \"_copyTextureToNewAtlas\",\n            value: function _copyTextureToNewAtlas(key, oldAtlas, newAtlas) {\n                var _oldAtlas$getOffsets = oldAtlas.getOffsets(key), _oldAtlas$getOffsets2 = _slicedToArray(_oldAtlas$getOffsets, 2), s1 = _oldAtlas$getOffsets2[0], s2 = _oldAtlas$getOffsets2[1];\n                if (s2.w === 0) {\n                    // the texture does not wrap, draw directly to new atlas\n                    newAtlas.draw(key, s1, function(context) {\n                        context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);\n                    });\n                } else {\n                    // the texture wraps, first draw both parts to a scratch canvas\n                    var scratch = this._getScratchCanvas();\n                    scratch.clear();\n                    scratch.context.drawImage(oldAtlas.canvas, s1.x, s1.y, s1.w, s1.h, 0, 0, s1.w, s1.h);\n                    scratch.context.drawImage(oldAtlas.canvas, s2.x, s2.y, s2.w, s2.h, s1.w, 0, s2.w, s2.h);\n                    // now draw the scratch to the new atlas\n                    var w = s1.w + s2.w;\n                    var h = s1.h;\n                    newAtlas.draw(key, {\n                        w: w,\n                        h: h\n                    }, function(context) {\n                        context.drawImage(scratch, 0, 0, w, h, 0, 0, w, h // the destination context has already been translated to the correct position\n                        );\n                    });\n                }\n            }\n        },\n        {\n            key: \"getCounts\",\n            value: function getCounts() {\n                return {\n                    keyCount: this.styleKeyToAtlas.size,\n                    atlasCount: new Set(this.styleKeyToAtlas.values()).size\n                };\n            }\n        }\n    ]);\n}();\nfunction intersection(set1, set2) {\n    // TODO why no Set.intersection in node 16???\n    if (set1.intersection) return set1.intersection(set2);\n    else return new Set(_toConsumableArray(set1).filter(function(x) {\n        return set2.has(x);\n    }));\n}\n/**\n * Used to manage batches of Atlases for drawing nodes and labels.\n * Supports different types of AtlasCollections for different render types,\n * for example 'node-body' and 'node-label' would be different render types.\n * Render types are kept separate because they will likely need to be garbage collected\n * separately and its not entierly guaranteed that their style keys won't collide.\n */ var AtlasManager = /*#__PURE__*/ function() {\n    function AtlasManager(r, globalOptions) {\n        _classCallCheck(this, AtlasManager);\n        this.r = r;\n        this.globalOptions = globalOptions;\n        this.atlasSize = globalOptions.webglTexSize;\n        this.maxAtlasesPerBatch = globalOptions.webglTexPerBatch;\n        this.renderTypes = new Map(); // renderType:string -> renderTypeOptions\n        this.collections = new Map(); // collectionName:string -> AtlasCollection\n        this.typeAndIdToKey = new Map(); // [renderType,id] => Array<style key>\n    }\n    return _createClass(AtlasManager, [\n        {\n            key: \"getAtlasSize\",\n            value: function getAtlasSize() {\n                return this.atlasSize;\n            }\n        },\n        {\n            key: \"addAtlasCollection\",\n            value: function addAtlasCollection(collectionName, atlasCollectionOptions) {\n                var _this$globalOptions = this.globalOptions, webglTexSize = _this$globalOptions.webglTexSize, createTextureCanvas = _this$globalOptions.createTextureCanvas;\n                var texRows = atlasCollectionOptions.texRows;\n                var cachedCreateTextureCanvas = this._cacheScratchCanvas(createTextureCanvas);\n                var atlasCollection = new AtlasCollection(this.r, webglTexSize, texRows, cachedCreateTextureCanvas);\n                this.collections.set(collectionName, atlasCollection);\n            }\n        },\n        {\n            key: \"addRenderType\",\n            value: function addRenderType(type, renderTypeOptions) {\n                var collection = renderTypeOptions.collection;\n                if (!this.collections.has(collection)) throw new Error(\"invalid atlas collection name '\".concat(collection, \"'\"));\n                var atlasCollection = this.collections.get(collection);\n                var opts = extend({\n                    type: type,\n                    atlasCollection: atlasCollection\n                }, renderTypeOptions);\n                this.renderTypes.set(type, opts);\n            }\n        },\n        {\n            key: \"getRenderTypeOpts\",\n            value: function getRenderTypeOpts(type) {\n                return this.renderTypes.get(type);\n            }\n        },\n        {\n            key: \"getAtlasCollection\",\n            value: function getAtlasCollection(name) {\n                return this.collections.get(name);\n            }\n        },\n        {\n            key: \"_cacheScratchCanvas\",\n            value: function _cacheScratchCanvas(createTextureCanvas) {\n                // all scratch canvases for the same render type will have the same width and height (ie webglTexRows option)\n                // but we'll keep track of the width and height just to be safe\n                var prevW = -1;\n                var prevH = -1;\n                var scratchCanvas = null;\n                return function(r, w, h, scratch) {\n                    if (scratch) {\n                        if (!scratchCanvas || w != prevW || h != prevH) {\n                            prevW = w;\n                            prevH = h;\n                            scratchCanvas = createTextureCanvas(r, w, h);\n                        }\n                        return scratchCanvas;\n                    } else {\n                        return createTextureCanvas(r, w, h);\n                    }\n                };\n            }\n        },\n        {\n            key: \"_key\",\n            value: function _key(renderType, id) {\n                return \"\".concat(renderType, \"-\").concat(id); // TODO not very efficient\n            }\n        },\n        {\n            key: \"invalidate\",\n            value: function invalidate(eles) {\n                var _this3 = this;\n                var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref2$forceRedraw = _ref2.forceRedraw, forceRedraw = _ref2$forceRedraw === undefined ? false : _ref2$forceRedraw, _ref2$filterEle = _ref2.filterEle, filterEle = _ref2$filterEle === undefined ? function() {\n                    return true;\n                } : _ref2$filterEle, _ref2$filterType = _ref2.filterType, filterType = _ref2$filterType === undefined ? function() {\n                    return true;\n                } : _ref2$filterType;\n                var needGC = false;\n                var runGCNow = false;\n                var _iterator3 = _createForOfIteratorHelper(eles), _step3;\n                try {\n                    for(_iterator3.s(); !(_step3 = _iterator3.n()).done;){\n                        var ele = _step3.value;\n                        if (filterEle(ele)) {\n                            var _iterator4 = _createForOfIteratorHelper(this.renderTypes.values()), _step4;\n                            try {\n                                var _loop2 = function _loop2() {\n                                    var opts = _step4.value;\n                                    var renderType = opts.type;\n                                    if (filterType(renderType)) {\n                                        var atlasCollection = _this3.collections.get(opts.collection);\n                                        var key = opts.getKey(ele);\n                                        var keyArray = Array.isArray(key) ? key : [\n                                            key\n                                        ];\n                                        // when a node's background image finishes loading, the style key doesn't change but still needs to be redrawn\n                                        if (forceRedraw) {\n                                            keyArray.forEach(function(key) {\n                                                return atlasCollection.markKeyForGC(key);\n                                            });\n                                            runGCNow = true; // run GC to remove the old texture right now, that way we don't need to remember for the next gc \n                                        } else {\n                                            var id = opts.getID ? opts.getID(ele) : ele.id();\n                                            var mapKey = _this3._key(renderType, id);\n                                            var oldKeyArray = _this3.typeAndIdToKey.get(mapKey);\n                                            if (oldKeyArray !== undefined && !arrayEqual(keyArray, oldKeyArray)) {\n                                                // conservative approach, if any of the keys don't match then throw them all away\n                                                needGC = true;\n                                                _this3.typeAndIdToKey[\"delete\"](mapKey);\n                                                oldKeyArray.forEach(function(oldKey) {\n                                                    return atlasCollection.markKeyForGC(oldKey);\n                                                });\n                                            }\n                                        }\n                                    }\n                                };\n                                for(_iterator4.s(); !(_step4 = _iterator4.n()).done;){\n                                    _loop2();\n                                }\n                            } catch (err) {\n                                _iterator4.e(err);\n                            } finally{\n                                _iterator4.f();\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _iterator3.e(err);\n                } finally{\n                    _iterator3.f();\n                }\n                if (runGCNow) {\n                    this.gc();\n                    needGC = false;\n                }\n                return needGC;\n            }\n        },\n        {\n            key: \"gc\",\n            value: function gc() {\n                var _iterator5 = _createForOfIteratorHelper(this.collections.values()), _step5;\n                try {\n                    for(_iterator5.s(); !(_step5 = _iterator5.n()).done;){\n                        var collection = _step5.value;\n                        collection.gc();\n                    }\n                } catch (err) {\n                    _iterator5.e(err);\n                } finally{\n                    _iterator5.f();\n                }\n            }\n        },\n        {\n            key: \"getOrCreateAtlas\",\n            value: function getOrCreateAtlas(ele, type, bb, styleKey) {\n                // styleKey is not an array here\n                var opts = this.renderTypes.get(type);\n                var atlasCollection = this.collections.get(opts.collection);\n                // draws the texture only if needed\n                var drawn = false;\n                var atlas = atlasCollection.draw(styleKey, bb, function(context) {\n                    if (opts.drawClipped) {\n                        context.save();\n                        context.beginPath();\n                        context.rect(0, 0, bb.w, bb.h);\n                        context.clip();\n                        opts.drawElement(context, ele, bb, true, true);\n                        context.restore();\n                    } else {\n                        opts.drawElement(context, ele, bb, true, true);\n                    }\n                    drawn = true;\n                });\n                if (drawn) {\n                    var id = opts.getID ? opts.getID(ele) : ele.id(); // for testing\n                    var mapKey = this._key(type, id);\n                    if (this.typeAndIdToKey.has(mapKey)) {\n                        this.typeAndIdToKey.get(mapKey).push(styleKey);\n                    } else {\n                        this.typeAndIdToKey.set(mapKey, [\n                            styleKey\n                        ]);\n                    }\n                }\n                return atlas;\n            }\n        },\n        {\n            key: \"getAtlasInfo\",\n            value: function getAtlasInfo(ele, type) {\n                var _this4 = this;\n                var opts = this.renderTypes.get(type);\n                var key = opts.getKey(ele);\n                var keyArray = Array.isArray(key) ? key : [\n                    key\n                ];\n                return keyArray.map(function(styleKey) {\n                    var bb = opts.getBoundingBox(ele, styleKey); // pass the key back to the getBoundingBox method\n                    var atlas = _this4.getOrCreateAtlas(ele, type, bb, styleKey);\n                    var _atlas$getOffsets3 = atlas.getOffsets(styleKey), _atlas$getOffsets4 = _slicedToArray(_atlas$getOffsets3, 2), tex1 = _atlas$getOffsets4[0], tex2 = _atlas$getOffsets4[1];\n                    return {\n                        atlas: atlas,\n                        tex: tex1,\n                        tex1: tex1,\n                        tex2: tex2,\n                        bb: bb\n                    };\n                });\n            }\n        },\n        {\n            key: \"getDebugInfo\",\n            value: function getDebugInfo() {\n                var debugInfo = [];\n                var _iterator6 = _createForOfIteratorHelper(this.collections), _step6;\n                try {\n                    for(_iterator6.s(); !(_step6 = _iterator6.n()).done;){\n                        var _step6$value = _slicedToArray(_step6.value, 2), name = _step6$value[0], collection = _step6$value[1];\n                        var _collection$getCounts = collection.getCounts(), keyCount = _collection$getCounts.keyCount, atlasCount = _collection$getCounts.atlasCount;\n                        debugInfo.push({\n                            type: name,\n                            keyCount: keyCount,\n                            atlasCount: atlasCount\n                        });\n                    }\n                } catch (err) {\n                    _iterator6.e(err);\n                } finally{\n                    _iterator6.f();\n                }\n                return debugInfo;\n            }\n        }\n    ]);\n}();\nvar AtlasBatchManager = /*#__PURE__*/ function() {\n    function AtlasBatchManager(globalOptions) {\n        _classCallCheck(this, AtlasBatchManager);\n        this.globalOptions = globalOptions;\n        this.atlasSize = globalOptions.webglTexSize;\n        this.maxAtlasesPerBatch = globalOptions.webglTexPerBatch;\n        this.batchAtlases = [];\n    }\n    return _createClass(AtlasBatchManager, [\n        {\n            key: \"getMaxAtlasesPerBatch\",\n            value: function getMaxAtlasesPerBatch() {\n                return this.maxAtlasesPerBatch;\n            }\n        },\n        {\n            key: \"getAtlasSize\",\n            value: function getAtlasSize() {\n                return this.atlasSize;\n            }\n        },\n        {\n            key: \"getIndexArray\",\n            value: function getIndexArray() {\n                return Array.from({\n                    length: this.maxAtlasesPerBatch\n                }, function(v, i) {\n                    return i;\n                });\n            }\n        },\n        {\n            key: \"startBatch\",\n            value: function startBatch() {\n                this.batchAtlases = [];\n            }\n        },\n        {\n            key: \"getAtlasCount\",\n            value: function getAtlasCount() {\n                return this.batchAtlases.length;\n            }\n        },\n        {\n            key: \"getAtlases\",\n            value: function getAtlases() {\n                return this.batchAtlases;\n            }\n        },\n        {\n            key: \"canAddToCurrentBatch\",\n            value: function canAddToCurrentBatch(atlas) {\n                if (this.batchAtlases.length === this.maxAtlasesPerBatch) {\n                    return this.batchAtlases.includes(atlas);\n                }\n                return true; // not full\n            }\n        },\n        {\n            key: \"getAtlasIndexForBatch\",\n            value: function getAtlasIndexForBatch(atlas) {\n                var atlasID = this.batchAtlases.indexOf(atlas);\n                if (atlasID < 0) {\n                    if (this.batchAtlases.length === this.maxAtlasesPerBatch) {\n                        throw new Error('cannot add more atlases to batch');\n                    }\n                    this.batchAtlases.push(atlas);\n                    atlasID = this.batchAtlases.length - 1;\n                }\n                return atlasID;\n            }\n        }\n    ]);\n}();\n// Fragment shader functions to calculate signed distance\n// https://iquilezles.org/articles/distfunctions2d/\n// ellipse: https://www.shadertoy.com/view/4lsXDN \n/**\n * param p - point\n * float r - circle radius, eg 0.5 for unit circle\n */ var circleSD = \"\\n  float circleSD(vec2 p, float r) {\\n    return distance(vec2(0), p) - r; // signed distance\\n  }\\n\";\n/**\n * param p - point\n * param b - b.x = half width, b.y = half height\n */ var rectangleSD = \"\\n  float rectangleSD(vec2 p, vec2 b) {\\n    vec2 d = abs(p)-b;\\n    return distance(vec2(0),max(d,0.0)) + min(max(d.x,d.y),0.0);\\n  }\\n\";\n/**\n * param p - point\n * param b - b.x = half width, b.y = half height\n * param cr - vector of corner radiuses\n */ var roundRectangleSD = \"\\n  float roundRectangleSD(vec2 p, vec2 b, vec4 cr) {\\n    cr.xy = (p.x > 0.0) ? cr.xy : cr.zw;\\n    cr.x  = (p.y > 0.0) ? cr.x  : cr.y;\\n    vec2 q = abs(p) - b + cr.x;\\n    return min(max(q.x, q.y), 0.0) + distance(vec2(0), max(q, 0.0)) - cr.x;\\n  }\\n\";\n/**\n * param p - point\n * param ab - a.x = horizontal radius, a.y = vertical radius\n */ var ellipseSD = \"\\n  float ellipseSD(vec2 p, vec2 ab) {\\n    p = abs( p ); // symmetry\\n\\n    // find root with Newton solver\\n    vec2 q = ab*(p-ab);\\n    float w = (q.x<q.y)? 1.570796327 : 0.0;\\n    for( int i=0; i<5; i++ ) {\\n      vec2 cs = vec2(cos(w),sin(w));\\n      vec2 u = ab*vec2( cs.x,cs.y);\\n      vec2 v = ab*vec2(-cs.y,cs.x);\\n      w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\\n    }\\n    \\n    // compute final point and distance\\n    float d = length(p-ab*vec2(cos(w),sin(w)));\\n    \\n    // return signed distance\\n    return (dot(p/ab,p/ab)>1.0) ? d : -d;\\n  }\\n\";\n/**\n * Two render modes. Each mode has its own shader program. They are almost identical, the main difference is the output.\n * SCREEN:  output pixel colors to the screen\n * PICKING: output z-order index to an offscreen framebuffer, used to detect what's under the mouse cursor\n */ var RENDER_TARGET = {\n    SCREEN: {\n        name: 'screen',\n        screen: true\n    },\n    PICKING: {\n        name: 'picking',\n        picking: true\n    }\n};\n/**\n * Special handing for label textures in PICKING mode. See issue #3337.\n */ var TEX_PICKING_MODE = {\n    // render the texture just like in RENDER_TARGET.SCREEN mode\n    IGNORE: 1,\n    // don't render the texture at all\n    USE_BB: 2 // render the bounding box as an opaque rectangle\n};\n// Vertex types.\n// Used directly in the shaders so must be numeric.\n// There is only one shader program used for an entire frame that renders all types of elements.\n// There are if-else blocks in the shaders that do different things depending on the vertex type.\n// This allows all elements to be rendererd in large batches without switching shader programs.\nvar TEXTURE = 0;\nvar EDGE_STRAIGHT = 1;\nvar EDGE_CURVE_SEGMENT = 2;\nvar EDGE_ARROW = 3;\nvar RECTANGLE = 4;\nvar ROUND_RECTANGLE = 5;\nvar BOTTOM_ROUND_RECTANGLE = 6;\nvar ELLIPSE = 7;\nvar ElementDrawingWebGL = /*#__PURE__*/ function() {\n    /**\n   * @param {WebGLRenderingContext} gl\n   */ function ElementDrawingWebGL(r, gl, opts) {\n        _classCallCheck(this, ElementDrawingWebGL);\n        this.r = r; // reference to the canvas renderer\n        this.gl = gl;\n        this.maxInstances = opts.webglBatchSize;\n        this.atlasSize = opts.webglTexSize;\n        this.bgColor = opts.bgColor;\n        this.debug = opts.webglDebug;\n        this.batchDebugInfo = [];\n        opts.enableWrapping = true;\n        opts.createTextureCanvas = createTextureCanvas; // Unit tests mock this\n        this.atlasManager = new AtlasManager(r, opts);\n        this.batchManager = new AtlasBatchManager(opts);\n        this.simpleShapeOptions = new Map();\n        this.program = this._createShaderProgram(RENDER_TARGET.SCREEN);\n        this.pickingProgram = this._createShaderProgram(RENDER_TARGET.PICKING);\n        this.vao = this._createVAO();\n    }\n    /**\n   * @param { string } collectionName\n   * @param {{ texRows: number }} opts\n   */ return _createClass(ElementDrawingWebGL, [\n        {\n            key: \"addAtlasCollection\",\n            value: function addAtlasCollection(collectionName, opts) {\n                this.atlasManager.addAtlasCollection(collectionName, opts);\n            }\n        },\n        {\n            key: \"addTextureAtlasRenderType\",\n            value: function addTextureAtlasRenderType(typeName, opts) {\n                this.atlasManager.addRenderType(typeName, opts);\n            }\n        },\n        {\n            key: \"addSimpleShapeRenderType\",\n            value: function addSimpleShapeRenderType(typeName, opts) {\n                this.simpleShapeOptions.set(typeName, opts);\n            }\n        },\n        {\n            key: \"invalidate\",\n            value: function invalidate(eles) {\n                var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, type = _ref.type;\n                var atlasManager = this.atlasManager;\n                if (type) {\n                    return atlasManager.invalidate(eles, {\n                        filterType: function filterType(t) {\n                            return t === type;\n                        },\n                        forceRedraw: true\n                    });\n                } else {\n                    return atlasManager.invalidate(eles);\n                }\n            }\n        },\n        {\n            key: \"gc\",\n            value: function gc() {\n                this.atlasManager.gc();\n            }\n        },\n        {\n            key: \"_createShaderProgram\",\n            value: function _createShaderProgram(renderTarget) {\n                var gl = this.gl;\n                var vertexShaderSource = \"#version 300 es\\n      precision highp float;\\n\\n      uniform mat3 uPanZoomMatrix;\\n      uniform int  uAtlasSize;\\n      \\n      // instanced\\n      in vec2 aPosition; // a vertex from the unit square\\n      \\n      in mat3 aTransform; // used to transform verticies, eg into a bounding box\\n      in int aVertType; // the type of thing we are rendering\\n\\n      // the z-index that is output when using picking mode\\n      in vec4 aIndex;\\n      \\n      // For textures\\n      in int aAtlasId; // which shader unit/atlas to use\\n      in vec4 aTex; // x/y/w/h of texture in atlas\\n\\n      // for edges\\n      in vec4 aPointAPointB;\\n      in vec4 aPointCPointD;\\n      in vec2 aLineWidth; // also used for node border width\\n\\n      // simple shapes\\n      in vec4 aCornerRadius; // for round-rectangle [top-right, bottom-right, top-left, bottom-left]\\n      in vec4 aColor; // also used for edges\\n      in vec4 aBorderColor; // aLineWidth is used for border width\\n\\n      // output values passed to the fragment shader\\n      out vec2 vTexCoord;\\n      out vec4 vColor;\\n      out vec2 vPosition;\\n      // flat values are not interpolated\\n      flat out int vAtlasId; \\n      flat out int vVertType;\\n      flat out vec2 vTopRight;\\n      flat out vec2 vBotLeft;\\n      flat out vec4 vCornerRadius;\\n      flat out vec4 vBorderColor;\\n      flat out vec2 vBorderWidth;\\n      flat out vec4 vIndex;\\n      \\n      void main(void) {\\n        int vid = gl_VertexID;\\n        vec2 position = aPosition; // TODO make this a vec3, simplifies some code below\\n\\n        if(aVertType == \".concat(TEXTURE, \") {\\n          float texX = aTex.x; // texture coordinates\\n          float texY = aTex.y;\\n          float texW = aTex.z;\\n          float texH = aTex.w;\\n\\n          if(vid == 1 || vid == 2 || vid == 4) {\\n            texX += texW;\\n          }\\n          if(vid == 2 || vid == 4 || vid == 5) {\\n            texY += texH;\\n          }\\n\\n          float d = float(uAtlasSize);\\n          vTexCoord = vec2(texX / d, texY / d); // tex coords must be between 0 and 1\\n\\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\\n        }\\n        else if(aVertType == \").concat(RECTANGLE, \" || aVertType == \").concat(ELLIPSE, \" \\n             || aVertType == \").concat(ROUND_RECTANGLE, \" || aVertType == \").concat(BOTTOM_ROUND_RECTANGLE, \") { // simple shapes\\n\\n          // the bounding box is needed by the fragment shader\\n          vBotLeft  = (aTransform * vec3(0, 0, 1)).xy; // flat\\n          vTopRight = (aTransform * vec3(1, 1, 1)).xy; // flat\\n          vPosition = (aTransform * vec3(position, 1)).xy; // will be interpolated\\n\\n          // calculations are done in the fragment shader, just pass these along\\n          vColor = aColor;\\n          vCornerRadius = aCornerRadius;\\n          vBorderColor = aBorderColor;\\n          vBorderWidth = aLineWidth;\\n\\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\\n        }\\n        else if(aVertType == \").concat(EDGE_STRAIGHT, \") {\\n          vec2 source = aPointAPointB.xy;\\n          vec2 target = aPointAPointB.zw;\\n\\n          // adjust the geometry so that the line is centered on the edge\\n          position.y = position.y - 0.5;\\n\\n          // stretch the unit square into a long skinny rectangle\\n          vec2 xBasis = target - source;\\n          vec2 yBasis = normalize(vec2(-xBasis.y, xBasis.x));\\n          vec2 point = source + xBasis * position.x + yBasis * aLineWidth[0] * position.y;\\n\\n          gl_Position = vec4(uPanZoomMatrix * vec3(point, 1.0), 1.0);\\n          vColor = aColor;\\n        } \\n        else if(aVertType == \").concat(EDGE_CURVE_SEGMENT, \") {\\n          vec2 pointA = aPointAPointB.xy;\\n          vec2 pointB = aPointAPointB.zw;\\n          vec2 pointC = aPointCPointD.xy;\\n          vec2 pointD = aPointCPointD.zw;\\n\\n          // adjust the geometry so that the line is centered on the edge\\n          position.y = position.y - 0.5;\\n\\n          vec2 p0, p1, p2, pos;\\n          if(position.x == 0.0) { // The left side of the unit square\\n            p0 = pointA;\\n            p1 = pointB;\\n            p2 = pointC;\\n            pos = position;\\n          } else { // The right side of the unit square, use same approach but flip the geometry upside down\\n            p0 = pointD;\\n            p1 = pointC;\\n            p2 = pointB;\\n            pos = vec2(0.0, -position.y);\\n          }\\n\\n          vec2 p01 = p1 - p0;\\n          vec2 p12 = p2 - p1;\\n          vec2 p21 = p1 - p2;\\n\\n          // Find the normal vector.\\n          vec2 tangent = normalize(normalize(p12) + normalize(p01));\\n          vec2 normal = vec2(-tangent.y, tangent.x);\\n\\n          // Find the vector perpendicular to p0 -> p1.\\n          vec2 p01Norm = normalize(vec2(-p01.y, p01.x));\\n\\n          // Determine the bend direction.\\n          float sigma = sign(dot(p01 + p21, normal));\\n          float width = aLineWidth[0];\\n\\n          if(sign(pos.y) == -sigma) {\\n            // This is an intersecting vertex. Adjust the position so that there's no overlap.\\n            vec2 point = 0.5 * width * normal * -sigma / dot(normal, p01Norm);\\n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);\\n          } else {\\n            // This is a non-intersecting vertex. Treat it like a mitre join.\\n            vec2 point = 0.5 * width * normal * sigma * dot(normal, p01Norm);\\n            gl_Position = vec4(uPanZoomMatrix * vec3(p1 + point, 1.0), 1.0);\\n          }\\n\\n          vColor = aColor;\\n        } \\n        else if(aVertType == \").concat(EDGE_ARROW, \" && vid < 3) {\\n          // massage the first triangle into an edge arrow\\n          if(vid == 0)\\n            position = vec2(-0.15, -0.3);\\n          if(vid == 1)\\n            position = vec2(  0.0,  0.0);\\n          if(vid == 2)\\n            position = vec2( 0.15, -0.3);\\n\\n          gl_Position = vec4(uPanZoomMatrix * aTransform * vec3(position, 1.0), 1.0);\\n          vColor = aColor;\\n        }\\n        else {\\n          gl_Position = vec4(2.0, 0.0, 0.0, 1.0); // discard vertex by putting it outside webgl clip space\\n        }\\n\\n        vAtlasId = aAtlasId;\\n        vVertType = aVertType;\\n        vIndex = aIndex;\\n      }\\n    \");\n                var idxs = this.batchManager.getIndexArray();\n                var fragmentShaderSource = \"#version 300 es\\n      precision highp float;\\n\\n      // declare texture unit for each texture atlas in the batch\\n      \".concat(idxs.map(function(i) {\n                    return \"uniform sampler2D uTexture\".concat(i, \";\");\n                }).join('\\n\\t'), \"\\n\\n      uniform vec4 uBGColor;\\n      uniform float uZoom;\\n\\n      in vec2 vTexCoord;\\n      in vec4 vColor;\\n      in vec2 vPosition; // model coordinates\\n\\n      flat in int vAtlasId;\\n      flat in vec4 vIndex;\\n      flat in int vVertType;\\n      flat in vec2 vTopRight;\\n      flat in vec2 vBotLeft;\\n      flat in vec4 vCornerRadius;\\n      flat in vec4 vBorderColor;\\n      flat in vec2 vBorderWidth;\\n\\n      out vec4 outColor;\\n\\n      \").concat(circleSD, \"\\n      \").concat(rectangleSD, \"\\n      \").concat(roundRectangleSD, \"\\n      \").concat(ellipseSD, \"\\n\\n      vec4 blend(vec4 top, vec4 bot) { // blend colors with premultiplied alpha\\n        return vec4( \\n          top.rgb + (bot.rgb * (1.0 - top.a)),\\n          top.a   + (bot.a   * (1.0 - top.a)) \\n        );\\n      }\\n\\n      vec4 distInterp(vec4 cA, vec4 cB, float d) { // interpolate color using Signed Distance\\n        // scale to the zoom level so that borders don't look blurry when zoomed in\\n        // note 1.5 is an aribitrary value chosen because it looks good\\n        return mix(cA, cB, 1.0 - smoothstep(0.0, 1.5 / uZoom, abs(d))); \\n      }\\n\\n      void main(void) {\\n        if(vVertType == \").concat(TEXTURE, \") {\\n          // look up the texel from the texture unit\\n          \").concat(idxs.map(function(i) {\n                    return \"if(vAtlasId == \".concat(i, \") outColor = texture(uTexture\").concat(i, \", vTexCoord);\");\n                }).join('\\n\\telse '), \"\\n        } \\n        else if(vVertType == \").concat(EDGE_ARROW, \") {\\n          // mimics how canvas renderer uses context.globalCompositeOperation = 'destination-out';\\n          outColor = blend(vColor, uBGColor);\\n          outColor.a = 1.0; // make opaque, masks out line under arrow\\n        }\\n        else if(vVertType == \").concat(RECTANGLE, \" && vBorderWidth == vec2(0.0)) { // simple rectangle with no border\\n          outColor = vColor; // unit square is already transformed to the rectangle, nothing else needs to be done\\n        }\\n        else if(vVertType == \").concat(RECTANGLE, \" || vVertType == \").concat(ELLIPSE, \" \\n          || vVertType == \").concat(ROUND_RECTANGLE, \" || vVertType == \").concat(BOTTOM_ROUND_RECTANGLE, \") { // use SDF\\n\\n          float outerBorder = vBorderWidth[0];\\n          float innerBorder = vBorderWidth[1];\\n          float borderPadding = outerBorder * 2.0;\\n          float w = vTopRight.x - vBotLeft.x - borderPadding;\\n          float h = vTopRight.y - vBotLeft.y - borderPadding;\\n          vec2 b = vec2(w/2.0, h/2.0); // half width, half height\\n          vec2 p = vPosition - vec2(vTopRight.x - b[0] - outerBorder, vTopRight.y - b[1] - outerBorder); // translate to center\\n\\n          float d; // signed distance\\n          if(vVertType == \").concat(RECTANGLE, \") {\\n            d = rectangleSD(p, b);\\n          } else if(vVertType == \").concat(ELLIPSE, \" && w == h) {\\n            d = circleSD(p, b.x); // faster than ellipse\\n          } else if(vVertType == \").concat(ELLIPSE, \") {\\n            d = ellipseSD(p, b);\\n          } else {\\n            d = roundRectangleSD(p, b, vCornerRadius.wzyx);\\n          }\\n\\n          // use the distance to interpolate a color to smooth the edges of the shape, doesn't need multisampling\\n          // we must smooth colors inwards, because we can't change pixels outside the shape's bounding box\\n          if(d > 0.0) {\\n            if(d > outerBorder) {\\n              discard;\\n            } else {\\n              outColor = distInterp(vBorderColor, vec4(0), d - outerBorder);\\n            }\\n          } else {\\n            if(d > innerBorder) {\\n              vec4 outerColor = outerBorder == 0.0 ? vec4(0) : vBorderColor;\\n              vec4 innerBorderColor = blend(vBorderColor, vColor);\\n              outColor = distInterp(innerBorderColor, outerColor, d);\\n            } \\n            else {\\n              vec4 outerColor;\\n              if(innerBorder == 0.0 && outerBorder == 0.0) {\\n                outerColor = vec4(0);\\n              } else if(innerBorder == 0.0) {\\n                outerColor = vBorderColor;\\n              } else {\\n                outerColor = blend(vBorderColor, vColor);\\n              }\\n              outColor = distInterp(vColor, outerColor, d - innerBorder);\\n            }\\n          }\\n        }\\n        else {\\n          outColor = vColor;\\n        }\\n\\n        \").concat(renderTarget.picking ? \"if(outColor.a == 0.0) discard;\\n             else outColor = vIndex;\" : '', \"\\n      }\\n    \");\n                var program = createProgram(gl, vertexShaderSource, fragmentShaderSource);\n                // instance geometry\n                program.aPosition = gl.getAttribLocation(program, 'aPosition');\n                // attributes\n                program.aIndex = gl.getAttribLocation(program, 'aIndex');\n                program.aVertType = gl.getAttribLocation(program, 'aVertType');\n                program.aTransform = gl.getAttribLocation(program, 'aTransform');\n                program.aAtlasId = gl.getAttribLocation(program, 'aAtlasId');\n                program.aTex = gl.getAttribLocation(program, 'aTex');\n                program.aPointAPointB = gl.getAttribLocation(program, 'aPointAPointB');\n                program.aPointCPointD = gl.getAttribLocation(program, 'aPointCPointD');\n                program.aLineWidth = gl.getAttribLocation(program, 'aLineWidth');\n                program.aColor = gl.getAttribLocation(program, 'aColor');\n                program.aCornerRadius = gl.getAttribLocation(program, 'aCornerRadius');\n                program.aBorderColor = gl.getAttribLocation(program, 'aBorderColor');\n                // uniforms\n                program.uPanZoomMatrix = gl.getUniformLocation(program, 'uPanZoomMatrix');\n                program.uAtlasSize = gl.getUniformLocation(program, 'uAtlasSize');\n                program.uBGColor = gl.getUniformLocation(program, 'uBGColor');\n                program.uZoom = gl.getUniformLocation(program, 'uZoom');\n                program.uTextures = [];\n                for(var i = 0; i < this.batchManager.getMaxAtlasesPerBatch(); i++){\n                    program.uTextures.push(gl.getUniformLocation(program, \"uTexture\".concat(i)));\n                }\n                return program;\n            }\n        },\n        {\n            key: \"_createVAO\",\n            value: function _createVAO() {\n                var unitSquare = [\n                    0,\n                    0,\n                    1,\n                    0,\n                    1,\n                    1,\n                    0,\n                    0,\n                    1,\n                    1,\n                    0,\n                    1\n                ];\n                this.vertexCount = unitSquare.length / 2;\n                var n = this.maxInstances;\n                var gl = this.gl, program = this.program;\n                var vao = gl.createVertexArray();\n                gl.bindVertexArray(vao);\n                createBufferStaticDraw(gl, 'vec2', program.aPosition, unitSquare);\n                // Create buffers for all the attributes\n                this.transformBuffer = create3x3MatrixBufferDynamicDraw(gl, n, program.aTransform);\n                this.indexBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aIndex);\n                this.vertTypeBuffer = createBufferDynamicDraw(gl, n, 'int', program.aVertType);\n                this.atlasIdBuffer = createBufferDynamicDraw(gl, n, 'int', program.aAtlasId);\n                this.texBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aTex);\n                this.pointAPointBBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aPointAPointB);\n                this.pointCPointDBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aPointCPointD);\n                this.lineWidthBuffer = createBufferDynamicDraw(gl, n, 'vec2', program.aLineWidth);\n                this.colorBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aColor);\n                this.cornerRadiusBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aCornerRadius);\n                this.borderColorBuffer = createBufferDynamicDraw(gl, n, 'vec4', program.aBorderColor);\n                gl.bindVertexArray(null);\n                return vao;\n            }\n        },\n        {\n            key: \"buffers\",\n            get: function get() {\n                var _this = this;\n                if (!this._buffers) {\n                    this._buffers = Object.keys(this).filter(function(k) {\n                        return endsWith(k, 'Buffer');\n                    }).map(function(k) {\n                        return _this[k];\n                    });\n                }\n                return this._buffers;\n            }\n        },\n        {\n            key: \"startFrame\",\n            value: function startFrame(panZoomMatrix) {\n                var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : RENDER_TARGET.SCREEN;\n                this.panZoomMatrix = panZoomMatrix;\n                this.renderTarget = renderTarget;\n                this.batchDebugInfo = [];\n                this.wrappedCount = 0;\n                this.simpleCount = 0;\n                this.startBatch();\n            }\n        },\n        {\n            key: \"startBatch\",\n            value: function startBatch() {\n                this.instanceCount = 0;\n                this.batchManager.startBatch();\n            }\n        },\n        {\n            key: \"endFrame\",\n            value: function endFrame() {\n                this.endBatch();\n            }\n        },\n        {\n            key: \"_isVisible\",\n            value: function _isVisible(ele, opts) {\n                if (ele.visible()) {\n                    if (opts && opts.isVisible) {\n                        return opts.isVisible(ele);\n                    }\n                    return true;\n                }\n                return false;\n            }\n        },\n        {\n            key: \"drawTexture\",\n            value: function drawTexture(ele, eleIndex, type) {\n                var atlasManager = this.atlasManager, batchManager = this.batchManager;\n                var opts = atlasManager.getRenderTypeOpts(type);\n                if (!this._isVisible(ele, opts)) {\n                    return;\n                }\n                // Edges with invalid points could be passed here (labels), causing errors\n                // Ref: Random \"Script Error\" thrown when generating nodes and edges in newest webgl version #3365\n                // https://github.com/cytoscape/cytoscape.js/issues/3365\n                if (ele.isEdge() && !this._isValidEdge(ele)) {\n                    return;\n                }\n                if (this.renderTarget.picking && opts.getTexPickingMode) {\n                    var mode = opts.getTexPickingMode(ele);\n                    if (mode === TEX_PICKING_MODE.IGNORE) {\n                        return;\n                    } else if (mode == TEX_PICKING_MODE.USE_BB) {\n                        this.drawPickingRectangle(ele, eleIndex, type);\n                        return;\n                    }\n                }\n                // Get the atlas and the texture coordinates, will draw the texture if it hasn't been drawn yet\n                // May be more than one texture if for example the label has multiple lines\n                var atlasInfoArray = atlasManager.getAtlasInfo(ele, type);\n                var _iterator = _createForOfIteratorHelper(atlasInfoArray), _step;\n                try {\n                    for(_iterator.s(); !(_step = _iterator.n()).done;){\n                        var atlasInfo = _step.value;\n                        var atlas = atlasInfo.atlas, tex1 = atlasInfo.tex1, tex2 = atlasInfo.tex2; // tex2 is used if the label wraps and there are two textures\n                        if (!batchManager.canAddToCurrentBatch(atlas)) {\n                            this.endBatch();\n                        }\n                        var atlasIndex = batchManager.getAtlasIndexForBatch(atlas);\n                        for(var _i = 0, _arr = [\n                            [\n                                tex1,\n                                true\n                            ],\n                            [\n                                tex2,\n                                false\n                            ]\n                        ]; _i < _arr.length; _i++){\n                            var _arr$_i = _slicedToArray(_arr[_i], 2), tex = _arr$_i[0], first = _arr$_i[1];\n                            if (tex.w != 0) {\n                                var instance = this.instanceCount;\n                                this.vertTypeBuffer.getView(instance)[0] = TEXTURE;\n                                var indexView = this.indexBuffer.getView(instance);\n                                indexToVec4(eleIndex, indexView);\n                                // Set values in the buffers using Typed Array Views for performance.\n                                var atlasIdView = this.atlasIdBuffer.getView(instance);\n                                atlasIdView[0] = atlasIndex;\n                                // we have two sets of texture coordinates and transforms because textures can wrap in the atlas\n                                var texView = this.texBuffer.getView(instance);\n                                texView[0] = tex.x;\n                                texView[1] = tex.y;\n                                texView[2] = tex.w;\n                                texView[3] = tex.h;\n                                var matrixView = this.transformBuffer.getMatrixView(instance);\n                                this.setTransformMatrix(ele, matrixView, opts, atlasInfo, first);\n                                this.instanceCount++;\n                                if (!first) this.wrappedCount++;\n                                if (this.instanceCount >= this.maxInstances) {\n                                    this.endBatch();\n                                }\n                            }\n                        }\n                    }\n                } catch (err) {\n                    _iterator.e(err);\n                } finally{\n                    _iterator.f();\n                }\n            }\n        },\n        {\n            key: \"setTransformMatrix\",\n            value: function setTransformMatrix(ele, matrix, opts, atlasInfo) {\n                var first = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n                var padding = 0;\n                if (opts.shapeProps && opts.shapeProps.padding) {\n                    padding = ele.pstyle(opts.shapeProps.padding).pfValue;\n                }\n                if (atlasInfo) {\n                    // we've already computed the bb and tex bounds for a texture\n                    var bb = atlasInfo.bb, tex1 = atlasInfo.tex1, tex2 = atlasInfo.tex2;\n                    // wrapped textures need separate matrix for each part\n                    var ratio = tex1.w / (tex1.w + tex2.w);\n                    if (!first) {\n                        // first = true means its the first part of the wrapped texture\n                        ratio = 1 - ratio;\n                    }\n                    var adjBB = this._getAdjustedBB(bb, padding, first, ratio);\n                    this._applyTransformMatrix(matrix, adjBB, opts, ele);\n                } else {\n                    // we don't have a texture, or we want to avoid creating a texture for simple shapes\n                    var _bb = opts.getBoundingBox(ele);\n                    var _adjBB = this._getAdjustedBB(_bb, padding, true, 1);\n                    this._applyTransformMatrix(matrix, _adjBB, opts, ele);\n                }\n            }\n        },\n        {\n            key: \"_applyTransformMatrix\",\n            value: function _applyTransformMatrix(matrix, adjBB, opts, ele) {\n                var x, y;\n                identity(matrix);\n                var theta = opts.getRotation ? opts.getRotation(ele) : 0;\n                if (theta !== 0) {\n                    var _opts$getRotationPoin = opts.getRotationPoint(ele), sx = _opts$getRotationPoin.x, sy = _opts$getRotationPoin.y;\n                    translate(matrix, matrix, [\n                        sx,\n                        sy\n                    ]);\n                    rotate(matrix, matrix, theta);\n                    var offset = opts.getRotationOffset(ele);\n                    x = offset.x + (adjBB.xOffset || 0);\n                    y = offset.y + (adjBB.yOffset || 0);\n                } else {\n                    x = adjBB.x1;\n                    y = adjBB.y1;\n                }\n                translate(matrix, matrix, [\n                    x,\n                    y\n                ]);\n                scale(matrix, matrix, [\n                    adjBB.w,\n                    adjBB.h\n                ]);\n            }\n        },\n        {\n            key: \"_getAdjustedBB\",\n            value: function _getAdjustedBB(bb, padding, first, ratio) {\n                var x1 = bb.x1, y1 = bb.y1, w = bb.w, h = bb.h, yOffset = bb.yOffset;\n                if (padding) {\n                    x1 -= padding;\n                    y1 -= padding;\n                    w += 2 * padding;\n                    h += 2 * padding;\n                }\n                var xOffset = 0;\n                var adjW = w * ratio;\n                if (first && ratio < 1) {\n                    w = adjW;\n                } else if (!first && ratio < 1) {\n                    xOffset = w - adjW;\n                    x1 += xOffset;\n                    w = adjW;\n                }\n                return {\n                    x1: x1,\n                    y1: y1,\n                    w: w,\n                    h: h,\n                    xOffset: xOffset,\n                    yOffset: yOffset\n                };\n            }\n        },\n        {\n            key: \"drawPickingRectangle\",\n            value: function drawPickingRectangle(ele, eleIndex, type) {\n                var opts = this.atlasManager.getRenderTypeOpts(type);\n                var instance = this.instanceCount;\n                this.vertTypeBuffer.getView(instance)[0] = RECTANGLE;\n                var indexView = this.indexBuffer.getView(instance);\n                indexToVec4(eleIndex, indexView);\n                var colorView = this.colorBuffer.getView(instance);\n                toWebGLColor([\n                    0,\n                    0,\n                    0\n                ], 1, colorView); // opaque, so entire label BB is clickable\n                var matrixView = this.transformBuffer.getMatrixView(instance);\n                this.setTransformMatrix(ele, matrixView, opts);\n                this.simpleCount++;\n                this.instanceCount++;\n                if (this.instanceCount >= this.maxInstances) {\n                    this.endBatch();\n                }\n            }\n        },\n        {\n            key: \"drawNode\",\n            value: function drawNode(node, eleIndex, type) {\n                var opts = this.simpleShapeOptions.get(type);\n                if (!this._isVisible(node, opts)) {\n                    return;\n                }\n                var props = opts.shapeProps;\n                // Check if we have to use a texture\n                var vertType = this._getVertTypeForShape(node, props.shape);\n                if (vertType === undefined || opts.isSimple && !opts.isSimple(node)) {\n                    this.drawTexture(node, eleIndex, type);\n                    return;\n                }\n                // Render a \"simple shape\" using SDF (signed distance fields)\n                var instance = this.instanceCount;\n                this.vertTypeBuffer.getView(instance)[0] = vertType;\n                if (vertType === ROUND_RECTANGLE || vertType === BOTTOM_ROUND_RECTANGLE) {\n                    // get corner radius\n                    var bb = opts.getBoundingBox(node);\n                    var radius = this._getCornerRadius(node, props.radius, bb);\n                    var radiusView = this.cornerRadiusBuffer.getView(instance);\n                    radiusView[0] = radius; // top-right\n                    radiusView[1] = radius; // bottom-right\n                    radiusView[2] = radius; // top-left\n                    radiusView[3] = radius; // bottom-left\n                    if (vertType === BOTTOM_ROUND_RECTANGLE) {\n                        radiusView[0] = 0;\n                        radiusView[2] = 0;\n                    }\n                }\n                var indexView = this.indexBuffer.getView(instance);\n                indexToVec4(eleIndex, indexView);\n                var color = node.pstyle(props.color).value;\n                var opacity = node.pstyle(props.opacity).value;\n                var colorView = this.colorBuffer.getView(instance);\n                toWebGLColor(color, opacity, colorView);\n                var lineWidthView = this.lineWidthBuffer.getView(instance); // reuse edge line width attribute for node border\n                lineWidthView[0] = 0;\n                lineWidthView[1] = 0;\n                if (props.border) {\n                    var borderWidth = node.pstyle('border-width').value;\n                    if (borderWidth > 0) {\n                        var borderColor = node.pstyle('border-color').value;\n                        var borderOpacity = node.pstyle('border-opacity').value;\n                        var borderColorView = this.borderColorBuffer.getView(instance);\n                        toWebGLColor(borderColor, borderOpacity, borderColorView);\n                        // SDF distance is negative inside the shape and positive outside\n                        var borderPos = node.pstyle('border-position').value;\n                        if (borderPos === 'inside') {\n                            lineWidthView[0] = 0;\n                            lineWidthView[1] = -borderWidth;\n                        } else if (borderPos === 'outside') {\n                            lineWidthView[0] = borderWidth;\n                            lineWidthView[1] = 0;\n                        } else {\n                            // 'center'\n                            var halfWidth = borderWidth / 2;\n                            lineWidthView[0] = halfWidth;\n                            lineWidthView[1] = -halfWidth;\n                        }\n                    }\n                }\n                var matrixView = this.transformBuffer.getMatrixView(instance);\n                this.setTransformMatrix(node, matrixView, opts);\n                this.simpleCount++;\n                this.instanceCount++;\n                if (this.instanceCount >= this.maxInstances) {\n                    this.endBatch();\n                }\n            }\n        },\n        {\n            key: \"_getVertTypeForShape\",\n            value: function _getVertTypeForShape(node, shapeProp) {\n                var shape = node.pstyle(shapeProp).value;\n                switch(shape){\n                    case 'rectangle':\n                        return RECTANGLE;\n                    case 'ellipse':\n                        return ELLIPSE;\n                    case 'roundrectangle':\n                    case 'round-rectangle':\n                        return ROUND_RECTANGLE;\n                    case 'bottom-round-rectangle':\n                        return BOTTOM_ROUND_RECTANGLE;\n                    default:\n                        return undefined;\n                }\n            }\n        },\n        {\n            key: \"_getCornerRadius\",\n            value: function _getCornerRadius(node, radiusProp, _ref2) {\n                var w = _ref2.w, h = _ref2.h;\n                // see CRp.drawRoundRectanglePath\n                if (node.pstyle(radiusProp).value === 'auto') {\n                    return getRoundRectangleRadius(w, h);\n                } else {\n                    var radius = node.pstyle(radiusProp).pfValue;\n                    var halfWidth = w / 2;\n                    var halfHeight = h / 2;\n                    return Math.min(radius, halfHeight, halfWidth);\n                }\n            }\n        },\n        {\n            key: \"drawEdgeArrow\",\n            value: function drawEdgeArrow(edge, eleIndex, prefix) {\n                if (!edge.visible()) {\n                    return;\n                }\n                // Edge points and arrow angles etc are calculated by the base renderer and cached in the rscratch object.\n                var rs = edge._private.rscratch;\n                var x, y, angle;\n                if (prefix === 'source') {\n                    x = rs.arrowStartX;\n                    y = rs.arrowStartY;\n                    angle = rs.srcArrowAngle;\n                } else {\n                    x = rs.arrowEndX;\n                    y = rs.arrowEndY;\n                    angle = rs.tgtArrowAngle;\n                }\n                // taken from CRp.drawArrowhead\n                if (isNaN(x) || x == null || isNaN(y) || y == null || isNaN(angle) || angle == null) {\n                    return;\n                }\n                // check shape after the x/y check because pstyle() is a bit slow\n                var arrowShape = edge.pstyle(prefix + '-arrow-shape').value;\n                if (arrowShape === 'none') {\n                    return;\n                }\n                var color = edge.pstyle(prefix + '-arrow-color').value;\n                var baseOpacity = edge.pstyle('opacity').value;\n                var lineOpacity = edge.pstyle('line-opacity').value;\n                var opacity = baseOpacity * lineOpacity;\n                var lineWidth = edge.pstyle('width').pfValue;\n                var scale$1 = edge.pstyle('arrow-scale').value;\n                var size = this.r.getArrowWidth(lineWidth, scale$1);\n                var instance = this.instanceCount;\n                var transform = this.transformBuffer.getMatrixView(instance);\n                identity(transform);\n                translate(transform, transform, [\n                    x,\n                    y\n                ]);\n                scale(transform, transform, [\n                    size,\n                    size\n                ]);\n                rotate(transform, transform, angle);\n                this.vertTypeBuffer.getView(instance)[0] = EDGE_ARROW;\n                var indexView = this.indexBuffer.getView(instance);\n                indexToVec4(eleIndex, indexView);\n                var colorView = this.colorBuffer.getView(instance);\n                toWebGLColor(color, opacity, colorView);\n                this.instanceCount++;\n                if (this.instanceCount >= this.maxInstances) {\n                    this.endBatch();\n                }\n            }\n        },\n        {\n            key: \"drawEdgeLine\",\n            value: function drawEdgeLine(edge, eleIndex) {\n                if (!edge.visible()) {\n                    return;\n                }\n                var points = this._getEdgePoints(edge);\n                if (!points) {\n                    return;\n                }\n                // line style\n                var baseOpacity = edge.pstyle('opacity').value;\n                var lineOpacity = edge.pstyle('line-opacity').value;\n                var width = edge.pstyle('width').pfValue;\n                var color = edge.pstyle('line-color').value;\n                var opacity = baseOpacity * lineOpacity;\n                if (points.length / 2 + this.instanceCount > this.maxInstances) {\n                    this.endBatch();\n                }\n                if (points.length == 4) {\n                    // straight line\n                    var instance = this.instanceCount;\n                    this.vertTypeBuffer.getView(instance)[0] = EDGE_STRAIGHT;\n                    var indexView = this.indexBuffer.getView(instance);\n                    indexToVec4(eleIndex, indexView);\n                    var colorView = this.colorBuffer.getView(instance);\n                    toWebGLColor(color, opacity, colorView);\n                    var lineWidthBuffer = this.lineWidthBuffer.getView(instance);\n                    lineWidthBuffer[0] = width;\n                    var sourceTargetView = this.pointAPointBBuffer.getView(instance);\n                    sourceTargetView[0] = points[0]; // source x\n                    sourceTargetView[1] = points[1]; // source y\n                    sourceTargetView[2] = points[2]; // target x\n                    sourceTargetView[3] = points[3]; // target y\n                    this.instanceCount++;\n                    if (this.instanceCount >= this.maxInstances) {\n                        this.endBatch();\n                    }\n                } else {\n                    // curved line\n                    for(var i = 0; i < points.length - 2; i += 2){\n                        var _instance = this.instanceCount;\n                        this.vertTypeBuffer.getView(_instance)[0] = EDGE_CURVE_SEGMENT;\n                        var _indexView = this.indexBuffer.getView(_instance);\n                        indexToVec4(eleIndex, _indexView);\n                        var _colorView = this.colorBuffer.getView(_instance);\n                        toWebGLColor(color, opacity, _colorView);\n                        var _lineWidthBuffer = this.lineWidthBuffer.getView(_instance);\n                        _lineWidthBuffer[0] = width;\n                        var pAx = points[i - 2], pAy = points[i - 1];\n                        var pBx = points[i], pBy = points[i + 1];\n                        var pCx = points[i + 2], pCy = points[i + 3];\n                        var pDx = points[i + 4], pDy = points[i + 5];\n                        // make phantom points for the first and last segments\n                        // TODO adding 0.001 to avoid division by zero in the shader (I think), need a better solution\n                        if (i == 0) {\n                            pAx = 2 * pBx - pCx + 0.001;\n                            pAy = 2 * pBy - pCy + 0.001;\n                        }\n                        if (i == points.length - 4) {\n                            pDx = 2 * pCx - pBx + 0.001;\n                            pDy = 2 * pCy - pBy + 0.001;\n                        }\n                        var pointABView = this.pointAPointBBuffer.getView(_instance);\n                        pointABView[0] = pAx;\n                        pointABView[1] = pAy;\n                        pointABView[2] = pBx;\n                        pointABView[3] = pBy;\n                        var pointCDView = this.pointCPointDBuffer.getView(_instance);\n                        pointCDView[0] = pCx;\n                        pointCDView[1] = pCy;\n                        pointCDView[2] = pDx;\n                        pointCDView[3] = pDy;\n                        this.instanceCount++;\n                        if (this.instanceCount >= this.maxInstances) {\n                            this.endBatch();\n                        }\n                    }\n                }\n            }\n        },\n        {\n            key: \"_isValidEdge\",\n            value: function _isValidEdge(edge) {\n                var rs = edge._private.rscratch;\n                if (rs.badLine || rs.allpts == null || isNaN(rs.allpts[0])) {\n                    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n                    return false;\n                }\n                return true;\n            }\n        },\n        {\n            key: \"_getEdgePoints\",\n            value: function _getEdgePoints(edge) {\n                var rs = edge._private.rscratch;\n                // if bezier ctrl pts can not be calculated, then die\n                if (!this._isValidEdge(edge)) {\n                    // isNaN in case edge is impossible and browser bugs (e.g. safari)\n                    return;\n                }\n                var controlPoints = rs.allpts;\n                if (controlPoints.length == 4) {\n                    return controlPoints;\n                }\n                var numSegments = this._getNumSegments(edge);\n                return this._getCurveSegmentPoints(controlPoints, numSegments);\n            }\n        },\n        {\n            key: \"_getNumSegments\",\n            value: function _getNumSegments(edge) {\n                // TODO Need a heuristic that decides how many segments to use. Factors to consider:\n                // - edge width/length\n                // - edge curvature (the more the curvature, the more segments)\n                // - zoom level (more segments when zoomed in)\n                // - number of visible edges (more segments when there are fewer edges)\n                // - performance (fewer segments when performance is a concern)\n                // - user configurable option(s)\n                // note: number of segments must be less than the max number of instances\n                // note: segments don't need to be evenly spaced out, it might make sense to have shorter segments nearer to the control points\n                var numSegments = 15;\n                return Math.min(Math.max(numSegments, 5), this.maxInstances);\n            }\n        },\n        {\n            key: \"_getCurveSegmentPoints\",\n            value: function _getCurveSegmentPoints(controlPoints, segments) {\n                if (controlPoints.length == 4) {\n                    return controlPoints; // straight line\n                }\n                var curvePoints = Array((segments + 1) * 2);\n                for(var i = 0; i <= segments; i++){\n                    // the first and last points are the same as the first and last control points\n                    if (i == 0) {\n                        curvePoints[0] = controlPoints[0];\n                        curvePoints[1] = controlPoints[1];\n                    } else if (i == segments) {\n                        curvePoints[i * 2] = controlPoints[controlPoints.length - 2];\n                        curvePoints[i * 2 + 1] = controlPoints[controlPoints.length - 1];\n                    } else {\n                        var t = i / segments; // segments have equal length, its not strictly necessary to do it this way\n                        // pass in curvePoints to set the values in the array directly\n                        this._setCurvePoint(controlPoints, t, curvePoints, i * 2);\n                    }\n                }\n                return curvePoints;\n            }\n        },\n        {\n            key: \"_setCurvePoint\",\n            value: function _setCurvePoint(points, t, curvePoints, cpi) {\n                if (points.length <= 2) {\n                    curvePoints[cpi] = points[0];\n                    curvePoints[cpi + 1] = points[1];\n                } else {\n                    var newpoints = Array(points.length - 2);\n                    for(var i = 0; i < newpoints.length; i += 2){\n                        var x = (1 - t) * points[i] + t * points[i + 2];\n                        var y = (1 - t) * points[i + 1] + t * points[i + 3];\n                        newpoints[i] = x;\n                        newpoints[i + 1] = y;\n                    }\n                    return this._setCurvePoint(newpoints, t, curvePoints, cpi);\n                }\n            }\n        },\n        {\n            key: \"endBatch\",\n            value: function endBatch() {\n                var gl = this.gl, vao = this.vao, vertexCount = this.vertexCount, count = this.instanceCount;\n                if (count === 0) return;\n                var program = this.renderTarget.picking ? this.pickingProgram : this.program;\n                gl.useProgram(program);\n                gl.bindVertexArray(vao);\n                // buffer the attribute data\n                var _iterator2 = _createForOfIteratorHelper(this.buffers), _step2;\n                try {\n                    for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                        var buffer = _step2.value;\n                        buffer.bufferSubData(count);\n                    }\n                } catch (err) {\n                    _iterator2.e(err);\n                } finally{\n                    _iterator2.f();\n                }\n                var atlases = this.batchManager.getAtlases();\n                // must buffer before activating texture units\n                for(var i = 0; i < atlases.length; i++){\n                    atlases[i].bufferIfNeeded(gl);\n                }\n                // Activate all the texture units that we need\n                for(var _i2 = 0; _i2 < atlases.length; _i2++){\n                    gl.activeTexture(gl.TEXTURE0 + _i2);\n                    gl.bindTexture(gl.TEXTURE_2D, atlases[_i2].texture);\n                    gl.uniform1i(program.uTextures[_i2], _i2);\n                }\n                // Set the uniforms\n                gl.uniform1f(program.uZoom, getEffectiveZoom(this.r));\n                gl.uniformMatrix3fv(program.uPanZoomMatrix, false, this.panZoomMatrix);\n                gl.uniform1i(program.uAtlasSize, this.batchManager.getAtlasSize());\n                // set background color, needed for edge arrow color blending\n                var webglBgColor = toWebGLColor(this.bgColor, 1);\n                gl.uniform4fv(program.uBGColor, webglBgColor);\n                // draw!\n                gl.drawArraysInstanced(gl.TRIANGLES, 0, vertexCount, count);\n                gl.bindVertexArray(null);\n                gl.bindTexture(gl.TEXTURE_2D, null); // TODO is this right when having multiple texture units?\n                if (this.debug) {\n                    this.batchDebugInfo.push({\n                        count: count,\n                        // instance count\n                        atlasCount: atlases.length\n                    });\n                }\n                // start the next batch, even if not needed\n                this.startBatch();\n            }\n        },\n        {\n            key: \"getDebugInfo\",\n            value: function getDebugInfo() {\n                var atlasInfo = this.atlasManager.getDebugInfo();\n                var totalAtlases = atlasInfo.reduce(function(count, info) {\n                    return count + info.atlasCount;\n                }, 0);\n                var batchInfo = this.batchDebugInfo;\n                var totalInstances = batchInfo.reduce(function(count, info) {\n                    return count + info.count;\n                }, 0);\n                return {\n                    atlasInfo: atlasInfo,\n                    totalAtlases: totalAtlases,\n                    wrappedCount: this.wrappedCount,\n                    simpleCount: this.simpleCount,\n                    batchCount: batchInfo.length,\n                    batchInfo: batchInfo,\n                    totalInstances: totalInstances\n                };\n            }\n        }\n    ]);\n}();\nvar CRp$4 = {};\n/**\n * Initialize the WebGL rendering mode after the Canvas renderer has been initialized.\n */ CRp$4.initWebgl = function(opts, fns) {\n    var r = this;\n    var gl = r.data.contexts[r.WEBGL];\n    // Set defaults and limits for configuration options.\n    opts.bgColor = getBGColor(r);\n    opts.webglTexSize = Math.min(opts.webglTexSize, gl.getParameter(gl.MAX_TEXTURE_SIZE));\n    opts.webglTexRows = Math.min(opts.webglTexRows, 54);\n    opts.webglTexRowsNodes = Math.min(opts.webglTexRowsNodes, 54);\n    opts.webglBatchSize = Math.min(opts.webglBatchSize, 16384);\n    opts.webglTexPerBatch = Math.min(opts.webglTexPerBatch, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));\n    // Turn debug mode on or off.\n    r.webglDebug = opts.webglDebug;\n    r.webglDebugShowAtlases = opts.webglDebugShowAtlases;\n    // Create offscreen framebuffer that stores the results when RENDER_TARGET.PICKING is enabled.\n    // This is used to store the topmost element z-index for each pixel, which is used to tell whats under the mouse cursor point.\n    r.pickingFrameBuffer = createPickingFrameBuffer(gl);\n    r.pickingFrameBuffer.needsDraw = true;\n    // Create an ElementDrawingWebGL instance wich is used to do the actual WebGL rendering.\n    // This instance needs to be configured to draw various types of elements.\n    r.drawing = new ElementDrawingWebGL(r, gl, opts);\n    // Some functions that are used to configure ElementDrawingWebGL\n    var getLabelRotation = function getLabelRotation(prop) {\n        return function(ele) {\n            return r.getTextAngle(ele, prop);\n        };\n    };\n    var isLabelVisible = function isLabelVisible(prop) {\n        return function(ele) {\n            var label = ele.pstyle(prop);\n            return label && label.value;\n        };\n    };\n    var isLayerVisible = function isLayerVisible(prefix) {\n        return function(node) {\n            // prefix is 'overlay' or 'underlay'\n            return node.pstyle(\"\".concat(prefix, \"-opacity\")).value > 0;\n        };\n    };\n    var getTexPickingMode = function getTexPickingMode(ele) {\n        // tells when a label should be clickable\n        var enabled = ele.pstyle('text-events').strValue === 'yes';\n        return enabled ? TEX_PICKING_MODE.USE_BB : TEX_PICKING_MODE.IGNORE;\n    };\n    var getBBForSimpleShape = function getBBForSimpleShape(node) {\n        // \"simple\" shapes need their BB to include border and padding\n        var _node$position = node.position(), x = _node$position.x, y = _node$position.y;\n        var w = node.outerWidth(); // includes border and padding\n        var h = node.outerHeight();\n        return {\n            w: w,\n            h: h,\n            x1: x - w / 2,\n            y1: y - h / 2\n        };\n    };\n    // An AtlasCollection is a collection of Atlases that have the same configuraiton options.\n    // Create one for node bodies and one for all types of labels.\n    r.drawing.addAtlasCollection('node', {\n        texRows: opts.webglTexRowsNodes\n    });\n    r.drawing.addAtlasCollection('label', {\n        texRows: opts.webglTexRows\n    });\n    // Configure the different types of elements that can be rendered.\n    // Node bodies can be rendered as textures or as \"simple shapes\". \n    // Simple shapes are preferred because they do not use texture memory.\n    // Textures are required if the node body uses complex styles. \n    r.drawing.addTextureAtlasRenderType('node-body', {\n        collection: 'node',\n        getKey: fns.getStyleKey,\n        getBoundingBox: fns.getElementBox,\n        drawElement: fns.drawElement\n    });\n    r.drawing.addSimpleShapeRenderType('node-body', {\n        getBoundingBox: getBBForSimpleShape,\n        isSimple: isSimpleShape,\n        shapeProps: {\n            shape: 'shape',\n            color: 'background-color',\n            opacity: 'background-opacity',\n            radius: 'corner-radius',\n            border: true\n        }\n    });\n    r.drawing.addSimpleShapeRenderType('node-overlay', {\n        getBoundingBox: getBBForSimpleShape,\n        isVisible: isLayerVisible('overlay'),\n        shapeProps: {\n            shape: 'overlay-shape',\n            color: 'overlay-color',\n            opacity: 'overlay-opacity',\n            padding: 'overlay-padding',\n            radius: 'overlay-corner-radius'\n        }\n    });\n    r.drawing.addSimpleShapeRenderType('node-underlay', {\n        getBoundingBox: getBBForSimpleShape,\n        isVisible: isLayerVisible('underlay'),\n        shapeProps: {\n            shape: 'underlay-shape',\n            color: 'underlay-color',\n            opacity: 'underlay-opacity',\n            padding: 'underlay-padding',\n            radius: 'underlay-corner-radius'\n        }\n    });\n    r.drawing.addTextureAtlasRenderType('label', {\n        // node label or edge mid label\n        collection: 'label',\n        getTexPickingMode: getTexPickingMode,\n        getKey: getStyleKeysForLabel(fns.getLabelKey, null),\n        getBoundingBox: getBoundingBoxForLabel(fns.getLabelBox, null),\n        drawClipped: true,\n        drawElement: fns.drawLabel,\n        getRotation: getLabelRotation(null),\n        getRotationPoint: fns.getLabelRotationPoint,\n        getRotationOffset: fns.getLabelRotationOffset,\n        isVisible: isLabelVisible('label')\n    });\n    r.drawing.addTextureAtlasRenderType('edge-source-label', {\n        collection: 'label',\n        getTexPickingMode: getTexPickingMode,\n        getKey: getStyleKeysForLabel(fns.getSourceLabelKey, 'source'),\n        getBoundingBox: getBoundingBoxForLabel(fns.getSourceLabelBox, 'source'),\n        drawClipped: true,\n        drawElement: fns.drawSourceLabel,\n        getRotation: getLabelRotation('source'),\n        getRotationPoint: fns.getSourceLabelRotationPoint,\n        getRotationOffset: fns.getSourceLabelRotationOffset,\n        isVisible: isLabelVisible('source-label')\n    });\n    r.drawing.addTextureAtlasRenderType('edge-target-label', {\n        collection: 'label',\n        getTexPickingMode: getTexPickingMode,\n        getKey: getStyleKeysForLabel(fns.getTargetLabelKey, 'target'),\n        getBoundingBox: getBoundingBoxForLabel(fns.getTargetLabelBox, 'target'),\n        drawClipped: true,\n        drawElement: fns.drawTargetLabel,\n        getRotation: getLabelRotation('target'),\n        getRotationPoint: fns.getTargetLabelRotationPoint,\n        getRotationOffset: fns.getTargetLabelRotationOffset,\n        isVisible: isLabelVisible('target-label')\n    });\n    // Very simplistic way of triggering garbage collection, just use a timer.\n    var setGCFlag = debounce(function() {\n        console.log('garbage collect flag set');\n        r.data.gc = true;\n    }, 10000);\n    // Event listener checks if style keys are no longer in use.\n    r.onUpdateEleCalcs(function(willDraw, eles) {\n        var gcNeeded = false;\n        if (eles && eles.length > 0) {\n            gcNeeded |= r.drawing.invalidate(eles);\n        }\n        if (gcNeeded) {\n            setGCFlag();\n        }\n    });\n    // \"Override\" certain functions in canvas and base renderer\n    overrideCanvasRendererFunctions(r);\n};\nfunction getBGColor(r) {\n    var container = r.cy.container();\n    var cssColor = container && container.style && container.style.backgroundColor || 'white';\n    return color2tuple(cssColor);\n}\nfunction getLabelLines(ele, prefix) {\n    var rs = ele._private.rscratch;\n    return getPrefixedProperty(rs, 'labelWrapCachedLines', prefix) || [];\n}\n/** \n * Handle multi-line labels by rendering each line as a seperate texture.\n * That means each line needs its own style key.\n */ var getStyleKeysForLabel = function getStyleKeysForLabel(getKey, prefix) {\n    return function(ele) {\n        var key = getKey(ele);\n        var lines = getLabelLines(ele, prefix);\n        if (lines.length > 1) {\n            return lines.map(function(line, index) {\n                return \"\".concat(key, \"_\").concat(index);\n            });\n        }\n        return key;\n    };\n};\n/**\n * Need to create a separate bounding box for each line of a multi-line label.\n * Note that 'drawClipped: true' should be used with this.\n */ var getBoundingBoxForLabel = function getBoundingBoxForLabel(getBoundingBox, prefix) {\n    return function(ele, styleKey) {\n        var bb = getBoundingBox(ele);\n        if (typeof styleKey === 'string') {\n            var ui = styleKey.indexOf('_');\n            if (ui > 0) {\n                var lineIndex = Number(styleKey.substring(ui + 1));\n                var lines = getLabelLines(ele, prefix);\n                // Adjust the height and Y coordinate for one line of the label.\n                var h = bb.h / lines.length;\n                var yOffset = h * lineIndex;\n                var y1 = bb.y1 + yOffset;\n                // the yOffset is needed when rotating the label\n                return {\n                    x1: bb.x1,\n                    w: bb.w,\n                    y1: y1,\n                    h: h,\n                    yOffset: yOffset\n                };\n            }\n        }\n        return bb;\n    };\n};\n/**\n * Plug into the canvas renderer by dynamically overriding some of its functions.\n * This requires minimal changes to the canvas rendrerer.\n */ function overrideCanvasRendererFunctions(r) {\n    {\n        // Override the render function to call the webgl render function if the zoom level is appropriate\n        var renderCanvas = r.render;\n        r.render = function(options) {\n            options = options || {};\n            var cy = r.cy;\n            if (r.webgl) {\n                // If the zoom level is greater than the max zoom level, then disable webgl and switch back to \n                // the canvas renderer.\n                if (cy.zoom() > maxZoom$1) {\n                    clearWebgl(r);\n                    renderCanvas.call(r, options);\n                } else {\n                    clearCanvas(r);\n                    renderWebgl(r, options, RENDER_TARGET.SCREEN);\n                }\n            }\n        };\n    }\n    {\n        // Override the matchCanvasSize function to update the picking frame buffer size\n        var baseFunc = r.matchCanvasSize;\n        r.matchCanvasSize = function(container) {\n            baseFunc.call(r, container);\n            r.pickingFrameBuffer.setFramebufferAttachmentSizes(r.canvasWidth, r.canvasHeight);\n            r.pickingFrameBuffer.needsDraw = true;\n        };\n    }\n    {\n        // Override function to call the webgl version for picking.\n        // Don't override r.getAllInBox() selction box picking, its not accurate enough with webgl\n        r.findNearestElements = function(x, y, interactiveElementsOnly, isTouch) {\n            // the canvas version of this function is very slow on large graphs\n            return findNearestElementsWebgl(r, x, y);\n        };\n    }\n    {\n        // need to know when the cached elements have changed so we can invalidate our caches\n        var _baseFunc = r.invalidateCachedZSortedEles;\n        r.invalidateCachedZSortedEles = function() {\n            _baseFunc.call(r);\n            r.pickingFrameBuffer.needsDraw = true;\n        };\n    }\n    {\n        // need to know when the cached elements have changed so we can invalidate our caches\n        var _baseFunc2 = r.notify;\n        r.notify = function(eventName, eles) {\n            _baseFunc2.call(r, eventName, eles);\n            if (eventName === 'viewport' || eventName === 'bounds') {\n                r.pickingFrameBuffer.needsDraw = true;\n            } else if (eventName === 'background') {\n                // background image finished loading, need to redraw\n                r.drawing.invalidate(eles, {\n                    type: 'node-body'\n                });\n            }\n        };\n    }\n}\nfunction clearWebgl(r) {\n    var gl = r.data.contexts[r.WEBGL];\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n}\nfunction clearCanvas(r) {\n    // the CRp.clearCanvas() function doesn't take the transform into account\n    var clear = function clear(context) {\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);\n        context.restore();\n    };\n    clear(r.data.contexts[r.NODE]);\n    clear(r.data.contexts[r.DRAG]);\n}\nfunction createPanZoomMatrix(r) {\n    var width = r.canvasWidth;\n    var height = r.canvasHeight;\n    var _util$getEffectivePan = getEffectivePanZoom(r), pan = _util$getEffectivePan.pan, zoom = _util$getEffectivePan.zoom;\n    var transform = create();\n    translate(transform, transform, [\n        pan.x,\n        pan.y\n    ]);\n    scale(transform, transform, [\n        zoom,\n        zoom\n    ]);\n    var projection$1 = create();\n    projection(projection$1, width, height);\n    var product = create();\n    multiply(product, projection$1, transform);\n    return product;\n}\nfunction setContextTransform(r, context) {\n    var width = r.canvasWidth;\n    var height = r.canvasHeight;\n    var _util$getEffectivePan2 = getEffectivePanZoom(r), pan = _util$getEffectivePan2.pan, zoom = _util$getEffectivePan2.zoom;\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    context.clearRect(0, 0, width, height);\n    context.translate(pan.x, pan.y);\n    context.scale(zoom, zoom);\n}\nfunction drawSelectionRectangle(r, options) {\n    r.drawSelectionRectangle(options, function(context) {\n        return setContextTransform(r, context);\n    });\n}\nfunction drawAxes(r) {\n    // for debgging\n    var context = r.data.contexts[r.NODE];\n    context.save();\n    setContextTransform(r, context);\n    context.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n    context.beginPath();\n    context.moveTo(-1e3, 0);\n    context.lineTo(1000, 0);\n    context.stroke();\n    context.beginPath();\n    context.moveTo(0, -1e3);\n    context.lineTo(0, 1000);\n    context.stroke();\n    context.restore();\n}\nfunction drawAtlases(r) {\n    // For debugging the atlases, this doesn't work for Atlases that are locked\n    var draw = function draw(drawing, name, row) {\n        var collection = drawing.atlasManager.getAtlasCollection(name);\n        var context = r.data.contexts[r.NODE];\n        var atlases = collection.atlases;\n        for(var _i = 0; _i < atlases.length; _i++){\n            var atlas = atlases[_i];\n            var canvas = atlas.canvas;\n            if (canvas) {\n                var w = canvas.width;\n                var h = canvas.height;\n                var x = w * _i;\n                var y = canvas.height * row;\n                var scale = 0.4;\n                context.save();\n                context.scale(scale, scale);\n                context.drawImage(canvas, x, y);\n                context.strokeStyle = 'black';\n                context.rect(x, y, w, h);\n                context.stroke();\n                context.restore();\n            }\n        }\n    };\n    var i = 0;\n    draw(r.drawing, 'node', i++);\n    draw(r.drawing, 'label', i++);\n}\n/**\n * Returns the z-order index of elments under or very close to the mouse cursor point.\n * Arguments are in model coordinates.\n * (x1, y1) is top left corner\n * (x2, y2) is bottom right corner (optional)\n * Returns a Set of indexes.\n */ function getPickingIndexes(r, mX1, mY1, mX2, mY2) {\n    var x, y, w, h;\n    var _util$getEffectivePan3 = getEffectivePanZoom(r), pan = _util$getEffectivePan3.pan, zoom = _util$getEffectivePan3.zoom;\n    {\n        var _util$modelToRendered = modelToRenderedPosition(r, pan, zoom, mX1, mY1), _util$modelToRendered2 = _slicedToArray(_util$modelToRendered, 2), cX1 = _util$modelToRendered2[0], cY1 = _util$modelToRendered2[1];\n        var t = 6; // should be even\n        x = cX1 - t / 2;\n        y = cY1 - t / 2;\n        w = t;\n        h = t;\n    }\n    if (w === 0 || h === 0) {\n        return [];\n    }\n    var gl = r.data.contexts[r.WEBGL];\n    gl.bindFramebuffer(gl.FRAMEBUFFER, r.pickingFrameBuffer);\n    if (r.pickingFrameBuffer.needsDraw) {\n        // Draw element z-indexes to the picking framebuffer\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        renderWebgl(r, null, RENDER_TARGET.PICKING);\n        r.pickingFrameBuffer.needsDraw = false;\n    }\n    var n = w * h; // number of pixels to read\n    var data = new Uint8Array(n * 4); // 4 bytes per pixel\n    gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, data);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    var indexes = new Set();\n    for(var i = 0; i < n; i++){\n        var pixel = data.slice(i * 4, i * 4 + 4);\n        var index = vec4ToIndex(pixel) - 1; // The framebuffer is cleared with 0s, so z-indexes are offset by 1\n        if (index >= 0) {\n            indexes.add(index);\n        }\n    }\n    return indexes;\n}\n/**\n * Cy.js: model coordinate y axis goes down\n */ function findNearestElementsWebgl(r, x, y) {\n    // model coordinates\n    var indexes = getPickingIndexes(r, x, y);\n    var eles = r.getCachedZSortedEles();\n    var node, edge;\n    var _iterator = _createForOfIteratorHelper(indexes), _step;\n    try {\n        for(_iterator.s(); !(_step = _iterator.n()).done;){\n            var index = _step.value;\n            var ele = eles[index];\n            if (!node && ele.isNode()) {\n                node = ele;\n            }\n            if (!edge && ele.isEdge()) {\n                edge = ele;\n            }\n            if (node && edge) {\n                break;\n            }\n        }\n    } catch (err) {\n        _iterator.e(err);\n    } finally{\n        _iterator.f();\n    }\n    return [\n        node,\n        edge\n    ].filter(Boolean);\n}\n/**\n * Draw one node or edge. \n */ function drawEle(r, index, ele) {\n    var drawing = r.drawing;\n    index += 1; // 0 is used to clear the background, need to offset all z-indexes by one\n    if (ele.isNode()) {\n        drawing.drawNode(ele, index, 'node-underlay');\n        drawing.drawNode(ele, index, 'node-body');\n        drawing.drawTexture(ele, index, 'label');\n        drawing.drawNode(ele, index, 'node-overlay');\n    } else {\n        drawing.drawEdgeLine(ele, index);\n        drawing.drawEdgeArrow(ele, index, 'source');\n        drawing.drawEdgeArrow(ele, index, 'target');\n        drawing.drawTexture(ele, index, 'label');\n        drawing.drawTexture(ele, index, 'edge-source-label');\n        drawing.drawTexture(ele, index, 'edge-target-label');\n    }\n}\n/**\n * Render one frame.\n */ function renderWebgl(r, options, renderTarget) {\n    var start;\n    if (r.webglDebug) {\n        start = performance.now(); // eslint-disable-line no-undef\n    }\n    var drawing = r.drawing;\n    var eleCount = 0;\n    if (renderTarget.screen) {\n        if (r.data.canvasNeedsRedraw[r.SELECT_BOX]) {\n            drawSelectionRectangle(r, options);\n        }\n    }\n    // see drawing-elements.js drawCachedElement()\n    if (r.data.canvasNeedsRedraw[r.NODE] || renderTarget.picking) {\n        var gl = r.data.contexts[r.WEBGL];\n        if (renderTarget.screen) {\n            gl.clearColor(0, 0, 0, 0); // background color\n            gl.enable(gl.BLEND); // enable alpha blending of colors\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); // webgl colors use premultiplied alpha\n        } else {\n            gl.disable(gl.BLEND); // don't blend z-order index values! they are not colors\n        }\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        var panZoomMatrix = createPanZoomMatrix(r);\n        var eles = r.getCachedZSortedEles();\n        eleCount = eles.length;\n        drawing.startFrame(panZoomMatrix, renderTarget);\n        if (renderTarget.screen) {\n            for(var i = 0; i < eles.nondrag.length; i++){\n                drawEle(r, i, eles.nondrag[i]);\n            }\n            for(var _i2 = 0; _i2 < eles.drag.length; _i2++){\n                drawEle(r, _i2, eles.drag[_i2]);\n            }\n        } else if (renderTarget.picking) {\n            for(var _i3 = 0; _i3 < eles.length; _i3++){\n                drawEle(r, _i3, eles[_i3]);\n            }\n        }\n        drawing.endFrame();\n        if (renderTarget.screen && r.webglDebugShowAtlases) {\n            drawAxes(r);\n            drawAtlases(r);\n        }\n        r.data.canvasNeedsRedraw[r.NODE] = false;\n        r.data.canvasNeedsRedraw[r.DRAG] = false;\n    }\n    if (r.webglDebug) {\n        // eslint-disable-next-line no-undef\n        var end = performance.now();\n        var compact = false;\n        var time = Math.ceil(end - start);\n        var debugInfo = drawing.getDebugInfo();\n        var report = [\n            \"\".concat(eleCount, \" elements\"),\n            \"\".concat(debugInfo.totalInstances, \" instances\"),\n            \"\".concat(debugInfo.batchCount, \" batches\"),\n            \"\".concat(debugInfo.totalAtlases, \" atlases\"),\n            \"\".concat(debugInfo.wrappedCount, \" wrapped textures\"),\n            \"\".concat(debugInfo.simpleCount, \" simple shapes\")\n        ].join(', ');\n        if (compact) {\n            console.log(\"WebGL (\".concat(renderTarget.name, \") - time \").concat(time, \"ms, \").concat(report));\n        } else {\n            console.log(\"WebGL (\".concat(renderTarget.name, \") - frame time \").concat(time, \"ms\"));\n            console.log('Totals:');\n            console.log(\"  \".concat(report));\n            console.log('Texture Atlases Used:');\n            var atlasInfo = debugInfo.atlasInfo;\n            var _iterator2 = _createForOfIteratorHelper(atlasInfo), _step2;\n            try {\n                for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                    var info = _step2.value;\n                    console.log(\"  \".concat(info.type, \": \").concat(info.keyCount, \" keys, \").concat(info.atlasCount, \" atlases\"));\n                }\n            } catch (err) {\n                _iterator2.e(err);\n            } finally{\n                _iterator2.f();\n            }\n            console.log('');\n        }\n    }\n    if (r.data.gc) {\n        console.log('Garbage Collect!');\n        r.data.gc = false;\n        drawing.gc();\n    }\n}\nvar CRp$3 = {};\n// @O Polygon drawing\nCRp$3.drawPolygonPath = function(context, x, y, width, height, points) {\n    var halfW = width / 2;\n    var halfH = height / 2;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.moveTo(x + halfW * points[0], y + halfH * points[1]);\n    for(var i = 1; i < points.length / 2; i++){\n        context.lineTo(x + halfW * points[i * 2], y + halfH * points[i * 2 + 1]);\n    }\n    context.closePath();\n};\nCRp$3.drawRoundPolygonPath = function(context, x, y, width, height, points, corners) {\n    corners.forEach(function(corner) {\n        return drawPreparedRoundCorner(context, corner);\n    });\n    context.closePath();\n};\n// Round rectangle drawing\nCRp$3.drawRoundRectanglePath = function(context, x, y, width, height, radius) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : Math.min(radius, halfHeight, halfWidth);\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    // Start at top middle\n    context.moveTo(x, y - halfHeight);\n    // Arc from middle top to right side\n    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);\n    // Arc from right side to bottom\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    // Arc from bottom to left side\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    // Arc from left side to topBorder\n    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);\n    // Join line\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n};\nCRp$3.drawBottomRoundRectanglePath = function(context, x, y, width, height, radius) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerRadius = radius === 'auto' ? getRoundRectangleRadius(width, height) : radius;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    // Start at top middle\n    context.moveTo(x, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight);\n    context.lineTo(x + halfWidth, y);\n    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);\n    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);\n    context.lineTo(x - halfWidth, y - halfHeight);\n    context.lineTo(x, y - halfHeight);\n    context.closePath();\n};\nCRp$3.drawCutRectanglePath = function(context, x, y, width, height, points, corners) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var cornerLength = corners === 'auto' ? getCutRectangleCornerLength() : corners;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.moveTo(x - halfWidth + cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth - cornerLength, y - halfHeight);\n    context.lineTo(x + halfWidth, y - halfHeight + cornerLength);\n    context.lineTo(x + halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x + halfWidth - cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth + cornerLength, y + halfHeight);\n    context.lineTo(x - halfWidth, y + halfHeight - cornerLength);\n    context.lineTo(x - halfWidth, y - halfHeight + cornerLength);\n    context.closePath();\n};\nCRp$3.drawBarrelPath = function(context, x, y, width, height) {\n    var halfWidth = width / 2;\n    var halfHeight = height / 2;\n    var xBegin = x - halfWidth;\n    var xEnd = x + halfWidth;\n    var yBegin = y - halfHeight;\n    var yEnd = y + halfHeight;\n    var barrelCurveConstants = getBarrelCurveConstants(width, height);\n    var wOffset = barrelCurveConstants.widthOffset;\n    var hOffset = barrelCurveConstants.heightOffset;\n    var ctrlPtXOffset = barrelCurveConstants.ctrlPtOffsetPct * wOffset;\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    context.moveTo(xBegin, yBegin + hOffset);\n    context.lineTo(xBegin, yEnd - hOffset);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yEnd, xBegin + wOffset, yEnd);\n    context.lineTo(xEnd - wOffset, yEnd);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yEnd, xEnd, yEnd - hOffset);\n    context.lineTo(xEnd, yBegin + hOffset);\n    context.quadraticCurveTo(xEnd - ctrlPtXOffset, yBegin, xEnd - wOffset, yBegin);\n    context.lineTo(xBegin + wOffset, yBegin);\n    context.quadraticCurveTo(xBegin + ctrlPtXOffset, yBegin, xBegin, yBegin + hOffset);\n    context.closePath();\n};\nvar sin0 = Math.sin(0);\nvar cos0 = Math.cos(0);\nvar sin = {};\nvar cos = {};\nvar ellipseStepSize = Math.PI / 40;\nfor(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){\n    sin[i] = Math.sin(i);\n    cos[i] = Math.cos(i);\n}\nCRp$3.drawEllipsePath = function(context, centerX, centerY, width, height) {\n    if (context.beginPath) {\n        context.beginPath();\n    }\n    if (context.ellipse) {\n        context.ellipse(centerX, centerY, width / 2, height / 2, 0, 0, 2 * Math.PI);\n    } else {\n        var xPos, yPos;\n        var rw = width / 2;\n        var rh = height / 2;\n        for(var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize){\n            xPos = centerX - rw * sin[i] * sin0 + rw * cos[i] * cos0;\n            yPos = centerY + rh * cos[i] * sin0 + rh * sin[i] * cos0;\n            if (i === 0) {\n                context.moveTo(xPos, yPos);\n            } else {\n                context.lineTo(xPos, yPos);\n            }\n        }\n    }\n    context.closePath();\n};\n/* global atob, ArrayBuffer, Uint8Array, Blob */ var CRp$2 = {};\nCRp$2.createBuffer = function(w, h) {\n    var buffer = document.createElement('canvas'); // eslint-disable-line no-undef\n    buffer.width = w;\n    buffer.height = h;\n    return [\n        buffer,\n        buffer.getContext('2d')\n    ];\n};\nCRp$2.bufferCanvasImage = function(options) {\n    var cy = this.cy;\n    var eles = cy.mutableElements();\n    var bb = eles.boundingBox();\n    var ctrRect = this.findContainerClientCoords();\n    var width = options.full ? Math.ceil(bb.w) : ctrRect[2];\n    var height = options.full ? Math.ceil(bb.h) : ctrRect[3];\n    var specdMaxDims = number$1(options.maxWidth) || number$1(options.maxHeight);\n    var pxRatio = this.getPixelRatio();\n    var scale = 1;\n    if (options.scale !== undefined) {\n        width *= options.scale;\n        height *= options.scale;\n        scale = options.scale;\n    } else if (specdMaxDims) {\n        var maxScaleW = Infinity;\n        var maxScaleH = Infinity;\n        if (number$1(options.maxWidth)) {\n            maxScaleW = scale * options.maxWidth / width;\n        }\n        if (number$1(options.maxHeight)) {\n            maxScaleH = scale * options.maxHeight / height;\n        }\n        scale = Math.min(maxScaleW, maxScaleH);\n        width *= scale;\n        height *= scale;\n    }\n    if (!specdMaxDims) {\n        width *= pxRatio;\n        height *= pxRatio;\n        scale *= pxRatio;\n    }\n    var buffCanvas = document.createElement('canvas'); // eslint-disable-line no-undef\n    buffCanvas.width = width;\n    buffCanvas.height = height;\n    buffCanvas.style.width = width + 'px';\n    buffCanvas.style.height = height + 'px';\n    var buffCxt = buffCanvas.getContext('2d');\n    // Rasterize the layers, but only if container has nonzero size\n    if (width > 0 && height > 0) {\n        buffCxt.clearRect(0, 0, width, height);\n        buffCxt.globalCompositeOperation = 'source-over';\n        var zsortedEles = this.getCachedZSortedEles();\n        if (options.full) {\n            // draw the full bounds of the graph\n            buffCxt.translate(-bb.x1 * scale, -bb.y1 * scale);\n            buffCxt.scale(scale, scale);\n            this.drawElements(buffCxt, zsortedEles);\n            buffCxt.scale(1 / scale, 1 / scale);\n            buffCxt.translate(bb.x1 * scale, bb.y1 * scale);\n        } else {\n            // draw the current view\n            var pan = cy.pan();\n            var translation = {\n                x: pan.x * scale,\n                y: pan.y * scale\n            };\n            scale *= cy.zoom();\n            buffCxt.translate(translation.x, translation.y);\n            buffCxt.scale(scale, scale);\n            this.drawElements(buffCxt, zsortedEles);\n            buffCxt.scale(1 / scale, 1 / scale);\n            buffCxt.translate(-translation.x, -translation.y);\n        }\n        // need to fill bg at end like this in order to fill cleared transparent pixels in jpgs\n        if (options.bg) {\n            buffCxt.globalCompositeOperation = 'destination-over';\n            buffCxt.fillStyle = options.bg;\n            buffCxt.rect(0, 0, width, height);\n            buffCxt.fill();\n        }\n    }\n    return buffCanvas;\n};\nfunction b64ToBlob(b64, mimeType) {\n    var bytes = atob(b64);\n    var buff = new ArrayBuffer(bytes.length);\n    var buffUint8 = new Uint8Array(buff);\n    for(var i = 0; i < bytes.length; i++){\n        buffUint8[i] = bytes.charCodeAt(i);\n    }\n    return new Blob([\n        buff\n    ], {\n        type: mimeType\n    });\n}\nfunction b64UriToB64(b64uri) {\n    var i = b64uri.indexOf(',');\n    return b64uri.substr(i + 1);\n}\nfunction output(options, canvas, mimeType) {\n    var getB64Uri = function getB64Uri() {\n        return canvas.toDataURL(mimeType, options.quality);\n    };\n    switch(options.output){\n        case 'blob-promise':\n            return new Promise$1(function(resolve, reject) {\n                try {\n                    canvas.toBlob(function(blob) {\n                        if (blob != null) {\n                            resolve(blob);\n                        } else {\n                            reject(new Error('`canvas.toBlob()` sent a null value in its callback'));\n                        }\n                    }, mimeType, options.quality);\n                } catch (err) {\n                    reject(err);\n                }\n            });\n        case 'blob':\n            return b64ToBlob(b64UriToB64(getB64Uri()), mimeType);\n        case 'base64':\n            return b64UriToB64(getB64Uri());\n        case 'base64uri':\n        default:\n            return getB64Uri();\n    }\n}\nCRp$2.png = function(options) {\n    return output(options, this.bufferCanvasImage(options), 'image/png');\n};\nCRp$2.jpg = function(options) {\n    return output(options, this.bufferCanvasImage(options), 'image/jpeg');\n};\nvar CRp$1 = {};\nCRp$1.nodeShapeImpl = function(name, context, centerX, centerY, width, height, points, corners) {\n    switch(name){\n        case 'ellipse':\n            return this.drawEllipsePath(context, centerX, centerY, width, height);\n        case 'polygon':\n            return this.drawPolygonPath(context, centerX, centerY, width, height, points);\n        case 'round-polygon':\n            return this.drawRoundPolygonPath(context, centerX, centerY, width, height, points, corners);\n        case 'roundrectangle':\n        case 'round-rectangle':\n            return this.drawRoundRectanglePath(context, centerX, centerY, width, height, corners);\n        case 'cutrectangle':\n        case 'cut-rectangle':\n            return this.drawCutRectanglePath(context, centerX, centerY, width, height, points, corners);\n        case 'bottomroundrectangle':\n        case 'bottom-round-rectangle':\n            return this.drawBottomRoundRectanglePath(context, centerX, centerY, width, height, corners);\n        case 'barrel':\n            return this.drawBarrelPath(context, centerX, centerY, width, height);\n    }\n};\nvar CR = CanvasRenderer;\nvar CRp = CanvasRenderer.prototype;\nCRp.CANVAS_LAYERS = 3;\n//\nCRp.SELECT_BOX = 0;\nCRp.DRAG = 1;\nCRp.NODE = 2;\nCRp.WEBGL = 3;\nCRp.CANVAS_TYPES = [\n    '2d',\n    '2d',\n    '2d',\n    'webgl2'\n];\nCRp.BUFFER_COUNT = 3;\n//\nCRp.TEXTURE_BUFFER = 0;\nCRp.MOTIONBLUR_BUFFER_NODE = 1;\nCRp.MOTIONBLUR_BUFFER_DRAG = 2;\nfunction CanvasRenderer(options) {\n    var r = this;\n    var containerWindow = r.cy.window();\n    var document1 = containerWindow.document;\n    if (options.webgl) {\n        CRp.CANVAS_LAYERS = r.CANVAS_LAYERS = 4;\n        console.log('webgl rendering enabled');\n    }\n    r.data = {\n        canvases: new Array(CRp.CANVAS_LAYERS),\n        contexts: new Array(CRp.CANVAS_LAYERS),\n        canvasNeedsRedraw: new Array(CRp.CANVAS_LAYERS),\n        bufferCanvases: new Array(CRp.BUFFER_COUNT),\n        bufferContexts: new Array(CRp.CANVAS_LAYERS)\n    };\n    var tapHlOffAttr = '-webkit-tap-highlight-color';\n    var tapHlOffStyle = 'rgba(0,0,0,0)';\n    r.data.canvasContainer = document1.createElement('div'); // eslint-disable-line no-undef\n    var containerStyle = r.data.canvasContainer.style;\n    r.data.canvasContainer.style[tapHlOffAttr] = tapHlOffStyle;\n    containerStyle.position = 'relative';\n    containerStyle.zIndex = '0';\n    containerStyle.overflow = 'hidden';\n    var container = options.cy.container();\n    container.appendChild(r.data.canvasContainer);\n    container.style[tapHlOffAttr] = tapHlOffStyle;\n    var styleMap = {\n        '-webkit-user-select': 'none',\n        '-moz-user-select': '-moz-none',\n        'user-select': 'none',\n        '-webkit-tap-highlight-color': 'rgba(0,0,0,0)',\n        'outline-style': 'none'\n    };\n    if (ms()) {\n        styleMap['-ms-touch-action'] = 'none';\n        styleMap['touch-action'] = 'none';\n    }\n    for(var i = 0; i < CRp.CANVAS_LAYERS; i++){\n        var canvas = r.data.canvases[i] = document1.createElement('canvas'); // eslint-disable-line no-undef\n        var type = CRp.CANVAS_TYPES[i];\n        r.data.contexts[i] = canvas.getContext(type);\n        if (!r.data.contexts[i]) {\n            error('Could not create canvas of type ' + type);\n        }\n        Object.keys(styleMap).forEach(function(k) {\n            canvas.style[k] = styleMap[k];\n        });\n        canvas.style.position = 'absolute';\n        canvas.setAttribute('data-id', 'layer' + i);\n        canvas.style.zIndex = String(CRp.CANVAS_LAYERS - i);\n        r.data.canvasContainer.appendChild(canvas);\n        r.data.canvasNeedsRedraw[i] = false;\n    }\n    r.data.topCanvas = r.data.canvases[0];\n    r.data.canvases[CRp.NODE].setAttribute('data-id', 'layer' + CRp.NODE + '-node');\n    r.data.canvases[CRp.SELECT_BOX].setAttribute('data-id', 'layer' + CRp.SELECT_BOX + '-selectbox');\n    r.data.canvases[CRp.DRAG].setAttribute('data-id', 'layer' + CRp.DRAG + '-drag');\n    if (r.data.canvases[CRp.WEBGL]) {\n        r.data.canvases[CRp.WEBGL].setAttribute('data-id', 'layer' + CRp.WEBGL + '-webgl');\n    }\n    for(var i = 0; i < CRp.BUFFER_COUNT; i++){\n        r.data.bufferCanvases[i] = document1.createElement('canvas'); // eslint-disable-line no-undef\n        r.data.bufferContexts[i] = r.data.bufferCanvases[i].getContext('2d');\n        r.data.bufferCanvases[i].style.position = 'absolute';\n        r.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);\n        r.data.bufferCanvases[i].style.zIndex = String(-i - 1);\n        r.data.bufferCanvases[i].style.visibility = 'hidden';\n    //r.data.canvasContainer.appendChild(r.data.bufferCanvases[i]);\n    }\n    r.pathsEnabled = true;\n    var emptyBb = makeBoundingBox();\n    var getBoxCenter = function getBoxCenter(bb) {\n        return {\n            x: (bb.x1 + bb.x2) / 2,\n            y: (bb.y1 + bb.y2) / 2\n        };\n    };\n    var getCenterOffset = function getCenterOffset(bb) {\n        return {\n            x: -bb.w / 2,\n            y: -bb.h / 2\n        };\n    };\n    var backgroundTimestampHasChanged = function backgroundTimestampHasChanged(ele) {\n        var _p = ele[0]._private;\n        var same = _p.oldBackgroundTimestamp === _p.backgroundTimestamp;\n        return !same;\n    };\n    var getStyleKey = function getStyleKey(ele) {\n        return ele[0]._private.nodeKey;\n    };\n    var getLabelKey = function getLabelKey(ele) {\n        return ele[0]._private.labelStyleKey;\n    };\n    var getSourceLabelKey = function getSourceLabelKey(ele) {\n        return ele[0]._private.sourceLabelStyleKey;\n    };\n    var getTargetLabelKey = function getTargetLabelKey(ele) {\n        return ele[0]._private.targetLabelStyleKey;\n    };\n    var drawElement = function drawElement(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElement(context, ele, bb, false, false, useEleOpacity);\n    };\n    var drawLabel = function drawLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElementText(context, ele, bb, scaledLabelShown, 'main', useEleOpacity);\n    };\n    var drawSourceLabel = function drawSourceLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElementText(context, ele, bb, scaledLabelShown, 'source', useEleOpacity);\n    };\n    var drawTargetLabel = function drawTargetLabel(context, ele, bb, scaledLabelShown, useEleOpacity) {\n        return r.drawElementText(context, ele, bb, scaledLabelShown, 'target', useEleOpacity);\n    };\n    var getElementBox = function getElementBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.bodyBounds;\n    };\n    var getLabelBox = function getLabelBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.labelBounds.main || emptyBb;\n    };\n    var getSourceLabelBox = function getSourceLabelBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.labelBounds.source || emptyBb;\n    };\n    var getTargetLabelBox = function getTargetLabelBox(ele) {\n        ele.boundingBox();\n        return ele[0]._private.labelBounds.target || emptyBb;\n    };\n    var isLabelVisibleAtScale = function isLabelVisibleAtScale(ele, scaledLabelShown) {\n        return scaledLabelShown;\n    };\n    var getElementRotationPoint = function getElementRotationPoint(ele) {\n        return getBoxCenter(getElementBox(ele));\n    };\n    var addTextMargin = function addTextMargin(prefix, pt, ele) {\n        var pre = prefix ? prefix + '-' : '';\n        return {\n            x: pt.x + ele.pstyle(pre + 'text-margin-x').pfValue,\n            y: pt.y + ele.pstyle(pre + 'text-margin-y').pfValue\n        };\n    };\n    var getRsPt = function getRsPt(ele, x, y) {\n        var rs = ele[0]._private.rscratch;\n        return {\n            x: rs[x],\n            y: rs[y]\n        };\n    };\n    var getLabelRotationPoint = function getLabelRotationPoint(ele) {\n        return addTextMargin('', getRsPt(ele, 'labelX', 'labelY'), ele);\n    };\n    var getSourceLabelRotationPoint = function getSourceLabelRotationPoint(ele) {\n        return addTextMargin('source', getRsPt(ele, 'sourceLabelX', 'sourceLabelY'), ele);\n    };\n    var getTargetLabelRotationPoint = function getTargetLabelRotationPoint(ele) {\n        return addTextMargin('target', getRsPt(ele, 'targetLabelX', 'targetLabelY'), ele);\n    };\n    var getElementRotationOffset = function getElementRotationOffset(ele) {\n        return getCenterOffset(getElementBox(ele));\n    };\n    var getSourceLabelRotationOffset = function getSourceLabelRotationOffset(ele) {\n        return getCenterOffset(getSourceLabelBox(ele));\n    };\n    var getTargetLabelRotationOffset = function getTargetLabelRotationOffset(ele) {\n        return getCenterOffset(getTargetLabelBox(ele));\n    };\n    var getLabelRotationOffset = function getLabelRotationOffset(ele) {\n        var bb = getLabelBox(ele);\n        var p = getCenterOffset(getLabelBox(ele));\n        if (ele.isNode()) {\n            switch(ele.pstyle('text-halign').value){\n                case 'left':\n                    p.x = -bb.w - (bb.leftPad || 0);\n                    break;\n                case 'right':\n                    p.x = -(bb.rightPad || 0);\n                    break;\n            }\n            switch(ele.pstyle('text-valign').value){\n                case 'top':\n                    p.y = -bb.h - (bb.topPad || 0);\n                    break;\n                case 'bottom':\n                    p.y = -(bb.botPad || 0);\n                    break;\n            }\n        }\n        return p;\n    };\n    var eleTxrCache = r.data.eleTxrCache = new ElementTextureCache(r, {\n        getKey: getStyleKey,\n        doesEleInvalidateKey: backgroundTimestampHasChanged,\n        drawElement: drawElement,\n        getBoundingBox: getElementBox,\n        getRotationPoint: getElementRotationPoint,\n        getRotationOffset: getElementRotationOffset,\n        allowEdgeTxrCaching: false,\n        allowParentTxrCaching: false\n    });\n    var lblTxrCache = r.data.lblTxrCache = new ElementTextureCache(r, {\n        getKey: getLabelKey,\n        drawElement: drawLabel,\n        getBoundingBox: getLabelBox,\n        getRotationPoint: getLabelRotationPoint,\n        getRotationOffset: getLabelRotationOffset,\n        isVisible: isLabelVisibleAtScale\n    });\n    var slbTxrCache = r.data.slbTxrCache = new ElementTextureCache(r, {\n        getKey: getSourceLabelKey,\n        drawElement: drawSourceLabel,\n        getBoundingBox: getSourceLabelBox,\n        getRotationPoint: getSourceLabelRotationPoint,\n        getRotationOffset: getSourceLabelRotationOffset,\n        isVisible: isLabelVisibleAtScale\n    });\n    var tlbTxrCache = r.data.tlbTxrCache = new ElementTextureCache(r, {\n        getKey: getTargetLabelKey,\n        drawElement: drawTargetLabel,\n        getBoundingBox: getTargetLabelBox,\n        getRotationPoint: getTargetLabelRotationPoint,\n        getRotationOffset: getTargetLabelRotationOffset,\n        isVisible: isLabelVisibleAtScale\n    });\n    var lyrTxrCache = r.data.lyrTxrCache = new LayeredTextureCache(r);\n    r.onUpdateEleCalcs(function invalidateTextureCaches(willDraw, eles) {\n        // each cache should check for sub-key diff to see that the update affects that cache particularly\n        eleTxrCache.invalidateElements(eles);\n        lblTxrCache.invalidateElements(eles);\n        slbTxrCache.invalidateElements(eles);\n        tlbTxrCache.invalidateElements(eles);\n        // any change invalidates the layers\n        lyrTxrCache.invalidateElements(eles);\n        // update the old bg timestamp so diffs can be done in the ele txr caches\n        for(var _i = 0; _i < eles.length; _i++){\n            var _p = eles[_i]._private;\n            _p.oldBackgroundTimestamp = _p.backgroundTimestamp;\n        }\n    });\n    var refineInLayers = function refineInLayers(reqs) {\n        for(var i = 0; i < reqs.length; i++){\n            lyrTxrCache.enqueueElementRefinement(reqs[i].ele);\n        }\n    };\n    eleTxrCache.onDequeue(refineInLayers);\n    lblTxrCache.onDequeue(refineInLayers);\n    slbTxrCache.onDequeue(refineInLayers);\n    tlbTxrCache.onDequeue(refineInLayers);\n    if (options.webgl) {\n        r.initWebgl(options, {\n            getStyleKey: getStyleKey,\n            getLabelKey: getLabelKey,\n            getSourceLabelKey: getSourceLabelKey,\n            getTargetLabelKey: getTargetLabelKey,\n            drawElement: drawElement,\n            drawLabel: drawLabel,\n            drawSourceLabel: drawSourceLabel,\n            drawTargetLabel: drawTargetLabel,\n            getElementBox: getElementBox,\n            getLabelBox: getLabelBox,\n            getSourceLabelBox: getSourceLabelBox,\n            getTargetLabelBox: getTargetLabelBox,\n            getElementRotationPoint: getElementRotationPoint,\n            getElementRotationOffset: getElementRotationOffset,\n            getLabelRotationPoint: getLabelRotationPoint,\n            getSourceLabelRotationPoint: getSourceLabelRotationPoint,\n            getTargetLabelRotationPoint: getTargetLabelRotationPoint,\n            getLabelRotationOffset: getLabelRotationOffset,\n            getSourceLabelRotationOffset: getSourceLabelRotationOffset,\n            getTargetLabelRotationOffset: getTargetLabelRotationOffset\n        });\n    }\n}\nCRp.redrawHint = function(group, bool) {\n    var r = this;\n    switch(group){\n        case 'eles':\n            r.data.canvasNeedsRedraw[CRp.NODE] = bool;\n            break;\n        case 'drag':\n            r.data.canvasNeedsRedraw[CRp.DRAG] = bool;\n            break;\n        case 'select':\n            r.data.canvasNeedsRedraw[CRp.SELECT_BOX] = bool;\n            break;\n        case 'gc':\n            r.data.gc = true;\n            break;\n    }\n};\n// whether to use Path2D caching for drawing\nvar pathsImpld = typeof Path2D !== 'undefined';\nCRp.path2dEnabled = function(on) {\n    if (on === undefined) {\n        return this.pathsEnabled;\n    }\n    this.pathsEnabled = on ? true : false;\n};\nCRp.usePaths = function() {\n    return pathsImpld && this.pathsEnabled;\n};\nCRp.setImgSmoothing = function(context, bool) {\n    if (context.imageSmoothingEnabled != null) {\n        context.imageSmoothingEnabled = bool;\n    } else {\n        context.webkitImageSmoothingEnabled = bool;\n        context.mozImageSmoothingEnabled = bool;\n        context.msImageSmoothingEnabled = bool;\n    }\n};\nCRp.getImgSmoothing = function(context) {\n    if (context.imageSmoothingEnabled != null) {\n        return context.imageSmoothingEnabled;\n    } else {\n        return context.webkitImageSmoothingEnabled || context.mozImageSmoothingEnabled || context.msImageSmoothingEnabled;\n    }\n};\nCRp.makeOffscreenCanvas = function(width, height) {\n    var canvas;\n    if ((typeof OffscreenCanvas === \"undefined\" ? \"undefined\" : _typeof(OffscreenCanvas)) !== \"undefined\") {\n        canvas = new OffscreenCanvas(width, height);\n    } else {\n        var containerWindow = this.cy.window();\n        var document1 = containerWindow.document;\n        canvas = document1.createElement('canvas'); // eslint-disable-line no-undef\n        canvas.width = width;\n        canvas.height = height;\n    }\n    return canvas;\n};\n[\n    CRp$b,\n    CRp$a,\n    CRp$9,\n    CRp$8,\n    CRp$7,\n    CRp$6,\n    CRp$5,\n    CRp$4,\n    CRp$3,\n    CRp$2,\n    CRp$1\n].forEach(function(props) {\n    extend(CRp, props);\n});\nvar renderer = [\n    {\n        name: 'null',\n        impl: NullRenderer\n    },\n    {\n        name: 'base',\n        impl: BR\n    },\n    {\n        name: 'canvas',\n        impl: CR\n    }\n];\nvar incExts = [\n    {\n        type: 'layout',\n        extensions: layout\n    },\n    {\n        type: 'renderer',\n        extensions: renderer\n    }\n];\n// registered extensions to cytoscape, indexed by name\nvar extensions = {};\n// registered modules for extensions, indexed by name\nvar modules = {};\nfunction setExtension(type, name, registrant) {\n    var ext = registrant;\n    var overrideErr = function overrideErr(field) {\n        warn('Can not register `' + name + '` for `' + type + '` since `' + field + '` already exists in the prototype and can not be overridden');\n    };\n    if (type === 'core') {\n        if (Core.prototype[name]) {\n            return overrideErr(name);\n        } else {\n            Core.prototype[name] = registrant;\n        }\n    } else if (type === 'collection') {\n        if (Collection.prototype[name]) {\n            return overrideErr(name);\n        } else {\n            Collection.prototype[name] = registrant;\n        }\n    } else if (type === 'layout') {\n        // fill in missing layout functions in the prototype\n        var Layout = function Layout(options) {\n            this.options = options;\n            registrant.call(this, options);\n            // make sure layout has _private for use w/ std apis like .on()\n            if (!plainObject(this._private)) {\n                this._private = {};\n            }\n            this._private.cy = options.cy;\n            this._private.listeners = [];\n            this.createEmitter();\n        };\n        var layoutProto = Layout.prototype = Object.create(registrant.prototype);\n        var optLayoutFns = [];\n        for(var i = 0; i < optLayoutFns.length; i++){\n            var fnName = optLayoutFns[i];\n            layoutProto[fnName] = layoutProto[fnName] || function() {\n                return this;\n            };\n        }\n        // either .start() or .run() is defined, so autogen the other\n        if (layoutProto.start && !layoutProto.run) {\n            layoutProto.run = function() {\n                this.start();\n                return this;\n            };\n        } else if (!layoutProto.start && layoutProto.run) {\n            layoutProto.start = function() {\n                this.run();\n                return this;\n            };\n        }\n        var regStop = registrant.prototype.stop;\n        layoutProto.stop = function() {\n            var opts = this.options;\n            if (opts && opts.animate) {\n                var anis = this.animations;\n                if (anis) {\n                    for(var _i = 0; _i < anis.length; _i++){\n                        anis[_i].stop();\n                    }\n                }\n            }\n            if (regStop) {\n                regStop.call(this);\n            } else {\n                this.emit('layoutstop');\n            }\n            return this;\n        };\n        if (!layoutProto.destroy) {\n            layoutProto.destroy = function() {\n                return this;\n            };\n        }\n        layoutProto.cy = function() {\n            return this._private.cy;\n        };\n        var getCy = function getCy(layout) {\n            return layout._private.cy;\n        };\n        var emitterOpts = {\n            addEventFields: function addEventFields(layout, evt) {\n                evt.layout = layout;\n                evt.cy = getCy(layout);\n                evt.target = layout;\n            },\n            bubble: function bubble() {\n                return true;\n            },\n            parent: function parent(layout) {\n                return getCy(layout);\n            }\n        };\n        extend(layoutProto, {\n            createEmitter: function createEmitter() {\n                this._private.emitter = new Emitter(emitterOpts, this);\n                return this;\n            },\n            emitter: function emitter() {\n                return this._private.emitter;\n            },\n            on: function on(evt, cb) {\n                this.emitter().on(evt, cb);\n                return this;\n            },\n            one: function one(evt, cb) {\n                this.emitter().one(evt, cb);\n                return this;\n            },\n            once: function once(evt, cb) {\n                this.emitter().one(evt, cb);\n                return this;\n            },\n            removeListener: function removeListener(evt, cb) {\n                this.emitter().removeListener(evt, cb);\n                return this;\n            },\n            removeAllListeners: function removeAllListeners() {\n                this.emitter().removeAllListeners();\n                return this;\n            },\n            emit: function emit(evt, params) {\n                this.emitter().emit(evt, params);\n                return this;\n            }\n        });\n        define.eventAliasesOn(layoutProto);\n        ext = Layout; // replace with our wrapped layout\n    } else if (type === 'renderer' && name !== 'null' && name !== 'base') {\n        // user registered renderers inherit from base\n        var BaseRenderer = getExtension('renderer', 'base');\n        var bProto = BaseRenderer.prototype;\n        var RegistrantRenderer = registrant;\n        var rProto = registrant.prototype;\n        var Renderer = function Renderer() {\n            BaseRenderer.apply(this, arguments);\n            RegistrantRenderer.apply(this, arguments);\n        };\n        var proto = Renderer.prototype;\n        for(var pName in bProto){\n            var pVal = bProto[pName];\n            var existsInR = rProto[pName] != null;\n            if (existsInR) {\n                return overrideErr(pName);\n            }\n            proto[pName] = pVal; // take impl from base\n        }\n        for(var _pName in rProto){\n            proto[_pName] = rProto[_pName]; // take impl from registrant\n        }\n        bProto.clientFunctions.forEach(function(name) {\n            proto[name] = proto[name] || function() {\n                error('Renderer does not implement `renderer.' + name + '()` on its prototype');\n            };\n        });\n        ext = Renderer;\n    } else if (type === '__proto__' || type === 'constructor' || type === 'prototype') {\n        // to avoid potential prototype pollution\n        return error(type + ' is an illegal type to be registered, possibly lead to prototype pollutions');\n    }\n    return setMap({\n        map: extensions,\n        keys: [\n            type,\n            name\n        ],\n        value: ext\n    });\n}\nfunction getExtension(type, name) {\n    return getMap({\n        map: extensions,\n        keys: [\n            type,\n            name\n        ]\n    });\n}\nfunction setModule(type, name, moduleType, moduleName, registrant) {\n    return setMap({\n        map: modules,\n        keys: [\n            type,\n            name,\n            moduleType,\n            moduleName\n        ],\n        value: registrant\n    });\n}\nfunction getModule(type, name, moduleType, moduleName) {\n    return getMap({\n        map: modules,\n        keys: [\n            type,\n            name,\n            moduleType,\n            moduleName\n        ]\n    });\n}\nvar extension = function extension() {\n    // e.g. extension('renderer', 'svg')\n    if (arguments.length === 2) {\n        return getExtension.apply(null, arguments);\n    } else if (arguments.length === 3) {\n        return setExtension.apply(null, arguments);\n    } else if (arguments.length === 4) {\n        return getModule.apply(null, arguments);\n    } else if (arguments.length === 5) {\n        return setModule.apply(null, arguments);\n    } else {\n        error('Invalid extension access syntax');\n    }\n};\n// allows a core instance to access extensions internally\nCore.prototype.extension = extension;\n// included extensions\nincExts.forEach(function(group) {\n    group.extensions.forEach(function(ext) {\n        setExtension(group.type, ext.name, ext.impl);\n    });\n});\n// a dummy stylesheet object that doesn't need a reference to the core\n// (useful for init)\nvar _Stylesheet = function Stylesheet() {\n    if (!(this instanceof _Stylesheet)) {\n        return new _Stylesheet();\n    }\n    this.length = 0;\n};\nvar sheetfn = _Stylesheet.prototype;\nsheetfn.instanceString = function() {\n    return 'stylesheet';\n};\n// just store the selector to be parsed later\nsheetfn.selector = function(selector) {\n    var i = this.length++;\n    this[i] = {\n        selector: selector,\n        properties: []\n    };\n    return this; // chaining\n};\n// just store the property to be parsed later\nsheetfn.css = function(name, value) {\n    var i = this.length - 1;\n    if (string(name)) {\n        this[i].properties.push({\n            name: name,\n            value: value\n        });\n    } else if (plainObject(name)) {\n        var map = name;\n        var propNames = Object.keys(map);\n        for(var j = 0; j < propNames.length; j++){\n            var key = propNames[j];\n            var mapVal = map[key];\n            if (mapVal == null) {\n                continue;\n            }\n            var prop = _Style.properties[key] || _Style.properties[dash2camel(key)];\n            if (prop == null) {\n                continue;\n            }\n            var _name = prop.name;\n            var _value = mapVal;\n            this[i].properties.push({\n                name: _name,\n                value: _value\n            });\n        }\n    }\n    return this; // chaining\n};\nsheetfn.style = sheetfn.css;\n// generate a real style object from the dummy stylesheet\nsheetfn.generateStyle = function(cy) {\n    var style = new _Style(cy);\n    return this.appendToStyle(style);\n};\n// append a dummy stylesheet object on a real style object\nsheetfn.appendToStyle = function(style) {\n    for(var i = 0; i < this.length; i++){\n        var context = this[i];\n        var selector = context.selector;\n        var props = context.properties;\n        style.selector(selector); // apply selector\n        for(var j = 0; j < props.length; j++){\n            var prop = props[j];\n            style.css(prop.name, prop.value); // apply property\n        }\n    }\n    return style;\n};\nvar version = \"3.33.1\";\nvar cytoscape = function cytoscape(options) {\n    // if no options specified, use default\n    if (options === undefined) {\n        options = {};\n    }\n    // create instance\n    if (plainObject(options)) {\n        return new Core(options);\n    } else if (string(options)) {\n        return extension.apply(extension, arguments);\n    }\n};\n// e.g. cytoscape.use( require('cytoscape-foo'), bar )\ncytoscape.use = function(ext) {\n    var args = Array.prototype.slice.call(arguments, 1); // args to pass to ext\n    args.unshift(cytoscape); // cytoscape is first arg to ext\n    ext.apply(null, args);\n    return this;\n};\ncytoscape.warnings = function(bool) {\n    return warnings(bool);\n};\n// replaced by build system\ncytoscape.version = version;\n// expose public apis (mostly for extensions)\ncytoscape.stylesheet = cytoscape.Stylesheet = _Stylesheet;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2N5dG9zY2FwZUAzLjMzLjEvbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZS5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FFRCxTQUFTQSxrQkFBa0JDLENBQUMsRUFBRUMsQ0FBQztJQUM1QixTQUFRQSxLQUFLQSxJQUFJRCxFQUFFRSxNQUFNLEtBQU1ELENBQUFBLElBQUlELEVBQUVFLE1BQU07SUFDNUMsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLElBQUlDLE1BQU1KLElBQUlFLElBQUlGLEdBQUdFLElBQUtDLENBQUMsQ0FBQ0QsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDckQsT0FBT0M7QUFDVDtBQUNBLFNBQVNFLGdCQUFnQk4sQ0FBQztJQUN4QixJQUFJSyxNQUFNRSxPQUFPLENBQUNQLElBQUksT0FBT0E7QUFDL0I7QUFDQSxTQUFTUSxtQkFBbUJSLENBQUM7SUFDM0IsSUFBSUssTUFBTUUsT0FBTyxDQUFDUCxJQUFJLE9BQU9ELGtCQUFrQkM7QUFDakQ7QUFDQSxTQUFTUyxnQkFBZ0JSLENBQUMsRUFBRUcsQ0FBQztJQUMzQixJQUFJLENBQUVILENBQUFBLGFBQWFHLENBQUFBLEdBQUksTUFBTSxJQUFJTSxVQUFVO0FBQzdDO0FBQ0EsU0FBU0Msa0JBQWtCUixDQUFDLEVBQUVILENBQUM7SUFDN0IsSUFBSyxJQUFJWSxJQUFJLEdBQUdBLElBQUlaLEVBQUVFLE1BQU0sRUFBRVUsSUFBSztRQUNqQyxJQUFJQyxJQUFJYixDQUFDLENBQUNZLEVBQUU7UUFDWkMsRUFBRUMsVUFBVSxHQUFHRCxFQUFFQyxVQUFVLElBQUksT0FBT0QsRUFBRUUsWUFBWSxHQUFHLE1BQU0sV0FBV0YsS0FBTUEsQ0FBQUEsRUFBRUcsUUFBUSxHQUFHLElBQUcsR0FBSUMsT0FBT0MsY0FBYyxDQUFDZixHQUFHZ0IsZUFBZU4sRUFBRU8sR0FB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c0RBQXNEO0FBQ3REcThLLFVBQVU1aUUsR0FBRyxHQUFHLFNBQVVtaEUsR0FBRztJQUMzQixJQUFJMzZLLE9BQU9uRyxNQUFNaUIsU0FBUyxDQUFDK0IsS0FBSyxDQUFDcEIsSUFBSSxDQUFDc0UsV0FBVyxJQUFJLHNCQUFzQjtJQUUzRUMsS0FBSzBoQixPQUFPLENBQUMwNkosWUFBWSxnQ0FBZ0M7SUFFekR6QixJQUFJcDZLLEtBQUssQ0FBQyxNQUFNUDtJQUNoQixPQUFPLElBQUk7QUFDYjtBQUNBbzhLLFVBQVV2aUssUUFBUSxHQUFHLFNBQVV3eUUsSUFBSTtJQUNqQyxPQUFPeHlFLFNBQVN3eUU7QUFDbEI7QUFFQSwyQkFBMkI7QUFDM0IrdkYsVUFBVUQsT0FBTyxHQUFHQTtBQUVwQiw2Q0FBNkM7QUFDN0NDLFVBQVVyOUssVUFBVSxHQUFHcTlLLFVBQVVILFVBQVUsR0FBR0Q7QUFFZCIsInNvdXJjZXMiOlsiL1VzZXJzL0Vib290aC9hZ2VudF9jX2ZyYW1ld29yay9zcmMvcmVhbHRpbWVfY2xpZW50L25vZGVfbW9kdWxlcy8ucG5wbS9jeXRvc2NhcGVAMy4zMy4xL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUvZGlzdC9jeXRvc2NhcGUuZXNtLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNi0yMDI1LCBUaGUgQ3l0b3NjYXBlIENvbnNvcnRpdW0uXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuICogdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUg4oCcU29mdHdhcmXigJ0pLCB0byBkZWFsIGluXG4gKiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG4gKiB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllc1xuICogb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvXG4gKiBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCDigJxBUyBJU+KAnSwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgZmFsc2UsIG8uY29uZmlndXJhYmxlID0gdHJ1ZSwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSB0cnVlKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyLCBlKSB7XG4gIHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKCF0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikpIHx8IGUpIHtcbiAgICAgIHQgJiYgKHIgPSB0KTtcbiAgICAgIHZhciBuID0gMCxcbiAgICAgICAgRiA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgczogRixcbiAgICAgICAgbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuID49IHIubGVuZ3RoID8ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiByW24rK11cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlOiBmdW5jdGlvbiAocikge1xuICAgICAgICAgIHRocm93IHI7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuICB2YXIgbyxcbiAgICBhID0gdHJ1ZSxcbiAgICB1ID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgczogZnVuY3Rpb24gKCkge1xuICAgICAgdCA9IHQuY2FsbChyKTtcbiAgICB9LFxuICAgIG46IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByID0gdC5uZXh0KCk7XG4gICAgICByZXR1cm4gYSA9IHIuZG9uZSwgcjtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChyKSB7XG4gICAgICB1ID0gdHJ1ZSwgbyA9IHI7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhIHx8IG51bGwgPT0gdC5yZXR1cm4gfHwgdC5yZXR1cm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh1KSB0aHJvdyBvO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eSQxKGUsIHIsIHQpIHtcbiAgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pIDogZVtyXSA9IHQsIGU7XG59XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHtcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSB0cnVlLFxuICAgICAgbyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSB0cnVlLCBuID0gcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFmICYmIG51bGwgIT0gdC5yZXR1cm4gJiYgKHUgPSB0LnJldHVybigpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAobykgdGhyb3cgbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbn1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkociwgZSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBlKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgZSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh1bmRlZmluZWQgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoU3RyaW5nICkodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG52YXIgX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG52YXIgbmF2aWdhdG9yID0gX3dpbmRvdyA/IF93aW5kb3cubmF2aWdhdG9yIDogbnVsbDtcbl93aW5kb3cgPyBfd2luZG93LmRvY3VtZW50IDogbnVsbDtcbnZhciB0eXBlb2ZzdHIgPSBfdHlwZW9mKCcnKTtcbnZhciB0eXBlb2ZvYmogPSBfdHlwZW9mKHt9KTtcbnZhciB0eXBlb2ZmbiA9IF90eXBlb2YoZnVuY3Rpb24gKCkge30pO1xudmFyIHR5cGVvZmh0bWxlbGUgPSB0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihIVE1MRWxlbWVudCk7XG52YXIgaW5zdGFuY2VTdHIgPSBmdW5jdGlvbiBpbnN0YW5jZVN0cihvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouaW5zdGFuY2VTdHJpbmcgJiYgZm4kNihvYmouaW5zdGFuY2VTdHJpbmcpID8gb2JqLmluc3RhbmNlU3RyaW5nKCkgOiBudWxsO1xufTtcblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uIHN0cmluZyhvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PSB0eXBlb2ZzdHI7XG59O1xudmFyIGZuJDYgPSBmdW5jdGlvbiBmbihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mZm47XG59O1xudmFyIGFycmF5ID0gZnVuY3Rpb24gYXJyYXkob2JqKSB7XG4gIHJldHVybiAhZWxlbWVudE9yQ29sbGVjdGlvbihvYmopICYmIChBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheShvYmopIDogb2JqICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXkpO1xufTtcbnZhciBwbGFpbk9iamVjdCA9IGZ1bmN0aW9uIHBsYWluT2JqZWN0KG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgX3R5cGVvZihvYmopID09PSB0eXBlb2ZvYmogJiYgIWFycmF5KG9iaikgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59O1xudmFyIG9iamVjdCA9IGZ1bmN0aW9uIG9iamVjdChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gdHlwZW9mb2JqO1xufTtcbnZhciBudW1iZXIkMSA9IGZ1bmN0aW9uIG51bWJlcihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIF90eXBlb2Yob2JqKSA9PT0gX3R5cGVvZigxKSAmJiAhaXNOYU4ob2JqKTtcbn07XG52YXIgaW50ZWdlciA9IGZ1bmN0aW9uIGludGVnZXIob2JqKSB7XG4gIHJldHVybiBudW1iZXIkMShvYmopICYmIE1hdGguZmxvb3Iob2JqKSA9PT0gb2JqO1xufTtcbnZhciBodG1sRWxlbWVudCA9IGZ1bmN0aW9uIGh0bWxFbGVtZW50KG9iaikge1xuICBpZiAoJ3VuZGVmaW5lZCcgPT09IHR5cGVvZmh0bWxlbGUpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsICE9IG9iaiAmJiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgfVxufTtcbnZhciBlbGVtZW50T3JDb2xsZWN0aW9uID0gZnVuY3Rpb24gZWxlbWVudE9yQ29sbGVjdGlvbihvYmopIHtcbiAgcmV0dXJuIGVsZW1lbnQob2JqKSB8fCBjb2xsZWN0aW9uKG9iaik7XG59O1xudmFyIGVsZW1lbnQgPSBmdW5jdGlvbiBlbGVtZW50KG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmIG9iai5fcHJpdmF0ZS5zaW5nbGU7XG59O1xudmFyIGNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjb2xsZWN0aW9uKG9iaikge1xuICByZXR1cm4gaW5zdGFuY2VTdHIob2JqKSA9PT0gJ2NvbGxlY3Rpb24nICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xufTtcbnZhciBjb3JlID0gZnVuY3Rpb24gY29yZShvYmopIHtcbiAgcmV0dXJuIGluc3RhbmNlU3RyKG9iaikgPT09ICdjb3JlJztcbn07XG52YXIgc3R5bGVzaGVldCA9IGZ1bmN0aW9uIHN0eWxlc2hlZXQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnc3R5bGVzaGVldCc7XG59O1xudmFyIGV2ZW50ID0gZnVuY3Rpb24gZXZlbnQob2JqKSB7XG4gIHJldHVybiBpbnN0YW5jZVN0cihvYmopID09PSAnZXZlbnQnO1xufTtcbnZhciBlbXB0eVN0cmluZyA9IGZ1bmN0aW9uIGVtcHR5U3RyaW5nKG9iaikge1xuICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XG4gICAgLy8gbnVsbCBpcyBlbXB0eVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKG9iaiA9PT0gJycgfHwgb2JqLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgZW1wdHlcbiAgfVxuICByZXR1cm4gZmFsc2U7IC8vIG90aGVyd2lzZSwgd2UgZG9uJ3Qga25vdyB3aGF0IHdlJ3ZlIGdvdFxufTtcbnZhciBkb21FbGVtZW50ID0gZnVuY3Rpb24gZG9tRWxlbWVudChvYmopIHtcbiAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIG5vdCBpbiBhIGJyb3dzZXIgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIH1cbn07XG52YXIgYm91bmRpbmdCb3ggPSBmdW5jdGlvbiBib3VuZGluZ0JveChvYmopIHtcbiAgcmV0dXJuIHBsYWluT2JqZWN0KG9iaikgJiYgbnVtYmVyJDEob2JqLngxKSAmJiBudW1iZXIkMShvYmoueDIpICYmIG51bWJlciQxKG9iai55MSkgJiYgbnVtYmVyJDEob2JqLnkyKTtcbn07XG52YXIgcHJvbWlzZSA9IGZ1bmN0aW9uIHByb21pc2Uob2JqKSB7XG4gIHJldHVybiBvYmplY3Qob2JqKSAmJiBmbiQ2KG9iai50aGVuKTtcbn07XG52YXIgbXMgPSBmdW5jdGlvbiBtcygpIHtcbiAgcmV0dXJuIG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9tc2llfHRyaWRlbnR8ZWRnZS9pKTtcbn07IC8vIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuXG52YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uIG1lbW9pemUoZm4sIGtleUZuKSB7XG4gIGlmICgha2V5Rm4pIHtcbiAgICBrZXlGbiA9IGZ1bmN0aW9uIGtleUZuKCkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJncy5qb2luKCckJyk7XG4gICAgfTtcbiAgfVxuICB2YXIgX21lbW9pemVkRm4gPSBmdW5jdGlvbiBtZW1vaXplZEZuKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgcmV0O1xuICAgIHZhciBrID0ga2V5Rm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgdmFyIGNhY2hlID0gX21lbW9pemVkRm4uY2FjaGU7XG4gICAgaWYgKCEocmV0ID0gY2FjaGVba10pKSB7XG4gICAgICByZXQgPSBjYWNoZVtrXSA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICBfbWVtb2l6ZWRGbi5jYWNoZSA9IHt9O1xuICByZXR1cm4gX21lbW9pemVkRm47XG59O1xuXG52YXIgY2FtZWwyZGFzaCA9IG1lbW9pemUoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbQS1aXSkvZywgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gJy0nICsgdi50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbn0pO1xudmFyIGRhc2gyY2FtZWwgPSBtZW1vaXplKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oLVxcdykvZywgZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdlsxXS50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn0pO1xudmFyIHByZXBlbmRDYW1lbCA9IG1lbW9pemUoZnVuY3Rpb24gKHByZWZpeCwgc3RyKSB7XG4gIHJldHVybiBwcmVmaXggKyBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59LCBmdW5jdGlvbiAocHJlZml4LCBzdHIpIHtcbiAgcmV0dXJuIHByZWZpeCArICckJyArIHN0cjtcbn0pO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICBpZiAoZW1wdHlTdHJpbmcoc3RyKSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xudmFyIGVuZHNXaXRoID0gZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCBzdWZmaXgpIHtcbiAgcmV0dXJuIHN0cmluZy5zbGljZSgtMSAqIHN1ZmZpeC5sZW5ndGgpID09PSBzdWZmaXg7XG59O1xuXG52YXIgbnVtYmVyID0gJyg/OlstK10/KD86KD86XFxcXGQrfFxcXFxkKlxcXFwuXFxcXGQrKSg/OltFZV1bKy1dP1xcXFxkKyk/KSknO1xudmFyIHJnYmEgPSAncmdiW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnWyVdPykoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIHJnYmFOb0JhY2tSZWZzID0gJ3JnYlthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnWyVdPylcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0/KVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXT8pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhzbGEgPSAnaHNsW2FdP1xcXFwoKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICdbJV0pXFxcXHMqLFxcXFxzKignICsgbnVtYmVyICsgJ1slXSkoPzpcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhzbGFOb0JhY2tSZWZzID0gJ2hzbFthXT9cXFxcKCg/OicgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooPzonICsgbnVtYmVyICsgJ1slXSlcXFxccyosXFxcXHMqKD86JyArIG51bWJlciArICdbJV0pKD86XFxcXHMqLFxcXFxzKig/OicgKyBudW1iZXIgKyAnKSk/XFxcXCknO1xudmFyIGhleDMgPSAnXFxcXCNbMC05YS1mQS1GXXszfSc7XG52YXIgaGV4NiA9ICdcXFxcI1swLTlhLWZBLUZdezZ9JztcblxudmFyIGFzY2VuZGluZyA9IGZ1bmN0aW9uIGFzY2VuZGluZyhhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhID4gYikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xudmFyIGRlc2NlbmRpbmcgPSBmdW5jdGlvbiBkZXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIC0xICogYXNjZW5kaW5nKGEsIGIpO1xufTtcblxudmFyIGV4dGVuZCA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG9iaiA9IGFyZ3NbaV07XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGsgPSBrZXlzW2pdO1xuICAgICAgdGd0W2tdID0gb2JqW2tdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGd0O1xufTtcblxuLy8gZ2V0IFtyLCBnLCBiXSBmcm9tICNhYmMgb3IgI2FhYmJjY1xudmFyIGhleDJ0dXBsZSA9IGZ1bmN0aW9uIGhleDJ0dXBsZShoZXgpIHtcbiAgaWYgKCEoaGV4Lmxlbmd0aCA9PT0gNCB8fCBoZXgubGVuZ3RoID09PSA3KSB8fCBoZXhbMF0gIT09ICcjJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2hvcnRIZXggPSBoZXgubGVuZ3RoID09PSA0O1xuICB2YXIgciwgZywgYjtcbiAgdmFyIGJhc2UgPSAxNjtcbiAgaWYgKHNob3J0SGV4KSB7XG4gICAgciA9IHBhcnNlSW50KGhleFsxXSArIGhleFsxXSwgYmFzZSk7XG4gICAgZyA9IHBhcnNlSW50KGhleFsyXSArIGhleFsyXSwgYmFzZSk7XG4gICAgYiA9IHBhcnNlSW50KGhleFszXSArIGhleFszXSwgYmFzZSk7XG4gIH0gZWxzZSB7XG4gICAgciA9IHBhcnNlSW50KGhleFsxXSArIGhleFsyXSwgYmFzZSk7XG4gICAgZyA9IHBhcnNlSW50KGhleFszXSArIGhleFs0XSwgYmFzZSk7XG4gICAgYiA9IHBhcnNlSW50KGhleFs1XSArIGhleFs2XSwgYmFzZSk7XG4gIH1cbiAgcmV0dXJuIFtyLCBnLCBiXTtcbn07XG5cbi8vIGdldCBbciwgZywgYiwgYV0gZnJvbSBoc2woMCwgMCwgMCkgb3IgaHNsYSgwLCAwLCAwLCAwKVxudmFyIGhzbDJ0dXBsZSA9IGZ1bmN0aW9uIGhzbDJ0dXBsZShoc2wpIHtcbiAgdmFyIHJldDtcbiAgdmFyIGgsIHMsIGwsIGEsIHIsIGcsIGI7XG4gIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkgdCArPSAxO1xuICAgIGlmICh0ID4gMSkgdCAtPSAxO1xuICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgIGlmICh0IDwgMSAvIDIpIHJldHVybiBxO1xuICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICByZXR1cm4gcDtcbiAgfVxuICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgaHNsYSArICckJykuZXhlYyhoc2wpO1xuICBpZiAobSkge1xuICAgIC8vIGdldCBodWVcbiAgICBoID0gcGFyc2VJbnQobVsxXSk7XG4gICAgaWYgKGggPCAwKSB7XG4gICAgICBoID0gKDM2MCAtIC0xICogaCAlIDM2MCkgJSAzNjA7XG4gICAgfSBlbHNlIGlmIChoID4gMzYwKSB7XG4gICAgICBoID0gaCAlIDM2MDtcbiAgICB9XG4gICAgaCAvPSAzNjA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIHMgPSBwYXJzZUZsb2F0KG1bMl0pO1xuICAgIGlmIChzIDwgMCB8fCBzID4gMTAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzYXR1cmF0aW9uIGlzIFswLCAxMDBdXG4gICAgcyA9IHMgLyAxMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgIGwgPSBwYXJzZUZsb2F0KG1bM10pO1xuICAgIGlmIChsIDwgMCB8fCBsID4gMTAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBsaWdodG5lc3MgaXMgWzAsIDEwMF1cbiAgICBsID0gbCAvIDEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgYSA9IG1bNF07XG4gICAgaWYgKGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYSA9IHBhcnNlRmxvYXQoYSk7XG4gICAgICBpZiAoYSA8IDAgfHwgYSA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBhbHBoYSBpcyBbMCwgMV1cbiAgICB9XG5cbiAgICAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgLy8gY29kZSBmcm9tIGh0dHA6Ly9tamlqYWNrc29uLmNvbS8yMDA4LzAyL3JnYi10by1oc2wtYW5kLXJnYi10by1oc3YtY29sb3ItbW9kZWwtY29udmVyc2lvbi1hbGdvcml0aG1zLWluLWphdmFzY3JpcHRcbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZChsICogMjU1KTsgLy8gYWNocm9tYXRpY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgIHIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKSk7XG4gICAgICBnID0gTWF0aC5yb3VuZCgyNTUgKiBodWUycmdiKHAsIHEsIGgpKTtcbiAgICAgIGIgPSBNYXRoLnJvdW5kKDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKSk7XG4gICAgfVxuICAgIHJldCA9IFtyLCBnLCBiLCBhXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxuLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIHJnYigwLCAwLCAwKSBvciByZ2JhKDAsIDAsIDAsIDApXG52YXIgcmdiMnR1cGxlID0gZnVuY3Rpb24gcmdiMnR1cGxlKHJnYikge1xuICB2YXIgcmV0O1xuICB2YXIgbSA9IG5ldyBSZWdFeHAoJ14nICsgcmdiYSArICckJykuZXhlYyhyZ2IpO1xuICBpZiAobSkge1xuICAgIHJldCA9IFtdO1xuICAgIHZhciBpc1BjdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IDM7IGkrKykge1xuICAgICAgdmFyIGNoYW5uZWwgPSBtW2ldO1xuICAgICAgaWYgKGNoYW5uZWxbY2hhbm5lbC5sZW5ndGggLSAxXSA9PT0gJyUnKSB7XG4gICAgICAgIGlzUGN0W2ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNoYW5uZWwgPSBwYXJzZUZsb2F0KGNoYW5uZWwpO1xuICAgICAgaWYgKGlzUGN0W2ldKSB7XG4gICAgICAgIGNoYW5uZWwgPSBjaGFubmVsIC8gMTAwICogMjU1OyAvLyBub3JtYWxpc2UgdG8gWzAsIDI1NV1cbiAgICAgIH1cbiAgICAgIGlmIChjaGFubmVsIDwgMCB8fCBjaGFubmVsID4gMjU1KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cbiAgICAgIHJldC5wdXNoKE1hdGguZmxvb3IoY2hhbm5lbCkpO1xuICAgIH1cbiAgICB2YXIgYXRMZWFzdE9uZUlzUGN0ID0gaXNQY3RbMV0gfHwgaXNQY3RbMl0gfHwgaXNQY3RbM107XG4gICAgdmFyIGFsbEFyZVBjdCA9IGlzUGN0WzFdICYmIGlzUGN0WzJdICYmIGlzUGN0WzNdO1xuICAgIGlmIChhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbXVzdCBhbGwgYmUgcGVyY2VudCB2YWx1ZXMgaWYgb25lIGlzXG5cbiAgICB2YXIgYWxwaGEgPSBtWzRdO1xuICAgIGlmIChhbHBoYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoYWxwaGEpO1xuICAgICAgaWYgKGFscGhhIDwgMCB8fCBhbHBoYSA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBpbnZhbGlkIGFscGhhIHZhbHVlXG5cbiAgICAgIHJldC5wdXNoKGFscGhhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG52YXIgY29sb3JuYW1lMnR1cGxlID0gZnVuY3Rpb24gY29sb3JuYW1lMnR1cGxlKGNvbG9yKSB7XG4gIHJldHVybiBjb2xvcnNbY29sb3IudG9Mb3dlckNhc2UoKV07XG59O1xudmFyIGNvbG9yMnR1cGxlID0gZnVuY3Rpb24gY29sb3IydHVwbGUoY29sb3IpIHtcbiAgcmV0dXJuIChhcnJheShjb2xvcikgPyBjb2xvciA6IG51bGwpIHx8IGNvbG9ybmFtZTJ0dXBsZShjb2xvcikgfHwgaGV4MnR1cGxlKGNvbG9yKSB8fCByZ2IydHVwbGUoY29sb3IpIHx8IGhzbDJ0dXBsZShjb2xvcik7XG59O1xudmFyIGNvbG9ycyA9IHtcbiAgLy8gc3BlY2lhbCBjb2xvdXIgbmFtZXNcbiAgdHJhbnNwYXJlbnQ6IFswLCAwLCAwLCAwXSxcbiAgLy8gTkIgYWxwaGEgPT09IDBcblxuICAvLyByZWd1bGFyIGNvbG91cnNcbiAgYWxpY2VibHVlOiBbMjQwLCAyNDgsIDI1NV0sXG4gIGFudGlxdWV3aGl0ZTogWzI1MCwgMjM1LCAyMTVdLFxuICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICBhcXVhbWFyaW5lOiBbMTI3LCAyNTUsIDIxMl0sXG4gIGF6dXJlOiBbMjQwLCAyNTUsIDI1NV0sXG4gIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gIGJpc3F1ZTogWzI1NSwgMjI4LCAxOTZdLFxuICBibGFjazogWzAsIDAsIDBdLFxuICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICBibHVlOiBbMCwgMCwgMjU1XSxcbiAgYmx1ZXZpb2xldDogWzEzOCwgNDMsIDIyNl0sXG4gIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICBidXJseXdvb2Q6IFsyMjIsIDE4NCwgMTM1XSxcbiAgY2FkZXRibHVlOiBbOTUsIDE1OCwgMTYwXSxcbiAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgY2hvY29sYXRlOiBbMjEwLCAxMDUsIDMwXSxcbiAgY29yYWw6IFsyNTUsIDEyNywgODBdLFxuICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICBjb3Juc2lsazogWzI1NSwgMjQ4LCAyMjBdLFxuICBjcmltc29uOiBbMjIwLCAyMCwgNjBdLFxuICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICBkYXJrYmx1ZTogWzAsIDAsIDEzOV0sXG4gIGRhcmtjeWFuOiBbMCwgMTM5LCAxMzldLFxuICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzQsIDExXSxcbiAgZGFya2dyYXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2dyZWVuOiBbMCwgMTAwLCAwXSxcbiAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgZGFya2toYWtpOiBbMTg5LCAxODMsIDEwN10sXG4gIGRhcmttYWdlbnRhOiBbMTM5LCAwLCAxMzldLFxuICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgZGFya29yYW5nZTogWzI1NSwgMTQwLCAwXSxcbiAgZGFya29yY2hpZDogWzE1MywgNTAsIDIwNF0sXG4gIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICBkYXJrc2FsbW9uOiBbMjMzLCAxNTAsIDEyMl0sXG4gIGRhcmtzZWFncmVlbjogWzE0MywgMTg4LCAxNDNdLFxuICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICBkYXJrc2xhdGVncmF5OiBbNDcsIDc5LCA3OV0sXG4gIGRhcmtzbGF0ZWdyZXk6IFs0NywgNzksIDc5XSxcbiAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgZGFya3Zpb2xldDogWzE0OCwgMCwgMjExXSxcbiAgZGVlcHBpbms6IFsyNTUsIDIwLCAxNDddLFxuICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgZGltZ3JheTogWzEwNSwgMTA1LCAxMDVdLFxuICBkaW1ncmV5OiBbMTA1LCAxMDUsIDEwNV0sXG4gIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICBmaXJlYnJpY2s6IFsxNzgsIDM0LCAzNF0sXG4gIGZsb3JhbHdoaXRlOiBbMjU1LCAyNTAsIDI0MF0sXG4gIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICBmdWNoc2lhOiBbMjU1LCAwLCAyNTVdLFxuICBnYWluc2Jvcm86IFsyMjAsIDIyMCwgMjIwXSxcbiAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICBnb2xkOiBbMjU1LCAyMTUsIDBdLFxuICBnb2xkZW5yb2Q6IFsyMTgsIDE2NSwgMzJdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIGdyZXk6IFsxMjgsIDEyOCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gIGhvbmV5ZGV3OiBbMjQwLCAyNTUsIDI0MF0sXG4gIGhvdHBpbms6IFsyNTUsIDEwNSwgMTgwXSxcbiAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICBpbmRpZ286IFs3NSwgMCwgMTMwXSxcbiAgaXZvcnk6IFsyNTUsIDI1NSwgMjQwXSxcbiAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgbGF2ZW5kZXI6IFsyMzAsIDIzMCwgMjUwXSxcbiAgbGF2ZW5kZXJibHVzaDogWzI1NSwgMjQwLCAyNDVdLFxuICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gIGxlbW9uY2hpZmZvbjogWzI1NSwgMjUwLCAyMDVdLFxuICBsaWdodGJsdWU6IFsxNzMsIDIxNiwgMjMwXSxcbiAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICBsaWdodGN5YW46IFsyMjQsIDI1NSwgMjU1XSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFsyNTAsIDI1MCwgMjEwXSxcbiAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0Z3JlZW46IFsxNDQsIDIzOCwgMTQ0XSxcbiAgbGlnaHRncmV5OiBbMjExLCAyMTEsIDIxMV0sXG4gIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICBsaWdodHNhbG1vbjogWzI1NSwgMTYwLCAxMjJdLFxuICBsaWdodHNlYWdyZWVuOiBbMzIsIDE3OCwgMTcwXSxcbiAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gIGxpZ2h0c2xhdGVncmF5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c2xhdGVncmV5OiBbMTE5LCAxMzYsIDE1M10sXG4gIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gIGxpZ2h0eWVsbG93OiBbMjU1LCAyNTUsIDIyNF0sXG4gIGxpbWU6IFswLCAyNTUsIDBdLFxuICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gIGxpbmVuOiBbMjUwLCAyNDAsIDIzMF0sXG4gIG1hZ2VudGE6IFsyNTUsIDAsIDI1NV0sXG4gIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFsxMDIsIDIwNSwgMTcwXSxcbiAgbWVkaXVtYmx1ZTogWzAsIDAsIDIwNV0sXG4gIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gIG1lZGl1bXB1cnBsZTogWzE0NywgMTEyLCAyMTldLFxuICBtZWRpdW1zZWFncmVlbjogWzYwLCAxNzksIDExM10sXG4gIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICBtZWRpdW1zcHJpbmdncmVlbjogWzAsIDI1MCwgMTU0XSxcbiAgbWVkaXVtdHVycXVvaXNlOiBbNzIsIDIwOSwgMjA0XSxcbiAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgbWlkbmlnaHRibHVlOiBbMjUsIDI1LCAxMTJdLFxuICBtaW50Y3JlYW06IFsyNDUsIDI1NSwgMjUwXSxcbiAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gIG1vY2Nhc2luOiBbMjU1LCAyMjgsIDE4MV0sXG4gIG5hdmFqb3doaXRlOiBbMjU1LCAyMjIsIDE3M10sXG4gIG5hdnk6IFswLCAwLCAxMjhdLFxuICBvbGRsYWNlOiBbMjUzLCAyNDUsIDIzMF0sXG4gIG9saXZlOiBbMTI4LCAxMjgsIDBdLFxuICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICBvcmFuZ2U6IFsyNTUsIDE2NSwgMF0sXG4gIG9yYW5nZXJlZDogWzI1NSwgNjksIDBdLFxuICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgcGFsZWdvbGRlbnJvZDogWzIzOCwgMjMyLCAxNzBdLFxuICBwYWxlZ3JlZW46IFsxNTIsIDI1MSwgMTUyXSxcbiAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICBwYWxldmlvbGV0cmVkOiBbMjE5LCAxMTIsIDE0N10sXG4gIHBhcGF5YXdoaXA6IFsyNTUsIDIzOSwgMjEzXSxcbiAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gIHBlcnU6IFsyMDUsIDEzMywgNjNdLFxuICBwaW5rOiBbMjU1LCAxOTIsIDIwM10sXG4gIHBsdW06IFsyMjEsIDE2MCwgMjIxXSxcbiAgcG93ZGVyYmx1ZTogWzE3NiwgMjI0LCAyMzBdLFxuICBwdXJwbGU6IFsxMjgsIDAsIDEyOF0sXG4gIHJlZDogWzI1NSwgMCwgMF0sXG4gIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICByb3lhbGJsdWU6IFs2NSwgMTA1LCAyMjVdLFxuICBzYWRkbGVicm93bjogWzEzOSwgNjksIDE5XSxcbiAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gIHNhbmR5YnJvd246IFsyNDQsIDE2NCwgOTZdLFxuICBzZWFncmVlbjogWzQ2LCAxMzksIDg3XSxcbiAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgc2llbm5hOiBbMTYwLCA4MiwgNDVdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICBzbGF0ZWJsdWU6IFsxMDYsIDkwLCAyMDVdLFxuICBzbGF0ZWdyYXk6IFsxMTIsIDEyOCwgMTQ0XSxcbiAgc2xhdGVncmV5OiBbMTEyLCAxMjgsIDE0NF0sXG4gIHNub3c6IFsyNTUsIDI1MCwgMjUwXSxcbiAgc3ByaW5nZ3JlZW46IFswLCAyNTUsIDEyN10sXG4gIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gIHRhbjogWzIxMCwgMTgwLCAxNDBdLFxuICB0ZWFsOiBbMCwgMTI4LCAxMjhdLFxuICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gIHRvbWF0bzogWzI1NSwgOTksIDcxXSxcbiAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgdmlvbGV0OiBbMjM4LCAxMzAsIDIzOF0sXG4gIHdoZWF0OiBbMjQ1LCAyMjIsIDE3OV0sXG4gIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gIHdoaXRlc21va2U6IFsyNDUsIDI0NSwgMjQ1XSxcbiAgeWVsbG93OiBbMjU1LCAyNTUsIDBdLFxuICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1MF1cbn07XG5cbi8vIHNldHMgdGhlIHZhbHVlIGluIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbnZhciBzZXRNYXAgPSBmdW5jdGlvbiBzZXRNYXAob3B0aW9ucykge1xuICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChwbGFpbk9iamVjdChrZXkpKSB7XG4gICAgICB0aHJvdyBFcnJvcignVHJpZWQgdG8gc2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICB9XG4gICAgaWYgKGkgPCBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgIC8vIGV4dGVuZCB0aGUgbWFwIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKG9ialtrZXldID09IG51bGwpIHtcbiAgICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICBvYmpba2V5XSA9IG9wdGlvbnMudmFsdWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBnZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCBldmVuIGlmIGl0J3Mgbm90IGJ1aWx0IGluIHBsYWNlc1xudmFyIGdldE1hcCA9IGZ1bmN0aW9uIGdldE1hcChvcHRpb25zKSB7XG4gIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKHBsYWluT2JqZWN0KGtleSkpIHtcbiAgICAgIHRocm93IEVycm9yKCdUcmllZCB0byBnZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgIH1cbiAgICBvYmogPSBvYmpba2V5XTtcbiAgICBpZiAob2JqID09IG51bGwpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNPYmplY3RfMTtcbnZhciBoYXNSZXF1aXJlZElzT2JqZWN0O1xuXG5mdW5jdGlvbiByZXF1aXJlSXNPYmplY3QgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJc09iamVjdCkgcmV0dXJuIGlzT2JqZWN0XzE7XG5cdGhhc1JlcXVpcmVkSXNPYmplY3QgPSAxO1xuXHRmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuXHQgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHQgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG5cdH1cblxuXHRpc09iamVjdF8xID0gaXNPYmplY3Q7XG5cdHJldHVybiBpc09iamVjdF8xO1xufVxuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuXG52YXIgX2ZyZWVHbG9iYWw7XG52YXIgaGFzUmVxdWlyZWRfZnJlZUdsb2JhbDtcblxuZnVuY3Rpb24gcmVxdWlyZV9mcmVlR2xvYmFsICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2ZyZWVHbG9iYWwpIHJldHVybiBfZnJlZUdsb2JhbDtcblx0aGFzUmVxdWlyZWRfZnJlZUdsb2JhbCA9IDE7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGNvbW1vbmpzR2xvYmFsO1xuXG5cdF9mcmVlR2xvYmFsID0gZnJlZUdsb2JhbDtcblx0cmV0dXJuIF9mcmVlR2xvYmFsO1xufVxuXG52YXIgX3Jvb3Q7XG52YXIgaGFzUmVxdWlyZWRfcm9vdDtcblxuZnVuY3Rpb24gcmVxdWlyZV9yb290ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX3Jvb3QpIHJldHVybiBfcm9vdDtcblx0aGFzUmVxdWlyZWRfcm9vdCA9IDE7XG5cdHZhciBmcmVlR2xvYmFsID0gcmVxdWlyZV9mcmVlR2xvYmFsKCk7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cblx0dmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cblx0LyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG5cdHZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cdF9yb290ID0gcm9vdDtcblx0cmV0dXJuIF9yb290O1xufVxuXG52YXIgbm93XzE7XG52YXIgaGFzUmVxdWlyZWROb3c7XG5cbmZ1bmN0aW9uIHJlcXVpcmVOb3cgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWROb3cpIHJldHVybiBub3dfMTtcblx0aGFzUmVxdWlyZWROb3cgPSAxO1xuXHR2YXIgcm9vdCA9IHJlcXVpcmVfcm9vdCgpO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSB0aW1lc3RhbXAgb2YgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIGVsYXBzZWQgc2luY2Vcblx0ICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDIuNC4wXG5cdCAqIEBjYXRlZ29yeSBEYXRlXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuXHQgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG5cdCAqIH0sIF8ubm93KCkpO1xuXHQgKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuXHQgKi9cblx0dmFyIG5vdyA9IGZ1bmN0aW9uKCkge1xuXHQgIHJldHVybiByb290LkRhdGUubm93KCk7XG5cdH07XG5cblx0bm93XzEgPSBub3c7XG5cdHJldHVybiBub3dfMTtcbn1cblxuLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG5cbnZhciBfdHJpbW1lZEVuZEluZGV4O1xudmFyIGhhc1JlcXVpcmVkX3RyaW1tZWRFbmRJbmRleDtcblxuZnVuY3Rpb24gcmVxdWlyZV90cmltbWVkRW5kSW5kZXggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfdHJpbW1lZEVuZEluZGV4KSByZXR1cm4gX3RyaW1tZWRFbmRJbmRleDtcblx0aGFzUmVxdWlyZWRfdHJpbW1lZEVuZEluZGV4ID0gMTtcblx0dmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG5cdC8qKlxuXHQgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG5cdCAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cblx0ICovXG5cdGZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcblx0ICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG5cdCAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuXHQgIHJldHVybiBpbmRleDtcblx0fVxuXG5cdF90cmltbWVkRW5kSW5kZXggPSB0cmltbWVkRW5kSW5kZXg7XG5cdHJldHVybiBfdHJpbW1lZEVuZEluZGV4O1xufVxuXG52YXIgX2Jhc2VUcmltO1xudmFyIGhhc1JlcXVpcmVkX2Jhc2VUcmltO1xuXG5mdW5jdGlvbiByZXF1aXJlX2Jhc2VUcmltICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Jhc2VUcmltKSByZXR1cm4gX2Jhc2VUcmltO1xuXHRoYXNSZXF1aXJlZF9iYXNlVHJpbSA9IDE7XG5cdHZhciB0cmltbWVkRW5kSW5kZXggPSByZXF1aXJlX3RyaW1tZWRFbmRJbmRleCgpO1xuXG5cdC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cblx0dmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuXHQgIHJldHVybiBzdHJpbmdcblx0ICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG5cdCAgICA6IHN0cmluZztcblx0fVxuXG5cdF9iYXNlVHJpbSA9IGJhc2VUcmltO1xuXHRyZXR1cm4gX2Jhc2VUcmltO1xufVxuXG52YXIgX1N5bWJvbDtcbnZhciBoYXNSZXF1aXJlZF9TeW1ib2w7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfU3ltYm9sICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX1N5bWJvbCkgcmV0dXJuIF9TeW1ib2w7XG5cdGhhc1JlcXVpcmVkX1N5bWJvbCA9IDE7XG5cdHZhciByb290ID0gcmVxdWlyZV9yb290KCk7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRfU3ltYm9sID0gU3ltYm9sO1xuXHRyZXR1cm4gX1N5bWJvbDtcbn1cblxudmFyIF9nZXRSYXdUYWc7XG52YXIgaGFzUmVxdWlyZWRfZ2V0UmF3VGFnO1xuXG5mdW5jdGlvbiByZXF1aXJlX2dldFJhd1RhZyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9nZXRSYXdUYWcpIHJldHVybiBfZ2V0UmF3VGFnO1xuXHRoYXNSZXF1aXJlZF9nZXRSYXdUYWcgPSAxO1xuXHR2YXIgU3ltYm9sID0gcmVxdWlyZV9TeW1ib2woKTtcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIHJlc29sdmUgdGhlXG5cdCAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuXHQgKiBvZiB2YWx1ZXMuXG5cdCAqL1xuXHR2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuXHQvKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cblx0dmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG5cdC8qKlxuXHQgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcblx0ICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG5cdCAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuXHQgIHRyeSB7XG5cdCAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG5cdCAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cblx0ICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdCAgaWYgKHVubWFza2VkKSB7XG5cdCAgICBpZiAoaXNPd24pIHtcblx0ICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblx0ICAgIH1cblx0ICB9XG5cdCAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdF9nZXRSYXdUYWcgPSBnZXRSYXdUYWc7XG5cdHJldHVybiBfZ2V0UmF3VGFnO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cbnZhciBfb2JqZWN0VG9TdHJpbmc7XG52YXIgaGFzUmVxdWlyZWRfb2JqZWN0VG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfb2JqZWN0VG9TdHJpbmcgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfb2JqZWN0VG9TdHJpbmcpIHJldHVybiBfb2JqZWN0VG9TdHJpbmc7XG5cdGhhc1JlcXVpcmVkX29iamVjdFRvU3RyaW5nID0gMTtcblx0dmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuXHQvKipcblx0ICogVXNlZCB0byByZXNvbHZlIHRoZVxuXHQgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcblx0ICogb2YgdmFsdWVzLlxuXHQgKi9cblx0dmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcblx0ICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cdH1cblxuXHRfb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RUb1N0cmluZztcblx0cmV0dXJuIF9vYmplY3RUb1N0cmluZztcbn1cblxudmFyIF9iYXNlR2V0VGFnO1xudmFyIGhhc1JlcXVpcmVkX2Jhc2VHZXRUYWc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYmFzZUdldFRhZyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9iYXNlR2V0VGFnKSByZXR1cm4gX2Jhc2VHZXRUYWc7XG5cdGhhc1JlcXVpcmVkX2Jhc2VHZXRUYWcgPSAxO1xuXHR2YXIgU3ltYm9sID0gcmVxdWlyZV9TeW1ib2woKSxcblx0ICAgIGdldFJhd1RhZyA9IHJlcXVpcmVfZ2V0UmF3VGFnKCksXG5cdCAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmVfb2JqZWN0VG9TdHJpbmcoKTtcblxuXHQvKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG5cdHZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuXHQgICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cblx0LyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG5cdHZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG5cdCAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcblx0ICB9XG5cdCAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuXHQgICAgPyBnZXRSYXdUYWcodmFsdWUpXG5cdCAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcblx0fVxuXG5cdF9iYXNlR2V0VGFnID0gYmFzZUdldFRhZztcblx0cmV0dXJuIF9iYXNlR2V0VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNPYmplY3RMaWtlXzE7XG52YXIgaGFzUmVxdWlyZWRJc09iamVjdExpa2U7XG5cbmZ1bmN0aW9uIHJlcXVpcmVJc09iamVjdExpa2UgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJc09iamVjdExpa2UpIHJldHVybiBpc09iamVjdExpa2VfMTtcblx0aGFzUmVxdWlyZWRJc09iamVjdExpa2UgPSAxO1xuXHRmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcblx0ICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG5cdH1cblxuXHRpc09iamVjdExpa2VfMSA9IGlzT2JqZWN0TGlrZTtcblx0cmV0dXJuIGlzT2JqZWN0TGlrZV8xO1xufVxuXG52YXIgaXNTeW1ib2xfMTtcbnZhciBoYXNSZXF1aXJlZElzU3ltYm9sO1xuXG5mdW5jdGlvbiByZXF1aXJlSXNTeW1ib2wgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRJc1N5bWJvbCkgcmV0dXJuIGlzU3ltYm9sXzE7XG5cdGhhc1JlcXVpcmVkSXNTeW1ib2wgPSAxO1xuXHR2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmVfYmFzZUdldFRhZygpLFxuXHQgICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZUlzT2JqZWN0TGlrZSgpO1xuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzU3ltYm9sKCdhYmMnKTtcblx0ICogLy8gPT4gZmFsc2Vcblx0ICovXG5cdGZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG5cdCAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuXHQgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcblx0fVxuXG5cdGlzU3ltYm9sXzEgPSBpc1N5bWJvbDtcblx0cmV0dXJuIGlzU3ltYm9sXzE7XG59XG5cbnZhciB0b051bWJlcl8xO1xudmFyIGhhc1JlcXVpcmVkVG9OdW1iZXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVUb051bWJlciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFRvTnVtYmVyKSByZXR1cm4gdG9OdW1iZXJfMTtcblx0aGFzUmVxdWlyZWRUb051bWJlciA9IDE7XG5cdHZhciBiYXNlVHJpbSA9IHJlcXVpcmVfYmFzZVRyaW0oKSxcblx0ICAgIGlzT2JqZWN0ID0gcmVxdWlyZUlzT2JqZWN0KCksXG5cdCAgICBpc1N5bWJvbCA9IHJlcXVpcmVJc1N5bWJvbCgpO1xuXG5cdC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuXHR2YXIgTkFOID0gMCAvIDA7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG5cdHZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuXHR2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuXHQvKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuXHR2YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDQuMC4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy50b051bWJlcigzLjIpO1xuXHQgKiAvLyA9PiAzLjJcblx0ICpcblx0ICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcblx0ICogLy8gPT4gNWUtMzI0XG5cdCAqXG5cdCAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuXHQgKiAvLyA9PiBJbmZpbml0eVxuXHQgKlxuXHQgKiBfLnRvTnVtYmVyKCczLjInKTtcblx0ICogLy8gPT4gMy4yXG5cdCAqL1xuXHRmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIE5BTjtcblx0ICB9XG5cdCAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuXHQgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuXHQgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcblx0ICB9XG5cdCAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuXHQgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG5cdCAgfVxuXHQgIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuXHQgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG5cdCAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG5cdCAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcblx0ICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuXHR9XG5cblx0dG9OdW1iZXJfMSA9IHRvTnVtYmVyO1xuXHRyZXR1cm4gdG9OdW1iZXJfMTtcbn1cblxudmFyIGRlYm91bmNlXzE7XG52YXIgaGFzUmVxdWlyZWREZWJvdW5jZTtcblxuZnVuY3Rpb24gcmVxdWlyZURlYm91bmNlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRGVib3VuY2UpIHJldHVybiBkZWJvdW5jZV8xO1xuXHRoYXNSZXF1aXJlZERlYm91bmNlID0gMTtcblx0dmFyIGlzT2JqZWN0ID0gcmVxdWlyZUlzT2JqZWN0KCksXG5cdCAgICBub3cgPSByZXF1aXJlTm93KCksXG5cdCAgICB0b051bWJlciA9IHJlcXVpcmVUb051bWJlcigpO1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cblx0dmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuXHQvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG5cdHZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcblx0ICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcblx0ICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG5cdCAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcblx0ICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG5cdCAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuXHQgKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG5cdCAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcblx0ICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2Bcblx0ICogaW52b2NhdGlvbi5cblx0ICpcblx0ICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuXHQgKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuXHQgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG5cdCAqXG5cdCAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuXHQgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG5cdCAqXG5cdCAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuXHQgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cblx0ICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG5cdCAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuXHQgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuXHQgKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuXHQgKlxuXHQgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cblx0ICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuXHQgKiAgICdsZWFkaW5nJzogdHJ1ZSxcblx0ICogICAndHJhaWxpbmcnOiBmYWxzZVxuXHQgKiB9KSk7XG5cdCAqXG5cdCAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG5cdCAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuXHQgKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG5cdCAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcblx0ICpcblx0ICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cblx0ICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG5cdCAqL1xuXHRmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG5cdCAgdmFyIGxhc3RBcmdzLFxuXHQgICAgICBsYXN0VGhpcyxcblx0ICAgICAgbWF4V2FpdCxcblx0ICAgICAgcmVzdWx0LFxuXHQgICAgICB0aW1lcklkLFxuXHQgICAgICBsYXN0Q2FsbFRpbWUsXG5cdCAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcblx0ICAgICAgbGVhZGluZyA9IGZhbHNlLFxuXHQgICAgICBtYXhpbmcgPSBmYWxzZSxcblx0ICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG5cdCAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcblx0ICB9XG5cdCAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG5cdCAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG5cdCAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG5cdCAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcblx0ICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG5cdCAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuXHQgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcblx0ICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cblx0ICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG5cdCAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG5cdCAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG5cdCAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuXHQgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuXHQgICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cblx0ICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG5cdCAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cblx0ICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcblx0ICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG5cdCAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcblx0ICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuXHQgICAgcmV0dXJuIG1heGluZ1xuXHQgICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG5cdCAgICAgIDogdGltZVdhaXRpbmc7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcblx0ICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG5cdCAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuXHQgICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcblx0ICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG5cdCAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG5cdCAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuXHQgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcblx0ICAgIHZhciB0aW1lID0gbm93KCk7XG5cdCAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG5cdCAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG5cdCAgICB9XG5cdCAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cblx0ICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcblx0ICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cblx0ICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cblx0ICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuXHQgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG5cdCAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuXHQgICAgfVxuXHQgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gY2FuY2VsKCkge1xuXHQgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG5cdCAgICB9XG5cdCAgICBsYXN0SW52b2tlVGltZSA9IDA7XG5cdCAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBmbHVzaCgpIHtcblx0ICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcblx0ICAgIHZhciB0aW1lID0gbm93KCksXG5cdCAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuXHQgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG5cdCAgICBsYXN0VGhpcyA9IHRoaXM7XG5cdCAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG5cdCAgICBpZiAoaXNJbnZva2luZykge1xuXHQgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKG1heGluZykge1xuXHQgICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG5cdCAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuXHQgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG5cdCAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0ICB9XG5cdCAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcblx0ICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcblx0ICByZXR1cm4gZGVib3VuY2VkO1xuXHR9XG5cblx0ZGVib3VuY2VfMSA9IGRlYm91bmNlO1xuXHRyZXR1cm4gZGVib3VuY2VfMTtcbn1cblxudmFyIGRlYm91bmNlRXhwb3J0cyA9IHJlcXVpcmVEZWJvdW5jZSgpO1xudmFyIGRlYm91bmNlID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGRlYm91bmNlRXhwb3J0cyk7XG5cbnZhciBwZXJmb3JtYW5jZSQxID0gX3dpbmRvdyA/IF93aW5kb3cucGVyZm9ybWFuY2UgOiBudWxsO1xudmFyIHBub3cgPSBwZXJmb3JtYW5jZSQxICYmIHBlcmZvcm1hbmNlJDEubm93ID8gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcGVyZm9ybWFuY2UkMS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcbnZhciByYWYgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfd2luZG93KSB7XG4gICAgaWYgKF93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIF93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICBfd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX3dpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgX3dpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF93aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgX3dpbmRvdy5tc1JlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKGZuKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm4ocG5vdygpKTtcbiAgICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgfVxuICB9O1xufSgpO1xudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbikge1xuICByZXR1cm4gcmFmKGZuKTtcbn07XG52YXIgcGVyZm9ybWFuY2VOb3cgPSBwbm93O1xuXG52YXIgREVGQVVMVF9IQVNIX1NFRUQgPSA5MjYxO1xudmFyIEsgPSA2NTU5OTsgLy8gMzcgYWxzbyB3b3JrcyBwcmV0dHkgd2VsbFxudmFyIERFRkFVTFRfSEFTSF9TRUVEX0FMVCA9IDUzODE7XG52YXIgaGFzaEl0ZXJhYmxlSW50cyA9IGZ1bmN0aW9uIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IpIHtcbiAgdmFyIHNlZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IERFRkFVTFRfSEFTSF9TRUVEO1xuICAvLyBzZGJtL3N0cmluZy1oYXNoXG4gIHZhciBoYXNoID0gc2VlZDtcbiAgdmFyIGVudHJ5O1xuICBmb3IgKDs7KSB7XG4gICAgZW50cnkgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKGVudHJ5LmRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBoYXNoID0gaGFzaCAqIEsgKyBlbnRyeS52YWx1ZSB8IDA7XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59O1xudmFyIGhhc2hJbnQgPSBmdW5jdGlvbiBoYXNoSW50KG51bSkge1xuICB2YXIgc2VlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogREVGQVVMVF9IQVNIX1NFRUQ7XG4gIC8vIHNkYm0vc3RyaW5nLWhhc2hcbiAgcmV0dXJuIHNlZWQgKiBLICsgbnVtIHwgMDtcbn07XG52YXIgaGFzaEludEFsdCA9IGZ1bmN0aW9uIGhhc2hJbnRBbHQobnVtKSB7XG4gIHZhciBzZWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX0hBU0hfU0VFRF9BTFQ7XG4gIC8vIGRqYjIvc3RyaW5nLWhhc2hcbiAgcmV0dXJuIChzZWVkIDw8IDUpICsgc2VlZCArIG51bSB8IDA7XG59O1xudmFyIGNvbWJpbmVIYXNoZXMgPSBmdW5jdGlvbiBjb21iaW5lSGFzaGVzKGhhc2gxLCBoYXNoMikge1xuICByZXR1cm4gaGFzaDEgKiAweDIwMDAwMCArIGhhc2gyO1xufTtcbnZhciBjb21iaW5lSGFzaGVzQXJyYXkgPSBmdW5jdGlvbiBjb21iaW5lSGFzaGVzQXJyYXkoaGFzaGVzKSB7XG4gIHJldHVybiBoYXNoZXNbMF0gKiAweDIwMDAwMCArIGhhc2hlc1sxXTtcbn07XG52YXIgaGFzaEFycmF5cyA9IGZ1bmN0aW9uIGhhc2hBcnJheXMoaGFzaGVzMSwgaGFzaGVzMikge1xuICByZXR1cm4gW2hhc2hJbnQoaGFzaGVzMVswXSwgaGFzaGVzMlswXSksIGhhc2hJbnRBbHQoaGFzaGVzMVsxXSwgaGFzaGVzMlsxXSldO1xufTtcbnZhciBoYXNoSW50c0FycmF5ID0gZnVuY3Rpb24gaGFzaEludHNBcnJheShpbnRzLCBzZWVkKSB7XG4gIHZhciBlbnRyeSA9IHtcbiAgICB2YWx1ZTogMCxcbiAgICBkb25lOiBmYWxzZVxuICB9O1xuICB2YXIgaSA9IDA7XG4gIHZhciBsZW5ndGggPSBpbnRzLmxlbmd0aDtcbiAgdmFyIGl0ZXJhdG9yID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBpZiAoaSA8IGxlbmd0aCkge1xuICAgICAgICBlbnRyeS52YWx1ZSA9IGludHNbaSsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5LmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJ5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhhc2hJdGVyYWJsZUludHMoaXRlcmF0b3IsIHNlZWQpO1xufTtcbnZhciBoYXNoU3RyaW5nID0gZnVuY3Rpb24gaGFzaFN0cmluZyhzdHIsIHNlZWQpIHtcbiAgdmFyIGVudHJ5ID0ge1xuICAgIHZhbHVlOiAwLFxuICAgIGRvbmU6IGZhbHNlXG4gIH07XG4gIHZhciBpID0gMDtcbiAgdmFyIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIHZhciBpdGVyYXRvciA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSBzdHIuY2hhckNvZGVBdChpKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW50cnkuZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFzaEl0ZXJhYmxlSW50cyhpdGVyYXRvciwgc2VlZCk7XG59O1xudmFyIGhhc2hTdHJpbmdzID0gZnVuY3Rpb24gaGFzaFN0cmluZ3MoKSB7XG4gIHJldHVybiBoYXNoU3RyaW5nc0FycmF5KGFyZ3VtZW50cyk7XG59O1xudmFyIGhhc2hTdHJpbmdzQXJyYXkgPSBmdW5jdGlvbiBoYXNoU3RyaW5nc0FycmF5KHN0cnMpIHtcbiAgdmFyIGhhc2g7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdHIgPSBzdHJzW2ldO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNoID0gaGFzaFN0cmluZyhzdHIsIGhhc2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHJvdGF0ZVBvaW50KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGFuZ2xlRGVncmVlcykge1xuICB2YXIgYW5nbGVSYWRpYW5zID0gYW5nbGVEZWdyZWVzICogTWF0aC5QSSAvIDE4MDtcbiAgdmFyIHJvdGF0ZWRYID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSAqICh4IC0gY2VudGVyWCkgLSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpICogKHkgLSBjZW50ZXJZKSArIGNlbnRlclg7XG4gIHZhciByb3RhdGVkWSA9IE1hdGguc2luKGFuZ2xlUmFkaWFucykgKiAoeCAtIGNlbnRlclgpICsgTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSAqICh5IC0gY2VudGVyWSkgKyBjZW50ZXJZO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdGF0ZWRYLFxuICAgIHk6IHJvdGF0ZWRZXG4gIH07XG59XG52YXIgbW92ZVBvaW50QnlCb3hBc3BlY3QgPSBmdW5jdGlvbiBtb3ZlUG9pbnRCeUJveEFzcGVjdCh4LCB5LCBib3hYLCBib3hZLCBza2V3WCwgc2tld1kpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiAoeCAtIGJveFgpICogc2tld1ggKyBib3hYLFxuICAgIHk6ICh5IC0gYm94WSkgKiBza2V3WSArIGJveFlcbiAgfTtcbn07XG5mdW5jdGlvbiByb3RhdGVQb3NBbmRTa2V3QnlCb3gocG9zLCBib3gsIGFuZ2xlRGVncmVlcykge1xuICBpZiAoYW5nbGVEZWdyZWVzID09PSAwKSByZXR1cm4gcG9zO1xuICB2YXIgY2VudGVyWCA9IChib3gueDEgKyBib3gueDIpIC8gMjtcbiAgdmFyIGNlbnRlclkgPSAoYm94LnkxICsgYm94LnkyKSAvIDI7XG4gIHZhciBza2V3WCA9IGJveC53IC8gYm94Lmg7XG4gIHZhciBza2V3WSA9IDEgLyBza2V3WDtcbiAgdmFyIHJvdGF0ZWQgPSByb3RhdGVQb2ludChwb3MueCwgcG9zLnksIGNlbnRlclgsIGNlbnRlclksIGFuZ2xlRGVncmVlcyk7XG4gIHZhciBza2V3ZWQgPSBtb3ZlUG9pbnRCeUJveEFzcGVjdChyb3RhdGVkLngsIHJvdGF0ZWQueSwgY2VudGVyWCwgY2VudGVyWSwgc2tld1gsIHNrZXdZKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBza2V3ZWQueCxcbiAgICB5OiBza2V3ZWQueVxuICB9O1xufVxuXG52YXIgd2FybmluZ3NFbmFibGVkID0gdHJ1ZTtcbnZhciB3YXJuU3VwcG9ydGVkID0gY29uc29sZS53YXJuICE9IG51bGw7XG52YXIgdHJhY2VTdXBwb3J0ZWQgPSBjb25zb2xlLnRyYWNlICE9IG51bGw7XG52YXIgTUFYX0lOVCQxID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTtcbnZhciB0cnVlaWZ5ID0gZnVuY3Rpb24gdHJ1ZWlmeSgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGZhbHNpZnkgPSBmdW5jdGlvbiBmYWxzaWZ5KCkge1xuICByZXR1cm4gZmFsc2U7XG59O1xudmFyIHplcm9pZnkgPSBmdW5jdGlvbiB6ZXJvaWZ5KCkge1xuICByZXR1cm4gMDtcbn07XG52YXIgbm9vcCQxID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xudmFyIGVycm9yID0gZnVuY3Rpb24gZXJyb3IobXNnKSB7XG4gIHRocm93IG5ldyBFcnJvcihtc2cpO1xufTtcbnZhciB3YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKGVuYWJsZWQpIHtcbiAgaWYgKGVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHdhcm5pbmdzRW5hYmxlZCA9ICEhZW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gd2FybmluZ3NFbmFibGVkO1xuICB9XG59O1xudmFyIHdhcm4gPSBmdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAoIXdhcm5pbmdzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdhcm5TdXBwb3J0ZWQpIHtcbiAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhtc2cpO1xuICAgIGlmICh0cmFjZVN1cHBvcnRlZCkge1xuICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBjbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICByZXR1cm4gZXh0ZW5kKHt9LCBvYmopO1xufTtcblxuLy8gZ2V0cyBhIHNoYWxsb3cgY29weSBvZiB0aGUgYXJndW1lbnRcbnZhciBjb3B5ID0gZnVuY3Rpb24gY29weShvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAoYXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIGNsb25lKG9iaik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcbnZhciBjb3B5QXJyYXkgPSBmdW5jdGlvbiBjb3B5QXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnIuc2xpY2UoKTtcbn07XG52YXIgdXVpZCA9IGZ1bmN0aW9uIHV1aWQoYSwgYiAvKiBwbGFjZWhvbGRlcnMgKi8pIHtcbiAgZm9yIChcbiAgLy8gbG9vcCA6KVxuICBiID0gYSA9ICcnO1xuICAvLyBiIC0gcmVzdWx0ICwgYSAtIG51bWVyaWMgbGV0aWFibGVcbiAgYSsrIDwgMzY7XG4gIC8vXG4gIGIgKz0gYSAqIDUxICYgNTIgLy8gaWYgXCJhXCIgaXMgbm90IDkgb3IgMTQgb3IgMTkgb3IgMjRcbiAgP1xuICAvLyAgcmV0dXJuIGEgcmFuZG9tIG51bWJlciBvciA0XG4gIChhIF4gMTUgLy8gaWYgXCJhXCIgaXMgbm90IDE1XG4gID9cbiAgLy8gZ2VuZXJhdGUgYSByYW5kb20gbnVtYmVyIGZyb20gMCB0byAxNVxuICA4IF4gTWF0aC5yYW5kb20oKSAqIChhIF4gMjAgPyAxNiA6IDQpIC8vIHVubGVzcyBcImFcIiBpcyAyMCwgaW4gd2hpY2ggY2FzZSBhIHJhbmRvbSBudW1iZXIgZnJvbSA4IHRvIDExXG4gIDogNCAvLyAgb3RoZXJ3aXNlIDRcbiAgKS50b1N0cmluZygxNikgOiAnLScgLy8gIGluIG90aGVyIGNhc2VzIChpZiBcImFcIiBpcyA5LDE0LDE5LDI0KSBpbnNlcnQgXCItXCJcbiAgKTtcbiAgcmV0dXJuIGI7XG59O1xudmFyIF9zdGF0aWNFbXB0eU9iamVjdCA9IHt9O1xudmFyIHN0YXRpY0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24gc3RhdGljRW1wdHlPYmplY3QoKSB7XG4gIHJldHVybiBfc3RhdGljRW1wdHlPYmplY3Q7XG59O1xudmFyIGRlZmF1bHRzJGcgPSBmdW5jdGlvbiBkZWZhdWx0cyhfZGVmYXVsdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhfZGVmYXVsdHMpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICB2YXIgZmlsbGVkT3B0cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgb3B0VmFsID0gb3B0cyA9PSBudWxsID8gdW5kZWZpbmVkIDogb3B0c1trZXldO1xuICAgICAgZmlsbGVkT3B0c1trZXldID0gb3B0VmFsID09PSB1bmRlZmluZWQgPyBfZGVmYXVsdHNba2V5XSA6IG9wdFZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxlZE9wdHM7XG4gIH07XG59O1xudmFyIHJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uIHJlbW92ZUZyb21BcnJheShhcnIsIGVsZSwgb25lQ29weSkge1xuICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGFycltpXSA9PT0gZWxlKSB7XG4gICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufTtcbnZhciBjbGVhckFycmF5ID0gZnVuY3Rpb24gY2xlYXJBcnJheShhcnIpIHtcbiAgYXJyLnNwbGljZSgwLCBhcnIubGVuZ3RoKTtcbn07XG52YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2goYXJyLCBvdGhlckFycikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gb3RoZXJBcnJbaV07XG4gICAgYXJyLnB1c2goZWwpO1xuICB9XG59O1xudmFyIGdldFByZWZpeGVkUHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcmVmaXhlZFByb3BlcnR5KG9iaiwgcHJvcE5hbWUsIHByZWZpeCkge1xuICBpZiAocHJlZml4KSB7XG4gICAgcHJvcE5hbWUgPSBwcmVwZW5kQ2FtZWwocHJlZml4LCBwcm9wTmFtZSk7IC8vIGUuZy4gKGxhYmVsV2lkdGgsIHNvdXJjZSkgPT4gc291cmNlTGFiZWxXaWR0aFxuICB9XG4gIHJldHVybiBvYmpbcHJvcE5hbWVdO1xufTtcbnZhciBzZXRQcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJlZml4ZWRQcm9wZXJ0eShvYmosIHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKSB7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcm9wTmFtZSA9IHByZXBlbmRDYW1lbChwcmVmaXgsIHByb3BOYW1lKTsgLy8gZS5nLiAobGFiZWxXaWR0aCwgc291cmNlKSA9PiBzb3VyY2VMYWJlbFdpZHRoXG4gIH1cbiAgb2JqW3Byb3BOYW1lXSA9IHZhbHVlO1xufTtcblxuLyogZ2xvYmFsIE1hcCAqL1xudmFyIE9iamVjdE1hcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE9iamVjdE1hcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT2JqZWN0TWFwKTtcbiAgICB0aGlzLl9vYmogPSB7fTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE9iamVjdE1hcCwgW3tcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbCkge1xuICAgICAgdGhpcy5fb2JqW2tleV0gPSB2YWw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWxldGUoa2V5KSB7XG4gICAgICB0aGlzLl9vYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX29iaiA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX29ialtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW2tleV07XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgTWFwJDEgPSB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyA/IE1hcCA6IE9iamVjdE1hcDtcblxuLyogZ2xvYmFsIFNldCAqL1xuXG52YXIgdW5kZWYgPSBcInVuZGVmaW5lZFwiIDtcbnZhciBPYmplY3RTZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYmplY3RTZXQoYXJyYXlPck9iamVjdFNldCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPYmplY3RTZXQpO1xuICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICBpZiAoYXJyYXlPck9iamVjdFNldCAhPSBudWxsKSB7XG4gICAgICB2YXIgYXJyO1xuICAgICAgaWYgKGFycmF5T3JPYmplY3RTZXQuaW5zdGFuY2VTdHJpbmcgIT0gbnVsbCAmJiBhcnJheU9yT2JqZWN0U2V0Lmluc3RhbmNlU3RyaW5nKCkgPT09IHRoaXMuaW5zdGFuY2VTdHJpbmcoKSkge1xuICAgICAgICBhcnIgPSBhcnJheU9yT2JqZWN0U2V0LnRvQXJyYXkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFyciA9IGFycmF5T3JPYmplY3RTZXQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFkZChhcnJbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE9iamVjdFNldCwgW3tcbiAgICBrZXk6IFwiaW5zdGFuY2VTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ3NldCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQodmFsKSB7XG4gICAgICB2YXIgbyA9IHRoaXMuX29iajtcbiAgICAgIGlmIChvW3ZhbF0gIT09IDEpIHtcbiAgICAgICAgb1t2YWxdID0gMTtcbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKHZhbCkge1xuICAgICAgdmFyIG8gPSB0aGlzLl9vYmo7XG4gICAgICBpZiAob1t2YWxdID09PSAxKSB7XG4gICAgICAgIG9bdmFsXSA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZS0tO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX29iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXModmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqW3ZhbF0gPT09IDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fb2JqKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gX3RoaXMuaGFzKGtleSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FycmF5KCkuZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgfVxuICB9XSk7XG59KCk7XG52YXIgU2V0JDEgPSAodHlwZW9mIFNldCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKFNldCkpICE9PSB1bmRlZiA/IFNldCA6IE9iamVjdFNldDtcblxuLy8gcmVwcmVzZW50cyBhIG5vZGUgb3IgYW4gZWRnZVxudmFyIEVsZW1lbnQgPSBmdW5jdGlvbiBFbGVtZW50KGN5LCBwYXJhbXMpIHtcbiAgdmFyIHJlc3RvcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIGlmIChjeSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICFjb3JlKGN5KSkge1xuICAgIGVycm9yKCdBbiBlbGVtZW50IG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlIGFuZCBwYXJhbWV0ZXJzIHNldCcpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZ3JvdXAgPSBwYXJhbXMuZ3JvdXA7XG5cbiAgLy8gdHJ5IHRvIGF1dG9tYXRpY2FsbHkgaW5mZXIgdGhlIGdyb3VwIGlmIHVuc3BlY2lmaWVkXG4gIGlmIChncm91cCA9PSBudWxsKSB7XG4gICAgaWYgKHBhcmFtcy5kYXRhICYmIHBhcmFtcy5kYXRhLnNvdXJjZSAhPSBudWxsICYmIHBhcmFtcy5kYXRhLnRhcmdldCAhPSBudWxsKSB7XG4gICAgICBncm91cCA9ICdlZGdlcyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwID0gJ25vZGVzJztcbiAgICB9XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBncm91cFxuICBpZiAoZ3JvdXAgIT09ICdub2RlcycgJiYgZ3JvdXAgIT09ICdlZGdlcycpIHtcbiAgICBlcnJvcignQW4gZWxlbWVudCBtdXN0IGJlIG9mIHR5cGUgYG5vZGVzYCBvciBgZWRnZXNgOyB5b3Ugc3BlY2lmaWVkIGAnICsgZ3JvdXAgKyAnYCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIG1ha2UgdGhlIGVsZW1lbnQgYXJyYXktbGlrZSwganVzdCBsaWtlIGEgY29sbGVjdGlvblxuICB0aGlzLmxlbmd0aCA9IDE7XG4gIHRoaXNbMF0gPSB0aGlzO1xuXG4gIC8vIE5PVEU6IHdoZW4gc29tZXRoaW5nIGlzIGFkZGVkIGhlcmUsIGFkZCBhbHNvIHRvIGVsZS5qc29uKClcbiAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICBjeTogY3ksXG4gICAgc2luZ2xlOiB0cnVlLFxuICAgIC8vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVsZW1lbnRcbiAgICBkYXRhOiBwYXJhbXMuZGF0YSB8fCB7fSxcbiAgICAvLyBkYXRhIG9iamVjdFxuICAgIHBvc2l0aW9uOiBwYXJhbXMucG9zaXRpb24gfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIC8vICh4LCB5KSBwb3NpdGlvbiBwYWlyXG4gICAgYXV0b1dpZHRoOiB1bmRlZmluZWQsXG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiBub2RlcyBjYWxjdWxhdGVkIGJ5IHRoZSByZW5kZXJlciB3aGVuIHNldCB0byBzcGVjaWFsICdhdXRvJyB2YWx1ZVxuICAgIGF1dG9IZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBhdXRvUGFkZGluZzogdW5kZWZpbmVkLFxuICAgIGNvbXBvdW5kQm91bmRzQ2xlYW46IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGNvbXBvdW5kIGRpbWVuc2lvbnMgbmVlZCB0byBiZSByZWNhbGN1bGF0ZWQgdGhlIG5leHQgdGltZSBkaW1lbnNpb25zIGFyZSByZWFkXG4gICAgbGlzdGVuZXJzOiBbXSxcbiAgICAvLyBhcnJheSBvZiBib3VuZCBsaXN0ZW5lcnNcbiAgICBncm91cDogZ3JvdXAsXG4gICAgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICBzdHlsZToge30sXG4gICAgLy8gcHJvcGVydGllcyBhcyBzZXQgYnkgdGhlIHN0eWxlXG4gICAgcnN0eWxlOiB7fSxcbiAgICAvLyBwcm9wZXJ0aWVzIGZvciBzdHlsZSBzZW50IGZyb20gdGhlIHJlbmRlcmVyIHRvIHRoZSBjb3JlXG4gICAgc3R5bGVDeHRzOiBbXSxcbiAgICAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgIHN0eWxlS2V5czoge30sXG4gICAgLy8gcGVyLWdyb3VwIGtleXMgb2Ygc3R5bGUgcHJvcGVydHkgdmFsdWVzXG4gICAgcmVtb3ZlZDogdHJ1ZSxcbiAgICAvLyB3aGV0aGVyIGl0J3MgaW5zaWRlIHRoZSB2aXM7IHRydWUgaWYgcmVtb3ZlZCAoc2V0IHRydWUgaGVyZSBzaW5jZSB3ZSBjYWxsIHJlc3RvcmUpXG4gICAgc2VsZWN0ZWQ6IHBhcmFtcy5zZWxlY3RlZCA/IHRydWUgOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0ZWRcbiAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy5zZWxlY3RhYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgaXQncyBzZWxlY3RhYmxlXG4gICAgbG9ja2VkOiBwYXJhbXMubG9ja2VkID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgbG9ja2VkIChjYW5ub3QgYmUgbW92ZWQpXG4gICAgZ3JhYmJlZDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBncmFiYmVkIGJ5IHRoZSBtb3VzZTsgcmVuZGVyZXIgc2V0cyB0aGlzIHByaXZhdGVseVxuICAgIGdyYWJiYWJsZTogcGFyYW1zLmdyYWJiYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgIHBhbm5hYmxlOiBwYXJhbXMucGFubmFibGUgPT09IHVuZGVmaW5lZCA/IGdyb3VwID09PSAnZWRnZXMnID8gdHJ1ZSA6IGZhbHNlIDogcGFyYW1zLnBhbm5hYmxlID8gdHJ1ZSA6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHBhc3N0aHJvdWdoIHBhbm5pbmcgZW5hYmxlZFxuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBhY3RpdmUgZnJvbSB1c2VyIGludGVyYWN0aW9uXG4gICAgY2xhc3NlczogbmV3IFNldCQxKCksXG4gICAgLy8gbWFwICggY2xhc3NOYW1lID0+IHRydWUgKVxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgcnNjcmF0Y2g6IHt9LFxuICAgIC8vIG9iamVjdCBpbiB3aGljaCB0aGUgcmVuZGVyZXIgY2FuIHN0b3JlIGluZm9ybWF0aW9uXG4gICAgc2NyYXRjaDogcGFyYW1zLnNjcmF0Y2ggfHwge30sXG4gICAgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgZWRnZXM6IFtdLFxuICAgIC8vIGFycmF5IG9mIGNvbm5lY3RlZCBlZGdlc1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICAvLyBhcnJheSBvZiBjaGlsZHJlblxuICAgIHBhcmVudDogcGFyYW1zLnBhcmVudCAmJiBwYXJhbXMucGFyZW50LmlzTm9kZSgpID8gcGFyYW1zLnBhcmVudCA6IG51bGwsXG4gICAgLy8gcGFyZW50IHJlZlxuICAgIHRyYXZlcnNhbENhY2hlOiB7fSxcbiAgICAvLyBjYWNoZSBvZiBvdXRwdXQgb2YgdHJhdmVyc2FsIGZ1bmN0aW9uc1xuICAgIGJhY2tncm91bmRpbmc6IGZhbHNlLFxuICAgIC8vIHdoZXRoZXIgYmFja2dyb3VuZCBpbWFnZXMgYXJlIGxvYWRpbmdcbiAgICBiYkNhY2hlOiBudWxsLFxuICAgIC8vIGNhY2hlIG9mIHRoZSBjdXJyZW50IGJvdW5kaW5nIGJveFxuICAgIGJiQ2FjaGVTaGlmdDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIC8vIHNoaWZ0IGFwcGxpZWQgdG8gY2FjaGVkIGJiIHRvIGJlIGFwcGxpZWQgb24gbmV4dCBnZXRcbiAgICBib2R5Qm91bmRzOiBudWxsLFxuICAgIC8vIGJvdW5kcyBjYWNoZSBvZiBlbGVtZW50IGJvZHksIHcvbyBvdmVybGF5XG4gICAgb3ZlcmxheUJvdW5kczogbnVsbCxcbiAgICAvLyBib3VuZHMgY2FjaGUgb2YgZWxlbWVudCBib2R5LCBpbmNsdWRpbmcgb3ZlcmxheVxuICAgIGxhYmVsQm91bmRzOiB7XG4gICAgICAvLyBib3VuZHMgY2FjaGUgb2YgbGFiZWxzXG4gICAgICBhbGw6IG51bGwsXG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICBtYWluOiBudWxsXG4gICAgfSxcbiAgICBhcnJvd0JvdW5kczoge1xuICAgICAgLy8gYm91bmRzIGNhY2hlIG9mIGVkZ2UgYXJyb3dzXG4gICAgICBzb3VyY2U6IG51bGwsXG4gICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAnbWlkLXNvdXJjZSc6IG51bGwsXG4gICAgICAnbWlkLXRhcmdldCc6IG51bGxcbiAgICB9XG4gIH07XG4gIGlmIChfcC5wb3NpdGlvbi54ID09IG51bGwpIHtcbiAgICBfcC5wb3NpdGlvbi54ID0gMDtcbiAgfVxuICBpZiAoX3AucG9zaXRpb24ueSA9PSBudWxsKSB7XG4gICAgX3AucG9zaXRpb24ueSA9IDA7XG4gIH1cblxuICAvLyByZW5kZXJlZFBvc2l0aW9uIG92ZXJyaWRlcyBpZiBzcGVjaWZpZWRcbiAgaWYgKHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uKSB7XG4gICAgdmFyIHJwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgX3AucG9zaXRpb24gPSB7XG4gICAgICB4OiAocnBvcy54IC0gcGFuLngpIC8gem9vbSxcbiAgICAgIHk6IChycG9zLnkgLSBwYW4ueSkgLyB6b29tXG4gICAgfTtcbiAgfVxuICB2YXIgY2xhc3NlcyA9IFtdO1xuICBpZiAoYXJyYXkocGFyYW1zLmNsYXNzZXMpKSB7XG4gICAgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzO1xuICB9IGVsc2UgaWYgKHN0cmluZyhwYXJhbXMuY2xhc3NlcykpIHtcbiAgICBjbGFzc2VzID0gcGFyYW1zLmNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNscyA9IGNsYXNzZXNbaV07XG4gICAgaWYgKCFjbHMgfHwgY2xzID09PSAnJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIF9wLmNsYXNzZXMuYWRkKGNscyk7XG4gIH1cbiAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7XG4gIGlmIChyZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSkge1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIHZhciBieXBhc3MgPSBwYXJhbXMuc3R5bGUgfHwgcGFyYW1zLmNzcztcbiAgaWYgKGJ5cGFzcykge1xuICAgIHdhcm4oJ1NldHRpbmcgYSBgc3R5bGVgIGJ5cGFzcyBhdCBlbGVtZW50IGNyZWF0aW9uIHNob3VsZCBiZSBkb25lIG9ubHkgd2hlbiBhYnNvbHV0ZWx5IG5lY2Vzc2FyeS4gIFRyeSB0byB1c2UgdGhlIHN0eWxlc2hlZXQgaW5zdGVhZC4nKTtcbiAgICB0aGlzLnN0eWxlKGJ5cGFzcyk7XG4gIH1cbn07XG5cbnZhciBkZWZpbmVTZWFyY2ggPSBmdW5jdGlvbiBkZWZpbmVTZWFyY2gocGFyYW1zKSB7XG4gIHBhcmFtcyA9IHtcbiAgICBiZnM6IHBhcmFtcy5iZnMgfHwgIXBhcmFtcy5kZnMsXG4gICAgZGZzOiBwYXJhbXMuZGZzIHx8ICFwYXJhbXMuYmZzXG4gIH07XG5cbiAgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYVxuICByZXR1cm4gZnVuY3Rpb24gc2VhcmNoRm4ocm9vdHMsIGZuLCBkaXJlY3RlZCkge1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmIChwbGFpbk9iamVjdChyb290cykgJiYgIWVsZW1lbnRPckNvbGxlY3Rpb24ocm9vdHMpKSB7XG4gICAgICBvcHRpb25zID0gcm9vdHM7XG4gICAgICByb290cyA9IG9wdGlvbnMucm9vdHMgfHwgb3B0aW9ucy5yb290O1xuICAgICAgZm4gPSBvcHRpb25zLnZpc2l0O1xuICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgIH1cbiAgICBkaXJlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgIWZuJDYoZm4pID8gZm4gOiBkaXJlY3RlZDtcbiAgICBmbiA9IGZuJDYoZm4pID8gZm4gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciB2ID0gcm9vdHMgPSBzdHJpbmcocm9vdHMpID8gdGhpcy5maWx0ZXIocm9vdHMpIDogcm9vdHM7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBbXTtcbiAgICB2YXIgY29ubmVjdGVkQnkgPSB7fTtcbiAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICB2YXIgViA9IHt9O1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIgZm91bmQ7XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcblxuICAgIC8vIGVucXVldWUgdlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZpID0gdltpXTtcbiAgICAgIHZhciB2aUlkID0gdmkuaWQoKTtcbiAgICAgIGlmICh2aS5pc05vZGUoKSkge1xuICAgICAgICBRLnVuc2hpZnQodmkpO1xuICAgICAgICBpZiAocGFyYW1zLmJmcykge1xuICAgICAgICAgIFZbdmlJZF0gPSB0cnVlO1xuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2godmkpO1xuICAgICAgICB9XG4gICAgICAgIGlkMmRlcHRoW3ZpSWRdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciB2ID0gcGFyYW1zLmJmcyA/IFEuc2hpZnQoKSA6IFEucG9wKCk7XG4gICAgICAgIHZhciB2SWQgPSB2LmlkKCk7XG4gICAgICAgIGlmIChwYXJhbXMuZGZzKSB7XG4gICAgICAgICAgaWYgKFZbdklkXSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIFZbdklkXSA9IHRydWU7XG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFt2SWRdO1xuICAgICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVt2SWRdO1xuICAgICAgICB2YXIgc3JjID0gcHJldkVkZ2UgIT0gbnVsbCA/IHByZXZFZGdlLnNvdXJjZSgpIDogbnVsbDtcbiAgICAgICAgdmFyIHRndCA9IHByZXZFZGdlICE9IG51bGwgPyBwcmV2RWRnZS50YXJnZXQoKSA6IG51bGw7XG4gICAgICAgIHZhciBwcmV2Tm9kZSA9IHByZXZFZGdlID09IG51bGwgPyB1bmRlZmluZWQgOiB2LnNhbWUoc3JjKSA/IHRndFswXSA6IHNyY1swXTtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgcmV0ID0gZm4odiwgcHJldkVkZ2UsIHByZXZOb2RlLCBqKyssIGRlcHRoKTtcbiAgICAgICAgaWYgKHJldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgICByZXR1cm4gMTsgLy8gYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiAxOyAvLyBicmVha1xuICAgICAgICB9XG4gICAgICAgIHZhciB2d0VkZ2VzID0gdi5jb25uZWN0ZWRFZGdlcygpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiAoIWRpcmVjdGVkIHx8IGUuc291cmNlKCkuc2FtZSh2KSkgJiYgZWRnZXMuaGFzKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdndFZGdlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW19pMl07XG4gICAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gIW4uc2FtZSh2KSAmJiBub2Rlcy5oYXMobik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHdJZCA9IHcuaWQoKTtcbiAgICAgICAgICBpZiAody5sZW5ndGggIT09IDAgJiYgIVZbd0lkXSkge1xuICAgICAgICAgICAgdyA9IHdbMF07XG4gICAgICAgICAgICBRLnB1c2godyk7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmJmcykge1xuICAgICAgICAgICAgICBWW3dJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKHcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29ubmVjdGVkQnlbd0lkXSA9IGU7XG4gICAgICAgICAgICBpZDJkZXB0aFt3SWRdID0gaWQyZGVwdGhbdklkXSArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3JldDtcbiAgICB3aGlsZSAoUS5sZW5ndGggIT09IDApIHtcbiAgICAgIF9yZXQgPSBfbG9vcCgpO1xuICAgICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKF9yZXQgPT09IDEpIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgY29ubmVjdGVkRWxlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbm5lY3RlZE5vZGVzW19pXTtcbiAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbbm9kZS5pZCgpXTtcbiAgICAgIGlmIChlZGdlICE9IG51bGwpIHtcbiAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogY3kuY29sbGVjdGlvbihjb25uZWN0ZWRFbGVzKSxcbiAgICAgIGZvdW5kOiBjeS5jb2xsZWN0aW9uKGZvdW5kKVxuICAgIH07XG4gIH07XG59O1xuXG4vLyBzZWFyY2gsIHNwYW5uaW5nIHRyZWVzLCBldGNcbnZhciBlbGVzZm4kdiA9IHtcbiAgYnJlYWR0aEZpcnN0U2VhcmNoOiBkZWZpbmVTZWFyY2goe1xuICAgIGJmczogdHJ1ZVxuICB9KSxcbiAgZGVwdGhGaXJzdFNlYXJjaDogZGVmaW5lU2VhcmNoKHtcbiAgICBkZnM6IHRydWVcbiAgfSlcbn07XG5cbi8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aWNhbCBhbGlhc1xuZWxlc2ZuJHYuYmZzID0gZWxlc2ZuJHYuYnJlYWR0aEZpcnN0U2VhcmNoO1xuZWxlc2ZuJHYuZGZzID0gZWxlc2ZuJHYuZGVwdGhGaXJzdFNlYXJjaDtcblxudmFyIGhlYXAkMiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBoZWFwJDEgPSBoZWFwJDIuZXhwb3J0cztcblxudmFyIGhhc1JlcXVpcmVkSGVhcCQxO1xuXG5mdW5jdGlvbiByZXF1aXJlSGVhcCQxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSGVhcCQxKSByZXR1cm4gaGVhcCQyLmV4cG9ydHM7XG5cdGhhc1JlcXVpcmVkSGVhcCQxID0gMTtcblx0KGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XHQvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOC4wXG5cdFx0KGZ1bmN0aW9uKCkge1xuXHRcdCAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG5cdFx0ICBmbG9vciA9IE1hdGguZmxvb3IsIG1pbiA9IE1hdGgubWluO1xuXG5cblx0XHQgIC8qXG5cdFx0ICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuXHRcdCAgICovXG5cblx0XHQgIGRlZmF1bHRDbXAgPSBmdW5jdGlvbih4LCB5KSB7XG5cdFx0ICAgIGlmICh4IDwgeSkge1xuXHRcdCAgICAgIHJldHVybiAtMTtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAoeCA+IHkpIHtcblx0XHQgICAgICByZXR1cm4gMTtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gMDtcblx0XHQgIH07XG5cblxuXHRcdCAgLypcblx0XHQgIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG5cdFx0ICBcblx0XHQgIElmIHggaXMgYWxyZWFkeSBpbiBhLCBpbnNlcnQgaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgeC5cblx0XHQgIFxuXHRcdCAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxuXHRcdCAgb2YgYSB0byBiZSBzZWFyY2hlZC5cblx0XHQgICAqL1xuXG5cdFx0ICBpbnNvcnQgPSBmdW5jdGlvbihhLCB4LCBsbywgaGksIGNtcCkge1xuXHRcdCAgICB2YXIgbWlkO1xuXHRcdCAgICBpZiAobG8gPT0gbnVsbCkge1xuXHRcdCAgICAgIGxvID0gMDtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIGlmIChsbyA8IDApIHtcblx0XHQgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKGhpID09IG51bGwpIHtcblx0XHQgICAgICBoaSA9IGEubGVuZ3RoO1xuXHRcdCAgICB9XG5cdFx0ICAgIHdoaWxlIChsbyA8IGhpKSB7XG5cdFx0ICAgICAgbWlkID0gZmxvb3IoKGxvICsgaGkpIC8gMik7XG5cdFx0ICAgICAgaWYgKGNtcCh4LCBhW21pZF0pIDwgMCkge1xuXHRcdCAgICAgICAgaGkgPSBtaWQ7XG5cdFx0ICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgIGxvID0gbWlkICsgMTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIChbXS5zcGxpY2UuYXBwbHkoYSwgW2xvLCBsbyAtIGxvXS5jb25jYXQoeCkpLCB4KTtcblx0XHQgIH07XG5cblxuXHRcdCAgLypcblx0XHQgIFB1c2ggaXRlbSBvbnRvIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cblx0XHQgICAqL1xuXG5cdFx0ICBoZWFwcHVzaCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICBhcnJheS5wdXNoKGl0ZW0pO1xuXHRcdCAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuXHRcdCAgfTtcblxuXG5cdFx0ICAvKlxuXHRcdCAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuXHRcdCAgICovXG5cblx0XHQgIGhlYXBwb3AgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG5cdFx0ICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcblx0XHQgICAgaWYgKGFycmF5Lmxlbmd0aCkge1xuXHRcdCAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcblx0XHQgICAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG5cdFx0ICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcblx0XHQgICAgfSBlbHNlIHtcblx0XHQgICAgICByZXR1cm5pdGVtID0gbGFzdGVsdDtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gcmV0dXJuaXRlbTtcblx0XHQgIH07XG5cblxuXHRcdCAgLypcblx0XHQgIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cblx0XHQgIFxuXHRcdCAgVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGhlYXBwb3AoKSBmb2xsb3dlZCBieSBoZWFwcHVzaCgpLCBhbmQgY2FuIGJlXG5cdFx0ICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcblx0XHQgIHJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2Zcblx0XHQgIHRoaXMgcm91dGluZSB1bmxlc3Mgd3JpdHRlbiBhcyBwYXJ0IG9mIGEgY29uZGl0aW9uYWwgcmVwbGFjZW1lbnQ6XG5cdFx0ICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG5cdFx0ICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXG5cdFx0ICAgKi9cblxuXHRcdCAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG5cdFx0ICAgIHZhciByZXR1cm5pdGVtO1xuXHRcdCAgICBpZiAoY21wID09IG51bGwpIHtcblx0XHQgICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcblx0XHQgICAgYXJyYXlbMF0gPSBpdGVtO1xuXHRcdCAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuXHRcdCAgICByZXR1cm4gcmV0dXJuaXRlbTtcblx0XHQgIH07XG5cblxuXHRcdCAgLypcblx0XHQgIEZhc3QgdmVyc2lvbiBvZiBhIGhlYXBwdXNoIGZvbGxvd2VkIGJ5IGEgaGVhcHBvcC5cblx0XHQgICAqL1xuXG5cdFx0ICBoZWFwcHVzaHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcblx0XHQgICAgdmFyIF9yZWY7XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuXHRcdCAgICAgIF9yZWYgPSBbYXJyYXlbMF0sIGl0ZW1dLCBpdGVtID0gX3JlZlswXSwgYXJyYXlbMF0gPSBfcmVmWzFdO1xuXHRcdCAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIGl0ZW07XG5cdFx0ICB9O1xuXG5cblx0XHQgIC8qXG5cdFx0ICBUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuXHRcdCAgICovXG5cblx0XHQgIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG5cdFx0ICAgIHZhciBpLCBfaSwgX2xlbiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgX3JlZjEgPSAoZnVuY3Rpb24oKSB7XG5cdFx0ICAgICAgX3Jlc3VsdHMxID0gW107XG5cdFx0ICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cblx0XHQgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuXHRcdCAgICB9KS5hcHBseSh0aGlzKS5yZXZlcnNlKCk7XG5cdFx0ICAgIF9yZXN1bHRzID0gW107XG5cdFx0ICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcblx0XHQgICAgICBpID0gX3JlZjFbX2ldO1xuXHRcdCAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG5cdFx0ICAgIH1cblx0XHQgICAgcmV0dXJuIF9yZXN1bHRzO1xuXHRcdCAgfTtcblxuXG5cdFx0ICAvKlxuXHRcdCAgVXBkYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gaXRlbSBpbiB0aGUgaGVhcC5cblx0XHQgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuXHRcdCAgICovXG5cblx0XHQgIHVwZGF0ZUl0ZW0gPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG5cdFx0ICAgIHZhciBwb3M7XG5cdFx0ICAgIGlmIChjbXAgPT0gbnVsbCkge1xuXHRcdCAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG5cdFx0ICAgIH1cblx0XHQgICAgcG9zID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcblx0XHQgICAgaWYgKHBvcyA9PT0gLTEpIHtcblx0XHQgICAgICByZXR1cm47XG5cdFx0ICAgIH1cblx0XHQgICAgX3NpZnRkb3duKGFycmF5LCAwLCBwb3MsIGNtcCk7XG5cdFx0ICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG5cdFx0ICB9O1xuXG5cblx0XHQgIC8qXG5cdFx0ICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuXHRcdCAgICovXG5cblx0XHQgIG5sYXJnZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuXHRcdCAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKTtcblx0XHQgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG5cdFx0ICAgICAgcmV0dXJuIHJlc3VsdDtcblx0XHQgICAgfVxuXHRcdCAgICBoZWFwaWZ5KHJlc3VsdCwgY21wKTtcblx0XHQgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuXHRcdCAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcblx0XHQgICAgICBlbGVtID0gX3JlZltfaV07XG5cdFx0ICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiByZXN1bHQuc29ydChjbXApLnJldmVyc2UoKTtcblx0XHQgIH07XG5cblxuXHRcdCAgLypcblx0XHQgIEZpbmQgdGhlIG4gc21hbGxlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuXHRcdCAgICovXG5cblx0XHQgIG5zbWFsbGVzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcblx0XHQgICAgdmFyIGVsZW0sIGxvcywgcmVzdWx0LCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuXHRcdCAgICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pLnNvcnQoY21wKTtcblx0XHQgICAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcblx0XHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG5cdFx0ICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuXHRcdCAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuXHRcdCAgICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuXHRcdCAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuXHRcdCAgICAgICAgICBpbnNvcnQocmVzdWx0LCBlbGVtLCAwLCBudWxsLCBjbXApO1xuXHRcdCAgICAgICAgICByZXN1bHQucG9wKCk7XG5cdFx0ICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG5cdFx0ICAgICAgICB9XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIHJldHVybiByZXN1bHQ7XG5cdFx0ICAgIH1cblx0XHQgICAgaGVhcGlmeShhcnJheSwgY21wKTtcblx0XHQgICAgX3Jlc3VsdHMgPSBbXTtcblx0XHQgICAgZm9yIChfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgMCA8PSBfcmVmMSA/ICsrX2ogOiAtLV9qKSB7XG5cdFx0ICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcblx0XHQgICAgfVxuXHRcdCAgICByZXR1cm4gX3Jlc3VsdHM7XG5cdFx0ICB9O1xuXG5cdFx0ICBfc2lmdGRvd24gPSBmdW5jdGlvbihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKSB7XG5cdFx0ICAgIHZhciBuZXdpdGVtLCBwYXJlbnQsIHBhcmVudHBvcztcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcblx0XHQgICAgd2hpbGUgKHBvcyA+IHN0YXJ0cG9zKSB7XG5cdFx0ICAgICAgcGFyZW50cG9zID0gKHBvcyAtIDEpID4+IDE7XG5cdFx0ICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcblx0XHQgICAgICBpZiAoY21wKG5ld2l0ZW0sIHBhcmVudCkgPCAwKSB7XG5cdFx0ICAgICAgICBhcnJheVtwb3NdID0gcGFyZW50O1xuXHRcdCAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuXHRcdCAgICAgICAgY29udGludWU7XG5cdFx0ICAgICAgfVxuXHRcdCAgICAgIGJyZWFrO1xuXHRcdCAgICB9XG5cdFx0ICAgIHJldHVybiBhcnJheVtwb3NdID0gbmV3aXRlbTtcblx0XHQgIH07XG5cblx0XHQgIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcblx0XHQgICAgdmFyIGNoaWxkcG9zLCBlbmRwb3MsIG5ld2l0ZW0sIHJpZ2h0cG9zLCBzdGFydHBvcztcblx0XHQgICAgaWYgKGNtcCA9PSBudWxsKSB7XG5cdFx0ICAgICAgY21wID0gZGVmYXVsdENtcDtcblx0XHQgICAgfVxuXHRcdCAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG5cdFx0ICAgIHN0YXJ0cG9zID0gcG9zO1xuXHRcdCAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcblx0XHQgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcblx0XHQgICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XG5cdFx0ICAgICAgcmlnaHRwb3MgPSBjaGlsZHBvcyArIDE7XG5cdFx0ICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG5cdFx0ICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xuXHRcdCAgICAgIH1cblx0XHQgICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuXHRcdCAgICAgIHBvcyA9IGNoaWxkcG9zO1xuXHRcdCAgICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG5cdFx0ICAgIH1cblx0XHQgICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG5cdFx0ICAgIHJldHVybiBfc2lmdGRvd24oYXJyYXksIHN0YXJ0cG9zLCBwb3MsIGNtcCk7XG5cdFx0ICB9O1xuXG5cdFx0ICBIZWFwID0gKGZ1bmN0aW9uKCkge1xuXHRcdCAgICBIZWFwLnB1c2ggPSBoZWFwcHVzaDtcblxuXHRcdCAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cblx0XHQgICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cblx0XHQgICAgSGVhcC5wdXNocG9wID0gaGVhcHB1c2hwb3A7XG5cblx0XHQgICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuXHRcdCAgICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xuXG5cdFx0ICAgIEhlYXAubmxhcmdlc3QgPSBubGFyZ2VzdDtcblxuXHRcdCAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuXHRcdCAgICBmdW5jdGlvbiBIZWFwKGNtcCkge1xuXHRcdCAgICAgIHRoaXMuY21wID0gY21wICE9IG51bGwgPyBjbXAgOiBkZWZhdWx0Q21wO1xuXHRcdCAgICAgIHRoaXMubm9kZXMgPSBbXTtcblx0XHQgICAgfVxuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbih4KSB7XG5cdFx0ICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcblx0XHQgICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCkge1xuXHRcdCAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbih4KSB7XG5cdFx0ICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5wdXNocG9wID0gZnVuY3Rpb24oeCkge1xuXHRcdCAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuaGVhcGlmeSA9IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS51cGRhdGVJdGVtID0gZnVuY3Rpb24oeCkge1xuXHRcdCAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcblx0XHQgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG5cdFx0ICAgIH07XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHRcdCAgICAgIHZhciBoZWFwO1xuXHRcdCAgICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuXHRcdCAgICAgIGhlYXAubm9kZXMgPSB0aGlzLm5vZGVzLnNsaWNlKDApO1xuXHRcdCAgICAgIHJldHVybiBoZWFwO1xuXHRcdCAgICB9O1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcblx0XHQgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcblx0XHQgICAgfTtcblxuXHRcdCAgICBIZWFwLnByb3RvdHlwZS5pbnNlcnQgPSBIZWFwLnByb3RvdHlwZS5wdXNoO1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cblx0XHQgICAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLmhhcyA9IEhlYXAucHJvdG90eXBlLmNvbnRhaW5zO1xuXG5cdFx0ICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuXHRcdCAgICByZXR1cm4gSGVhcDtcblxuXHRcdCAgfSkoKTtcblxuXHRcdCAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0XHQgICAge1xuXHRcdCAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0XHQgICAgfVxuXHRcdCAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0ICAgIHJldHVybiBIZWFwO1xuXHRcdCAgfSk7XG5cblx0XHR9KS5jYWxsKGhlYXAkMSk7IFxuXHR9IChoZWFwJDIpKTtcblx0cmV0dXJuIGhlYXAkMi5leHBvcnRzO1xufVxuXG52YXIgaGVhcDtcbnZhciBoYXNSZXF1aXJlZEhlYXA7XG5cbmZ1bmN0aW9uIHJlcXVpcmVIZWFwICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSGVhcCkgcmV0dXJuIGhlYXA7XG5cdGhhc1JlcXVpcmVkSGVhcCA9IDE7XG5cdGhlYXAgPSByZXF1aXJlSGVhcCQxKCk7XG5cdHJldHVybiBoZWFwO1xufVxuXG52YXIgaGVhcEV4cG9ydHMgPSByZXF1aXJlSGVhcCgpO1xudmFyIEhlYXAgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaGVhcEV4cG9ydHMpO1xuXG52YXIgZGlqa3N0cmFEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICByb290OiBudWxsLFxuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJHUgPSB7XG4gIGRpamtzdHJhOiBmdW5jdGlvbiBkaWprc3RyYShvcHRpb25zKSB7XG4gICAgaWYgKCFwbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICByb290OiBhcmdzWzBdLFxuICAgICAgICB3ZWlnaHQ6IGFyZ3NbMV0sXG4gICAgICAgIGRpcmVjdGVkOiBhcmdzWzJdXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgX2RpamtzdHJhRGVmYXVsdHMgPSBkaWprc3RyYURlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgcm9vdCA9IF9kaWprc3RyYURlZmF1bHRzLnJvb3QsXG4gICAgICB3ZWlnaHQgPSBfZGlqa3N0cmFEZWZhdWx0cy53ZWlnaHQsXG4gICAgICBkaXJlY3RlZCA9IF9kaWprc3RyYURlZmF1bHRzLmRpcmVjdGVkO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG4gICAgdmFyIHNvdXJjZSA9IHN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdIDogcm9vdFswXTtcbiAgICB2YXIgZGlzdCA9IHt9O1xuICAgIHZhciBwcmV2ID0ge307XG4gICAgdmFyIGtub3duRGlzdCA9IHt9O1xuICAgIHZhciBfdGhpcyRieUdyb3VwID0gdGhpcy5ieUdyb3VwKCksXG4gICAgICBub2RlcyA9IF90aGlzJGJ5R3JvdXAubm9kZXMsXG4gICAgICBlZGdlcyA9IF90aGlzJGJ5R3JvdXAuZWRnZXM7XG4gICAgZWRnZXMudW5tZXJnZUJ5KGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNMb29wKCk7XG4gICAgfSk7XG4gICAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG5vZGUpIHtcbiAgICAgIHJldHVybiBkaXN0W25vZGUuaWQoKV07XG4gICAgfTtcbiAgICB2YXIgc2V0RGlzdCA9IGZ1bmN0aW9uIHNldERpc3Qobm9kZSwgZCkge1xuICAgICAgZGlzdFtub2RlLmlkKCldID0gZDtcbiAgICAgIFEudXBkYXRlSXRlbShub2RlKTtcbiAgICB9O1xuICAgIHZhciBRID0gbmV3IEhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBnZXREaXN0KGEpIC0gZ2V0RGlzdChiKTtcbiAgICB9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgZGlzdFtub2RlLmlkKCldID0gbm9kZS5zYW1lKHNvdXJjZSkgPyAwIDogSW5maW5pdHk7XG4gICAgICBRLnB1c2gobm9kZSk7XG4gICAgfVxuICAgIHZhciBkaXN0QmV0d2VlbiA9IGZ1bmN0aW9uIGRpc3RCZXR3ZWVuKHUsIHYpIHtcbiAgICAgIHZhciB1dnMgPSAoZGlyZWN0ZWQgPyB1LmVkZ2VzVG8odikgOiB1LmVkZ2VzV2l0aCh2KSkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICB2YXIgc21hbGxlc3RFZGdlO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHV2cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSB1dnNbX2ldO1xuICAgICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgICAgICBpZiAoX3dlaWdodCA8IHNtYWxsZXN0RGlzdGFuY2UgfHwgIXNtYWxsZXN0RWRnZSkge1xuICAgICAgICAgIHNtYWxsZXN0RGlzdGFuY2UgPSBfd2VpZ2h0O1xuICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVkZ2U6IHNtYWxsZXN0RWRnZSxcbiAgICAgICAgZGlzdDogc21hbGxlc3REaXN0YW5jZVxuICAgICAgfTtcbiAgICB9O1xuICAgIHdoaWxlIChRLnNpemUoKSA+IDApIHtcbiAgICAgIHZhciB1ID0gUS5wb3AoKTtcbiAgICAgIHZhciBzbWFsbGV0c0Rpc3QgPSBnZXREaXN0KHUpO1xuICAgICAgdmFyIHVpZCA9IHUuaWQoKTtcbiAgICAgIGtub3duRGlzdFt1aWRdID0gc21hbGxldHNEaXN0O1xuICAgICAgaWYgKHNtYWxsZXRzRGlzdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgbmVpZ2hib3JzID0gdS5uZWlnaGJvcmhvb2QoKS5pbnRlcnNlY3Qobm9kZXMpO1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbmVpZ2hib3JzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHYgPSBuZWlnaGJvcnNbX2kyXTtcbiAgICAgICAgdmFyIHZpZCA9IHYuaWQoKTtcbiAgICAgICAgdmFyIHZEaXN0ID0gZGlzdEJldHdlZW4odSwgdik7XG4gICAgICAgIHZhciBhbHQgPSBzbWFsbGV0c0Rpc3QgKyB2RGlzdC5kaXN0O1xuICAgICAgICBpZiAoYWx0IDwgZ2V0RGlzdCh2KSkge1xuICAgICAgICAgIHNldERpc3QodiwgYWx0KTtcbiAgICAgICAgICBwcmV2W3ZpZF0gPSB7XG4gICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgZWRnZTogdkRpc3QuZWRnZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yXG4gICAgfSAvLyB3aGlsZVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uIGRpc3RhbmNlVG8obm9kZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gc3RyaW5nKG5vZGUpID8gbm9kZXMuZmlsdGVyKG5vZGUpWzBdIDogbm9kZVswXTtcbiAgICAgICAgcmV0dXJuIGtub3duRGlzdFt0YXJnZXQuaWQoKV07XG4gICAgICB9LFxuICAgICAgcGF0aFRvOiBmdW5jdGlvbiBwYXRoVG8obm9kZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gc3RyaW5nKG5vZGUpID8gbm9kZXMuZmlsdGVyKG5vZGUpWzBdIDogbm9kZVswXTtcbiAgICAgICAgdmFyIFMgPSBbXTtcbiAgICAgICAgdmFyIHUgPSB0YXJnZXQ7XG4gICAgICAgIHZhciB1aWQgPSB1LmlkKCk7XG4gICAgICAgIGlmICh0YXJnZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIFMudW5zaGlmdCh0YXJnZXQpO1xuICAgICAgICAgIHdoaWxlIChwcmV2W3VpZF0pIHtcbiAgICAgICAgICAgIHZhciBwID0gcHJldlt1aWRdO1xuICAgICAgICAgICAgUy51bnNoaWZ0KHAuZWRnZSk7XG4gICAgICAgICAgICBTLnVuc2hpZnQocC5ub2RlKTtcbiAgICAgICAgICAgIHUgPSBwLm5vZGU7XG4gICAgICAgICAgICB1aWQgPSB1LmlkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVzLnNwYXduKFMpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbnZhciBlbGVzZm4kdCA9IHtcbiAgLy8ga3J1c2thbCdzIGFsZ29yaXRobSAoZmluZHMgbWluIHNwYW5uaW5nIHRyZWUsIGFzc3VtaW5nIHVuZGlyZWN0ZWQgZ3JhcGgpXG4gIC8vIGltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBrcnVza2FsOiBmdW5jdGlvbiBrcnVza2FsKHdlaWdodEZuKSB7XG4gICAgd2VpZ2h0Rm4gPSB3ZWlnaHRGbiB8fCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfTtcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgZm9yZXN0ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgQSA9IG5vZGVzOyAvLyBhc3N1bWVzIGJ5R3JvdXAoKSBjcmVhdGVzIG5ldyBjb2xsZWN0aW9ucyB0aGF0IGNhbiBiZSBzYWZlbHkgbXV0YXRlZFxuXG4gICAgdmFyIGZpbmRTZXRJbmRleCA9IGZ1bmN0aW9uIGZpbmRTZXRJbmRleChlbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVzID0gZm9yZXN0W2ldO1xuICAgICAgICBpZiAoZWxlcy5oYXMoZWxlKSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0YXJ0IHdpdGggb25lIGZvcmVzdCBwZXIgbm9kZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgZm9yZXN0W2ldID0gdGhpcy5zcGF3bihub2Rlc1tpXSk7XG4gICAgfVxuICAgIHZhciBTID0gZWRnZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIHdlaWdodEZuKGEpIC0gd2VpZ2h0Rm4oYik7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IFNbX2ldO1xuICAgICAgdmFyIHUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgdmFyIHYgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgICAgdmFyIHNldFVJbmRleCA9IGZpbmRTZXRJbmRleCh1KTtcbiAgICAgIHZhciBzZXRWSW5kZXggPSBmaW5kU2V0SW5kZXgodik7XG4gICAgICB2YXIgc2V0VSA9IGZvcmVzdFtzZXRVSW5kZXhdO1xuICAgICAgdmFyIHNldFYgPSBmb3Jlc3Rbc2V0VkluZGV4XTtcbiAgICAgIGlmIChzZXRVSW5kZXggIT09IHNldFZJbmRleCkge1xuICAgICAgICBBLm1lcmdlKGVkZ2UpO1xuXG4gICAgICAgIC8vIGNvbWJpbmUgZm9yZXN0cyBmb3IgdSBhbmQgdlxuICAgICAgICBzZXRVLm1lcmdlKHNldFYpO1xuICAgICAgICBmb3Jlc3Quc3BsaWNlKHNldFZJbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBO1xuICB9XG59O1xuXG52YXIgYVN0YXJEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICByb290OiBudWxsLFxuICBnb2FsOiBudWxsLFxuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGhldXJpc3RpYzogZnVuY3Rpb24gaGV1cmlzdGljKGVkZ2UpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kcyA9IHtcbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGFTdGFyOiBmdW5jdGlvbiBhU3RhcihvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBfYVN0YXJEZWZhdWx0cyA9IGFTdGFyRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICByb290ID0gX2FTdGFyRGVmYXVsdHMucm9vdCxcbiAgICAgIGdvYWwgPSBfYVN0YXJEZWZhdWx0cy5nb2FsLFxuICAgICAgaGV1cmlzdGljID0gX2FTdGFyRGVmYXVsdHMuaGV1cmlzdGljLFxuICAgICAgZGlyZWN0ZWQgPSBfYVN0YXJEZWZhdWx0cy5kaXJlY3RlZCxcbiAgICAgIHdlaWdodCA9IF9hU3RhckRlZmF1bHRzLndlaWdodDtcbiAgICByb290ID0gY3kuY29sbGVjdGlvbihyb290KVswXTtcbiAgICBnb2FsID0gY3kuY29sbGVjdGlvbihnb2FsKVswXTtcbiAgICB2YXIgc2lkID0gcm9vdC5pZCgpO1xuICAgIHZhciB0aWQgPSBnb2FsLmlkKCk7XG4gICAgdmFyIGdTY29yZSA9IHt9O1xuICAgIHZhciBmU2NvcmUgPSB7fTtcbiAgICB2YXIgY2xvc2VkU2V0SWRzID0ge307XG4gICAgdmFyIG9wZW5TZXQgPSBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZTY29yZVthLmlkKCldIC0gZlNjb3JlW2IuaWQoKV07XG4gICAgfSk7XG4gICAgdmFyIG9wZW5TZXRJZHMgPSBuZXcgU2V0JDEoKTtcbiAgICB2YXIgY2FtZUZyb20gPSB7fTtcbiAgICB2YXIgY2FtZUZyb21FZGdlID0ge307XG4gICAgdmFyIGFkZFRvT3BlblNldCA9IGZ1bmN0aW9uIGFkZFRvT3BlblNldChlbGUsIGlkKSB7XG4gICAgICBvcGVuU2V0LnB1c2goZWxlKTtcbiAgICAgIG9wZW5TZXRJZHMuYWRkKGlkKTtcbiAgICB9O1xuICAgIHZhciBjTWluLCBjTWluSWQ7XG4gICAgdmFyIHBvcEZyb21PcGVuU2V0ID0gZnVuY3Rpb24gcG9wRnJvbU9wZW5TZXQoKSB7XG4gICAgICBjTWluID0gb3BlblNldC5wb3AoKTtcbiAgICAgIGNNaW5JZCA9IGNNaW4uaWQoKTtcbiAgICAgIG9wZW5TZXRJZHNbXCJkZWxldGVcIl0oY01pbklkKTtcbiAgICB9O1xuICAgIHZhciBpc0luT3BlblNldCA9IGZ1bmN0aW9uIGlzSW5PcGVuU2V0KGlkKSB7XG4gICAgICByZXR1cm4gb3BlblNldElkcy5oYXMoaWQpO1xuICAgIH07XG4gICAgYWRkVG9PcGVuU2V0KHJvb3QsIHNpZCk7XG4gICAgZ1Njb3JlW3NpZF0gPSAwO1xuICAgIGZTY29yZVtzaWRdID0gaGV1cmlzdGljKHJvb3QpO1xuXG4gICAgLy8gQ291bnRlclxuICAgIHZhciBzdGVwcyA9IDA7XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICB3aGlsZSAob3BlblNldC5zaXplKCkgPiAwKSB7XG4gICAgICBwb3BGcm9tT3BlblNldCgpO1xuICAgICAgc3RlcHMrKztcblxuICAgICAgLy8gSWYgd2UndmUgZm91bmQgb3VyIGdvYWwsIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgIGlmIChjTWluSWQgPT09IHRpZCkge1xuICAgICAgICB2YXIgcGF0aCA9IFtdO1xuICAgICAgICB2YXIgcGF0aE5vZGUgPSBnb2FsO1xuICAgICAgICB2YXIgcGF0aE5vZGVJZCA9IHRpZDtcbiAgICAgICAgdmFyIHBhdGhFZGdlID0gY2FtZUZyb21FZGdlW3BhdGhOb2RlSWRdO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgcGF0aC51bnNoaWZ0KHBhdGhOb2RlKTtcbiAgICAgICAgICBpZiAocGF0aEVkZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aC51bnNoaWZ0KHBhdGhFZGdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aE5vZGUgPSBjYW1lRnJvbVtwYXRoTm9kZUlkXTtcbiAgICAgICAgICBpZiAocGF0aE5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGhOb2RlSWQgPSBwYXRoTm9kZS5pZCgpO1xuICAgICAgICAgIHBhdGhFZGdlID0gY2FtZUZyb21FZGdlW3BhdGhOb2RlSWRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm91bmQ6IHRydWUsXG4gICAgICAgICAgZGlzdGFuY2U6IGdTY29yZVtjTWluSWRdLFxuICAgICAgICAgIHBhdGg6IHRoaXMuc3Bhd24ocGF0aCksXG4gICAgICAgICAgc3RlcHM6IHN0ZXBzXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBjTWluIHRvIHByb2Nlc3NlZCBub2Rlc1xuICAgICAgY2xvc2VkU2V0SWRzW2NNaW5JZF0gPSB0cnVlO1xuXG4gICAgICAvLyBVcGRhdGUgc2NvcmVzIGZvciBuZWlnaGJvcnMgb2YgY01pblxuICAgICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaWYgZ3JhcGggaXMgZGlyZWN0ZWQgb3Igbm90XG4gICAgICB2YXIgdndFZGdlcyA9IGNNaW4uX3ByaXZhdGUuZWRnZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW2ldO1xuXG4gICAgICAgIC8vIGVkZ2UgbXVzdCBiZSBpbiBzZXQgb2YgY2FsbGluZyBlbGVzXG4gICAgICAgIGlmICghdGhpcy5oYXNFbGVtZW50V2l0aElkKGUuaWQoKSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNNaW4gbXVzdCBiZSB0aGUgc291cmNlIG9mIGVkZ2UgaWYgZGlyZWN0ZWRcbiAgICAgICAgaWYgKGRpcmVjdGVkICYmIGUuZGF0YSgnc291cmNlJykgIT09IGNNaW5JZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3U3JjID0gZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHdUZ3QgPSBlLnRhcmdldCgpO1xuICAgICAgICB2YXIgdyA9IHdTcmMuaWQoKSAhPT0gY01pbklkID8gd1NyYyA6IHdUZ3Q7XG4gICAgICAgIHZhciB3aWQgPSB3LmlkKCk7XG5cbiAgICAgICAgLy8gbm9kZSBtdXN0IGJlIGluIHNldCBvZiBjYWxsaW5nIGVsZXNcbiAgICAgICAgaWYgKCF0aGlzLmhhc0VsZW1lbnRXaXRoSWQod2lkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm9kZSBpcyBpbiBjbG9zZWRTZXQsIGlnbm9yZSBpdFxuICAgICAgICBpZiAoY2xvc2VkU2V0SWRzW3dpZF0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5ldyB0ZW50YXRpdmUgc2NvcmUgZm9yIG5vZGUgd1xuICAgICAgICB2YXIgdGVtcFNjb3JlID0gZ1Njb3JlW2NNaW5JZF0gKyB3ZWlnaHQoZSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGdTY29yZSBmb3Igbm9kZSB3IGlmOlxuICAgICAgICAvLyAgIHcgbm90IHByZXNlbnQgaW4gb3BlblNldFxuICAgICAgICAvLyBPUlxuICAgICAgICAvLyAgIHRlbnRhdGl2ZSBnU2NvcmUgaXMgbGVzcyB0aGFuIHByZXZpb3VzIHZhbHVlXG5cbiAgICAgICAgLy8gdyBub3QgaW4gb3BlblNldFxuICAgICAgICBpZiAoIWlzSW5PcGVuU2V0KHdpZCkpIHtcbiAgICAgICAgICBnU2NvcmVbd2lkXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICBmU2NvcmVbd2lkXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyh3KTtcbiAgICAgICAgICBhZGRUb09wZW5TZXQodywgd2lkKTtcbiAgICAgICAgICBjYW1lRnJvbVt3aWRdID0gY01pbjtcbiAgICAgICAgICBjYW1lRnJvbUVkZ2Vbd2lkXSA9IGU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3IGFscmVhZHkgaW4gb3BlblNldCwgYnV0IHdpdGggZ3JlYXRlciBnU2NvcmVcbiAgICAgICAgaWYgKHRlbXBTY29yZSA8IGdTY29yZVt3aWRdKSB7XG4gICAgICAgICAgZ1Njb3JlW3dpZF0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgZlNjb3JlW3dpZF0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgY2FtZUZyb21bd2lkXSA9IGNNaW47XG4gICAgICAgICAgY2FtZUZyb21FZGdlW3dpZF0gPSBlO1xuICAgICAgICB9XG4gICAgICB9IC8vIEVuZCBvZiBuZWlnaGJvcnMgdXBkYXRlXG4gICAgfSAvLyBFbmQgb2YgbWFpbiBsb29wXG5cbiAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIGhlcmUsIHRoZW4gd2UndmUgbm90IHJlYWNoZWQgb3VyIGdvYWxcbiAgICByZXR1cm4ge1xuICAgICAgZm91bmQ6IGZhbHNlLFxuICAgICAgZGlzdGFuY2U6IHVuZGVmaW5lZCxcbiAgICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICAgIHN0ZXBzOiBzdGVwc1xuICAgIH07XG4gIH1cbn07IC8vIGVsZXNmblxuXG52YXIgZmxveWRXYXJzaGFsbERlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kciA9IHtcbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGZsb3lkV2Fyc2hhbGw6IGZ1bmN0aW9uIGZsb3lkV2Fyc2hhbGwob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0ID0gZmxveWRXYXJzaGFsbERlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgd2VpZ2h0ID0gX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0LndlaWdodCxcbiAgICAgIGRpcmVjdGVkID0gX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0LmRpcmVjdGVkO1xuICAgIHZhciB3ZWlnaHRGbiA9IHdlaWdodDtcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuICAgIHZhciBOID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBOc3EgPSBOICogTjtcbiAgICB2YXIgaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2Yobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgfTtcbiAgICB2YXIgYXRJbmRleCA9IGZ1bmN0aW9uIGF0SW5kZXgoaSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH07XG5cbiAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuICAgIHZhciBkaXN0ID0gbmV3IEFycmF5KE5zcSk7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBOc3E7IG4rKykge1xuICAgICAgdmFyIGogPSBuICUgTjtcbiAgICAgIHZhciBpID0gKG4gLSBqKSAvIE47XG4gICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICBkaXN0W25dID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3Rbbl0gPSBJbmZpbml0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIG1hdHJpeCB1c2VkIGZvciBwYXRoIHJlY29uc3RydWN0aW9uXG4gICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICB2YXIgbmV4dCA9IG5ldyBBcnJheShOc3EpO1xuICAgIHZhciBlZGdlTmV4dCA9IG5ldyBBcnJheShOc3EpO1xuXG4gICAgLy8gUHJvY2VzcyBlZGdlc1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbX2ldO1xuICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgICAgIGlmIChzcmMgPT09IHRndCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gZXhjbHVkZSBsb29wc1xuXG4gICAgICB2YXIgcyA9IGluZGV4T2Yoc3JjKTtcbiAgICAgIHZhciB0ID0gaW5kZXhPZih0Z3QpO1xuICAgICAgdmFyIHN0ID0gcyAqIE4gKyB0OyAvLyBzb3VyY2UgdG8gdGFyZ2V0IGluZGV4XG4gICAgICB2YXIgX3dlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuXG4gICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG4gICAgICBpZiAoZGlzdFtzdF0gPiBfd2VpZ2h0KSB7XG4gICAgICAgIGRpc3Rbc3RdID0gX3dlaWdodDtcbiAgICAgICAgbmV4dFtzdF0gPSB0O1xuICAgICAgICBlZGdlTmV4dFtzdF0gPSBlZGdlO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCBwcm9jZXNzICdyZXZlcnNlZCcgZWRnZVxuICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICB2YXIgdHMgPSB0ICogTiArIHM7IC8vIHRhcmdldCB0byBzb3VyY2UgaW5kZXhcblxuICAgICAgICBpZiAoIWRpcmVjdGVkICYmIGRpc3RbdHNdID4gX3dlaWdodCkge1xuICAgICAgICAgIGRpc3RbdHNdID0gX3dlaWdodDtcbiAgICAgICAgICBuZXh0W3RzXSA9IHM7XG4gICAgICAgICAgZWRnZU5leHRbdHNdID0gZWRnZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1haW4gbG9vcFxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgTjsgaysrKSB7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBOOyBfaTIrKykge1xuICAgICAgICB2YXIgaWsgPSBfaTIgKiBOICsgaztcbiAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IE47IF9qKyspIHtcbiAgICAgICAgICB2YXIgaWogPSBfaTIgKiBOICsgX2o7XG4gICAgICAgICAgdmFyIGtqID0gayAqIE4gKyBfajtcbiAgICAgICAgICBpZiAoZGlzdFtpa10gKyBkaXN0W2tqXSA8IGRpc3RbaWpdKSB7XG4gICAgICAgICAgICBkaXN0W2lqXSA9IGRpc3RbaWtdICsgZGlzdFtral07XG4gICAgICAgICAgICBuZXh0W2lqXSA9IG5leHRbaWtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZ2V0QXJnRWxlID0gZnVuY3Rpb24gZ2V0QXJnRWxlKGVsZSkge1xuICAgICAgcmV0dXJuIChzdHJpbmcoZWxlKSA/IGN5LmZpbHRlcihlbGUpIDogZWxlKVswXTtcbiAgICB9O1xuICAgIHZhciBpbmRleE9mQXJnRWxlID0gZnVuY3Rpb24gaW5kZXhPZkFyZ0VsZShlbGUpIHtcbiAgICAgIHJldHVybiBpbmRleE9mKGdldEFyZ0VsZShlbGUpKTtcbiAgICB9O1xuICAgIHZhciByZXMgPSB7XG4gICAgICBkaXN0YW5jZTogZnVuY3Rpb24gZGlzdGFuY2UoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICByZXR1cm4gZGlzdFtpICogTiArIGpdO1xuICAgICAgfSxcbiAgICAgIHBhdGg6IGZ1bmN0aW9uIHBhdGgoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIGkgPSBpbmRleE9mQXJnRWxlKGZyb20pO1xuICAgICAgICB2YXIgaiA9IGluZGV4T2ZBcmdFbGUodG8pO1xuICAgICAgICB2YXIgZnJvbU5vZGUgPSBhdEluZGV4KGkpO1xuICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgIHJldHVybiBmcm9tTm9kZS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRbaSAqIE4gKyBqXSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgdmFyIHByZXYgPSBpO1xuICAgICAgICB2YXIgZWRnZTtcbiAgICAgICAgcGF0aC5tZXJnZShmcm9tTm9kZSk7XG4gICAgICAgIHdoaWxlIChpICE9PSBqKSB7XG4gICAgICAgICAgcHJldiA9IGk7XG4gICAgICAgICAgaSA9IG5leHRbaSAqIE4gKyBqXTtcbiAgICAgICAgICBlZGdlID0gZWRnZU5leHRbcHJldiAqIE4gKyBpXTtcbiAgICAgICAgICBwYXRoLm1lcmdlKGVkZ2UpO1xuICAgICAgICAgIHBhdGgubWVyZ2UoYXRJbmRleChpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzO1xuICB9IC8vIGZsb3lkV2Fyc2hhbGxcbn07IC8vIGVsZXNmblxuXG52YXIgYmVsbG1hbkZvcmREZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0sXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgcm9vdDogbnVsbFxufSk7XG52YXIgZWxlc2ZuJHEgPSB7XG4gIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICBiZWxsbWFuRm9yZDogZnVuY3Rpb24gYmVsbG1hbkZvcmQob3B0aW9ucykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIF9iZWxsbWFuRm9yZERlZmF1bHRzID0gYmVsbG1hbkZvcmREZWZhdWx0cyhvcHRpb25zKSxcbiAgICAgIHdlaWdodCA9IF9iZWxsbWFuRm9yZERlZmF1bHRzLndlaWdodCxcbiAgICAgIGRpcmVjdGVkID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICByb290ID0gX2JlbGxtYW5Gb3JkRGVmYXVsdHMucm9vdDtcbiAgICB2YXIgd2VpZ2h0Rm4gPSB3ZWlnaHQ7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzLFxuICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzO1xuICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaW5mb01hcCA9IG5ldyBNYXAkMSgpO1xuICAgIHZhciBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlID0gZmFsc2U7XG4gICAgdmFyIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzID0gW107XG4gICAgcm9vdCA9IGN5LmNvbGxlY3Rpb24ocm9vdClbMF07IC8vIGluIGNhc2Ugc2VsZWN0b3IgcGFzc2VkXG5cbiAgICBlZGdlcy51bm1lcmdlQnkoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLmlzTG9vcCgpO1xuICAgIH0pO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICB2YXIgZ2V0SW5mbyA9IGZ1bmN0aW9uIGdldEluZm8obm9kZSkge1xuICAgICAgdmFyIG9iaiA9IGluZm9NYXAuZ2V0KG5vZGUuaWQoKSk7XG4gICAgICBpZiAoIW9iaikge1xuICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgaW5mb01hcC5zZXQobm9kZS5pZCgpLCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHZhciBnZXROb2RlRnJvbVRvID0gZnVuY3Rpb24gZ2V0Tm9kZUZyb21Ubyh0bykge1xuICAgICAgcmV0dXJuIChzdHJpbmcodG8pID8gY3kuJCh0bykgOiB0bylbMF07XG4gICAgfTtcbiAgICB2YXIgZGlzdGFuY2VUbyA9IGZ1bmN0aW9uIGRpc3RhbmNlVG8odG8pIHtcbiAgICAgIHJldHVybiBnZXRJbmZvKGdldE5vZGVGcm9tVG8odG8pKS5kaXN0O1xuICAgIH07XG4gICAgdmFyIHBhdGhUbyA9IGZ1bmN0aW9uIHBhdGhUbyh0bykge1xuICAgICAgdmFyIHRoaXNTdGFydCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogcm9vdDtcbiAgICAgIHZhciBlbmQgPSBnZXROb2RlRnJvbVRvKHRvKTtcbiAgICAgIHZhciBwYXRoID0gW107XG4gICAgICB2YXIgbm9kZSA9IGVuZDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zcGF3bigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfZ2V0SW5mbyA9IGdldEluZm8obm9kZSksXG4gICAgICAgICAgZWRnZSA9IF9nZXRJbmZvLmVkZ2UsXG4gICAgICAgICAgcHJlZCA9IF9nZXRJbmZvLnByZWQ7XG4gICAgICAgIHBhdGgudW5zaGlmdChub2RlWzBdKTtcbiAgICAgICAgaWYgKG5vZGUuc2FtZSh0aGlzU3RhcnQpICYmIHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGdlICE9IG51bGwpIHtcbiAgICAgICAgICBwYXRoLnVuc2hpZnQoZWRnZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IHByZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlcy5zcGF3bihwYXRoKTtcbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbGl6YXRpb25zIHsgZGlzdCwgcHJlZCwgZWRnZSB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIGluZm8gPSBnZXRJbmZvKG5vZGUpO1xuICAgICAgaWYgKG5vZGUuc2FtZShyb290KSkge1xuICAgICAgICBpbmZvLmRpc3QgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mby5kaXN0ID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBpbmZvLnByZWQgPSBudWxsO1xuICAgICAgaW5mby5lZGdlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBFZGdlcyByZWxheGF0aW9uXG4gICAgdmFyIHJlcGxhY2VkRWRnZSA9IGZhbHNlO1xuICAgIHZhciBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIGNoZWNrRm9yRWRnZVJlcGxhY2VtZW50KG5vZGUxLCBub2RlMiwgZWRnZSwgaW5mbzEsIGluZm8yLCB3ZWlnaHQpIHtcbiAgICAgIHZhciBkaXN0ID0gaW5mbzEuZGlzdCArIHdlaWdodDtcbiAgICAgIGlmIChkaXN0IDwgaW5mbzIuZGlzdCAmJiAhZWRnZS5zYW1lKGluZm8xLmVkZ2UpKSB7XG4gICAgICAgIGluZm8yLmRpc3QgPSBkaXN0O1xuICAgICAgICBpbmZvMi5wcmVkID0gbm9kZTE7XG4gICAgICAgIGluZm8yLmVkZ2UgPSBlZGdlO1xuICAgICAgICByZXBsYWNlZEVkZ2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IG51bU5vZGVzOyBfaSsrKSB7XG4gICAgICByZXBsYWNlZEVkZ2UgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgbnVtRWRnZXM7IGUrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG4gICAgICAgIHZhciBfd2VpZ2h0ID0gd2VpZ2h0Rm4oZWRnZSk7XG4gICAgICAgIHZhciBzcmNJbmZvID0gZ2V0SW5mbyhzcmMpO1xuICAgICAgICB2YXIgdGd0SW5mbyA9IGdldEluZm8odGd0KTtcbiAgICAgICAgY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQoc3JjLCB0Z3QsIGVkZ2UsIHNyY0luZm8sIHRndEluZm8sIF93ZWlnaHQpO1xuXG4gICAgICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlICdyZXZlcnNlJyBlZGdlXG4gICAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgICBjaGVja0ZvckVkZ2VSZXBsYWNlbWVudCh0Z3QsIHNyYywgZWRnZSwgdGd0SW5mbywgc3JjSW5mbywgX3dlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmVwbGFjZWRFZGdlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVwbGFjZWRFZGdlKSB7XG4gICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlc1xuICAgICAgdmFyIG5lZ2F0aXZlV2VpZ2h0Q3ljbGVJZHMgPSBbXTtcbiAgICAgIGZvciAodmFyIF9lID0gMDsgX2UgPCBudW1FZGdlczsgX2UrKykge1xuICAgICAgICB2YXIgX2VkZ2UgPSBlZGdlc1tfZV07XG4gICAgICAgIHZhciBfc3JjID0gX2VkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciBfdGd0ID0gX2VkZ2UudGFyZ2V0KCk7XG4gICAgICAgIHZhciBfd2VpZ2h0MiA9IHdlaWdodEZuKF9lZGdlKTtcbiAgICAgICAgdmFyIHNyY0Rpc3QgPSBnZXRJbmZvKF9zcmMpLmRpc3Q7XG4gICAgICAgIHZhciB0Z3REaXN0ID0gZ2V0SW5mbyhfdGd0KS5kaXN0O1xuICAgICAgICBpZiAoc3JjRGlzdCArIF93ZWlnaHQyIDwgdGd0RGlzdCB8fCAhZGlyZWN0ZWQgJiYgdGd0RGlzdCArIF93ZWlnaHQyIDwgc3JjRGlzdCkge1xuICAgICAgICAgIGlmICghaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSkge1xuICAgICAgICAgICAgd2FybignR3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGUgZm9yIEJlbGxtYW4tRm9yZCcpO1xuICAgICAgICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmZpbmROZWdhdGl2ZVdlaWdodEN5Y2xlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBuZWdhdGl2ZU5vZGVzID0gW107XG4gICAgICAgICAgICBpZiAoc3JjRGlzdCArIF93ZWlnaHQyIDwgdGd0RGlzdCkge1xuICAgICAgICAgICAgICBuZWdhdGl2ZU5vZGVzLnB1c2goX3NyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpcmVjdGVkICYmIHRndERpc3QgKyBfd2VpZ2h0MiA8IHNyY0Rpc3QpIHtcbiAgICAgICAgICAgICAgbmVnYXRpdmVOb2Rlcy5wdXNoKF90Z3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG51bU5lZ2F0aXZlTm9kZXMgPSBuZWdhdGl2ZU5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbnVtTmVnYXRpdmVOb2RlczsgbisrKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IG5lZ2F0aXZlTm9kZXNbbl07XG4gICAgICAgICAgICAgIHZhciBjeWNsZSA9IFtzdGFydF07XG4gICAgICAgICAgICAgIGN5Y2xlLnB1c2goZ2V0SW5mbyhzdGFydCkuZWRnZSk7XG4gICAgICAgICAgICAgIHZhciBfbm9kZSA9IGdldEluZm8oc3RhcnQpLnByZWQ7XG4gICAgICAgICAgICAgIHdoaWxlIChjeWNsZS5pbmRleE9mKF9ub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjeWNsZS5wdXNoKF9ub2RlKTtcbiAgICAgICAgICAgICAgICBjeWNsZS5wdXNoKGdldEluZm8oX25vZGUpLmVkZ2UpO1xuICAgICAgICAgICAgICAgIF9ub2RlID0gZ2V0SW5mbyhfbm9kZSkucHJlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjeWNsZSA9IGN5Y2xlLnNsaWNlKGN5Y2xlLmluZGV4T2YoX25vZGUpKTtcbiAgICAgICAgICAgICAgdmFyIHNtYWxsZXN0SWQgPSBjeWNsZVswXS5pZCgpO1xuICAgICAgICAgICAgICB2YXIgc21hbGxlc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgIGZvciAodmFyIGMgPSAyOyBjIDwgY3ljbGUubGVuZ3RoOyBjICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3ljbGVbY10uaWQoKSA8IHNtYWxsZXN0SWQpIHtcbiAgICAgICAgICAgICAgICAgIHNtYWxsZXN0SWQgPSBjeWNsZVtjXS5pZCgpO1xuICAgICAgICAgICAgICAgICAgc21hbGxlc3RJbmRleCA9IGM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGN5Y2xlID0gY3ljbGUuc2xpY2Uoc21hbGxlc3RJbmRleCkuY29uY2F0KGN5Y2xlLnNsaWNlKDAsIHNtYWxsZXN0SW5kZXgpKTtcbiAgICAgICAgICAgICAgY3ljbGUucHVzaChjeWNsZVswXSk7XG4gICAgICAgICAgICAgIHZhciBjeWNsZUlkID0gY3ljbGUubWFwKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5pZCgpO1xuICAgICAgICAgICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgaWYgKG5lZ2F0aXZlV2VpZ2h0Q3ljbGVJZHMuaW5kZXhPZihjeWNsZUlkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZVdlaWdodEN5Y2xlcy5wdXNoKGVsZXMuc3Bhd24oY3ljbGUpKTtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZVdlaWdodEN5Y2xlSWRzLnB1c2goY3ljbGVJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkaXN0YW5jZVRvOiBkaXN0YW5jZVRvLFxuICAgICAgcGF0aFRvOiBwYXRoVG8sXG4gICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlLFxuICAgICAgbmVnYXRpdmVXZWlnaHRDeWNsZXM6IG5lZ2F0aXZlV2VpZ2h0Q3ljbGVzXG4gICAgfTtcbiAgfSAvLyBiZWxsbWFuRm9yZFxufTsgLy8gZWxlc2ZuXG5cbnZhciBzcXJ0MiA9IE1hdGguc3FydCgyKTtcblxuLy8gRnVuY3Rpb24gd2hpY2ggY29sYXBzZXMgMiAobWV0YSkgbm9kZXMgaW50byBvbmVcbi8vIFVwZGF0ZXMgdGhlIHJlbWFpbmluZyBlZGdlIGxpc3RzXG4vLyBSZWNlaXZlcyBhcyBhIHBhcmFtYXRlciB0aGUgZWRnZSB3aGljaCBjYXVzZXMgdGhlIGNvbGxhcHNlXG52YXIgY29sbGFwc2UgPSBmdW5jdGlvbiBjb2xsYXBzZShlZGdlSW5kZXgsIG5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKSB7XG4gIGlmIChyZW1haW5pbmdFZGdlcy5sZW5ndGggPT09IDApIHtcbiAgICBlcnJvcihcIkthcmdlci1TdGVpbiBtdXN0IGJlIHJ1biBvbiBhIGNvbm5lY3RlZCAoc3ViKWdyYXBoXCIpO1xuICB9XG4gIHZhciBlZGdlSW5mbyA9IHJlbWFpbmluZ0VkZ2VzW2VkZ2VJbmRleF07XG4gIHZhciBzb3VyY2VJbiA9IGVkZ2VJbmZvWzFdO1xuICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgdmFyIHBhcnRpdGlvbjEgPSBub2RlTWFwW3NvdXJjZUluXTtcbiAgdmFyIHBhcnRpdGlvbjIgPSBub2RlTWFwW3RhcmdldEluXTtcbiAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXM7IC8vIHJlLXVzZSBhcnJheVxuXG4gIC8vIERlbGV0ZSBhbGwgZWRnZXMgYmV0d2VlbiBwYXJ0aXRpb24xIGFuZCBwYXJ0aXRpb24yXG4gIGZvciAodmFyIGkgPSBuZXdFZGdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBlZGdlID0gbmV3RWRnZXNbaV07XG4gICAgdmFyIHNyYyA9IGVkZ2VbMV07XG4gICAgdmFyIHRndCA9IGVkZ2VbMl07XG4gICAgaWYgKG5vZGVNYXBbc3JjXSA9PT0gcGFydGl0aW9uMSAmJiBub2RlTWFwW3RndF0gPT09IHBhcnRpdGlvbjIgfHwgbm9kZU1hcFtzcmNdID09PSBwYXJ0aXRpb24yICYmIG5vZGVNYXBbdGd0XSA9PT0gcGFydGl0aW9uMSkge1xuICAgICAgbmV3RWRnZXMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmV3RWRnZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9lZGdlID0gbmV3RWRnZXNbX2ldO1xuICAgIGlmIChfZWRnZVsxXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgLy8gQ2hlY2sgc291cmNlXG4gICAgICBuZXdFZGdlc1tfaV0gPSBfZWRnZS5zbGljZSgpOyAvLyBjb3B5XG4gICAgICBuZXdFZGdlc1tfaV1bMV0gPSBwYXJ0aXRpb24xO1xuICAgIH0gZWxzZSBpZiAoX2VkZ2VbMl0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgIC8vIENoZWNrIHRhcmdldFxuICAgICAgbmV3RWRnZXNbX2ldID0gX2VkZ2Uuc2xpY2UoKTsgLy8gY29weVxuICAgICAgbmV3RWRnZXNbX2ldWzJdID0gcGFydGl0aW9uMTtcbiAgICB9XG4gIH1cblxuICAvLyBNb3ZlIGFsbCBub2RlcyBmcm9tIHBhcnRpdGlvbjIgdG8gcGFydGl0aW9uMVxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlTWFwLmxlbmd0aDsgX2kyKyspIHtcbiAgICBpZiAobm9kZU1hcFtfaTJdID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICBub2RlTWFwW19pMl0gPSBwYXJ0aXRpb24xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3RWRnZXM7XG59O1xuXG4vLyBDb250cmFjdHMgYSBncmFwaCB1bnRpbCB3ZSByZWFjaCBhIGNlcnRhaW4gbnVtYmVyIG9mIG1ldGEgbm9kZXNcbnZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMsIHNpemUsIHNpemVMaW1pdCkge1xuICB3aGlsZSAoc2l6ZSA+IHNpemVMaW1pdCkge1xuICAgIC8vIENob29zZSBhbiBlZGdlIHJhbmRvbWx5XG4gICAgdmFyIGVkZ2VJbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCk7XG5cbiAgICAvLyBDb2xsYXBzZSBncmFwaCBiYXNlZCBvbiBlZGdlXG4gICAgcmVtYWluaW5nRWRnZXMgPSBjb2xsYXBzZShlZGdlSW5kZXgsIG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcyk7XG4gICAgc2l6ZS0tO1xuICB9XG4gIHJldHVybiByZW1haW5pbmdFZGdlcztcbn07XG52YXIgZWxlc2ZuJHAgPSB7XG4gIC8vIENvbXB1dGVzIHRoZSBtaW5pbXVtIGN1dCBvZiBhbiB1bmRpcmVjdGVkIGdyYXBoXG4gIC8vIFJldHVybnMgdGhlIGNvcnJlY3QgYW5zd2VyIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuICBrYXJnZXJTdGVpbjogZnVuY3Rpb24ga2FyZ2VyU3RlaW4oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgX3RoaXMkYnlHcm91cCA9IHRoaXMuYnlHcm91cCgpLFxuICAgICAgbm9kZXMgPSBfdGhpcyRieUdyb3VwLm5vZGVzLFxuICAgICAgZWRnZXMgPSBfdGhpcyRieUdyb3VwLmVkZ2VzO1xuICAgIGVkZ2VzLnVubWVyZ2VCeShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuaXNMb29wKCk7XG4gICAgfSk7XG4gICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICB2YXIgbnVtSXRlciA9IE1hdGguY2VpbChNYXRoLnBvdyhNYXRoLmxvZyhudW1Ob2RlcykgLyBNYXRoLkxOMiwgMikpO1xuICAgIHZhciBzdG9wU2l6ZSA9IE1hdGguZmxvb3IobnVtTm9kZXMgLyBzcXJ0Mik7XG4gICAgaWYgKG51bU5vZGVzIDwgMikge1xuICAgICAgZXJyb3IoJ0F0IGxlYXN0IDIgbm9kZXMgYXJlIHJlcXVpcmVkIGZvciBLYXJnZXItU3RlaW4gYWxnb3JpdGhtJyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIE5vdyBzdG9yZSBlZGdlIGRlc3RpbmF0aW9uIGFzIGluZGV4ZXNcbiAgICAvLyBGb3JtYXQgZm9yIGVhY2ggZWRnZSAoZWRnZSBpbmRleCwgc291cmNlIG5vZGUgaW5kZXgsIHRhcmdldCBub2RlIGluZGV4KVxuICAgIHZhciBlZGdlSW5kZXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKykge1xuICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgIGVkZ2VJbmRleGVzLnB1c2goW2ksIG5vZGVzLmluZGV4T2YoZS5zb3VyY2UoKSksIG5vZGVzLmluZGV4T2YoZS50YXJnZXQoKSldKTtcbiAgICB9XG5cbiAgICAvLyBXZSB3aWxsIHN0b3JlIHRoZSBiZXN0IGN1dCBmb3VuZCBoZXJlXG4gICAgdmFyIG1pbkN1dFNpemUgPSBJbmZpbml0eTtcbiAgICB2YXIgbWluQ3V0RWRnZUluZGV4ZXMgPSBbXTtcbiAgICB2YXIgbWluQ3V0Tm9kZU1hcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG5cbiAgICAvLyBJbml0aWFsIG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICB2YXIgbWV0YU5vZGVNYXAgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBtZXRhTm9kZU1hcDIgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgIHZhciBjb3B5Tm9kZXNNYXAgPSBmdW5jdGlvbiBjb3B5Tm9kZXNNYXAoZnJvbSwgdG8pIHtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bU5vZGVzOyBfaTMrKykge1xuICAgICAgICB0b1tfaTNdID0gZnJvbVtfaTNdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBNYWluIGxvb3BcbiAgICBmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8PSBudW1JdGVyOyBpdGVyKyspIHtcbiAgICAgIC8vIFJlc2V0IG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG51bU5vZGVzOyBfaTQrKykge1xuICAgICAgICBtZXRhTm9kZU1hcFtfaTRdID0gX2k0O1xuICAgICAgfVxuXG4gICAgICAvLyBDb250cmFjdCB1bnRpbCBzdG9wIHBvaW50IChzdG9wU2l6ZSBub2RlcylcbiAgICAgIHZhciBlZGdlc1N0YXRlID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZUluZGV4ZXMuc2xpY2UoKSwgbnVtTm9kZXMsIHN0b3BTaXplKTtcbiAgICAgIHZhciBlZGdlc1N0YXRlMiA9IGVkZ2VzU3RhdGUuc2xpY2UoKTsgLy8gY29weVxuXG4gICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb2xhcHNlZCBub2RlcyBzdGF0ZVxuICAgICAgY29weU5vZGVzTWFwKG1ldGFOb2RlTWFwLCBtZXRhTm9kZU1hcDIpO1xuXG4gICAgICAvLyBSdW4gMiBpdGVyYXRpb25zIHN0YXJ0aW5nIGluIHRoZSBzdG9wIHN0YXRlXG4gICAgICB2YXIgcmVzMSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyKTtcbiAgICAgIHZhciByZXMyID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcDIsIGVkZ2VzU3RhdGUyLCBzdG9wU2l6ZSwgMik7XG5cbiAgICAgIC8vIElzIGFueSBvZiB0aGUgMiByZXN1bHRzIHRoZSBiZXN0IGN1dCBzbyBmYXI/XG4gICAgICBpZiAocmVzMS5sZW5ndGggPD0gcmVzMi5sZW5ndGggJiYgcmVzMS5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgIG1pbkN1dFNpemUgPSByZXMxLmxlbmd0aDtcbiAgICAgICAgbWluQ3V0RWRnZUluZGV4ZXMgPSByZXMxO1xuICAgICAgICBjb3B5Tm9kZXNNYXAobWV0YU5vZGVNYXAsIG1pbkN1dE5vZGVNYXApO1xuICAgICAgfSBlbHNlIGlmIChyZXMyLmxlbmd0aCA8PSByZXMxLmxlbmd0aCAmJiByZXMyLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczIubGVuZ3RoO1xuICAgICAgICBtaW5DdXRFZGdlSW5kZXhlcyA9IHJlczI7XG4gICAgICAgIGNvcHlOb2Rlc01hcChtZXRhTm9kZU1hcDIsIG1pbkN1dE5vZGVNYXApO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIG9mIG1haW4gbG9vcFxuXG4gICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgIHZhciBjdXQgPSB0aGlzLnNwYXduKG1pbkN1dEVkZ2VJbmRleGVzLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGVkZ2VzW2VbMF1dO1xuICAgIH0pKTtcbiAgICB2YXIgcGFydGl0aW9uMSA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgcGFydGl0aW9uMiA9IHRoaXMuc3Bhd24oKTtcblxuICAgIC8vIHRyYXZlcnNlIG1ldGFOb2RlTWFwIGZvciBiZXN0IGN1dFxuICAgIHZhciB3aXRuZXNzTm9kZVBhcnRpdGlvbiA9IG1pbkN1dE5vZGVNYXBbMF07XG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbWluQ3V0Tm9kZU1hcC5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICB2YXIgcGFydGl0aW9uSWQgPSBtaW5DdXROb2RlTWFwW19pNV07XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW19pNV07XG4gICAgICBpZiAocGFydGl0aW9uSWQgPT09IHdpdG5lc3NOb2RlUGFydGl0aW9uKSB7XG4gICAgICAgIHBhcnRpdGlvbjEubWVyZ2Uobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0aXRpb24yLm1lcmdlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0cnVjdCBjb21wb25lbnRzIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBkaXNqb2ludCBzdWJzZXQgb2Ygbm9kZXNcbiAgICB2YXIgY29uc3RydWN0Q29tcG9uZW50ID0gZnVuY3Rpb24gY29uc3RydWN0Q29tcG9uZW50KHN1YnNldCkge1xuICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLnNwYXduKCk7XG4gICAgICBzdWJzZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBjb21wb25lbnQubWVyZ2Uobm9kZSk7XG4gICAgICAgIG5vZGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgLy8gZW5zdXJlIGVkZ2UgaXMgd2l0aGluIGNhbGxpbmcgY29sbGVjdGlvbiBhbmQgZWRnZSBpcyBub3QgaW4gY3V0XG4gICAgICAgICAgaWYgKF90aGlzLmNvbnRhaW5zKGVkZ2UpICYmICFjdXQuY29udGFpbnMoZWRnZSkpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5tZXJnZShlZGdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gY29tcG9uZW50O1xuICAgIH07XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbY29uc3RydWN0Q29tcG9uZW50KHBhcnRpdGlvbjEpLCBjb25zdHJ1Y3RDb21wb25lbnQocGFydGl0aW9uMildO1xuICAgIHZhciByZXQgPSB7XG4gICAgICBjdXQ6IGN1dCxcbiAgICAgIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gICAgICAvLyBuLmIuIHBhcnRpdGlvbnMgYXJlIGluY2x1ZGVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgb2xkIGFwaSBzcGVjXG4gICAgICAvLyAoY291bGQgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciB2ZXJzaW9uKVxuICAgICAgcGFydGl0aW9uMTogcGFydGl0aW9uMSxcbiAgICAgIHBhcnRpdGlvbjI6IHBhcnRpdGlvbjJcbiAgICB9O1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn07IC8vIGVsZXNmblxuXG52YXIgX01hdGgkaHlwb3Q7XG52YXIgY29weVBvc2l0aW9uID0gZnVuY3Rpb24gY29weVBvc2l0aW9uKHApIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwLngsXG4gICAgeTogcC55XG4gIH07XG59O1xudmFyIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uJDEgPSBmdW5jdGlvbiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihwLCB6b29tLCBwYW4pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwLnggKiB6b29tICsgcGFuLngsXG4gICAgeTogcC55ICogem9vbSArIHBhbi55XG4gIH07XG59O1xudmFyIHJlbmRlcmVkVG9Nb2RlbFBvc2l0aW9uID0gZnVuY3Rpb24gcmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocCwgem9vbSwgcGFuKSB7XG4gIHJldHVybiB7XG4gICAgeDogKHAueCAtIHBhbi54KSAvIHpvb20sXG4gICAgeTogKHAueSAtIHBhbi55KSAvIHpvb21cbiAgfTtcbn07XG52YXIgYXJyYXkycG9pbnQgPSBmdW5jdGlvbiBhcnJheTJwb2ludChhcnIpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhcnJbMF0sXG4gICAgeTogYXJyWzFdXG4gIH07XG59O1xudmFyIG1pbiA9IGZ1bmN0aW9uIG1pbihhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgbWluID0gSW5maW5pdHk7XG4gIGZvciAodmFyIGkgPSBiZWdpbjsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIHZhbCA9IGFycltpXTtcbiAgICBpZiAoaXNGaW5pdGUodmFsKSkge1xuICAgICAgbWluID0gTWF0aC5taW4odmFsLCBtaW4pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluO1xufTtcbnZhciBtYXggPSBmdW5jdGlvbiBtYXgoYXJyKSB7XG4gIHZhciBiZWdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogYXJyLmxlbmd0aDtcbiAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xuICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICBtYXggPSBNYXRoLm1heCh2YWwsIG1heCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXg7XG59O1xudmFyIG1lYW4gPSBmdW5jdGlvbiBtZWFuKGFycikge1xuICB2YXIgYmVnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGFyci5sZW5ndGg7XG4gIHZhciB0b3RhbCA9IDA7XG4gIHZhciBuID0gMDtcbiAgZm9yICh2YXIgaSA9IGJlZ2luOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgdmFsID0gYXJyW2ldO1xuICAgIGlmIChpc0Zpbml0ZSh2YWwpKSB7XG4gICAgICB0b3RhbCArPSB2YWw7XG4gICAgICBuKys7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b3RhbCAvIG47XG59O1xudmFyIG1lZGlhbiA9IGZ1bmN0aW9uIG1lZGlhbihhcnIpIHtcbiAgdmFyIGJlZ2luID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBhcnIubGVuZ3RoO1xuICB2YXIgY29weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNvcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gIHZhciBpbmNsdWRlSG9sZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIGlmIChjb3B5KSB7XG4gICAgYXJyID0gYXJyLnNsaWNlKGJlZ2luLCBlbmQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChlbmQgPCBhcnIubGVuZ3RoKSB7XG4gICAgICBhcnIuc3BsaWNlKGVuZCwgYXJyLmxlbmd0aCAtIGVuZCk7XG4gICAgfVxuICAgIGlmIChiZWdpbiA+IDApIHtcbiAgICAgIGFyci5zcGxpY2UoMCwgYmVnaW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFsbCBub24gZmluaXRlIChlLmcuIEluZmluaXR5LCBOYU4pIGVsZW1lbnRzIG11c3QgYmUgLUluZmluaXR5IHNvIHRoZXkgZ28gdG8gdGhlIHN0YXJ0XG4gIHZhciBvZmYgPSAwOyAvLyBvZmZzZXQgZnJvbSBub24tZmluaXRlIHZhbHVlc1xuICBmb3IgKHZhciBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHYgPSBhcnJbaV07XG4gICAgaWYgKGluY2x1ZGVIb2xlcykge1xuICAgICAgaWYgKCFpc0Zpbml0ZSh2KSkge1xuICAgICAgICBhcnJbaV0gPSAtSW5maW5pdHk7XG4gICAgICAgIG9mZisrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBqdXN0IHJlbW92ZSBpdCBpZiB3ZSBkb24ndCB3YW50IHRvIGNvbnNpZGVyIGhvbGVzXG4gICAgICBhcnIuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBpZiAoc29ydCkge1xuICAgIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYSAtIGI7XG4gICAgfSk7IC8vIHJlcXVpcmVzIGNvcHkgPSB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGUgb3JpZ1xuICB9XG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICB2YXIgbWlkID0gTWF0aC5mbG9vcihsZW4gLyAyKTtcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICByZXR1cm4gYXJyW21pZCArIDEgKyBvZmZdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoYXJyW21pZCAtIDEgKyBvZmZdICsgYXJyW21pZCArIG9mZl0pIC8gMjtcbiAgfVxufTtcbnZhciBkZWcycmFkID0gZnVuY3Rpb24gZGVnMnJhZChkZWcpIHtcbiAgcmV0dXJuIE1hdGguUEkgKiBkZWcgLyAxODA7XG59O1xudmFyIGdldEFuZ2xlRnJvbURpc3AgPSBmdW5jdGlvbiBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSkge1xuICByZXR1cm4gTWF0aC5hdGFuMihkaXNwWSwgZGlzcFgpIC0gTWF0aC5QSSAvIDI7XG59O1xudmFyIGxvZzIgPSBNYXRoLmxvZzIgfHwgZnVuY3Rpb24gKG4pIHtcbiAgcmV0dXJuIE1hdGgubG9nKG4pIC8gTWF0aC5sb2coMik7XG59O1xudmFyIHNpZ251bSA9IGZ1bmN0aW9uIHNpZ251bSh4KSB7XG4gIGlmICh4ID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHggPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xudmFyIGRpc3QgPSBmdW5jdGlvbiBkaXN0KHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHNxZGlzdChwMSwgcDIpKTtcbn07XG52YXIgc3FkaXN0ID0gZnVuY3Rpb24gc3FkaXN0KHAxLCBwMikge1xuICB2YXIgZHggPSBwMi54IC0gcDEueDtcbiAgdmFyIGR5ID0gcDIueSAtIHAxLnk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn07XG52YXIgaW5QbGFjZVN1bU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIGluUGxhY2VTdW1Ob3JtYWxpemUodikge1xuICB2YXIgbGVuZ3RoID0gdi5sZW5ndGg7XG5cbiAgLy8gRmlyc3QsIGdldCBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gIHZhciB0b3RhbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB0b3RhbCArPSB2W2ldO1xuICB9XG5cbiAgLy8gTm93LCBkaXZpZGUgZWFjaCBieSB0aGUgc3VtIG9mIGFsbCBlbGVtZW50c1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGVuZ3RoOyBfaSsrKSB7XG4gICAgdltfaV0gPSB2W19pXSAvIHRvdGFsO1xuICB9XG4gIHJldHVybiB2O1xufTtcblxuLy8gZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0LDqXppZXJfY3VydmUjUXVhZHJhdGljX2N1cnZlc1xudmFyIHFiZXppZXJBdCA9IGZ1bmN0aW9uIHFiZXppZXJBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiAoMSAtIHQpICogKDEgLSB0KSAqIHAwICsgMiAqICgxIC0gdCkgKiB0ICogcDEgKyB0ICogdCAqIHAyO1xufTtcbnZhciBxYmV6aWVyUHRBdCA9IGZ1bmN0aW9uIHFiZXppZXJQdEF0KHAwLCBwMSwgcDIsIHQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBxYmV6aWVyQXQocDAueCwgcDEueCwgcDIueCwgdCksXG4gICAgeTogcWJlemllckF0KHAwLnksIHAxLnksIHAyLnksIHQpXG4gIH07XG59O1xudmFyIGxpbmVBdCA9IGZ1bmN0aW9uIGxpbmVBdChwMCwgcDEsIHQsIGQpIHtcbiAgdmFyIHZlYyA9IHtcbiAgICB4OiBwMS54IC0gcDAueCxcbiAgICB5OiBwMS55IC0gcDAueVxuICB9O1xuICB2YXIgdmVjRGlzdCA9IGRpc3QocDAsIHAxKTtcbiAgdmFyIG5vcm1WZWMgPSB7XG4gICAgeDogdmVjLnggLyB2ZWNEaXN0LFxuICAgIHk6IHZlYy55IC8gdmVjRGlzdFxuICB9O1xuICB0ID0gdCA9PSBudWxsID8gMCA6IHQ7XG4gIGQgPSBkICE9IG51bGwgPyBkIDogdCAqIHZlY0Rpc3Q7XG4gIHJldHVybiB7XG4gICAgeDogcDAueCArIG5vcm1WZWMueCAqIGQsXG4gICAgeTogcDAueSArIG5vcm1WZWMueSAqIGRcbiAgfTtcbn07XG52YXIgYm91bmQgPSBmdW5jdGlvbiBib3VuZChtaW4sIHZhbCwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsKSk7XG59O1xuXG4vLyBtYWtlcyBhIGZ1bGwgYmIgKHgxLCB5MSwgeDIsIHkyLCB3LCBoKSBmcm9tIGltcGxpY2l0IHBhcmFtc1xudmFyIG1ha2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIG1ha2VCb3VuZGluZ0JveChiYikge1xuICBpZiAoYmIgPT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogSW5maW5pdHksXG4gICAgICB5MTogSW5maW5pdHksXG4gICAgICB4MjogLUluZmluaXR5LFxuICAgICAgeTI6IC1JbmZpbml0eSxcbiAgICAgIHc6IDAsXG4gICAgICBoOiAwXG4gICAgfTtcbiAgfSBlbHNlIGlmIChiYi54MSAhPSBudWxsICYmIGJiLnkxICE9IG51bGwpIHtcbiAgICBpZiAoYmIueDIgIT0gbnVsbCAmJiBiYi55MiAhPSBudWxsICYmIGJiLngyID49IGJiLngxICYmIGJiLnkyID49IGJiLnkxKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogYmIueDEsXG4gICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgeDI6IGJiLngyLFxuICAgICAgICB5MjogYmIueTIsXG4gICAgICAgIHc6IGJiLngyIC0gYmIueDEsXG4gICAgICAgIGg6IGJiLnkyIC0gYmIueTFcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChiYi53ICE9IG51bGwgJiYgYmIuaCAhPSBudWxsICYmIGJiLncgPj0gMCAmJiBiYi5oID49IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICB4MjogYmIueDEgKyBiYi53LFxuICAgICAgICB5MjogYmIueTEgKyBiYi5oLFxuICAgICAgICB3OiBiYi53LFxuICAgICAgICBoOiBiYi5oXG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcbnZhciBjb3B5Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiBjb3B5Qm91bmRpbmdCb3goYmIpIHtcbiAgcmV0dXJuIHtcbiAgICB4MTogYmIueDEsXG4gICAgeDI6IGJiLngyLFxuICAgIHc6IGJiLncsXG4gICAgeTE6IGJiLnkxLFxuICAgIHkyOiBiYi55MixcbiAgICBoOiBiYi5oXG4gIH07XG59O1xudmFyIGNsZWFyQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBjbGVhckJvdW5kaW5nQm94KGJiKSB7XG4gIGJiLngxID0gSW5maW5pdHk7XG4gIGJiLnkxID0gSW5maW5pdHk7XG4gIGJiLngyID0gLUluZmluaXR5O1xuICBiYi55MiA9IC1JbmZpbml0eTtcbiAgYmIudyA9IDA7XG4gIGJiLmggPSAwO1xufTtcbnZhciB1cGRhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gIC8vIHVwZGF0ZSBiYjEgd2l0aCBiYjIgYm91bmRzXG5cbiAgYmIxLngxID0gTWF0aC5taW4oYmIxLngxLCBiYjIueDEpO1xuICBiYjEueDIgPSBNYXRoLm1heChiYjEueDIsIGJiMi54Mik7XG4gIGJiMS53ID0gYmIxLngyIC0gYmIxLngxO1xuICBiYjEueTEgPSBNYXRoLm1pbihiYjEueTEsIGJiMi55MSk7XG4gIGJiMS55MiA9IE1hdGgubWF4KGJiMS55MiwgYmIyLnkyKTtcbiAgYmIxLmggPSBiYjEueTIgLSBiYjEueTE7XG59O1xudmFyIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludCA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgeCwgeSkge1xuICBiYi54MSA9IE1hdGgubWluKGJiLngxLCB4KTtcbiAgYmIueDIgPSBNYXRoLm1heChiYi54MiwgeCk7XG4gIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICBiYi55MSA9IE1hdGgubWluKGJiLnkxLCB5KTtcbiAgYmIueTIgPSBNYXRoLm1heChiYi55MiwgeSk7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xufTtcbnZhciBleHBhbmRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94KGJiKSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICBiYi54MSAtPSBwYWRkaW5nO1xuICBiYi54MiArPSBwYWRkaW5nO1xuICBiYi55MSAtPSBwYWRkaW5nO1xuICBiYi55MiArPSBwYWRkaW5nO1xuICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG4gIHJldHVybiBiYjtcbn07XG52YXIgZXhwYW5kQm91bmRpbmdCb3hTaWRlcyA9IGZ1bmN0aW9uIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmIpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFswXTtcbiAgdmFyIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdDtcbiAgaWYgKHBhZGRpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgdG9wID0gcmlnaHQgPSBib3R0b20gPSBsZWZ0ID0gcGFkZGluZ1swXTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gMikge1xuICAgIHRvcCA9IGJvdHRvbSA9IHBhZGRpbmdbMF07XG4gICAgbGVmdCA9IHJpZ2h0ID0gcGFkZGluZ1sxXTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBfcGFkZGluZyA9IF9zbGljZWRUb0FycmF5KHBhZGRpbmcsIDQpO1xuICAgIHRvcCA9IF9wYWRkaW5nWzBdO1xuICAgIHJpZ2h0ID0gX3BhZGRpbmdbMV07XG4gICAgYm90dG9tID0gX3BhZGRpbmdbMl07XG4gICAgbGVmdCA9IF9wYWRkaW5nWzNdO1xuICB9XG4gIGJiLngxIC09IGxlZnQ7XG4gIGJiLngyICs9IHJpZ2h0O1xuICBiYi55MSAtPSB0b3A7XG4gIGJiLnkyICs9IGJvdHRvbTtcbiAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICByZXR1cm4gYmI7XG59O1xuXG4vLyBhc3NpZ24gdGhlIHZhbHVlcyBvZiBiYjIgaW50byBiYjFcbnZhciBhc3NpZ25Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uIGFzc2lnbkJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gIGJiMS54MSA9IGJiMi54MTtcbiAgYmIxLnkxID0gYmIyLnkxO1xuICBiYjEueDIgPSBiYjIueDI7XG4gIGJiMS55MiA9IGJiMi55MjtcbiAgYmIxLncgPSBiYjEueDIgLSBiYjEueDE7XG4gIGJiMS5oID0gYmIxLnkyIC0gYmIxLnkxO1xufTtcbnZhciBib3VuZGluZ0JveGVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gYm91bmRpbmdCb3hlc0ludGVyc2VjdChiYjEsIGJiMikge1xuICAvLyBjYXNlOiBvbmUgYmIgdG8gcmlnaHQgb2Ygb3RoZXJcbiAgaWYgKGJiMS54MSA+IGJiMi54Mikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYmIyLngxID4gYmIxLngyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2FzZTogb25lIGJiIHRvIGxlZnQgb2Ygb3RoZXJcbiAgaWYgKGJiMS54MiA8IGJiMi54MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYmIyLngyIDwgYmIxLngxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gY2FzZTogb25lIGJiIGFib3ZlIG90aGVyXG4gIGlmIChiYjEueTIgPCBiYjIueTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGJiMi55MiA8IGJiMS55MSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGNhc2U6IG9uZSBiYiBiZWxvdyBvdGhlclxuICBpZiAoYmIxLnkxID4gYmIyLnkyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChiYjIueTEgPiBiYjEueTIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIG11c3QgaGF2ZSBzb21lIG92ZXJsYXBcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBpbkJvdW5kaW5nQm94KGJiLCB4LCB5KSB7XG4gIHJldHVybiBiYi54MSA8PSB4ICYmIHggPD0gYmIueDIgJiYgYmIueTEgPD0geSAmJiB5IDw9IGJiLnkyO1xufTtcbnZhciBwb2ludEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiBwb2ludEluQm91bmRpbmdCb3goYmIsIHB0KSB7XG4gIHJldHVybiBpbkJvdW5kaW5nQm94KGJiLCBwdC54LCBwdC55KTtcbn07XG52YXIgYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24gYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KGJiMSwgYmIyKSB7XG4gIHJldHVybiBpbkJvdW5kaW5nQm94KGJiMSwgYmIyLngxLCBiYjIueTEpICYmIGluQm91bmRpbmdCb3goYmIxLCBiYjIueDIsIGJiMi55Mik7XG59O1xudmFyIGh5cG90ID0gKF9NYXRoJGh5cG90ID0gTWF0aC5oeXBvdCkgIT09IG51bGwgJiYgX01hdGgkaHlwb3QgIT09IHVuZGVmaW5lZCA/IF9NYXRoJGh5cG90IDogZnVuY3Rpb24gKHgsIHkpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn07XG5mdW5jdGlvbiBpbmZsYXRlUG9seWdvbihwb2x5Z29uLCBkKSB7XG4gIGlmIChwb2x5Z29uLmxlbmd0aCA8IDMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05lZWQgYXQgbGVhc3QgMyB2ZXJ0aWNlcycpO1xuICB9XG4gIC8vIEhlbHBlcnNcbiAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGEueCArIGIueCxcbiAgICAgIHk6IGEueSArIGIueVxuICAgIH07XG4gIH07XG4gIHZhciBzdWIgPSBmdW5jdGlvbiBzdWIoYSwgYikge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBhLnggLSBiLngsXG4gICAgICB5OiBhLnkgLSBiLnlcbiAgICB9O1xuICB9O1xuICB2YXIgc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2LCBzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHYueCAqIHMsXG4gICAgICB5OiB2LnkgKiBzXG4gICAgfTtcbiAgfTtcbiAgdmFyIGNyb3NzID0gZnVuY3Rpb24gY3Jvc3ModSwgdikge1xuICAgIHJldHVybiB1LnggKiB2LnkgLSB1LnkgKiB2Lng7XG4gIH07XG4gIHZhciBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUodikge1xuICAgIHZhciBsZW4gPSBoeXBvdCh2LngsIHYueSk7XG4gICAgcmV0dXJuIGxlbiA9PT0gMCA/IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSA6IHtcbiAgICAgIHg6IHYueCAvIGxlbixcbiAgICAgIHk6IHYueSAvIGxlblxuICAgIH07XG4gIH07XG4gIC8vIFNpZ25lZCBhcmVhIChwb3NpdGl2ZSA9IENDVylcbiAgdmFyIHNpZ25lZEFyZWEgPSBmdW5jdGlvbiBzaWduZWRBcmVhKHB0cykge1xuICAgIHZhciBBID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBwdHNbaV0sXG4gICAgICAgIHEgPSBwdHNbKGkgKyAxKSAlIHB0cy5sZW5ndGhdO1xuICAgICAgQSArPSBwLnggKiBxLnkgLSBxLnggKiBwLnk7XG4gICAgfVxuICAgIHJldHVybiBBIC8gMjtcbiAgfTtcbiAgLy8gTGluZeKAk2xpbmUgaW50ZXJzZWN0aW9uIChpbmZpbml0ZSBsaW5lcylcbiAgdmFyIGludGVyc2VjdExpbmVzID0gZnVuY3Rpb24gaW50ZXJzZWN0TGluZXMocDEsIHAyLCBwMywgcDQpIHtcbiAgICB2YXIgciA9IHN1YihwMiwgcDEpO1xuICAgIHZhciBzID0gc3ViKHA0LCBwMyk7XG4gICAgdmFyIGRlbm9tID0gY3Jvc3Mociwgcyk7XG4gICAgaWYgKE1hdGguYWJzKGRlbm9tKSA8IDFlLTkpIHtcbiAgICAgIC8vIFBhcmFsbGVsIG9yIG5lYXJseSBzbyDigJQgZmFsbGJhY2sgdG8gbWlkcG9pbnRcbiAgICAgIHJldHVybiBhZGQocDEsIHNjYWxlKHIsIDAuNSkpO1xuICAgIH1cbiAgICB2YXIgdCA9IGNyb3NzKHN1YihwMywgcDEpLCBzKSAvIGRlbm9tO1xuICAgIHJldHVybiBhZGQocDEsIHNjYWxlKHIsIHQpKTtcbiAgfTtcblxuICAvLyBNYWtlIGEgc2hhbGxvdyBjb3B5IGFuZCBlbmZvcmNlIENDV1xuICB2YXIgcHRzID0gcG9seWdvbi5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcC54LFxuICAgICAgeTogcC55XG4gICAgfTtcbiAgfSk7XG4gIGlmIChzaWduZWRBcmVhKHB0cykgPCAwKSBwdHMucmV2ZXJzZSgpO1xuICB2YXIgbiA9IHB0cy5sZW5ndGg7XG4gIC8vIENvbXB1dGUgb3V0d2FyZCBub3JtYWxzIGZvciBlYWNoIGVkZ2VcbiAgdmFyIG5vcm1hbHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgcCA9IHB0c1tpXSxcbiAgICAgIHEgPSBwdHNbKGkgKyAxKSAlIG5dO1xuICAgIHZhciBlZGdlID0gc3ViKHEsIHApO1xuICAgIC8vIEZvciBDQ1cgcG9seWdvbiwgaW53YXJkIG5vcm1hbCA9ICgtZWRnZS55LCBlZGdlLngpXG4gICAgLy8gc28gb3V0d2FyZCBub3JtYWwgPSAoZWRnZS55LCAtZWRnZS54KVxuICAgIHZhciBvdXQgPSBub3JtYWxpemUoe1xuICAgICAgeDogZWRnZS55LFxuICAgICAgeTogLWVkZ2UueFxuICAgIH0pO1xuICAgIG5vcm1hbHMucHVzaChvdXQpO1xuICB9XG5cbiAgLy8gQnVpbGQgb2Zmc2V0IGVkZ2VzXG4gIHZhciBvZmZzZXRFZGdlcyA9IG5vcm1hbHMubWFwKGZ1bmN0aW9uIChucm0sIGkpIHtcbiAgICB2YXIgcDEgPSBhZGQocHRzW2ldLCBzY2FsZShucm0sIGQpKTtcbiAgICB2YXIgcDIgPSBhZGQocHRzWyhpICsgMSkgJSBuXSwgc2NhbGUobnJtLCBkKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHAxOiBwMSxcbiAgICAgIHAyOiBwMlxuICAgIH07XG4gIH0pO1xuXG4gIC8vIEludGVyc2VjdCBjb25zZWN1dGl2ZSBvZmZzZXQgZWRnZXNcbiAgdmFyIGluZmxhdGVkID0gW107XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG47IF9pMisrKSB7XG4gICAgdmFyIHByZXZFZGdlID0gb2Zmc2V0RWRnZXNbKF9pMiAtIDEgKyBuKSAlIG5dO1xuICAgIHZhciBjdXJyRWRnZSA9IG9mZnNldEVkZ2VzW19pMl07XG4gICAgdmFyIGlwID0gaW50ZXJzZWN0TGluZXMocHJldkVkZ2UucDEsIHByZXZFZGdlLnAyLCBjdXJyRWRnZS5wMSwgY3VyckVkZ2UucDIpO1xuICAgIGluZmxhdGVkLnB1c2goaXApO1xuICB9XG4gIHJldHVybiBpbmZsYXRlZDtcbn1cbmZ1bmN0aW9uIG1pdGVyQm94KHB0cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgc3Ryb2tlV2lkdGgpIHtcbiAgdmFyIHRwdHMgPSB0cmFuc2Zvcm1Qb2ludHMocHRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIG9mZnNldFBvaW50cyA9IGluZmxhdGVQb2x5Z29uKHRwdHMsIHN0cm9rZVdpZHRoKTtcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gIG9mZnNldFBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwdCkge1xuICAgIHJldHVybiBleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQoYmIsIHB0LngsIHB0LnkpO1xuICB9KTtcbiAgcmV0dXJuIGJiO1xufVxudmFyIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdmFyIHJhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA3ICYmIGFyZ3VtZW50c1s3XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzddIDogJ2F1dG8nO1xuICB2YXIgY29ybmVyUmFkaXVzID0gcmFkaXVzID09PSAnYXV0bycgPyBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KSA6IHJhZGl1cztcbiAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICBjb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihjb3JuZXJSYWRpdXMsIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gIHZhciBkb1dpZHRoID0gY29ybmVyUmFkaXVzICE9PSBoYWxmV2lkdGgsXG4gICAgZG9IZWlnaHQgPSBjb3JuZXJSYWRpdXMgIT09IGhhbGZIZWlnaHQ7XG5cbiAgLy8gQ2hlY2sgaW50ZXJzZWN0aW9ucyB3aXRoIHN0cmFpZ2h0IGxpbmUgc2VnbWVudHNcbiAgdmFyIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG5cbiAgLy8gVG9wIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcbiAgaWYgKGRvV2lkdGgpIHtcbiAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgLSBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIHRvcFN0YXJ0WCwgdG9wU3RhcnRZLCB0b3BFbmRYLCB0b3BFbmRZLCBmYWxzZSk7XG4gICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICBpZiAoZG9IZWlnaHQpIHtcbiAgICB2YXIgcmlnaHRTdGFydFggPSBub2RlWCArIGhhbGZXaWR0aCArIHBhZGRpbmc7XG4gICAgdmFyIHJpZ2h0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgcmlnaHRFbmRYID0gcmlnaHRTdGFydFg7XG4gICAgdmFyIHJpZ2h0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIG5vZGVYLCBub2RlWSwgcmlnaHRTdGFydFgsIHJpZ2h0U3RhcnRZLCByaWdodEVuZFgsIHJpZ2h0RW5kWSwgZmFsc2UpO1xuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIEJvdHRvbSBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gIGlmIChkb1dpZHRoKSB7XG4gICAgdmFyIGJvdHRvbVN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICB2YXIgYm90dG9tU3RhcnRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0ICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgYm90dG9tRW5kWSA9IGJvdHRvbVN0YXJ0WTtcbiAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCBib3R0b21TdGFydFgsIGJvdHRvbVN0YXJ0WSwgYm90dG9tRW5kWCwgYm90dG9tRW5kWSwgZmFsc2UpO1xuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIExlZnQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICBpZiAoZG9IZWlnaHQpIHtcbiAgICB2YXIgbGVmdFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoIC0gcGFkZGluZztcbiAgICB2YXIgbGVmdFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGxlZnRFbmRYID0gbGVmdFN0YXJ0WDtcbiAgICB2YXIgbGVmdEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBub2RlWCwgbm9kZVksIGxlZnRTdGFydFgsIGxlZnRTdGFydFksIGxlZnRFbmRYLCBsZWZ0RW5kWSwgZmFsc2UpO1xuICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBhcmMgc2VnbWVudHNcbiAgdmFyIGFyY0ludGVyc2VjdGlvbnM7XG5cbiAgLy8gVG9wIExlZnRcbiAge1xuICAgIHZhciB0b3BMZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgIHZhciB0b3BMZWZ0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICBhcmNJbnRlcnNlY3Rpb25zID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBub2RlWCwgbm9kZVksIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG5cbiAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gdG9wTGVmdENlbnRlclggJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BMZWZ0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyBUb3AgUmlnaHRcbiAge1xuICAgIHZhciB0b3BSaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgdG9wUmlnaHRDZW50ZXJYLCB0b3BSaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IHRvcFJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdIDw9IHRvcFJpZ2h0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gUmlnaHRcbiAge1xuICAgIHZhciBib3R0b21SaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICB2YXIgYm90dG9tUmlnaHRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tUmlnaHRDZW50ZXJYLCBib3R0b21SaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMCAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IGJvdHRvbVJpZ2h0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbVJpZ2h0Q2VudGVyWSkge1xuICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyBCb3R0b20gTGVmdFxuICB7XG4gICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgIGFyY0ludGVyc2VjdGlvbnMgPSBpbnRlcnNlY3RMaW5lQ2lyY2xlKHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSBib3R0b21MZWZ0Q2VudGVyWCAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbUxlZnRDZW50ZXJZKSB7XG4gICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW107IC8vIGlmIG5vdGhpbmdcbn07XG52YXIgaW5MaW5lVmljaW5pdHkgPSBmdW5jdGlvbiBpbkxpbmVWaWNpbml0eSh4LCB5LCBseDEsIGx5MSwgbHgyLCBseTIsIHRvbGVyYW5jZSkge1xuICB2YXIgdCA9IHRvbGVyYW5jZTtcbiAgdmFyIHgxID0gTWF0aC5taW4obHgxLCBseDIpO1xuICB2YXIgeDIgPSBNYXRoLm1heChseDEsIGx4Mik7XG4gIHZhciB5MSA9IE1hdGgubWluKGx5MSwgbHkyKTtcbiAgdmFyIHkyID0gTWF0aC5tYXgobHkxLCBseTIpO1xuICByZXR1cm4geDEgLSB0IDw9IHggJiYgeCA8PSB4MiArIHQgJiYgeTEgLSB0IDw9IHkgJiYgeSA8PSB5MiArIHQ7XG59O1xudmFyIGluQmV6aWVyVmljaW5pdHkgPSBmdW5jdGlvbiBpbkJlemllclZpY2luaXR5KHgsIHksIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSkge1xuICB2YXIgYmIgPSB7XG4gICAgeDE6IE1hdGgubWluKHgxLCB4MywgeDIpIC0gdG9sZXJhbmNlLFxuICAgIHgyOiBNYXRoLm1heCh4MSwgeDMsIHgyKSArIHRvbGVyYW5jZSxcbiAgICB5MTogTWF0aC5taW4oeTEsIHkzLCB5MikgLSB0b2xlcmFuY2UsXG4gICAgeTI6IE1hdGgubWF4KHkxLCB5MywgeTIpICsgdG9sZXJhbmNlXG4gIH07XG5cbiAgLy8gaWYgb3V0c2lkZSB0aGUgcm91Z2ggYm91bmRpbmcgYm94IGZvciB0aGUgYmV6aWVyLCB0aGVuIGl0IGNhbid0IGJlIGEgaGl0XG4gIGlmICh4IDwgYmIueDEgfHwgeCA+IGJiLngyIHx8IHkgPCBiYi55MSB8fCB5ID4gYmIueTIpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnYmV6aWVyIG91dCBvZiByb3VnaCBiYicpXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIGNvbnNvbGUubG9nKCdkbyBtb3JlIGV4cGVuc2l2ZSBjaGVjaycpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xudmFyIHNvbHZlUXVhZHJhdGljID0gZnVuY3Rpb24gc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgdmFsKSB7XG4gIGMgLT0gdmFsO1xuICB2YXIgciA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICBpZiAociA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIHNxcnRSID0gTWF0aC5zcXJ0KHIpO1xuICB2YXIgZGVub20gPSAyICogYTtcbiAgdmFyIHJvb3QxID0gKC1iICsgc3FydFIpIC8gZGVub207XG4gIHZhciByb290MiA9ICgtYiAtIHNxcnRSKSAvIGRlbm9tO1xuICByZXR1cm4gW3Jvb3QxLCByb290Ml07XG59O1xudmFyIHNvbHZlQ3ViaWMgPSBmdW5jdGlvbiBzb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJlc3VsdCkge1xuICAvLyBTb2x2ZXMgYSBjdWJpYyBmdW5jdGlvbiwgcmV0dXJucyByb290IGluIGZvcm0gW3IxLCBpMSwgcjIsIGkyLCByMywgaTNdLCB3aGVyZVxuICAvLyByIGlzIHRoZSByZWFsIGNvbXBvbmVudCwgaSBpcyB0aGUgaW1hZ2luYXJ5IGNvbXBvbmVudFxuXG4gIC8vIEFuIGltcGxlbWVudGF0aW9uIG9mIHRoZSBDYXJkYW5vIG1ldGhvZCBmcm9tIHRoZSB5ZWFyIDE1NDVcbiAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19mdW5jdGlvbiNUaGVfbmF0dXJlX29mX3RoZV9yb290c1xuXG4gIHZhciBlcHNpbG9uID0gMC4wMDAwMTtcblxuICAvLyBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvIHdoaWxlIGtlZXBpbmcgdGhlIG92ZXJhbGwgZXhwcmVzc2lvbiBjbG9zZSBpbiB2YWx1ZVxuICBpZiAoYSA9PT0gMCkge1xuICAgIGEgPSBlcHNpbG9uO1xuICB9XG4gIGIgLz0gYTtcbiAgYyAvPSBhO1xuICBkIC89IGE7XG4gIHZhciBkaXNjcmltaW5hbnQsIHEsIHIsIGR1bTEsIHMsIHQsIHRlcm0xLCByMTM7XG4gIHEgPSAoMy4wICogYyAtIGIgKiBiKSAvIDkuMDtcbiAgciA9IC0oMjcuMCAqIGQpICsgYiAqICg5LjAgKiBjIC0gMi4wICogKGIgKiBiKSk7XG4gIHIgLz0gNTQuMDtcbiAgZGlzY3JpbWluYW50ID0gcSAqIHEgKiBxICsgciAqIHI7XG4gIHJlc3VsdFsxXSA9IDA7XG4gIHRlcm0xID0gYiAvIDMuMDtcbiAgaWYgKGRpc2NyaW1pbmFudCA+IDApIHtcbiAgICBzID0gciArIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgIHMgPSBzIDwgMCA/IC1NYXRoLnBvdygtcywgMS4wIC8gMy4wKSA6IE1hdGgucG93KHMsIDEuMCAvIDMuMCk7XG4gICAgdCA9IHIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICB0ID0gdCA8IDAgPyAtTWF0aC5wb3coLXQsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyh0LCAxLjAgLyAzLjApO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgIHRlcm0xICs9IChzICsgdCkgLyAyLjA7XG4gICAgcmVzdWx0WzRdID0gcmVzdWx0WzJdID0gLXRlcm0xO1xuICAgIHRlcm0xID0gTWF0aC5zcXJ0KDMuMCkgKiAoLXQgKyBzKSAvIDI7XG4gICAgcmVzdWx0WzNdID0gdGVybTE7XG4gICAgcmVzdWx0WzVdID0gLXRlcm0xO1xuICAgIHJldHVybjtcbiAgfVxuICByZXN1bHRbNV0gPSByZXN1bHRbM10gPSAwO1xuICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XG4gICAgcjEzID0gciA8IDAgPyAtTWF0aC5wb3coLXIsIDEuMCAvIDMuMCkgOiBNYXRoLnBvdyhyLCAxLjAgLyAzLjApO1xuICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtKHIxMyArIHRlcm0xKTtcbiAgICByZXR1cm47XG4gIH1cbiAgcSA9IC1xO1xuICBkdW0xID0gcSAqIHEgKiBxO1xuICBkdW0xID0gTWF0aC5hY29zKHIgLyBNYXRoLnNxcnQoZHVtMSkpO1xuICByMTMgPSAyLjAgKiBNYXRoLnNxcnQocSk7XG4gIHJlc3VsdFswXSA9IC10ZXJtMSArIHIxMyAqIE1hdGguY29zKGR1bTEgLyAzLjApO1xuICByZXN1bHRbMl0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDIuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgcmVzdWx0WzRdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyA0LjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gIHJldHVybjtcbn07XG52YXIgc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbiBzcWRpc3RUb1F1YWRyYXRpY0Jlemllcih4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIC8vIEZpbmQgbWluaW11bSBkaXN0YW5jZSBieSB1c2luZyB0aGUgbWluaW11bSBvZiB0aGUgZGlzdGFuY2VcbiAgLy8gZnVuY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnQgYW5kIHRoZSBjdXJ2ZVxuXG4gIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcmVzdWx0aW5nIGN1YmljIGVxdWF0aW9uXG4gIC8vIHdob3NlIHJvb3RzIHRlbGwgdXMgd2hlcmUgYSBwb3NzaWJsZSBtaW5pbXVtIGlzXG4gIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcblxuICB2YXIgYSA9IDEuMCAqIHgxICogeDEgLSA0ICogeDEgKiB4MiArIDIgKiB4MSAqIHgzICsgNCAqIHgyICogeDIgLSA0ICogeDIgKiB4MyArIHgzICogeDMgKyB5MSAqIHkxIC0gNCAqIHkxICogeTIgKyAyICogeTEgKiB5MyArIDQgKiB5MiAqIHkyIC0gNCAqIHkyICogeTMgKyB5MyAqIHkzO1xuICB2YXIgYiA9IDEuMCAqIDkgKiB4MSAqIHgyIC0gMyAqIHgxICogeDEgLSAzICogeDEgKiB4MyAtIDYgKiB4MiAqIHgyICsgMyAqIHgyICogeDMgKyA5ICogeTEgKiB5MiAtIDMgKiB5MSAqIHkxIC0gMyAqIHkxICogeTMgLSA2ICogeTIgKiB5MiArIDMgKiB5MiAqIHkzO1xuICB2YXIgYyA9IDEuMCAqIDMgKiB4MSAqIHgxIC0gNiAqIHgxICogeDIgKyB4MSAqIHgzIC0geDEgKiB4ICsgMiAqIHgyICogeDIgKyAyICogeDIgKiB4IC0geDMgKiB4ICsgMyAqIHkxICogeTEgLSA2ICogeTEgKiB5MiArIHkxICogeTMgLSB5MSAqIHkgKyAyICogeTIgKiB5MiArIDIgKiB5MiAqIHkgLSB5MyAqIHk7XG4gIHZhciBkID0gMS4wICogeDEgKiB4MiAtIHgxICogeDEgKyB4MSAqIHggLSB4MiAqIHggKyB5MSAqIHkyIC0geTEgKiB5MSArIHkxICogeSAtIHkyICogeTtcblxuICAvLyBkZWJ1ZyhcImNvZWZmaWNpZW50czogXCIgKyBhIC8gYSArIFwiLCBcIiArIGIgLyBhICsgXCIsIFwiICsgYyAvIGEgKyBcIiwgXCIgKyBkIC8gYSk7XG5cbiAgdmFyIHJvb3RzID0gW107XG5cbiAgLy8gVXNlIHRoZSBjdWJpYyBzb2x2aW5nIGFsZ29yaXRobVxuICBzb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJvb3RzKTtcbiAgdmFyIHplcm9UaHJlc2hvbGQgPSAwLjAwMDAwMDE7XG4gIHZhciBwYXJhbXMgPSBbXTtcbiAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IDY7IGluZGV4ICs9IDIpIHtcbiAgICBpZiAoTWF0aC5hYnMocm9vdHNbaW5kZXggKyAxXSkgPCB6ZXJvVGhyZXNob2xkICYmIHJvb3RzW2luZGV4XSA+PSAwICYmIHJvb3RzW2luZGV4XSA8PSAxLjApIHtcbiAgICAgIHBhcmFtcy5wdXNoKHJvb3RzW2luZGV4XSk7XG4gICAgfVxuICB9XG4gIHBhcmFtcy5wdXNoKDEuMCk7XG4gIHBhcmFtcy5wdXNoKDAuMCk7XG4gIHZhciBtaW5EaXN0YW5jZVNxdWFyZWQgPSAtMTtcbiAgdmFyIGN1clgsIGN1clksIGRpc3RTcXVhcmVkO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIGN1clggPSBNYXRoLnBvdygxLjAgLSBwYXJhbXNbaV0sIDIuMCkgKiB4MSArIDIuMCAqICgxIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHgyICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeDM7XG4gICAgY3VyWSA9IE1hdGgucG93KDEgLSBwYXJhbXNbaV0sIDIuMCkgKiB5MSArIDIgKiAoMS4wIC0gcGFyYW1zW2ldKSAqIHBhcmFtc1tpXSAqIHkyICsgcGFyYW1zW2ldICogcGFyYW1zW2ldICogeTM7XG4gICAgZGlzdFNxdWFyZWQgPSBNYXRoLnBvdyhjdXJYIC0geCwgMikgKyBNYXRoLnBvdyhjdXJZIC0geSwgMik7XG4gICAgLy8gZGVidWcoJ2Rpc3RhbmNlIGZvciBwYXJhbSAnICsgcGFyYW1zW2ldICsgXCI6IFwiICsgTWF0aC5zcXJ0KGRpc3RTcXVhcmVkKSk7XG4gICAgaWYgKG1pbkRpc3RhbmNlU3F1YXJlZCA+PSAwKSB7XG4gICAgICBpZiAoZGlzdFNxdWFyZWQgPCBtaW5EaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluRGlzdGFuY2VTcXVhcmVkO1xufTtcbnZhciBzcWRpc3RUb0Zpbml0ZUxpbmUgPSBmdW5jdGlvbiBzcWRpc3RUb0Zpbml0ZUxpbmUoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIG9mZnNldCA9IFt4IC0geDEsIHkgLSB5MV07XG4gIHZhciBsaW5lID0gW3gyIC0geDEsIHkyIC0geTFdO1xuICB2YXIgbGluZVNxID0gbGluZVswXSAqIGxpbmVbMF0gKyBsaW5lWzFdICogbGluZVsxXTtcbiAgdmFyIGh5cFNxID0gb2Zmc2V0WzBdICogb2Zmc2V0WzBdICsgb2Zmc2V0WzFdICogb2Zmc2V0WzFdO1xuICB2YXIgZG90UHJvZHVjdCA9IG9mZnNldFswXSAqIGxpbmVbMF0gKyBvZmZzZXRbMV0gKiBsaW5lWzFdO1xuICB2YXIgYWRqU3EgPSBkb3RQcm9kdWN0ICogZG90UHJvZHVjdCAvIGxpbmVTcTtcbiAgaWYgKGRvdFByb2R1Y3QgPCAwKSB7XG4gICAgcmV0dXJuIGh5cFNxO1xuICB9XG4gIGlmIChhZGpTcSA+IGxpbmVTcSkge1xuICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgfVxuICByZXR1cm4gaHlwU3EgLSBhZGpTcTtcbn07XG52YXIgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzID0gZnVuY3Rpb24gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykge1xuICB2YXIgeDEsIHkxLCB4MiwgeTI7XG4gIHZhciB5MztcblxuICAvLyBJbnRlcnNlY3Qgd2l0aCB2ZXJ0aWNhbCBsaW5lIHRocm91Z2ggKHgsIHkpXG4gIHZhciB1cCA9IDA7XG4gIC8vIGxldCBkb3duID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgeDEgPSBwb2ludHNbaSAqIDJdO1xuICAgIHkxID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgaWYgKGkgKyAxIDwgcG9pbnRzLmxlbmd0aCAvIDIpIHtcbiAgICAgIHgyID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgIHkyID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHgyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDJdO1xuICAgICAgeTIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMiArIDFdO1xuICAgIH1cbiAgICBpZiAoeDEgPT0geCAmJiB4MiA9PSB4KSA7IGVsc2UgaWYgKHgxID49IHggJiYgeCA+PSB4MiB8fCB4MSA8PSB4ICYmIHggPD0geDIpIHtcbiAgICAgIHkzID0gKHggLSB4MSkgLyAoeDIgLSB4MSkgKiAoeTIgLSB5MSkgKyB5MTtcbiAgICAgIGlmICh5MyA+IHkpIHtcbiAgICAgICAgdXArKztcbiAgICAgIH1cblxuICAgICAgLy8gaWYoIHkzIDwgeSApe1xuICAgICAgLy8gZG93bisrO1xuICAgICAgLy8gfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHVwICUgMiA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbnZhciBwb2ludEluc2lkZVBvbHlnb24gPSBmdW5jdGlvbiBwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG5cbiAgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcbiAgdmFyIGFuZ2xlO1xuICBpZiAoZGlyZWN0aW9uWzBdICE9IG51bGwpIHtcbiAgICBhbmdsZSA9IE1hdGguYXRhbihkaXJlY3Rpb25bMV0gLyBkaXJlY3Rpb25bMF0pO1xuICAgIGlmIChkaXJlY3Rpb25bMF0gPCAwKSB7XG4gICAgICBhbmdsZSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gLWFuZ2xlIC0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFuZ2xlID0gZGlyZWN0aW9uO1xuICB9XG4gIHZhciBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICB2YXIgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcblxuICAvLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gd2lkdGggLyAyICogKGJhc2VQb2ludHNbaSAqIDJdICogY29zIC0gYmFzZVBvaW50c1tpICogMiArIDFdICogc2luKTtcbiAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gaGVpZ2h0IC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBjb3MgKyBiYXNlUG9pbnRzW2kgKiAyXSAqIHNpbik7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdICs9IGNlbnRlclg7XG4gICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSArPSBjZW50ZXJZO1xuICB9XG4gIHZhciBwb2ludHM7XG4gIGlmIChwYWRkaW5nID4gMCkge1xuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBleHBhbmRQb2x5Z29uKHRyYW5zZm9ybWVkUG9pbnRzLCAtcGFkZGluZyk7XG4gICAgcG9pbnRzID0gam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gIH1cbiAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBwb2ludHMpO1xufTtcbnZhciBwb2ludEluc2lkZVJvdW5kUG9seWdvbiA9IGZ1bmN0aW9uIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lcnMpIHtcbiAgdmFyIGN1dFBvbHlnb25Qb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGggKiAyKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3JuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvcm5lciA9IGNvcm5lcnNbaV07XG4gICAgY3V0UG9seWdvblBvaW50c1tpICogNCArIDBdID0gY29ybmVyLnN0YXJ0WDtcbiAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgMV0gPSBjb3JuZXIuc3RhcnRZO1xuICAgIGN1dFBvbHlnb25Qb2ludHNbaSAqIDQgKyAyXSA9IGNvcm5lci5zdG9wWDtcbiAgICBjdXRQb2x5Z29uUG9pbnRzW2kgKiA0ICsgM10gPSBjb3JuZXIuc3RvcFk7XG4gICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGNvcm5lci5jeCAtIHgsIDIpICsgTWF0aC5wb3coY29ybmVyLmN5IC0geSwgMik7XG4gICAgaWYgKHNxdWFyZWREaXN0YW5jZSA8PSBNYXRoLnBvdyhjb3JuZXIucmFkaXVzLCAyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0UG9seWdvblBvaW50cyk7XG59O1xudmFyIGpvaW5MaW5lcyA9IGZ1bmN0aW9uIGpvaW5MaW5lcyhsaW5lU2V0KSB7XG4gIHZhciB2ZXJ0aWNlcyA9IG5ldyBBcnJheShsaW5lU2V0Lmxlbmd0aCAvIDIpO1xuICB2YXIgY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLCBjdXJyZW50TGluZUVuZFgsIGN1cnJlbnRMaW5lRW5kWTtcbiAgdmFyIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVNldC5sZW5ndGggLyA0OyBpKyspIHtcbiAgICBjdXJyZW50TGluZVN0YXJ0WCA9IGxpbmVTZXRbaSAqIDRdO1xuICAgIGN1cnJlbnRMaW5lU3RhcnRZID0gbGluZVNldFtpICogNCArIDFdO1xuICAgIGN1cnJlbnRMaW5lRW5kWCA9IGxpbmVTZXRbaSAqIDQgKyAyXTtcbiAgICBjdXJyZW50TGluZUVuZFkgPSBsaW5lU2V0W2kgKiA0ICsgM107XG4gICAgaWYgKGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxKSB7XG4gICAgICBuZXh0TGluZVN0YXJ0WCA9IGxpbmVTZXRbKGkgKyAxKSAqIDRdO1xuICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMV07XG4gICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgM107XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFswXTtcbiAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsxXTtcbiAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WzNdO1xuICAgIH1cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gZmluaXRlTGluZXNJbnRlcnNlY3QoY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLCBjdXJyZW50TGluZUVuZFgsIGN1cnJlbnRMaW5lRW5kWSwgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLCBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWSwgdHJ1ZSk7XG4gICAgdmVydGljZXNbaSAqIDJdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgIHZlcnRpY2VzW2kgKiAyICsgMV0gPSBpbnRlcnNlY3Rpb25bMV07XG4gIH1cbiAgcmV0dXJuIHZlcnRpY2VzO1xufTtcbnZhciBleHBhbmRQb2x5Z29uID0gZnVuY3Rpb24gZXhwYW5kUG9seWdvbihwb2ludHMsIHBhZCkge1xuICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gbmV3IEFycmF5KHBvaW50cy5sZW5ndGggKiAyKTtcbiAgdmFyIGN1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFksIG5leHRQb2ludFgsIG5leHRQb2ludFk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIGN1cnJlbnRQb2ludFggPSBwb2ludHNbaSAqIDJdO1xuICAgIGN1cnJlbnRQb2ludFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRQb2ludFggPSBwb2ludHNbMF07XG4gICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWzFdO1xuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuXG4gICAgLy8gQXNzdW1lIENDVyBwb2x5Z29uIHdpbmRpbmdcblxuICAgIHZhciBvZmZzZXRYID0gbmV4dFBvaW50WSAtIGN1cnJlbnRQb2ludFk7XG4gICAgdmFyIG9mZnNldFkgPSAtKG5leHRQb2ludFggLSBjdXJyZW50UG9pbnRYKTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBvZmZzZXRMZW5ndGggPSBNYXRoLnNxcnQob2Zmc2V0WCAqIG9mZnNldFggKyBvZmZzZXRZICogb2Zmc2V0WSk7XG4gICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRYID0gb2Zmc2V0WCAvIG9mZnNldExlbmd0aDtcbiAgICB2YXIgbm9ybWFsaXplZE9mZnNldFkgPSBvZmZzZXRZIC8gb2Zmc2V0TGVuZ3RoO1xuICAgIGV4cGFuZGVkTGluZVNldFtpICogNF0gPSBjdXJyZW50UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgMV0gPSBjdXJyZW50UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgMl0gPSBuZXh0UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgM10gPSBuZXh0UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gIH1cbiAgcmV0dXJuIGV4cGFuZGVkTGluZVNldDtcbn07XG52YXIgaW50ZXJzZWN0TGluZUVsbGlwc2UgPSBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lRWxsaXBzZSh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBlbGxpcHNlV3JhZGl1cywgZWxsaXBzZUhyYWRpdXMpIHtcbiAgdmFyIGRpc3BYID0gY2VudGVyWCAtIHg7XG4gIHZhciBkaXNwWSA9IGNlbnRlclkgLSB5O1xuICBkaXNwWCAvPSBlbGxpcHNlV3JhZGl1cztcbiAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkpO1xuICB2YXIgbmV3TGVuZ3RoID0gbGVuIC0gMTtcbiAgaWYgKG5ld0xlbmd0aCA8IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGxlblByb3BvcnRpb24gPSBuZXdMZW5ndGggLyBsZW47XG4gIHJldHVybiBbKGNlbnRlclggLSB4KSAqIGxlblByb3BvcnRpb24gKyB4LCAoY2VudGVyWSAtIHkpICogbGVuUHJvcG9ydGlvbiArIHldO1xufTtcbnZhciBjaGVja0luRWxsaXBzZSA9IGZ1bmN0aW9uIGNoZWNrSW5FbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgeCAtPSBjZW50ZXJYO1xuICB5IC09IGNlbnRlclk7XG4gIHggLz0gd2lkdGggLyAyICsgcGFkZGluZztcbiAgeSAvPSBoZWlnaHQgLyAyICsgcGFkZGluZztcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgPD0gMTtcbn07XG5cbi8vIFJldHVybnMgaW50ZXJzZWN0aW9ucyBvZiBpbmNyZWFzaW5nIGRpc3RhbmNlIGZyb20gbGluZSdzIHN0YXJ0IHBvaW50XG52YXIgaW50ZXJzZWN0TGluZUNpcmNsZSA9IGZ1bmN0aW9uIGludGVyc2VjdExpbmVDaXJjbGUoeDEsIHkxLCB4MiwgeTIsIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cykge1xuICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gIHZhciBkID0gW3gyIC0geDEsIHkyIC0geTFdOyAvLyBEaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcbiAgdmFyIGYgPSBbeDEgLSBjZW50ZXJYLCB5MSAtIGNlbnRlclldO1xuICB2YXIgYSA9IGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV07XG4gIHZhciBiID0gMiAqIChmWzBdICogZFswXSArIGZbMV0gKiBkWzFdKTtcbiAgdmFyIGMgPSBmWzBdICogZlswXSArIGZbMV0gKiBmWzFdIC0gcmFkaXVzICogcmFkaXVzO1xuICB2YXIgZGlzY3JpbWluYW50ID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gIGlmIChkaXNjcmltaW5hbnQgPCAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gIHZhciB0TWluID0gTWF0aC5taW4odDEsIHQyKTtcbiAgdmFyIHRNYXggPSBNYXRoLm1heCh0MSwgdDIpO1xuICB2YXIgaW5SYW5nZVBhcmFtcyA9IFtdO1xuICBpZiAodE1pbiA+PSAwICYmIHRNaW4gPD0gMSkge1xuICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWluKTtcbiAgfVxuICBpZiAodE1heCA+PSAwICYmIHRNYXggPD0gMSkge1xuICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWF4KTtcbiAgfVxuICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMF0gKyB4MTtcbiAgdmFyIG5lYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMV0gKyB5MTtcbiAgaWYgKGluUmFuZ2VQYXJhbXMubGVuZ3RoID4gMSkge1xuICAgIGlmIChpblJhbmdlUGFyYW1zWzBdID09IGluUmFuZ2VQYXJhbXNbMV0pIHtcbiAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZhckludGVyc2VjdGlvblggPSBpblJhbmdlUGFyYW1zWzFdICogZFswXSArIHgxO1xuICAgICAgdmFyIGZhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzFdICogZFsxXSArIHkxO1xuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblksIGZhckludGVyc2VjdGlvblgsIGZhckludGVyc2VjdGlvblldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gIH1cbn07XG52YXIgbWlkT2ZUaHJlZSA9IGZ1bmN0aW9uIG1pZE9mVGhyZWUoYSwgYiwgYykge1xuICBpZiAoYiA8PSBhICYmIGEgPD0gYyB8fCBjIDw9IGEgJiYgYSA8PSBiKSB7XG4gICAgcmV0dXJuIGE7XG4gIH0gZWxzZSBpZiAoYSA8PSBiICYmIGIgPD0gYyB8fCBjIDw9IGIgJiYgYiA8PSBhKSB7XG4gICAgcmV0dXJuIGI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGM7XG4gIH1cbn07XG5cbi8vICh4MSx5MSk9Pih4Mix5MikgaW50ZXJzZWN0IHdpdGggKHgzLHkzKT0+KHg0LHk0KVxudmFyIGZpbml0ZUxpbmVzSW50ZXJzZWN0ID0gZnVuY3Rpb24gZmluaXRlTGluZXNJbnRlcnNlY3QoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBpbmZpbml0ZUxpbmVzKSB7XG4gIHZhciBkeDEzID0geDEgLSB4MztcbiAgdmFyIGR4MjEgPSB4MiAtIHgxO1xuICB2YXIgZHg0MyA9IHg0IC0geDM7XG4gIHZhciBkeTEzID0geTEgLSB5MztcbiAgdmFyIGR5MjEgPSB5MiAtIHkxO1xuICB2YXIgZHk0MyA9IHk0IC0geTM7XG4gIHZhciB1YV90ID0gZHg0MyAqIGR5MTMgLSBkeTQzICogZHgxMztcbiAgdmFyIHViX3QgPSBkeDIxICogZHkxMyAtIGR5MjEgKiBkeDEzO1xuICB2YXIgdV9iID0gZHk0MyAqIGR4MjEgLSBkeDQzICogZHkyMTtcbiAgaWYgKHVfYiAhPT0gMCkge1xuICAgIHZhciB1YSA9IHVhX3QgLyB1X2I7XG4gICAgdmFyIHViID0gdWJfdCAvIHVfYjtcbiAgICB2YXIgZmxwdFRocmVzaG9sZCA9IDAuMDAxO1xuICAgIHZhciBfbWluID0gMCAtIGZscHRUaHJlc2hvbGQ7XG4gICAgdmFyIF9tYXggPSAxICsgZmxwdFRocmVzaG9sZDtcbiAgICBpZiAoX21pbiA8PSB1YSAmJiB1YSA8PSBfbWF4ICYmIF9taW4gPD0gdWIgJiYgdWIgPD0gX21heCkge1xuICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWluZmluaXRlTGluZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFt4MSArIHVhICogZHgyMSwgeTEgKyB1YSAqIGR5MjFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodWFfdCA9PT0gMCB8fCB1Yl90ID09PSAwKSB7XG4gICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuXG4gICAgICAvLyBDaGVjayBlbmRwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgaWYgKG1pZE9mVGhyZWUoeDEsIHgyLCB4NCkgPT09IHg0KSB7XG4gICAgICAgIHJldHVybiBbeDQsIHk0XTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgIGlmIChtaWRPZlRocmVlKHgxLCB4MiwgeDMpID09PSB4Mykge1xuICAgICAgICByZXR1cm4gW3gzLCB5M107XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZHBvaW50IG9mIGZpcnN0IGxpbmVcbiAgICAgIGlmIChtaWRPZlRocmVlKHgzLCB4NCwgeDIpID09PSB4Mikge1xuICAgICAgICByZXR1cm4gW3gyLCB5Ml07XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBhcmFsbGVsLCBub24tY29pbmNpZGVudFxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufTtcbnZhciB0cmFuc2Zvcm1Qb2ludHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciByZXQgPSBbXTtcbiAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkggPSBoZWlnaHQgLyAyO1xuICB2YXIgeCA9IGNlbnRlclg7XG4gIHZhciB5ID0gY2VudGVyWTtcbiAgcmV0LnB1c2goe1xuICAgIHg6IHggKyBoYWxmVyAqIHBvaW50c1swXSxcbiAgICB5OiB5ICsgaGFsZkggKiBwb2ludHNbMV1cbiAgfSk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIHJldC5wdXNoKHtcbiAgICAgIHg6IHggKyBoYWxmVyAqIHBvaW50c1tpICogMl0sXG4gICAgICB5OiB5ICsgaGFsZkggKiBwb2ludHNbaSAqIDIgKyAxXVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG4vLyBtYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKCB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nIClcbi8vIGludGVyc2VjdCBhIG5vZGUgcG9seWdvbiAocHRzIHRyYW5zZm9ybWVkKVxuLy9cbi8vIG1hdGgucG9seWdvbkludGVyc2VjdExpbmUoIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclkgKVxuLy8gaW50ZXJzZWN0IHRoZSBwb2ludHMgKG5vIHRyYW5zZm9ybSlcbnZhciBwb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbjtcbiAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgdmFyIGRvVHJhbnNmb3JtID0gdHJ1ZTtcbiAgaWYgKHdpZHRoID09IG51bGwpIHtcbiAgICBkb1RyYW5zZm9ybSA9IGZhbHNlO1xuICB9XG4gIHZhciBwb2ludHM7XG4gIGlmIChkb1RyYW5zZm9ybSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSBiYXNlUG9pbnRzW2kgKiAyXSAqIHdpZHRoICsgY2VudGVyWDtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBoZWlnaHQgKyBjZW50ZXJZO1xuICAgIH1cbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBleHBhbmRQb2x5Z29uKHRyYW5zZm9ybWVkUG9pbnRzLCAtcGFkZGluZyk7XG4gICAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IGJhc2VQb2ludHM7XG4gIH1cbiAgdmFyIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZO1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBwb2ludHMubGVuZ3RoIC8gMjsgX2kzKyspIHtcbiAgICBjdXJyZW50WCA9IHBvaW50c1tfaTMgKiAyXTtcbiAgICBjdXJyZW50WSA9IHBvaW50c1tfaTMgKiAyICsgMV07XG4gICAgaWYgKF9pMyA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgbmV4dFggPSBwb2ludHNbKF9pMyArIDEpICogMl07XG4gICAgICBuZXh0WSA9IHBvaW50c1soX2kzICsgMSkgKiAyICsgMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgfVxuICAgIGludGVyc2VjdGlvbiA9IGZpbml0ZUxpbmVzSW50ZXJzZWN0KHgsIHksIGNlbnRlclgsIGNlbnRlclksIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZKTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG59O1xudmFyIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbiByb3VuZFBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcsIGNvcm5lcnMpIHtcbiAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgdmFyIGludGVyc2VjdGlvbjtcbiAgdmFyIGxpbmVzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoICogMik7XG4gIGNvcm5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY29ybmVyLCBpKSB7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDJdID0gY29ybmVyLnN0YXJ0WDtcbiAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID0gY29ybmVyLnN0YXJ0WTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZXNbaSAqIDQgLSAyXSA9IGNvcm5lci5zdGFydFg7XG4gICAgICBsaW5lc1tpICogNCAtIDFdID0gY29ybmVyLnN0YXJ0WTtcbiAgICB9XG4gICAgbGluZXNbaSAqIDRdID0gY29ybmVyLnN0b3BYO1xuICAgIGxpbmVzW2kgKiA0ICsgMV0gPSBjb3JuZXIuc3RvcFk7XG4gICAgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0TGluZUNpcmNsZSh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXIuY3gsIGNvcm5lci5jeSwgY29ybmVyLnJhZGl1cyk7XG4gICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGggLyA0OyBpKyspIHtcbiAgICBpbnRlcnNlY3Rpb24gPSBmaW5pdGVMaW5lc0ludGVyc2VjdCh4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCBsaW5lc1tpICogNF0sIGxpbmVzW2kgKiA0ICsgMV0sIGxpbmVzW2kgKiA0ICsgMl0sIGxpbmVzW2kgKiA0ICsgM10sIGZhbHNlKTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uLmxlbmd0aCAhPT0gMCkge1xuICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICB9XG4gIH1cbiAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoID4gMikge1xuICAgIHZhciBsb3dlc3RJbnRlcnNlY3Rpb24gPSBbaW50ZXJzZWN0aW9uc1swXSwgaW50ZXJzZWN0aW9uc1sxXV07XG4gICAgdmFyIGxvd2VzdFNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGxvd2VzdEludGVyc2VjdGlvblswXSAtIHgsIDIpICsgTWF0aC5wb3cobG93ZXN0SW50ZXJzZWN0aW9uWzFdIC0geSwgMik7XG4gICAgZm9yICh2YXIgX2k0ID0gMTsgX2k0IDwgaW50ZXJzZWN0aW9ucy5sZW5ndGggLyAyOyBfaTQrKykge1xuICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IE1hdGgucG93KGludGVyc2VjdGlvbnNbX2k0ICogMl0gLSB4LCAyKSArIE1hdGgucG93KGludGVyc2VjdGlvbnNbX2k0ICogMiArIDFdIC0geSwgMik7XG4gICAgICBpZiAoc3F1YXJlZERpc3RhbmNlIDw9IGxvd2VzdFNxdWFyZWREaXN0YW5jZSkge1xuICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMF0gPSBpbnRlcnNlY3Rpb25zW19pNCAqIDJdO1xuICAgICAgICBsb3dlc3RJbnRlcnNlY3Rpb25bMV0gPSBpbnRlcnNlY3Rpb25zW19pNCAqIDIgKyAxXTtcbiAgICAgICAgbG93ZXN0U3F1YXJlZERpc3RhbmNlID0gc3F1YXJlZERpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG93ZXN0SW50ZXJzZWN0aW9uO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufTtcbnZhciBzaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50KSB7XG4gIHZhciBkaXNwID0gW2ludGVyc2VjdGlvblswXSAtIG9mZnNldFswXSwgaW50ZXJzZWN0aW9uWzFdIC0gb2Zmc2V0WzFdXTtcbiAgdmFyIGxlbmd0aCA9IE1hdGguc3FydChkaXNwWzBdICogZGlzcFswXSArIGRpc3BbMV0gKiBkaXNwWzFdKTtcbiAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG4gIGlmIChsZW5SYXRpbyA8IDApIHtcbiAgICBsZW5SYXRpbyA9IDAuMDAwMDE7XG4gIH1cbiAgcmV0dXJuIFtvZmZzZXRbMF0gKyBsZW5SYXRpbyAqIGRpc3BbMF0sIG9mZnNldFsxXSArIGxlblJhdGlvICogZGlzcFsxXV07XG59O1xudmFyIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSA9IGZ1bmN0aW9uIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZShzaWRlcywgcm90YXRpb25SYWRpYW5zKSB7XG4gIHZhciBwb2ludHMgPSBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpO1xuICBwb2ludHMgPSBmaXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKTtcbiAgcmV0dXJuIHBvaW50cztcbn07XG52YXIgZml0UG9seWdvblRvU3F1YXJlID0gZnVuY3Rpb24gZml0UG9seWdvblRvU3F1YXJlKHBvaW50cykge1xuICB2YXIgeCwgeTtcbiAgdmFyIHNpZGVzID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gIHZhciBtaW5YID0gSW5maW5pdHksXG4gICAgbWluWSA9IEluZmluaXR5LFxuICAgIG1heFggPSAtSW5maW5pdHksXG4gICAgbWF4WSA9IC1JbmZpbml0eTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgeCA9IHBvaW50c1syICogaV07XG4gICAgeSA9IHBvaW50c1syICogaSArIDFdO1xuICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgbWluWSA9IE1hdGgubWluKG1pblksIHkpO1xuICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgfVxuXG4gIC8vIHN0cmV0Y2ggZmFjdG9yc1xuICB2YXIgc3ggPSAyIC8gKG1heFggLSBtaW5YKTtcbiAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG4gIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHNpZGVzOyBfaTUrKykge1xuICAgIHggPSBwb2ludHNbMiAqIF9pNV0gPSBwb2ludHNbMiAqIF9pNV0gKiBzeDtcbiAgICB5ID0gcG9pbnRzWzIgKiBfaTUgKyAxXSA9IHBvaW50c1syICogX2k1ICsgMV0gKiBzeTtcbiAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCk7XG4gICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSk7XG4gIH1cbiAgaWYgKG1pblkgPCAtMSkge1xuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IHNpZGVzOyBfaTYrKykge1xuICAgICAgeSA9IHBvaW50c1syICogX2k2ICsgMV0gPSBwb2ludHNbMiAqIF9pNiArIDFdICsgKC0xIC0gbWluWSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb2ludHM7XG59O1xudmFyIGdlbmVyYXRlVW5pdE5nb25Qb2ludHMgPSBmdW5jdGlvbiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgdmFyIGluY3JlbWVudCA9IDEuMCAvIHNpZGVzICogMiAqIE1hdGguUEk7XG4gIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID8gTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG4gIHN0YXJ0QW5nbGUgKz0gcm90YXRpb25SYWRpYW5zO1xuICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHNpZGVzICogMik7XG4gIHZhciBjdXJyZW50QW5nbGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgIGN1cnJlbnRBbmdsZSA9IGkgKiBpbmNyZW1lbnQgKyBzdGFydEFuZ2xlO1xuICAgIHBvaW50c1syICogaV0gPSBNYXRoLmNvcyhjdXJyZW50QW5nbGUpOyAvLyB4XG4gICAgcG9pbnRzWzIgKiBpICsgMV0gPSBNYXRoLnNpbigtY3VycmVudEFuZ2xlKTsgLy8geVxuICB9XG4gIHJldHVybiBwb2ludHM7XG59O1xuXG4vLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzLCB1bmxlc3MgaGFsZiBvZiB3aWR0aCBvciBoZWlnaHQgaXMgc21hbGxlciB0aGFuIGRlZmF1bHRcbnZhciBnZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyA9IGZ1bmN0aW9uIGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIE1hdGgubWluKHdpZHRoIC8gNCwgaGVpZ2h0IC8gNCwgOCk7XG59O1xuXG4vLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzXG52YXIgZ2V0Um91bmRQb2x5Z29uUmFkaXVzID0gZnVuY3Rpb24gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIE1hdGgubWluKHdpZHRoIC8gMTAsIGhlaWdodCAvIDEwLCA4KTtcbn07XG52YXIgZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoID0gZnVuY3Rpb24gZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCkge1xuICByZXR1cm4gODtcbn07XG52YXIgYmV6aWVyUHRzVG9RdWFkQ29lZmYgPSBmdW5jdGlvbiBiZXppZXJQdHNUb1F1YWRDb2VmZihwMCwgcDEsIHAyKSB7XG4gIHJldHVybiBbcDAgLSAyICogcDEgKyBwMiwgMiAqIChwMSAtIHAwKSwgcDBdO1xufTtcblxuLy8gZ2V0IGN1cnZlIHdpZHRoLCBoZWlnaHQsIGFuZCBjb250cm9sIHBvaW50IHBvc2l0aW9uIG9mZnNldHMgYXMgYSBwZXJjZW50YWdlIG9mIG5vZGUgaGVpZ2h0IC8gd2lkdGhcbnZhciBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyA9IGZ1bmN0aW9uIGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICBoZWlnaHRPZmZzZXQ6IE1hdGgubWluKDE1LCAwLjA1ICogaGVpZ2h0KSxcbiAgICB3aWR0aE9mZnNldDogTWF0aC5taW4oMTAwLCAwLjI1ICogd2lkdGgpLFxuICAgIGN0cmxQdE9mZnNldFBjdDogMC4wNVxuICB9O1xufTtcblxuLy8gU2VwYXJhdGluZyBBeGlzIFRoZW9yZW0gKFNBVCkgdG8gZGV0ZXJtaW5lIGlmIHR3byBwb2x5Z29ucyBpbnRlcnNlY3QuIFxuLy8gVGhlIGZ1bmN0aW9uIHRha2VzIHR3byBwb2x5Z29ucyBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBcbi8vIHdoZXRoZXIgdGhlIHR3byBwb2x5Z29ucyBpbnRlcnNlY3QuXG5mdW5jdGlvbiBzYXRQb2x5Z29uSW50ZXJzZWN0aW9uKHBvbHkxLCBwb2x5Mikge1xuICBmdW5jdGlvbiBnZXRBeGVzKHBvbHlnb24pIHtcbiAgICB2YXIgYXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAxID0gcG9seWdvbltpXTtcbiAgICAgIHZhciBwMiA9IHBvbHlnb25bKGkgKyAxKSAlIHBvbHlnb24ubGVuZ3RoXTtcbiAgICAgIHZhciBlZGdlID0ge1xuICAgICAgICB4OiBwMi54IC0gcDEueCxcbiAgICAgICAgeTogcDIueSAtIHAxLnlcbiAgICAgIH07XG4gICAgICB2YXIgbm9ybWFsID0ge1xuICAgICAgICB4OiAtZWRnZS55LFxuICAgICAgICB5OiBlZGdlLnhcbiAgICAgIH07XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KG5vcm1hbC54ICogbm9ybWFsLnggKyBub3JtYWwueSAqIG5vcm1hbC55KTtcbiAgICAgIGF4ZXMucHVzaCh7XG4gICAgICAgIHg6IG5vcm1hbC54IC8gbGVuZ3RoLFxuICAgICAgICB5OiBub3JtYWwueSAvIGxlbmd0aFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBheGVzO1xuICB9XG4gIGZ1bmN0aW9uIHByb2plY3QocG9seWdvbiwgYXhpcykge1xuICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwb2x5Z29uKSxcbiAgICAgIF9zdGVwO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgcG9pbnQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSBwb2ludC54ICogYXhpcy54ICsgcG9pbnQueSAqIGF4aXMueTtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBwcm9qZWN0aW9uKTtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBwcm9qZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBvdmVybGFwcyhwcm9qMSwgcHJvajIpIHtcbiAgICByZXR1cm4gIShwcm9qMS5tYXggPCBwcm9qMi5taW4gfHwgcHJvajIubWF4IDwgcHJvajEubWluKTtcbiAgfVxuICB2YXIgYXhlcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoZ2V0QXhlcyhwb2x5MSkpLCBfdG9Db25zdW1hYmxlQXJyYXkoZ2V0QXhlcyhwb2x5MikpKTtcbiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihheGVzKSxcbiAgICBfc3RlcDI7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBheGlzID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgdmFyIHByb2oxID0gcHJvamVjdChwb2x5MSwgYXhpcyk7XG4gICAgICB2YXIgcHJvajIgPSBwcm9qZWN0KHBvbHkyLCBheGlzKTtcbiAgICAgIGlmICghb3ZlcmxhcHMocHJvajEsIHByb2oyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG92ZXJsYXAsIHNvIHRoZSBwb2x5Z29ucyBkbyBub3QgaW50ZXJzZWN0XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTsgLy8gcG9seWdvbnMgaW50ZXJzZWN0XG59XG5cbnZhciBwYWdlUmFua0RlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIGRhbXBpbmdGYWN0b3I6IDAuOCxcbiAgcHJlY2lzaW9uOiAwLjAwMDAwMSxcbiAgaXRlcmF0aW9uczogMjAwLFxuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn0pO1xudmFyIGVsZXNmbiRvID0ge1xuICBwYWdlUmFuazogZnVuY3Rpb24gcGFnZVJhbmsob3B0aW9ucykge1xuICAgIHZhciBfcGFnZVJhbmtEZWZhdWx0cyA9IHBhZ2VSYW5rRGVmYXVsdHMob3B0aW9ucyksXG4gICAgICBkYW1waW5nRmFjdG9yID0gX3BhZ2VSYW5rRGVmYXVsdHMuZGFtcGluZ0ZhY3RvcixcbiAgICAgIHByZWNpc2lvbiA9IF9wYWdlUmFua0RlZmF1bHRzLnByZWNpc2lvbixcbiAgICAgIGl0ZXJhdGlvbnMgPSBfcGFnZVJhbmtEZWZhdWx0cy5pdGVyYXRpb25zLFxuICAgICAgd2VpZ2h0ID0gX3BhZ2VSYW5rRGVmYXVsdHMud2VpZ2h0O1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIF90aGlzJGJ5R3JvdXAgPSB0aGlzLmJ5R3JvdXAoKSxcbiAgICAgIG5vZGVzID0gX3RoaXMkYnlHcm91cC5ub2RlcyxcbiAgICAgIGVkZ2VzID0gX3RoaXMkYnlHcm91cC5lZGdlcztcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgdmFyIG51bU5vZGVzU3FkID0gbnVtTm9kZXMgKiBudW1Ob2RlcztcbiAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAvLyBDb25zdHJ1Y3QgdHJhbnNwb3NlZCBhZGphY2VuY3kgbWF0cml4XG4gICAgLy8gRmlyc3QgbGV0cyBoYXZlIGEgemVyb2VkIG1hdHJpeCBvZiB0aGUgcmlnaHQgc2l6ZVxuICAgIC8vIFdlJ2xsIGFsc28ga2VlcCB0cmFjayBvZiB0aGUgc3VtIG9mIGVhY2ggY29sdW1uXG4gICAgdmFyIG1hdHJpeCA9IG5ldyBBcnJheShudW1Ob2Rlc1NxZCk7XG4gICAgdmFyIGNvbHVtblN1bSA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIGFkZGl0aW9uYWxQcm9iID0gKDEgLSBkYW1waW5nRmFjdG9yKSAvIG51bU5vZGVzO1xuXG4gICAgLy8gQ3JlYXRlIG51bGwgbWF0cml4XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgdmFyIG4gPSBpICogbnVtTm9kZXMgKyBqO1xuICAgICAgICBtYXRyaXhbbl0gPSAwO1xuICAgICAgfVxuICAgICAgY29sdW1uU3VtW2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyBOb3csIHByb2Nlc3MgZWRnZXNcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbnVtRWRnZXM7IF9pKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbX2ldO1xuICAgICAgdmFyIHNyY0lkID0gZWRnZS5kYXRhKCdzb3VyY2UnKTtcbiAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuZGF0YSgndGFyZ2V0Jyk7XG5cbiAgICAgIC8vIERvbid0IGluY2x1ZGUgbG9vcHMgaW4gdGhlIG1hdHJpeFxuICAgICAgaWYgKHNyY0lkID09PSB0Z3RJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzID0gbm9kZXMuaW5kZXhPZklkKHNyY0lkKTtcbiAgICAgIHZhciB0ID0gbm9kZXMuaW5kZXhPZklkKHRndElkKTtcbiAgICAgIHZhciB3ID0gd2VpZ2h0KGVkZ2UpO1xuICAgICAgdmFyIF9uID0gdCAqIG51bU5vZGVzICsgcztcblxuICAgICAgLy8gVXBkYXRlIG1hdHJpeFxuICAgICAgbWF0cml4W19uXSArPSB3O1xuXG4gICAgICAvLyBVcGRhdGUgY29sdW1uIHN1bVxuICAgICAgY29sdW1uU3VtW3NdICs9IHc7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgcHJvYmFiaWxpdHkgYmFzZWQgb24gZGFtcGluZyBmYWN0b3JcbiAgICAvLyBBbHNvLCB0YWtlIGludG8gYWNjb3VudCBjb2x1bW5zIHRoYXQgaGF2ZSBzdW0gPSAwXG4gICAgdmFyIHAgPSAxLjAgLyBudW1Ob2RlcyArIGFkZGl0aW9uYWxQcm9iOyAvLyBTaG9ydGhhbmRcblxuICAgIC8vIFRyYXZlcnNlIG1hdHJpeCwgY29sdW1uIGJ5IGNvbHVtblxuICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBudW1Ob2RlczsgX2orKykge1xuICAgICAgaWYgKGNvbHVtblN1bVtfal0gPT09IDApIHtcbiAgICAgICAgLy8gTm8gJ2xpbmtzJyBvdXQgZnJvbSBub2RlIGp0aCwgYXNzdW1lIGVxdWFsIHByb2JhYmlsaXR5IGZvciBlYWNoIHBvc3NpYmxlIG5vZGVcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbnVtTm9kZXM7IF9pMisrKSB7XG4gICAgICAgICAgdmFyIF9uMiA9IF9pMiAqIG51bU5vZGVzICsgX2o7XG4gICAgICAgICAgbWF0cml4W19uMl0gPSBwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlIGp0aCBoYXMgb3V0Z29pbmcgbGluaywgY29tcHV0ZSBub3JtYWxpemVkIHByb2JhYmlsaXRpZXNcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbnVtTm9kZXM7IF9pMysrKSB7XG4gICAgICAgICAgdmFyIF9uMyA9IF9pMyAqIG51bU5vZGVzICsgX2o7XG4gICAgICAgICAgbWF0cml4W19uM10gPSBtYXRyaXhbX24zXSAvIGNvbHVtblN1bVtfal0gKyBhZGRpdGlvbmFsUHJvYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgZG9taW5hbnQgZWlnZW52ZWN0b3IgdXNpbmcgcG93ZXIgbWV0aG9kXG4gICAgdmFyIGVpZ2VudmVjdG9yID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICB2YXIgdGVtcCA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgdmFyIHByZXZpb3VzO1xuXG4gICAgLy8gU3RhcnQgd2l0aCBhIHZlY3RvciBvZiBhbGwgMSdzXG4gICAgLy8gQWxzbywgaW5pdGlhbGl6ZSBhIG51bGwgdmVjdG9yIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBzaG9ydGhhbmRcbiAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1Ob2RlczsgX2k0KyspIHtcbiAgICAgIGVpZ2VudmVjdG9yW19pNF0gPSAxO1xuICAgIH1cbiAgICBmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8IGl0ZXJhdGlvbnM7IGl0ZXIrKykge1xuICAgICAgLy8gVGVtcCBhcnJheSB3aXRoIGFsbCAwJ3NcbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IG51bU5vZGVzOyBfaTUrKykge1xuICAgICAgICB0ZW1wW19pNV0gPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBNdWx0aXBseSBtYXRyaXggd2l0aCBwcmV2aW91cyByZXN1bHRcbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG51bU5vZGVzOyBfaTYrKykge1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBudW1Ob2RlczsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX240ID0gX2k2ICogbnVtTm9kZXMgKyBfajI7XG4gICAgICAgICAgdGVtcFtfaTZdICs9IG1hdHJpeFtfbjRdICogZWlnZW52ZWN0b3JbX2oyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5QbGFjZVN1bU5vcm1hbGl6ZSh0ZW1wKTtcbiAgICAgIHByZXZpb3VzID0gZWlnZW52ZWN0b3I7XG4gICAgICBlaWdlbnZlY3RvciA9IHRlbXA7XG4gICAgICB0ZW1wID0gcHJldmlvdXM7XG4gICAgICB2YXIgZGlmZiA9IDA7XG4gICAgICAvLyBDb21wdXRlIGRpZmZlcmVuY2UgKHNxdWFyZWQgbW9kdWxlKSBvZiBib3RoIHZlY3RvcnNcbiAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IG51bU5vZGVzOyBfaTcrKykge1xuICAgICAgICB2YXIgZGVsdGEgPSBwcmV2aW91c1tfaTddIC0gZWlnZW52ZWN0b3JbX2k3XTtcbiAgICAgICAgZGlmZiArPSBkZWx0YSAqIGRlbHRhO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBkaWZmZXJlbmNlIGlzIGxlc3MgdGhhbiB0aGUgZGVzaXJlZCB0aHJlc2hvbGQsIHN0b3AgaXRlcmF0aW5nXG4gICAgICBpZiAoZGlmZiA8IHByZWNpc2lvbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgIHJhbms6IGZ1bmN0aW9uIHJhbmsobm9kZSkge1xuICAgICAgICBub2RlID0gY3kuY29sbGVjdGlvbihub2RlKVswXTtcbiAgICAgICAgcmV0dXJuIGVpZ2VudmVjdG9yW25vZGVzLmluZGV4T2Yobm9kZSldO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlcztcbiAgfSAvLyBwYWdlUmFua1xufTsgLy8gZWxlc2ZuXG5cbnZhciBkZWZhdWx0cyRmID0gZGVmYXVsdHMkZyh7XG4gIHJvb3Q6IG51bGwsXG4gIHdlaWdodDogZnVuY3Rpb24gd2VpZ2h0KGVkZ2UpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICBhbHBoYTogMFxufSk7XG52YXIgZWxlc2ZuJG4gPSB7XG4gIGRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkOiBmdW5jdGlvbiBkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzJGYob3B0aW9ucyk7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgaWYgKCFvcHRpb25zLmRpcmVjdGVkKSB7XG4gICAgICB2YXIgZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG1heERlZ3JlZSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcbiAgICAgICAgb3B0aW9ucy5yb290ID0gbm9kZTtcbiAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucyk7XG4gICAgICAgIGlmIChtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSkge1xuICAgICAgICAgIG1heERlZ3JlZSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuICAgICAgICB9XG4gICAgICAgIGRlZ3JlZXNbbm9kZS5pZCgpXSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBmdW5jdGlvbiBkZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhEZWdyZWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVncmVlc1tub2RlLmlkKCldIC8gbWF4RGVncmVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5kZWdyZWVzID0ge307XG4gICAgICB2YXIgb3V0ZGVncmVlcyA9IHt9O1xuICAgICAgdmFyIG1heEluZGVncmVlID0gMDtcbiAgICAgIHZhciBtYXhPdXRkZWdyZWUgPSAwO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bU5vZGVzOyBfaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcbiAgICAgICAgdmFyIGlkID0gX25vZGUuaWQoKTtcblxuICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHlcbiAgICAgICAgb3B0aW9ucy5yb290ID0gX25vZGU7XG4gICAgICAgIHZhciBfY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eShvcHRpb25zKTtcbiAgICAgICAgaWYgKG1heEluZGVncmVlIDwgX2N1cnJEZWdyZWUuaW5kZWdyZWUpIG1heEluZGVncmVlID0gX2N1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPCBfY3VyckRlZ3JlZS5vdXRkZWdyZWUpIG1heE91dGRlZ3JlZSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgICAgaW5kZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLmluZGVncmVlO1xuICAgICAgICBvdXRkZWdyZWVzW2lkXSA9IF9jdXJyRGVncmVlLm91dGRlZ3JlZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluZGVncmVlOiBmdW5jdGlvbiBpbmRlZ3JlZShub2RlKSB7XG4gICAgICAgICAgaWYgKG1heEluZGVncmVlID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5kZWdyZWVzW25vZGUuaWQoKV0gLyBtYXhJbmRlZ3JlZTtcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZGVncmVlOiBmdW5jdGlvbiBvdXRkZWdyZWUobm9kZSkge1xuICAgICAgICAgIGlmIChtYXhPdXRkZWdyZWUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICBub2RlID0gY3kuZmlsdGVyKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb3V0ZGVncmVlc1tub2RlLmlkKCldIC8gbWF4T3V0ZGVncmVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgLy8gZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWRcblxuICAvLyBJbXBsZW1lbnRlZCBmcm9tIHRoZSBhbGdvcml0aG0gaW4gT3BzYWhsJ3MgcGFwZXJcbiAgLy8gXCJOb2RlIGNlbnRyYWxpdHkgaW4gd2VpZ2h0ZWQgbmV0d29ya3M6IEdlbmVyYWxpemluZyBkZWdyZWUgYW5kIHNob3J0ZXN0IHBhdGhzXCJcbiAgLy8gY2hlY2sgdGhlIGhlYWRpbmcgMiBcIkRlZ3JlZVwiXG4gIGRlZ3JlZUNlbnRyYWxpdHk6IGZ1bmN0aW9uIGRlZ3JlZUNlbnRyYWxpdHkob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyRmKG9wdGlvbnMpO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgY2FsbGluZ0VsZXMgPSB0aGlzO1xuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICByb290ID0gX29wdGlvbnMucm9vdCxcbiAgICAgIHdlaWdodCA9IF9vcHRpb25zLndlaWdodCxcbiAgICAgIGRpcmVjdGVkID0gX29wdGlvbnMuZGlyZWN0ZWQsXG4gICAgICBhbHBoYSA9IF9vcHRpb25zLmFscGhhO1xuICAgIHJvb3QgPSBjeS5jb2xsZWN0aW9uKHJvb3QpWzBdO1xuICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgIHZhciBjb25uRWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGNhbGxpbmdFbGVzKTtcbiAgICAgIHZhciBrID0gY29ubkVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBzID0gMDtcblxuICAgICAgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5FZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzICs9IHdlaWdodChjb25uRWRnZXNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVncmVlOiBNYXRoLnBvdyhrLCAxIC0gYWxwaGEpICogTWF0aC5wb3cocywgYWxwaGEpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZWRnZXMgPSByb290LmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgICB2YXIgaW5jb21pbmcgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UudGFyZ2V0KCkuc2FtZShyb290KSAmJiBjYWxsaW5nRWxlcy5oYXMoZWRnZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBvdXRnb2luZyA9IGVkZ2VzLmZpbHRlcihmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS5zb3VyY2UoKS5zYW1lKHJvb3QpICYmIGNhbGxpbmdFbGVzLmhhcyhlZGdlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGtfaW4gPSBpbmNvbWluZy5sZW5ndGg7XG4gICAgICB2YXIga19vdXQgPSBvdXRnb2luZy5sZW5ndGg7XG4gICAgICB2YXIgc19pbiA9IDA7XG4gICAgICB2YXIgc19vdXQgPSAwO1xuXG4gICAgICAvLyBOb3csIHN1bSBpbmNvbWluZyBlZGdlIHdlaWdodHNcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGluY29taW5nLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgc19pbiArPSB3ZWlnaHQoaW5jb21pbmdbX2kyXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgb3V0Z29pbmcubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICBzX291dCArPSB3ZWlnaHQob3V0Z29pbmdbX2kzXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmRlZ3JlZTogTWF0aC5wb3coa19pbiwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfaW4sIGFscGhhKSxcbiAgICAgICAgb3V0ZGVncmVlOiBNYXRoLnBvdyhrX291dCwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfb3V0LCBhbHBoYSlcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIGRlZ3JlZUNlbnRyYWxpdHlcbn07IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcbmVsZXNmbiRuLmRjID0gZWxlc2ZuJG4uZGVncmVlQ2VudHJhbGl0eTtcbmVsZXNmbiRuLmRjbiA9IGVsZXNmbiRuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuJG4uZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbnZhciBkZWZhdWx0cyRlID0gZGVmYXVsdHMkZyh7XG4gIGhhcm1vbmljOiB0cnVlLFxuICB3ZWlnaHQ6IGZ1bmN0aW9uIHdlaWdodCgpIHtcbiAgICByZXR1cm4gMTtcbiAgfSxcbiAgZGlyZWN0ZWQ6IGZhbHNlLFxuICByb290OiBudWxsXG59KTtcbnZhciBlbGVzZm4kbSA9IHtcbiAgY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIGNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkKG9wdGlvbnMpIHtcbiAgICB2YXIgX2RlZmF1bHRzID0gZGVmYXVsdHMkZShvcHRpb25zKSxcbiAgICAgIGhhcm1vbmljID0gX2RlZmF1bHRzLmhhcm1vbmljLFxuICAgICAgd2VpZ2h0ID0gX2RlZmF1bHRzLndlaWdodCxcbiAgICAgIGRpcmVjdGVkID0gX2RlZmF1bHRzLmRpcmVjdGVkO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgY2xvc2VuZXNzZXMgPSB7fTtcbiAgICB2YXIgbWF4Q2xvc2VuZXNzID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIGZ3ID0gdGhpcy5mbG95ZFdhcnNoYWxsKHtcbiAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgZGlyZWN0ZWQ6IGRpcmVjdGVkXG4gICAgfSk7XG5cbiAgICAvLyBDb21wdXRlIGNsb3NlbmVzcyBmb3IgZXZlcnkgbm9kZSBhbmQgZmluZCB0aGUgbWF4aW11bSBjbG9zZW5lc3NcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY3VyckNsb3NlbmVzcyA9IDA7XG4gICAgICB2YXIgbm9kZV9pID0gbm9kZXNbaV07XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgdmFyIGQgPSBmdy5kaXN0YW5jZShub2RlX2ksIG5vZGVzW2pdKTtcbiAgICAgICAgICBpZiAoaGFybW9uaWMpIHtcbiAgICAgICAgICAgIGN1cnJDbG9zZW5lc3MgKz0gMSAvIGQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJDbG9zZW5lc3MgKz0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFybW9uaWMpIHtcbiAgICAgICAgY3VyckNsb3NlbmVzcyA9IDEgLyBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuICAgICAgaWYgKG1heENsb3NlbmVzcyA8IGN1cnJDbG9zZW5lc3MpIHtcbiAgICAgICAgbWF4Q2xvc2VuZXNzID0gY3VyckNsb3NlbmVzcztcbiAgICAgIH1cbiAgICAgIGNsb3NlbmVzc2VzW25vZGVfaS5pZCgpXSA9IGN1cnJDbG9zZW5lc3M7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjbG9zZW5lc3M6IGZ1bmN0aW9uIGNsb3NlbmVzcyhub2RlKSB7XG4gICAgICAgIGlmIChtYXhDbG9zZW5lc3MgPT0gMCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgbm9kZSA9IGN5LmZpbHRlcihub2RlKVswXS5pZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvc2VuZXNzZXNbbm9kZV0gLyBtYXhDbG9zZW5lc3M7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gIGNsb3NlbmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIGNsb3NlbmVzc0NlbnRyYWxpdHkob3B0aW9ucykge1xuICAgIHZhciBfZGVmYXVsdHMyID0gZGVmYXVsdHMkZShvcHRpb25zKSxcbiAgICAgIHJvb3QgPSBfZGVmYXVsdHMyLnJvb3QsXG4gICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMyLndlaWdodCxcbiAgICAgIGRpcmVjdGVkID0gX2RlZmF1bHRzMi5kaXJlY3RlZCxcbiAgICAgIGhhcm1vbmljID0gX2RlZmF1bHRzMi5oYXJtb25pYztcbiAgICByb290ID0gdGhpcy5maWx0ZXIocm9vdClbMF07XG5cbiAgICAvLyB3ZSBuZWVkIGRpc3RhbmNlIGZyb20gdGhpcyBub2RlIHRvIGV2ZXJ5IG90aGVyIG5vZGVcbiAgICB2YXIgZGlqa3N0cmEgPSB0aGlzLmRpamtzdHJhKHtcbiAgICAgIHJvb3Q6IHJvb3QsXG4gICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgIH0pO1xuICAgIHZhciB0b3RhbERpc3RhbmNlID0gMDtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICAgIGlmICghbi5zYW1lKHJvb3QpKSB7XG4gICAgICAgIHZhciBkID0gZGlqa3N0cmEuZGlzdGFuY2VUbyhuKTtcbiAgICAgICAgaWYgKGhhcm1vbmljKSB7XG4gICAgICAgICAgdG90YWxEaXN0YW5jZSArPSAxIC8gZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhcm1vbmljID8gdG90YWxEaXN0YW5jZSA6IDEgLyB0b3RhbERpc3RhbmNlO1xuICB9IC8vIGNsb3NlbmVzc0NlbnRyYWxpdHlcbn07IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcbmVsZXNmbiRtLmNjID0gZWxlc2ZuJG0uY2xvc2VuZXNzQ2VudHJhbGl0eTtcbmVsZXNmbiRtLmNjbiA9IGVsZXNmbiRtLmNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkID0gZWxlc2ZuJG0uY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ7XG5cbnZhciBkZWZhdWx0cyRkID0gZGVmYXVsdHMkZyh7XG4gIHdlaWdodDogbnVsbCxcbiAgZGlyZWN0ZWQ6IGZhbHNlXG59KTtcbnZhciBlbGVzZm4kbCA9IHtcbiAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiBiZXR3ZWVubmVzc0NlbnRyYWxpdHkob3B0aW9ucykge1xuICAgIHZhciBfZGVmYXVsdHMgPSBkZWZhdWx0cyRkKG9wdGlvbnMpLFxuICAgICAgZGlyZWN0ZWQgPSBfZGVmYXVsdHMuZGlyZWN0ZWQsXG4gICAgICB3ZWlnaHQgPSBfZGVmYXVsdHMud2VpZ2h0O1xuICAgIHZhciB3ZWlnaHRlZCA9IHdlaWdodCAhPSBudWxsO1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgIC8vIHN0YXJ0aW5nXG4gICAgdmFyIFYgPSB0aGlzLm5vZGVzKCk7XG4gICAgdmFyIEEgPSB7fTtcbiAgICB2YXIgX0MgPSB7fTtcbiAgICB2YXIgbWF4ID0gMDtcbiAgICB2YXIgQyA9IHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsKSB7XG4gICAgICAgIF9DW2tleV0gPSB2YWw7XG4gICAgICAgIGlmICh2YWwgPiBtYXgpIHtcbiAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9DW2tleV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEEgY29udGFpbnMgdGhlIG5laWdoYm9yaG9vZHMgb2YgZXZlcnkgbm9kZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHYgPSBWW2ldO1xuICAgICAgdmFyIHZpZCA9IHYuaWQoKTtcbiAgICAgIGlmIChkaXJlY3RlZCkge1xuICAgICAgICBBW3ZpZF0gPSB2Lm91dGdvZXJzKCkubm9kZXMoKTsgLy8gZ2V0IG91dGdvZXJzIG9mIGV2ZXJ5IG5vZGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFbdmlkXSA9IHYub3Blbk5laWdoYm9yaG9vZCgpLm5vZGVzKCk7IC8vIGdldCBuZWlnaGJvcnMgb2YgZXZlcnkgbm9kZVxuICAgICAgfVxuICAgICAgQy5zZXQodmlkLCAwKTtcbiAgICB9XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgc2lkID0gVltzXS5pZCgpO1xuICAgICAgdmFyIFMgPSBbXTsgLy8gc3RhY2tcbiAgICAgIHZhciBQID0ge307XG4gICAgICB2YXIgZyA9IHt9O1xuICAgICAgdmFyIGQgPSB7fTtcbiAgICAgIHZhciBRID0gbmV3IEhlYXAoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGRbYV0gLSBkW2JdO1xuICAgICAgfSk7IC8vIHF1ZXVlXG5cbiAgICAgIC8vIGluaXQgZGljdGlvbmFyaWVzXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgVi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF92aWQgPSBWW19pXS5pZCgpO1xuICAgICAgICBQW192aWRdID0gW107XG4gICAgICAgIGdbX3ZpZF0gPSAwO1xuICAgICAgICBkW192aWRdID0gSW5maW5pdHk7XG4gICAgICB9XG4gICAgICBnW3NpZF0gPSAxOyAvLyBzaWdtYVxuICAgICAgZFtzaWRdID0gMDsgLy8gZGlzdGFuY2UgdG8gc1xuXG4gICAgICBRLnB1c2goc2lkKTtcbiAgICAgIHdoaWxlICghUS5lbXB0eSgpKSB7XG4gICAgICAgIHZhciBfdiA9IFEucG9wKCk7XG4gICAgICAgIFMucHVzaChfdik7XG4gICAgICAgIGlmICh3ZWlnaHRlZCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQVtfdl0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciB3ID0gQVtfdl1bal07XG4gICAgICAgICAgICB2YXIgdkVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKF92KTtcbiAgICAgICAgICAgIHZhciBlZGdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHZFbGUuZWRnZXNUbyh3KS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGVkZ2UgPSB2RWxlLmVkZ2VzVG8odylbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlZGdlID0gdy5lZGdlc1RvKHZFbGUpWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVkZ2VXZWlnaHQgPSB3ZWlnaHQoZWRnZSk7XG4gICAgICAgICAgICB3ID0gdy5pZCgpO1xuICAgICAgICAgICAgaWYgKGRbd10gPiBkW192XSArIGVkZ2VXZWlnaHQpIHtcbiAgICAgICAgICAgICAgZFt3XSA9IGRbX3ZdICsgZWRnZVdlaWdodDtcbiAgICAgICAgICAgICAgaWYgKFEubm9kZXMuaW5kZXhPZih3KSA8IDApIHtcbiAgICAgICAgICAgICAgICAvL2lmIHcgaXMgbm90IGluIFFcbiAgICAgICAgICAgICAgICBRLnB1c2godyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBvc2l0aW9uIGlmIHcgaXMgaW4gUVxuICAgICAgICAgICAgICAgIFEudXBkYXRlSXRlbSh3KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBnW3ddID0gMDtcbiAgICAgICAgICAgICAgUFt3XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRbd10gPT0gZFtfdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgIGdbd10gPSBnW3ddICsgZ1tfdl07XG4gICAgICAgICAgICAgIFBbd10ucHVzaChfdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBBW192XS5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgIHZhciBfdyA9IEFbX3ZdW19qXS5pZCgpO1xuICAgICAgICAgICAgaWYgKGRbX3ddID09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgIFEucHVzaChfdyk7XG4gICAgICAgICAgICAgIGRbX3ddID0gZFtfdl0gKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRbX3ddID09IGRbX3ZdICsgMSkge1xuICAgICAgICAgICAgICBnW193XSA9IGdbX3ddICsgZ1tfdl07XG4gICAgICAgICAgICAgIFBbX3ddLnB1c2goX3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGUgPSB7fTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IFYubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBlW1ZbX2kyXS5pZCgpXSA9IDA7XG4gICAgICB9XG4gICAgICB3aGlsZSAoUy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfdzIgPSBTLnBvcCgpO1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBQW193Ml0ubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgIHZhciBfdjIgPSBQW193Ml1bX2oyXTtcbiAgICAgICAgICBlW192Ml0gPSBlW192Ml0gKyBnW192Ml0gLyBnW193Ml0gKiAoMSArIGVbX3cyXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF93MiAhPSBWW3NdLmlkKCkpIHtcbiAgICAgICAgICBDLnNldChfdzIsIEMuZ2V0KF93MikgKyBlW193Ml0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IFYubGVuZ3RoOyBzKyspIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuICAgIHZhciByZXQgPSB7XG4gICAgICBiZXR3ZWVubmVzczogZnVuY3Rpb24gYmV0d2Vlbm5lc3Mobm9kZSkge1xuICAgICAgICB2YXIgaWQgPSBjeS5jb2xsZWN0aW9uKG5vZGUpLmlkKCk7XG4gICAgICAgIHJldHVybiBDLmdldChpZCk7XG4gICAgICB9LFxuICAgICAgYmV0d2Vlbm5lc3NOb3JtYWxpemVkOiBmdW5jdGlvbiBiZXR3ZWVubmVzc05vcm1hbGl6ZWQobm9kZSkge1xuICAgICAgICBpZiAobWF4ID09IDApIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWQgPSBjeS5jb2xsZWN0aW9uKG5vZGUpLmlkKCk7XG4gICAgICAgIHJldHVybiBDLmdldChpZCkgLyBtYXg7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFsaWFzXG4gICAgcmV0LmJldHdlZW5uZXNzTm9ybWFsaXNlZCA9IHJldC5iZXR3ZWVubmVzc05vcm1hbGl6ZWQ7XG4gICAgcmV0dXJuIHJldDtcbiAgfSAvLyBiZXR3ZWVubmVzc0NlbnRyYWxpdHlcbn07IC8vIGVsZXNmblxuXG4vLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGljYWwgYWxpYXNcbmVsZXNmbiRsLmJjID0gZWxlc2ZuJGwuYmV0d2Vlbm5lc3NDZW50cmFsaXR5O1xuXG4vLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXRvc2NhcGUvY3l0b3NjYXBlLmpzLW1hcmtvdi1jbHVzdGVyXG5cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBkZWZhdWx0cyRjID0gZGVmYXVsdHMkZyh7XG4gIGV4cGFuZEZhY3RvcjogMixcbiAgLy8gYWZmZWN0cyB0aW1lIG9mIGNvbXB1dGF0aW9uIGFuZCBjbHVzdGVyIGdyYW51bGFyaXR5IHRvIHNvbWUgZXh0ZW50OiBNICogTVxuICBpbmZsYXRlRmFjdG9yOiAyLFxuICAvLyBhZmZlY3RzIGNsdXN0ZXIgZ3JhbnVsYXJpdHkgKHRoZSBncmVhdGVyIHRoZSB2YWx1ZSwgdGhlIG1vcmUgY2x1c3RlcnMpOiBNKGksaikgLyBFKGopXG4gIG11bHRGYWN0b3I6IDEsXG4gIC8vIG9wdGlvbmFsIHNlbGYgbG9vcHMgZm9yIGVhY2ggbm9kZS4gVXNlIGEgbmV1dHJhbCB2YWx1ZSB0byBpbXByb3ZlIGNsdXN0ZXIgY29tcHV0YXRpb25zLlxuICBtYXhJdGVyYXRpb25zOiAyMCxcbiAgLy8gbWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyBvZiB0aGUgTUNMIGFsZ29yaXRobSBpbiBhIHNpbmdsZSBydW5cbiAgYXR0cmlidXRlczogW1xuICAvLyBhdHRyaWJ1dGVzL2ZlYXR1cmVzIHVzZWQgdG8gZ3JvdXAgbm9kZXMsIGllLiBzaW1pbGFyaXR5IHZhbHVlcyBiZXR3ZWVuIG5vZGVzXG4gIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1dXG59KTtcbi8qIGVzbGludC1lbmFibGUgKi9cblxudmFyIHNldE9wdGlvbnMkMyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICByZXR1cm4gZGVmYXVsdHMkYyhvcHRpb25zKTtcbn07XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBnZXRTaW1pbGFyaXR5JDEgPSBmdW5jdGlvbiBnZXRTaW1pbGFyaXR5KGVkZ2UsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIHRvdGFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdG90YWwgKz0gYXR0cmlidXRlc1tpXShlZGdlKTtcbiAgfVxuICByZXR1cm4gdG90YWw7XG59O1xudmFyIGFkZExvb3BzID0gZnVuY3Rpb24gYWRkTG9vcHMoTSwgbiwgdmFsKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgTVtpICogbiArIGldID0gdmFsO1xuICB9XG59O1xudmFyIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShNLCBuKSB7XG4gIHZhciBzdW07XG4gIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG47IGNvbCsrKSB7XG4gICAgc3VtID0gMDtcbiAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBuOyByb3crKykge1xuICAgICAgc3VtICs9IE1bcm93ICogbiArIGNvbF07XG4gICAgfVxuICAgIGZvciAodmFyIF9yb3cgPSAwOyBfcm93IDwgbjsgX3JvdysrKSB7XG4gICAgICBNW19yb3cgKiBuICsgY29sXSA9IE1bX3JvdyAqIG4gKyBjb2xdIC8gc3VtO1xuICAgIH1cbiAgfVxufTtcblxuLy8gVE9ETzogYmxvY2tlZCBtYXRyaXggbXVsdGlwbGljYXRpb24/XG52YXIgbW11bHQgPSBmdW5jdGlvbiBtbXVsdChBLCBCLCBuKSB7XG4gIHZhciBDID0gbmV3IEFycmF5KG4gKiBuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgQ1tpICogbiArIGpdID0gMDtcbiAgICB9XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBuOyBfaisrKSB7XG4gICAgICAgIENbaSAqIG4gKyBfal0gKz0gQVtpICogbiArIGtdICogQltrICogbiArIF9qXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIEM7XG59O1xudmFyIGV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZChNLCBuLCBleHBhbmRGYWN0b3IgLyoqIHBvd2VyICoqLykge1xuICB2YXIgX00gPSBNLnNsaWNlKDApO1xuICBmb3IgKHZhciBwID0gMTsgcCA8IGV4cGFuZEZhY3RvcjsgcCsrKSB7XG4gICAgTSA9IG1tdWx0KE0sIF9NLCBuKTtcbiAgfVxuICByZXR1cm4gTTtcbn07XG52YXIgaW5mbGF0ZSA9IGZ1bmN0aW9uIGluZmxhdGUoTSwgbiwgaW5mbGF0ZUZhY3RvciAvKiogciAqKi8pIHtcbiAgdmFyIF9NID0gbmV3IEFycmF5KG4gKiBuKTtcblxuICAvLyBNKGksaikgXiBpbmZsYXRlUG93ZXJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuICogbjsgaSsrKSB7XG4gICAgX01baV0gPSBNYXRoLnBvdyhNW2ldLCBpbmZsYXRlRmFjdG9yKTtcbiAgfVxuICBub3JtYWxpemUoX00sIG4pO1xuICByZXR1cm4gX007XG59O1xudmFyIGhhc0NvbnZlcmdlZCA9IGZ1bmN0aW9uIGhhc0NvbnZlcmdlZChNLCBfTSwgbjIsIHJvdW5kRmFjdG9yKSB7XG4gIC8vIENoZWNrIHRoYXQgYm90aCBtYXRyaWNlcyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIChpLGopXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjI7IGkrKykge1xuICAgIHZhciB2MSA9IE1hdGgucm91bmQoTVtpXSAqIE1hdGgucG93KDEwLCByb3VuZEZhY3RvcikpIC8gTWF0aC5wb3coMTAsIHJvdW5kRmFjdG9yKTsgLy8gdHJ1bmNhdGUgdG8gJ3JvdW5kRmFjdG9yJyBkZWNpbWFsIHBsYWNlc1xuICAgIHZhciB2MiA9IE1hdGgucm91bmQoX01baV0gKiBNYXRoLnBvdygxMCwgcm91bmRGYWN0b3IpKSAvIE1hdGgucG93KDEwLCByb3VuZEZhY3Rvcik7XG4gICAgaWYgKHYxICE9PSB2Mikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgYXNzaWduJDIgPSBmdW5jdGlvbiBhc3NpZ24oTSwgbiwgbm9kZXMsIGN5KSB7XG4gIHZhciBjbHVzdGVycyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciBjbHVzdGVyID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIC8vIFJvdy13aXNlIGF0dHJhY3RvcnMgYW5kIGVsZW1lbnRzIHRoYXQgdGhleSBhdHRyYWN0IGJlbG9uZyBpbiBzYW1lIGNsdXN0ZXJcbiAgICAgIGlmIChNYXRoLnJvdW5kKE1baSAqIG4gKyBqXSAqIDEwMDApIC8gMTAwMCA+IDApIHtcbiAgICAgICAgY2x1c3Rlci5wdXNoKG5vZGVzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsdXN0ZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjbHVzdGVycy5wdXNoKGN5LmNvbGxlY3Rpb24oY2x1c3RlcikpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIGlzRHVwbGljYXRlID0gZnVuY3Rpb24gaXNEdXBsaWNhdGUoYzEsIGMyKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYzEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWMyW2ldIHx8IGMxW2ldLmlkKCkgIT09IGMyW2ldLmlkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIHJlbW92ZUR1cGxpY2F0ZXMgPSBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGNsdXN0ZXJzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2x1c3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsdXN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAoaSAhPSBqICYmIGlzRHVwbGljYXRlKGNsdXN0ZXJzW2ldLCBjbHVzdGVyc1tqXSkpIHtcbiAgICAgICAgY2x1c3RlcnMuc3BsaWNlKGosIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIG1hcmtvdkNsdXN0ZXJpbmcgPSBmdW5jdGlvbiBtYXJrb3ZDbHVzdGVyaW5nKG9wdGlvbnMpIHtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAvLyBTZXQgcGFyYW1ldGVycyBvZiBhbGdvcml0aG06XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQzKG9wdGlvbnMpO1xuXG4gIC8vIE1hcCBlYWNoIG5vZGUgdG8gaXRzIHBvc2l0aW9uIGluIG5vZGUgYXJyYXlcbiAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBzdG9jaGFzdGljIG1hdHJpeCBNIGZyb20gaW5wdXQgZ3JhcGggRyAoc2hvdWxkIGJlIHN5bW1ldHJpYy91bmRpcmVjdGVkKVxuICB2YXIgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICBuMiA9IG4gKiBuO1xuICB2YXIgTSA9IG5ldyBBcnJheShuMiksXG4gICAgX007XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBuMjsgX2krKykge1xuICAgIE1bX2ldID0gMDtcbiAgfVxuICBmb3IgKHZhciBlID0gMDsgZSA8IGVkZ2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tlXTtcbiAgICB2YXIgX2kyID0gaWQycG9zaXRpb25bZWRnZS5zb3VyY2UoKS5pZCgpXTtcbiAgICB2YXIgaiA9IGlkMnBvc2l0aW9uW2VkZ2UudGFyZ2V0KCkuaWQoKV07XG4gICAgdmFyIHNpbSA9IGdldFNpbWlsYXJpdHkkMShlZGdlLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIE1bX2kyICogbiArIGpdICs9IHNpbTsgLy8gRyBzaG91bGQgYmUgc3ltbWV0cmljIGFuZCB1bmRpcmVjdGVkXG4gICAgTVtqICogbiArIF9pMl0gKz0gc2ltO1xuICB9XG5cbiAgLy8gQmVnaW4gTWFya292IGNsdXN0ZXIgYWxnb3JpdGhtXG5cbiAgLy8gU3RlcCAxOiBBZGQgc2VsZiBsb29wcyB0byBlYWNoIG5vZGUsIGllLiBhZGQgbXVsdEZhY3RvciB0byBtYXRyaXggZGlhZ29uYWxcbiAgYWRkTG9vcHMoTSwgbiwgb3B0cy5tdWx0RmFjdG9yKTtcblxuICAvLyBTdGVwIDI6IE0gPSBub3JtYWxpemUoIE0gKTtcbiAgbm9ybWFsaXplKE0sIG4pO1xuICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTtcblxuICAgIC8vIFN0ZXAgMzpcbiAgICBfTSA9IGV4cGFuZChNLCBuLCBvcHRzLmV4cGFuZEZhY3Rvcik7XG5cbiAgICAvLyBTdGVwIDQ6XG4gICAgTSA9IGluZmxhdGUoX00sIG4sIG9wdHMuaW5mbGF0ZUZhY3Rvcik7XG5cbiAgICAvLyBTdGVwIDU6IGNoZWNrIHRvIHNlZSBpZiB+c3RlYWR5IHN0YXRlIGhhcyBiZWVuIHJlYWNoZWRcbiAgICBpZiAoIWhhc0NvbnZlcmdlZChNLCBfTSwgbjIsIDQpKSB7XG4gICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgaXRlcmF0aW9ucysrO1xuICB9XG5cbiAgLy8gQnVpbGQgY2x1c3RlcnMgZnJvbSBtYXRyaXhcbiAgdmFyIGNsdXN0ZXJzID0gYXNzaWduJDIoTSwgbiwgbm9kZXMsIGN5KTtcblxuICAvLyBSZW1vdmUgZHVwbGljYXRlIGNsdXN0ZXJzIGR1ZSB0byBzeW1tZXRyeSBvZiBncmFwaCBhbmQgTSBtYXRyaXhcbiAgY2x1c3RlcnMgPSByZW1vdmVEdXBsaWNhdGVzKGNsdXN0ZXJzKTtcbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcbnZhciBtYXJrb3ZDbHVzdGVyaW5nJDEgPSB7XG4gIG1hcmtvdkNsdXN0ZXJpbmc6IG1hcmtvdkNsdXN0ZXJpbmcsXG4gIG1jbDogbWFya292Q2x1c3RlcmluZ1xufTtcblxuLy8gQ29tbW9uIGRpc3RhbmNlIG1ldHJpY3MgZm9yIGNsdXN0ZXJpbmcgYWxnb3JpdGhtc1xuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGllcmFyY2hpY2FsX2NsdXN0ZXJpbmcjTWV0cmljXG5cbnZhciBpZGVudGl0eSQxID0gZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn07XG52YXIgYWJzRGlmZiA9IGZ1bmN0aW9uIGFic0RpZmYocCwgcSkge1xuICByZXR1cm4gTWF0aC5hYnMocSAtIHApO1xufTtcbnZhciBhZGRBYnNEaWZmID0gZnVuY3Rpb24gYWRkQWJzRGlmZih0b3RhbCwgcCwgcSkge1xuICByZXR1cm4gdG90YWwgKyBhYnNEaWZmKHAsIHEpO1xufTtcbnZhciBhZGRTcXVhcmVkRGlmZiA9IGZ1bmN0aW9uIGFkZFNxdWFyZWREaWZmKHRvdGFsLCBwLCBxKSB7XG4gIHJldHVybiB0b3RhbCArIE1hdGgucG93KHEgLSBwLCAyKTtcbn07XG52YXIgc3FydCA9IGZ1bmN0aW9uIHNxcnQoeCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHgpO1xufTtcbnZhciBtYXhBYnNEaWZmID0gZnVuY3Rpb24gbWF4QWJzRGlmZihjdXJyZW50TWF4LCBwLCBxKSB7XG4gIHJldHVybiBNYXRoLm1heChjdXJyZW50TWF4LCBhYnNEaWZmKHAsIHEpKTtcbn07XG52YXIgZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIGluaXQsIHZpc2l0KSB7XG4gIHZhciBwb3N0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBpZGVudGl0eSQxO1xuICB2YXIgcmV0ID0gaW5pdDtcbiAgdmFyIHAsIHE7XG4gIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IGxlbmd0aDsgZGltKyspIHtcbiAgICBwID0gZ2V0UChkaW0pO1xuICAgIHEgPSBnZXRRKGRpbSk7XG4gICAgcmV0ID0gdmlzaXQocmV0LCBwLCBxKTtcbiAgfVxuICByZXR1cm4gcG9zdChyZXQpO1xufTtcbnZhciBkaXN0YW5jZXMgPSB7XG4gIGV1Y2xpZGVhbjogZnVuY3Rpb24gZXVjbGlkZWFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIGlmIChsZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkU3F1YXJlZERpZmYsIHNxcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3Igc2luZ2xlIGF0dHIgY2FzZSwgbW9yZSBlZmZpY2llbnQgdG8gYXZvaWQgc3FydFxuICAgICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkQWJzRGlmZik7XG4gICAgfVxuICB9LFxuICBzcXVhcmVkRXVjbGlkZWFuOiBmdW5jdGlvbiBzcXVhcmVkRXVjbGlkZWFuKGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIDAsIGFkZFNxdWFyZWREaWZmKTtcbiAgfSxcbiAgbWFuaGF0dGFuOiBmdW5jdGlvbiBtYW5oYXR0YW4obGVuZ3RoLCBnZXRQLCBnZXRRKSB7XG4gICAgcmV0dXJuIGdldERpc3RhbmNlKGxlbmd0aCwgZ2V0UCwgZ2V0USwgMCwgYWRkQWJzRGlmZik7XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gbWF4KGxlbmd0aCwgZ2V0UCwgZ2V0USkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShsZW5ndGgsIGdldFAsIGdldFEsIC1JbmZpbml0eSwgbWF4QWJzRGlmZik7XG4gIH1cbn07XG5cbi8vIGluIGNhc2UgdGhlIHVzZXIgYWNjaWRlbnRhbGx5IGRvZXNuJ3QgdXNlIGNhbWVsIGNhc2VcbmRpc3RhbmNlc1snc3F1YXJlZC1ldWNsaWRlYW4nXSA9IGRpc3RhbmNlc1snc3F1YXJlZEV1Y2xpZGVhbiddO1xuZGlzdGFuY2VzWydzcXVhcmVkZXVjbGlkZWFuJ10gPSBkaXN0YW5jZXNbJ3NxdWFyZWRFdWNsaWRlYW4nXTtcbmZ1bmN0aW9uIGNsdXN0ZXJpbmdEaXN0YW5jZSAobWV0aG9kLCBsZW5ndGgsIGdldFAsIGdldFEsIG5vZGVQLCBub2RlUSkge1xuICB2YXIgaW1wbDtcbiAgaWYgKGZuJDYobWV0aG9kKSkge1xuICAgIGltcGwgPSBtZXRob2Q7XG4gIH0gZWxzZSB7XG4gICAgaW1wbCA9IGRpc3RhbmNlc1ttZXRob2RdIHx8IGRpc3RhbmNlcy5ldWNsaWRlYW47XG4gIH1cbiAgaWYgKGxlbmd0aCA9PT0gMCAmJiBmbiQ2KG1ldGhvZCkpIHtcbiAgICByZXR1cm4gaW1wbChub2RlUCwgbm9kZVEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbXBsKGxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKTtcbiAgfVxufVxuXG52YXIgZGVmYXVsdHMkYiA9IGRlZmF1bHRzJGcoe1xuICBrOiAyLFxuICBtOiAyLFxuICBzZW5zaXRpdml0eVRocmVzaG9sZDogMC4wMDAxLFxuICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gIG1heEl0ZXJhdGlvbnM6IDEwLFxuICBhdHRyaWJ1dGVzOiBbXSxcbiAgdGVzdE1vZGU6IGZhbHNlLFxuICB0ZXN0Q2VudHJvaWRzOiBudWxsXG59KTtcbnZhciBzZXRPcHRpb25zJDIgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlZmF1bHRzJGIob3B0aW9ucyk7XG59O1xuXG52YXIgZ2V0RGlzdCA9IGZ1bmN0aW9uIGdldERpc3QodHlwZSwgbm9kZSwgY2VudHJvaWQsIGF0dHJpYnV0ZXMsIG1vZGUpIHtcbiAgdmFyIG5vTm9kZVAgPSBtb2RlICE9PSAna01lZG9pZHMnO1xuICB2YXIgZ2V0UCA9IG5vTm9kZVAgPyBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBjZW50cm9pZFtpXTtcbiAgfSA6IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXNbaV0oY2VudHJvaWQpO1xuICB9O1xuICB2YXIgZ2V0USA9IGZ1bmN0aW9uIGdldFEoaSkge1xuICAgIHJldHVybiBhdHRyaWJ1dGVzW2ldKG5vZGUpO1xuICB9O1xuICB2YXIgbm9kZVAgPSBjZW50cm9pZDtcbiAgdmFyIG5vZGVRID0gbm9kZTtcbiAgcmV0dXJuIGNsdXN0ZXJpbmdEaXN0YW5jZSh0eXBlLCBhdHRyaWJ1dGVzLmxlbmd0aCwgZ2V0UCwgZ2V0USwgbm9kZVAsIG5vZGVRKTtcbn07XG52YXIgcmFuZG9tQ2VudHJvaWRzID0gZnVuY3Rpb24gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBrLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBuZGltID0gYXR0cmlidXRlcy5sZW5ndGg7XG4gIHZhciBtaW4gPSBuZXcgQXJyYXkobmRpbSk7XG4gIHZhciBtYXggPSBuZXcgQXJyYXkobmRpbSk7XG4gIHZhciBjZW50cm9pZHMgPSBuZXcgQXJyYXkoayk7XG4gIHZhciBjZW50cm9pZCA9IG51bGw7XG5cbiAgLy8gRmluZCBtaW4sIG1heCB2YWx1ZXMgZm9yIGVhY2ggYXR0cmlidXRlIGRpbWVuc2lvblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5kaW07IGkrKykge1xuICAgIG1pbltpXSA9IG5vZGVzLm1pbihhdHRyaWJ1dGVzW2ldKS52YWx1ZTtcbiAgICBtYXhbaV0gPSBub2Rlcy5tYXgoYXR0cmlidXRlc1tpXSkudmFsdWU7XG4gIH1cblxuICAvLyBCdWlsZCBrIGNlbnRyb2lkcywgZWFjaCByZXByZXNlbnRlZCBhcyBhbiBuLWRpbSBmZWF0dXJlIHZlY3RvclxuICBmb3IgKHZhciBjID0gMDsgYyA8IGs7IGMrKykge1xuICAgIGNlbnRyb2lkID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5kaW07IF9pKyspIHtcbiAgICAgIGNlbnRyb2lkW19pXSA9IE1hdGgucmFuZG9tKCkgKiAobWF4W19pXSAtIG1pbltfaV0pICsgbWluW19pXTsgLy8gcmFuZG9tIGluaXRpYWwgdmFsdWVcbiAgICB9XG4gICAgY2VudHJvaWRzW2NdID0gY2VudHJvaWQ7XG4gIH1cbiAgcmV0dXJuIGNlbnRyb2lkcztcbn07XG52YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiBjbGFzc2lmeShub2RlLCBjZW50cm9pZHMsIGRpc3RhbmNlLCBhdHRyaWJ1dGVzLCB0eXBlKSB7XG4gIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjZW50cm9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlzdCA9IGdldERpc3QoZGlzdGFuY2UsIG5vZGUsIGNlbnRyb2lkc1tpXSwgYXR0cmlidXRlcywgdHlwZSk7XG4gICAgaWYgKGRpc3QgPCBtaW4pIHtcbiAgICAgIG1pbiA9IGRpc3Q7XG4gICAgICBpbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG52YXIgYnVpbGRDbHVzdGVyID0gZnVuY3Rpb24gYnVpbGRDbHVzdGVyKGNlbnRyb2lkLCBub2RlcywgYXNzaWdubWVudCkge1xuICB2YXIgY2x1c3RlciA9IFtdO1xuICB2YXIgbm9kZSA9IG51bGw7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgbm9kZXMubGVuZ3RoOyBuKyspIHtcbiAgICBub2RlID0gbm9kZXNbbl07XG4gICAgaWYgKGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9PT0gY2VudHJvaWQpIHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJOb2RlIFwiICsgbm9kZS5pZCgpICsgXCIgaXMgYXNzb2NpYXRlZCB3aXRoIG1lZG9pZCAjOiBcIiArIG0pO1xuICAgICAgY2x1c3Rlci5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2x1c3Rlcjtcbn07XG52YXIgaGF2ZVZhbHVlc0NvbnZlcmdlZCA9IGZ1bmN0aW9uIGhhdmVWYWx1ZXNDb252ZXJnZWQodjEsIHYyLCBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICByZXR1cm4gTWF0aC5hYnModjIgLSB2MSkgPD0gc2Vuc2l0aXZpdHlUaHJlc2hvbGQ7XG59O1xudmFyIGhhdmVNYXRyaWNlc0NvbnZlcmdlZCA9IGZ1bmN0aW9uIGhhdmVNYXRyaWNlc0NvbnZlcmdlZCh2MSwgdjIsIHNlbnNpdGl2aXR5VGhyZXNob2xkKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHYxW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHYxW2ldW2pdIC0gdjJbaV1bal0pO1xuICAgICAgaWYgKGRpZmYgPiBzZW5zaXRpdml0eVRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBzZWVuQmVmb3JlID0gZnVuY3Rpb24gc2VlbkJlZm9yZShub2RlLCBtZWRvaWRzLCBuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKG5vZGUgPT09IG1lZG9pZHNbaV0pIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgcmFuZG9tTWVkb2lkcyA9IGZ1bmN0aW9uIHJhbmRvbU1lZG9pZHMobm9kZXMsIGspIHtcbiAgdmFyIG1lZG9pZHMgPSBuZXcgQXJyYXkoayk7XG5cbiAgLy8gRm9yIHNtYWxsIGRhdGEgc2V0cywgdGhlIHByb2JhYmlsaXR5IG9mIG1lZG9pZCBjb25mbGljdCBpcyBncmVhdGVyLFxuICAvLyBzbyB3ZSBuZWVkIHRvIGNoZWNrIHRvIHNlZSBpZiB3ZSd2ZSBhbHJlYWR5IHNlZW4gb3IgY2hvc2UgdGhpcyBub2RlIGJlZm9yZS5cbiAgaWYgKG5vZGVzLmxlbmd0aCA8IDUwKSB7XG4gICAgLy8gUmFuZG9tbHkgc2VsZWN0IGsgbWVkb2lkcyBmcm9tIHRoZSBuIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZXMubGVuZ3RoKV07XG5cbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgY2hvc2VuIHRoaXMgbm9kZSB0byBiZSBhIG1lZG9pZCwgZG9uJ3QgY2hvb3NlIGl0IGFnYWluIChmb3Igc21hbGwgZGF0YSBzZXRzKS5cbiAgICAgIC8vIEluc3RlYWQgY2hvb3NlIGEgZGlmZmVyZW50IHJhbmRvbSBub2RlLlxuICAgICAgd2hpbGUgKHNlZW5CZWZvcmUobm9kZSwgbWVkb2lkcywgaSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldO1xuICAgICAgfVxuICAgICAgbWVkb2lkc1tpXSA9IG5vZGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbGF0aXZlbHkgbGFyZ2UgZGF0YSBzZXQsIHNvIHByZXR0eSBzYWZlIHRvIG5vdCBjaGVjayBhbmQganVzdCBzZWxlY3QgcmFuZG9tIG5vZGVzXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgazsgX2kyKyspIHtcbiAgICAgIG1lZG9pZHNbX2kyXSA9IG5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVzLmxlbmd0aCldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVkb2lkcztcbn07XG52YXIgZmluZENvc3QgPSBmdW5jdGlvbiBmaW5kQ29zdChwb3RlbnRpYWxOZXdNZWRvaWQsIGNsdXN0ZXIsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGNvc3QgPSAwO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IGNsdXN0ZXIubGVuZ3RoOyBuKyspIHtcbiAgICBjb3N0ICs9IGdldERpc3QoJ21hbmhhdHRhbicsIGNsdXN0ZXJbbl0sIHBvdGVudGlhbE5ld01lZG9pZCwgYXR0cmlidXRlcywgJ2tNZWRvaWRzJyk7XG4gIH1cbiAgcmV0dXJuIGNvc3Q7XG59O1xudmFyIGtNZWFucyA9IGZ1bmN0aW9uIGtNZWFucyhvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICB2YXIgbm9kZSA9IG51bGw7XG5cbiAgLy8gU2V0IHBhcmFtZXRlcnMgb2YgYWxnb3JpdGhtOiAjIG9mIGNsdXN0ZXJzLCBkaXN0YW5jZSBtZXRyaWMsIGV0Yy5cbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDIob3B0aW9ucyk7XG5cbiAgLy8gQmVnaW4gay1tZWFucyBhbGdvcml0aG1cbiAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KG9wdHMuayk7XG4gIHZhciBhc3NpZ25tZW50ID0ge307XG4gIHZhciBjZW50cm9pZHM7XG5cbiAgLy8gU3RlcCAxOiBJbml0aWFsaXplIGNlbnRyb2lkIHBvc2l0aW9uc1xuICBpZiAob3B0cy50ZXN0TW9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy50ZXN0Q2VudHJvaWRzID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGEgc2VlZGVkIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxuICAgICAgb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgICAgY2VudHJvaWRzID0gcmFuZG9tQ2VudHJvaWRzKG5vZGVzLCBvcHRzLmssIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdHMudGVzdENlbnRyb2lkcykgPT09ICdvYmplY3QnKSB7XG4gICAgICBjZW50cm9pZHMgPSBvcHRzLnRlc3RDZW50cm9pZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRyb2lkcyA9IHJhbmRvbUNlbnRyb2lkcyhub2Rlcywgb3B0cy5rLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjZW50cm9pZHMgPSByYW5kb21DZW50cm9pZHMobm9kZXMsIG9wdHMuaywgb3B0cy5hdHRyaWJ1dGVzKTtcbiAgfVxuICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIC8vIFN0ZXAgMjogQXNzaWduIG5vZGVzIHRvIHRoZSBuZWFyZXN0IGNlbnRyb2lkXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgbm9kZSA9IG5vZGVzW25dO1xuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGNsdXN0ZXIgdGhpcyBub2RlIGJlbG9uZ3MgdG86IG5vZGUgaWQgPT4gY2x1c3RlciAjXG4gICAgICBhc3NpZ25tZW50W25vZGUuaWQoKV0gPSBjbGFzc2lmeShub2RlLCBjZW50cm9pZHMsIG9wdHMuZGlzdGFuY2UsIG9wdHMuYXR0cmlidXRlcywgJ2tNZWFucycpO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgMzogRm9yIGVhY2ggb2YgdGhlIGsgY2x1c3RlcnMsIHVwZGF0ZSBpdHMgY2VudHJvaWRcbiAgICBpc1N0aWxsTW92aW5nID0gZmFsc2U7XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvcHRzLms7IGMrKykge1xuICAgICAgLy8gR2V0IGFsbCBub2RlcyB0aGF0IGJlbG9uZyB0byB0aGlzIGNsdXN0ZXJcbiAgICAgIHZhciBjbHVzdGVyID0gYnVpbGRDbHVzdGVyKGMsIG5vZGVzLCBhc3NpZ25tZW50KTtcbiAgICAgIGlmIChjbHVzdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBjbHVzdGVyIGlzIGVtcHR5LCBicmVhayBvdXQgZWFybHkgJiBtb3ZlIHRvIG5leHQgY2x1c3RlclxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGNlbnRyb2lkcyBieSBjYWxjdWxhdGluZyBhdmcgb2YgYWxsIG5vZGVzIHdpdGhpbiB0aGUgY2x1c3Rlci5cbiAgICAgIHZhciBuZGltID0gb3B0cy5hdHRyaWJ1dGVzLmxlbmd0aDtcbiAgICAgIHZhciBjZW50cm9pZCA9IGNlbnRyb2lkc1tjXTsgLy8gWyBkaW1fMSwgZGltXzIsIGRpbV8zLCAuLi4gLCBkaW1fbiBdXG4gICAgICB2YXIgbmV3Q2VudHJvaWQgPSBuZXcgQXJyYXkobmRpbSk7XG4gICAgICB2YXIgc3VtID0gbmV3IEFycmF5KG5kaW0pO1xuICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBuZGltOyBkKyspIHtcbiAgICAgICAgc3VtW2RdID0gMC4wO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gY2x1c3RlcltpXTtcbiAgICAgICAgICBzdW1bZF0gKz0gb3B0cy5hdHRyaWJ1dGVzW2RdKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIG5ld0NlbnRyb2lkW2RdID0gc3VtW2RdIC8gY2x1c3Rlci5sZW5ndGg7XG5cbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIGFsZ29yaXRobSBoYXMgY29udmVyZ2VkLCBpLmUuIHdoZW4gY2VudHJvaWRzIG5vIGxvbmdlciBjaGFuZ2VcbiAgICAgICAgaWYgKCFoYXZlVmFsdWVzQ29udmVyZ2VkKG5ld0NlbnRyb2lkW2RdLCBjZW50cm9pZFtkXSwgb3B0cy5zZW5zaXRpdml0eVRocmVzaG9sZCkpIHtcbiAgICAgICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2VudHJvaWRzW2NdID0gbmV3Q2VudHJvaWQ7XG4gICAgICBjbHVzdGVyc1tjXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3Rlcik7XG4gICAgfVxuICAgIGl0ZXJhdGlvbnMrKztcbiAgfVxuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIGtNZWRvaWRzID0gZnVuY3Rpb24ga01lZG9pZHMob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIG5vZGUgPSBudWxsO1xuICB2YXIgb3B0cyA9IHNldE9wdGlvbnMkMihvcHRpb25zKTtcblxuICAvLyBCZWdpbiBrLW1lZG9pZHMgYWxnb3JpdGhtXG4gIHZhciBjbHVzdGVycyA9IG5ldyBBcnJheShvcHRzLmspO1xuICB2YXIgbWVkb2lkcztcbiAgdmFyIGFzc2lnbm1lbnQgPSB7fTtcbiAgdmFyIGN1ckNvc3Q7XG4gIHZhciBtaW5Db3N0cyA9IG5ldyBBcnJheShvcHRzLmspOyAvLyBtaW5pbXVtIGNvc3QgY29uZmlndXJhdGlvbiBmb3IgZWFjaCBjbHVzdGVyXG5cbiAgLy8gU3RlcCAxOiBJbml0aWFsaXplIGsgbWVkb2lkc1xuICBpZiAob3B0cy50ZXN0TW9kZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0cy50ZXN0Q2VudHJvaWRzID09PSAnbnVtYmVyJykgOyBlbHNlIGlmIChfdHlwZW9mKG9wdHMudGVzdENlbnRyb2lkcykgPT09ICdvYmplY3QnKSB7XG4gICAgICBtZWRvaWRzID0gb3B0cy50ZXN0Q2VudHJvaWRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZWRvaWRzID0gcmFuZG9tTWVkb2lkcyhub2Rlcywgb3B0cy5rKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbWVkb2lkcyA9IHJhbmRvbU1lZG9pZHMobm9kZXMsIG9wdHMuayk7XG4gIH1cbiAgdmFyIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gIHdoaWxlIChpc1N0aWxsTW92aW5nICYmIGl0ZXJhdGlvbnMgPCBvcHRzLm1heEl0ZXJhdGlvbnMpIHtcbiAgICAvLyBTdGVwIDI6IEFzc2lnbiBub2RlcyB0byB0aGUgbmVhcmVzdCBtZWRvaWRcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBub2RlID0gbm9kZXNbbl07XG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGlzIG5vZGUgYmVsb25ncyB0bzogbm9kZSBpZCA9PiBjbHVzdGVyICNcbiAgICAgIGFzc2lnbm1lbnRbbm9kZS5pZCgpXSA9IGNsYXNzaWZ5KG5vZGUsIG1lZG9pZHMsIG9wdHMuZGlzdGFuY2UsIG9wdHMuYXR0cmlidXRlcywgJ2tNZWRvaWRzJyk7XG4gICAgfVxuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTtcbiAgICAvLyBTdGVwIDM6IEZvciBlYWNoIG1lZG9pZCBtLCBhbmQgZm9yIGVhY2ggbm9kZSBhc3NvY2lhdGVkIHdpdGggbWVkaW9kIG0sXG4gICAgLy8gc2VsZWN0IHRoZSBub2RlIHdpdGggdGhlIGxvd2VzdCBjb25maWd1cmF0aW9uIGNvc3QgYXMgbmV3IG1lZG9pZC5cbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IG1lZG9pZHMubGVuZ3RoOyBtKyspIHtcbiAgICAgIC8vIEdldCBhbGwgbm9kZXMgdGhhdCBiZWxvbmcgdG8gdGhpcyBtZWRvaWRcbiAgICAgIHZhciBjbHVzdGVyID0gYnVpbGRDbHVzdGVyKG0sIG5vZGVzLCBhc3NpZ25tZW50KTtcbiAgICAgIGlmIChjbHVzdGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBJZiBjbHVzdGVyIGlzIGVtcHR5LCBicmVhayBvdXQgZWFybHkgJiBtb3ZlIHRvIG5leHQgY2x1c3RlclxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1pbkNvc3RzW21dID0gZmluZENvc3QobWVkb2lkc1ttXSwgY2x1c3Rlciwgb3B0cy5hdHRyaWJ1dGVzKTsgLy8gb3JpZ2luYWwgY29zdFxuXG4gICAgICAvLyBTZWxlY3QgZGlmZmVyZW50IG1lZG9pZCBpZiBpdHMgY29uZmlndXJhdGlvbiBoYXMgdGhlIGxvd2VzdCBjb3N0XG4gICAgICBmb3IgKHZhciBfbiA9IDA7IF9uIDwgY2x1c3Rlci5sZW5ndGg7IF9uKyspIHtcbiAgICAgICAgY3VyQ29zdCA9IGZpbmRDb3N0KGNsdXN0ZXJbX25dLCBjbHVzdGVyLCBvcHRzLmF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAoY3VyQ29zdCA8IG1pbkNvc3RzW21dKSB7XG4gICAgICAgICAgbWluQ29zdHNbbV0gPSBjdXJDb3N0O1xuICAgICAgICAgIG1lZG9pZHNbbV0gPSBjbHVzdGVyW19uXTtcbiAgICAgICAgICBpc1N0aWxsTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2x1c3RlcnNbbV0gPSBjeS5jb2xsZWN0aW9uKGNsdXN0ZXIpO1xuICAgIH1cbiAgICBpdGVyYXRpb25zKys7XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcbnZhciB1cGRhdGVDZW50cm9pZHMgPSBmdW5jdGlvbiB1cGRhdGVDZW50cm9pZHMoY2VudHJvaWRzLCBub2RlcywgVSwgd2VpZ2h0LCBvcHRzKSB7XG4gIHZhciBudW1lcmF0b3IsIGRlbm9taW5hdG9yO1xuICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjZW50cm9pZHMubGVuZ3RoOyBjKyspIHtcbiAgICAgIHdlaWdodFtuXVtjXSA9IE1hdGgucG93KFVbbl1bY10sIG9wdHMubSk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIF9jID0gMDsgX2MgPCBjZW50cm9pZHMubGVuZ3RoOyBfYysrKSB7XG4gICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgb3B0cy5hdHRyaWJ1dGVzLmxlbmd0aDsgZGltKyspIHtcbiAgICAgIG51bWVyYXRvciA9IDA7XG4gICAgICBkZW5vbWluYXRvciA9IDA7XG4gICAgICBmb3IgKHZhciBfbjIgPSAwOyBfbjIgPCBub2Rlcy5sZW5ndGg7IF9uMisrKSB7XG4gICAgICAgIG51bWVyYXRvciArPSB3ZWlnaHRbX24yXVtfY10gKiBvcHRzLmF0dHJpYnV0ZXNbZGltXShub2Rlc1tfbjJdKTtcbiAgICAgICAgZGVub21pbmF0b3IgKz0gd2VpZ2h0W19uMl1bX2NdO1xuICAgICAgfVxuICAgICAgY2VudHJvaWRzW19jXVtkaW1dID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgfVxuICB9XG59O1xudmFyIHVwZGF0ZU1lbWJlcnNoaXAgPSBmdW5jdGlvbiB1cGRhdGVNZW1iZXJzaGlwKFUsIF9VLCBjZW50cm9pZHMsIG5vZGVzLCBvcHRzKSB7XG4gIC8vIFNhdmUgcHJldmlvdXMgc3RlcFxuICBmb3IgKHZhciBpID0gMDsgaSA8IFUubGVuZ3RoOyBpKyspIHtcbiAgICBfVVtpXSA9IFVbaV0uc2xpY2UoKTtcbiAgfVxuICB2YXIgc3VtLCBudW1lcmF0b3IsIGRlbm9taW5hdG9yO1xuICB2YXIgcG93ID0gMiAvIChvcHRzLm0gLSAxKTtcbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBjZW50cm9pZHMubGVuZ3RoOyBjKyspIHtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IG5vZGVzLmxlbmd0aDsgbisrKSB7XG4gICAgICBzdW0gPSAwO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjZW50cm9pZHMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgLy8gYWdhaW5zdCBhbGwgb3RoZXIgY2VudHJvaWRzXG4gICAgICAgIG51bWVyYXRvciA9IGdldERpc3Qob3B0cy5kaXN0YW5jZSwgbm9kZXNbbl0sIGNlbnRyb2lkc1tjXSwgb3B0cy5hdHRyaWJ1dGVzLCAnY21lYW5zJyk7XG4gICAgICAgIGRlbm9taW5hdG9yID0gZ2V0RGlzdChvcHRzLmRpc3RhbmNlLCBub2Rlc1tuXSwgY2VudHJvaWRzW2tdLCBvcHRzLmF0dHJpYnV0ZXMsICdjbWVhbnMnKTtcbiAgICAgICAgc3VtICs9IE1hdGgucG93KG51bWVyYXRvciAvIGRlbm9taW5hdG9yLCBwb3cpO1xuICAgICAgfVxuICAgICAgVVtuXVtjXSA9IDEgLyBzdW07XG4gICAgfVxuICB9XG59O1xudmFyIGFzc2lnbiQxID0gZnVuY3Rpb24gYXNzaWduKG5vZGVzLCBVLCBvcHRzLCBjeSkge1xuICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgZm9yICh2YXIgYyA9IDA7IGMgPCBjbHVzdGVycy5sZW5ndGg7IGMrKykge1xuICAgIGNsdXN0ZXJzW2NdID0gW107XG4gIH1cbiAgdmFyIG1heDtcbiAgdmFyIGluZGV4O1xuICBmb3IgKHZhciBuID0gMDsgbiA8IFUubGVuZ3RoOyBuKyspIHtcbiAgICAvLyBmb3IgZWFjaCBub2RlIChVIGlzIE4geCBDIG1hdHJpeClcbiAgICBtYXggPSAtSW5maW5pdHk7XG4gICAgaW5kZXggPSAtMTtcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggY2x1c3RlciB0aGUgbm9kZSBpcyBtb3N0IGxpa2VseSB0byBiZWxvbmcgaW5cbiAgICBmb3IgKHZhciBfYzIgPSAwOyBfYzIgPCBVWzBdLmxlbmd0aDsgX2MyKyspIHtcbiAgICAgIGlmIChVW25dW19jMl0gPiBtYXgpIHtcbiAgICAgICAgbWF4ID0gVVtuXVtfYzJdO1xuICAgICAgICBpbmRleCA9IF9jMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY2x1c3RlcnNbaW5kZXhdLnB1c2gobm9kZXNbbl0pO1xuICB9XG5cbiAgLy8gVHVybiBldmVyeSBhcnJheSBpbnRvIGEgY29sbGVjdGlvbiBvZiBub2Rlc1xuICBmb3IgKHZhciBfYzMgPSAwOyBfYzMgPCBjbHVzdGVycy5sZW5ndGg7IF9jMysrKSB7XG4gICAgY2x1c3RlcnNbX2MzXSA9IGN5LmNvbGxlY3Rpb24oY2x1c3RlcnNbX2MzXSk7XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcbnZhciBmdXp6eUNNZWFucyA9IGZ1bmN0aW9uIGZ1enp5Q01lYW5zKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyQyKG9wdGlvbnMpO1xuXG4gIC8vIEJlZ2luIGZ1enp5IGMtbWVhbnMgYWxnb3JpdGhtXG4gIHZhciBjbHVzdGVycztcbiAgdmFyIGNlbnRyb2lkcztcbiAgdmFyIFU7XG4gIHZhciBfVTtcbiAgdmFyIHdlaWdodDtcblxuICAvLyBTdGVwIDE6IEluaXRpYWxpemUgbGV0aWFibGVzLlxuICBfVSA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTiB4IEMgbWF0cml4XG4gICAgX1VbaV0gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgfVxuICBVID0gbmV3IEFycmF5KG5vZGVzLmxlbmd0aCk7XG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAvLyBOIHggQyBtYXRyaXhcbiAgICBVW19pM10gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgfVxuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2Rlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9wdHMuazsgaisrKSB7XG4gICAgICBVW19pNF1bal0gPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgdG90YWwgKz0gVVtfaTRdW2pdO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgb3B0cy5rOyBfaisrKSB7XG4gICAgICBVW19pNF1bX2pdID0gVVtfaTRdW19qXSAvIHRvdGFsO1xuICAgIH1cbiAgfVxuICBjZW50cm9pZHMgPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgb3B0cy5rOyBfaTUrKykge1xuICAgIGNlbnRyb2lkc1tfaTVdID0gbmV3IEFycmF5KG9wdHMuYXR0cmlidXRlcy5sZW5ndGgpO1xuICB9XG4gIHdlaWdodCA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpO1xuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBub2Rlcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgLy8gTiB4IEMgbWF0cml4XG4gICAgd2VpZ2h0W19pNl0gPSBuZXcgQXJyYXkob3B0cy5rKTtcbiAgfVxuICAvLyBlbmQgaW5pdCBGQ01cblxuICB2YXIgaXNTdGlsbE1vdmluZyA9IHRydWU7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgd2hpbGUgKGlzU3RpbGxNb3ZpbmcgJiYgaXRlcmF0aW9ucyA8IG9wdHMubWF4SXRlcmF0aW9ucykge1xuICAgIGlzU3RpbGxNb3ZpbmcgPSBmYWxzZTtcblxuICAgIC8vIFN0ZXAgMjogQ2FsY3VsYXRlIHRoZSBjZW50cm9pZHMgZm9yIGVhY2ggc3RlcC5cbiAgICB1cGRhdGVDZW50cm9pZHMoY2VudHJvaWRzLCBub2RlcywgVSwgd2VpZ2h0LCBvcHRzKTtcblxuICAgIC8vIFN0ZXAgMzogVXBkYXRlIHRoZSBwYXJ0aXRpb24gbWF0cml4IFUuXG4gICAgdXBkYXRlTWVtYmVyc2hpcChVLCBfVSwgY2VudHJvaWRzLCBub2Rlcywgb3B0cyk7XG5cbiAgICAvLyBTdGVwIDQ6IENoZWNrIGZvciBjb252ZXJnZW5jZS5cbiAgICBpZiAoIWhhdmVNYXRyaWNlc0NvbnZlcmdlZChVLCBfVSwgb3B0cy5zZW5zaXRpdml0eVRocmVzaG9sZCkpIHtcbiAgICAgIGlzU3RpbGxNb3ZpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBpdGVyYXRpb25zKys7XG4gIH1cblxuICAvLyBBc3NpZ24gbm9kZXMgdG8gY2x1c3RlcnMgd2l0aCBoaWdoZXN0IHByb2JhYmlsaXR5LlxuICBjbHVzdGVycyA9IGFzc2lnbiQxKG5vZGVzLCBVLCBvcHRzLCBjeSk7XG4gIHJldHVybiB7XG4gICAgY2x1c3RlcnM6IGNsdXN0ZXJzLFxuICAgIGRlZ3JlZU9mTWVtYmVyc2hpcDogVVxuICB9O1xufTtcbnZhciBrQ2x1c3RlcmluZyA9IHtcbiAga01lYW5zOiBrTWVhbnMsXG4gIGtNZWRvaWRzOiBrTWVkb2lkcyxcbiAgZnV6enlDTWVhbnM6IGZ1enp5Q01lYW5zLFxuICBmY206IGZ1enp5Q01lYW5zXG59O1xuXG4vLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXRvc2NhcGUvY3l0b3NjYXBlLmpzLWhpZXJhcmNoaWNhbFxuXG52YXIgZGVmYXVsdHMkYSA9IGRlZmF1bHRzJGcoe1xuICBkaXN0YW5jZTogJ2V1Y2xpZGVhbicsXG4gIC8vIGRpc3RhbmNlIG1ldHJpYyB0byBjb21wYXJlIG5vZGVzXG4gIGxpbmthZ2U6ICdtaW4nLFxuICAvLyBsaW5rYWdlIGNyaXRlcmlvbiA6IGhvdyB0byBkZXRlcm1pbmUgdGhlIGRpc3RhbmNlIGJldHdlZW4gY2x1c3RlcnMgb2Ygbm9kZXNcbiAgbW9kZTogJ3RocmVzaG9sZCcsXG4gIC8vIG1vZGU6J3RocmVzaG9sZCcgPT4gY2x1c3RlcnMgbXVzdCBiZSB0aHJlc2hvbGQgZGlzdGFuY2UgYXBhcnRcbiAgdGhyZXNob2xkOiBJbmZpbml0eSxcbiAgLy8gdGhlIGRpc3RhbmNlIHRocmVzaG9sZFxuICAvLyBtb2RlOidkZW5kcm9ncmFtJyA9PiB0aGUgbm9kZXMgYXJlIG9yZ2FuaXNlZCBhcyBsZWF2ZXMgaW4gYSB0cmVlIChzaWJsaW5ncyBhcmUgY2xvc2UpLCBtZXJnaW5nIG1ha2VzIGNsdXN0ZXJzXG4gIGFkZERlbmRyb2dyYW06IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIGFkZCB0aGUgZGVuZHJvZ3JhbSB0byB0aGUgZ3JhcGggZm9yIHZpelxuICBkZW5kcm9ncmFtRGVwdGg6IDAsXG4gIC8vIGRlcHRoIGF0IHdoaWNoIGRlbmRyb2dyYW0gYnJhbmNoZXMgYXJlIG1lcmdlZCBpbnRvIHRoZSByZXR1cm5lZCBjbHVzdGVyc1xuICBhdHRyaWJ1dGVzOiBbXSAvLyBhcnJheSBvZiBhdHRyIGZ1bmN0aW9uc1xufSk7XG52YXIgbGlua2FnZUFsaWFzZXMgPSB7XG4gICdzaW5nbGUnOiAnbWluJyxcbiAgJ2NvbXBsZXRlJzogJ21heCdcbn07XG52YXIgc2V0T3B0aW9ucyQxID0gZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIHZhciBvcHRzID0gZGVmYXVsdHMkYShvcHRpb25zKTtcbiAgdmFyIHByZWZlcnJlZEFsaWFzID0gbGlua2FnZUFsaWFzZXNbb3B0cy5saW5rYWdlXTtcbiAgaWYgKHByZWZlcnJlZEFsaWFzICE9IG51bGwpIHtcbiAgICBvcHRzLmxpbmthZ2UgPSBwcmVmZXJyZWRBbGlhcztcbiAgfVxuICByZXR1cm4gb3B0cztcbn07XG52YXIgbWVyZ2VDbG9zZXN0ID0gZnVuY3Rpb24gbWVyZ2VDbG9zZXN0KGNsdXN0ZXJzLCBpbmRleCwgZGlzdHMsIG1pbnMsIG9wdHMpIHtcbiAgLy8gRmluZCB0d28gY2xvc2VzdCBjbHVzdGVycyBmcm9tIGNhY2hlZCBtaW5zXG4gIHZhciBtaW5LZXkgPSAwO1xuICB2YXIgbWluID0gSW5maW5pdHk7XG4gIHZhciBkaXN0O1xuICB2YXIgYXR0cnMgPSBvcHRzLmF0dHJpYnV0ZXM7XG4gIHZhciBnZXREaXN0ID0gZnVuY3Rpb24gZ2V0RGlzdChuMSwgbjIpIHtcbiAgICByZXR1cm4gY2x1c3RlcmluZ0Rpc3RhbmNlKG9wdHMuZGlzdGFuY2UsIGF0dHJzLmxlbmd0aCwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMSk7XG4gICAgfSwgZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBhdHRyc1tpXShuMik7XG4gICAgfSwgbjEsIG4yKTtcbiAgfTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBjbHVzdGVyc1tpXS5rZXk7XG4gICAgdmFyIF9kaXN0ID0gZGlzdHNba2V5XVttaW5zW2tleV1dO1xuICAgIGlmIChfZGlzdCA8IG1pbikge1xuICAgICAgbWluS2V5ID0ga2V5O1xuICAgICAgbWluID0gX2Rpc3Q7XG4gICAgfVxuICB9XG4gIGlmIChvcHRzLm1vZGUgPT09ICd0aHJlc2hvbGQnICYmIG1pbiA+PSBvcHRzLnRocmVzaG9sZCB8fCBvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJyAmJiBjbHVzdGVycy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGMxID0gaW5kZXhbbWluS2V5XTtcbiAgdmFyIGMyID0gaW5kZXhbbWluc1ttaW5LZXldXTtcbiAgdmFyIG1lcmdlZDtcblxuICAvLyBNZXJnZSB0d28gY2xvc2VzdCBjbHVzdGVyc1xuICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICBtZXJnZWQgPSB7XG4gICAgICBsZWZ0OiBjMSxcbiAgICAgIHJpZ2h0OiBjMixcbiAgICAgIGtleTogYzEua2V5XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtZXJnZWQgPSB7XG4gICAgICB2YWx1ZTogYzEudmFsdWUuY29uY2F0KGMyLnZhbHVlKSxcbiAgICAgIGtleTogYzEua2V5XG4gICAgfTtcbiAgfVxuICBjbHVzdGVyc1tjMS5pbmRleF0gPSBtZXJnZWQ7XG4gIGNsdXN0ZXJzLnNwbGljZShjMi5pbmRleCwgMSk7XG4gIGluZGV4W2MxLmtleV0gPSBtZXJnZWQ7XG5cbiAgLy8gVXBkYXRlIGRpc3RhbmNlcyB3aXRoIG5ldyBtZXJnZWQgY2x1c3RlclxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY2x1c3RlcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIGN1ciA9IGNsdXN0ZXJzW19pXTtcbiAgICBpZiAoYzEua2V5ID09PSBjdXIua2V5KSB7XG4gICAgICBkaXN0ID0gSW5maW5pdHk7XG4gICAgfSBlbHNlIGlmIChvcHRzLmxpbmthZ2UgPT09ICdtaW4nKSB7XG4gICAgICBkaXN0ID0gZGlzdHNbYzEua2V5XVtjdXIua2V5XTtcbiAgICAgIGlmIChkaXN0c1tjMS5rZXldW2N1ci5rZXldID4gZGlzdHNbYzIua2V5XVtjdXIua2V5XSkge1xuICAgICAgICBkaXN0ID0gZGlzdHNbYzIua2V5XVtjdXIua2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdHMubGlua2FnZSA9PT0gJ21heCcpIHtcbiAgICAgIGRpc3QgPSBkaXN0c1tjMS5rZXldW2N1ci5rZXldO1xuICAgICAgaWYgKGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPCBkaXN0c1tjMi5rZXldW2N1ci5rZXldKSB7XG4gICAgICAgIGRpc3QgPSBkaXN0c1tjMi5rZXldW2N1ci5rZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0cy5saW5rYWdlID09PSAnbWVhbicpIHtcbiAgICAgIGRpc3QgPSAoZGlzdHNbYzEua2V5XVtjdXIua2V5XSAqIGMxLnNpemUgKyBkaXN0c1tjMi5rZXldW2N1ci5rZXldICogYzIuc2l6ZSkgLyAoYzEuc2l6ZSArIGMyLnNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIGRpc3QgPSBnZXREaXN0KGN1ci52YWx1ZSwgYzEudmFsdWUpO2Vsc2UgZGlzdCA9IGdldERpc3QoY3VyLnZhbHVlWzBdLCBjMS52YWx1ZVswXSk7XG4gICAgfVxuICAgIGRpc3RzW2MxLmtleV1bY3VyLmtleV0gPSBkaXN0c1tjdXIua2V5XVtjMS5rZXldID0gZGlzdDsgLy8gZGlzdGFuY2UgbWF0cml4IGlzIHN5bW1ldHJpY1xuICB9XG5cbiAgLy8gVXBkYXRlIGNhY2hlZCBtaW5zXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNsdXN0ZXJzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIga2V5MSA9IGNsdXN0ZXJzW19pMl0ua2V5O1xuICAgIGlmIChtaW5zW2tleTFdID09PSBjMS5rZXkgfHwgbWluc1trZXkxXSA9PT0gYzIua2V5KSB7XG4gICAgICB2YXIgX21pbiA9IGtleTE7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNsdXN0ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBrZXkyID0gY2x1c3RlcnNbal0ua2V5O1xuICAgICAgICBpZiAoZGlzdHNba2V5MV1ba2V5Ml0gPCBkaXN0c1trZXkxXVtfbWluXSkge1xuICAgICAgICAgIF9taW4gPSBrZXkyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtaW5zW2tleTFdID0gX21pbjtcbiAgICB9XG4gICAgY2x1c3RlcnNbX2kyXS5pbmRleCA9IF9pMjtcbiAgfVxuXG4gIC8vIENsZWFuIHVwIG1ldGEgZGF0YSB1c2VkIGZvciBjbHVzdGVyaW5nXG4gIGMxLmtleSA9IGMyLmtleSA9IGMxLmluZGV4ID0gYzIuaW5kZXggPSBudWxsO1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgX2dldEFsbENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0QWxsQ2hpbGRyZW4ocm9vdCwgYXJyLCBjeSkge1xuICBpZiAoIXJvb3QpIHJldHVybjtcbiAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICBhcnIucHVzaChyb290LnZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocm9vdC5sZWZ0KSBfZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBhcnIpO1xuICAgIGlmIChyb290LnJpZ2h0KSBfZ2V0QWxsQ2hpbGRyZW4ocm9vdC5yaWdodCwgYXJyKTtcbiAgfVxufTtcbnZhciBfYnVpbGREZW5kcm9ncmFtID0gZnVuY3Rpb24gYnVpbGREZW5kcm9ncmFtKHJvb3QsIGN5KSB7XG4gIGlmICghcm9vdCkgcmV0dXJuICcnO1xuICBpZiAocm9vdC5sZWZ0ICYmIHJvb3QucmlnaHQpIHtcbiAgICB2YXIgbGVmdFN0ciA9IF9idWlsZERlbmRyb2dyYW0ocm9vdC5sZWZ0LCBjeSk7XG4gICAgdmFyIHJpZ2h0U3RyID0gX2J1aWxkRGVuZHJvZ3JhbShyb290LnJpZ2h0LCBjeSk7XG4gICAgdmFyIG5vZGUgPSBjeS5hZGQoe1xuICAgICAgZ3JvdXA6ICdub2RlcycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBsZWZ0U3RyICsgJywnICsgcmlnaHRTdHJcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6ICdlZGdlcycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNvdXJjZTogbGVmdFN0cixcbiAgICAgICAgdGFyZ2V0OiBub2RlLmlkKClcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6ICdlZGdlcycsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNvdXJjZTogcmlnaHRTdHIsXG4gICAgICAgIHRhcmdldDogbm9kZS5pZCgpXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGUuaWQoKTtcbiAgfSBlbHNlIGlmIChyb290LnZhbHVlKSB7XG4gICAgcmV0dXJuIHJvb3QudmFsdWUuaWQoKTtcbiAgfVxufTtcbnZhciBfYnVpbGRDbHVzdGVyc0Zyb21UcmVlID0gZnVuY3Rpb24gYnVpbGRDbHVzdGVyc0Zyb21UcmVlKHJvb3QsIGssIGN5KSB7XG4gIGlmICghcm9vdCkgcmV0dXJuIFtdO1xuICB2YXIgbGVmdCA9IFtdLFxuICAgIHJpZ2h0ID0gW10sXG4gICAgbGVhdmVzID0gW107XG4gIGlmIChrID09PSAwKSB7XG4gICAgLy8gZG9uJ3QgY3V0IHRyZWUsIHNpbXBseSByZXR1cm4gYWxsIG5vZGVzIGFzIDEgc2luZ2xlIGNsdXN0ZXJcbiAgICBpZiAocm9vdC5sZWZ0KSBfZ2V0QWxsQ2hpbGRyZW4ocm9vdC5sZWZ0LCBsZWZ0KTtcbiAgICBpZiAocm9vdC5yaWdodCkgX2dldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIHJpZ2h0KTtcbiAgICBsZWF2ZXMgPSBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKGxlYXZlcyldO1xuICB9IGVsc2UgaWYgKGsgPT09IDEpIHtcbiAgICAvLyBjdXQgYXQgcm9vdFxuXG4gICAgaWYgKHJvb3QudmFsdWUpIHtcbiAgICAgIC8vIGxlYWYgbm9kZVxuICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKHJvb3QudmFsdWUpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJvb3QubGVmdCkgX2dldEFsbENoaWxkcmVuKHJvb3QubGVmdCwgbGVmdCk7XG4gICAgICBpZiAocm9vdC5yaWdodCkgX2dldEFsbENoaWxkcmVuKHJvb3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgIHJldHVybiBbY3kuY29sbGVjdGlvbihsZWZ0KSwgY3kuY29sbGVjdGlvbihyaWdodCldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgcmV0dXJuIFtjeS5jb2xsZWN0aW9uKHJvb3QudmFsdWUpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJvb3QubGVmdCkgbGVmdCA9IF9idWlsZENsdXN0ZXJzRnJvbVRyZWUocm9vdC5sZWZ0LCBrIC0gMSwgY3kpO1xuICAgICAgaWYgKHJvb3QucmlnaHQpIHJpZ2h0ID0gX2J1aWxkQ2x1c3RlcnNGcm9tVHJlZShyb290LnJpZ2h0LCBrIC0gMSwgY3kpO1xuICAgICAgcmV0dXJuIGxlZnQuY29uY2F0KHJpZ2h0KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBoaWVyYXJjaGljYWxDbHVzdGVyaW5nID0gZnVuY3Rpb24gaGllcmFyY2hpY2FsQ2x1c3RlcmluZyhvcHRpb25zKSB7XG4gIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gIC8vIFNldCBwYXJhbWV0ZXJzIG9mIGFsZ29yaXRobTogbGlua2FnZSB0eXBlLCBkaXN0YW5jZSBtZXRyaWMsIGV0Yy5cbiAgdmFyIG9wdHMgPSBzZXRPcHRpb25zJDEob3B0aW9ucyk7XG4gIHZhciBhdHRycyA9IG9wdHMuYXR0cmlidXRlcztcbiAgdmFyIGdldERpc3QgPSBmdW5jdGlvbiBnZXREaXN0KG4xLCBuMikge1xuICAgIHJldHVybiBjbHVzdGVyaW5nRGlzdGFuY2Uob3B0cy5kaXN0YW5jZSwgYXR0cnMubGVuZ3RoLCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHJzW2ldKG4xKTtcbiAgICB9LCBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGF0dHJzW2ldKG4yKTtcbiAgICB9LCBuMSwgbjIpO1xuICB9O1xuXG4gIC8vIEJlZ2luIGhpZXJhcmNoaWNhbCBhbGdvcml0aG1cbiAgdmFyIGNsdXN0ZXJzID0gW107XG4gIHZhciBkaXN0cyA9IFtdOyAvLyBkaXN0YW5jZXMgYmV0d2VlbiBlYWNoIHBhaXIgb2YgY2x1c3RlcnNcbiAgdmFyIG1pbnMgPSBbXTsgLy8gY2xvc2VzdCBjbHVzdGVyIGZvciBlYWNoIGNsdXN0ZXJcbiAgdmFyIGluZGV4ID0gW107IC8vIGhhc2ggb2YgYWxsIGNsdXN0ZXJzIGJ5IGtleVxuXG4gIC8vIEluIGFnZ2xvbWVyYXRpdmUgKGJvdHRvbS11cCkgY2x1c3RlcmluZywgZWFjaCBub2RlIHN0YXJ0cyBhcyBpdHMgb3duIGNsdXN0ZXJcbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgIHZhciBjbHVzdGVyID0ge1xuICAgICAgdmFsdWU6IG9wdHMubW9kZSA9PT0gJ2RlbmRyb2dyYW0nID8gbm9kZXNbbl0gOiBbbm9kZXNbbl1dLFxuICAgICAga2V5OiBuLFxuICAgICAgaW5kZXg6IG5cbiAgICB9O1xuICAgIGNsdXN0ZXJzW25dID0gY2x1c3RlcjtcbiAgICBpbmRleFtuXSA9IGNsdXN0ZXI7XG4gICAgZGlzdHNbbl0gPSBbXTtcbiAgICBtaW5zW25dID0gMDtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBlYWNoIHBhaXIgb2YgY2x1c3RlcnNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDw9IGk7IGorKykge1xuICAgICAgdmFyIGRpc3QgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAob3B0cy5tb2RlID09PSAnZGVuZHJvZ3JhbScpIHtcbiAgICAgICAgLy8gbW9kZXMgc3RvcmUgY2x1c3RlciB2YWx1ZXMgZGlmZmVyZW50bHlcbiAgICAgICAgZGlzdCA9IGkgPT09IGogPyBJbmZpbml0eSA6IGdldERpc3QoY2x1c3RlcnNbaV0udmFsdWUsIGNsdXN0ZXJzW2pdLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3QgPSBpID09PSBqID8gSW5maW5pdHkgOiBnZXREaXN0KGNsdXN0ZXJzW2ldLnZhbHVlWzBdLCBjbHVzdGVyc1tqXS52YWx1ZVswXSk7XG4gICAgICB9XG4gICAgICBkaXN0c1tpXVtqXSA9IGRpc3Q7XG4gICAgICBkaXN0c1tqXVtpXSA9IGRpc3Q7XG4gICAgICBpZiAoZGlzdCA8IGRpc3RzW2ldW21pbnNbaV1dKSB7XG4gICAgICAgIG1pbnNbaV0gPSBqOyAvLyBDYWNoZSBtaW5zOiBjbG9zZXN0IGNsdXN0ZXIgdG8gY2x1c3RlciBpIGlzIGNsdXN0ZXIgalxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGNsb3Nlc3QgcGFpciBvZiBjbHVzdGVycyBhbmQgbWVyZ2UgdGhlbSBpbnRvIGEgc2luZ2xlIGNsdXN0ZXIuXG4gIC8vIFVwZGF0ZSBkaXN0YW5jZXMgYmV0d2VlbiBuZXcgY2x1c3RlciBhbmQgZWFjaCBvZiB0aGUgb2xkIGNsdXN0ZXJzLCBhbmQgbG9vcCB1bnRpbCB0aHJlc2hvbGQgcmVhY2hlZC5cbiAgdmFyIG1lcmdlZCA9IG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKTtcbiAgd2hpbGUgKG1lcmdlZCkge1xuICAgIG1lcmdlZCA9IG1lcmdlQ2xvc2VzdChjbHVzdGVycywgaW5kZXgsIGRpc3RzLCBtaW5zLCBvcHRzKTtcbiAgfVxuICB2YXIgcmV0Q2x1c3RlcnM7XG5cbiAgLy8gRGVuZHJvZ3JhbSBtb2RlIGJ1aWxkcyB0aGUgaGllcmFyY2h5IGFuZCBhZGRzIGludGVybWVkaWFyeSBub2RlcyArIGVkZ2VzXG4gIC8vIGluIGFkZGl0aW9uIHRvIHJldHVybmluZyB0aGUgY2x1c3RlcnMuXG4gIGlmIChvcHRzLm1vZGUgPT09ICdkZW5kcm9ncmFtJykge1xuICAgIHJldENsdXN0ZXJzID0gX2J1aWxkQ2x1c3RlcnNGcm9tVHJlZShjbHVzdGVyc1swXSwgb3B0cy5kZW5kcm9ncmFtRGVwdGgsIGN5KTtcbiAgICBpZiAob3B0cy5hZGREZW5kcm9ncmFtKSBfYnVpbGREZW5kcm9ncmFtKGNsdXN0ZXJzWzBdLCBjeSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVndWxhciBtb2RlIHNpbXBseSByZXR1cm5zIHRoZSBjbHVzdGVyc1xuXG4gICAgcmV0Q2x1c3RlcnMgPSBuZXcgQXJyYXkoY2x1c3RlcnMubGVuZ3RoKTtcbiAgICBjbHVzdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjbHVzdGVyLCBpKSB7XG4gICAgICAvLyBDbGVhbiB1cCBtZXRhIGRhdGEgdXNlZCBmb3IgY2x1c3RlcmluZ1xuICAgICAgY2x1c3Rlci5rZXkgPSBjbHVzdGVyLmluZGV4ID0gbnVsbDtcbiAgICAgIHJldENsdXN0ZXJzW2ldID0gY3kuY29sbGVjdGlvbihjbHVzdGVyLnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmV0Q2x1c3RlcnM7XG59O1xudmFyIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSA9IHtcbiAgaGllcmFyY2hpY2FsQ2x1c3RlcmluZzogaGllcmFyY2hpY2FsQ2x1c3RlcmluZyxcbiAgaGNhOiBoaWVyYXJjaGljYWxDbHVzdGVyaW5nXG59O1xuXG4vLyBJbXBsZW1lbnRlZCBieSBab2UgWGkgQHpvZXhpIGZvciBHU09DIDIwMTZcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXRvc2NhcGUvY3l0b3NjYXBlLmpzLWFmZmluaXR5LXByb3BhZ2F0aW9uXG5cbnZhciBkZWZhdWx0cyQ5ID0gZGVmYXVsdHMkZyh7XG4gIGRpc3RhbmNlOiAnZXVjbGlkZWFuJyxcbiAgLy8gZGlzdGFuY2UgbWV0cmljIHRvIGNvbXBhcmUgYXR0cmlidXRlcyBiZXR3ZWVuIHR3byBub2Rlc1xuICBwcmVmZXJlbmNlOiAnbWVkaWFuJyxcbiAgLy8gc3VpdGFiaWxpdHkgb2YgYSBkYXRhIHBvaW50IHRvIHNlcnZlIGFzIGFuIGV4ZW1wbGFyXG4gIGRhbXBpbmc6IDAuOCxcbiAgLy8gZGFtcGluZyBmYWN0b3IgYmV0d2VlbiBbMC41LCAxKVxuICBtYXhJdGVyYXRpb25zOiAxMDAwLFxuICAvLyBtYXggbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcnVuXG4gIG1pbkl0ZXJhdGlvbnM6IDEwMCxcbiAgLy8gbWluIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHJ1biBpbiBvcmRlciBmb3IgY2x1c3RlcmluZyB0byBzdG9wXG4gIGF0dHJpYnV0ZXM6IFsvLyBmdW5jdGlvbnMgdG8gcXVhbnRpZnkgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiBhbnkgdHdvIHBvaW50c1xuICAgIC8vIGUuZy4gbm9kZSA9PiBub2RlLmRhdGEoJ3dlaWdodCcpXG4gIF1cbn0pO1xudmFyIHNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIGRtcCA9IG9wdGlvbnMuZGFtcGluZztcbiAgdmFyIHByZWYgPSBvcHRpb25zLnByZWZlcmVuY2U7XG4gIGlmICghKDAuNSA8PSBkbXAgJiYgZG1wIDwgMSkpIHtcbiAgICBlcnJvcihcIkRhbXBpbmcgbXVzdCByYW5nZSBvbiBbMC41LCAxKS4gIEdvdDogXCIuY29uY2F0KGRtcCkpO1xuICB9XG4gIHZhciB2YWxpZFByZWZzID0gWydtZWRpYW4nLCAnbWVhbicsICdtaW4nLCAnbWF4J107XG4gIGlmICghKHZhbGlkUHJlZnMuc29tZShmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB2ID09PSBwcmVmO1xuICB9KSB8fCBudW1iZXIkMShwcmVmKSkpIHtcbiAgICBlcnJvcihcIlByZWZlcmVuY2UgbXVzdCBiZSBvbmUgb2YgW1wiLmNvbmNhdCh2YWxpZFByZWZzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIFwiJ1wiLmNvbmNhdChwLCBcIidcIik7XG4gICAgfSkuam9pbignLCAnKSwgXCJdIG9yIGEgbnVtYmVyLiAgR290OiBcIikuY29uY2F0KHByZWYpKTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdHMkOShvcHRpb25zKTtcbn07XG5cbnZhciBnZXRTaW1pbGFyaXR5ID0gZnVuY3Rpb24gZ2V0U2ltaWxhcml0eSh0eXBlLCBuMSwgbjIsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGF0dHIgPSBmdW5jdGlvbiBhdHRyKG4sIGkpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlc1tpXShuKTtcbiAgfTtcblxuICAvLyBuYiBuZWdhdGl2ZSBiZWNhdXNlIHNpbWlsYXJpdHkgc2hvdWxkIGhhdmUgYW4gaW52ZXJzZSByZWxhdGlvbnNoaXAgdG8gZGlzdGFuY2VcbiAgcmV0dXJuIC1jbHVzdGVyaW5nRGlzdGFuY2UodHlwZSwgYXR0cmlidXRlcy5sZW5ndGgsIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGF0dHIobjEsIGkpO1xuICB9LCBmdW5jdGlvbiAoaSkge1xuICAgIHJldHVybiBhdHRyKG4yLCBpKTtcbiAgfSwgbjEsIG4yKTtcbn07XG52YXIgZ2V0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uIGdldFByZWZlcmVuY2UoUywgcHJlZmVyZW5jZSkge1xuICAvLyBsYXJnZXIgcHJlZmVyZW5jZSA9IGdyZWF0ZXIgIyBvZiBjbHVzdGVyc1xuICB2YXIgcCA9IG51bGw7XG4gIGlmIChwcmVmZXJlbmNlID09PSAnbWVkaWFuJykge1xuICAgIHAgPSBtZWRpYW4oUyk7XG4gIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21lYW4nKSB7XG4gICAgcCA9IG1lYW4oUyk7XG4gIH0gZWxzZSBpZiAocHJlZmVyZW5jZSA9PT0gJ21pbicpIHtcbiAgICBwID0gbWluKFMpO1xuICB9IGVsc2UgaWYgKHByZWZlcmVuY2UgPT09ICdtYXgnKSB7XG4gICAgcCA9IG1heChTKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDdXN0b20gcHJlZmVyZW5jZSBudW1iZXIsIGFzIHNldCBieSB1c2VyXG4gICAgcCA9IHByZWZlcmVuY2U7XG4gIH1cbiAgcmV0dXJuIHA7XG59O1xudmFyIGZpbmRFeGVtcGxhcnMgPSBmdW5jdGlvbiBmaW5kRXhlbXBsYXJzKG4sIFIsIEEpIHtcbiAgdmFyIGluZGljZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBpZiAoUltpICogbiArIGldICsgQVtpICogbiArIGldID4gMCkge1xuICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kaWNlcztcbn07XG52YXIgYXNzaWduQ2x1c3RlcnMgPSBmdW5jdGlvbiBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpIHtcbiAgdmFyIGNsdXN0ZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICBmb3IgKHZhciBlaSA9IDA7IGVpIDwgZXhlbXBsYXJzLmxlbmd0aDsgZWkrKykge1xuICAgICAgdmFyIGUgPSBleGVtcGxhcnNbZWldO1xuICAgICAgaWYgKFNbaSAqIG4gKyBlXSA+IG1heCkge1xuICAgICAgICBpbmRleCA9IGU7XG4gICAgICAgIG1heCA9IFNbaSAqIG4gKyBlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgY2x1c3RlcnMucHVzaChpbmRleCk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIF9laSA9IDA7IF9laSA8IGV4ZW1wbGFycy5sZW5ndGg7IF9laSsrKSB7XG4gICAgY2x1c3RlcnNbZXhlbXBsYXJzW19laV1dID0gZXhlbXBsYXJzW19laV07XG4gIH1cbiAgcmV0dXJuIGNsdXN0ZXJzO1xufTtcbnZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24obiwgUywgZXhlbXBsYXJzKSB7XG4gIHZhciBjbHVzdGVycyA9IGFzc2lnbkNsdXN0ZXJzKG4sIFMsIGV4ZW1wbGFycyk7XG4gIGZvciAodmFyIGVpID0gMDsgZWkgPCBleGVtcGxhcnMubGVuZ3RoOyBlaSsrKSB7XG4gICAgdmFyIGlpID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjbHVzdGVycy5sZW5ndGg7IGMrKykge1xuICAgICAgaWYgKGNsdXN0ZXJzW2NdID09PSBleGVtcGxhcnNbZWldKSB7XG4gICAgICAgIGlpLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBtYXhJID0gLTE7XG4gICAgdmFyIG1heFN1bSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlpLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3VtID0gMDtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaWkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3VtICs9IFNbaWlbal0gKiBuICsgaWlbaV1dO1xuICAgICAgfVxuICAgICAgaWYgKHN1bSA+IG1heFN1bSkge1xuICAgICAgICBtYXhJID0gaTtcbiAgICAgICAgbWF4U3VtID0gc3VtO1xuICAgICAgfVxuICAgIH1cbiAgICBleGVtcGxhcnNbZWldID0gaWlbbWF4SV07XG4gIH1cbiAgY2x1c3RlcnMgPSBhc3NpZ25DbHVzdGVycyhuLCBTLCBleGVtcGxhcnMpO1xuICByZXR1cm4gY2x1c3RlcnM7XG59O1xudmFyIGFmZmluaXR5UHJvcGFnYXRpb24gPSBmdW5jdGlvbiBhZmZpbml0eVByb3BhZ2F0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gIHZhciBvcHRzID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBNYXAgZWFjaCBub2RlIHRvIGl0cyBwb3NpdGlvbiBpbiBub2RlIGFycmF5XG4gIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICB9XG5cbiAgLy8gQmVnaW4gYWZmaW5pdHkgcHJvcGFnYXRpb24gYWxnb3JpdGhtXG5cbiAgdmFyIG47IC8vIG51bWJlciBvZiBkYXRhIHBvaW50c1xuICB2YXIgbjI7IC8vIHNpemUgb2YgbWF0cmljZXNcbiAgdmFyIFM7IC8vIHNpbWlsYXJpdHkgbWF0cml4ICgxRCBhcnJheSlcbiAgdmFyIHA7IC8vIHByZWZlcmVuY2Uvc3VpdGFiaWxpdHkgb2YgYSBkYXRhIHBvaW50IHRvIHNlcnZlIGFzIGFuIGV4ZW1wbGFyXG4gIHZhciBSOyAvLyByZXNwb25zaWJpbGl0eSBtYXRyaXggKDFEIGFycmF5KVxuICB2YXIgQTsgLy8gYXZhaWxhYmlsaXR5IG1hdHJpeCAoMUQgYXJyYXkpXG5cbiAgbiA9IG5vZGVzLmxlbmd0aDtcbiAgbjIgPSBuICogbjtcblxuICAvLyBJbml0aWFsaXplIGFuZCBidWlsZCBTIHNpbWlsYXJpdHkgbWF0cml4XG4gIFMgPSBuZXcgQXJyYXkobjIpO1xuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbjI7IF9pKyspIHtcbiAgICBTW19pXSA9IC1JbmZpbml0eTsgLy8gZm9yIGNhc2VzIHdoZXJlIHR3byBkYXRhIHBvaW50cyBzaG91bGRuJ3QgYmUgbGlua2VkIHRvZ2V0aGVyXG4gIH1cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbjsgX2kyKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgaWYgKF9pMiAhPT0gaikge1xuICAgICAgICBTW19pMiAqIG4gKyBqXSA9IGdldFNpbWlsYXJpdHkob3B0cy5kaXN0YW5jZSwgbm9kZXNbX2kyXSwgbm9kZXNbal0sIG9wdHMuYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUGxhY2UgcHJlZmVyZW5jZXMgb24gdGhlIGRpYWdvbmFsIG9mIFNcbiAgcCA9IGdldFByZWZlcmVuY2UoUywgb3B0cy5wcmVmZXJlbmNlKTtcbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbjsgX2kzKyspIHtcbiAgICBTW19pMyAqIG4gKyBfaTNdID0gcDtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgUiByZXNwb25zaWJpbGl0eSBtYXRyaXhcbiAgUiA9IG5ldyBBcnJheShuMik7XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG4yOyBfaTQrKykge1xuICAgIFJbX2k0XSA9IDAuMDtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgQSBhdmFpbGFiaWxpdHkgbWF0cml4XG4gIEEgPSBuZXcgQXJyYXkobjIpO1xuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBuMjsgX2k1KyspIHtcbiAgICBBW19pNV0gPSAwLjA7XG4gIH1cbiAgdmFyIG9sZCA9IG5ldyBBcnJheShuKTtcbiAgdmFyIFJwID0gbmV3IEFycmF5KG4pO1xuICB2YXIgc2UgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG47IF9pNisrKSB7XG4gICAgb2xkW19pNl0gPSAwLjA7XG4gICAgUnBbX2k2XSA9IDAuMDtcbiAgICBzZVtfaTZdID0gMDtcbiAgfVxuICB2YXIgZSA9IG5ldyBBcnJheShuICogb3B0cy5taW5JdGVyYXRpb25zKTtcbiAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgZS5sZW5ndGg7IF9pNysrKSB7XG4gICAgZVtfaTddID0gMDtcbiAgfVxuICB2YXIgaXRlcjtcbiAgZm9yIChpdGVyID0gMDsgaXRlciA8IG9wdHMubWF4SXRlcmF0aW9uczsgaXRlcisrKSB7XG4gICAgLy8gbWFpbiBhbGdvcml0aG1pYyBsb29wXG5cbiAgICAvLyBVcGRhdGUgUiByZXNwb25zaWJpbGl0eSBtYXRyaXhcbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBuOyBfaTgrKykge1xuICAgICAgdmFyIG1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgbWF4MiA9IC1JbmZpbml0eSxcbiAgICAgICAgbWF4SSA9IC0xLFxuICAgICAgICBBUyA9IDAuMDtcbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBuOyBfaisrKSB7XG4gICAgICAgIG9sZFtfal0gPSBSW19pOCAqIG4gKyBfal07XG4gICAgICAgIEFTID0gQVtfaTggKiBuICsgX2pdICsgU1tfaTggKiBuICsgX2pdO1xuICAgICAgICBpZiAoQVMgPj0gbWF4KSB7XG4gICAgICAgICAgbWF4MiA9IG1heDtcbiAgICAgICAgICBtYXggPSBBUztcbiAgICAgICAgICBtYXhJID0gX2o7XG4gICAgICAgIH0gZWxzZSBpZiAoQVMgPiBtYXgyKSB7XG4gICAgICAgICAgbWF4MiA9IEFTO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBuOyBfajIrKykge1xuICAgICAgICBSW19pOCAqIG4gKyBfajJdID0gKDEgLSBvcHRzLmRhbXBpbmcpICogKFNbX2k4ICogbiArIF9qMl0gLSBtYXgpICsgb3B0cy5kYW1waW5nICogb2xkW19qMl07XG4gICAgICB9XG4gICAgICBSW19pOCAqIG4gKyBtYXhJXSA9ICgxIC0gb3B0cy5kYW1waW5nKSAqIChTW19pOCAqIG4gKyBtYXhJXSAtIG1heDIpICsgb3B0cy5kYW1waW5nICogb2xkW21heEldO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBBIGF2YWlsYWJpbGl0eSBtYXRyaXhcbiAgICBmb3IgKHZhciBfaTkgPSAwOyBfaTkgPCBuOyBfaTkrKykge1xuICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICBmb3IgKHZhciBfajMgPSAwOyBfajMgPCBuOyBfajMrKykge1xuICAgICAgICBvbGRbX2ozXSA9IEFbX2ozICogbiArIF9pOV07XG4gICAgICAgIFJwW19qM10gPSBNYXRoLm1heCgwLCBSW19qMyAqIG4gKyBfaTldKTtcbiAgICAgICAgc3VtICs9IFJwW19qM107XG4gICAgICB9XG4gICAgICBzdW0gLT0gUnBbX2k5XTtcbiAgICAgIFJwW19pOV0gPSBSW19pOSAqIG4gKyBfaTldO1xuICAgICAgc3VtICs9IFJwW19pOV07XG4gICAgICBmb3IgKHZhciBfajQgPSAwOyBfajQgPCBuOyBfajQrKykge1xuICAgICAgICBBW19qNCAqIG4gKyBfaTldID0gKDEgLSBvcHRzLmRhbXBpbmcpICogTWF0aC5taW4oMCwgc3VtIC0gUnBbX2o0XSkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2o0XTtcbiAgICAgIH1cbiAgICAgIEFbX2k5ICogbiArIF9pOV0gPSAoMSAtIG9wdHMuZGFtcGluZykgKiAoc3VtIC0gUnBbX2k5XSkgKyBvcHRzLmRhbXBpbmcgKiBvbGRbX2k5XTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY29udmVyZ2VuY2VcbiAgICB2YXIgSyA9IDA7XG4gICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBuOyBfaTEwKyspIHtcbiAgICAgIHZhciBFID0gQVtfaTEwICogbiArIF9pMTBdICsgUltfaTEwICogbiArIF9pMTBdID4gMCA/IDEgOiAwO1xuICAgICAgZVtpdGVyICUgb3B0cy5taW5JdGVyYXRpb25zICogbiArIF9pMTBdID0gRTtcbiAgICAgIEsgKz0gRTtcbiAgICB9XG4gICAgaWYgKEsgPiAwICYmIChpdGVyID49IG9wdHMubWluSXRlcmF0aW9ucyAtIDEgfHwgaXRlciA9PSBvcHRzLm1heEl0ZXJhdGlvbnMgLSAxKSkge1xuICAgICAgdmFyIF9zdW0gPSAwO1xuICAgICAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCBuOyBfaTExKyspIHtcbiAgICAgICAgc2VbX2kxMV0gPSAwO1xuICAgICAgICBmb3IgKHZhciBfajUgPSAwOyBfajUgPCBvcHRzLm1pbkl0ZXJhdGlvbnM7IF9qNSsrKSB7XG4gICAgICAgICAgc2VbX2kxMV0gKz0gZVtfajUgKiBuICsgX2kxMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlW19pMTFdID09PSAwIHx8IHNlW19pMTFdID09PSBvcHRzLm1pbkl0ZXJhdGlvbnMpIHtcbiAgICAgICAgICBfc3VtKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChfc3VtID09PSBuKSB7XG4gICAgICAgIC8vIHRoZW4gd2UgaGF2ZSBjb252ZXJnZW5jZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZGVudGlmeSBleGVtcGxhcnMgKGNsdXN0ZXIgY2VudGVycylcbiAgdmFyIGV4ZW1wbGFyc0luZGljZXMgPSBmaW5kRXhlbXBsYXJzKG4sIFIsIEEpO1xuXG4gIC8vIEFzc2lnbiBub2RlcyB0byBjbHVzdGVyc1xuICB2YXIgY2x1c3RlckluZGljZXMgPSBhc3NpZ24obiwgUywgZXhlbXBsYXJzSW5kaWNlcyk7XG4gIHZhciBjbHVzdGVycyA9IHt9O1xuICBmb3IgKHZhciBjID0gMDsgYyA8IGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoOyBjKyspIHtcbiAgICBjbHVzdGVyc1tleGVtcGxhcnNJbmRpY2VzW2NdXSA9IFtdO1xuICB9XG4gIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbm9kZXMubGVuZ3RoOyBfaTEyKyspIHtcbiAgICB2YXIgcG9zID0gaWQycG9zaXRpb25bbm9kZXNbX2kxMl0uaWQoKV07XG4gICAgdmFyIGNsdXN0ZXJJbmRleCA9IGNsdXN0ZXJJbmRpY2VzW3Bvc107XG4gICAgaWYgKGNsdXN0ZXJJbmRleCAhPSBudWxsKSB7XG4gICAgICAvLyB0aGUgbm9kZSBtYXkgaGF2ZSBub3QgYmVlbiBhc3NpZ25lZCBhIGNsdXN0ZXIgaWYgbm8gdmFsaWQgYXR0cmlidXRlcyB3ZXJlIHNwZWNpZmllZFxuICAgICAgY2x1c3RlcnNbY2x1c3RlckluZGV4XS5wdXNoKG5vZGVzW19pMTJdKTtcbiAgICB9XG4gIH1cbiAgdmFyIHJldENsdXN0ZXJzID0gbmV3IEFycmF5KGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoKTtcbiAgZm9yICh2YXIgX2MgPSAwOyBfYyA8IGV4ZW1wbGFyc0luZGljZXMubGVuZ3RoOyBfYysrKSB7XG4gICAgcmV0Q2x1c3RlcnNbX2NdID0gY3kuY29sbGVjdGlvbihjbHVzdGVyc1tleGVtcGxhcnNJbmRpY2VzW19jXV0pO1xuICB9XG4gIHJldHVybiByZXRDbHVzdGVycztcbn07XG52YXIgYWZmaW5pdHlQcm9wYWdhdGlvbiQxID0ge1xuICBhZmZpbml0eVByb3BhZ2F0aW9uOiBhZmZpbml0eVByb3BhZ2F0aW9uLFxuICBhcDogYWZmaW5pdHlQcm9wYWdhdGlvblxufTtcblxudmFyIGhpZXJob2x6ZXJEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICByb290OiB1bmRlZmluZWQsXG4gIGRpcmVjdGVkOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJGsgPSB7XG4gIGhpZXJob2x6ZXI6IGZ1bmN0aW9uIGhpZXJob2x6ZXIob3B0aW9ucykge1xuICAgIGlmICghcGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcm9vdDogYXJnc1swXSxcbiAgICAgICAgZGlyZWN0ZWQ6IGFyZ3NbMV1cbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBfaGllcmhvbHplckRlZmF1bHRzID0gaGllcmhvbHplckRlZmF1bHRzKG9wdGlvbnMpLFxuICAgICAgcm9vdCA9IF9oaWVyaG9semVyRGVmYXVsdHMucm9vdCxcbiAgICAgIGRpcmVjdGVkID0gX2hpZXJob2x6ZXJEZWZhdWx0cy5kaXJlY3RlZDtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGRmbGFnID0gZmFsc2U7XG4gICAgdmFyIG9kZEluO1xuICAgIHZhciBvZGRPdXQ7XG4gICAgdmFyIHN0YXJ0VmVydGV4O1xuICAgIGlmIChyb290KSBzdGFydFZlcnRleCA9IHN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpWzBdLmlkKCkgOiByb290WzBdLmlkKCk7XG4gICAgdmFyIG5vZGVzID0ge307XG4gICAgdmFyIGVkZ2VzID0ge307XG4gICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgICAgIHZhciBpbmQgPSBlbGUuaW5kZWdyZWUodHJ1ZSk7XG4gICAgICAgICAgdmFyIG91dGQgPSBlbGUub3V0ZGVncmVlKHRydWUpO1xuICAgICAgICAgIHZhciBkMSA9IGluZCAtIG91dGQ7XG4gICAgICAgICAgdmFyIGQyID0gb3V0ZCAtIGluZDtcbiAgICAgICAgICBpZiAoZDEgPT0gMSkge1xuICAgICAgICAgICAgaWYgKG9kZEluKSBkZmxhZyA9IHRydWU7ZWxzZSBvZGRJbiA9IGlkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZDIgPT0gMSkge1xuICAgICAgICAgICAgaWYgKG9kZE91dCkgZGZsYWcgPSB0cnVlO2Vsc2Ugb2RkT3V0ID0gaWQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChkMiA+IDEgfHwgZDEgPiAxKSB7XG4gICAgICAgICAgICBkZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVzW2lkXSA9IFtdO1xuICAgICAgICAgIGVsZS5vdXRnb2VycygpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmlzRWRnZSgpKSBub2Rlc1tpZF0ucHVzaChlLmlkKCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkZ2VzW2lkXSA9IFt1bmRlZmluZWQsIGVsZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgdmFyIGQgPSBlbGUuZGVncmVlKHRydWUpO1xuICAgICAgICAgIGlmIChkICUgMikge1xuICAgICAgICAgICAgaWYgKCFvZGRJbikgb2RkSW4gPSBpZDtlbHNlIGlmICghb2RkT3V0KSBvZGRPdXQgPSBpZDtlbHNlIGRmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZXNbaWRdID0gW107XG4gICAgICAgICAgZWxlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2lkXS5wdXNoKGUuaWQoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZXNbaWRdID0gW2VsZS5zb3VyY2UoKS5pZCgpLCBlbGUudGFyZ2V0KCkuaWQoKV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgZm91bmQ6IGZhbHNlLFxuICAgICAgdHJhaWw6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgaWYgKGRmbGFnKSByZXR1cm4gcmVzdWx0O2Vsc2UgaWYgKG9kZE91dCAmJiBvZGRJbikge1xuICAgICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICAgIGlmIChzdGFydFZlcnRleCAmJiBvZGRPdXQgIT0gc3RhcnRWZXJ0ZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0VmVydGV4ID0gb2RkT3V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0VmVydGV4ICYmIG9kZE91dCAhPSBzdGFydFZlcnRleCAmJiBvZGRJbiAhPSBzdGFydFZlcnRleCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXJ0VmVydGV4KSB7XG4gICAgICAgICAgc3RhcnRWZXJ0ZXggPSBvZGRPdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzdGFydFZlcnRleCkgc3RhcnRWZXJ0ZXggPSBlbGVzWzBdLmlkKCk7XG4gICAgfVxuICAgIHZhciB3YWxrID0gZnVuY3Rpb24gd2Fsayh2KSB7XG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB2O1xuICAgICAgdmFyIHN1YnRvdXIgPSBbdl07XG4gICAgICB2YXIgYWRqLCBhZGpUYWlsLCBhZGpIZWFkO1xuICAgICAgd2hpbGUgKG5vZGVzW2N1cnJlbnROb2RlXS5sZW5ndGgpIHtcbiAgICAgICAgYWRqID0gbm9kZXNbY3VycmVudE5vZGVdLnNoaWZ0KCk7XG4gICAgICAgIGFkalRhaWwgPSBlZGdlc1thZGpdWzBdO1xuICAgICAgICBhZGpIZWFkID0gZWRnZXNbYWRqXVsxXTtcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlICE9IGFkakhlYWQpIHtcbiAgICAgICAgICBub2Rlc1thZGpIZWFkXSA9IG5vZGVzW2FkakhlYWRdLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGUgIT0gYWRqO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGN1cnJlbnROb2RlID0gYWRqSGVhZDtcbiAgICAgICAgfSBlbHNlIGlmICghZGlyZWN0ZWQgJiYgY3VycmVudE5vZGUgIT0gYWRqVGFpbCkge1xuICAgICAgICAgIG5vZGVzW2FkalRhaWxdID0gbm9kZXNbYWRqVGFpbF0uZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZSAhPSBhZGo7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY3VycmVudE5vZGUgPSBhZGpUYWlsO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRvdXIudW5zaGlmdChhZGopO1xuICAgICAgICBzdWJ0b3VyLnVuc2hpZnQoY3VycmVudE5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1YnRvdXI7XG4gICAgfTtcbiAgICB2YXIgdHJhaWwgPSBbXTtcbiAgICB2YXIgc3VidG91ciA9IFtdO1xuICAgIHN1YnRvdXIgPSB3YWxrKHN0YXJ0VmVydGV4KTtcbiAgICB3aGlsZSAoc3VidG91ci5sZW5ndGggIT0gMSkge1xuICAgICAgaWYgKG5vZGVzW3N1YnRvdXJbMF1dLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHRyYWlsLnVuc2hpZnQoZWxlcy5nZXRFbGVtZW50QnlJZChzdWJ0b3VyLnNoaWZ0KCkpKTtcbiAgICAgICAgdHJhaWwudW5zaGlmdChlbGVzLmdldEVsZW1lbnRCeUlkKHN1YnRvdXIuc2hpZnQoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VidG91ciA9IHdhbGsoc3VidG91ci5zaGlmdCgpKS5jb25jYXQoc3VidG91cik7XG4gICAgICB9XG4gICAgfVxuICAgIHRyYWlsLnVuc2hpZnQoZWxlcy5nZXRFbGVtZW50QnlJZChzdWJ0b3VyLnNoaWZ0KCkpKTsgLy8gZmluYWwgbm9kZVxuXG4gICAgZm9yICh2YXIgZCBpbiBub2Rlcykge1xuICAgICAgaWYgKG5vZGVzW2RdLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuZm91bmQgPSB0cnVlO1xuICAgIHJlc3VsdC50cmFpbCA9IHRoaXMuc3Bhd24odHJhaWwsIHRydWUpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkID0gZnVuY3Rpb24gaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCgpIHtcbiAgdmFyIGVsZXMgPSB0aGlzO1xuICB2YXIgbm9kZXMgPSB7fTtcbiAgdmFyIGlkID0gMDtcbiAgdmFyIGVkZ2VDb3VudCA9IDA7XG4gIHZhciBjb21wb25lbnRzID0gW107XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgdmlzaXRlZEVkZ2VzID0ge307XG4gIHZhciBidWlsZENvbXBvbmVudCA9IGZ1bmN0aW9uIGJ1aWxkQ29tcG9uZW50KHgsIHkpIHtcbiAgICB2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgdmFyIGN1dHNldCA9IFtdO1xuICAgIHZhciBjb21wb25lbnQgPSBlbGVzLnNwYXduKCk7XG4gICAgd2hpbGUgKHN0YWNrW2ldLnggIT0geCB8fCBzdGFja1tpXS55ICE9IHkpIHtcbiAgICAgIGN1dHNldC5wdXNoKHN0YWNrLnBvcCgpLmVkZ2UpO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBjdXRzZXQucHVzaChzdGFjay5wb3AoKS5lZGdlKTtcbiAgICBjdXRzZXQuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gZWRnZS5jb25uZWN0ZWROb2RlcygpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICAgIGNvbXBvbmVudC5tZXJnZShlZGdlKTtcbiAgICAgIGNvbm5lY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGUuaWQoKTtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICAgICAgY29tcG9uZW50Lm1lcmdlKG5vZGUpO1xuICAgICAgICBpZiAoIW5vZGVzW25vZGVJZF0uY3V0VmVydGV4KSB7XG4gICAgICAgICAgY29tcG9uZW50Lm1lcmdlKGNvbm5lY3RlZEVkZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wb25lbnQubWVyZ2UoY29ubmVjdGVkRWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICByZXR1cm4gZWRnZS5pc0xvb3AoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICB9O1xuICB2YXIgX2JpY29ubmVjdGVkU2VhcmNoID0gZnVuY3Rpb24gYmljb25uZWN0ZWRTZWFyY2gocm9vdCwgY3VycmVudE5vZGUsIHBhcmVudCkge1xuICAgIGlmIChyb290ID09PSBwYXJlbnQpIGVkZ2VDb3VudCArPSAxO1xuICAgIG5vZGVzW2N1cnJlbnROb2RlXSA9IHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGxvdzogaWQrKyxcbiAgICAgIGN1dFZlcnRleDogZmFsc2VcbiAgICB9O1xuICAgIHZhciBlZGdlcyA9IGVsZXMuZ2V0RWxlbWVudEJ5SWQoY3VycmVudE5vZGUpLmNvbm5lY3RlZEVkZ2VzKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgIGlmIChlZGdlcy5zaXplKCkgPT09IDApIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChlbGVzLnNwYXduKGVsZXMuZ2V0RWxlbWVudEJ5SWQoY3VycmVudE5vZGUpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzb3VyY2VJZCwgdGFyZ2V0SWQsIG90aGVyTm9kZUlkLCBlZGdlSWQ7XG4gICAgICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHNvdXJjZUlkID0gZWRnZS5zb3VyY2UoKS5pZCgpO1xuICAgICAgICB0YXJnZXRJZCA9IGVkZ2UudGFyZ2V0KCkuaWQoKTtcbiAgICAgICAgb3RoZXJOb2RlSWQgPSBzb3VyY2VJZCA9PT0gY3VycmVudE5vZGUgPyB0YXJnZXRJZCA6IHNvdXJjZUlkO1xuICAgICAgICBpZiAob3RoZXJOb2RlSWQgIT09IHBhcmVudCkge1xuICAgICAgICAgIGVkZ2VJZCA9IGVkZ2UuaWQoKTtcbiAgICAgICAgICBpZiAoIXZpc2l0ZWRFZGdlc1tlZGdlSWRdKSB7XG4gICAgICAgICAgICB2aXNpdGVkRWRnZXNbZWRnZUlkXSA9IHRydWU7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgeDogY3VycmVudE5vZGUsXG4gICAgICAgICAgICAgIHk6IG90aGVyTm9kZUlkLFxuICAgICAgICAgICAgICBlZGdlOiBlZGdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEob3RoZXJOb2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgICAgICBfYmljb25uZWN0ZWRTZWFyY2gocm9vdCwgb3RoZXJOb2RlSWQsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIG5vZGVzW2N1cnJlbnROb2RlXS5sb3cgPSBNYXRoLm1pbihub2Rlc1tjdXJyZW50Tm9kZV0ubG93LCBub2Rlc1tvdGhlck5vZGVJZF0ubG93KTtcbiAgICAgICAgICAgIGlmIChub2Rlc1tjdXJyZW50Tm9kZV0uaWQgPD0gbm9kZXNbb3RoZXJOb2RlSWRdLmxvdykge1xuICAgICAgICAgICAgICBub2Rlc1tjdXJyZW50Tm9kZV0uY3V0VmVydGV4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnVpbGRDb21wb25lbnQoY3VycmVudE5vZGUsIG90aGVyTm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZXNbY3VycmVudE5vZGVdLmxvdyA9IE1hdGgubWluKG5vZGVzW2N1cnJlbnROb2RlXS5sb3csIG5vZGVzW290aGVyTm9kZUlkXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGVsZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIG5vZGVJZCA9IGVsZS5pZCgpO1xuICAgICAgaWYgKCEobm9kZUlkIGluIG5vZGVzKSkge1xuICAgICAgICBlZGdlQ291bnQgPSAwO1xuICAgICAgICBfYmljb25uZWN0ZWRTZWFyY2gobm9kZUlkLCBub2RlSWQpO1xuICAgICAgICBub2Rlc1tub2RlSWRdLmN1dFZlcnRleCA9IGVkZ2VDb3VudCA+IDE7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdmFyIGN1dFZlcnRpY2VzID0gT2JqZWN0LmtleXMobm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gbm9kZXNbaWRdLmN1dFZlcnRleDtcbiAgfSkubWFwKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiBlbGVzLmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY3V0OiBlbGVzLnNwYXduKGN1dFZlcnRpY2VzKSxcbiAgICBjb21wb25lbnRzOiBjb21wb25lbnRzXG4gIH07XG59O1xudmFyIGhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQkMSA9IHtcbiAgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZDogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCxcbiAgaHRiYzogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCxcbiAgaHRiOiBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkLFxuICBob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkQ29tcG9uZW50czogaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZFxufTtcblxudmFyIHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkID0gZnVuY3Rpb24gdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQoKSB7XG4gIHZhciBlbGVzID0gdGhpcztcbiAgdmFyIG5vZGVzID0ge307XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBjb21wb25lbnRzID0gW107XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgY3V0ID0gZWxlcy5zcGF3bihlbGVzKTtcbiAgdmFyIF9zdHJvbmdseUNvbm5lY3RlZFNlYXJjaCA9IGZ1bmN0aW9uIHN0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoKHNvdXJjZU5vZGVJZCkge1xuICAgIHN0YWNrLnB1c2goc291cmNlTm9kZUlkKTtcbiAgICBub2Rlc1tzb3VyY2VOb2RlSWRdID0ge1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgbG93OiBpbmRleCsrLFxuICAgICAgZXhwbG9yZWQ6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBlbGVzLmdldEVsZW1lbnRCeUlkKHNvdXJjZU5vZGVJZCkuY29ubmVjdGVkRWRnZXMoKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgY29ubmVjdGVkRWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgdmFyIHRhcmdldE5vZGVJZCA9IGVkZ2UudGFyZ2V0KCkuaWQoKTtcbiAgICAgIGlmICh0YXJnZXROb2RlSWQgIT09IHNvdXJjZU5vZGVJZCkge1xuICAgICAgICBpZiAoISh0YXJnZXROb2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgICAgX3N0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoKHRhcmdldE5vZGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2Rlc1t0YXJnZXROb2RlSWRdLmV4cGxvcmVkKSB7XG4gICAgICAgICAgbm9kZXNbc291cmNlTm9kZUlkXS5sb3cgPSBNYXRoLm1pbihub2Rlc1tzb3VyY2VOb2RlSWRdLmxvdywgbm9kZXNbdGFyZ2V0Tm9kZUlkXS5sb3cpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKG5vZGVzW3NvdXJjZU5vZGVJZF0uaW5kZXggPT09IG5vZGVzW3NvdXJjZU5vZGVJZF0ubG93KSB7XG4gICAgICB2YXIgY29tcG9uZW50Tm9kZXMgPSBlbGVzLnNwYXduKCk7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIHZhciBub2RlSWQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgY29tcG9uZW50Tm9kZXMubWVyZ2UoZWxlcy5nZXRFbGVtZW50QnlJZChub2RlSWQpKTtcbiAgICAgICAgbm9kZXNbbm9kZUlkXS5sb3cgPSBub2Rlc1tzb3VyY2VOb2RlSWRdLmluZGV4O1xuICAgICAgICBub2Rlc1tub2RlSWRdLmV4cGxvcmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5vZGVJZCA9PT0gc291cmNlTm9kZUlkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjb21wb25lbnRFZGdlcyA9IGNvbXBvbmVudE5vZGVzLmVkZ2VzV2l0aChjb21wb25lbnROb2Rlcyk7XG4gICAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50Tm9kZXMubWVyZ2UoY29tcG9uZW50RWRnZXMpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICBjdXQgPSBjdXQuZGlmZmVyZW5jZShjb21wb25lbnQpO1xuICAgIH1cbiAgfTtcbiAgZWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICB2YXIgbm9kZUlkID0gZWxlLmlkKCk7XG4gICAgICBpZiAoIShub2RlSWQgaW4gbm9kZXMpKSB7XG4gICAgICAgIF9zdHJvbmdseUNvbm5lY3RlZFNlYXJjaChub2RlSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgY3V0OiBjdXQsXG4gICAgY29tcG9uZW50czogY29tcG9uZW50c1xuICB9O1xufTtcbnZhciB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCQxID0ge1xuICB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZDogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQsXG4gIHRzYzogdGFyamFuU3Ryb25nbHlDb25uZWN0ZWQsXG4gIHRzY2M6IHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkLFxuICB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZENvbXBvbmVudHM6IHRhcmphblN0cm9uZ2x5Q29ubmVjdGVkXG59O1xuXG52YXIgZWxlc2ZuJGogPSB7fTtcbltlbGVzZm4kdiwgZWxlc2ZuJHUsIGVsZXNmbiR0LCBlbGVzZm4kcywgZWxlc2ZuJHIsIGVsZXNmbiRxLCBlbGVzZm4kcCwgZWxlc2ZuJG8sIGVsZXNmbiRuLCBlbGVzZm4kbSwgZWxlc2ZuJGwsIG1hcmtvdkNsdXN0ZXJpbmckMSwga0NsdXN0ZXJpbmcsIGhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSwgYWZmaW5pdHlQcm9wYWdhdGlvbiQxLCBlbGVzZm4kaywgaG9wY3JvZnRUYXJqYW5CaWNvbm5lY3RlZCQxLCB0YXJqYW5TdHJvbmdseUNvbm5lY3RlZCQxXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoZWxlc2ZuJGosIHByb3BzKTtcbn0pO1xuXG4vKiFcbkVtYmVkZGFibGUgTWluaW11bSBTdHJpY3RseS1Db21wbGlhbnQgUHJvbWlzZXMvQSsgMS4xLjEgVGhlbmFibGVcbkNvcHlyaWdodCAoYykgMjAxMy0yMDE0IFJhbGYgUy4gRW5nZWxzY2hhbGwgKGh0dHA6Ly9lbmdlbHNjaGFsbC5jb20pXG5MaWNlbnNlZCB1bmRlciBUaGUgTUlUIExpY2Vuc2UgKGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQpXG4qL1xuXG4vKiAgcHJvbWlzZSBzdGF0ZXMgW1Byb21pc2VzL0ErIDIuMV0gICovXG52YXIgU1RBVEVfUEVORElORyA9IDA7IC8qICBbUHJvbWlzZXMvQSsgMi4xLjFdICAqL1xudmFyIFNUQVRFX0ZVTEZJTExFRCA9IDE7IC8qICBbUHJvbWlzZXMvQSsgMi4xLjJdICAqL1xudmFyIFNUQVRFX1JFSkVDVEVEID0gMjsgLyogIFtQcm9taXNlcy9BKyAyLjEuM10gICovXG5cbi8qICBwcm9taXNlIG9iamVjdCBjb25zdHJ1Y3RvciAgKi9cbnZhciBfYXBpID0gZnVuY3Rpb24gYXBpKGV4ZWN1dG9yKSB7XG4gIC8qICBvcHRpb25hbGx5IHN1cHBvcnQgbm9uLWNvbnN0cnVjdG9yL3BsYWluLWZ1bmN0aW9uIGNhbGwgICovXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfYXBpKSkgcmV0dXJuIG5ldyBfYXBpKGV4ZWN1dG9yKTtcblxuICAvKiAgaW5pdGlhbGl6ZSBvYmplY3QgICovXG4gIHRoaXMuaWQgPSAnVGhlbmFibGUvMS4wLjcnO1xuICB0aGlzLnN0YXRlID0gU1RBVEVfUEVORElORzsgLyogIGluaXRpYWwgc3RhdGUgICovXG4gIHRoaXMuZnVsZmlsbFZhbHVlID0gdW5kZWZpbmVkOyAvKiAgaW5pdGlhbCB2YWx1ZSAgKi8gLyogIFtQcm9taXNlcy9BKyAxLjMsIDIuMS4yLjJdICAqL1xuICB0aGlzLnJlamVjdFJlYXNvbiA9IHVuZGVmaW5lZDsgLyogIGluaXRpYWwgcmVhc29uICovIC8qICBbUHJvbWlzZXMvQSsgMS41LCAyLjEuMy4yXSAgKi9cbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IFtdOyAvKiAgaW5pdGlhbCBoYW5kbGVycyAgKi9cbiAgdGhpcy5vblJlamVjdGVkID0gW107IC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuXG4gIC8qICBwcm92aWRlIG9wdGlvbmFsIGluZm9ybWF0aW9uLWhpZGluZyBwcm94eSAgKi9cbiAgdGhpcy5wcm94eSA9IHtcbiAgICB0aGVuOiB0aGlzLnRoZW4uYmluZCh0aGlzKVxuICB9O1xuXG4gIC8qICBzdXBwb3J0IG9wdGlvbmFsIGV4ZWN1dG9yIGZ1bmN0aW9uICAqL1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yID09PSAnZnVuY3Rpb24nKSBleGVjdXRvci5jYWxsKHRoaXMsIHRoaXMuZnVsZmlsbC5iaW5kKHRoaXMpLCB0aGlzLnJlamVjdC5iaW5kKHRoaXMpKTtcbn07XG5cbi8qICBwcm9taXNlIEFQSSBtZXRob2RzICAqL1xuX2FwaS5wcm90b3R5cGUgPSB7XG4gIC8qICBwcm9taXNlIHJlc29sdmluZyBtZXRob2RzICAqL1xuICBmdWxmaWxsOiBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfRlVMRklMTEVELCAnZnVsZmlsbFZhbHVlJywgdmFsdWUpO1xuICB9LFxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBkZWxpdmVyKHRoaXMsIFNUQVRFX1JFSkVDVEVELCAncmVqZWN0UmVhc29uJywgdmFsdWUpO1xuICB9LFxuICAvKiAgXCJUaGUgdGhlbiBNZXRob2RcIiBbUHJvbWlzZXMvQSsgMS4xLCAxLjIsIDIuMl0gICovXG4gIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICB2YXIgY3VyciA9IHRoaXM7XG4gICAgdmFyIG5leHQgPSBuZXcgX2FwaSgpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi43XSAgKi9cbiAgICBjdXJyLm9uRnVsZmlsbGVkLnB1c2gocmVzb2x2ZXIob25GdWxmaWxsZWQsIG5leHQsICdmdWxmaWxsJykpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLzIuMi42XSAgKi9cbiAgICBjdXJyLm9uUmVqZWN0ZWQucHVzaChyZXNvbHZlcihvblJlamVjdGVkLCBuZXh0LCAncmVqZWN0JykpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi4zLzIuMi42XSAgKi9cbiAgICBleGVjdXRlKGN1cnIpO1xuICAgIHJldHVybiBuZXh0LnByb3h5OyAvKiAgW1Byb21pc2VzL0ErIDIuMi43LCAzLjNdICAqL1xuICB9XG59O1xuXG4vKiAgZGVsaXZlciBhbiBhY3Rpb24gICovXG52YXIgZGVsaXZlciA9IGZ1bmN0aW9uIGRlbGl2ZXIoY3Vyciwgc3RhdGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9QRU5ESU5HKSB7XG4gICAgY3Vyci5zdGF0ZSA9IHN0YXRlOyAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjEsIDIuMS4zLjFdICAqL1xuICAgIGN1cnJbbmFtZV0gPSB2YWx1ZTsgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4yLCAyLjEuMy4yXSAgKi9cbiAgICBleGVjdXRlKGN1cnIpO1xuICB9XG4gIHJldHVybiBjdXJyO1xufTtcblxuLyogIGV4ZWN1dGUgYWxsIGhhbmRsZXJzICAqL1xudmFyIGV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlKGN1cnIpIHtcbiAgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX0ZVTEZJTExFRCkgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCAnb25GdWxmaWxsZWQnLCBjdXJyLmZ1bGZpbGxWYWx1ZSk7ZWxzZSBpZiAoY3Vyci5zdGF0ZSA9PT0gU1RBVEVfUkVKRUNURUQpIGV4ZWN1dGVfaGFuZGxlcnMoY3VyciwgJ29uUmVqZWN0ZWQnLCBjdXJyLnJlamVjdFJlYXNvbik7XG59O1xuXG4vKiAgZXhlY3V0ZSBwYXJ0aWN1bGFyIHNldCBvZiBoYW5kbGVycyAgKi9cbnZhciBleGVjdXRlX2hhbmRsZXJzID0gZnVuY3Rpb24gZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCBuYW1lLCB2YWx1ZSkge1xuICAvKiBnbG9iYWwgc2V0SW1tZWRpYXRlOiB0cnVlICovXG4gIC8qIGdsb2JhbCBzZXRUaW1lb3V0OiB0cnVlICovXG5cbiAgLyogIHNob3J0LWNpcmN1aXQgcHJvY2Vzc2luZyAgKi9cbiAgaWYgKGN1cnJbbmFtZV0ubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgLyogIGl0ZXJhdGUgb3ZlciBhbGwgaGFuZGxlcnMsIGV4YWN0bHkgb25jZSAgKi9cbiAgdmFyIGhhbmRsZXJzID0gY3VycltuYW1lXTtcbiAgY3VycltuYW1lXSA9IFtdOyAvKiAgW1Byb21pc2VzL0ErIDIuMi4yLjMsIDIuMi4zLjNdICAqL1xuICB2YXIgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykgaGFuZGxlcnNbaV0odmFsdWUpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi41XSAgKi9cbiAgfTtcblxuICAvKiAgZXhlY3V0ZSBwcm9jZWR1cmUgYXN5bmNocm9ub3VzbHkgICovIC8qICBbUHJvbWlzZXMvQSsgMi4yLjQsIDMuMV0gICovXG4gIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSBzZXRJbW1lZGlhdGUoZnVuYyk7ZWxzZSBzZXRUaW1lb3V0KGZ1bmMsIDApO1xufTtcblxuLyogIGdlbmVyYXRlIGEgcmVzb2x2ZXIgZnVuY3Rpb24gICovXG52YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbiByZXNvbHZlcihjYiwgbmV4dCwgbWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSAvKiAgW1Byb21pc2VzL0ErIDIuMi4xLCAyLjIuNy4zLCAyLjIuNy40XSAgKi9cbiAgICAgIG5leHRbbWV0aG9kXS5jYWxsKG5leHQsIHZhbHVlKTsgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4zLCAyLjIuNy40XSAgKi9lbHNlIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBjYih2YWx1ZSk7XG4gICAgICB9IC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMSwgMi4yLjMuMSwgMi4yLjUsIDMuMl0gICovIGNhdGNoIChlKSB7XG4gICAgICAgIG5leHQucmVqZWN0KGUpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjJdICAqL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBfcmVzb2x2ZShuZXh0LCByZXN1bHQpOyAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjFdICAqL1xuICAgIH1cbiAgfTtcbn07XG5cbi8qICBcIlByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmVcIiAgKi8gLyogIFtQcm9taXNlcy9BKyAyLjNdICAqL1xudmFyIF9yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZShwcm9taXNlLCB4KSB7XG4gIC8qICBzYW5pdHkgY2hlY2sgYXJndW1lbnRzICAqLyAvKiAgW1Byb21pc2VzL0ErIDIuMy4xXSAgKi9cbiAgaWYgKHByb21pc2UgPT09IHggfHwgcHJvbWlzZS5wcm94eSA9PT0geCkge1xuICAgIHByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyogIHN1cmdpY2FsbHkgY2hlY2sgZm9yIGEgXCJ0aGVuXCIgbWV0aG9kXG4gICAgKG1haW5seSB0byBqdXN0IGNhbGwgdGhlIFwiZ2V0dGVyXCIgb2YgXCJ0aGVuXCIgb25seSBvbmNlKSAgKi9cbiAgdmFyIHRoZW47XG4gIGlmIChfdHlwZW9mKHgpID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoZW4gPSB4LnRoZW47XG4gICAgfSAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjEsIDMuNV0gICovIGNhdGNoIChlKSB7XG4gICAgICBwcm9taXNlLnJlamVjdChlKTsgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4yXSAgKi9cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvKiAgaGFuZGxlIG93biBUaGVuYWJsZXMgICAgW1Byb21pc2VzL0ErIDIuMy4yXVxuICAgIGFuZCBzaW1pbGFyIFwidGhlbmFibGVzXCIgW1Byb21pc2VzL0ErIDIuMy4zXSAgKi9cbiAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIC8qICBjYWxsIHJldHJpZXZlZCBcInRoZW5cIiBtZXRob2QgKi8gLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zXSAgKi9cbiAgICAgIHRoZW4uY2FsbCh4LCAvKiAgcmVzb2x2ZVByb21pc2UgICovIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4xXSAgKi9cbiAgICAgIGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuICAgICAgICByZXNvbHZlZCA9IHRydWU7IC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgaWYgKHkgPT09IHgpIC8qICBbUHJvbWlzZXMvQSsgMy42XSAgKi9cbiAgICAgICAgICBwcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdjaXJjdWxhciB0aGVuYWJsZSBjaGFpbicpKTtlbHNlIF9yZXNvbHZlKHByb21pc2UsIHkpO1xuICAgICAgfSwgLyogIHJlamVjdFByb21pc2UgICovIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4yXSAgKi9cbiAgICAgIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuICAgICAgICByZXNvbHZlZCA9IHRydWU7IC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgcHJvbWlzZS5yZWplY3Qocik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoIXJlc29sdmVkKSAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgIHByb21pc2UucmVqZWN0KGUpOyAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuNF0gICovXG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qICBoYW5kbGUgb3RoZXIgdmFsdWVzICAqL1xuICBwcm9taXNlLmZ1bGZpbGwoeCk7IC8qICBbUHJvbWlzZXMvQSsgMi4zLjQsIDIuMy4zLjRdICAqL1xufTtcblxuLy8gc28gd2UgYWx3YXlzIGhhdmUgUHJvbWlzZS5hbGwoKVxuX2FwaS5hbGwgPSBmdW5jdGlvbiAocHMpIHtcbiAgcmV0dXJuIG5ldyBfYXBpKGZ1bmN0aW9uIChyZXNvbHZlQWxsLCByZWplY3RBbGwpIHtcbiAgICB2YXIgdmFscyA9IG5ldyBBcnJheShwcy5sZW5ndGgpO1xuICAgIHZhciBkb25lQ291bnQgPSAwO1xuICAgIHZhciBmdWxmaWxsID0gZnVuY3Rpb24gZnVsZmlsbChpLCB2YWwpIHtcbiAgICAgIHZhbHNbaV0gPSB2YWw7XG4gICAgICBkb25lQ291bnQrKztcbiAgICAgIGlmIChkb25lQ291bnQgPT09IHBzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlQWxsKHZhbHMpO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBwID0gcHNbaV07XG4gICAgICAgIHZhciBpc1Byb21pc2UgPSBwICE9IG51bGwgJiYgcC50aGVuICE9IG51bGw7XG4gICAgICAgIGlmIChpc1Byb21pc2UpIHtcbiAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgZnVsZmlsbChpLCB2YWwpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdEFsbChlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2YWwgPSBwO1xuICAgICAgICAgIGZ1bGZpbGwoaSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSkoaSk7XG4gICAgfVxuICB9KTtcbn07XG5fYXBpLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBuZXcgX2FwaShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzb2x2ZSh2YWwpO1xuICB9KTtcbn07XG5fYXBpLnJlamVjdCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBfYXBpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsKTtcbiAgfSk7XG59O1xudmFyIFByb21pc2UkMSA9IHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyA/IFByb21pc2UgOiBfYXBpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbnZhciBBbmltYXRpb24gPSBmdW5jdGlvbiBBbmltYXRpb24odGFyZ2V0LCBvcHRzLCBvcHRzMikge1xuICB2YXIgaXNDb3JlID0gY29yZSh0YXJnZXQpO1xuICB2YXIgaXNFbGUgPSAhaXNDb3JlO1xuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlID0gZXh0ZW5kKHtcbiAgICBkdXJhdGlvbjogMTAwMFxuICB9LCBvcHRzLCBvcHRzMik7XG4gIF9wLnRhcmdldCA9IHRhcmdldDtcbiAgX3Auc3R5bGUgPSBfcC5zdHlsZSB8fCBfcC5jc3M7XG4gIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgX3AucGxheWluZyA9IGZhbHNlO1xuICBfcC5ob29rZWQgPSBmYWxzZTtcbiAgX3AuYXBwbHlpbmcgPSBmYWxzZTtcbiAgX3AucHJvZ3Jlc3MgPSAwO1xuICBfcC5jb21wbGV0ZXMgPSBbXTtcbiAgX3AuZnJhbWVzID0gW107XG4gIGlmIChfcC5jb21wbGV0ZSAmJiBmbiQ2KF9wLmNvbXBsZXRlKSkge1xuICAgIF9wLmNvbXBsZXRlcy5wdXNoKF9wLmNvbXBsZXRlKTtcbiAgfVxuICBpZiAoaXNFbGUpIHtcbiAgICB2YXIgcG9zID0gdGFyZ2V0LnBvc2l0aW9uKCk7XG4gICAgX3Auc3RhcnRQb3NpdGlvbiA9IF9wLnN0YXJ0UG9zaXRpb24gfHwge1xuICAgICAgeDogcG9zLngsXG4gICAgICB5OiBwb3MueVxuICAgIH07XG4gICAgX3Auc3RhcnRTdHlsZSA9IF9wLnN0YXJ0U3R5bGUgfHwgdGFyZ2V0LmN5KCkuc3R5bGUoKS5nZXRBbmltYXRpb25TdGFydFN0eWxlKHRhcmdldCwgX3Auc3R5bGUpO1xuICB9XG4gIGlmIChpc0NvcmUpIHtcbiAgICB2YXIgcGFuID0gdGFyZ2V0LnBhbigpO1xuICAgIF9wLnN0YXJ0UGFuID0ge1xuICAgICAgeDogcGFuLngsXG4gICAgICB5OiBwYW4ueVxuICAgIH07XG4gICAgX3Auc3RhcnRab29tID0gdGFyZ2V0Lnpvb20oKTtcbiAgfVxuXG4gIC8vIGZvciBmdXR1cmUgdGltZWxpbmUvYW5pbWF0aW9ucyBpbXBsXG4gIHRoaXMubGVuZ3RoID0gMTtcbiAgdGhpc1swXSA9IHRoaXM7XG59O1xudmFyIGFuaWZuID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcbmV4dGVuZChhbmlmbiwge1xuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdhbmltYXRpb24nO1xuICB9LFxuICBob29rOiBmdW5jdGlvbiBob29rKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKCFfcC5ob29rZWQpIHtcbiAgICAgIC8vIGFkZCB0byB0YXJnZXQncyBhbmltYXRpb24gcXVldWVcbiAgICAgIHZhciBxO1xuICAgICAgdmFyIHRBbmkgPSBfcC50YXJnZXQuX3ByaXZhdGUuYW5pbWF0aW9uO1xuICAgICAgaWYgKF9wLnF1ZXVlKSB7XG4gICAgICAgIHEgPSB0QW5pLnF1ZXVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcSA9IHRBbmkuY3VycmVudDtcbiAgICAgIH1cbiAgICAgIHEucHVzaCh0aGlzKTtcblxuICAgICAgLy8gYWRkIHRvIHRoZSBhbmltYXRpb24gbG9vcCBwb29sXG4gICAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihfcC50YXJnZXQpKSB7XG4gICAgICAgIF9wLnRhcmdldC5jeSgpLmFkZFRvQW5pbWF0aW9uUG9vbChfcC50YXJnZXQpO1xuICAgICAgfVxuICAgICAgX3AuaG9va2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBsYXk6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgIC8vIGF1dG9yZXdpbmRcbiAgICBpZiAoX3AucHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgIF9wLnByb2dyZXNzID0gMDtcbiAgICB9XG4gICAgX3AucGxheWluZyA9IHRydWU7XG4gICAgX3Auc3RhcnRlZCA9IGZhbHNlOyAvLyBuZWVkcyB0byBiZSBzdGFydGVkIGJ5IGFuaW1hdGlvbiBsb29wXG4gICAgX3Auc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG9vaygpO1xuXG4gICAgLy8gdGhlIGFuaW1hdGlvbiBsb29wIHdpbGwgc3RhcnQgdGhlIGFuaW1hdGlvbi4uLlxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHBsYXlpbmc6IGZ1bmN0aW9uIHBsYXlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGxheWluZztcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uIGFwcGx5KCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgX3AuYXBwbHlpbmcgPSB0cnVlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTsgLy8gbmVlZHMgdG8gYmUgc3RhcnRlZCBieSBhbmltYXRpb24gbG9vcFxuICAgIF9wLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvb2soKTtcblxuICAgIC8vIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGFwcGx5IHRoZSBhbmltYXRpb24gYXQgdGhpcyBwcm9ncmVzc1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFwcGx5aW5nOiBmdW5jdGlvbiBhcHBseWluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hcHBseWluZztcbiAgfSxcbiAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgX3AucGxheWluZyA9IGZhbHNlO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIF9wLnBsYXlpbmcgPSBmYWxzZTtcbiAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgX3Auc3RvcHBlZCA9IHRydWU7IC8vIHRvIGJlIHJlbW92ZWQgZnJvbSBhbmltYXRpb24gcXVldWVzXG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmV3aW5kOiBmdW5jdGlvbiByZXdpbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3MoMCk7XG4gIH0sXG4gIGZhc3Rmb3J3YXJkOiBmdW5jdGlvbiBmYXN0Zm9yd2FyZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzcygxKTtcbiAgfSxcbiAgdGltZTogZnVuY3Rpb24gdGltZSh0KSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gX3AucHJvZ3Jlc3MgKiBfcC5kdXJhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3ModCAvIF9wLmR1cmF0aW9uKTtcbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhwKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgd2FzUGxheWluZyA9IF9wLnBsYXlpbmc7XG4gICAgaWYgKHAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIF9wLnByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB9XG4gICAgICBfcC5wcm9ncmVzcyA9IHA7XG4gICAgICBfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNvbXBsZXRlZDogZnVuY3Rpb24gY29tcGxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnByb2dyZXNzID09PSAxO1xuICB9LFxuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIHdhc1BsYXlpbmcgPSBfcC5wbGF5aW5nO1xuICAgIGlmICh3YXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICAgIF9wLnByb2dyZXNzID0gMSAtIF9wLnByb2dyZXNzO1xuICAgIF9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB2YXIgc3dhcCA9IGZ1bmN0aW9uIHN3YXAoYSwgYikge1xuICAgICAgdmFyIF9wYSA9IF9wW2FdO1xuICAgICAgaWYgKF9wYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9wW2FdID0gX3BbYl07XG4gICAgICBfcFtiXSA9IF9wYTtcbiAgICB9O1xuICAgIHN3YXAoJ3pvb20nLCAnc3RhcnRab29tJyk7XG4gICAgc3dhcCgncGFuJywgJ3N0YXJ0UGFuJyk7XG4gICAgc3dhcCgncG9zaXRpb24nLCAnc3RhcnRQb3NpdGlvbicpO1xuXG4gICAgLy8gc3dhcCBzdHlsZXNcbiAgICBpZiAoX3Auc3R5bGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3Auc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBfcC5zdHlsZVtpXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBzdGFydFN0eWxlUHJvcCA9IF9wLnN0YXJ0U3R5bGVbbmFtZV07XG4gICAgICAgIF9wLnN0YXJ0U3R5bGVbbmFtZV0gPSBwcm9wO1xuICAgICAgICBfcC5zdHlsZVtpXSA9IHN0YXJ0U3R5bGVQcm9wO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAod2FzUGxheWluZykge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwcm9taXNlOiBmdW5jdGlvbiBwcm9taXNlKHR5cGUpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBhcnI7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICAgIGFyciA9IF9wLmZyYW1lcztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgYXJyID0gX3AuY29tcGxldGVzO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhcnIucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTtcbmFuaWZuLmNvbXBsZXRlID0gYW5pZm4uY29tcGxldGVkO1xuYW5pZm4ucnVuID0gYW5pZm4ucGxheTtcbmFuaWZuLnJ1bm5pbmcgPSBhbmlmbi5wbGF5aW5nO1xuXG52YXIgZGVmaW5lJDMgPSB7XG4gIGFuaW1hdGVkOiBmdW5jdGlvbiBhbmltYXRlZCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZWRJbXBsKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGUgPSBhbGxbMF07XG4gICAgICBpZiAoZWxlKSB7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQubGVuZ3RoID4gMDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICAvLyBhbmltYXRlZFxuXG4gIGNsZWFyUXVldWU6IGZ1bmN0aW9uIGNsZWFyUXVldWUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyUXVldWVJbXBsKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSxcbiAgLy8gY2xlYXJRdWV1ZVxuXG4gIGRlbGF5OiBmdW5jdGlvbiBkZWxheSgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlJbXBsKHRpbWUsIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIGRlbGF5OiB0aW1lLFxuICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuICAvLyBkZWxheVxuXG4gIGRlbGF5QW5pbWF0aW9uOiBmdW5jdGlvbiBkZWxheUFuaW1hdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVsYXlBbmltYXRpb25JbXBsKHRpbWUsIGNvbXBsZXRlKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uKHtcbiAgICAgICAgZGVsYXk6IHRpbWUsXG4gICAgICAgIGR1cmF0aW9uOiB0aW1lLFxuICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgIH0pO1xuICAgIH07XG4gIH0sXG4gIC8vIGRlbGF5XG5cbiAgYW5pbWF0aW9uOiBmdW5jdGlvbiBhbmltYXRpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGlvbkltcGwocHJvcGVydGllcywgcGFyYW1zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIHZhciBpc0NvcmUgPSAhc2VsZklzQXJyYXlMaWtlO1xuICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIHByb3BlcnRpZXMgPSBleHRlbmQoe30sIHByb3BlcnRpZXMsIHBhcmFtcyk7XG4gICAgICB2YXIgcHJvcGVydGllc0VtcHR5ID0gT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoID09PSAwO1xuICAgICAgaWYgKHByb3BlcnRpZXNFbXB0eSkge1xuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbihhbGxbMF0sIHByb3BlcnRpZXMpOyAvLyBub3RoaW5nIHRvIGFuaW1hdGVcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wZXJ0aWVzLmR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcGVydGllcy5kdXJhdGlvbiA9IDQwMDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAocHJvcGVydGllcy5kdXJhdGlvbikge1xuICAgICAgICBjYXNlICdzbG93JzpcbiAgICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gNjAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmYXN0JzpcbiAgICAgICAgICBwcm9wZXJ0aWVzLmR1cmF0aW9uID0gMjAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlcykge1xuICAgICAgICBwcm9wZXJ0aWVzLnN0eWxlID0gc3R5bGUuZ2V0UHJvcHNMaXN0KHByb3BlcnRpZXMuc3R5bGUgfHwgcHJvcGVydGllcy5jc3MpO1xuICAgICAgICBwcm9wZXJ0aWVzLmNzcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChpc0VsZXMgJiYgcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJwb3MgPSBwcm9wZXJ0aWVzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgIHByb3BlcnRpZXMucG9zaXRpb24gPSByZW5kZXJlZFRvTW9kZWxQb3NpdGlvbihycG9zLCB6b29tLCBwYW4pO1xuICAgICAgfVxuXG4gICAgICAvLyBvdmVycmlkZSBwYW4gdy8gcGFuQnkgaWYgc2V0XG4gICAgICBpZiAoaXNDb3JlICYmIHByb3BlcnRpZXMucGFuQnkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFuQnkgPSBwcm9wZXJ0aWVzLnBhbkJ5O1xuICAgICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgcHJvcGVydGllcy5wYW4gPSB7XG4gICAgICAgICAgeDogY3lQYW4ueCArIHBhbkJ5LngsXG4gICAgICAgICAgeTogY3lQYW4ueSArIHBhbkJ5LnlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIGNlbnRlciBpZiBzZXRcbiAgICAgIHZhciBjZW50ZXIgPSBwcm9wZXJ0aWVzLmNlbnRlciB8fCBwcm9wZXJ0aWVzLmNlbnRyZTtcbiAgICAgIGlmIChpc0NvcmUgJiYgY2VudGVyICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGNlbnRlclBhbiA9IGN5LmdldENlbnRlclBhbihjZW50ZXIuZWxlcywgcHJvcGVydGllcy56b29tKTtcbiAgICAgICAgaWYgKGNlbnRlclBhbiAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBjZW50ZXJQYW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gb3ZlcnJpZGUgcGFuICYgem9vbSB3LyBmaXQgaWYgc2V0XG4gICAgICBpZiAoaXNDb3JlICYmIHByb3BlcnRpZXMuZml0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGZpdCA9IHByb3BlcnRpZXMuZml0O1xuICAgICAgICB2YXIgZml0VnAgPSBjeS5nZXRGaXRWaWV3cG9ydChmaXQuZWxlcyB8fCBmaXQuYm91bmRpbmdCb3gsIGZpdC5wYWRkaW5nKTtcbiAgICAgICAgaWYgKGZpdFZwICE9IG51bGwpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBmaXRWcC56b29tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG92ZXJyaWRlIHpvb20gKCYgcG90ZW50aWFsbHkgcGFuKSB3LyB6b29tIG9iaiBpZiBzZXRcbiAgICAgIGlmIChpc0NvcmUgJiYgcGxhaW5PYmplY3QocHJvcGVydGllcy56b29tKSkge1xuICAgICAgICB2YXIgdnAgPSBjeS5nZXRab29tZWRWaWV3cG9ydChwcm9wZXJ0aWVzLnpvb20pO1xuICAgICAgICBpZiAodnAgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh2cC56b29tZWQpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IHZwLnpvb207XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2cC5wYW5uZWQpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMucGFuID0gdnAucGFuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLnpvb20gPSBudWxsOyAvLyBhbiBpbmF2YWxpZCB6b29tIChlLmcuIG5vIGRlbHRhKSBnZXRzIGF1dG9tYXRpY2FsbHkgZGVzdHJveWVkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKGFsbFswXSwgcHJvcGVydGllcyk7XG4gICAgfTtcbiAgfSxcbiAgLy8gYW5pbWF0ZVxuXG4gIGFuaW1hdGU6IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKHByb3BlcnRpZXMsIHBhcmFtcykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcykge1xuICAgICAgICBwcm9wZXJ0aWVzID0gZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzLCBwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYW51YWxseSBob29rIGFuZCBydW4gdGhlIGFuaW1hdGlvblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGFsbFtpXTtcbiAgICAgICAgdmFyIHF1ZXVlID0gZWxlLmFuaW1hdGVkKCkgJiYgKHByb3BlcnRpZXMucXVldWUgPT09IHVuZGVmaW5lZCB8fCBwcm9wZXJ0aWVzLnF1ZXVlKTtcbiAgICAgICAgdmFyIGFuaSA9IGVsZS5hbmltYXRpb24ocHJvcGVydGllcywgcXVldWUgPyB7XG4gICAgICAgICAgcXVldWU6IHRydWVcbiAgICAgICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGFuaS5wbGF5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9O1xuICB9LFxuICAvLyBhbmltYXRlXG5cbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3RvcEltcGwoY2xlYXJRdWV1ZSwganVtcFRvRW5kKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBhbmlzID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYW5pcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBhbmkgPSBhbmlzW2pdO1xuICAgICAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgICAgICAgICBpZiAoanVtcFRvRW5kKSB7XG4gICAgICAgICAgICAvLyBuZXh0IGl0ZXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uIGxvb3AsIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIC8vIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIGVuZCBhbmQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgYW5pX3AuZHVyYXRpb24gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBxdWV1ZSBvZiBmdXR1cmUgYW5pbWF0aW9uc1xuICAgICAgICBpZiAoY2xlYXJRdWV1ZSkge1xuICAgICAgICAgIF9wLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghanVtcFRvRW5kKSB7XG4gICAgICAgICAgX3AuYW5pbWF0aW9uLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB3ZSBoYXZlIHRvIG5vdGlmeSAodGhlIGFuaW1hdGlvbiBsb29wIGRvZXNuJ3QgZG8gaXQgZm9yIHVzIG9uIGBzdG9wYClcbiAgICAgIGN5Lm5vdGlmeSgnZHJhdycpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSAvLyBzdG9wXG59OyAvLyBkZWZpbmVcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5cbnZhciBpc0FycmF5XzE7XG52YXIgaGFzUmVxdWlyZWRJc0FycmF5O1xuXG5mdW5jdGlvbiByZXF1aXJlSXNBcnJheSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZElzQXJyYXkpIHJldHVybiBpc0FycmF5XzE7XG5cdGhhc1JlcXVpcmVkSXNBcnJheSA9IDE7XG5cdHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuXHRpc0FycmF5XzEgPSBpc0FycmF5O1xuXHRyZXR1cm4gaXNBcnJheV8xO1xufVxuXG52YXIgX2lzS2V5O1xudmFyIGhhc1JlcXVpcmVkX2lzS2V5O1xuXG5mdW5jdGlvbiByZXF1aXJlX2lzS2V5ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2lzS2V5KSByZXR1cm4gX2lzS2V5O1xuXHRoYXNSZXF1aXJlZF9pc0tleSA9IDE7XG5cdHZhciBpc0FycmF5ID0gcmVxdWlyZUlzQXJyYXkoKSxcblx0ICAgIGlzU3ltYm9sID0gcmVxdWlyZUlzU3ltYm9sKCk7XG5cblx0LyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuXHR2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcblx0ICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLztcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG5cdCAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHQgIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcblx0ICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0ICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG5cdCAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuXHR9XG5cblx0X2lzS2V5ID0gaXNLZXk7XG5cdHJldHVybiBfaXNLZXk7XG59XG5cbnZhciBpc0Z1bmN0aW9uXzE7XG52YXIgaGFzUmVxdWlyZWRJc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiByZXF1aXJlSXNGdW5jdGlvbiAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZElzRnVuY3Rpb24pIHJldHVybiBpc0Z1bmN0aW9uXzE7XG5cdGhhc1JlcXVpcmVkSXNGdW5jdGlvbiA9IDE7XG5cdHZhciBiYXNlR2V0VGFnID0gcmVxdWlyZV9iYXNlR2V0VGFnKCksXG5cdCAgICBpc09iamVjdCA9IHJlcXVpcmVJc09iamVjdCgpO1xuXG5cdC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblx0dmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuXHQgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG5cdCAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuXHQgICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDAuMS4wXG5cdCAqIEBjYXRlZ29yeSBMYW5nXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIF8uaXNGdW5jdGlvbihfKTtcblx0ICogLy8gPT4gdHJ1ZVxuXHQgKlxuXHQgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuXHQgKiAvLyA9PiBmYWxzZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuXHQgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuXHQgIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuXHQgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcblx0ICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xuXHR9XG5cblx0aXNGdW5jdGlvbl8xID0gaXNGdW5jdGlvbjtcblx0cmV0dXJuIGlzRnVuY3Rpb25fMTtcbn1cblxudmFyIF9jb3JlSnNEYXRhO1xudmFyIGhhc1JlcXVpcmVkX2NvcmVKc0RhdGE7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfY29yZUpzRGF0YSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9jb3JlSnNEYXRhKSByZXR1cm4gX2NvcmVKc0RhdGE7XG5cdGhhc1JlcXVpcmVkX2NvcmVKc0RhdGEgPSAxO1xuXHR2YXIgcm9vdCA9IHJlcXVpcmVfcm9vdCgpO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cblx0dmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuXHRfY29yZUpzRGF0YSA9IGNvcmVKc0RhdGE7XG5cdHJldHVybiBfY29yZUpzRGF0YTtcbn1cblxudmFyIF9pc01hc2tlZDtcbnZhciBoYXNSZXF1aXJlZF9pc01hc2tlZDtcblxuZnVuY3Rpb24gcmVxdWlyZV9pc01hc2tlZCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9pc01hc2tlZCkgcmV0dXJuIF9pc01hc2tlZDtcblx0aGFzUmVxdWlyZWRfaXNNYXNrZWQgPSAxO1xuXHR2YXIgY29yZUpzRGF0YSA9IHJlcXVpcmVfY29yZUpzRGF0YSgpO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG5cdHZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuXHQgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG5cdCAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xuXHR9KCkpO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG5cdCAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcblx0fVxuXG5cdF9pc01hc2tlZCA9IGlzTWFza2VkO1xuXHRyZXR1cm4gX2lzTWFza2VkO1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cbnZhciBfdG9Tb3VyY2U7XG52YXIgaGFzUmVxdWlyZWRfdG9Tb3VyY2U7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfdG9Tb3VyY2UgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfdG9Tb3VyY2UpIHJldHVybiBfdG9Tb3VyY2U7XG5cdGhhc1JlcXVpcmVkX3RvU291cmNlID0gMTtcblx0dmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuXHQvKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG5cdHZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuXHQgIGlmIChmdW5jICE9IG51bGwpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcblx0ICAgIH0gY2F0Y2ggKGUpIHt9XG5cdCAgICB0cnkge1xuXHQgICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG5cdCAgICB9IGNhdGNoIChlKSB7fVxuXHQgIH1cblx0ICByZXR1cm4gJyc7XG5cdH1cblxuXHRfdG9Tb3VyY2UgPSB0b1NvdXJjZTtcblx0cmV0dXJuIF90b1NvdXJjZTtcbn1cblxudmFyIF9iYXNlSXNOYXRpdmU7XG52YXIgaGFzUmVxdWlyZWRfYmFzZUlzTmF0aXZlO1xuXG5mdW5jdGlvbiByZXF1aXJlX2Jhc2VJc05hdGl2ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9iYXNlSXNOYXRpdmUpIHJldHVybiBfYmFzZUlzTmF0aXZlO1xuXHRoYXNSZXF1aXJlZF9iYXNlSXNOYXRpdmUgPSAxO1xuXHR2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmVJc0Z1bmN0aW9uKCksXG5cdCAgICBpc01hc2tlZCA9IHJlcXVpcmVfaXNNYXNrZWQoKSxcblx0ICAgIGlzT2JqZWN0ID0gcmVxdWlyZUlzT2JqZWN0KCksXG5cdCAgICB0b1NvdXJjZSA9IHJlcXVpcmVfdG9Tb3VyY2UoKTtcblxuXHQvKipcblx0ICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuXHQgKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cblx0ICovXG5cdHZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cblx0LyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xuXHR2YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG5cdCAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xuXHR2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG5cdC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xuXHR2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuXHQgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG5cdCAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG5cdCk7XG5cblx0LyoqXG5cdCAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuXHQgKiAgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG5cdCAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuXHQgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcblx0fVxuXG5cdF9iYXNlSXNOYXRpdmUgPSBiYXNlSXNOYXRpdmU7XG5cdHJldHVybiBfYmFzZUlzTmF0aXZlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cbnZhciBfZ2V0VmFsdWU7XG52YXIgaGFzUmVxdWlyZWRfZ2V0VmFsdWU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfZ2V0VmFsdWUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfZ2V0VmFsdWUpIHJldHVybiBfZ2V0VmFsdWU7XG5cdGhhc1JlcXVpcmVkX2dldFZhbHVlID0gMTtcblx0ZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcblx0ICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcblx0fVxuXG5cdF9nZXRWYWx1ZSA9IGdldFZhbHVlO1xuXHRyZXR1cm4gX2dldFZhbHVlO1xufVxuXG52YXIgX2dldE5hdGl2ZTtcbnZhciBoYXNSZXF1aXJlZF9nZXROYXRpdmU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfZ2V0TmF0aXZlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2dldE5hdGl2ZSkgcmV0dXJuIF9nZXROYXRpdmU7XG5cdGhhc1JlcXVpcmVkX2dldE5hdGl2ZSA9IDE7XG5cdHZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlX2Jhc2VJc05hdGl2ZSgpLFxuXHQgICAgZ2V0VmFsdWUgPSByZXF1aXJlX2dldFZhbHVlKCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG5cdCAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuXHQgIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcblx0ICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuXHR9XG5cblx0X2dldE5hdGl2ZSA9IGdldE5hdGl2ZTtcblx0cmV0dXJuIF9nZXROYXRpdmU7XG59XG5cbnZhciBfbmF0aXZlQ3JlYXRlO1xudmFyIGhhc1JlcXVpcmVkX25hdGl2ZUNyZWF0ZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9uYXRpdmVDcmVhdGUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbmF0aXZlQ3JlYXRlKSByZXR1cm4gX25hdGl2ZUNyZWF0ZTtcblx0aGFzUmVxdWlyZWRfbmF0aXZlQ3JlYXRlID0gMTtcblx0dmFyIGdldE5hdGl2ZSA9IHJlcXVpcmVfZ2V0TmF0aXZlKCk7XG5cblx0LyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuXHR2YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5cdF9uYXRpdmVDcmVhdGUgPSBuYXRpdmVDcmVhdGU7XG5cdHJldHVybiBfbmF0aXZlQ3JlYXRlO1xufVxuXG52YXIgX2hhc2hDbGVhcjtcbnZhciBoYXNSZXF1aXJlZF9oYXNoQ2xlYXI7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfaGFzaENsZWFyICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2hhc2hDbGVhcikgcmV0dXJuIF9oYXNoQ2xlYXI7XG5cdGhhc1JlcXVpcmVkX2hhc2hDbGVhciA9IDE7XG5cdHZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlX25hdGl2ZUNyZWF0ZSgpO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBjbGVhclxuXHQgKiBAbWVtYmVyT2YgSGFzaFxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuXHQgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcblx0ICB0aGlzLnNpemUgPSAwO1xuXHR9XG5cblx0X2hhc2hDbGVhciA9IGhhc2hDbGVhcjtcblx0cmV0dXJuIF9oYXNoQ2xlYXI7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5cbnZhciBfaGFzaERlbGV0ZTtcbnZhciBoYXNSZXF1aXJlZF9oYXNoRGVsZXRlO1xuXG5mdW5jdGlvbiByZXF1aXJlX2hhc2hEZWxldGUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfaGFzaERlbGV0ZSkgcmV0dXJuIF9oYXNoRGVsZXRlO1xuXHRoYXNSZXF1aXJlZF9oYXNoRGVsZXRlID0gMTtcblx0ZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcblx0ICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuXHQgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0X2hhc2hEZWxldGUgPSBoYXNoRGVsZXRlO1xuXHRyZXR1cm4gX2hhc2hEZWxldGU7XG59XG5cbnZhciBfaGFzaEdldDtcbnZhciBoYXNSZXF1aXJlZF9oYXNoR2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlX2hhc2hHZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfaGFzaEdldCkgcmV0dXJuIF9oYXNoR2V0O1xuXHRoYXNSZXF1aXJlZF9oYXNoR2V0ID0gMTtcblx0dmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmVfbmF0aXZlQ3JlYXRlKCk7XG5cblx0LyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuXHR2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGdldFxuXHQgKiBAbWVtYmVyT2YgSGFzaFxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cdCAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcblx0ICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuXHQgIH1cblx0ICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xuXHR9XG5cblx0X2hhc2hHZXQgPSBoYXNoR2V0O1xuXHRyZXR1cm4gX2hhc2hHZXQ7XG59XG5cbnZhciBfaGFzaEhhcztcbnZhciBoYXNSZXF1aXJlZF9oYXNoSGFzO1xuXG5mdW5jdGlvbiByZXF1aXJlX2hhc2hIYXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfaGFzaEhhcykgcmV0dXJuIF9oYXNoSGFzO1xuXHRoYXNSZXF1aXJlZF9oYXNoSGFzID0gMTtcblx0dmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmVfbmF0aXZlQ3JlYXRlKCk7XG5cblx0LyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xuXHR2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5cdC8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xuXHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBoYXNcblx0ICogQG1lbWJlck9mIEhhc2hcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG5cdCAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuXHQgIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuXHR9XG5cblx0X2hhc2hIYXMgPSBoYXNoSGFzO1xuXHRyZXR1cm4gX2hhc2hIYXM7XG59XG5cbnZhciBfaGFzaFNldDtcbnZhciBoYXNSZXF1aXJlZF9oYXNoU2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlX2hhc2hTZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfaGFzaFNldCkgcmV0dXJuIF9oYXNoU2V0O1xuXHRoYXNSZXF1aXJlZF9oYXNoU2V0ID0gMTtcblx0dmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmVfbmF0aXZlQ3JlYXRlKCk7XG5cblx0LyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xuXHR2YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgc2V0XG5cdCAqIEBtZW1iZXJPZiBIYXNoXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG5cdCAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcblx0ICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcblx0ICByZXR1cm4gdGhpcztcblx0fVxuXG5cdF9oYXNoU2V0ID0gaGFzaFNldDtcblx0cmV0dXJuIF9oYXNoU2V0O1xufVxuXG52YXIgX0hhc2g7XG52YXIgaGFzUmVxdWlyZWRfSGFzaDtcblxuZnVuY3Rpb24gcmVxdWlyZV9IYXNoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX0hhc2gpIHJldHVybiBfSGFzaDtcblx0aGFzUmVxdWlyZWRfSGFzaCA9IDE7XG5cdHZhciBoYXNoQ2xlYXIgPSByZXF1aXJlX2hhc2hDbGVhcigpLFxuXHQgICAgaGFzaERlbGV0ZSA9IHJlcXVpcmVfaGFzaERlbGV0ZSgpLFxuXHQgICAgaGFzaEdldCA9IHJlcXVpcmVfaGFzaEdldCgpLFxuXHQgICAgaGFzaEhhcyA9IHJlcXVpcmVfaGFzaEhhcygpLFxuXHQgICAgaGFzaFNldCA9IHJlcXVpcmVfaGFzaFNldCgpO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cblx0ICovXG5cdGZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cblx0ICB0aGlzLmNsZWFyKCk7XG5cdCAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuXHQgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcblx0ICB9XG5cdH1cblxuXHQvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5cdEhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuXHRIYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuXHRIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuXHRIYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuXHRIYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5cdF9IYXNoID0gSGFzaDtcblx0cmV0dXJuIF9IYXNoO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cblxudmFyIF9saXN0Q2FjaGVDbGVhcjtcbnZhciBoYXNSZXF1aXJlZF9saXN0Q2FjaGVDbGVhcjtcblxuZnVuY3Rpb24gcmVxdWlyZV9saXN0Q2FjaGVDbGVhciAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9saXN0Q2FjaGVDbGVhcikgcmV0dXJuIF9saXN0Q2FjaGVDbGVhcjtcblx0aGFzUmVxdWlyZWRfbGlzdENhY2hlQ2xlYXIgPSAxO1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcblx0ICB0aGlzLl9fZGF0YV9fID0gW107XG5cdCAgdGhpcy5zaXplID0gMDtcblx0fVxuXG5cdF9saXN0Q2FjaGVDbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuXHRyZXR1cm4gX2xpc3RDYWNoZUNsZWFyO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cblxudmFyIGVxXzE7XG52YXIgaGFzUmVxdWlyZWRFcTtcblxuZnVuY3Rpb24gcmVxdWlyZUVxICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkRXEpIHJldHVybiBlcV8xO1xuXHRoYXNSZXF1aXJlZEVxID0gMTtcblx0ZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG5cdCAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG5cdH1cblxuXHRlcV8xID0gZXE7XG5cdHJldHVybiBlcV8xO1xufVxuXG52YXIgX2Fzc29jSW5kZXhPZjtcbnZhciBoYXNSZXF1aXJlZF9hc3NvY0luZGV4T2Y7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYXNzb2NJbmRleE9mICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Fzc29jSW5kZXhPZikgcmV0dXJuIF9hc3NvY0luZGV4T2Y7XG5cdGhhc1JlcXVpcmVkX2Fzc29jSW5kZXhPZiA9IDE7XG5cdHZhciBlcSA9IHJlcXVpcmVFcSgpO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuXHQgKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuXHQgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdCAgd2hpbGUgKGxlbmd0aC0tKSB7XG5cdCAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuXHQgICAgICByZXR1cm4gbGVuZ3RoO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gLTE7XG5cdH1cblxuXHRfYXNzb2NJbmRleE9mID0gYXNzb2NJbmRleE9mO1xuXHRyZXR1cm4gX2Fzc29jSW5kZXhPZjtcbn1cblxudmFyIF9saXN0Q2FjaGVEZWxldGU7XG52YXIgaGFzUmVxdWlyZWRfbGlzdENhY2hlRGVsZXRlO1xuXG5mdW5jdGlvbiByZXF1aXJlX2xpc3RDYWNoZURlbGV0ZSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9saXN0Q2FjaGVEZWxldGUpIHJldHVybiBfbGlzdENhY2hlRGVsZXRlO1xuXHRoYXNSZXF1aXJlZF9saXN0Q2FjaGVEZWxldGUgPSAxO1xuXHR2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZV9hc3NvY0luZGV4T2YoKTtcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5cdC8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xuXHR2YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBkZWxldGVcblx0ICogQG1lbWJlck9mIExpc3RDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuXHQgKi9cblx0ZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuXHQgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcblx0ICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuXHQgIGlmIChpbmRleCA8IDApIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcblx0ICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG5cdCAgICBkYXRhLnBvcCgpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG5cdCAgfVxuXHQgIC0tdGhpcy5zaXplO1xuXHQgIHJldHVybiB0cnVlO1xuXHR9XG5cblx0X2xpc3RDYWNoZURlbGV0ZSA9IGxpc3RDYWNoZURlbGV0ZTtcblx0cmV0dXJuIF9saXN0Q2FjaGVEZWxldGU7XG59XG5cbnZhciBfbGlzdENhY2hlR2V0O1xudmFyIGhhc1JlcXVpcmVkX2xpc3RDYWNoZUdldDtcblxuZnVuY3Rpb24gcmVxdWlyZV9saXN0Q2FjaGVHZXQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbGlzdENhY2hlR2V0KSByZXR1cm4gX2xpc3RDYWNoZUdldDtcblx0aGFzUmVxdWlyZWRfbGlzdENhY2hlR2V0ID0gMTtcblx0dmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmVfYXNzb2NJbmRleE9mKCk7XG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBnZXRcblx0ICogQG1lbWJlck9mIExpc3RDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuXHQgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcblx0ICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuXHQgIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcblx0fVxuXG5cdF9saXN0Q2FjaGVHZXQgPSBsaXN0Q2FjaGVHZXQ7XG5cdHJldHVybiBfbGlzdENhY2hlR2V0O1xufVxuXG52YXIgX2xpc3RDYWNoZUhhcztcbnZhciBoYXNSZXF1aXJlZF9saXN0Q2FjaGVIYXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbGlzdENhY2hlSGFzICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2xpc3RDYWNoZUhhcykgcmV0dXJuIF9saXN0Q2FjaGVIYXM7XG5cdGhhc1JlcXVpcmVkX2xpc3RDYWNoZUhhcyA9IDE7XG5cdHZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlX2Fzc29jSW5kZXhPZigpO1xuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGhhc1xuXHQgKiBAbWVtYmVyT2YgTGlzdENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG5cdCAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG5cdH1cblxuXHRfbGlzdENhY2hlSGFzID0gbGlzdENhY2hlSGFzO1xuXHRyZXR1cm4gX2xpc3RDYWNoZUhhcztcbn1cblxudmFyIF9saXN0Q2FjaGVTZXQ7XG52YXIgaGFzUmVxdWlyZWRfbGlzdENhY2hlU2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlX2xpc3RDYWNoZVNldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9saXN0Q2FjaGVTZXQpIHJldHVybiBfbGlzdENhY2hlU2V0O1xuXHRoYXNSZXF1aXJlZF9saXN0Q2FjaGVTZXQgPSAxO1xuXHR2YXIgYXNzb2NJbmRleE9mID0gcmVxdWlyZV9hc3NvY0luZGV4T2YoKTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBzZXRcblx0ICogQG1lbWJlck9mIExpc3RDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuXHQgKi9cblx0ZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcblx0ICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG5cdCAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cblx0ICBpZiAoaW5kZXggPCAwKSB7XG5cdCAgICArK3RoaXMuc2l6ZTtcblx0ICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gdGhpcztcblx0fVxuXG5cdF9saXN0Q2FjaGVTZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cdHJldHVybiBfbGlzdENhY2hlU2V0O1xufVxuXG52YXIgX0xpc3RDYWNoZTtcbnZhciBoYXNSZXF1aXJlZF9MaXN0Q2FjaGU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfTGlzdENhY2hlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX0xpc3RDYWNoZSkgcmV0dXJuIF9MaXN0Q2FjaGU7XG5cdGhhc1JlcXVpcmVkX0xpc3RDYWNoZSA9IDE7XG5cdHZhciBsaXN0Q2FjaGVDbGVhciA9IHJlcXVpcmVfbGlzdENhY2hlQ2xlYXIoKSxcblx0ICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmVfbGlzdENhY2hlRGVsZXRlKCksXG5cdCAgICBsaXN0Q2FjaGVHZXQgPSByZXF1aXJlX2xpc3RDYWNoZUdldCgpLFxuXHQgICAgbGlzdENhY2hlSGFzID0gcmVxdWlyZV9saXN0Q2FjaGVIYXMoKSxcblx0ICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmVfbGlzdENhY2hlU2V0KCk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cblx0ICovXG5cdGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuXHQgIHRoaXMuY2xlYXIoKTtcblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG5cdCAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuXHQgIH1cblx0fVxuXG5cdC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuXHRMaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5cdExpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuXHRMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcblx0TGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5cdExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG5cdF9MaXN0Q2FjaGUgPSBMaXN0Q2FjaGU7XG5cdHJldHVybiBfTGlzdENhY2hlO1xufVxuXG52YXIgX01hcDtcbnZhciBoYXNSZXF1aXJlZF9NYXA7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfTWFwICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX01hcCkgcmV0dXJuIF9NYXA7XG5cdGhhc1JlcXVpcmVkX01hcCA9IDE7XG5cdHZhciBnZXROYXRpdmUgPSByZXF1aXJlX2dldE5hdGl2ZSgpLFxuXHQgICAgcm9vdCA9IHJlcXVpcmVfcm9vdCgpO1xuXG5cdC8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cblx0dmFyIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyk7XG5cblx0X01hcCA9IE1hcDtcblx0cmV0dXJuIF9NYXA7XG59XG5cbnZhciBfbWFwQ2FjaGVDbGVhcjtcbnZhciBoYXNSZXF1aXJlZF9tYXBDYWNoZUNsZWFyO1xuXG5mdW5jdGlvbiByZXF1aXJlX21hcENhY2hlQ2xlYXIgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbWFwQ2FjaGVDbGVhcikgcmV0dXJuIF9tYXBDYWNoZUNsZWFyO1xuXHRoYXNSZXF1aXJlZF9tYXBDYWNoZUNsZWFyID0gMTtcblx0dmFyIEhhc2ggPSByZXF1aXJlX0hhc2goKSxcblx0ICAgIExpc3RDYWNoZSA9IHJlcXVpcmVfTGlzdENhY2hlKCksXG5cdCAgICBNYXAgPSByZXF1aXJlX01hcCgpO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGNsZWFyXG5cdCAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcblx0ICB0aGlzLnNpemUgPSAwO1xuXHQgIHRoaXMuX19kYXRhX18gPSB7XG5cdCAgICAnaGFzaCc6IG5ldyBIYXNoLFxuXHQgICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG5cdCAgICAnc3RyaW5nJzogbmV3IEhhc2hcblx0ICB9O1xuXHR9XG5cblx0X21hcENhY2hlQ2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuXHRyZXR1cm4gX21hcENhY2hlQ2xlYXI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5cbnZhciBfaXNLZXlhYmxlO1xudmFyIGhhc1JlcXVpcmVkX2lzS2V5YWJsZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9pc0tleWFibGUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfaXNLZXlhYmxlKSByZXR1cm4gX2lzS2V5YWJsZTtcblx0aGFzUmVxdWlyZWRfaXNLZXlhYmxlID0gMTtcblx0ZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG5cdCAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdCAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcblx0ICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcblx0ICAgIDogKHZhbHVlID09PSBudWxsKTtcblx0fVxuXG5cdF9pc0tleWFibGUgPSBpc0tleWFibGU7XG5cdHJldHVybiBfaXNLZXlhYmxlO1xufVxuXG52YXIgX2dldE1hcERhdGE7XG52YXIgaGFzUmVxdWlyZWRfZ2V0TWFwRGF0YTtcblxuZnVuY3Rpb24gcmVxdWlyZV9nZXRNYXBEYXRhICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2dldE1hcERhdGEpIHJldHVybiBfZ2V0TWFwRGF0YTtcblx0aGFzUmVxdWlyZWRfZ2V0TWFwRGF0YSA9IDE7XG5cdHZhciBpc0tleWFibGUgPSByZXF1aXJlX2lzS2V5YWJsZSgpO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG5cdCAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG5cdCAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG5cdCAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuXHQgICAgOiBkYXRhLm1hcDtcblx0fVxuXG5cdF9nZXRNYXBEYXRhID0gZ2V0TWFwRGF0YTtcblx0cmV0dXJuIF9nZXRNYXBEYXRhO1xufVxuXG52YXIgX21hcENhY2hlRGVsZXRlO1xudmFyIGhhc1JlcXVpcmVkX21hcENhY2hlRGVsZXRlO1xuXG5mdW5jdGlvbiByZXF1aXJlX21hcENhY2hlRGVsZXRlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX21hcENhY2hlRGVsZXRlKSByZXR1cm4gX21hcENhY2hlRGVsZXRlO1xuXHRoYXNSZXF1aXJlZF9tYXBDYWNoZURlbGV0ZSA9IDE7XG5cdHZhciBnZXRNYXBEYXRhID0gcmVxdWlyZV9nZXRNYXBEYXRhKCk7XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGRlbGV0ZVxuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuXHQgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG5cdCAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRfbWFwQ2FjaGVEZWxldGUgPSBtYXBDYWNoZURlbGV0ZTtcblx0cmV0dXJuIF9tYXBDYWNoZURlbGV0ZTtcbn1cblxudmFyIF9tYXBDYWNoZUdldDtcbnZhciBoYXNSZXF1aXJlZF9tYXBDYWNoZUdldDtcblxuZnVuY3Rpb24gcmVxdWlyZV9tYXBDYWNoZUdldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9tYXBDYWNoZUdldCkgcmV0dXJuIF9tYXBDYWNoZUdldDtcblx0aGFzUmVxdWlyZWRfbWFwQ2FjaGVHZXQgPSAxO1xuXHR2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmVfZ2V0TWFwRGF0YSgpO1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbmFtZSBnZXRcblx0ICogQG1lbWJlck9mIE1hcENhY2hlXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcblx0ICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xuXHR9XG5cblx0X21hcENhY2hlR2V0ID0gbWFwQ2FjaGVHZXQ7XG5cdHJldHVybiBfbWFwQ2FjaGVHZXQ7XG59XG5cbnZhciBfbWFwQ2FjaGVIYXM7XG52YXIgaGFzUmVxdWlyZWRfbWFwQ2FjaGVIYXM7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbWFwQ2FjaGVIYXMgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfbWFwQ2FjaGVIYXMpIHJldHVybiBfbWFwQ2FjaGVIYXM7XG5cdGhhc1JlcXVpcmVkX21hcENhY2hlSGFzID0gMTtcblx0dmFyIGdldE1hcERhdGEgPSByZXF1aXJlX2dldE1hcERhdGEoKTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBuYW1lIGhhc1xuXHQgKiBAbWVtYmVyT2YgTWFwQ2FjaGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuXHQgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG5cdH1cblxuXHRfbWFwQ2FjaGVIYXMgPSBtYXBDYWNoZUhhcztcblx0cmV0dXJuIF9tYXBDYWNoZUhhcztcbn1cblxudmFyIF9tYXBDYWNoZVNldDtcbnZhciBoYXNSZXF1aXJlZF9tYXBDYWNoZVNldDtcblxuZnVuY3Rpb24gcmVxdWlyZV9tYXBDYWNoZVNldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9tYXBDYWNoZVNldCkgcmV0dXJuIF9tYXBDYWNoZVNldDtcblx0aGFzUmVxdWlyZWRfbWFwQ2FjaGVTZXQgPSAxO1xuXHR2YXIgZ2V0TWFwRGF0YSA9IHJlcXVpcmVfZ2V0TWFwRGF0YSgpO1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQG5hbWUgc2V0XG5cdCAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG5cdCAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG5cdCAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cblx0ICBkYXRhLnNldChrZXksIHZhbHVlKTtcblx0ICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcblx0ICByZXR1cm4gdGhpcztcblx0fVxuXG5cdF9tYXBDYWNoZVNldCA9IG1hcENhY2hlU2V0O1xuXHRyZXR1cm4gX21hcENhY2hlU2V0O1xufVxuXG52YXIgX01hcENhY2hlO1xudmFyIGhhc1JlcXVpcmVkX01hcENhY2hlO1xuXG5mdW5jdGlvbiByZXF1aXJlX01hcENhY2hlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX01hcENhY2hlKSByZXR1cm4gX01hcENhY2hlO1xuXHRoYXNSZXF1aXJlZF9NYXBDYWNoZSA9IDE7XG5cdHZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZV9tYXBDYWNoZUNsZWFyKCksXG5cdCAgICBtYXBDYWNoZURlbGV0ZSA9IHJlcXVpcmVfbWFwQ2FjaGVEZWxldGUoKSxcblx0ICAgIG1hcENhY2hlR2V0ID0gcmVxdWlyZV9tYXBDYWNoZUdldCgpLFxuXHQgICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlX21hcENhY2hlSGFzKCksXG5cdCAgICBtYXBDYWNoZVNldCA9IHJlcXVpcmVfbWFwQ2FjaGVTZXQoKTtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG5cdCAgdmFyIGluZGV4ID0gLTEsXG5cdCAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuXHQgIHRoaXMuY2xlYXIoKTtcblx0ICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHQgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG5cdCAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuXHQgIH1cblx0fVxuXG5cdC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5cdE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5cdE1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcblx0TWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuXHRNYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5cdE1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuXHRfTWFwQ2FjaGUgPSBNYXBDYWNoZTtcblx0cmV0dXJuIF9NYXBDYWNoZTtcbn1cblxudmFyIG1lbW9pemVfMTtcbnZhciBoYXNSZXF1aXJlZE1lbW9pemU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVNZW1vaXplICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkTWVtb2l6ZSkgcmV0dXJuIG1lbW9pemVfMTtcblx0aGFzUmVxdWlyZWRNZW1vaXplID0gMTtcblx0dmFyIE1hcENhY2hlID0gcmVxdWlyZV9NYXBDYWNoZSgpO1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cblx0dmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcblx0ICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuXHQgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcblx0ICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2Bcblx0ICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG5cdCAqXG5cdCAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcblx0ICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG5cdCAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG5cdCAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG5cdCAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSAwLjEuMFxuXHQgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuXHQgKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG5cdCAqXG5cdCAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuXHQgKiB2YWx1ZXMob2JqZWN0KTtcblx0ICogLy8gPT4gWzEsIDJdXG5cdCAqXG5cdCAqIHZhbHVlcyhvdGhlcik7XG5cdCAqIC8vID0+IFszLCA0XVxuXHQgKlxuXHQgKiBvYmplY3QuYSA9IDI7XG5cdCAqIHZhbHVlcyhvYmplY3QpO1xuXHQgKiAvLyA9PiBbMSwgMl1cblx0ICpcblx0ICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG5cdCAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcblx0ICogdmFsdWVzKG9iamVjdCk7XG5cdCAqIC8vID0+IFsnYScsICdiJ11cblx0ICpcblx0ICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cblx0ICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcblx0ICovXG5cdGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcblx0ICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcblx0ICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcblx0ICB9XG5cdCAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG5cdCAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcblx0ICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcblx0ICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG5cdCAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcblx0ICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG5cdCAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHQgIH07XG5cdCAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuXHQgIHJldHVybiBtZW1vaXplZDtcblx0fVxuXG5cdC8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxuXHRtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cblx0bWVtb2l6ZV8xID0gbWVtb2l6ZTtcblx0cmV0dXJuIG1lbW9pemVfMTtcbn1cblxudmFyIF9tZW1vaXplQ2FwcGVkO1xudmFyIGhhc1JlcXVpcmVkX21lbW9pemVDYXBwZWQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfbWVtb2l6ZUNhcHBlZCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9tZW1vaXplQ2FwcGVkKSByZXR1cm4gX21lbW9pemVDYXBwZWQ7XG5cdGhhc1JlcXVpcmVkX21lbW9pemVDYXBwZWQgPSAxO1xuXHR2YXIgbWVtb2l6ZSA9IHJlcXVpcmVNZW1vaXplKCk7XG5cblx0LyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xuXHR2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuXHQvKipcblx0ICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuXHQgKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG5cdCAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG5cdCAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuXHQgICAgICBjYWNoZS5jbGVhcigpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGtleTtcblx0ICB9KTtcblxuXHQgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0X21lbW9pemVDYXBwZWQgPSBtZW1vaXplQ2FwcGVkO1xuXHRyZXR1cm4gX21lbW9pemVDYXBwZWQ7XG59XG5cbnZhciBfc3RyaW5nVG9QYXRoO1xudmFyIGhhc1JlcXVpcmVkX3N0cmluZ1RvUGF0aDtcblxuZnVuY3Rpb24gcmVxdWlyZV9zdHJpbmdUb1BhdGggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfc3RyaW5nVG9QYXRoKSByZXR1cm4gX3N0cmluZ1RvUGF0aDtcblx0aGFzUmVxdWlyZWRfc3RyaW5nVG9QYXRoID0gMTtcblx0dmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlX21lbW9pemVDYXBwZWQoKTtcblxuXHQvKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG5cdHZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG5cdC8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xuXHR2YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cblx0ICovXG5cdHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuXHQgIHZhciByZXN1bHQgPSBbXTtcblx0ICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcblx0ICAgIHJlc3VsdC5wdXNoKCcnKTtcblx0ICB9XG5cdCAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHQgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuXHQgIH0pO1xuXHQgIHJldHVybiByZXN1bHQ7XG5cdH0pO1xuXG5cdF9zdHJpbmdUb1BhdGggPSBzdHJpbmdUb1BhdGg7XG5cdHJldHVybiBfc3RyaW5nVG9QYXRoO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuXG52YXIgX2FycmF5TWFwO1xudmFyIGhhc1JlcXVpcmVkX2FycmF5TWFwO1xuXG5mdW5jdGlvbiByZXF1aXJlX2FycmF5TWFwICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2FycmF5TWFwKSByZXR1cm4gX2FycmF5TWFwO1xuXHRoYXNSZXF1aXJlZF9hcnJheU1hcCA9IDE7XG5cdGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcblx0ICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0X2FycmF5TWFwID0gYXJyYXlNYXA7XG5cdHJldHVybiBfYXJyYXlNYXA7XG59XG5cbnZhciBfYmFzZVRvU3RyaW5nO1xudmFyIGhhc1JlcXVpcmVkX2Jhc2VUb1N0cmluZztcblxuZnVuY3Rpb24gcmVxdWlyZV9iYXNlVG9TdHJpbmcgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYmFzZVRvU3RyaW5nKSByZXR1cm4gX2Jhc2VUb1N0cmluZztcblx0aGFzUmVxdWlyZWRfYmFzZVRvU3RyaW5nID0gMTtcblx0dmFyIFN5bWJvbCA9IHJlcXVpcmVfU3ltYm9sKCksXG5cdCAgICBhcnJheU1hcCA9IHJlcXVpcmVfYXJyYXlNYXAoKSxcblx0ICAgIGlzQXJyYXkgPSByZXF1aXJlSXNBcnJheSgpLFxuXHQgICAgaXNTeW1ib2wgPSByZXF1aXJlSXNTeW1ib2woKTtcblxuXHQvKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cblx0dmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcblx0ICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG5cdCAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcblx0ICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuXHQgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcblx0ICAgIHJldHVybiB2YWx1ZTtcblx0ICB9XG5cdCAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuXHQgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG5cdCAgfVxuXHQgIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcblx0ICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG5cdCAgfVxuXHQgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG5cdCAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JbmZpbml0eSkgPyAnLTAnIDogcmVzdWx0O1xuXHR9XG5cblx0X2Jhc2VUb1N0cmluZyA9IGJhc2VUb1N0cmluZztcblx0cmV0dXJuIF9iYXNlVG9TdHJpbmc7XG59XG5cbnZhciB0b1N0cmluZ18xO1xudmFyIGhhc1JlcXVpcmVkVG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHJlcXVpcmVUb1N0cmluZyAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFRvU3RyaW5nKSByZXR1cm4gdG9TdHJpbmdfMTtcblx0aGFzUmVxdWlyZWRUb1N0cmluZyA9IDE7XG5cdHZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlX2Jhc2VUb1N0cmluZygpO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuXHQgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgNC4wLjBcblx0ICogQGNhdGVnb3J5IExhbmdcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cblx0ICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cblx0ICogQGV4YW1wbGVcblx0ICpcblx0ICogXy50b1N0cmluZyhudWxsKTtcblx0ICogLy8gPT4gJydcblx0ICpcblx0ICogXy50b1N0cmluZygtMCk7XG5cdCAqIC8vID0+ICctMCdcblx0ICpcblx0ICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuXHQgKiAvLyA9PiAnMSwyLDMnXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuXHQgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuXHR9XG5cblx0dG9TdHJpbmdfMSA9IHRvU3RyaW5nO1xuXHRyZXR1cm4gdG9TdHJpbmdfMTtcbn1cblxudmFyIF9jYXN0UGF0aDtcbnZhciBoYXNSZXF1aXJlZF9jYXN0UGF0aDtcblxuZnVuY3Rpb24gcmVxdWlyZV9jYXN0UGF0aCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9jYXN0UGF0aCkgcmV0dXJuIF9jYXN0UGF0aDtcblx0aGFzUmVxdWlyZWRfY2FzdFBhdGggPSAxO1xuXHR2YXIgaXNBcnJheSA9IHJlcXVpcmVJc0FycmF5KCksXG5cdCAgICBpc0tleSA9IHJlcXVpcmVfaXNLZXkoKSxcblx0ICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmVfc3RyaW5nVG9QYXRoKCksXG5cdCAgICB0b1N0cmluZyA9IHJlcXVpcmVUb1N0cmluZygpO1xuXG5cdC8qKlxuXHQgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuXHQgKi9cblx0ZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuXHQgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG5cdH1cblxuXHRfY2FzdFBhdGggPSBjYXN0UGF0aDtcblx0cmV0dXJuIF9jYXN0UGF0aDtcbn1cblxudmFyIF90b0tleTtcbnZhciBoYXNSZXF1aXJlZF90b0tleTtcblxuZnVuY3Rpb24gcmVxdWlyZV90b0tleSAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF90b0tleSkgcmV0dXJuIF90b0tleTtcblx0aGFzUmVxdWlyZWRfdG9LZXkgPSAxO1xuXHR2YXIgaXNTeW1ib2wgPSByZXF1aXJlSXNTeW1ib2woKTtcblxuXHQvKipcblx0ICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcblx0ICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHQgIH1cblx0ICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuXHQgIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSW5maW5pdHkpID8gJy0wJyA6IHJlc3VsdDtcblx0fVxuXG5cdF90b0tleSA9IHRvS2V5O1xuXHRyZXR1cm4gX3RvS2V5O1xufVxuXG52YXIgX2Jhc2VHZXQ7XG52YXIgaGFzUmVxdWlyZWRfYmFzZUdldDtcblxuZnVuY3Rpb24gcmVxdWlyZV9iYXNlR2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Jhc2VHZXQpIHJldHVybiBfYmFzZUdldDtcblx0aGFzUmVxdWlyZWRfYmFzZUdldCA9IDE7XG5cdHZhciBjYXN0UGF0aCA9IHJlcXVpcmVfY2FzdFBhdGgoKSxcblx0ICAgIHRvS2V5ID0gcmVxdWlyZV90b0tleSgpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cblx0ICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cblx0ICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcblx0ICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuXHQgIHZhciBpbmRleCA9IDAsXG5cdCAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG5cdCAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuXHQgIH1cblx0ICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG5cdH1cblxuXHRfYmFzZUdldCA9IGJhc2VHZXQ7XG5cdHJldHVybiBfYmFzZUdldDtcbn1cblxudmFyIGdldF8xO1xudmFyIGhhc1JlcXVpcmVkR2V0O1xuXG5mdW5jdGlvbiByZXF1aXJlR2V0ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkR2V0KSByZXR1cm4gZ2V0XzE7XG5cdGhhc1JlcXVpcmVkR2V0ID0gMTtcblx0dmFyIGJhc2VHZXQgPSByZXF1aXJlX2Jhc2VHZXQoKTtcblxuXHQvKipcblx0ICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcblx0ICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG5cdCAqXG5cdCAqIEBzdGF0aWNcblx0ICogQG1lbWJlck9mIF9cblx0ICogQHNpbmNlIDMuNy4wXG5cdCAqIEBjYXRlZ29yeSBPYmplY3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuXHQgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuXHQgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG5cdCAqXG5cdCAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG5cdCAqIC8vID0+IDNcblx0ICpcblx0ICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG5cdCAqIC8vID0+IDNcblx0ICpcblx0ICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuXHQgKiAvLyA9PiAnZGVmYXVsdCdcblx0ICovXG5cdGZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuXHQgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblx0ICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG5cdH1cblxuXHRnZXRfMSA9IGdldDtcblx0cmV0dXJuIGdldF8xO1xufVxuXG52YXIgZ2V0RXhwb3J0cyA9IHJlcXVpcmVHZXQoKTtcbnZhciBnZXQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZ2V0RXhwb3J0cyk7XG5cbnZhciBfZGVmaW5lUHJvcGVydHk7XG52YXIgaGFzUmVxdWlyZWRfZGVmaW5lUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfZGVmaW5lUHJvcGVydHkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfZGVmaW5lUHJvcGVydHkpIHJldHVybiBfZGVmaW5lUHJvcGVydHk7XG5cdGhhc1JlcXVpcmVkX2RlZmluZVByb3BlcnR5ID0gMTtcblx0dmFyIGdldE5hdGl2ZSA9IHJlcXVpcmVfZ2V0TmF0aXZlKCk7XG5cblx0dmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuXHQgIHRyeSB7XG5cdCAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuXHQgICAgZnVuYyh7fSwgJycsIHt9KTtcblx0ICAgIHJldHVybiBmdW5jO1xuXHQgIH0gY2F0Y2ggKGUpIHt9XG5cdH0oKSk7XG5cblx0X2RlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHk7XG5cdHJldHVybiBfZGVmaW5lUHJvcGVydHk7XG59XG5cbnZhciBfYmFzZUFzc2lnblZhbHVlO1xudmFyIGhhc1JlcXVpcmVkX2Jhc2VBc3NpZ25WYWx1ZTtcblxuZnVuY3Rpb24gcmVxdWlyZV9iYXNlQXNzaWduVmFsdWUgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfYmFzZUFzc2lnblZhbHVlKSByZXR1cm4gX2Jhc2VBc3NpZ25WYWx1ZTtcblx0aGFzUmVxdWlyZWRfYmFzZUFzc2lnblZhbHVlID0gMTtcblx0dmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZV9kZWZpbmVQcm9wZXJ0eSgpO1xuXG5cdC8qKlxuXHQgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuXHQgKiB2YWx1ZSBjaGVja3MuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG5cdCAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuXHQgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcblx0ICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG5cdCAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcblx0ICAgICAgJ3ZhbHVlJzogdmFsdWUsXG5cdCAgICAgICd3cml0YWJsZSc6IHRydWVcblx0ICAgIH0pO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuXHQgIH1cblx0fVxuXG5cdF9iYXNlQXNzaWduVmFsdWUgPSBiYXNlQXNzaWduVmFsdWU7XG5cdHJldHVybiBfYmFzZUFzc2lnblZhbHVlO1xufVxuXG52YXIgX2Fzc2lnblZhbHVlO1xudmFyIGhhc1JlcXVpcmVkX2Fzc2lnblZhbHVlO1xuXG5mdW5jdGlvbiByZXF1aXJlX2Fzc2lnblZhbHVlICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkX2Fzc2lnblZhbHVlKSByZXR1cm4gX2Fzc2lnblZhbHVlO1xuXHRoYXNSZXF1aXJlZF9hc3NpZ25WYWx1ZSA9IDE7XG5cdHZhciBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlX2Jhc2VBc3NpZ25WYWx1ZSgpLFxuXHQgICAgZXEgPSByZXF1aXJlRXEoKTtcblxuXHQvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cdHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cblx0LyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG5cdC8qKlxuXHQgKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG5cdCAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG5cdCAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cblx0ICovXG5cdGZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuXHQgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuXHQgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG5cdCAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG5cdCAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcblx0ICB9XG5cdH1cblxuXHRfYXNzaWduVmFsdWUgPSBhc3NpZ25WYWx1ZTtcblx0cmV0dXJuIF9hc3NpZ25WYWx1ZTtcbn1cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cbnZhciBfaXNJbmRleDtcbnZhciBoYXNSZXF1aXJlZF9pc0luZGV4O1xuXG5mdW5jdGlvbiByZXF1aXJlX2lzSW5kZXggKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfaXNJbmRleCkgcmV0dXJuIF9pc0luZGV4O1xuXHRoYXNSZXF1aXJlZF9pc0luZGV4ID0gMTtcblx0dmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG5cdC8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cblx0dmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG5cdCAqL1xuXHRmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcblx0ICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cblx0ICByZXR1cm4gISFsZW5ndGggJiZcblx0ICAgICh0eXBlID09ICdudW1iZXInIHx8XG5cdCAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcblx0ICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG5cdH1cblxuXHRfaXNJbmRleCA9IGlzSW5kZXg7XG5cdHJldHVybiBfaXNJbmRleDtcbn1cblxudmFyIF9iYXNlU2V0O1xudmFyIGhhc1JlcXVpcmVkX2Jhc2VTZXQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVfYmFzZVNldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZF9iYXNlU2V0KSByZXR1cm4gX2Jhc2VTZXQ7XG5cdGhhc1JlcXVpcmVkX2Jhc2VTZXQgPSAxO1xuXHR2YXIgYXNzaWduVmFsdWUgPSByZXF1aXJlX2Fzc2lnblZhbHVlKCksXG5cdCAgICBjYXN0UGF0aCA9IHJlcXVpcmVfY2FzdFBhdGgoKSxcblx0ICAgIGlzSW5kZXggPSByZXF1aXJlX2lzSW5kZXgoKSxcblx0ICAgIGlzT2JqZWN0ID0gcmVxdWlyZUlzT2JqZWN0KCksXG5cdCAgICB0b0tleSA9IHJlcXVpcmVfdG9LZXkoKTtcblxuXHQvKipcblx0ICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cblx0ICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG5cdCAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG5cdCAgICByZXR1cm4gb2JqZWN0O1xuXHQgIH1cblx0ICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuXHQgIHZhciBpbmRleCA9IC0xLFxuXHQgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcblx0ICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMSxcblx0ICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG5cdCAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcblx0ICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksXG5cdCAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuXHQgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcblx0ICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuXHQgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcblx0ICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuXHQgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIG5ld1ZhbHVlID0gaXNPYmplY3Qob2JqVmFsdWUpXG5cdCAgICAgICAgICA/IG9ialZhbHVlXG5cdCAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcblx0ICAgIG5lc3RlZCA9IG5lc3RlZFtrZXldO1xuXHQgIH1cblx0ICByZXR1cm4gb2JqZWN0O1xuXHR9XG5cblx0X2Jhc2VTZXQgPSBiYXNlU2V0O1xuXHRyZXR1cm4gX2Jhc2VTZXQ7XG59XG5cbnZhciBzZXRfMTtcbnZhciBoYXNSZXF1aXJlZFNldDtcblxuZnVuY3Rpb24gcmVxdWlyZVNldCAoKSB7XG5cdGlmIChoYXNSZXF1aXJlZFNldCkgcmV0dXJuIHNldF8xO1xuXHRoYXNSZXF1aXJlZFNldCA9IDE7XG5cdHZhciBiYXNlU2V0ID0gcmVxdWlyZV9iYXNlU2V0KCk7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuXHQgKiBpdCdzIGNyZWF0ZWQuIEFycmF5cyBhcmUgY3JlYXRlZCBmb3IgbWlzc2luZyBpbmRleCBwcm9wZXJ0aWVzIHdoaWxlIG9iamVjdHNcblx0ICogYXJlIGNyZWF0ZWQgZm9yIGFsbCBvdGhlciBtaXNzaW5nIHByb3BlcnRpZXMuIFVzZSBgXy5zZXRXaXRoYCB0byBjdXN0b21pemVcblx0ICogYHBhdGhgIGNyZWF0aW9uLlxuXHQgKlxuXHQgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cblx0ICpcblx0ICogQHN0YXRpY1xuXHQgKiBAbWVtYmVyT2YgX1xuXHQgKiBAc2luY2UgMy43LjBcblx0ICogQGNhdGVnb3J5IE9iamVjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuXHQgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG5cdCAqIEBleGFtcGxlXG5cdCAqXG5cdCAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG5cdCAqXG5cdCAqIF8uc2V0KG9iamVjdCwgJ2FbMF0uYi5jJywgNCk7XG5cdCAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG5cdCAqIC8vID0+IDRcblx0ICpcblx0ICogXy5zZXQob2JqZWN0LCBbJ3gnLCAnMCcsICd5JywgJ3onXSwgNSk7XG5cdCAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG5cdCAqIC8vID0+IDVcblx0ICovXG5cdGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG5cdCAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlKTtcblx0fVxuXG5cdHNldF8xID0gc2V0O1xuXHRyZXR1cm4gc2V0XzE7XG59XG5cbnZhciBzZXRFeHBvcnRzID0gcmVxdWlyZVNldCgpO1xudmFyIHNldCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzZXRFeHBvcnRzKTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5cbnZhciBfY29weUFycmF5O1xudmFyIGhhc1JlcXVpcmVkX2NvcHlBcnJheTtcblxuZnVuY3Rpb24gcmVxdWlyZV9jb3B5QXJyYXkgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRfY29weUFycmF5KSByZXR1cm4gX2NvcHlBcnJheTtcblx0aGFzUmVxdWlyZWRfY29weUFycmF5ID0gMTtcblx0ZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcblx0ICB2YXIgaW5kZXggPSAtMSxcblx0ICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuXHQgIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuXHQgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdCAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuXHQgIH1cblx0ICByZXR1cm4gYXJyYXk7XG5cdH1cblxuXHRfY29weUFycmF5ID0gY29weUFycmF5O1xuXHRyZXR1cm4gX2NvcHlBcnJheTtcbn1cblxudmFyIHRvUGF0aF8xO1xudmFyIGhhc1JlcXVpcmVkVG9QYXRoO1xuXG5mdW5jdGlvbiByZXF1aXJlVG9QYXRoICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkVG9QYXRoKSByZXR1cm4gdG9QYXRoXzE7XG5cdGhhc1JlcXVpcmVkVG9QYXRoID0gMTtcblx0dmFyIGFycmF5TWFwID0gcmVxdWlyZV9hcnJheU1hcCgpLFxuXHQgICAgY29weUFycmF5ID0gcmVxdWlyZV9jb3B5QXJyYXkoKSxcblx0ICAgIGlzQXJyYXkgPSByZXF1aXJlSXNBcnJheSgpLFxuXHQgICAgaXNTeW1ib2wgPSByZXF1aXJlSXNTeW1ib2woKSxcblx0ICAgIHN0cmluZ1RvUGF0aCA9IHJlcXVpcmVfc3RyaW5nVG9QYXRoKCksXG5cdCAgICB0b0tleSA9IHJlcXVpcmVfdG9LZXkoKSxcblx0ICAgIHRvU3RyaW5nID0gcmVxdWlyZVRvU3RyaW5nKCk7XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuXHQgKlxuXHQgKiBAc3RhdGljXG5cdCAqIEBtZW1iZXJPZiBfXG5cdCAqIEBzaW5jZSA0LjAuMFxuXHQgKiBAY2F0ZWdvcnkgVXRpbFxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuXHQgKiBAZXhhbXBsZVxuXHQgKlxuXHQgKiBfLnRvUGF0aCgnYS5iLmMnKTtcblx0ICogLy8gPT4gWydhJywgJ2InLCAnYyddXG5cdCAqXG5cdCAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuXHQgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuXHQgKi9cblx0ZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG5cdCAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcblx0ICB9XG5cdCAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuXHR9XG5cblx0dG9QYXRoXzEgPSB0b1BhdGg7XG5cdHJldHVybiB0b1BhdGhfMTtcbn1cblxudmFyIHRvUGF0aEV4cG9ydHMgPSByZXF1aXJlVG9QYXRoKCk7XG52YXIgdG9QYXRoID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHRvUGF0aEV4cG9ydHMpO1xuXG52YXIgZGVmaW5lJDIgPSB7XG4gIC8vIGFjY2VzcyBkYXRhIGZpZWxkXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEocGFyYW1zKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBpbW11dGFibGVLZXlzOiB7fSxcbiAgICAgIC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgICAgdXBkYXRlU3R5bGU6IGZhbHNlLFxuICAgICAgYmVmb3JlR2V0OiBmdW5jdGlvbiBiZWZvcmVHZXQoc2VsZikge30sXG4gICAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChzZWxmLCBvYmopIHt9LFxuICAgICAgb25TZXQ6IGZ1bmN0aW9uIG9uU2V0KHNlbGYpIHt9LFxuICAgICAgY2FuU2V0OiBmdW5jdGlvbiBjYW5TZXQoc2VsZikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHBhcmFtcyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGFJbXBsKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgdmFyIHNpbmdsZSA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGZbMF0gOiBzZWxmO1xuXG4gICAgICAvLyAuZGF0YSgnZm9vJywgLi4uKVxuICAgICAgaWYgKHN0cmluZyhuYW1lKSkge1xuICAgICAgICAvLyBzZXQgb3IgZ2V0IHByb3BlcnR5XG4gICAgICAgIHZhciBpc1BhdGhMaWtlID0gbmFtZS5pbmRleE9mKCcuJykgIT09IC0xOyAvLyB0aGVyZSBtaWdodCBiZSBhIG5vcm1hbCBmaWVsZCB3aXRoIGEgZG90IFxuICAgICAgICB2YXIgcGF0aCA9IGlzUGF0aExpa2UgJiYgdG9QYXRoKG5hbWUpO1xuXG4gICAgICAgIC8vIC5kYXRhKCdmb28nKVxuICAgICAgICBpZiAocC5hbGxvd0dldHRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldFxuXG4gICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgICBwLmJlZm9yZUdldChzaW5nbGUpO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBpdCdzIHBhdGggYW5kIGEgZmllbGQgd2l0aCB0aGUgc2FtZSBuYW1lIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChwYXRoICYmIHNpbmdsZS5fcHJpdmF0ZVtwLmZpZWxkXVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldCA9IGdldChzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF0sIHBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuXG4gICAgICAgICAgLy8gLmRhdGEoJ2ZvbycsICdiYXInKVxuICAgICAgICB9IGVsc2UgaWYgKHAuYWxsb3dTZXR0aW5nICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBzZXRcbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW25hbWVdO1xuICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZSA9IF9kZWZpbmVQcm9wZXJ0eSQxKHt9LCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICBwLmJlZm9yZVNldChzZWxmLCBjaGFuZ2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICAgICAgIGlmIChwLmNhblNldChlbGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggJiYgc2luZ2xlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHNldChlbGUuX3ByaXZhdGVbcC5maWVsZF0sIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZWxlLl9wcml2YXRlW3AuZmllbGRdW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgICAgICBpZiAocC51cGRhdGVTdHlsZSkge1xuICAgICAgICAgICAgICBzZWxmLnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNhbGwgb25TZXQgY2FsbGJhY2tcbiAgICAgICAgICAgIHAub25TZXQoc2VsZik7XG4gICAgICAgICAgICBpZiAocC5zZXR0aW5nVHJpZ2dlcnNFdmVudCkge1xuICAgICAgICAgICAgICBzZWxmW3AudHJpZ2dlckZuTmFtZV0ocC5zZXR0aW5nRXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC5kYXRhKHsgJ2Zvbyc6ICdiYXInIH0pXG4gICAgICB9IGVsc2UgaWYgKHAuYWxsb3dTZXR0aW5nICYmIHBsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgIC8vIGV4dGVuZFxuICAgICAgICB2YXIgb2JqID0gbmFtZTtcbiAgICAgICAgdmFyIGssIHY7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgcC5iZWZvcmVTZXQoc2VsZiwgb2JqKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgayA9IGtleXNbX2ldO1xuICAgICAgICAgIHYgPSBvYmpba107XG4gICAgICAgICAgdmFyIF92YWxpZCA9ICFwLmltbXV0YWJsZUtleXNba107XG4gICAgICAgICAgaWYgKF92YWxpZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9lbGUgPSBhbGxbal07XG4gICAgICAgICAgICAgIGlmIChwLmNhblNldChfZWxlKSkge1xuICAgICAgICAgICAgICAgIF9lbGUuX3ByaXZhdGVbcC5maWVsZF1ba10gPSB2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcbiAgICAgICAgaWYgKHAudXBkYXRlU3R5bGUpIHtcbiAgICAgICAgICBzZWxmLnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgIHAub25TZXQoc2VsZik7XG4gICAgICAgIGlmIChwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuc2V0dGluZ0V2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC5kYXRhKGZ1bmN0aW9uKCl7IC4uLiB9KVxuICAgICAgfSBlbHNlIGlmIChwLmFsbG93QmluZGluZyAmJiBmbiQ2KG5hbWUpKSB7XG4gICAgICAgIC8vIGJpbmQgdG8gZXZlbnRcbiAgICAgICAgdmFyIGZuID0gbmFtZTtcbiAgICAgICAgc2VsZi5vbihwLmJpbmRpbmdFdmVudCwgZm4pO1xuXG4gICAgICAgIC8vIC5kYXRhKClcbiAgICAgIH0gZWxzZSBpZiAocC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgdmFyIF9yZXQ7XG4gICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICBwLmJlZm9yZUdldChzaW5nbGUpO1xuICAgICAgICAgIF9yZXQgPSBzaW5nbGUuX3ByaXZhdGVbcC5maWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5hYmlsaXR5XG4gICAgfTsgLy8gZnVuY3Rpb25cbiAgfSxcbiAgLy8gZGF0YVxuXG4gIC8vIHJlbW92ZSBkYXRhIGZpZWxkXG4gIHJlbW92ZURhdGE6IGZ1bmN0aW9uIHJlbW92ZURhdGEocGFyYW1zKSB7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge30gLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgfTtcbiAgICBwYXJhbXMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVEYXRhSW1wbChuYW1lcykge1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcblxuICAgICAgLy8gLnJlbW92ZURhdGEoJ2ZvbyBiYXInKVxuICAgICAgaWYgKHN0cmluZyhuYW1lcykpIHtcbiAgICAgICAgLy8gdGhlbiBnZXQgdGhlIGxpc3Qgb2Yga2V5cywgYW5kIGRlbGV0ZSB0aGVtXG4gICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAvLyBkZWxldGUgZWFjaCBub24tZW1wdHkga2V5XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGVtcHR5U3RyaW5nKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tleV07IC8vIG5vdCB2YWxpZCBpZiBpbW11dGFibGVcbiAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKyspIHtcbiAgICAgICAgICAgICAgYWxsW2lfYV0uX3ByaXZhdGVbcC5maWVsZF1ba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAudHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLnJlbW92ZURhdGEoKVxuICAgICAgfSBlbHNlIGlmIChuYW1lcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRoZW4gZGVsZXRlIGFsbCBrZXlzXG5cbiAgICAgICAgZm9yICh2YXIgX2lfYSA9IDAsIF9sX2EgPSBhbGwubGVuZ3RoOyBfaV9hIDwgX2xfYTsgX2lfYSsrKSB7XG4gICAgICAgICAgdmFyIF9wcml2YXRlRmllbGRzID0gYWxsW19pX2FdLl9wcml2YXRlW3AuZmllbGRdO1xuICAgICAgICAgIHZhciBfa2V5cyA9IE9iamVjdC5rZXlzKF9wcml2YXRlRmllbGRzKTtcbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBfa2V5cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICB2YXIgX2tleSA9IF9rZXlzW19pMl07XG4gICAgICAgICAgICB2YXIgdmFsaWRLZXlUb0RlbGV0ZSA9ICFwLmltbXV0YWJsZUtleXNbX2tleV07XG4gICAgICAgICAgICBpZiAodmFsaWRLZXlUb0RlbGV0ZSkge1xuICAgICAgICAgICAgICBfcHJpdmF0ZUZpZWxkc1tfa2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAudHJpZ2dlckV2ZW50KSB7XG4gICAgICAgICAgc2VsZltwLnRyaWdnZXJGbk5hbWVdKHAuZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICB9OyAvLyBmdW5jdGlvblxuICB9IC8vIHJlbW92ZURhdGFcbn07IC8vIGRlZmluZVxuXG52YXIgZGVmaW5lJDEgPSB7XG4gIGV2ZW50QWxpYXNlc09uOiBmdW5jdGlvbiBldmVudEFsaWFzZXNPbihwcm90bykge1xuICAgIHZhciBwID0gcHJvdG87XG4gICAgcC5hZGRMaXN0ZW5lciA9IHAubGlzdGVuID0gcC5iaW5kID0gcC5vbjtcbiAgICBwLnVubGlzdGVuID0gcC51bmJpbmQgPSBwLm9mZiA9IHAucmVtb3ZlTGlzdGVuZXI7XG4gICAgcC50cmlnZ2VyID0gcC5lbWl0O1xuXG4gICAgLy8gdGhpcyBpcyBqdXN0IGEgd3JhcHBlciBhbGlhcyBvZiAub24oKVxuICAgIHAucG9uID0gcC5wcm9taXNlT24gPSBmdW5jdGlvbiAoZXZlbnRzLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlKSB7XG4gICAgICAgICAgc2VsZi5vZmYuYXBwbHkoc2VsZiwgb2ZmQXJncyk7XG4gICAgICAgICAgcmVzb2x2ZShlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uQXJncyA9IGFyZ3MuY29uY2F0KFtjYWxsYmFja10pO1xuICAgICAgICB2YXIgb2ZmQXJncyA9IG9uQXJncy5jb25jYXQoW10pO1xuICAgICAgICBzZWxmLm9uLmFwcGx5KHNlbGYsIG9uQXJncyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59OyAvLyBkZWZpbmVcblxuLy8gdXNlIHRoaXMgbW9kdWxlIHRvIGNoZXJyeSBwaWNrIGZ1bmN0aW9ucyBpbnRvIHlvdXIgcHJvdG90eXBlXG4vLyAodXNlZnVsIGZvciBmdW5jdGlvbnMgc2hhcmVkIGJldHdlZW4gdGhlIGNvcmUgYW5kIGNvbGxlY3Rpb25zLCBmb3IgZXhhbXBsZSlcblxudmFyIGRlZmluZSA9IHt9O1xuW2RlZmluZSQzLCBkZWZpbmUkMiwgZGVmaW5lJDFdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgZXh0ZW5kKGRlZmluZSwgbSk7XG59KTtcblxudmFyIGVsZXNmbiRpID0ge1xuICBhbmltYXRlOiBkZWZpbmUuYW5pbWF0ZSgpLFxuICBhbmltYXRpb246IGRlZmluZS5hbmltYXRpb24oKSxcbiAgYW5pbWF0ZWQ6IGRlZmluZS5hbmltYXRlZCgpLFxuICBjbGVhclF1ZXVlOiBkZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICBkZWxheTogZGVmaW5lLmRlbGF5KCksXG4gIGRlbGF5QW5pbWF0aW9uOiBkZWZpbmUuZGVsYXlBbmltYXRpb24oKSxcbiAgc3RvcDogZGVmaW5lLnN0b3AoKVxufTtcblxudmFyIGVsZXNmbiRoID0ge1xuICBjbGFzc2VzOiBmdW5jdGlvbiBjbGFzc2VzKF9jbGFzc2VzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChfY2xhc3NlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICBzZWxmWzBdLl9wcml2YXRlLmNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgIHJldHVybiByZXQucHVzaChjbHMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gZWxzZSBpZiAoIWFycmF5KF9jbGFzc2VzKSkge1xuICAgICAgLy8gZXh0cmFjdCBjbGFzc2VzIGZyb20gc3RyaW5nXG4gICAgICBfY2xhc3NlcyA9IChfY2xhc3NlcyB8fCAnJykubWF0Y2goL1xcUysvZykgfHwgW107XG4gICAgfVxuICAgIHZhciBjaGFuZ2VkID0gW107XG4gICAgdmFyIGNsYXNzZXNTZXQgPSBuZXcgU2V0JDEoX2NsYXNzZXMpO1xuXG4gICAgLy8gY2hlY2sgYW5kIHVwZGF0ZSBlYWNoIGVsZVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGVsZSA9IHNlbGZbal07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgZWxlQ2xhc3NlcyA9IF9wLmNsYXNzZXM7XG4gICAgICB2YXIgY2hhbmdlZEVsZSA9IGZhbHNlO1xuXG4gICAgICAvLyBjaGVjayBpZiBlbGUgaGFzIGFsbCBvZiB0aGUgcGFzc2VkIGNsYXNzZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2NsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNscyA9IF9jbGFzc2VzW2ldO1xuICAgICAgICB2YXIgZWxlSGFzQ2xhc3MgPSBlbGVDbGFzc2VzLmhhcyhjbHMpO1xuICAgICAgICBpZiAoIWVsZUhhc0NsYXNzKSB7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgZWxlIGhhcyBjbGFzc2VzIG91dHNpZGUgb2YgdGhvc2UgcGFzc2VkXG4gICAgICBpZiAoIWNoYW5nZWRFbGUpIHtcbiAgICAgICAgY2hhbmdlZEVsZSA9IGVsZUNsYXNzZXMuc2l6ZSAhPT0gX2NsYXNzZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZWRFbGUpIHtcbiAgICAgICAgX3AuY2xhc3NlcyA9IGNsYXNzZXNTZXQ7XG4gICAgICAgIGNoYW5nZWQucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgIGlmIChjaGFuZ2VkLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuc3Bhd24oY2hhbmdlZCkudXBkYXRlU3R5bGUoKS5lbWl0KCdjbGFzcycpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcbiAgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGVDbGFzcyhjbGFzc2VzLCB0cnVlKTtcbiAgfSxcbiAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUgIT0gbnVsbCAmJiBlbGUuX3ByaXZhdGUuY2xhc3Nlcy5oYXMoY2xhc3NOYW1lKTtcbiAgfSxcbiAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uIHRvZ2dsZUNsYXNzKGNsYXNzZXMsIHRvZ2dsZSkge1xuICAgIGlmICghYXJyYXkoY2xhc3NlcykpIHtcbiAgICAgIC8vIGV4dHJhY3QgY2xhc3NlcyBmcm9tIHN0cmluZ1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMubWF0Y2goL1xcUysvZykgfHwgW107XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdG9nZ2xlVW5kZWZkID0gdG9nZ2xlID09PSB1bmRlZmluZWQ7XG4gICAgdmFyIGNoYW5nZWQgPSBbXTsgLy8gZWxlcyB3aG8gaGFkIGNsYXNzZXMgY2hhbmdlZFxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gc2VsZi5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gc2VsZltpXTtcbiAgICAgIHZhciBlbGVDbGFzc2VzID0gZWxlLl9wcml2YXRlLmNsYXNzZXM7XG4gICAgICB2YXIgY2hhbmdlZEVsZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2pdO1xuICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGVDbGFzc2VzLmhhcyhjbHMpO1xuICAgICAgICB2YXIgY2hhbmdlZE5vdyA9IGZhbHNlO1xuICAgICAgICBpZiAodG9nZ2xlIHx8IHRvZ2dsZVVuZGVmZCAmJiAhaGFzQ2xhc3MpIHtcbiAgICAgICAgICBlbGVDbGFzc2VzLmFkZChjbHMpO1xuICAgICAgICAgIGNoYW5nZWROb3cgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCF0b2dnbGUgfHwgdG9nZ2xlVW5kZWZkICYmIGhhc0NsYXNzKSB7XG4gICAgICAgICAgZWxlQ2xhc3Nlc1tcImRlbGV0ZVwiXShjbHMpO1xuICAgICAgICAgIGNoYW5nZWROb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hhbmdlZEVsZSAmJiBjaGFuZ2VkTm93KSB7XG4gICAgICAgICAgY2hhbmdlZC5wdXNoKGVsZSk7XG4gICAgICAgICAgY2hhbmdlZEVsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIGogY2xhc3Nlc1xuICAgIH0gLy8gZm9yIGkgZWxlc1xuXG4gICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgaWYgKGNoYW5nZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zcGF3bihjaGFuZ2VkKS51cGRhdGVTdHlsZSgpLmVtaXQoJ2NsYXNzJyk7XG4gICAgfVxuICAgIHJldHVybiBzZWxmO1xuICB9LFxuICByZW1vdmVDbGFzczogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoY2xhc3Nlcykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIGZhbHNlKTtcbiAgfSxcbiAgZmxhc2hDbGFzczogZnVuY3Rpb24gZmxhc2hDbGFzcyhjbGFzc2VzLCBkdXJhdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgZHVyYXRpb24gPSAyNTA7XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgcmV0dXJuIHNlbGY7IC8vIG5vdGhpbmcgdG8gZG8gcmVhbGx5XG4gICAgfVxuICAgIHNlbGYuYWRkQ2xhc3MoY2xhc3Nlcyk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLnJlbW92ZUNsYXNzKGNsYXNzZXMpO1xuICAgIH0sIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxufTtcbmVsZXNmbiRoLmNsYXNzTmFtZSA9IGVsZXNmbiRoLmNsYXNzTmFtZXMgPSBlbGVzZm4kaC5jbGFzc2VzO1xuXG4vLyB0b2tlbnMgaW4gdGhlIHF1ZXJ5IGxhbmd1YWdlXG52YXIgdG9rZW5zID0ge1xuICBtZXRhQ2hhcjogJ1tcXFxcIVxcXFxcIlxcXFwjXFxcXCRcXFxcJVxcXFwmXFxcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcLlxcXFwvXFxcXDpcXFxcO1xcXFw8XFxcXD1cXFxcPlxcXFw/XFxcXEBcXFxcW1xcXFxdXFxcXF5cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XScsXG4gIC8vIGNoYXJzIHdlIG5lZWQgdG8gZXNjYXBlIGluIGxldCBuYW1lcywgZXRjXG4gIGNvbXBhcmF0b3JPcDogJz18XFxcXCE9fD58Pj18PHw8PXxcXFxcJD18XFxcXF49fFxcXFwqPScsXG4gIC8vIGJpbmFyeSBjb21wYXJpc29uIG9wICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICBib29sT3A6ICdcXFxcP3xcXFxcIXxcXFxcXicsXG4gIC8vIGJvb2xlYW4gKHVuYXJ5KSBvcGVyYXRvcnMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gIHN0cmluZzogJ1wiKD86XFxcXFxcXFxcInxbXlwiXSkqXCInICsgJ3wnICsgXCInKD86XFxcXFxcXFwnfFteJ10pKidcIixcbiAgLy8gc3RyaW5nIGxpdGVyYWxzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLSBkb3VibGVxdW90ZXMgfCBzaW5nbGVxdW90ZXNcbiAgbnVtYmVyOiBudW1iZXIsXG4gIC8vIG51bWJlciBsaXRlcmFsICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLS0gZS5nLiAwLjEyMzQsIDEyMzQsIDEyZTEyM1xuICBtZXRhOiAnZGVncmVlfGluZGVncmVlfG91dGRlZ3JlZScsXG4gIC8vIGFsbG93ZWQgbWV0YWRhdGEgZmllbGRzIChpLmUuIGFsbG93ZWQgZnVuY3Rpb25zIHRvIHVzZSBmcm9tIENvbGxlY3Rpb24pXG4gIHNlcGFyYXRvcjogJ1xcXFxzKixcXFxccyonLFxuICAvLyBxdWVyaWVzIGFyZSBzZXBhcmF0ZWQgYnkgY29tbWFzLCBlLmcuIGVkZ2VbZm9vID0gJ2JhciddLCBub2RlLnNvbWVDbGFzc1xuICBkZXNjZW5kYW50OiAnXFxcXHMrJyxcbiAgY2hpbGQ6ICdcXFxccys+XFxcXHMrJyxcbiAgc3ViamVjdDogJ1xcXFwkJyxcbiAgZ3JvdXA6ICdub2RlfGVkZ2V8XFxcXConLFxuICBkaXJlY3RlZEVkZ2U6ICdcXFxccystPlxcXFxzKycsXG4gIHVuZGlyZWN0ZWRFZGdlOiAnXFxcXHMrPC0+XFxcXHMrJ1xufTtcbnRva2Vucy52YXJpYWJsZSA9ICcoPzpbXFxcXHctLl18KD86XFxcXFxcXFwnICsgdG9rZW5zLm1ldGFDaGFyICsgJykpKyc7IC8vIGEgdmFyaWFibGUgbmFtZSBjYW4gaGF2ZSBsZXR0ZXJzLCBudW1iZXJzLCBkYXNoZXMsIGFuZCBwZXJpb2RzXG50b2tlbnMuY2xhc3NOYW1lID0gJyg/OltcXFxcdy1dfCg/OlxcXFxcXFxcJyArIHRva2Vucy5tZXRhQ2hhciArICcpKSsnOyAvLyBhIGNsYXNzIG5hbWUgaGFzIHRoZSBzYW1lIHJ1bGVzIGFzIGEgdmFyaWFibGUgZXhjZXB0IGl0IGNhbid0IGhhdmUgYSAnLicgaW4gdGhlIG5hbWVcbnRva2Vucy52YWx1ZSA9IHRva2Vucy5zdHJpbmcgKyAnfCcgKyB0b2tlbnMubnVtYmVyOyAvLyBhIHZhbHVlIGxpdGVyYWwsIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXJcbnRva2Vucy5pZCA9IHRva2Vucy52YXJpYWJsZTsgLy8gYW4gZWxlbWVudCBpZCAoZm9sbG93cyB2YXJpYWJsZSBjb252ZW50aW9ucylcblxuKGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wcywgb3AsIGk7XG5cbiAgLy8gYWRkIEAgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG4gIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcbiAgZm9yIChpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgIG9wID0gb3BzW2ldO1xuICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xAJyArIG9wO1xuICB9XG5cbiAgLy8gYWRkICEgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG4gIG9wcyA9IHRva2Vucy5jb21wYXJhdG9yT3Auc3BsaXQoJ3wnKTtcbiAgZm9yIChpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgIG9wID0gb3BzW2ldO1xuICAgIGlmIChvcC5pbmRleE9mKCchJykgPj0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBza2lwIG9wcyB0aGF0IGV4cGxpY2l0bHkgY29udGFpbiAhXG4gICAgaWYgKG9wID09PSAnPScpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gc2tpcCA9IGIvYyAhPSBpcyBleHBsaWNpdGx5IGRlZmluZWRcblxuICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xcXFxcIScgKyBvcDtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBNYWtlIGEgbmV3IHF1ZXJ5IG9iamVjdFxuICpcbiAqIEBwcm9wIHR5cGUge1R5cGV9IFRoZSB0eXBlIGVudW0gKGludCkgb2YgdGhlIHF1ZXJ5XG4gKiBAcHJvcCBjaGVja3MgTGlzdCBvZiBjaGVja3MgdG8gbWFrZSBhZ2FpbnN0IGFuIGVsZSB0byB0ZXN0IGZvciBhIG1hdGNoXG4gKi9cbnZhciBuZXdRdWVyeSA9IGZ1bmN0aW9uIG5ld1F1ZXJ5KCkge1xuICByZXR1cm4ge1xuICAgIGNoZWNrczogW11cbiAgfTtcbn07XG5cbi8qKlxuICogQSBjaGVjayB0eXBlIGVudW0tbGlrZSBvYmplY3QuICBVc2VzIGludGVnZXIgdmFsdWVzIGZvciBmYXN0IG1hdGNoKCkgbG9va3VwLlxuICogVGhlIG9yZGVyaW5nIGRvZXMgbm90IG1hdHRlciBhcyBsb25nIGFzIHRoZSBpbnRzIGFyZSB1bmlxdWUuXG4gKi9cbnZhciBUeXBlID0ge1xuICAvKiogRS5nLiBub2RlICovXG4gIEdST1VQOiAwLFxuICAvKiogQSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzICovXG4gIENPTExFQ1RJT046IDEsXG4gIC8qKiBBIGZpbHRlcihlbGUpIGZ1bmN0aW9uICovXG4gIEZJTFRFUjogMixcbiAgLyoqIEUuZy4gW2ZvbyA+IDFdICovXG4gIERBVEFfQ09NUEFSRTogMyxcbiAgLyoqIEUuZy4gW2Zvb10gKi9cbiAgREFUQV9FWElTVDogNCxcbiAgLyoqIEUuZy4gWz9mb29dICovXG4gIERBVEFfQk9PTDogNSxcbiAgLyoqIEUuZy4gW1tkZWdyZWUgPiAyXV0gKi9cbiAgTUVUQV9DT01QQVJFOiA2LFxuICAvKiogRS5nLiA6c2VsZWN0ZWQgKi9cbiAgU1RBVEU6IDcsXG4gIC8qKiBFLmcuICNmb28gKi9cbiAgSUQ6IDgsXG4gIC8qKiBFLmcuIC5mb28gKi9cbiAgQ0xBU1M6IDksXG4gIC8qKiBFLmcuICNmb28gPC0+ICNiYXIgKi9cbiAgVU5ESVJFQ1RFRF9FREdFOiAxMCxcbiAgLyoqIEUuZy4gI2ZvbyAtPiAjYmFyICovXG4gIERJUkVDVEVEX0VER0U6IDExLFxuICAvKiogRS5nLiAkI2ZvbyAtPiAjYmFyICovXG4gIE5PREVfU09VUkNFOiAxMixcbiAgLyoqIEUuZy4gI2ZvbyAtPiAkI2JhciAqL1xuICBOT0RFX1RBUkdFVDogMTMsXG4gIC8qKiBFLmcuICQjZm9vIDwtPiAjYmFyICovXG4gIE5PREVfTkVJR0hCT1I6IDE0LFxuICAvKiogRS5nLiAjZm9vID4gI2JhciAqL1xuICBDSElMRDogMTUsXG4gIC8qKiBFLmcuICNmb28gI2JhciAqL1xuICBERVNDRU5EQU5UOiAxNixcbiAgLyoqIEUuZy4gJCNmb28gPiAjYmFyICovXG4gIFBBUkVOVDogMTcsXG4gIC8qKiBFLmcuICQjZm9vICNiYXIgKi9cbiAgQU5DRVNUT1I6IDE4LFxuICAvKiogRS5nLiAjZm9vID4gJGJhciA+ICNiYXogKi9cbiAgQ09NUE9VTkRfU1BMSVQ6IDE5LFxuICAvKiogQWx3YXlzIG1hdGNoZXMsIHVzZWZ1bCBwbGFjZWhvbGRlciBmb3Igc3ViamVjdCBpbiBgQ09NUE9VTkRfU1BMSVRgICovXG4gIFRSVUU6IDIwXG59O1xuXG52YXIgc3RhdGVTZWxlY3RvcnMgPSBbe1xuICBzZWxlY3RvcjogJzpzZWxlY3RlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5zZWxlY3RlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVuc2VsZWN0ZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnNlbGVjdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6c2VsZWN0YWJsZScsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5zZWxlY3RhYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5zZWxlY3RhYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6bG9ja2VkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmxvY2tlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOnVubG9ja2VkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp2aXNpYmxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnZpc2libGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpoaWRkZW4nLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzp0cmFuc3BhcmVudCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS50cmFuc3BhcmVudCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmdyYWJiZWQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuZ3JhYmJlZCgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmZyZWUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmdyYWJiZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpyZW1vdmVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLnJlbW92ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzppbnNpZGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLnJlbW92ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpncmFiYmFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuZ3JhYmJhYmxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5ncmFiYmFibGUnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiAhZWxlLmdyYWJiYWJsZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmFuaW1hdGVkJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmFuaW1hdGVkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6dW5hbmltYXRlZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUuYW5pbWF0ZWQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpwYXJlbnQnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNQYXJlbnQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpjaGlsZGxlc3MnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZGxlc3MoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpjaGlsZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pc0NoaWxkKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6b3JwaGFuJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzT3JwaGFuKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6bm9ub3JwaGFuJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzQ2hpbGQoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpjb21wb3VuZCcsXG4gIG1hdGNoZXM6IGZ1bmN0aW9uIG1hdGNoZXMoZWxlKSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgcmV0dXJuIGVsZS5pc1BhcmVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlLnNvdXJjZSgpLmlzUGFyZW50KCkgfHwgZWxlLnRhcmdldCgpLmlzUGFyZW50KCk7XG4gICAgfVxuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmxvb3AnLFxuICBtYXRjaGVzOiBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNMb29wKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6c2ltcGxlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmlzU2ltcGxlKCk7XG4gIH1cbn0sIHtcbiAgc2VsZWN0b3I6ICc6YWN0aXZlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmFjdGl2ZSgpO1xuICB9XG59LCB7XG4gIHNlbGVjdG9yOiAnOmluYWN0aXZlJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5hY3RpdmUoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpiYWNrZ3JvdW5kaW5nJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gZWxlLmJhY2tncm91bmRpbmcoKTtcbiAgfVxufSwge1xuICBzZWxlY3RvcjogJzpub25iYWNrZ3JvdW5kaW5nJyxcbiAgbWF0Y2hlczogZnVuY3Rpb24gbWF0Y2hlcyhlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5iYWNrZ3JvdW5kaW5nKCk7XG4gIH1cbn1dLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgLy8gbi5iLiBzZWxlY3RvcnMgdGhhdCBhcmUgc3RhcnRpbmcgc3Vic3RyaW5ncyBvZiBvdGhlcnMgbXVzdCBoYXZlIHRoZSBsb25nZXIgb25lcyBmaXJzdFxuICByZXR1cm4gZGVzY2VuZGluZyhhLnNlbGVjdG9yLCBiLnNlbGVjdG9yKTtcbn0pO1xudmFyIGxvb2t1cCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbFRvRm4gPSB7fTtcbiAgdmFyIHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVTZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBzID0gc3RhdGVTZWxlY3RvcnNbaV07XG4gICAgc2VsVG9GbltzLnNlbGVjdG9yXSA9IHMubWF0Y2hlcztcbiAgfVxuICByZXR1cm4gc2VsVG9Gbjtcbn0oKTtcbnZhciBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyA9IGZ1bmN0aW9uIHN0YXRlU2VsZWN0b3JNYXRjaGVzKHNlbCwgZWxlKSB7XG4gIHJldHVybiBsb29rdXBbc2VsXShlbGUpO1xufTtcbnZhciBzdGF0ZVNlbGVjdG9yUmVnZXggPSAnKCcgKyBzdGF0ZVNlbGVjdG9ycy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgcmV0dXJuIHMuc2VsZWN0b3I7XG59KS5qb2luKCd8JykgKyAnKSc7XG5cbi8vIHdoZW4gYSB0b2tlbiBsaWtlIGEgdmFyaWFibGUgaGFzIGVzY2FwZWQgbWV0YSBjaGFyYWN0ZXJzLCB3ZSBuZWVkIHRvIGNsZWFuIHRoZSBiYWNrc2xhc2hlcyBvdXRcbi8vIHNvIHRoYXQgdmFsdWVzIGdldCBjb21wYXJlZCBwcm9wZXJseSBpbiBTZWxlY3Rvci5maWx0ZXIoKVxudmFyIGNsZWFuTWV0YUNoYXJzID0gZnVuY3Rpb24gY2xlYW5NZXRhQ2hhcnMoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcXFxcXCgnICsgdG9rZW5zLm1ldGFDaGFyICsgJyknLCAnZycpLCBmdW5jdGlvbiAobWF0Y2gsICQxKSB7XG4gICAgcmV0dXJuICQxO1xuICB9KTtcbn07XG52YXIgcmVwbGFjZUxhc3RRdWVyeSA9IGZ1bmN0aW9uIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIGV4YW1pbmluZ1F1ZXJ5LCByZXBsYWNlbWVudFF1ZXJ5KSB7XG4gIHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdID0gcmVwbGFjZW1lbnRRdWVyeTtcbn07XG5cbi8vIE5PVEU6IGFkZCBuZXcgZXhwcmVzc2lvbiBzeW50YXggaGVyZSB0byBoYXZlIGl0IHJlY29nbmlzZWQgYnkgdGhlIHBhcnNlcjtcbi8vIC0gYSBxdWVyeSBjb250YWlucyBhbGwgYWRqYWNlbnQgKGkuZS4gbm8gc2VwYXJhdG9yIGluIGJldHdlZW4pIGV4cHJlc3Npb25zO1xuLy8gLSB0aGUgY3VycmVudCBxdWVyeSBpcyBzdG9yZWQgaW4gc2VsZWN0b3JbaV1cbi8vIC0geW91IG5lZWQgdG8gY2hlY2sgdGhlIHF1ZXJ5IG9iamVjdHMgaW4gbWF0Y2goKSBmb3IgaXQgYWN0dWFsbHkgZmlsdGVyIHByb3Blcmx5LCBidXQgdGhhdCdzIHByZXR0eSBzdHJhaWdodCBmb3J3YXJkXG52YXIgZXhwcnMgPSBbe1xuICBuYW1lOiAnZ3JvdXAnLFxuICAvLyBqdXN0IHVzZWQgZm9yIGlkZW50aWZ5aW5nIHdoZW4gZGVidWdnaW5nXG4gIHF1ZXJ5OiB0cnVlLFxuICByZWdleDogJygnICsgdG9rZW5zLmdyb3VwICsgJyknLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICBncm91cCA9IF9yZWYyWzBdO1xuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuR1JPVVAsXG4gICAgICB2YWx1ZTogZ3JvdXAgPT09ICcqJyA/IGdyb3VwIDogZ3JvdXAgKyAncydcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnc3RhdGUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6IHN0YXRlU2VsZWN0b3JSZWdleCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjMpIHtcbiAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMSksXG4gICAgICBzdGF0ZSA9IF9yZWY0WzBdO1xuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuU1RBVEUsXG4gICAgICB2YWx1ZTogc3RhdGVcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnaWQnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcIygnICsgdG9rZW5zLmlkICsgJyknLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5LCBfcmVmNSkge1xuICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAxKSxcbiAgICAgIGlkID0gX3JlZjZbMF07XG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5JRCxcbiAgICAgIHZhbHVlOiBjbGVhbk1ldGFDaGFycyhpZClcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnY2xhc3NOYW1lJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXC4oJyArIHRva2Vucy5jbGFzc05hbWUgKyAnKScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY3KSB7XG4gICAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDEpLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZjhbMF07XG4gICAgcXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgdHlwZTogVHlwZS5DTEFTUyxcbiAgICAgIHZhbHVlOiBjbGVhbk1ldGFDaGFycyhjbGFzc05hbWUpXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2RhdGFFeGlzdHMnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccypcXFxcXScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWY5KSB7XG4gICAgdmFyIF9yZWYxMCA9IF9zbGljZWRUb0FycmF5KF9yZWY5LCAxKSxcbiAgICAgIHZhcmlhYmxlID0gX3JlZjEwWzBdO1xuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuREFUQV9FWElTVCxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSlcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnZGF0YUNvbXBhcmUnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLnZhcmlhYmxlICsgJylcXFxccyooJyArIHRva2Vucy5jb21wYXJhdG9yT3AgKyAnKVxcXFxzKignICsgdG9rZW5zLnZhbHVlICsgJylcXFxccypcXFxcXScsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnksIF9yZWYxMSkge1xuICAgIHZhciBfcmVmMTIgPSBfc2xpY2VkVG9BcnJheShfcmVmMTEsIDMpLFxuICAgICAgdmFyaWFibGUgPSBfcmVmMTJbMF0sXG4gICAgICBjb21wYXJhdG9yT3AgPSBfcmVmMTJbMV0sXG4gICAgICB2YWx1ZSA9IF9yZWYxMlsyXTtcbiAgICB2YXIgdmFsdWVJc1N0cmluZyA9IG5ldyBSZWdFeHAoJ14nICsgdG9rZW5zLnN0cmluZyArICckJykuZXhlYyh2YWx1ZSkgIT0gbnVsbDtcbiAgICBpZiAodmFsdWVJc1N0cmluZykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgfVxuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuREFUQV9DT01QQVJFLFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKSxcbiAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnZGF0YUJvb2wnLFxuICBxdWVyeTogdHJ1ZSxcbiAgcmVnZXg6ICdcXFxcW1xcXFxzKignICsgdG9rZW5zLmJvb2xPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMudmFyaWFibGUgKyAnKVxcXFxzKlxcXFxdJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjEzKSB7XG4gICAgdmFyIF9yZWYxNCA9IF9zbGljZWRUb0FycmF5KF9yZWYxMywgMiksXG4gICAgICBib29sT3AgPSBfcmVmMTRbMF0sXG4gICAgICB2YXJpYWJsZSA9IF9yZWYxNFsxXTtcbiAgICBxdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICB0eXBlOiBUeXBlLkRBVEFfQk9PTCxcbiAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICBvcGVyYXRvcjogYm9vbE9wXG4gICAgfSk7XG4gIH1cbn0sIHtcbiAgbmFtZTogJ21ldGFDb21wYXJlJyxcbiAgcXVlcnk6IHRydWUsXG4gIHJlZ2V4OiAnXFxcXFtcXFxcW1xcXFxzKignICsgdG9rZW5zLm1ldGEgKyAnKVxcXFxzKignICsgdG9rZW5zLmNvbXBhcmF0b3JPcCArICcpXFxcXHMqKCcgKyB0b2tlbnMubnVtYmVyICsgJylcXFxccypcXFxcXVxcXFxdJyxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSwgX3JlZjE1KSB7XG4gICAgdmFyIF9yZWYxNiA9IF9zbGljZWRUb0FycmF5KF9yZWYxNSwgMyksXG4gICAgICBtZXRhID0gX3JlZjE2WzBdLFxuICAgICAgY29tcGFyYXRvck9wID0gX3JlZjE2WzFdLFxuICAgICAgbnVtYmVyID0gX3JlZjE2WzJdO1xuICAgIHF1ZXJ5LmNoZWNrcy5wdXNoKHtcbiAgICAgIHR5cGU6IFR5cGUuTUVUQV9DT01QQVJFLFxuICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKG1ldGEpLFxuICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlcilcbiAgICB9KTtcbiAgfVxufSwge1xuICBuYW1lOiAnbmV4dFF1ZXJ5JyxcbiAgc2VwYXJhdG9yOiB0cnVlLFxuICByZWdleDogdG9rZW5zLnNlcGFyYXRvcixcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIHZhciBjdXJyZW50U3ViamVjdCA9IHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0O1xuICAgIHZhciBlZGdlQ291bnQgPSBzZWxlY3Rvci5lZGdlQ291bnQ7XG4gICAgdmFyIGNvbXBvdW5kQ291bnQgPSBzZWxlY3Rvci5jb21wb3VuZENvdW50O1xuICAgIHZhciBsYXN0USA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjdXJyZW50U3ViamVjdCAhPSBudWxsKSB7XG4gICAgICBsYXN0US5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG4gICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgfVxuICAgIGxhc3RRLmVkZ2VDb3VudCA9IGVkZ2VDb3VudDtcbiAgICBsYXN0US5jb21wb3VuZENvdW50ID0gY29tcG91bmRDb3VudDtcbiAgICBzZWxlY3Rvci5lZGdlQ291bnQgPSAwO1xuICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQgPSAwO1xuXG4gICAgLy8gZ28gb24gdG8gbmV4dCBxdWVyeVxuICAgIHZhciBuZXh0UXVlcnkgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGgrK10gPSBuZXdRdWVyeSgpO1xuICAgIHJldHVybiBuZXh0UXVlcnk7IC8vIHRoaXMgaXMgdGhlIG5ldyBxdWVyeSB0byBiZSBmaWxsZWQgYnkgdGhlIGZvbGxvd2luZyBleHByc1xuICB9XG59LCB7XG4gIG5hbWU6ICdkaXJlY3RlZEVkZ2UnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuZGlyZWN0ZWRFZGdlLFxuICBwb3B1bGF0ZTogZnVuY3Rpb24gcG9wdWxhdGUoc2VsZWN0b3IsIHF1ZXJ5KSB7XG4gICAgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09IG51bGwpIHtcbiAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZVxuICAgICAgdmFyIGVkZ2VRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgc291cmNlID0gcXVlcnk7XG4gICAgICB2YXIgdGFyZ2V0ID0gbmV3UXVlcnkoKTtcbiAgICAgIGVkZ2VRdWVyeS5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuRElSRUNURURfRURHRSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgICB9KTtcblxuICAgICAgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIGVkZ2UgcmF0aGVyIHRoYW4gdGhlIHNvdXJjZVxuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgcXVlcnksIGVkZ2VRdWVyeSk7XG4gICAgICBzZWxlY3Rvci5lZGdlQ291bnQrKztcblxuICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIHRhcmdldCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzb3VyY2UvdGFyZ2V0XG4gICAgICB2YXIgc3JjVGd0USA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgX3NvdXJjZSA9IHF1ZXJ5O1xuICAgICAgdmFyIF90YXJnZXQgPSBuZXdRdWVyeSgpO1xuICAgICAgc3JjVGd0US5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuTk9ERV9TT1VSQ0UsXG4gICAgICAgIHNvdXJjZTogX3NvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBfdGFyZ2V0XG4gICAgICB9KTtcblxuICAgICAgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlIG5laWdoYm91cmhvb2QgcmF0aGVyIHRoYW4gdGhlIG5vZGVcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBzcmNUZ3RRKTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrO1xuICAgICAgcmV0dXJuIF90YXJnZXQ7IC8vIG5vdyBwb3B1bGF0aW5nIHRoZSB0YXJnZXQgd2l0aCB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb25zXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICd1bmRpcmVjdGVkRWRnZScsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy51bmRpcmVjdGVkRWRnZSxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyB1bmRpcmVjdGVkIGVkZ2VcbiAgICAgIHZhciBlZGdlUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHNvdXJjZSA9IHF1ZXJ5O1xuICAgICAgdmFyIHRhcmdldCA9IG5ld1F1ZXJ5KCk7XG4gICAgICBlZGdlUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLlVORElSRUNURURfRURHRSxcbiAgICAgICAgbm9kZXM6IFtzb3VyY2UsIHRhcmdldF1cbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGUgcXVlcnkgaW4gdGhlIHNlbGVjdG9yIHNob3VsZCBiZSB0aGUgZWRnZSByYXRoZXIgdGhhbiB0aGUgc291cmNlXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgZWRnZVF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmVkZ2VDb3VudCsrO1xuXG4gICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgdGFyZ2V0IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5laWdoYm91cmhvb2RcbiAgICAgIHZhciBuaG9vZFEgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIG5vZGUgPSBxdWVyeTtcbiAgICAgIHZhciBuZWlnaGJvciA9IG5ld1F1ZXJ5KCk7XG4gICAgICBuaG9vZFEuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLk5PREVfTkVJR0hCT1IsXG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIG5laWdoYm9yOiBuZWlnaGJvclxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSBuZWlnaGJvdXJob29kIHJhdGhlciB0aGFuIHRoZSBub2RlXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgbmhvb2RRKTtcbiAgICAgIHJldHVybiBuZWlnaGJvcjsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIG5laWdoYm9yIHdpdGggZm9sbG93aW5nIGV4cHJlc3Npb25zXG4gICAgfVxuICB9XG59LCB7XG4gIG5hbWU6ICdjaGlsZCcsXG4gIHNlcGFyYXRvcjogdHJ1ZSxcbiAgcmVnZXg6IHRva2Vucy5jaGlsZCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyBkZWZhdWx0OiBjaGlsZCBxdWVyeVxuICAgICAgdmFyIHBhcmVudENoaWxkUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIGNoaWxkID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBwYXJlbnQgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIHBhcmVudENoaWxkUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNISUxELFxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgY2hpbGQ6IGNoaWxkXG4gICAgICB9KTtcblxuICAgICAgLy8gdGhlIHF1ZXJ5IGluIHRoZSBzZWxlY3RvciBzaG91bGQgYmUgdGhlICc+JyBpdHNlbGZcbiAgICAgIHJlcGxhY2VMYXN0UXVlcnkoc2VsZWN0b3IsIHF1ZXJ5LCBwYXJlbnRDaGlsZFF1ZXJ5KTtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcblxuICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkIHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID09PSBxdWVyeSkge1xuICAgICAgLy8gY29tcG91bmQgc3BsaXQgcXVlcnlcbiAgICAgIHZhciBjb21wb3VuZCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgbGVmdCA9IHNlbGVjdG9yW3NlbGVjdG9yLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHJpZ2h0ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBzdWJqZWN0ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBfY2hpbGQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9wYXJlbnQgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAvLyBzZXQgdXAgdGhlIHJvb3QgY29tcG91bmQgcVxuICAgICAgY29tcG91bmQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTVBPVU5EX1NQTElULFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwb3B1bGF0ZSB0aGUgc3ViamVjdCBhbmQgcmVwbGFjZSB0aGUgcSBhdCB0aGUgb2xkIHNwb3QgKHdpdGhpbiBsZWZ0KSB3aXRoIFRSVUVcbiAgICAgIHN1YmplY3QuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0YWtlIHRoZSBjaGVja3MgZnJvbSB0aGUgbGVmdFxuICAgICAgcXVlcnkuY2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9XTsgLy8gY2hlY2tzIHVuZGVyIGxlZnQgcmVmcyB0aGUgc3ViamVjdCBpbXBsaWNpdGx5XG5cbiAgICAgIC8vIHNldCB1cCB0aGUgcmlnaHQgcVxuICAgICAgX3BhcmVudC5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuVFJVRVxuICAgICAgfSk7IC8vIHBhcmVudCBpbXBsaWNpdGx5IHJlZnMgdGhlIHN1YmplY3RcbiAgICAgIHJpZ2h0LmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5QQVJFTlQsXG4gICAgICAgIC8vIHR5cGUgaXMgc3dhcHBlZCBvbiByaWdodCBzaWRlIHF1ZXJpZXNcbiAgICAgICAgcGFyZW50OiBfcGFyZW50LFxuICAgICAgICBjaGlsZDogX2NoaWxkIC8vIGVtcHR5IGZvciBub3dcbiAgICAgIH0pO1xuICAgICAgcmVwbGFjZUxhc3RRdWVyeShzZWxlY3RvciwgbGVmdCwgY29tcG91bmQpO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIHJlZiBzaW5jZSB3ZSBtb3ZlZCB0aGluZ3MgYXJvdW5kIGZvciBgcXVlcnlgXG4gICAgICBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG4gICAgICByZXR1cm4gX2NoaWxkOyAvLyBub3cgcG9wdWxhdGluZyB0aGUgcmlnaHQgc2lkZSdzIGNoaWxkXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhcmVudCBxdWVyeVxuICAgICAgLy8gaW5mbyBmb3IgcGFyZW50IHF1ZXJ5XG4gICAgICB2YXIgX3BhcmVudDIgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9jaGlsZDIgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHBjUUNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuUEFSRU5ULFxuICAgICAgICBwYXJlbnQ6IF9wYXJlbnQyLFxuICAgICAgICBjaGlsZDogX2NoaWxkMlxuICAgICAgfV07XG5cbiAgICAgIC8vIHRoZSBwYXJlbnQtY2hpbGQgcXVlcnkgdGFrZXMgdGhlIHBsYWNlIG9mIHRoZSBxdWVyeSBwcmV2aW91c2x5IGJlaW5nIHBvcHVsYXRlZFxuICAgICAgX3BhcmVudDIuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0aGUgcHJldmlvdXMgcXVlcnkgY29udGFpbnMgdGhlIGNoZWNrcyBmb3IgdGhlIHBhcmVudFxuICAgICAgcXVlcnkuY2hlY2tzID0gcGNRQ2hlY2tzOyAvLyBwYyBxdWVyeSB0YWtlcyBvdmVyXG5cbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfY2hpbGQyOyAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgY2hpbGRcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogJ2Rlc2NlbmRhbnQnLFxuICBzZXBhcmF0b3I6IHRydWUsXG4gIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgcG9wdWxhdGU6IGZ1bmN0aW9uIHBvcHVsYXRlKHNlbGVjdG9yLCBxdWVyeSkge1xuICAgIGlmIChzZWxlY3Rvci5jdXJyZW50U3ViamVjdCA9PSBudWxsKSB7XG4gICAgICAvLyBkZWZhdWx0OiBkZXNjZW5kYW50IHF1ZXJ5XG4gICAgICB2YXIgYW5jQ2hRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgZGVzY2VuZGFudCA9IG5ld1F1ZXJ5KCk7XG4gICAgICB2YXIgYW5jZXN0b3IgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICAgIGFuY0NoUXVlcnkuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkRFU0NFTkRBTlQsXG4gICAgICAgIGFuY2VzdG9yOiBhbmNlc3RvcixcbiAgICAgICAgZGVzY2VuZGFudDogZGVzY2VuZGFudFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBxdWVyeSBpbiB0aGUgc2VsZWN0b3Igc2hvdWxkIGJlIHRoZSAnPicgaXRzZWxmXG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBxdWVyeSwgYW5jQ2hRdWVyeSk7XG4gICAgICBzZWxlY3Rvci5jb21wb3VuZENvdW50Kys7XG5cbiAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBkZXNjZW5kYW50IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgIHJldHVybiBkZXNjZW5kYW50O1xuICAgIH0gZWxzZSBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgPT09IHF1ZXJ5KSB7XG4gICAgICAvLyBjb21wb3VuZCBzcGxpdCBxdWVyeVxuICAgICAgdmFyIGNvbXBvdW5kID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBsZWZ0ID0gc2VsZWN0b3Jbc2VsZWN0b3IubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgcmlnaHQgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIHN1YmplY3QgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIF9kZXNjZW5kYW50ID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBfYW5jZXN0b3IgPSBuZXdRdWVyeSgpO1xuXG4gICAgICAvLyBzZXQgdXAgdGhlIHJvb3QgY29tcG91bmQgcVxuICAgICAgY29tcG91bmQuY2hlY2tzLnB1c2goe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTVBPVU5EX1NQTElULFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHN1YmplY3Q6IHN1YmplY3RcbiAgICAgIH0pO1xuXG4gICAgICAvLyBwb3B1bGF0ZSB0aGUgc3ViamVjdCBhbmQgcmVwbGFjZSB0aGUgcSBhdCB0aGUgb2xkIHNwb3QgKHdpdGhpbiBsZWZ0KSB3aXRoIFRSVUVcbiAgICAgIHN1YmplY3QuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0YWtlIHRoZSBjaGVja3MgZnJvbSB0aGUgbGVmdFxuICAgICAgcXVlcnkuY2hlY2tzID0gW3tcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9XTsgLy8gY2hlY2tzIHVuZGVyIGxlZnQgcmVmcyB0aGUgc3ViamVjdCBpbXBsaWNpdGx5XG5cbiAgICAgIC8vIHNldCB1cCB0aGUgcmlnaHQgcVxuICAgICAgX2FuY2VzdG9yLmNoZWNrcy5wdXNoKHtcbiAgICAgICAgdHlwZTogVHlwZS5UUlVFXG4gICAgICB9KTsgLy8gYW5jZXN0b3IgaW1wbGljaXRseSByZWZzIHRoZSBzdWJqZWN0XG4gICAgICByaWdodC5jaGVja3MucHVzaCh7XG4gICAgICAgIHR5cGU6IFR5cGUuQU5DRVNUT1IsXG4gICAgICAgIC8vIHR5cGUgaXMgc3dhcHBlZCBvbiByaWdodCBzaWRlIHF1ZXJpZXNcbiAgICAgICAgYW5jZXN0b3I6IF9hbmNlc3RvcixcbiAgICAgICAgZGVzY2VuZGFudDogX2Rlc2NlbmRhbnQgLy8gZW1wdHkgZm9yIG5vd1xuICAgICAgfSk7XG4gICAgICByZXBsYWNlTGFzdFF1ZXJ5KHNlbGVjdG9yLCBsZWZ0LCBjb21wb3VuZCk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgcmVmIHNpbmNlIHdlIG1vdmVkIHRoaW5ncyBhcm91bmQgZm9yIGBxdWVyeWBcbiAgICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfZGVzY2VuZGFudDsgLy8gbm93IHBvcHVsYXRpbmcgdGhlIHJpZ2h0IHNpZGUncyBkZXNjZW5kYW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFuY2VzdG9yIHF1ZXJ5XG4gICAgICAvLyBpbmZvIGZvciBwYXJlbnQgcXVlcnlcbiAgICAgIHZhciBfYW5jZXN0b3IyID0gbmV3UXVlcnkoKTtcbiAgICAgIHZhciBfZGVzY2VuZGFudDIgPSBuZXdRdWVyeSgpO1xuICAgICAgdmFyIGFkUUNoZWNrcyA9IFt7XG4gICAgICAgIHR5cGU6IFR5cGUuQU5DRVNUT1IsXG4gICAgICAgIGFuY2VzdG9yOiBfYW5jZXN0b3IyLFxuICAgICAgICBkZXNjZW5kYW50OiBfZGVzY2VuZGFudDJcbiAgICAgIH1dO1xuXG4gICAgICAvLyB0aGUgcGFyZW50LWNoaWxkIHF1ZXJ5IHRha2VzIHRoZSBwbGFjZSBvZiB0aGUgcXVlcnkgcHJldmlvdXNseSBiZWluZyBwb3B1bGF0ZWRcbiAgICAgIF9hbmNlc3RvcjIuY2hlY2tzID0gcXVlcnkuY2hlY2tzOyAvLyB0aGUgcHJldmlvdXMgcXVlcnkgY29udGFpbnMgdGhlIGNoZWNrcyBmb3IgdGhlIHBhcmVudFxuICAgICAgcXVlcnkuY2hlY2tzID0gYWRRQ2hlY2tzOyAvLyBwYyBxdWVyeSB0YWtlcyBvdmVyXG5cbiAgICAgIHNlbGVjdG9yLmNvbXBvdW5kQ291bnQrKztcbiAgICAgIHJldHVybiBfZGVzY2VuZGFudDI7IC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZFxuICAgIH1cbiAgfVxufSwge1xuICBuYW1lOiAnc3ViamVjdCcsXG4gIG1vZGlmaWVyOiB0cnVlLFxuICByZWdleDogdG9rZW5zLnN1YmplY3QsXG4gIHBvcHVsYXRlOiBmdW5jdGlvbiBwb3B1bGF0ZShzZWxlY3RvciwgcXVlcnkpIHtcbiAgICBpZiAoc2VsZWN0b3IuY3VycmVudFN1YmplY3QgIT0gbnVsbCAmJiBzZWxlY3Rvci5jdXJyZW50U3ViamVjdCAhPT0gcXVlcnkpIHtcbiAgICAgIHdhcm4oJ1JlZGVmaW5pdGlvbiBvZiBzdWJqZWN0IGluIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IudG9TdHJpbmcoKSArICdgJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdG9yLmN1cnJlbnRTdWJqZWN0ID0gcXVlcnk7XG4gICAgdmFyIHRvcFEgPSBzZWxlY3RvcltzZWxlY3Rvci5sZW5ndGggLSAxXTtcbiAgICB2YXIgdG9wQ2hrID0gdG9wUS5jaGVja3NbMF07XG4gICAgdmFyIHRvcFR5cGUgPSB0b3BDaGsgPT0gbnVsbCA/IG51bGwgOiB0b3BDaGsudHlwZTtcbiAgICBpZiAodG9wVHlwZSA9PT0gVHlwZS5ESVJFQ1RFRF9FREdFKSB7XG4gICAgICAvLyBkaXJlY3RlZCBlZGdlIHdpdGggc3ViamVjdCBvbiB0aGUgdGFyZ2V0XG5cbiAgICAgIC8vIGNoYW5nZSB0byB0YXJnZXQgbm9kZSBjaGVja1xuICAgICAgdG9wQ2hrLnR5cGUgPSBUeXBlLk5PREVfVEFSR0VUO1xuICAgIH0gZWxzZSBpZiAodG9wVHlwZSA9PT0gVHlwZS5VTkRJUkVDVEVEX0VER0UpIHtcbiAgICAgIC8vIHVuZGlyZWN0ZWQgZWRnZSB3aXRoIHN1YmplY3Qgb24gdGhlIHNlY29uZCBub2RlXG5cbiAgICAgIC8vIGNoYW5nZSB0byBuZWlnaGJvciBjaGVja1xuICAgICAgdG9wQ2hrLnR5cGUgPSBUeXBlLk5PREVfTkVJR0hCT1I7XG4gICAgICB0b3BDaGsubm9kZSA9IHRvcENoay5ub2Rlc1sxXTsgLy8gc2Vjb25kIG5vZGUgaXMgc3ViamVjdFxuICAgICAgdG9wQ2hrLm5laWdoYm9yID0gdG9wQ2hrLm5vZGVzWzBdO1xuXG4gICAgICAvLyBjbGVhbiB1cCB1bnVzZWQgZmllbGRzIGZvciBuZXcgdHlwZVxuICAgICAgdG9wQ2hrLm5vZGVzID0gbnVsbDtcbiAgICB9XG4gIH1cbn1dO1xuZXhwcnMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZS5yZWdleE9iaiA9IG5ldyBSZWdFeHAoJ14nICsgZS5yZWdleCk7XG59KTtcblxuLyoqXG4gKiBPZiBhbGwgdGhlIGV4cHJlc3Npb25zLCBmaW5kIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgcmVtYWluaW5nIHRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtYWluaW5nIFRoZSByZW1haW5pbmcgdGV4dCB0byBwYXJzZVxuICogQHJldHVybnMgVGhlIG1hdGNoZWQgZXhwcmVzc2lvbiBhbmQgdGhlIG5ld2x5IHJlbWFpbmluZyB0ZXh0IGB7IGV4cHIsIG1hdGNoLCBuYW1lLCByZW1haW5pbmcgfWBcbiAqL1xudmFyIGNvbnN1bWVFeHByID0gZnVuY3Rpb24gY29uc3VtZUV4cHIocmVtYWluaW5nKSB7XG4gIHZhciBleHByO1xuICB2YXIgbWF0Y2g7XG4gIHZhciBuYW1lO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IGV4cHJzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGUgPSBleHByc1tqXTtcbiAgICB2YXIgbiA9IGUubmFtZTtcbiAgICB2YXIgbSA9IHJlbWFpbmluZy5tYXRjaChlLnJlZ2V4T2JqKTtcbiAgICBpZiAobSAhPSBudWxsKSB7XG4gICAgICBtYXRjaCA9IG07XG4gICAgICBleHByID0gZTtcbiAgICAgIG5hbWUgPSBuO1xuICAgICAgdmFyIGNvbnN1bWVkID0gbVswXTtcbiAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoY29uc3VtZWQubGVuZ3RoKTtcbiAgICAgIGJyZWFrOyAvLyB3ZSd2ZSBjb25zdW1lZCBvbmUgZXhwciwgc28gd2UgY2FuIHJldHVybiBub3dcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHByOiBleHByLFxuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBuYW1lOiBuYW1lLFxuICAgIHJlbWFpbmluZzogcmVtYWluaW5nXG4gIH07XG59O1xuXG4vKipcbiAqIENvbnN1bWUgYWxsIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1haW5pbmcgVGhlIHRleHQgdG8gY29uc3VtZVxuICogQHJldHVybnMgVGhlIHRleHQgd2l0aCB0aGUgbGVhZGluZyB3aGl0ZXNwYWNlIHJlbW92ZWRcbiAqL1xudmFyIGNvbnN1bWVXaGl0ZXNwYWNlID0gZnVuY3Rpb24gY29uc3VtZVdoaXRlc3BhY2UocmVtYWluaW5nKSB7XG4gIHZhciBtYXRjaCA9IHJlbWFpbmluZy5tYXRjaCgvXlxccysvKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIGNvbnN1bWVkID0gbWF0Y2hbMF07XG4gICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyhjb25zdW1lZC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiByZW1haW5pbmc7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBzdHJpbmcgYW5kIHN0b3JlIHRoZSBwYXJzZWQgcmVwcmVzZW50YXRpb24gaW4gdGhlIFNlbGVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFRoZSBzZWxlY3RvciBzdHJpbmdcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc2VsZWN0b3Igd2FzIHN1Y2Nlc3NmdWxseSBwYXJzZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gKi9cbnZhciBwYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHNlbGVjdG9yKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHJlbWFpbmluZyA9IHNlbGYuaW5wdXRUZXh0ID0gc2VsZWN0b3I7XG4gIHZhciBjdXJyZW50UXVlcnkgPSBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgc2VsZi5sZW5ndGggPSAxO1xuICByZW1haW5pbmcgPSBjb25zdW1lV2hpdGVzcGFjZShyZW1haW5pbmcpOyAvLyBnZXQgcmlkIG9mIGxlYWRpbmcgd2hpdGVzcGFjZVxuXG4gIGZvciAoOzspIHtcbiAgICB2YXIgZXhwckluZm8gPSBjb25zdW1lRXhwcihyZW1haW5pbmcpO1xuICAgIGlmIChleHBySW5mby5leHByID09IG51bGwpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2BpcyBpbnZhbGlkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gZXhwckluZm8ubWF0Y2guc2xpY2UoMSk7XG5cbiAgICAgIC8vIGxldCB0aGUgdG9rZW4gcG9wdWxhdGUgdGhlIHNlbGVjdG9yIG9iamVjdCBpbiBjdXJyZW50UXVlcnlcbiAgICAgIHZhciByZXQgPSBleHBySW5mby5leHByLnBvcHVsYXRlKHNlbGYsIGN1cnJlbnRRdWVyeSwgYXJncyk7XG4gICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGV4aXQgaWYgcG9wdWxhdGlvbiBmYWlsZWRcbiAgICAgIH0gZWxzZSBpZiAocmV0ICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudFF1ZXJ5ID0gcmV0OyAvLyBjaGFuZ2UgdGhlIGN1cnJlbnQgcXVlcnkgdG8gYmUgZmlsbGVkIGlmIHRoZSBleHByIHNwZWNpZmllc1xuICAgICAgfVxuICAgIH1cbiAgICByZW1haW5pbmcgPSBleHBySW5mby5yZW1haW5pbmc7XG5cbiAgICAvLyB3ZSdyZSBkb25lIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gcGFyc2VcbiAgICBpZiAocmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHZhciBsYXN0USA9IHNlbGZbc2VsZi5sZW5ndGggLSAxXTtcbiAgaWYgKHNlbGYuY3VycmVudFN1YmplY3QgIT0gbnVsbCkge1xuICAgIGxhc3RRLnN1YmplY3QgPSBzZWxmLmN1cnJlbnRTdWJqZWN0O1xuICB9XG4gIGxhc3RRLmVkZ2VDb3VudCA9IHNlbGYuZWRnZUNvdW50O1xuICBsYXN0US5jb21wb3VuZENvdW50ID0gc2VsZi5jb21wb3VuZENvdW50O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcSA9IHNlbGZbaV07XG5cbiAgICAvLyBpbiBmdXR1cmUsIHRoaXMgY291bGQgcG90ZW50aWFsbHkgYmUgYWxsb3dlZCBpZiB0aGVyZSB3ZXJlIG9wZXJhdG9yIHByZWNlZGVuY2UgYW5kIGRldGVjdGlvbiBvZiBpbnZhbGlkIGNvbWJpbmF0aW9uc1xuICAgIGlmIChxLmNvbXBvdW5kQ291bnQgPiAwICYmIHEuZWRnZUNvdW50ID4gMCkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBib3RoIGEgY29tcG91bmQgc2VsZWN0b3IgYW5kIGFuIGVkZ2Ugc2VsZWN0b3InKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHEuZWRnZUNvdW50ID4gMSkge1xuICAgICAgd2FybignVGhlIHNlbGVjdG9yIGAnICsgc2VsZWN0b3IgKyAnYCBpcyBpbnZhbGlkIGJlY2F1c2UgaXQgdXNlcyBtdWx0aXBsZSBlZGdlIHNlbGVjdG9ycycpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocS5lZGdlQ291bnQgPT09IDEpIHtcbiAgICAgIHdhcm4oJ1RoZSBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AgaXMgZGVwcmVjYXRlZC4gIEVkZ2Ugc2VsZWN0b3JzIGRvIG5vdCB0YWtlIGVmZmVjdCBvbiBjaGFuZ2VzIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzIGFmdGVyIGFuIGVkZ2UgaXMgYWRkZWQsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiAgVXNlIGEgY2xhc3Mgb3IgZGF0YSBzZWxlY3RvciBvbiBlZGdlcyBpbnN0ZWFkLCB1cGRhdGluZyB0aGUgY2xhc3Mgb3IgZGF0YSBvZiBhbiBlZGdlIHdoZW4geW91ciBhcHAgZGV0ZWN0cyBhIGNoYW5nZSBpbiBzb3VyY2Ugb3IgdGFyZ2V0IG5vZGVzLicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTsgLy8gc3VjY2Vzc1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNlbGVjdG9yIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nLiAgVGhpcyB2YWx1ZSB1c2VzIGRlZmF1bHQgZm9ybWF0dGluZyxcbiAqIHNvIHRoaW5ncyBsaWtlIHNwYWNpbmcgbWF5IGRpZmZlciBmcm9tIHRoZSBpbnB1dCB0ZXh0IHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc2VsZWN0b3Igc3RyaW5nXG4gKi9cbnZhciB0b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICBpZiAodGhpcy50b1N0cmluZ0NhY2hlICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZ0NhY2hlO1xuICB9XG4gIHZhciBjbGVhbiA9IGZ1bmN0aW9uIGNsZWFuKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcbiAgdmFyIGNsZWFuVmFsID0gZnVuY3Rpb24gY2xlYW5WYWwodmFsKSB7XG4gICAgaWYgKHN0cmluZyh2YWwpKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIHZhbCArICdcIic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjbGVhbih2YWwpO1xuICAgIH1cbiAgfTtcbiAgdmFyIHNwYWNlID0gZnVuY3Rpb24gc3BhY2UodmFsKSB7XG4gICAgcmV0dXJuICcgJyArIHZhbCArICcgJztcbiAgfTtcbiAgdmFyIGNoZWNrVG9TdHJpbmcgPSBmdW5jdGlvbiBjaGVja1RvU3RyaW5nKGNoZWNrLCBzdWJqZWN0KSB7XG4gICAgdmFyIHR5cGUgPSBjaGVjay50eXBlLFxuICAgICAgdmFsdWUgPSBjaGVjay52YWx1ZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgVHlwZS5HUk9VUDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBncm91cCA9IGNsZWFuKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gZ3JvdXAuc3Vic3RyaW5nKDAsIGdyb3VwLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuREFUQV9DT01QQVJFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gY2hlY2suZmllbGQsXG4gICAgICAgICAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yO1xuICAgICAgICAgIHJldHVybiAnWycgKyBmaWVsZCArIHNwYWNlKGNsZWFuKG9wZXJhdG9yKSkgKyBjbGVhblZhbCh2YWx1ZSkgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5EQVRBX0JPT0w6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX29wZXJhdG9yID0gY2hlY2sub3BlcmF0b3IsXG4gICAgICAgICAgICBfZmllbGQgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1snICsgY2xlYW4oX29wZXJhdG9yKSArIF9maWVsZCArICddJztcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLkRBVEFfRVhJU1Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2ZpZWxkMiA9IGNoZWNrLmZpZWxkO1xuICAgICAgICAgIHJldHVybiAnWycgKyBfZmllbGQyICsgJ10nO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuTUVUQV9DT01QQVJFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9vcGVyYXRvcjIgPSBjaGVjay5vcGVyYXRvcixcbiAgICAgICAgICAgIF9maWVsZDMgPSBjaGVjay5maWVsZDtcbiAgICAgICAgICByZXR1cm4gJ1tbJyArIF9maWVsZDMgKyBzcGFjZShjbGVhbihfb3BlcmF0b3IyKSkgKyBjbGVhblZhbCh2YWx1ZSkgKyAnXV0nO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuU1RBVEU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgVHlwZS5JRDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiAnIycgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLkNMQVNTOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuICcuJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuUEFSRU5UOlxuICAgICAgY2FzZSBUeXBlLkNISUxEOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5VG9TdHJpbmcoY2hlY2sucGFyZW50LCBzdWJqZWN0KSArIHNwYWNlKCc+JykgKyBxdWVyeVRvU3RyaW5nKGNoZWNrLmNoaWxkLCBzdWJqZWN0KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLkFOQ0VTVE9SOlxuICAgICAgY2FzZSBUeXBlLkRFU0NFTkRBTlQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gcXVlcnlUb1N0cmluZyhjaGVjay5hbmNlc3Rvciwgc3ViamVjdCkgKyAnICcgKyBxdWVyeVRvU3RyaW5nKGNoZWNrLmRlc2NlbmRhbnQsIHN1YmplY3QpO1xuICAgICAgICB9XG4gICAgICBjYXNlIFR5cGUuQ09NUE9VTkRfU1BMSVQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5sZWZ0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgc3ViID0gcXVlcnlUb1N0cmluZyhjaGVjay5zdWJqZWN0LCBzdWJqZWN0KTtcbiAgICAgICAgICB2YXIgcmhzID0gcXVlcnlUb1N0cmluZyhjaGVjay5yaWdodCwgc3ViamVjdCk7XG4gICAgICAgICAgcmV0dXJuIGxocyArIChsaHMubGVuZ3RoID4gMCA/ICcgJyA6ICcnKSArIHN1YiArIHJocztcbiAgICAgICAgfVxuICAgICAgY2FzZSBUeXBlLlRSVUU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBxdWVyeVRvU3RyaW5nID0gZnVuY3Rpb24gcXVlcnlUb1N0cmluZyhxdWVyeSwgc3ViamVjdCkge1xuICAgIHJldHVybiBxdWVyeS5jaGVja3MucmVkdWNlKGZ1bmN0aW9uIChzdHIsIGNoaywgaSkge1xuICAgICAgcmV0dXJuIHN0ciArIChzdWJqZWN0ID09PSBxdWVyeSAmJiBpID09PSAwID8gJyQnIDogJycpICsgY2hlY2tUb1N0cmluZyhjaGssIHN1YmplY3QpO1xuICAgIH0sICcnKTtcbiAgfTtcbiAgdmFyIHN0ciA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzW2ldO1xuICAgIHN0ciArPSBxdWVyeVRvU3RyaW5nKHF1ZXJ5LCBxdWVyeS5zdWJqZWN0KTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmIGkgPCB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHN0ciArPSAnLCAnO1xuICAgIH1cbiAgfVxuICB0aGlzLnRvU3RyaW5nQ2FjaGUgPSBzdHI7XG4gIHJldHVybiBzdHI7XG59O1xudmFyIHBhcnNlJDEgPSB7XG4gIHBhcnNlOiBwYXJzZSxcbiAgdG9TdHJpbmc6IHRvU3RyaW5nXG59O1xuXG52YXIgdmFsQ21wID0gZnVuY3Rpb24gdmFsQ21wKGZpZWxkVmFsLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgdmFyIG1hdGNoZXM7XG4gIHZhciBpc0ZpZWxkU3RyID0gc3RyaW5nKGZpZWxkVmFsKTtcbiAgdmFyIGlzRmllbGROdW0gPSBudW1iZXIkMShmaWVsZFZhbCk7XG4gIHZhciBpc1ZhbFN0ciA9IHN0cmluZyh2YWx1ZSk7XG4gIHZhciBmaWVsZFN0ciwgdmFsU3RyO1xuICB2YXIgY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gIHZhciBub3RFeHByID0gZmFsc2U7XG4gIHZhciBpc0luZXFDbXAgPSBmYWxzZTtcbiAgaWYgKG9wZXJhdG9yLmluZGV4T2YoJyEnKSA+PSAwKSB7XG4gICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgIG5vdEV4cHIgPSB0cnVlO1xuICB9XG4gIGlmIChvcGVyYXRvci5pbmRleE9mKCdAJykgPj0gMCkge1xuICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSgnQCcsICcnKTtcbiAgICBjYXNlSW5zZW5zaXRpdmUgPSB0cnVlO1xuICB9XG4gIGlmIChpc0ZpZWxkU3RyIHx8IGlzVmFsU3RyIHx8IGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgIGZpZWxkU3RyID0gIWlzRmllbGRTdHIgJiYgIWlzRmllbGROdW0gPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgdmFsU3RyID0gJycgKyB2YWx1ZTtcbiAgfVxuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIGEgY2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uLCB0aGVuIHdlJ3JlIHVzaW5nIGEgU1RSSU5HIGNvbXBhcmlzb25cbiAgLy8gZXZlbiBpZiB3ZSdyZSBjb21wYXJpbmcgbnVtYmVyc1xuICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgZmllbGRWYWwgPSBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsdWUgPSB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgY2FzZSAnKj0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyKSA+PSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJD0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyLCBmaWVsZFN0ci5sZW5ndGggLSB2YWxTdHIubGVuZ3RoKSA+PSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnXj0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkU3RyLmluZGV4T2YodmFsU3RyKSA9PT0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJz0nOlxuICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID09PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJz4nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPj0nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA+PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzwnOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPD0nOlxuICAgICAgaXNJbmVxQ21wID0gdHJ1ZTtcbiAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtYXRjaGVzID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIGFwcGx5IHRoZSBub3Qgb3AsIGJ1dCBudWxsIHZhbHMgZm9yIGluZXF1YWxpdGllcyBzaG91bGQgYWx3YXlzIHN0YXkgbm9uLW1hdGNoaW5nXG4gIGlmIChub3RFeHByICYmIChmaWVsZFZhbCAhPSBudWxsIHx8ICFpc0luZXFDbXApKSB7XG4gICAgbWF0Y2hlcyA9ICFtYXRjaGVzO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufTtcbnZhciBib29sQ21wID0gZnVuY3Rpb24gYm9vbENtcChmaWVsZFZhbCwgb3BlcmF0b3IpIHtcbiAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgIGNhc2UgJz8nOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID8gdHJ1ZSA6IGZhbHNlO1xuICAgIGNhc2UgJyEnOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID8gZmFsc2UgOiB0cnVlO1xuICAgIGNhc2UgJ14nOlxuICAgICAgcmV0dXJuIGZpZWxkVmFsID09PSB1bmRlZmluZWQ7XG4gIH1cbn07XG52YXIgZXhpc3RDbXAgPSBmdW5jdGlvbiBleGlzdENtcChmaWVsZFZhbCkge1xuICByZXR1cm4gZmllbGRWYWwgIT09IHVuZGVmaW5lZDtcbn07XG52YXIgZGF0YSQxID0gZnVuY3Rpb24gZGF0YShlbGUsIGZpZWxkKSB7XG4gIHJldHVybiBlbGUuZGF0YShmaWVsZCk7XG59O1xudmFyIG1ldGEgPSBmdW5jdGlvbiBtZXRhKGVsZSwgZmllbGQpIHtcbiAgcmV0dXJuIGVsZVtmaWVsZF0oKTtcbn07XG5cbi8qKiBBIGxvb2t1cCBvZiBgbWF0Y2goY2hlY2ssIGVsZSlgIGZ1bmN0aW9ucyBieSBgVHlwZWAgaW50ICovXG52YXIgbWF0Y2ggPSBbXTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHF1ZXJ5IG1hdGNoZXMgZm9yIHRoZSBlbGVtZW50XG4gKiBAcGFyYW0gcXVlcnkgVGhlIGB7IHR5cGUsIHZhbHVlLCAuLi4gfWAgcXVlcnkgb2JqZWN0XG4gKiBAcGFyYW0gZWxlIFRoZSBlbGVtZW50IHRvIGNvbXBhcmUgYWdhaW5zdFxuKi9cbnZhciBtYXRjaGVzJDEgPSBmdW5jdGlvbiBtYXRjaGVzKHF1ZXJ5LCBlbGUpIHtcbiAgcmV0dXJuIHF1ZXJ5LmNoZWNrcy5ldmVyeShmdW5jdGlvbiAoY2hrKSB7XG4gICAgcmV0dXJuIG1hdGNoW2Noay50eXBlXShjaGssIGVsZSk7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuR1JPVVBdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGdyb3VwID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBncm91cCA9PT0gJyonIHx8IGdyb3VwID09PSBlbGUuZ3JvdXAoKTtcbn07XG5tYXRjaFtUeXBlLlNUQVRFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBzdGF0ZVNlbGVjdG9yID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBzdGF0ZVNlbGVjdG9yTWF0Y2hlcyhzdGF0ZVNlbGVjdG9yLCBlbGUpO1xufTtcbm1hdGNoW1R5cGUuSURdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGlkID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBlbGUuaWQoKSA9PT0gaWQ7XG59O1xubWF0Y2hbVHlwZS5DTEFTU10gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgY2xzID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiBlbGUuaGFzQ2xhc3MoY2xzKTtcbn07XG5tYXRjaFtUeXBlLk1FVEFfQ09NUEFSRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgIHZhbHVlID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiB2YWxDbXAobWV0YShlbGUsIGZpZWxkKSwgb3BlcmF0b3IsIHZhbHVlKTtcbn07XG5tYXRjaFtUeXBlLkRBVEFfQ09NUEFSRV0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZCxcbiAgICBvcGVyYXRvciA9IGNoZWNrLm9wZXJhdG9yLFxuICAgIHZhbHVlID0gY2hlY2sudmFsdWU7XG4gIHJldHVybiB2YWxDbXAoZGF0YSQxKGVsZSwgZmllbGQpLCBvcGVyYXRvciwgdmFsdWUpO1xufTtcbm1hdGNoW1R5cGUuREFUQV9CT09MXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHZhciBmaWVsZCA9IGNoZWNrLmZpZWxkLFxuICAgIG9wZXJhdG9yID0gY2hlY2sub3BlcmF0b3I7XG4gIHJldHVybiBib29sQ21wKGRhdGEkMShlbGUsIGZpZWxkKSwgb3BlcmF0b3IpO1xufTtcbm1hdGNoW1R5cGUuREFUQV9FWElTVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICB2YXIgZmllbGQgPSBjaGVjay5maWVsZDtcbiAgICBjaGVjay5vcGVyYXRvcjtcbiAgcmV0dXJuIGV4aXN0Q21wKGRhdGEkMShlbGUsIGZpZWxkKSk7XG59O1xubWF0Y2hbVHlwZS5VTkRJUkVDVEVEX0VER0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIHFBID0gY2hlY2subm9kZXNbMF07XG4gIHZhciBxQiA9IGNoZWNrLm5vZGVzWzFdO1xuICB2YXIgc3JjID0gZWxlLnNvdXJjZSgpO1xuICB2YXIgdGd0ID0gZWxlLnRhcmdldCgpO1xuICByZXR1cm4gbWF0Y2hlcyQxKHFBLCBzcmMpICYmIG1hdGNoZXMkMShxQiwgdGd0KSB8fCBtYXRjaGVzJDEocUIsIHNyYykgJiYgbWF0Y2hlcyQxKHFBLCB0Z3QpO1xufTtcbm1hdGNoW1R5cGUuTk9ERV9ORUlHSEJPUl0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLm5vZGUsIGVsZSkgJiYgZWxlLm5laWdoYm9yaG9vZCgpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2submVpZ2hib3IsIG4pO1xuICB9KTtcbn07XG5tYXRjaFtUeXBlLkRJUkVDVEVEX0VER0VdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5zb3VyY2UsIGVsZS5zb3VyY2UoKSkgJiYgbWF0Y2hlcyQxKGNoZWNrLnRhcmdldCwgZWxlLnRhcmdldCgpKTtcbn07XG5tYXRjaFtUeXBlLk5PREVfU09VUkNFXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suc291cmNlLCBlbGUpICYmIGVsZS5vdXRnb2VycygpLnNvbWUoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc05vZGUoKSAmJiBtYXRjaGVzJDEoY2hlY2sudGFyZ2V0LCBuKTtcbiAgfSk7XG59O1xubWF0Y2hbVHlwZS5OT0RFX1RBUkdFVF0gPSBmdW5jdGlvbiAoY2hlY2ssIGVsZSkge1xuICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLnRhcmdldCwgZWxlKSAmJiBlbGUuaW5jb21lcnMoKS5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgcmV0dXJuIG4uaXNOb2RlKCkgJiYgbWF0Y2hlcyQxKGNoZWNrLnNvdXJjZSwgbik7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuQ0hJTERdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5jaGlsZCwgZWxlKSAmJiBtYXRjaGVzJDEoY2hlY2sucGFyZW50LCBlbGUucGFyZW50KCkpO1xufTtcbm1hdGNoW1R5cGUuUEFSRU5UXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2sucGFyZW50LCBlbGUpICYmIGVsZS5jaGlsZHJlbigpLnNvbWUoZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gbWF0Y2hlcyQxKGNoZWNrLmNoaWxkLCBjKTtcbiAgfSk7XG59O1xubWF0Y2hbVHlwZS5ERVNDRU5EQU5UXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suZGVzY2VuZGFudCwgZWxlKSAmJiBlbGUuYW5jZXN0b3JzKCkuc29tZShmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suYW5jZXN0b3IsIGEpO1xuICB9KTtcbn07XG5tYXRjaFtUeXBlLkFOQ0VTVE9SXSA9IGZ1bmN0aW9uIChjaGVjaywgZWxlKSB7XG4gIHJldHVybiBtYXRjaGVzJDEoY2hlY2suYW5jZXN0b3IsIGVsZSkgJiYgZWxlLmRlc2NlbmRhbnRzKCkuc29tZShmdW5jdGlvbiAoZCkge1xuICAgIHJldHVybiBtYXRjaGVzJDEoY2hlY2suZGVzY2VuZGFudCwgZCk7XG4gIH0pO1xufTtcbm1hdGNoW1R5cGUuQ09NUE9VTkRfU1BMSVRdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgcmV0dXJuIG1hdGNoZXMkMShjaGVjay5zdWJqZWN0LCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5sZWZ0LCBlbGUpICYmIG1hdGNoZXMkMShjaGVjay5yaWdodCwgZWxlKTtcbn07XG5tYXRjaFtUeXBlLlRSVUVdID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5tYXRjaFtUeXBlLkNPTExFQ1RJT05dID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSBjaGVjay52YWx1ZTtcbiAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzKGVsZSk7XG59O1xubWF0Y2hbVHlwZS5GSUxURVJdID0gZnVuY3Rpb24gKGNoZWNrLCBlbGUpIHtcbiAgdmFyIGZpbHRlciA9IGNoZWNrLnZhbHVlO1xuICByZXR1cm4gZmlsdGVyKGVsZSk7XG59O1xuXG4vLyBmaWx0ZXIgYW4gZXhpc3RpbmcgY29sbGVjdGlvblxudmFyIGZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICAvLyBmb3IgMSBpZCAjZm9vIHF1ZXJpZXMsIGp1c3QgZ2V0IHRoZSBlbGVtZW50XG4gIGlmIChzZWxmLmxlbmd0aCA9PT0gMSAmJiBzZWxmWzBdLmNoZWNrcy5sZW5ndGggPT09IDEgJiYgc2VsZlswXS5jaGVja3NbMF0udHlwZSA9PT0gVHlwZS5JRCkge1xuICAgIHJldHVybiBjb2xsZWN0aW9uLmdldEVsZW1lbnRCeUlkKHNlbGZbMF0uY2hlY2tzWzBdLnZhbHVlKS5jb2xsZWN0aW9uKCk7XG4gIH1cbiAgdmFyIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG4gICAgICBpZiAobWF0Y2hlcyQxKHF1ZXJ5LCBlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBpZiAoc2VsZi50ZXh0KCkgPT0gbnVsbCkge1xuICAgIHNlbGVjdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiBzZWxlY3RvckZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY29sbGVjdGlvbi5maWx0ZXIoc2VsZWN0b3JGdW5jdGlvbik7XG59OyAvLyBmaWx0ZXJcblxuLy8gZG9lcyBzZWxlY3RvciBtYXRjaCBhIHNpbmdsZSBlbGVtZW50P1xudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiBtYXRjaGVzKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKykge1xuICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG4gICAgaWYgKG1hdGNoZXMkMShxdWVyeSwgZWxlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07IC8vIG1hdGNoZXNcblxudmFyIG1hdGNoaW5nID0ge1xuICBtYXRjaGVzOiBtYXRjaGVzLFxuICBmaWx0ZXI6IGZpbHRlclxufTtcblxudmFyIFNlbGVjdG9yID0gZnVuY3Rpb24gU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdGhpcy5pbnB1dFRleHQgPSBzZWxlY3RvcjtcbiAgdGhpcy5jdXJyZW50U3ViamVjdCA9IG51bGw7XG4gIHRoaXMuY29tcG91bmRDb3VudCA9IDA7XG4gIHRoaXMuZWRnZUNvdW50ID0gMDtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICBpZiAoc2VsZWN0b3IgPT0gbnVsbCB8fCBzdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yLm1hdGNoKC9eXFxzKiQvKSkgOyBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yKSkge1xuICAgIHRoaXMuYWRkUXVlcnkoe1xuICAgICAgY2hlY2tzOiBbe1xuICAgICAgICB0eXBlOiBUeXBlLkNPTExFQ1RJT04sXG4gICAgICAgIHZhbHVlOiBzZWxlY3Rvci5jb2xsZWN0aW9uKClcbiAgICAgIH1dXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoZm4kNihzZWxlY3RvcikpIHtcbiAgICB0aGlzLmFkZFF1ZXJ5KHtcbiAgICAgIGNoZWNrczogW3tcbiAgICAgICAgdHlwZTogVHlwZS5GSUxURVIsXG4gICAgICAgIHZhbHVlOiBzZWxlY3RvclxuICAgICAgfV1cbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzdHJpbmcoc2VsZWN0b3IpKSB7XG4gICAgaWYgKCF0aGlzLnBhcnNlKHNlbGVjdG9yKSkge1xuICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0Egc2VsZWN0b3IgbXVzdCBiZSBjcmVhdGVkIGZyb20gYSBzdHJpbmc7IGZvdW5kICcpO1xuICB9XG59O1xudmFyIHNlbGZuID0gU2VsZWN0b3IucHJvdG90eXBlO1xuW3BhcnNlJDEsIG1hdGNoaW5nXS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBleHRlbmQoc2VsZm4sIHApO1xufSk7XG5zZWxmbi50ZXh0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pbnB1dFRleHQ7XG59O1xuc2VsZm4uc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcbnNlbGZuLmVxID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIHRoaXNbaV07XG59O1xuc2VsZm4uc2FtZVRleHQgPSBmdW5jdGlvbiAob3RoZXJTZWwpIHtcbiAgcmV0dXJuICF0aGlzLmludmFsaWQgJiYgIW90aGVyU2VsLmludmFsaWQgJiYgdGhpcy50ZXh0KCkgPT09IG90aGVyU2VsLnRleHQoKTtcbn07XG5zZWxmbi5hZGRRdWVyeSA9IGZ1bmN0aW9uIChxKSB7XG4gIHRoaXNbdGhpcy5sZW5ndGgrK10gPSBxO1xufTtcbnNlbGZuLnNlbGVjdG9yID0gc2VsZm4udG9TdHJpbmc7XG5cbnZhciBlbGVzZm4kZyA9IHtcbiAgYWxsQXJlOiBmdW5jdGlvbiBhbGxBcmUoc2VsZWN0b3IpIHtcbiAgICB2YXIgc2VsT2JqID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5ldmVyeShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICB9KTtcbiAgfSxcbiAgaXM6IGZ1bmN0aW9uIGlzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNlbE9iaiA9IG5ldyBTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gc2VsT2JqLm1hdGNoZXMoZWxlKTtcbiAgICB9KTtcbiAgfSxcbiAgc29tZTogZnVuY3Rpb24gc29tZShmbiwgdGhpc0FyZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4odGhpc1tpXSwgaSwgdGhpcykgOiBmbi5hcHBseSh0aGlzQXJnLCBbdGhpc1tpXSwgaSwgdGhpc10pO1xuICAgICAgaWYgKHJldCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoZm4sIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKHRoaXNbaV0sIGksIHRoaXMpIDogZm4uYXBwbHkodGhpc0FyZywgW3RoaXNbaV0sIGksIHRoaXNdKTtcbiAgICAgIGlmICghcmV0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHNhbWU6IGZ1bmN0aW9uIHNhbWUoY29sbGVjdGlvbikge1xuICAgIC8vIGNoZWFwIGNvbGxlY3Rpb24gcmVmIGNoZWNrXG4gICAgaWYgKHRoaXMgPT09IGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgdmFyIHRoaXNMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB2YXIgY29sbGVjdGlvbkxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuXG4gICAgLy8gY2hlYXAgbGVuZ3RoIGNoZWNrXG4gICAgaWYgKHRoaXNMZW5ndGggIT09IGNvbGxlY3Rpb25MZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVhcCBlbGVtZW50IHJlZiBjaGVja1xuICAgIGlmICh0aGlzTGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdGhpc1swXSA9PT0gY29sbGVjdGlvblswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH0sXG4gIGFueVNhbWU6IGZ1bmN0aW9uIGFueVNhbWUoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBhbGxBcmVOZWlnaGJvcnM6IGZ1bmN0aW9uIGFsbEFyZU5laWdoYm9ycyhjb2xsZWN0aW9uKSB7XG4gICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKGNvbGxlY3Rpb24pO1xuICAgIHZhciBuaG9vZCA9IHRoaXMubmVpZ2hib3Job29kKCk7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIG5ob29kLmhhc0VsZW1lbnRXaXRoSWQoZWxlLmlkKCkpO1xuICAgIH0pO1xuICB9LFxuICBjb250YWluczogZnVuY3Rpb24gY29udGFpbnMoY29sbGVjdGlvbikge1xuICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbihjb2xsZWN0aW9uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uZXZlcnkoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIHNlbGYuaGFzRWxlbWVudFdpdGhJZChlbGUuaWQoKSk7XG4gICAgfSk7XG4gIH1cbn07XG5lbGVzZm4kZy5hbGxBcmVOZWlnaGJvdXJzID0gZWxlc2ZuJGcuYWxsQXJlTmVpZ2hib3JzO1xuZWxlc2ZuJGcuaGFzID0gZWxlc2ZuJGcuY29udGFpbnM7XG5lbGVzZm4kZy5lcXVhbCA9IGVsZXNmbiRnLmVxdWFscyA9IGVsZXNmbiRnLnNhbWU7XG5cbnZhciBjYWNoZSA9IGZ1bmN0aW9uIGNhY2hlKGZuLCBuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0cmF2ZXJzYWxDYWNoZShhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgdmFyIHNlbGVjdG9yT3JFbGVzID0gYXJnMTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoc2VsZWN0b3JPckVsZXMgPT0gbnVsbCkge1xuICAgICAga2V5ID0gJyc7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKHNlbGVjdG9yT3JFbGVzKSAmJiBzZWxlY3Rvck9yRWxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGtleSA9IHNlbGVjdG9yT3JFbGVzLmlkKCk7XG4gICAgfVxuICAgIGlmIChlbGVzLmxlbmd0aCA9PT0gMSAmJiBrZXkpIHtcbiAgICAgIHZhciBfcCA9IGVsZXNbMF0uX3ByaXZhdGU7XG4gICAgICB2YXIgdGNoID0gX3AudHJhdmVyc2FsQ2FjaGUgPSBfcC50cmF2ZXJzYWxDYWNoZSB8fCB7fTtcbiAgICAgIHZhciBjaCA9IHRjaFtuYW1lXSA9IHRjaFtuYW1lXSB8fCBbXTtcbiAgICAgIHZhciBoYXNoID0gaGFzaFN0cmluZyhrZXkpO1xuICAgICAgdmFyIGNhY2hlSGl0ID0gY2hbaGFzaF07XG4gICAgICBpZiAoY2FjaGVIaXQpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlSGl0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNoW2hhc2hdID0gZm4uY2FsbChlbGVzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlcywgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGVsZXNmbiRmID0ge1xuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICAgIHZhciBwYXJlbnRzID0gW107XG5cbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIHNpbmdsZSBlbGUgY2FsbFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXNbMF0uX3ByaXZhdGUucGFyZW50O1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIF9wYXJlbnQgPSBlbGUuX3ByaXZhdGUucGFyZW50O1xuICAgICAgaWYgKF9wYXJlbnQpIHtcbiAgICAgICAgcGFyZW50cy5wdXNoKF9wYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBwYXJlbnRzOiBmdW5jdGlvbiBwYXJlbnRzKHNlbGVjdG9yKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG4gICAgd2hpbGUgKGVsZXMubm9uZW1wdHkoKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBwYXJlbnRzLnB1c2goZWxlKTtcbiAgICAgIH1cbiAgICAgIGVsZXMgPSBlbGVzLnBhcmVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihwYXJlbnRzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBjb21tb25BbmNlc3RvcnM6IGZ1bmN0aW9uIGNvbW1vbkFuY2VzdG9ycyhzZWxlY3Rvcikge1xuICAgIHZhciBhbmNlc3RvcnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBwYXJlbnRzID0gZWxlLnBhcmVudHMoKTtcbiAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmludGVyc2VjdChwYXJlbnRzKTsgLy8gY3VycmVudCBsaXN0IG11c3QgYmUgY29tbW9uIHdpdGggY3VycmVudCBlbGUgcGFyZW50cyBzZXRcbiAgICB9XG4gICAgcmV0dXJuIGFuY2VzdG9ycy5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBvcnBoYW5zOiBmdW5jdGlvbiBvcnBoYW5zKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNPcnBoYW4oKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBub25vcnBoYW5zOiBmdW5jdGlvbiBub25vcnBoYW5zKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNDaGlsZCgpO1xuICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sXG4gIGNoaWxkcmVuOiBjYWNoZShmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGVsZUNoaWxkcmVuID0gZWxlLl9wcml2YXRlLmNoaWxkcmVuO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVDaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKGVsZUNoaWxkcmVuW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oY2hpbGRyZW4sIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH0sICdjaGlsZHJlbicpLFxuICBzaWJsaW5nczogZnVuY3Rpb24gc2libGluZ3Moc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpLm5vdCh0aGlzKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBpc1BhcmVudDogZnVuY3Rpb24gaXNQYXJlbnQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgfSxcbiAgaXNDaGlsZGxlc3M6IGZ1bmN0aW9uIGlzQ2hpbGRsZXNzKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLl9wcml2YXRlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0sXG4gIGlzQ2hpbGQ6IGZ1bmN0aW9uIGlzQ2hpbGQoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUucGFyZW50ICE9IG51bGw7XG4gICAgfVxuICB9LFxuICBpc09ycGhhbjogZnVuY3Rpb24gaXNPcnBoYW4oKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuX3ByaXZhdGUucGFyZW50ID09IG51bGw7XG4gICAgfVxuICB9LFxuICBkZXNjZW5kYW50czogZnVuY3Rpb24gZGVzY2VuZGFudHMoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICBmdW5jdGlvbiBhZGQoZWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgIGlmIChlbGUuY2hpbGRyZW4oKS5ub25lbXB0eSgpKSB7XG4gICAgICAgICAgYWRkKGVsZS5jaGlsZHJlbigpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBhZGQodGhpcy5jaGlsZHJlbigpKTtcbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZvckVhY2hDb21wb3VuZChlbGVzLCBmbiwgaW5jbHVkZVNlbGYsIHJlY3Vyc2l2ZVN0ZXApIHtcbiAgdmFyIHEgPSBbXTtcbiAgdmFyIGRpZCA9IG5ldyBTZXQkMSgpO1xuICB2YXIgY3kgPSBlbGVzLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIGlmIChpbmNsdWRlU2VsZikge1xuICAgICAgcS5wdXNoKGVsZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgIHJlY3Vyc2l2ZVN0ZXAocSwgZGlkLCBlbGUpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAocS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIF9lbGUgPSBxLnNoaWZ0KCk7XG4gICAgZm4oX2VsZSk7XG4gICAgZGlkLmFkZChfZWxlLmlkKCkpO1xuICAgIGlmIChoYXNDb21wb3VuZHMpIHtcbiAgICAgIHJlY3Vyc2l2ZVN0ZXAocSwgZGlkLCBfZWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZXM7XG59XG5mdW5jdGlvbiBhZGRDaGlsZHJlbihxLCBkaWQsIGVsZSkge1xuICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbGUuX3ByaXZhdGUuY2hpbGRyZW47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoIWRpZC5oYXMoY2hpbGQuaWQoKSkpIHtcbiAgICAgICAgcS5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gdmVyeSBlZmZpY2llbnQgdmVyc2lvbiBvZiBlbGVzLmFkZCggZWxlcy5kZXNjZW5kYW50cygpICkuZm9yRWFjaCgpXG4vLyBmb3IgaW50ZXJuYWwgdXNlXG5lbGVzZm4kZi5mb3JFYWNoRG93biA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgaW5jbHVkZVNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gIHJldHVybiBmb3JFYWNoQ29tcG91bmQodGhpcywgZm4sIGluY2x1ZGVTZWxmLCBhZGRDaGlsZHJlbik7XG59O1xuZnVuY3Rpb24gYWRkUGFyZW50KHEsIGRpZCwgZWxlKSB7XG4gIGlmIChlbGUuaXNDaGlsZCgpKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsZS5fcHJpdmF0ZS5wYXJlbnQ7XG4gICAgaWYgKCFkaWQuaGFzKHBhcmVudC5pZCgpKSkge1xuICAgICAgcS5wdXNoKHBhcmVudCk7XG4gICAgfVxuICB9XG59XG5lbGVzZm4kZi5mb3JFYWNoVXAgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGluY2x1ZGVTZWxmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICByZXR1cm4gZm9yRWFjaENvbXBvdW5kKHRoaXMsIGZuLCBpbmNsdWRlU2VsZiwgYWRkUGFyZW50KTtcbn07XG5mdW5jdGlvbiBhZGRQYXJlbnRBbmRDaGlsZHJlbihxLCBkaWQsIGVsZSkge1xuICBhZGRQYXJlbnQocSwgZGlkLCBlbGUpO1xuICBhZGRDaGlsZHJlbihxLCBkaWQsIGVsZSk7XG59XG5lbGVzZm4kZi5mb3JFYWNoVXBBbmREb3duID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBpbmNsdWRlU2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgcmV0dXJuIGZvckVhY2hDb21wb3VuZCh0aGlzLCBmbiwgaW5jbHVkZVNlbGYsIGFkZFBhcmVudEFuZENoaWxkcmVuKTtcbn07XG5cbi8vIGFsaWFzZXNcbmVsZXNmbiRmLmFuY2VzdG9ycyA9IGVsZXNmbiRmLnBhcmVudHM7XG5cbnZhciBmbiQ1LCBlbGVzZm4kZTtcbmZuJDUgPSBlbGVzZm4kZSA9IHtcbiAgZGF0YTogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIGltbXV0YWJsZUtleXM6IHtcbiAgICAgICdpZCc6IHRydWUsXG4gICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICd0YXJnZXQnOiB0cnVlLFxuICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICB9LFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByZW1vdmVEYXRhOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBldmVudDogJ2RhdGEnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgJ2lkJzogdHJ1ZSxcbiAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAncGFyZW50JzogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHNjcmF0Y2g6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgZXZlbnQ6ICdzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByc2NyYXRjaDogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgfSksXG4gIHJlbW92ZVJzY3JhdGNoOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICB9KSxcbiAgaWQ6IGZ1bmN0aW9uIGlkKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFsaWFzZXNcbmZuJDUuYXR0ciA9IGZuJDUuZGF0YTtcbmZuJDUucmVtb3ZlQXR0ciA9IGZuJDUucmVtb3ZlRGF0YTtcbnZhciBkYXRhID0gZWxlc2ZuJGU7XG5cbnZhciBlbGVzZm4kZCA9IHt9O1xuZnVuY3Rpb24gZGVmaW5lRGVncmVlRnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmNsdWRlTG9vcHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKGluY2x1ZGVMb29wcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmNsdWRlTG9vcHMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNlbGYuaXNOb2RlKCkgJiYgIXNlbGYucmVtb3ZlZCgpKSB7XG4gICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgIHZhciBub2RlID0gc2VsZlswXTtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbaV07XG4gICAgICAgIGlmICghaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkZWdyZWUgKz0gY2FsbGJhY2sobm9kZSwgZWRnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVncmVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xufVxuZXh0ZW5kKGVsZXNmbiRkLCB7XG4gIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKGVkZ2UudGFyZ2V0KCkpKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9KSxcbiAgaW5kZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBlZGdlKSB7XG4gICAgaWYgKGVkZ2UudGFyZ2V0KCkuc2FtZShub2RlKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSksXG4gIG91dGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGVkZ2UpIHtcbiAgICBpZiAoZWRnZS5zb3VyY2UoKS5zYW1lKG5vZGUpKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9KVxufSk7XG5mdW5jdGlvbiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbihkZWdyZWVGbiwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpbmNsdWRlTG9vcHMpIHtcbiAgICB2YXIgcmV0O1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gbm9kZXNbaV07XG4gICAgICB2YXIgZGVncmVlID0gZWxlW2RlZ3JlZUZuXShpbmNsdWRlTG9vcHMpO1xuICAgICAgaWYgKGRlZ3JlZSAhPT0gdW5kZWZpbmVkICYmIChyZXQgPT09IHVuZGVmaW5lZCB8fCBjYWxsYmFjayhkZWdyZWUsIHJldCkpKSB7XG4gICAgICAgIHJldCA9IGRlZ3JlZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn1cbmV4dGVuZChlbGVzZm4kZCwge1xuICBtaW5EZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9KSxcbiAgbWF4RGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWF4KSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgfSksXG4gIG1pbkluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9KSxcbiAgbWF4SW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uIChkZWdyZWUsIG1heCkge1xuICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gIH0pLFxuICBtaW5PdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbiAoZGVncmVlLCBtaW4pIHtcbiAgICByZXR1cm4gZGVncmVlIDwgbWluO1xuICB9KSxcbiAgbWF4T3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24gKGRlZ3JlZSwgbWF4KSB7XG4gICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgfSlcbn0pO1xuZXh0ZW5kKGVsZXNmbiRkLCB7XG4gIHRvdGFsRGVncmVlOiBmdW5jdGlvbiB0b3RhbERlZ3JlZShpbmNsdWRlTG9vcHMpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbCArPSBub2Rlc1tpXS5kZWdyZWUoaW5jbHVkZUxvb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG59KTtcblxudmFyIGZuJDQsIGVsZXNmbiRjO1xudmFyIGJlZm9yZVBvc2l0aW9uU2V0ID0gZnVuY3Rpb24gYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCBzaWxlbnQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgaWYgKCFlbGUubG9ja2VkKCkpIHtcbiAgICAgIHZhciBvbGRQb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgZGVsdGEgPSB7XG4gICAgICAgIHg6IG5ld1Bvcy54ICE9IG51bGwgPyBuZXdQb3MueCAtIG9sZFBvcy54IDogMCxcbiAgICAgICAgeTogbmV3UG9zLnkgIT0gbnVsbCA/IG5ld1Bvcy55IC0gb2xkUG9zLnkgOiAwXG4gICAgICB9O1xuICAgICAgaWYgKGVsZS5pc1BhcmVudCgpICYmICEoZGVsdGEueCA9PT0gMCAmJiBkZWx0YS55ID09PSAwKSkge1xuICAgICAgICBlbGUuY2hpbGRyZW4oKS5zaGlmdChkZWx0YSwgc2lsZW50KTtcbiAgICAgIH1cbiAgICAgIGVsZS5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgcG9zaXRpb25EZWYgPSB7XG4gIGZpZWxkOiAncG9zaXRpb24nLFxuICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICBzZXR0aW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICB0cmlnZ2VyRm5OYW1lOiAnZW1pdEFuZE5vdGlmeScsXG4gIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICBiZWZvcmVHZXQ6IGZ1bmN0aW9uIGJlZm9yZUdldChlbGUpIHtcbiAgICBlbGUudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgfSxcbiAgYmVmb3JlU2V0OiBmdW5jdGlvbiBiZWZvcmVTZXQoZWxlcywgbmV3UG9zKSB7XG4gICAgYmVmb3JlUG9zaXRpb25TZXQoZWxlcywgbmV3UG9zLCBmYWxzZSk7XG4gIH0sXG4gIG9uU2V0OiBmdW5jdGlvbiBvblNldChlbGVzKSB7XG4gICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgfSxcbiAgY2FuU2V0OiBmdW5jdGlvbiBjYW5TZXQoZWxlKSB7XG4gICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gIH1cbn07XG5mbiQ0ID0gZWxlc2ZuJGMgPSB7XG4gIHBvc2l0aW9uOiBkZWZpbmUuZGF0YShwb3NpdGlvbkRlZiksXG4gIC8vIHBvc2l0aW9uIGJ1dCBubyBub3RpZmljYXRpb24gdG8gcmVuZGVyZXJcbiAgc2lsZW50UG9zaXRpb246IGRlZmluZS5kYXRhKGV4dGVuZCh7fSwgcG9zaXRpb25EZWYsIHtcbiAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICBiZWZvcmVTZXQ6IGZ1bmN0aW9uIGJlZm9yZVNldChlbGVzLCBuZXdQb3MpIHtcbiAgICAgIGJlZm9yZVBvc2l0aW9uU2V0KGVsZXMsIG5ld1BvcywgdHJ1ZSk7XG4gICAgfSxcbiAgICBvblNldDogZnVuY3Rpb24gb25TZXQoZWxlcykge1xuICAgICAgZWxlcy5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICB9XG4gIH0pKSxcbiAgcG9zaXRpb25zOiBmdW5jdGlvbiBwb3NpdGlvbnMocG9zLCBzaWxlbnQpIHtcbiAgICBpZiAocGxhaW5PYmplY3QocG9zKSkge1xuICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICB0aGlzLnNpbGVudFBvc2l0aW9uKHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvc2l0aW9uKHBvcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmbiQ2KHBvcykpIHtcbiAgICAgIHZhciBfZm4gPSBwb3M7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBfcG9zID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoX3BvcyA9IF9mbihlbGUsIGkpKSB7XG4gICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgZWxlLnNpbGVudFBvc2l0aW9uKF9wb3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGUucG9zaXRpb24oX3Bvcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgc2lsZW50UG9zaXRpb25zOiBmdW5jdGlvbiBzaWxlbnRQb3NpdGlvbnMocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpb25zKHBvcywgdHJ1ZSk7XG4gIH0sXG4gIHNoaWZ0OiBmdW5jdGlvbiBzaGlmdChkaW0sIHZhbCwgc2lsZW50KSB7XG4gICAgdmFyIGRlbHRhO1xuICAgIGlmIChwbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICBkZWx0YSA9IHtcbiAgICAgICAgeDogbnVtYmVyJDEoZGltLngpID8gZGltLnggOiAwLFxuICAgICAgICB5OiBudW1iZXIkMShkaW0ueSkgPyBkaW0ueSA6IDBcbiAgICAgIH07XG4gICAgICBzaWxlbnQgPSB2YWw7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoZGltKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICBkZWx0YSA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGRlbHRhW2RpbV0gPSB2YWw7XG4gICAgfVxuICAgIGlmIChkZWx0YSAhPSBudWxsKSB7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgLy8gZXhjbHVkZSBhbnkgbm9kZSB0aGF0IGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgY2FsbGluZyBjb2xsZWN0aW9uXG4gICAgICAgIGlmIChjeS5oYXNDb21wb3VuZE5vZGVzKCkgJiYgZWxlLmlzQ2hpbGQoKSAmJiBlbGUuYW5jZXN0b3JzKCkuYW55U2FtZSh0aGlzKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIG5ld1BvcyA9IHtcbiAgICAgICAgICB4OiBwb3MueCArIGRlbHRhLngsXG4gICAgICAgICAgeTogcG9zLnkgKyBkZWx0YS55XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaWxlbnQpIHtcbiAgICAgICAgICBlbGUuc2lsZW50UG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGUucG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3kuZW5kQmF0Y2goKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNpbGVudFNoaWZ0OiBmdW5jdGlvbiBzaWxlbnRTaGlmdChkaW0sIHZhbCkge1xuICAgIGlmIChwbGFpbk9iamVjdChkaW0pKSB7XG4gICAgICB0aGlzLnNoaWZ0KGRpbSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoZGltKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICB0aGlzLnNoaWZ0KGRpbSwgdmFsLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGdldC9zZXQgdGhlIHJlbmRlcmVkIChpLmUuIG9uIHNjcmVlbikgcG9zaXRvbiBvZiB0aGUgZWxlbWVudFxuICByZW5kZXJlZFBvc2l0aW9uOiBmdW5jdGlvbiByZW5kZXJlZFBvc2l0aW9uKGRpbSwgdmFsKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICB2YXIgcnBvcyA9IHBsYWluT2JqZWN0KGRpbSkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHNldHRpbmcgPSBycG9zICE9PSB1bmRlZmluZWQgfHwgdmFsICE9PSB1bmRlZmluZWQgJiYgc3RyaW5nKGRpbSk7XG4gICAgaWYgKGVsZSAmJiBlbGUuaXNOb2RlKCkpIHtcbiAgICAgIC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgIGlmIChzZXR0aW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBfZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICBfZWxlLnBvc2l0aW9uKGRpbSwgKHZhbCAtIHBhbltkaW1dKSAvIHpvb20pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocnBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIF9lbGUucG9zaXRpb24ocmVuZGVyZWRUb01vZGVsUG9zaXRpb24ocnBvcywgem9vbSwgcGFuKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnZXR0aW5nXG4gICAgICAgIHZhciBwb3MgPSBlbGUucG9zaXRpb24oKTtcbiAgICAgICAgcnBvcyA9IG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uJDEocG9zLCB6b29tLCBwYW4pO1xuICAgICAgICBpZiAoZGltID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICByZXR1cm4gcnBvcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgIHJldHVybiBycG9zW2RpbV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzZXR0aW5nKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICAvLyBnZXQvc2V0IHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gIHJlbGF0aXZlUG9zaXRpb246IGZ1bmN0aW9uIHJlbGF0aXZlUG9zaXRpb24oZGltLCB2YWwpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIHBwb3MgPSBwbGFpbk9iamVjdChkaW0pID8gZGltIDogdW5kZWZpbmVkO1xuICAgIHZhciBzZXR0aW5nID0gcHBvcyAhPT0gdW5kZWZpbmVkIHx8IHZhbCAhPT0gdW5kZWZpbmVkICYmIHN0cmluZyhkaW0pO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIGlmIChlbGUgJiYgZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICBpZiAoc2V0dGluZykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX2VsZTIgPSB0aGlzW2ldO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gX2VsZTIucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG4gICAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5wb3NpdGlvbigpIDoge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKGRpbSwgdmFsICsgb3JpZ2luW2RpbV0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgIF9lbGUyLnBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgIHk6IHBwb3MueSArIG9yaWdpbi55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGdldHRpbmdcbiAgICAgICAgdmFyIHBvcyA9IGVsZS5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgX3BhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICB2YXIgX2hhc1BhcmVudCA9IF9wYXJlbnQgJiYgX3BhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgX3JlbGF0aXZlVG9QYXJlbnQgPSBfaGFzUGFyZW50O1xuICAgICAgICBpZiAoX2hhc1BhcmVudCkge1xuICAgICAgICAgIF9wYXJlbnQgPSBfcGFyZW50WzBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfb3JpZ2luID0gX3JlbGF0aXZlVG9QYXJlbnQgPyBfcGFyZW50LnBvc2l0aW9uKCkgOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIHBwb3MgPSB7XG4gICAgICAgICAgeDogcG9zLnggLSBfb3JpZ2luLngsXG4gICAgICAgICAgeTogcG9zLnkgLSBfb3JpZ2luLnlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRpbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgcmV0dXJuIHBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICByZXR1cm4gcHBvc1tkaW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc2V0dGluZykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfVxufTtcblxuLy8gYWxpYXNlc1xuZm4kNC5tb2RlbFBvc2l0aW9uID0gZm4kNC5wb2ludCA9IGZuJDQucG9zaXRpb247XG5mbiQ0Lm1vZGVsUG9zaXRpb25zID0gZm4kNC5wb2ludHMgPSBmbiQ0LnBvc2l0aW9ucztcbmZuJDQucmVuZGVyZWRQb2ludCA9IGZuJDQucmVuZGVyZWRQb3NpdGlvbjtcbmZuJDQucmVsYXRpdmVQb2ludCA9IGZuJDQucmVsYXRpdmVQb3NpdGlvbjtcbnZhciBwb3NpdGlvbiA9IGVsZXNmbiRjO1xuXG52YXIgZm4kMywgZWxlc2ZuJGI7XG5mbiQzID0gZWxlc2ZuJGIgPSB7fTtcbmVsZXNmbiRiLnJlbmRlcmVkQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94KG9wdGlvbnMpO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciB4MSA9IGJiLngxICogem9vbSArIHBhbi54O1xuICB2YXIgeDIgPSBiYi54MiAqIHpvb20gKyBwYW4ueDtcbiAgdmFyIHkxID0gYmIueTEgKiB6b29tICsgcGFuLnk7XG4gIHZhciB5MiA9IGJiLnkyICogem9vbSArIHBhbi55O1xuICByZXR1cm4ge1xuICAgIHgxOiB4MSxcbiAgICB4MjogeDIsXG4gICAgeTE6IHkxLFxuICAgIHkyOiB5MixcbiAgICB3OiB4MiAtIHgxLFxuICAgIGg6IHkyIC0geTFcbiAgfTtcbn07XG5lbGVzZm4kYi5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaWxlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gIGlmICghY3kuc3R5bGVFbmFibGVkKCkgfHwgIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuZm9yRWFjaFVwKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIF9wLmNvbXBvdW5kQm91bmRzQ2xlYW4gPSBmYWxzZTtcbiAgICAgIF9wLmJiQ2FjaGUgPSBudWxsO1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgZWxlLmVtaXRBbmROb3RpZnkoJ2JvdW5kcycpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcbmVsZXNmbiRiLnVwZGF0ZUNvbXBvdW5kQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZm9yY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgLy8gbm90IHBvc3NpYmxlIHRvIGRvIG9uIG5vbi1jb21wb3VuZCBncmFwaHMgb3Igd2l0aCB0aGUgc3R5bGUgZGlzYWJsZWRcbiAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzYXZlIGN5Y2xlcyB3aGVuIGJhdGNoaW5nIC0tIGJ1dCBib3VuZHMgd2lsbCBiZSBzdGFsZSAob3Igbm90IGV4aXN0IHlldClcbiAgaWYgKCFmb3JjZSAmJiBjeS5iYXRjaGluZygpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlKHBhcmVudCkge1xuICAgIGlmICghcGFyZW50LmlzUGFyZW50KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIF9wID0gcGFyZW50Ll9wcml2YXRlO1xuICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbigpO1xuICAgIHZhciBpbmNsdWRlTGFiZWxzID0gcGFyZW50LnBzdHlsZSgnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnKS52YWx1ZSA9PT0gJ2luY2x1ZGUnO1xuICAgIHZhciBtaW4gPSB7XG4gICAgICB3aWR0aDoge1xuICAgICAgICB2YWw6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aCcpLnBmVmFsdWUsXG4gICAgICAgIGxlZnQ6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aC1iaWFzLWxlZnQnKSxcbiAgICAgICAgcmlnaHQ6IHBhcmVudC5wc3R5bGUoJ21pbi13aWR0aC1iaWFzLXJpZ2h0JylcbiAgICAgIH0sXG4gICAgICBoZWlnaHQ6IHtcbiAgICAgICAgdmFsOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0JykucGZWYWx1ZSxcbiAgICAgICAgdG9wOiBwYXJlbnQucHN0eWxlKCdtaW4taGVpZ2h0LWJpYXMtdG9wJyksXG4gICAgICAgIGJvdHRvbTogcGFyZW50LnBzdHlsZSgnbWluLWhlaWdodC1iaWFzLWJvdHRvbScpXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgYmIgPSBjaGlsZHJlbi5ib3VuZGluZ0JveCh7XG4gICAgICBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzLFxuICAgICAgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSxcbiAgICAgIC8vIHVwZGF0aW5nIHRoZSBjb21wb3VuZCBib3VuZHMgaGFwcGVucyBvdXRzaWRlIG9mIHRoZSByZWd1bGFyXG4gICAgICAvLyBjYWNoZSBjeWNsZSAoaS5lLiBiZWZvcmUgZmlyZWQgZXZlbnRzKVxuICAgICAgdXNlQ2FjaGU6IGZhbHNlXG4gICAgfSk7XG4gICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuXG4gICAgLy8gaWYgY2hpbGRyZW4gdGFrZSB1cCB6ZXJvIGFyZWEgdGhlbiBrZWVwIHBvc2l0aW9uIGFuZCBmYWxsIGJhY2sgb24gc3R5bGVzaGVldCB3L2hcbiAgICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwKSB7XG4gICAgICBiYiA9IHtcbiAgICAgICAgdzogcGFyZW50LnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLFxuICAgICAgICBoOiBwYXJlbnQucHN0eWxlKCdoZWlnaHQnKS5wZlZhbHVlXG4gICAgICB9O1xuICAgICAgYmIueDEgPSBwb3MueCAtIGJiLncgLyAyO1xuICAgICAgYmIueDIgPSBwb3MueCArIGJiLncgLyAyO1xuICAgICAgYmIueTEgPSBwb3MueSAtIGJiLmggLyAyO1xuICAgICAgYmIueTIgPSBwb3MueSArIGJiLmggLyAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlQmlhc1ZhbHVlcyhwcm9wRGlmZiwgcHJvcEJpYXMsIHByb3BCaWFzQ29tcGxlbWVudCkge1xuICAgICAgdmFyIGJpYXNEaWZmID0gMDtcbiAgICAgIHZhciBiaWFzQ29tcGxlbWVudERpZmYgPSAwO1xuICAgICAgdmFyIGJpYXNUb3RhbCA9IHByb3BCaWFzICsgcHJvcEJpYXNDb21wbGVtZW50O1xuICAgICAgaWYgKHByb3BEaWZmID4gMCAmJiBiaWFzVG90YWwgPiAwKSB7XG4gICAgICAgIGJpYXNEaWZmID0gcHJvcEJpYXMgLyBiaWFzVG90YWwgKiBwcm9wRGlmZjtcbiAgICAgICAgYmlhc0NvbXBsZW1lbnREaWZmID0gcHJvcEJpYXNDb21wbGVtZW50IC8gYmlhc1RvdGFsICogcHJvcERpZmY7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiaWFzRGlmZjogYmlhc0RpZmYsXG4gICAgICAgIGJpYXNDb21wbGVtZW50RGlmZjogYmlhc0NvbXBsZW1lbnREaWZmXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlUGFkZGluZ1ZhbHVlcyh3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nT2JqZWN0LCByZWxhdGl2ZVRvKSB7XG4gICAgICAvLyBBc3N1bWluZyBwZXJjZW50YWdlIGlzIG51bWJlciBmcm9tIDAgdG8gMVxuICAgICAgaWYgKHBhZGRpbmdPYmplY3QudW5pdHMgPT09ICclJykge1xuICAgICAgICBzd2l0Y2ggKHJlbGF0aXZlVG8pIHtcbiAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiAwO1xuICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICByZXR1cm4gaGVpZ2h0ID4gMCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIGhlaWdodCA6IDA7XG4gICAgICAgICAgY2FzZSAnYXZlcmFnZSc6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyBwYWRkaW5nT2JqZWN0LnBmVmFsdWUgKiAod2lkdGggKyBoZWlnaHQpIC8gMiA6IDA7XG4gICAgICAgICAgY2FzZSAnbWluJzpcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCA/IHdpZHRoID4gaGVpZ2h0ID8gcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogcGFkZGluZ09iamVjdC5wZlZhbHVlICogd2lkdGggOiAwO1xuICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiAwICYmIGhlaWdodCA+IDAgPyB3aWR0aCA+IGhlaWdodCA/IHBhZGRpbmdPYmplY3QucGZWYWx1ZSAqIHdpZHRoIDogcGFkZGluZ09iamVjdC5wZlZhbHVlICogaGVpZ2h0IDogMDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFkZGluZ09iamVjdC51bml0cyA9PT0gJ3B4Jykge1xuICAgICAgICByZXR1cm4gcGFkZGluZ09iamVjdC5wZlZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBsZWZ0VmFsID0gbWluLndpZHRoLmxlZnQudmFsdWU7XG4gICAgaWYgKG1pbi53aWR0aC5sZWZ0LnVuaXRzID09PSAncHgnICYmIG1pbi53aWR0aC52YWwgPiAwKSB7XG4gICAgICBsZWZ0VmFsID0gbGVmdFZhbCAqIDEwMCAvIG1pbi53aWR0aC52YWw7XG4gICAgfVxuICAgIHZhciByaWdodFZhbCA9IG1pbi53aWR0aC5yaWdodC52YWx1ZTtcbiAgICBpZiAobWluLndpZHRoLnJpZ2h0LnVuaXRzID09PSAncHgnICYmIG1pbi53aWR0aC52YWwgPiAwKSB7XG4gICAgICByaWdodFZhbCA9IHJpZ2h0VmFsICogMTAwIC8gbWluLndpZHRoLnZhbDtcbiAgICB9XG4gICAgdmFyIHRvcFZhbCA9IG1pbi5oZWlnaHQudG9wLnZhbHVlO1xuICAgIGlmIChtaW4uaGVpZ2h0LnRvcC51bml0cyA9PT0gJ3B4JyAmJiBtaW4uaGVpZ2h0LnZhbCA+IDApIHtcbiAgICAgIHRvcFZhbCA9IHRvcFZhbCAqIDEwMCAvIG1pbi5oZWlnaHQudmFsO1xuICAgIH1cbiAgICB2YXIgYm90dG9tVmFsID0gbWluLmhlaWdodC5ib3R0b20udmFsdWU7XG4gICAgaWYgKG1pbi5oZWlnaHQuYm90dG9tLnVuaXRzID09PSAncHgnICYmIG1pbi5oZWlnaHQudmFsID4gMCkge1xuICAgICAgYm90dG9tVmFsID0gYm90dG9tVmFsICogMTAwIC8gbWluLmhlaWdodC52YWw7XG4gICAgfVxuICAgIHZhciB3aWR0aEJpYXNEaWZmcyA9IGNvbXB1dGVCaWFzVmFsdWVzKG1pbi53aWR0aC52YWwgLSBiYi53LCBsZWZ0VmFsLCByaWdodFZhbCk7XG4gICAgdmFyIGRpZmZMZWZ0ID0gd2lkdGhCaWFzRGlmZnMuYmlhc0RpZmY7XG4gICAgdmFyIGRpZmZSaWdodCA9IHdpZHRoQmlhc0RpZmZzLmJpYXNDb21wbGVtZW50RGlmZjtcbiAgICB2YXIgaGVpZ2h0Qmlhc0RpZmZzID0gY29tcHV0ZUJpYXNWYWx1ZXMobWluLmhlaWdodC52YWwgLSBiYi5oLCB0b3BWYWwsIGJvdHRvbVZhbCk7XG4gICAgdmFyIGRpZmZUb3AgPSBoZWlnaHRCaWFzRGlmZnMuYmlhc0RpZmY7XG4gICAgdmFyIGRpZmZCb3R0b20gPSBoZWlnaHRCaWFzRGlmZnMuYmlhc0NvbXBsZW1lbnREaWZmO1xuICAgIF9wLmF1dG9QYWRkaW5nID0gY29tcHV0ZVBhZGRpbmdWYWx1ZXMoYmIudywgYmIuaCwgcGFyZW50LnBzdHlsZSgncGFkZGluZycpLCBwYXJlbnQucHN0eWxlKCdwYWRkaW5nLXJlbGF0aXZlLXRvJykudmFsdWUpO1xuICAgIF9wLmF1dG9XaWR0aCA9IE1hdGgubWF4KGJiLncsIG1pbi53aWR0aC52YWwpO1xuICAgIHBvcy54ID0gKC1kaWZmTGVmdCArIGJiLngxICsgYmIueDIgKyBkaWZmUmlnaHQpIC8gMjtcbiAgICBfcC5hdXRvSGVpZ2h0ID0gTWF0aC5tYXgoYmIuaCwgbWluLmhlaWdodC52YWwpO1xuICAgIHBvcy55ID0gKC1kaWZmVG9wICsgYmIueTEgKyBiYi55MiArIGRpZmZCb3R0b20pIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgaWYgKCFfcC5jb21wb3VuZEJvdW5kc0NsZWFuIHx8IGZvcmNlKSB7XG4gICAgICB1cGRhdGUoZWxlKTtcbiAgICAgIGlmICghY3kuYmF0Y2hpbmcoKSkge1xuICAgICAgICBfcC5jb21wb3VuZEJvdW5kc0NsZWFuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xudmFyIG5vbmluZiA9IGZ1bmN0aW9uIG5vbmluZih4KSB7XG4gIGlmICh4ID09PSBJbmZpbml0eSB8fCB4ID09PSAtSW5maW5pdHkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4geDtcbn07XG52YXIgdXBkYXRlQm91bmRzID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzKGIsIHgxLCB5MSwgeDIsIHkyKSB7XG4gIC8vIGRvbid0IHVwZGF0ZSB3aXRoIHplcm8gYXJlYSBib3hlc1xuICBpZiAoeDIgLSB4MSA9PT0gMCB8fCB5MiAtIHkxID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZG9uJ3QgdXBkYXRlIHdpdGggbnVsbCBkaW1cbiAgaWYgKHgxID09IG51bGwgfHwgeTEgPT0gbnVsbCB8fCB4MiA9PSBudWxsIHx8IHkyID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYi54MSA9IHgxIDwgYi54MSA/IHgxIDogYi54MTtcbiAgYi54MiA9IHgyID4gYi54MiA/IHgyIDogYi54MjtcbiAgYi55MSA9IHkxIDwgYi55MSA/IHkxIDogYi55MTtcbiAgYi55MiA9IHkyID4gYi55MiA/IHkyIDogYi55MjtcbiAgYi53ID0gYi54MiAtIGIueDE7XG4gIGIuaCA9IGIueTIgLSBiLnkxO1xufTtcbnZhciB1cGRhdGVCb3VuZHNGcm9tQm94ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUJveChiLCBiMikge1xuICBpZiAoYjIgPT0gbnVsbCkge1xuICAgIHJldHVybiBiO1xuICB9XG4gIHJldHVybiB1cGRhdGVCb3VuZHMoYiwgYjIueDEsIGIyLnkxLCBiMi54MiwgYjIueTIpO1xufTtcbnZhciBwcmVmaXhlZFByb3BlcnR5ID0gZnVuY3Rpb24gcHJlZml4ZWRQcm9wZXJ0eShvYmosIGZpZWxkLCBwcmVmaXgpIHtcbiAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBmaWVsZCwgcHJlZml4KTtcbn07XG52YXIgdXBkYXRlQm91bmRzRnJvbUFycm93ID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICB2YXIgaGFsZkFyVyA9IHJzdHlsZS5hcnJvd1dpZHRoIC8gMjtcbiAgdmFyIGFycm93VHlwZSA9IGVsZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICB2YXIgeDtcbiAgdmFyIHk7XG4gIGlmIChhcnJvd1R5cGUgIT09ICdub25lJykge1xuICAgIGlmIChwcmVmaXggPT09ICdzb3VyY2UnKSB7XG4gICAgICB4ID0gcnN0eWxlLnNyY1g7XG4gICAgICB5ID0gcnN0eWxlLnNyY1k7XG4gICAgfSBlbHNlIGlmIChwcmVmaXggPT09ICd0YXJnZXQnKSB7XG4gICAgICB4ID0gcnN0eWxlLnRndFg7XG4gICAgICB5ID0gcnN0eWxlLnRndFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSByc3R5bGUubWlkWDtcbiAgICAgIHkgPSByc3R5bGUubWlkWTtcbiAgICB9XG5cbiAgICAvLyBhbHdheXMgc3RvcmUgdGhlIGluZGl2aWR1YWwgYXJyb3cgYm91bmRzXG4gICAgdmFyIGJicyA9IF9wLmFycm93Qm91bmRzID0gX3AuYXJyb3dCb3VuZHMgfHwge307XG4gICAgdmFyIGJiID0gYmJzW3ByZWZpeF0gPSBiYnNbcHJlZml4XSB8fCB7fTtcbiAgICBiYi54MSA9IHggLSBoYWxmQXJXO1xuICAgIGJiLnkxID0geSAtIGhhbGZBclc7XG4gICAgYmIueDIgPSB4ICsgaGFsZkFyVztcbiAgICBiYi55MiA9IHkgKyBoYWxmQXJXO1xuICAgIGJiLncgPSBiYi54MiAtIGJiLngxO1xuICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiLCAxKTtcbiAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBiYi54MSwgYmIueTEsIGJiLngyLCBiYi55Mik7XG4gIH1cbn07XG52YXIgdXBkYXRlQm91bmRzRnJvbUxhYmVsID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCBwcmVmaXgpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHByZWZpeERhc2g7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcmVmaXhEYXNoID0gcHJlZml4ICsgJy0nO1xuICB9IGVsc2Uge1xuICAgIHByZWZpeERhc2ggPSAnJztcbiAgfVxuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBsYWJlbCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnN0clZhbHVlO1xuICBpZiAobGFiZWwpIHtcbiAgICB2YXIgaGFsaWduID0gZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKTtcbiAgICB2YXIgdmFsaWduID0gZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKTtcbiAgICB2YXIgbGFiZWxXaWR0aCA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCk7XG4gICAgdmFyIGxhYmVsSGVpZ2h0ID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbEhlaWdodCcsIHByZWZpeCk7XG4gICAgdmFyIGxhYmVsWCA9IHByZWZpeGVkUHJvcGVydHkocnN0eWxlLCAnbGFiZWxYJywgcHJlZml4KTtcbiAgICB2YXIgbGFiZWxZID0gcHJlZml4ZWRQcm9wZXJ0eShyc3R5bGUsICdsYWJlbFknLCBwcmVmaXgpO1xuICAgIHZhciBtYXJnaW5YID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlO1xuICAgIHZhciBpc0VkZ2UgPSBlbGUuaXNFZGdlKCk7XG4gICAgdmFyIHJvdGF0aW9uID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgICB2YXIgb3V0bGluZVdpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgYm9yZGVyV2lkdGggPSBlbGUucHN0eWxlKCd0ZXh0LWJvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgdmFyIGhhbGZCb3JkZXJXaWR0aCA9IGJvcmRlcldpZHRoIC8gMjtcbiAgICB2YXIgcGFkZGluZyA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJykucGZWYWx1ZTtcbiAgICB2YXIgbWFyZ2luT2ZFcnJvciA9IDI7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcblxuICAgIHZhciBsaCA9IGxhYmVsSGVpZ2h0O1xuICAgIHZhciBsdyA9IGxhYmVsV2lkdGg7XG4gICAgdmFyIGx3XzIgPSBsdyAvIDI7XG4gICAgdmFyIGxoXzIgPSBsaCAvIDI7XG4gICAgdmFyIGx4MSwgbHgyLCBseTEsIGx5MjtcbiAgICBpZiAoaXNFZGdlKSB7XG4gICAgICBseDEgPSBsYWJlbFggLSBsd18yO1xuICAgICAgbHgyID0gbGFiZWxYICsgbHdfMjtcbiAgICAgIGx5MSA9IGxhYmVsWSAtIGxoXzI7XG4gICAgICBseTIgPSBsYWJlbFkgKyBsaF8yO1xuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGhhbGlnbi52YWx1ZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdztcbiAgICAgICAgICBseDIgPSBsYWJlbFg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHdfMjtcbiAgICAgICAgICBseDIgPSBsYWJlbFggKyBsd18yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbHgxID0gbGFiZWxYO1xuICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh2YWxpZ24udmFsdWUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaDtcbiAgICAgICAgICBseTIgPSBsYWJlbFk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGhfMjtcbiAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaF8yO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIGx5MSA9IGxhYmVsWTtcbiAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzaGlmdCBieSBtYXJnaW4gYW5kIGV4cGFuZCBieSBvdXRsaW5lIGFuZCBib3JkZXJcbiAgICB2YXIgbGVmdFBhZCA9IG1hcmdpblggLSBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgLSBwYWRkaW5nIC0gbWFyZ2luT2ZFcnJvcjtcbiAgICB2YXIgcmlnaHRQYWQgPSBtYXJnaW5YICsgTWF0aC5tYXgob3V0bGluZVdpZHRoLCBoYWxmQm9yZGVyV2lkdGgpICsgcGFkZGluZyArIG1hcmdpbk9mRXJyb3I7XG4gICAgdmFyIHRvcFBhZCA9IG1hcmdpblkgLSBNYXRoLm1heChvdXRsaW5lV2lkdGgsIGhhbGZCb3JkZXJXaWR0aCkgLSBwYWRkaW5nIC0gbWFyZ2luT2ZFcnJvcjtcbiAgICB2YXIgYm90UGFkID0gbWFyZ2luWSArIE1hdGgubWF4KG91dGxpbmVXaWR0aCwgaGFsZkJvcmRlcldpZHRoKSArIHBhZGRpbmcgKyBtYXJnaW5PZkVycm9yO1xuICAgIGx4MSArPSBsZWZ0UGFkO1xuICAgIGx4MiArPSByaWdodFBhZDtcbiAgICBseTEgKz0gdG9wUGFkO1xuICAgIGx5MiArPSBib3RQYWQ7XG5cbiAgICAvLyBhbHdheXMgc3RvcmUgdGhlIHVucm90YXRlZCBsYWJlbCBib3VuZHMgc2VwYXJhdGVseVxuICAgIHZhciBiYlByZWZpeCA9IHByZWZpeCB8fCAnbWFpbic7XG4gICAgdmFyIGJicyA9IF9wLmxhYmVsQm91bmRzO1xuICAgIHZhciBiYiA9IGJic1tiYlByZWZpeF0gPSBiYnNbYmJQcmVmaXhdIHx8IHt9O1xuICAgIGJiLngxID0gbHgxO1xuICAgIGJiLnkxID0gbHkxO1xuICAgIGJiLngyID0gbHgyO1xuICAgIGJiLnkyID0gbHkyO1xuICAgIGJiLncgPSBseDIgLSBseDE7XG4gICAgYmIuaCA9IGx5MiAtIGx5MTtcbiAgICBiYi5sZWZ0UGFkID0gbGVmdFBhZDtcbiAgICBiYi5yaWdodFBhZCA9IHJpZ2h0UGFkO1xuICAgIGJiLnRvcFBhZCA9IHRvcFBhZDtcbiAgICBiYi5ib3RQYWQgPSBib3RQYWQ7XG4gICAgdmFyIGlzQXV0b3JvdGF0ZSA9IGlzRWRnZSAmJiByb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnO1xuICAgIHZhciBpc1BmVmFsdWUgPSByb3RhdGlvbi5wZlZhbHVlICE9IG51bGwgJiYgcm90YXRpb24ucGZWYWx1ZSAhPT0gMDtcbiAgICBpZiAoaXNBdXRvcm90YXRlIHx8IGlzUGZWYWx1ZSkge1xuICAgICAgdmFyIHRoZXRhID0gaXNBdXRvcm90YXRlID8gcHJlZml4ZWRQcm9wZXJ0eShfcC5yc3R5bGUsICdsYWJlbEFuZ2xlJywgcHJlZml4KSA6IHJvdGF0aW9uLnBmVmFsdWU7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTtcblxuICAgICAgLy8gcm90YXRpb24gcG9pbnQgKGRlZmF1bHQgdmFsdWUgZm9yIGNlbnRlci1jZW50ZXIpXG4gICAgICB2YXIgeG8gPSAobHgxICsgbHgyKSAvIDI7XG4gICAgICB2YXIgeW8gPSAobHkxICsgbHkyKSAvIDI7XG4gICAgICBpZiAoIWlzRWRnZSkge1xuICAgICAgICBzd2l0Y2ggKGhhbGlnbi52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgeG8gPSBseDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB4byA9IGx4MTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsaWduLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHlvID0gbHkyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHlvID0gbHkxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSkge1xuICAgICAgICB4ID0geCAtIHhvO1xuICAgICAgICB5ID0geSAtIHlvO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHggKiBjb3MgLSB5ICogc2luICsgeG8sXG4gICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyB5b1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZShseDEsIGx5MSk7XG4gICAgICB2YXIgcHgxeTIgPSByb3RhdGUobHgxLCBseTIpO1xuICAgICAgdmFyIHB4MnkxID0gcm90YXRlKGx4MiwgbHkxKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZShseDIsIGx5Mik7XG4gICAgICBseDEgPSBNYXRoLm1pbihweDF5MS54LCBweDF5Mi54LCBweDJ5MS54LCBweDJ5Mi54KTtcbiAgICAgIGx4MiA9IE1hdGgubWF4KHB4MXkxLngsIHB4MXkyLngsIHB4MnkxLngsIHB4MnkyLngpO1xuICAgICAgbHkxID0gTWF0aC5taW4ocHgxeTEueSwgcHgxeTIueSwgcHgyeTEueSwgcHgyeTIueSk7XG4gICAgICBseTIgPSBNYXRoLm1heChweDF5MS55LCBweDF5Mi55LCBweDJ5MS55LCBweDJ5Mi55KTtcbiAgICB9XG4gICAgdmFyIGJiUHJlZml4Um90ID0gYmJQcmVmaXggKyAnUm90JztcbiAgICB2YXIgYmJSb3QgPSBiYnNbYmJQcmVmaXhSb3RdID0gYmJzW2JiUHJlZml4Um90XSB8fCB7fTtcbiAgICBiYlJvdC54MSA9IGx4MTtcbiAgICBiYlJvdC55MSA9IGx5MTtcbiAgICBiYlJvdC54MiA9IGx4MjtcbiAgICBiYlJvdC55MiA9IGx5MjtcbiAgICBiYlJvdC53ID0gbHgyIC0gbHgxO1xuICAgIGJiUm90LmggPSBseTIgLSBseTE7XG4gICAgdXBkYXRlQm91bmRzKGJvdW5kcywgbHgxLCBseTEsIGx4MiwgbHkyKTtcbiAgICB1cGRhdGVCb3VuZHMoX3AubGFiZWxCb3VuZHMuYWxsLCBseDEsIGx5MSwgbHgyLCBseTIpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59O1xudmFyIHVwZGF0ZUJvdW5kc0Zyb21PdXRsaW5lID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbU91dGxpbmUoYm91bmRzLCBlbGUpIHtcbiAgaWYgKGVsZS5jeSgpLmhlYWRsZXNzKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG91dGxpbmVPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3V0bGluZS1vcGFjaXR5JykudmFsdWU7XG4gIHZhciBvdXRsaW5lV2lkdGggPSBlbGUucHN0eWxlKCdvdXRsaW5lLXdpZHRoJykudmFsdWU7XG4gIHZhciBvdXRsaW5lT2Zmc2V0ID0gZWxlLnBzdHlsZSgnb3V0bGluZS1vZmZzZXQnKS52YWx1ZTtcbiAgdmFyIGV4cGFuc2lvbiA9IG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQ7XG4gIHVwZGF0ZUJvdW5kc0Zyb21NaXRlcihib3VuZHMsIGVsZSwgb3V0bGluZU9wYWNpdHksIGV4cGFuc2lvbiwgJ291dHNpZGUnLCBleHBhbnNpb24gLyAyKTtcbn07XG52YXIgdXBkYXRlQm91bmRzRnJvbU1pdGVyID0gZnVuY3Rpb24gdXBkYXRlQm91bmRzRnJvbU1pdGVyKGJvdW5kcywgZWxlLCBvcGFjaXR5LCBleHBhbnNpb25TaXplLCBleHBhbnNpb25Qb3NpdGlvbiwgdXNlRmFsbGJhY2tWYWx1ZSkge1xuICBpZiAob3BhY2l0eSA9PT0gMCB8fCBleHBhbnNpb25TaXplIDw9IDAgfHwgZXhwYW5zaW9uUG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjeSA9IGVsZS5jeSgpO1xuICB2YXIgc2hhcGUgPSBlbGUucHN0eWxlKCdzaGFwZScpLnZhbHVlO1xuICB2YXIgcnNoYXBlID0gY3kucmVuZGVyZXIoKS5ub2RlU2hhcGVzW3NoYXBlXTtcbiAgdmFyIF9lbGUkcG9zaXRpb24gPSBlbGUucG9zaXRpb24oKSxcbiAgICB4ID0gX2VsZSRwb3NpdGlvbi54LFxuICAgIHkgPSBfZWxlJHBvc2l0aW9uLnk7XG4gIHZhciB3ID0gZWxlLndpZHRoKCk7XG4gIHZhciBoID0gZWxlLmhlaWdodCgpO1xuICBpZiAocnNoYXBlLmhhc01pdGVyQm91bmRzKSB7XG4gICAgaWYgKGV4cGFuc2lvblBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgZXhwYW5zaW9uU2l6ZSAvPSAyO1xuICAgIH1cbiAgICB2YXIgbWJiID0gcnNoYXBlLm1pdGVyQm91bmRzKHgsIHksIHcsIGgsIGV4cGFuc2lvblNpemUpO1xuICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYm91bmRzLCBtYmIpO1xuICB9IGVsc2UgaWYgKHVzZUZhbGxiYWNrVmFsdWUgIT0gbnVsbCAmJiB1c2VGYWxsYmFja1ZhbHVlID4gMCkge1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYm91bmRzLCBbdXNlRmFsbGJhY2tWYWx1ZSwgdXNlRmFsbGJhY2tWYWx1ZSwgdXNlRmFsbGJhY2tWYWx1ZSwgdXNlRmFsbGJhY2tWYWx1ZV0pO1xuICB9XG59O1xudmFyIHVwZGF0ZUJvdW5kc0Zyb21NaXRlckJvcmRlciA9IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kc0Zyb21NaXRlckJvcmRlcihib3VuZHMsIGVsZSkge1xuICBpZiAoZWxlLmN5KCkuaGVhZGxlc3MoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYm9yZGVyT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ2JvcmRlci1vcGFjaXR5JykudmFsdWU7XG4gIHZhciBib3JkZXJXaWR0aCA9IGVsZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBib3JkZXJQb3NpdGlvbiA9IGVsZS5wc3R5bGUoJ2JvcmRlci1wb3NpdGlvbicpLnZhbHVlO1xuICB1cGRhdGVCb3VuZHNGcm9tTWl0ZXIoYm91bmRzLCBlbGUsIGJvcmRlck9wYWNpdHksIGJvcmRlcldpZHRoLCBib3JkZXJQb3NpdGlvbik7XG59O1xuXG4vLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudHMgKGluIHJhdyBtb2RlbCBwb3NpdGlvbilcbnZhciBib3VuZGluZ0JveEltcGwgPSBmdW5jdGlvbiBib3VuZGluZ0JveEltcGwoZWxlLCBvcHRpb25zKSB7XG4gIHZhciBjeSA9IGVsZS5fcHJpdmF0ZS5jeTtcbiAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuICB2YXIgaGVhZGxlc3MgPSBjeS5oZWFkbGVzcygpO1xuICB2YXIgYm91bmRzID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGlzTm9kZSA9IGVsZS5pc05vZGUoKTtcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIGV4MSwgZXgyLCBleTEsIGV5MjsgLy8gZXh0cmVtYSBvZiBib2R5IC8gbGluZXNcbiAgdmFyIHgsIHk7IC8vIG5vZGUgcG9zXG4gIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gIHZhciBtYW51YWxFeHBhbnNpb24gPSBpc05vZGUgJiYgc3R5bGVFbmFibGVkID8gZWxlLnBzdHlsZSgnYm91bmRzLWV4cGFuc2lvbicpLnBmVmFsdWUgOiBbMF07XG5cbiAgLy8gbXVzdCB1c2UgYGRpc3BsYXlgIHByb3Agb25seSwgYXMgcmVhZGluZyBgY29tcG91bmQud2lkdGgoKWAgY2F1c2VzIHJlY3Vyc2lvblxuICAvLyAob3RoZXIgZmFjdG9ycyBsaWtlIHdpZHRoIHZhbHVlcyB3aWxsIGJlIGNvbnNpZGVyZWQgbGF0ZXIgaW4gdGhpcyBmdW5jdGlvbiBhbnl3YXkpXG4gIHZhciBpc0Rpc3BsYXllZCA9IGZ1bmN0aW9uIGlzRGlzcGxheWVkKGVsZSkge1xuICAgIHJldHVybiBlbGUucHN0eWxlKCdkaXNwbGF5JykudmFsdWUgIT09ICdub25lJztcbiAgfTtcbiAgdmFyIGRpc3BsYXllZCA9ICFzdHlsZUVuYWJsZWQgfHwgaXNEaXNwbGF5ZWQoZWxlKVxuXG4gIC8vIG11c3QgdGFrZSBpbnRvIGFjY291bnQgY29ubmVjdGVkIG5vZGVzIGIvYyBvZiBpbXBsaWNpdCBlZGdlIGhpZGluZyBvbiBkaXNwbGF5Om5vbmUgbm9kZVxuICAmJiAoIWlzRWRnZSB8fCBpc0Rpc3BsYXllZChlbGUuc291cmNlKCkpICYmIGlzRGlzcGxheWVkKGVsZS50YXJnZXQoKSkpO1xuICBpZiAoZGlzcGxheWVkKSB7XG4gICAgLy8gZGlzcGxheWVkIHN1ZmZpY2VzLCBzaW5jZSB3ZSB3aWxsIGZpbmQgemVybyBhcmVhIGVsZXMgYW55d2F5XG4gICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gMDtcbiAgICB2YXIgb3ZlcmxheVBhZGRpbmcgPSAwO1xuICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlT3ZlcmxheXMpIHtcbiAgICAgIG92ZXJsYXlPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3ZlcmxheS1vcGFjaXR5JykudmFsdWU7XG4gICAgICBpZiAob3ZlcmxheU9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgb3ZlcmxheVBhZGRpbmcgPSBlbGUucHN0eWxlKCdvdmVybGF5LXBhZGRpbmcnKS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVuZGVybGF5T3BhY2l0eSA9IDA7XG4gICAgdmFyIHVuZGVybGF5UGFkZGluZyA9IDA7XG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVVbmRlcmxheXMpIHtcbiAgICAgIHVuZGVybGF5T3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3VuZGVybGF5LW9wYWNpdHknKS52YWx1ZTtcbiAgICAgIGlmICh1bmRlcmxheU9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgdW5kZXJsYXlQYWRkaW5nID0gZWxlLnBzdHlsZSgndW5kZXJsYXktcGFkZGluZycpLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGFkZGluZyA9IE1hdGgubWF4KG92ZXJsYXlQYWRkaW5nLCB1bmRlcmxheVBhZGRpbmcpO1xuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgd0hhbGYgPSAwO1xuICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHcgPSBlbGUucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICB3SGFsZiA9IHcgLyAyO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlICYmIG9wdGlvbnMuaW5jbHVkZU5vZGVzKSB7XG4gICAgICB2YXIgcG9zID0gZWxlLnBvc2l0aW9uKCk7XG4gICAgICB4ID0gcG9zLng7XG4gICAgICB5ID0gcG9zLnk7XG4gICAgICB2YXIgX3cgPSBlbGUub3V0ZXJXaWR0aCgpO1xuICAgICAgdmFyIGhhbGZXID0gX3cgLyAyO1xuICAgICAgdmFyIGggPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciBoYWxmSCA9IGggLyAyO1xuXG4gICAgICAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgIGV4MSA9IHggLSBoYWxmVztcbiAgICAgIGV4MiA9IHggKyBoYWxmVztcbiAgICAgIGV5MSA9IHkgLSBoYWxmSDtcbiAgICAgIGV5MiA9IHkgKyBoYWxmSDtcbiAgICAgIHVwZGF0ZUJvdW5kcyhib3VuZHMsIGV4MSwgZXkxLCBleDIsIGV5Mik7XG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21PdXRsaW5lKGJvdW5kcywgZWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQgJiYgb3B0aW9ucy5pbmNsdWRlT3V0bGluZXMgJiYgIWhlYWRsZXNzKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21PdXRsaW5lKGJvdW5kcywgZWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZUVuYWJsZWQpIHtcbiAgICAgICAgdXBkYXRlQm91bmRzRnJvbU1pdGVyQm9yZGVyKGJvdW5kcywgZWxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRWRnZSAmJiBvcHRpb25zLmluY2x1ZGVFZGdlcykge1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCAmJiAhaGVhZGxlc3MpIHtcbiAgICAgICAgdmFyIGN1cnZlU3R5bGUgPSBlbGUucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnN0clZhbHVlO1xuXG4gICAgICAgIC8vIGhhbmRsZSBlZGdlIGRpbWVuc2lvbnMgKHJvdWdoIGJveCBlc3RpbWF0ZSlcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIGV4MSA9IE1hdGgubWluKHJzdHlsZS5zcmNYLCByc3R5bGUubWlkWCwgcnN0eWxlLnRndFgpO1xuICAgICAgICBleDIgPSBNYXRoLm1heChyc3R5bGUuc3JjWCwgcnN0eWxlLm1pZFgsIHJzdHlsZS50Z3RYKTtcbiAgICAgICAgZXkxID0gTWF0aC5taW4ocnN0eWxlLnNyY1ksIHJzdHlsZS5taWRZLCByc3R5bGUudGd0WSk7XG4gICAgICAgIGV5MiA9IE1hdGgubWF4KHJzdHlsZS5zcmNZLCByc3R5bGUubWlkWSwgcnN0eWxlLnRndFkpO1xuXG4gICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcbiAgICAgICAgZXgxIC09IHdIYWxmO1xuICAgICAgICBleDIgKz0gd0hhbGY7XG4gICAgICAgIGV5MSAtPSB3SGFsZjtcbiAgICAgICAgZXkyICs9IHdIYWxmO1xuICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuXG4gICAgICAgIC8vIHByZWNpc2UgZWRnZXNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICAgICAgdmFyIGhwdHMgPSByc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICAgICAgaWYgKGhwdHMgJiYgaHB0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGV4MSA9IGhwdHNbMF0ueDtcbiAgICAgICAgICAgIGV5MSA9IGhwdHNbMF0ueTtcbiAgICAgICAgICAgIGV4MiA9IGhwdHNbMV0ueDtcbiAgICAgICAgICAgIGV5MiA9IGhwdHNbMV0ueTtcbiAgICAgICAgICAgIGlmIChleDEgPiBleDIpIHtcbiAgICAgICAgICAgICAgdmFyIHRlbXAgPSBleDE7XG4gICAgICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICAgICAgZXgyID0gdGVtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleTEgPiBleTIpIHtcbiAgICAgICAgICAgICAgdmFyIF90ZW1wID0gZXkxO1xuICAgICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICAgIGV5MiA9IF90ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgZXgxIC0gd0hhbGYsIGV5MSAtIHdIYWxmLCBleDIgKyB3SGFsZiwgZXkyICsgd0hhbGYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjdXJ2ZVN0eWxlID09PSAnYmV6aWVyJyB8fCBjdXJ2ZVN0eWxlID09PSAndW5idW5kbGVkLWJlemllcicgfHwgZW5kc1dpdGgoY3VydmVTdHlsZSwgJ3NlZ21lbnRzJykgfHwgZW5kc1dpdGgoY3VydmVTdHlsZSwgJ3RheGknKSkge1xuICAgICAgICAgIHZhciBwdHM7XG4gICAgICAgICAgc3dpdGNoIChjdXJ2ZVN0eWxlKSB7XG4gICAgICAgICAgICBjYXNlICdiZXppZXInOlxuICAgICAgICAgICAgY2FzZSAndW5idW5kbGVkLWJlemllcic6XG4gICAgICAgICAgICAgIHB0cyA9IHJzdHlsZS5iZXppZXJQdHM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgICAgICAgY2FzZSAndGF4aSc6XG4gICAgICAgICAgICBjYXNlICdyb3VuZC1zZWdtZW50cyc6XG4gICAgICAgICAgICBjYXNlICdyb3VuZC10YXhpJzpcbiAgICAgICAgICAgICAgcHRzID0gcnN0eWxlLmxpbmVQdHM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBwdCA9IHB0c1tqXTtcbiAgICAgICAgICAgICAgZXgxID0gcHQueCAtIHdIYWxmO1xuICAgICAgICAgICAgICBleDIgPSBwdC54ICsgd0hhbGY7XG4gICAgICAgICAgICAgIGV5MSA9IHB0LnkgLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXkyID0gcHQueSArIHdIYWxmO1xuICAgICAgICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBiZXppZXItbGlrZSBvciBzZWdtZW50LWxpa2UgZWRnZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaGVhZGxlc3Mgb3Igc3R5bGUgZGlzYWJsZWRcblxuICAgICAgICAvLyBmYWxsYmFjayBvbiBzb3VyY2UgYW5kIHRhcmdldCBwb3NpdGlvbnNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgdmFyIG4xID0gZWxlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgbjFwb3MgPSBuMS5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgbjIgPSBlbGUudGFyZ2V0KCk7XG4gICAgICAgIHZhciBuMnBvcyA9IG4yLnBvc2l0aW9uKCk7XG4gICAgICAgIGV4MSA9IG4xcG9zLng7XG4gICAgICAgIGV4MiA9IG4ycG9zLng7XG4gICAgICAgIGV5MSA9IG4xcG9zLnk7XG4gICAgICAgIGV5MiA9IG4ycG9zLnk7XG4gICAgICAgIGlmIChleDEgPiBleDIpIHtcbiAgICAgICAgICB2YXIgX3RlbXAyID0gZXgxO1xuICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICBleDIgPSBfdGVtcDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV5MSA+IGV5Mikge1xuICAgICAgICAgIHZhciBfdGVtcDMgPSBleTE7XG4gICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgIGV5MiA9IF90ZW1wMztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IGVkZ2Ugd2lkdGhcbiAgICAgICAgZXgxIC09IHdIYWxmO1xuICAgICAgICBleDIgKz0gd0hhbGY7XG4gICAgICAgIGV5MSAtPSB3SGFsZjtcbiAgICAgICAgZXkyICs9IHdIYWxmO1xuICAgICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEsIGV5MSwgZXgyLCBleTIpO1xuICAgICAgfSAvLyBoZWFkbGVzcyBvciBzdHlsZSBkaXNhYmxlZFxuICAgIH0gLy8gZWRnZXNcblxuICAgIC8vIGhhbmRsZSBlZGdlIGFycm93IHNpemVcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICBpZiAoc3R5bGVFbmFibGVkICYmIG9wdGlvbnMuaW5jbHVkZUVkZ2VzICYmIGlzRWRnZSkge1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAnbWlkLXNvdXJjZScpO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAnbWlkLXRhcmdldCcpO1xuICAgICAgdXBkYXRlQm91bmRzRnJvbUFycm93KGJvdW5kcywgZWxlLCAnc291cmNlJyk7XG4gICAgICB1cGRhdGVCb3VuZHNGcm9tQXJyb3coYm91bmRzLCBlbGUsICd0YXJnZXQnKTtcbiAgICB9XG5cbiAgICAvLyBnaG9zdFxuICAgIC8vLy8vLy8vXG5cbiAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICB2YXIgZ2hvc3QgPSBlbGUucHN0eWxlKCdnaG9zdCcpLnZhbHVlID09PSAneWVzJztcbiAgICAgIGlmIChnaG9zdCkge1xuICAgICAgICB2YXIgZ3ggPSBlbGUucHN0eWxlKCdnaG9zdC1vZmZzZXQteCcpLnBmVmFsdWU7XG4gICAgICAgIHZhciBneSA9IGVsZS5wc3R5bGUoJ2dob3N0LW9mZnNldC15JykucGZWYWx1ZTtcbiAgICAgICAgdXBkYXRlQm91bmRzKGJvdW5kcywgYm91bmRzLngxICsgZ3gsIGJvdW5kcy55MSArIGd5LCBib3VuZHMueDIgKyBneCwgYm91bmRzLnkyICsgZ3kpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsd2F5cyBzdG9yZSB0aGUgYm9keSBib3VuZHMgc2VwYXJhdGVseSBmcm9tIHRoZSBsYWJlbHNcbiAgICB2YXIgYmJCb2R5ID0gX3AuYm9keUJvdW5kcyA9IF9wLmJvZHlCb3VuZHMgfHwge307XG4gICAgYXNzaWduQm91bmRpbmdCb3goYmJCb2R5LCBib3VuZHMpO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94U2lkZXMoYmJCb2R5LCBtYW51YWxFeHBhbnNpb24pO1xuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJiQm9keSwgMSk7IC8vIGV4cGFuZCB0byB3b3JrIGFyb3VuZCBicm93c2VyIGRpbWVuc2lvbiBpbmFjY3VyYWNpZXNcblxuICAgIC8vIG92ZXJsYXlcbiAgICAvLy8vLy8vLy8vXG5cbiAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICBleDEgPSBib3VuZHMueDE7XG4gICAgICBleDIgPSBib3VuZHMueDI7XG4gICAgICBleTEgPSBib3VuZHMueTE7XG4gICAgICBleTIgPSBib3VuZHMueTI7XG4gICAgICB1cGRhdGVCb3VuZHMoYm91bmRzLCBleDEgLSBwYWRkaW5nLCBleTEgLSBwYWRkaW5nLCBleDIgKyBwYWRkaW5nLCBleTIgKyBwYWRkaW5nKTtcbiAgICB9XG5cbiAgICAvLyBhbHdheXMgc3RvcmUgdGhlIGJvZHkgYm91bmRzIHNlcGFyYXRlbHkgZnJvbSB0aGUgbGFiZWxzXG4gICAgdmFyIGJiT3ZlcmxheSA9IF9wLm92ZXJsYXlCb3VuZHMgPSBfcC5vdmVybGF5Qm91bmRzIHx8IHt9O1xuICAgIGFzc2lnbkJvdW5kaW5nQm94KGJiT3ZlcmxheSwgYm91bmRzKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJiT3ZlcmxheSwgbWFudWFsRXhwYW5zaW9uKTtcbiAgICBleHBhbmRCb3VuZGluZ0JveChiYk92ZXJsYXksIDEpOyAvLyBleHBhbmQgdG8gd29yayBhcm91bmQgYnJvd3NlciBkaW1lbnNpb24gaW5hY2N1cmFjaWVzXG5cbiAgICAvLyBoYW5kbGUgbGFiZWwgZGltZW5zaW9uc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICB2YXIgYmJMYWJlbHMgPSBfcC5sYWJlbEJvdW5kcyA9IF9wLmxhYmVsQm91bmRzIHx8IHt9O1xuICAgIGlmIChiYkxhYmVscy5hbGwgIT0gbnVsbCkge1xuICAgICAgY2xlYXJCb3VuZGluZ0JveChiYkxhYmVscy5hbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYkxhYmVscy5hbGwgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICB9XG4gICAgaWYgKHN0eWxlRW5hYmxlZCAmJiBvcHRpb25zLmluY2x1ZGVMYWJlbHMpIHtcbiAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVNYWluTGFiZWxzKSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21MYWJlbChib3VuZHMsIGVsZSwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFZGdlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVTb3VyY2VMYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tTGFiZWwoYm91bmRzLCBlbGUsICdzb3VyY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUxhYmVsKGJvdW5kcywgZWxlLCAndGFyZ2V0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHN0eWxlIGVuYWJsZWQgZm9yIGxhYmVsc1xuICB9IC8vIGlmIGRpc3BsYXllZFxuXG4gIGJvdW5kcy54MSA9IG5vbmluZihib3VuZHMueDEpO1xuICBib3VuZHMueTEgPSBub25pbmYoYm91bmRzLnkxKTtcbiAgYm91bmRzLngyID0gbm9uaW5mKGJvdW5kcy54Mik7XG4gIGJvdW5kcy55MiA9IG5vbmluZihib3VuZHMueTIpO1xuICBib3VuZHMudyA9IG5vbmluZihib3VuZHMueDIgLSBib3VuZHMueDEpO1xuICBib3VuZHMuaCA9IG5vbmluZihib3VuZHMueTIgLSBib3VuZHMueTEpO1xuICBpZiAoYm91bmRzLncgPiAwICYmIGJvdW5kcy5oID4gMCAmJiBkaXNwbGF5ZWQpIHtcbiAgICBleHBhbmRCb3VuZGluZ0JveFNpZGVzKGJvdW5kcywgbWFudWFsRXhwYW5zaW9uKTtcblxuICAgIC8vIGV4cGFuZCBib3VuZHMgYnkgMSBiZWNhdXNlIGFudGlhbGlhc2luZyBjYW4gaW5jcmVhc2UgdGhlIHZpc3VhbC9lZmZlY3RpdmUgc2l6ZSBieSAxIG9uIGFsbCBzaWRlc1xuICAgIGV4cGFuZEJvdW5kaW5nQm94KGJvdW5kcywgMSk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn07XG52YXIgZ2V0S2V5ID0gZnVuY3Rpb24gZ2V0S2V5KG9wdHMpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgdGYgPSBmdW5jdGlvbiB0Zih2YWwpIHtcbiAgICByZXR1cm4gKHZhbCA/IDEgOiAwKSA8PCBpKys7XG4gIH07XG4gIHZhciBrZXkgPSAwO1xuICBrZXkgKz0gdGYob3B0cy5pbmN1ZGVOb2Rlcyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVFZGdlcyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlTWFpbkxhYmVscyk7XG4gIGtleSArPSB0ZihvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMpO1xuICBrZXkgKz0gdGYob3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZU92ZXJsYXlzKTtcbiAga2V5ICs9IHRmKG9wdHMuaW5jbHVkZU91dGxpbmVzKTtcbiAgcmV0dXJuIGtleTtcbn07XG52YXIgZ2V0Qm91bmRpbmdCb3hQb3NLZXkgPSBmdW5jdGlvbiBnZXRCb3VuZGluZ0JveFBvc0tleShlbGUpIHtcbiAgdmFyIHIgPSBmdW5jdGlvbiByKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4KTtcbiAgfTtcbiAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgIHZhciBwMSA9IGVsZS5zb3VyY2UoKS5wb3NpdGlvbigpO1xuICAgIHZhciBwMiA9IGVsZS50YXJnZXQoKS5wb3NpdGlvbigpO1xuICAgIHJldHVybiBoYXNoSW50c0FycmF5KFtyKHAxLngpLCByKHAxLnkpLCByKHAyLngpLCByKHAyLnkpXSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHAgPSBlbGUucG9zaXRpb24oKTtcbiAgICByZXR1cm4gaGFzaEludHNBcnJheShbcihwLngpLCByKHAueSldKTtcbiAgfVxufTtcbnZhciBjYWNoZWRCb3VuZGluZ0JveEltcGwgPSBmdW5jdGlvbiBjYWNoZWRCb3VuZGluZ0JveEltcGwoZWxlLCBvcHRzKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGJiO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIga2V5ID0gb3B0cyA9PSBudWxsID8gZGVmQmJPcHRzS2V5IDogZ2V0S2V5KG9wdHMpO1xuICB2YXIgdXNpbmdEZWZPcHRzID0ga2V5ID09PSBkZWZCYk9wdHNLZXk7XG4gIGlmIChfcC5iYkNhY2hlID09IG51bGwpIHtcbiAgICBiYiA9IGJvdW5kaW5nQm94SW1wbChlbGUsIGRlZkJiT3B0cyk7XG4gICAgX3AuYmJDYWNoZSA9IGJiO1xuICAgIF9wLmJiQ2FjaGVQb3NLZXkgPSBnZXRCb3VuZGluZ0JveFBvc0tleShlbGUpO1xuICB9IGVsc2Uge1xuICAgIGJiID0gX3AuYmJDYWNoZTtcbiAgfVxuXG4gIC8vIG5vdCB1c2luZyBkZWYgb3B0cyA9PiBuZWVkIHRvIGJ1aWxkIHVwIGJiIGZyb20gY29tYmluYXRpb24gb2Ygc3ViIGJic1xuICBpZiAoIXVzaW5nRGVmT3B0cykge1xuICAgIHZhciBpc05vZGUgPSBlbGUuaXNOb2RlKCk7XG4gICAgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICBpZiAob3B0cy5pbmNsdWRlTm9kZXMgJiYgaXNOb2RlIHx8IG9wdHMuaW5jbHVkZUVkZ2VzICYmICFpc05vZGUpIHtcbiAgICAgIGlmIChvcHRzLmluY2x1ZGVPdmVybGF5cykge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5vdmVybGF5Qm91bmRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZUJvdW5kc0Zyb21Cb3goYmIsIF9wLmJvZHlCb3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5pbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAob3B0cy5pbmNsdWRlTWFpbkxhYmVscyAmJiAoIWlzRWRnZSB8fCBvcHRzLmluY2x1ZGVTb3VyY2VMYWJlbHMgJiYgb3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSkge1xuICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5hbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdHMuaW5jbHVkZU1haW5MYWJlbHMpIHtcbiAgICAgICAgICB1cGRhdGVCb3VuZHNGcm9tQm94KGJiLCBfcC5sYWJlbEJvdW5kcy5tYWluUm90KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pbmNsdWRlU291cmNlTGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMuc291cmNlUm90KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pbmNsdWRlVGFyZ2V0TGFiZWxzKSB7XG4gICAgICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChiYiwgX3AubGFiZWxCb3VuZHMudGFyZ2V0Um90KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICBiYi5oID0gYmIueTIgLSBiYi55MTtcbiAgfVxuICByZXR1cm4gYmI7XG59O1xudmFyIGRlZkJiT3B0cyA9IHtcbiAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICBpbmNsdWRlRWRnZXM6IHRydWUsXG4gIGluY2x1ZGVMYWJlbHM6IHRydWUsXG4gIGluY2x1ZGVNYWluTGFiZWxzOiB0cnVlLFxuICBpbmNsdWRlU291cmNlTGFiZWxzOiB0cnVlLFxuICBpbmNsdWRlVGFyZ2V0TGFiZWxzOiB0cnVlLFxuICBpbmNsdWRlT3ZlcmxheXM6IHRydWUsXG4gIGluY2x1ZGVVbmRlcmxheXM6IHRydWUsXG4gIGluY2x1ZGVPdXRsaW5lczogdHJ1ZSxcbiAgdXNlQ2FjaGU6IHRydWVcbn07XG52YXIgZGVmQmJPcHRzS2V5ID0gZ2V0S2V5KGRlZkJiT3B0cyk7XG52YXIgZmlsbGVkQmJPcHRzID0gZGVmYXVsdHMkZyhkZWZCYk9wdHMpO1xuZWxlc2ZuJGIuYm91bmRpbmdCb3ggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgYm91bmRzO1xuICB2YXIgdXNlQ2FjaGUgPSBvcHRpb25zID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy51c2VDYWNoZSA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMudXNlQ2FjaGUgPT09IHRydWU7XG4gIHZhciBpc0RpcnR5ID0gbWVtb2l6ZShmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHJldHVybiBfcC5iYkNhY2hlID09IG51bGwgfHwgX3Auc3R5bGVEaXJ0eSB8fCBfcC5iYkNhY2hlUG9zS2V5ICE9PSBnZXRCb3VuZGluZ0JveFBvc0tleShlbGUpO1xuICB9LCBmdW5jdGlvbiAoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5pZCgpO1xuICB9KTtcblxuICAvLyB0aGUgbWFpbiB1c2VjYXNlIGlzIGVsZS5ib3VuZGluZ0JveCgpIGZvciBhIHNpbmdsZSBlbGVtZW50IHdpdGggbm8vZGVmIG9wdGlvbnNcbiAgLy8gc3BlY2lmaWVkIHMudC4gdGhlIGNhY2hlIGlzIHVzZWQsIHNvIGNoZWNrIGZvciB0aGlzIGNhc2UgdG8gbWFrZSBpdCBmYXN0ZXIgYnlcbiAgLy8gYXZvaWRpbmcgdGhlIG92ZXJoZWFkIG9mIHRoZSByZXN0IG9mIHRoZSBmdW5jdGlvblxuICBpZiAodXNlQ2FjaGUgJiYgdGhpcy5sZW5ndGggPT09IDEgJiYgIWlzRGlydHkodGhpc1swXSkpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0gZGVmQmJPcHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gZmlsbGVkQmJPcHRzKG9wdGlvbnMpO1xuICAgIH1cbiAgICBib3VuZHMgPSBjYWNoZWRCb3VuZGluZ0JveEltcGwodGhpc1swXSwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRzID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmQmJPcHRzO1xuICAgIHZhciBvcHRzID0gZmlsbGVkQmJPcHRzKG9wdGlvbnMpO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgY3kgPSBlbGVzLmN5KCk7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuXG4gICAgLy8gY2FjaGUgdGhlIGlzRGlydHkgc3RhdGUgZm9yIGFsbCBlbGVzLCBlZGdlcyBmaXJzdCBzaW5jZSB0aGV5IGRlcGVuZCBvbiBub2RlIHN0YXRlXG4gICAgdGhpcy5lZGdlcygpLmZvckVhY2goaXNEaXJ0eSk7XG4gICAgdGhpcy5ub2RlcygpLmZvckVhY2goaXNEaXJ0eSk7XG4gICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUodXNlQ2FjaGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCF1c2VDYWNoZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIGlmIChpc0RpcnR5KGVsZSkpIHtcbiAgICAgICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgfVxuICAgICAgdXBkYXRlQm91bmRzRnJvbUJveChib3VuZHMsIGNhY2hlZEJvdW5kaW5nQm94SW1wbChlbGUsIG9wdHMpKTtcbiAgICB9XG4gIH1cbiAgYm91bmRzLngxID0gbm9uaW5mKGJvdW5kcy54MSk7XG4gIGJvdW5kcy55MSA9IG5vbmluZihib3VuZHMueTEpO1xuICBib3VuZHMueDIgPSBub25pbmYoYm91bmRzLngyKTtcbiAgYm91bmRzLnkyID0gbm9uaW5mKGJvdW5kcy55Mik7XG4gIGJvdW5kcy53ID0gbm9uaW5mKGJvdW5kcy54MiAtIGJvdW5kcy54MSk7XG4gIGJvdW5kcy5oID0gbm9uaW5mKGJvdW5kcy55MiAtIGJvdW5kcy55MSk7XG4gIHJldHVybiBib3VuZHM7XG59O1xuZWxlc2ZuJGIuZGlydHlCb3VuZGluZ0JveENhY2hlID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX3AgPSB0aGlzW2ldLl9wcml2YXRlO1xuICAgIF9wLmJiQ2FjaGUgPSBudWxsO1xuICAgIF9wLmJiQ2FjaGVQb3NLZXkgPSBudWxsO1xuICAgIF9wLmJvZHlCb3VuZHMgPSBudWxsO1xuICAgIF9wLm92ZXJsYXlCb3VuZHMgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLmFsbCA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMuc291cmNlID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy50YXJnZXQgPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLm1haW4gPSBudWxsO1xuICAgIF9wLmxhYmVsQm91bmRzLnNvdXJjZVJvdCA9IG51bGw7XG4gICAgX3AubGFiZWxCb3VuZHMudGFyZ2V0Um90ID0gbnVsbDtcbiAgICBfcC5sYWJlbEJvdW5kcy5tYWluUm90ID0gbnVsbDtcbiAgICBfcC5hcnJvd0JvdW5kcy5zb3VyY2UgPSBudWxsO1xuICAgIF9wLmFycm93Qm91bmRzLnRhcmdldCA9IG51bGw7XG4gICAgX3AuYXJyb3dCb3VuZHNbJ21pZC1zb3VyY2UnXSA9IG51bGw7XG4gICAgX3AuYXJyb3dCb3VuZHNbJ21pZC10YXJnZXQnXSA9IG51bGw7XG4gIH1cbiAgdGhpcy5lbWl0QW5kTm90aWZ5KCdib3VuZHMnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBwcml2YXRlIGhlbHBlciB0byBnZXQgYm91bmRpbmcgYm94IGZvciBjdXN0b20gbm9kZSBwb3NpdGlvbnNcbi8vIC0gZ29vZCBmb3IgcGVyZiBpbiBjZXJ0YWluIGNhc2VzIGJ1dCBjdXJyZW50bHkgcmVxdWlyZXMgZGlydHlpbmcgdGhlIHJlbmRlcmVkIHN0eWxlXG4vLyAtIHdvdWxkIGJlIGJldHRlciB0byBub3QgbW9kaWZ5IHRoZSBub2RlcyBidXQgdGhlIG5vZGVzIGFyZSByZWFkIGRpcmVjdGx5IGV2ZXJ5d2hlcmUgaW4gdGhlIHJlbmRlcmVyLi4uXG4vLyAtIHRyeSB0byB1c2UgZm9yIG9ubHkgdGhpbmdzIGxpa2UgZGlzY3JldGUgbGF5b3V0cyB3aGVyZSB0aGUgbm9kZSBwb3NpdGlvbiB3b3VsZCBjaGFuZ2UgYW55d2F5XG5lbGVzZm4kYi5ib3VuZGluZ0JveEF0ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIHBhcmVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gIGlmIChoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgcGFyZW50cyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuaXNQYXJlbnQoKTtcbiAgICB9KTtcbiAgICBub2RlcyA9IG5vZGVzLm5vdChwYXJlbnRzKTtcbiAgfVxuICBpZiAocGxhaW5PYmplY3QoZm4pKSB7XG4gICAgdmFyIG9iaiA9IGZuO1xuICAgIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH1cbiAgdmFyIHN0b3JlT2xkUG9zID0gZnVuY3Rpb24gc3RvcmVPbGRQb3Mobm9kZSwgaSkge1xuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmJiQXRPbGRQb3MgPSBmbihub2RlLCBpKTtcbiAgfTtcbiAgdmFyIGdldE9sZFBvcyA9IGZ1bmN0aW9uIGdldE9sZFBvcyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuYmJBdE9sZFBvcztcbiAgfTtcbiAgY3kuc3RhcnRCYXRjaCgpO1xuICBub2Rlcy5mb3JFYWNoKHN0b3JlT2xkUG9zKS5zaWxlbnRQb3NpdGlvbnMoZm4pO1xuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIHBhcmVudHMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgcGFyZW50cy5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICBwYXJlbnRzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKHRydWUpOyAvLyBmb3JjZSB1cGRhdGUgYi9jIHdlJ3JlIGluc2lkZSBhIGJhdGNoIGN5Y2xlXG4gIH1cbiAgdmFyIGJiID0gY29weUJvdW5kaW5nQm94KHRoaXMuYm91bmRpbmdCb3goe1xuICAgIHVzZUNhY2hlOiBmYWxzZVxuICB9KSk7XG4gIG5vZGVzLnNpbGVudFBvc2l0aW9ucyhnZXRPbGRQb3MpO1xuICBpZiAoaGFzQ29tcG91bmROb2Rlcykge1xuICAgIHBhcmVudHMuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgcGFyZW50cy5kaXJ0eUJvdW5kaW5nQm94Q2FjaGUoKTtcbiAgICBwYXJlbnRzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKHRydWUpOyAvLyBmb3JjZSB1cGRhdGUgYi9jIHdlJ3JlIGluc2lkZSBhIGJhdGNoIGN5Y2xlXG4gIH1cbiAgY3kuZW5kQmF0Y2goKTtcbiAgcmV0dXJuIGJiO1xufTtcbmZuJDMuYm91bmRpbmdib3ggPSBmbiQzLmJiID0gZm4kMy5ib3VuZGluZ0JveDtcbmZuJDMucmVuZGVyZWRCb3VuZGluZ2JveCA9IGZuJDMucmVuZGVyZWRCb3VuZGluZ0JveDtcbnZhciBib3VuZHMgPSBlbGVzZm4kYjtcblxudmFyIGZuJDIsIGVsZXNmbiRhO1xuZm4kMiA9IGVsZXNmbiRhID0ge307XG52YXIgZGVmaW5lRGltRm5zID0gZnVuY3Rpb24gZGVmaW5lRGltRm5zKG9wdHMpIHtcbiAgb3B0cy51cHBlcmNhc2VOYW1lID0gY2FwaXRhbGl6ZShvcHRzLm5hbWUpO1xuICBvcHRzLmF1dG9OYW1lID0gJ2F1dG8nICsgb3B0cy51cHBlcmNhc2VOYW1lO1xuICBvcHRzLmxhYmVsTmFtZSA9ICdsYWJlbCcgKyBvcHRzLnVwcGVyY2FzZU5hbWU7XG4gIG9wdHMub3V0ZXJOYW1lID0gJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZTtcbiAgb3B0cy51cHBlcmNhc2VPdXRlck5hbWUgPSBjYXBpdGFsaXplKG9wdHMub3V0ZXJOYW1lKTtcbiAgZm4kMltvcHRzLm5hbWVdID0gZnVuY3Rpb24gZGltSW1wbCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIGN5ID0gX3AuY3k7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAoc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIGlmIChlbGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgIGVsZS51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICAgIHJldHVybiBfcFtvcHRzLmF1dG9OYW1lXSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkID0gZWxlLnBzdHlsZShvcHRzLm5hbWUpO1xuICAgICAgICBzd2l0Y2ggKGQuc3RyVmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdsYWJlbCc6XG4gICAgICAgICAgICBlbGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKCk7XG4gICAgICAgICAgICByZXR1cm4gX3AucnN0eWxlW29wdHMubGFiZWxOYW1lXSB8fCAwO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZC5wZlZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZuJDJbJ291dGVyJyArIG9wdHMudXBwZXJjYXNlTmFtZV0gPSBmdW5jdGlvbiBvdXRlckRpbUltcGwoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKHN0eWxlRW5hYmxlZCkge1xuICAgICAgICB2YXIgZGltID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgICAgdmFyIGJvcmRlclBvcyA9IGVsZS5wc3R5bGUoJ2JvcmRlci1wb3NpdGlvbicpLnZhbHVlO1xuICAgICAgICB2YXIgYm9yZGVyO1xuICAgICAgICBpZiAoYm9yZGVyUG9zID09PSAnY2VudGVyJykge1xuICAgICAgICAgIGJvcmRlciA9IGVsZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7IC8vIG4uYi4gMS8yIGVhY2ggc2lkZVxuICAgICAgICB9IGVsc2UgaWYgKGJvcmRlclBvcyA9PT0gJ291dHNpZGUnKSB7XG4gICAgICAgICAgYm9yZGVyID0gMiAqIGVsZS5wc3R5bGUoJ2JvcmRlci13aWR0aCcpLnBmVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gJ2luc2lkZSdcbiAgICAgICAgICBib3JkZXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWRkaW5nID0gMiAqIGVsZS5wYWRkaW5nKCk7XG4gICAgICAgIHJldHVybiBkaW0gKyBib3JkZXIgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBmbiQyWydyZW5kZXJlZCcgKyBvcHRzLnVwcGVyY2FzZU5hbWVdID0gZnVuY3Rpb24gcmVuZGVyZWREaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBkID0gZWxlW29wdHMubmFtZV0oKTtcbiAgICAgIHJldHVybiBkICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICB9XG4gIH07XG4gIGZuJDJbJ3JlbmRlcmVkJyArIG9wdHMudXBwZXJjYXNlT3V0ZXJOYW1lXSA9IGZ1bmN0aW9uIHJlbmRlcmVkT3V0ZXJEaW1JbXBsKCkge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBvZCA9IGVsZVtvcHRzLm91dGVyTmFtZV0oKTtcbiAgICAgIHJldHVybiBvZCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgfVxuICB9O1xufTtcbmRlZmluZURpbUZucyh7XG4gIG5hbWU6ICd3aWR0aCdcbn0pO1xuZGVmaW5lRGltRm5zKHtcbiAgbmFtZTogJ2hlaWdodCdcbn0pO1xuZWxlc2ZuJGEucGFkZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgaWYgKGVsZS5pc1BhcmVudCgpKSB7XG4gICAgZWxlLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgaWYgKF9wLmF1dG9QYWRkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBfcC5hdXRvUGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ3BhZGRpbmcnKS5wZlZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlLnBzdHlsZSgncGFkZGluZycpLnBmVmFsdWU7XG4gIH1cbn07XG5lbGVzZm4kYS5wYWRkZWRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlLmhlaWdodCgpICsgMiAqIGVsZS5wYWRkaW5nKCk7XG59O1xuZWxlc2ZuJGEucGFkZGVkV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICByZXR1cm4gZWxlLndpZHRoKCkgKyAyICogZWxlLnBhZGRpbmcoKTtcbn07XG52YXIgd2lkdGhIZWlnaHQgPSBlbGVzZm4kYTtcblxudmFyIGlmRWRnZSA9IGZ1bmN0aW9uIGlmRWRnZShlbGUsIGdldFZhbHVlKSB7XG4gIGlmIChlbGUuaXNFZGdlKCkgJiYgZWxlLnRha2VzVXBTcGFjZSgpKSB7XG4gICAgcmV0dXJuIGdldFZhbHVlKGVsZSk7XG4gIH1cbn07XG52YXIgaWZFZGdlUmVuZGVyZWRQb3NpdGlvbiA9IGZ1bmN0aW9uIGlmRWRnZVJlbmRlcmVkUG9zaXRpb24oZWxlLCBnZXRQb2ludCkge1xuICBpZiAoZWxlLmlzRWRnZSgpICYmIGVsZS50YWtlc1VwU3BhY2UoKSkge1xuICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgIHJldHVybiBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiQxKGdldFBvaW50KGVsZSksIGN5Lnpvb20oKSwgY3kucGFuKCkpO1xuICB9XG59O1xudmFyIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zID0gZnVuY3Rpb24gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbnMoZWxlLCBnZXRQb2ludHMpIHtcbiAgaWYgKGVsZS5pc0VkZ2UoKSAmJiBlbGUudGFrZXNVcFNwYWNlKCkpIHtcbiAgICB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgcmV0dXJuIGdldFBvaW50cyhlbGUpLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uJDEocCwgem9vbSwgcGFuKTtcbiAgICB9KTtcbiAgfVxufTtcbnZhciBjb250cm9sUG9pbnRzID0gZnVuY3Rpb24gY29udHJvbFBvaW50cyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldENvbnRyb2xQb2ludHMoZWxlKTtcbn07XG52YXIgc2VnbWVudFBvaW50cyA9IGZ1bmN0aW9uIHNlZ21lbnRQb2ludHMoZWxlKSB7XG4gIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRTZWdtZW50UG9pbnRzKGVsZSk7XG59O1xudmFyIHNvdXJjZUVuZHBvaW50ID0gZnVuY3Rpb24gc291cmNlRW5kcG9pbnQoZWxlKSB7XG4gIHJldHVybiBlbGUucmVuZGVyZXIoKS5nZXRTb3VyY2VFbmRwb2ludChlbGUpO1xufTtcbnZhciB0YXJnZXRFbmRwb2ludCA9IGZ1bmN0aW9uIHRhcmdldEVuZHBvaW50KGVsZSkge1xuICByZXR1cm4gZWxlLnJlbmRlcmVyKCkuZ2V0VGFyZ2V0RW5kcG9pbnQoZWxlKTtcbn07XG52YXIgbWlkcG9pbnQgPSBmdW5jdGlvbiBtaWRwb2ludChlbGUpIHtcbiAgcmV0dXJuIGVsZS5yZW5kZXJlcigpLmdldEVkZ2VNaWRwb2ludChlbGUpO1xufTtcbnZhciBwdHMgPSB7XG4gIGNvbnRyb2xQb2ludHM6IHtcbiAgICBnZXQ6IGNvbnRyb2xQb2ludHMsXG4gICAgbXVsdDogdHJ1ZVxuICB9LFxuICBzZWdtZW50UG9pbnRzOiB7XG4gICAgZ2V0OiBzZWdtZW50UG9pbnRzLFxuICAgIG11bHQ6IHRydWVcbiAgfSxcbiAgc291cmNlRW5kcG9pbnQ6IHtcbiAgICBnZXQ6IHNvdXJjZUVuZHBvaW50XG4gIH0sXG4gIHRhcmdldEVuZHBvaW50OiB7XG4gICAgZ2V0OiB0YXJnZXRFbmRwb2ludFxuICB9LFxuICBtaWRwb2ludDoge1xuICAgIGdldDogbWlkcG9pbnRcbiAgfVxufTtcbnZhciByZW5kZXJlZE5hbWUgPSBmdW5jdGlvbiByZW5kZXJlZE5hbWUobmFtZSkge1xuICByZXR1cm4gJ3JlbmRlcmVkJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpO1xufTtcbnZhciBlZGdlUG9pbnRzID0gT2JqZWN0LmtleXMocHRzKS5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgbmFtZSkge1xuICB2YXIgc3BlYyA9IHB0c1tuYW1lXTtcbiAgdmFyIHJOYW1lID0gcmVuZGVyZWROYW1lKG5hbWUpO1xuICBvYmpbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlmRWRnZSh0aGlzLCBzcGVjLmdldCk7XG4gIH07XG4gIGlmIChzcGVjLm11bHQpIHtcbiAgICBvYmpbck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlmRWRnZVJlbmRlcmVkUG9zaXRpb25zKHRoaXMsIHNwZWMuZ2V0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG9ialtyTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaWZFZGdlUmVuZGVyZWRQb3NpdGlvbih0aGlzLCBzcGVjLmdldCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gb2JqO1xufSwge30pO1xuXG52YXIgZGltZW5zaW9ucyA9IGV4dGVuZCh7fSwgcG9zaXRpb24sIGJvdW5kcywgd2lkdGhIZWlnaHQsIGVkZ2VQb2ludHMpO1xuXG4vKiFcbkV2ZW50IG9iamVjdCBiYXNlZCBvbiBqUXVlcnkgZXZlbnRzLCBNSVQgbGljZW5zZVxuXG5odHRwczovL2pxdWVyeS5vcmcvbGljZW5zZS9cbmh0dHBzOi8vdGxkcmxlZ2FsLmNvbS9saWNlbnNlL21pdC1saWNlbnNlXG5odHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcbiovXG5cbnZhciBFdmVudCA9IGZ1bmN0aW9uIEV2ZW50KHNyYywgcHJvcHMpIHtcbiAgdGhpcy5yZWN5Y2xlKHNyYywgcHJvcHMpO1xufTtcbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5FdmVudC5wcm90b3R5cGUgPSB7XG4gIGluc3RhbmNlU3RyaW5nOiBmdW5jdGlvbiBpbnN0YW5jZVN0cmluZygpIHtcbiAgICByZXR1cm4gJ2V2ZW50JztcbiAgfSxcbiAgcmVjeWNsZTogZnVuY3Rpb24gcmVjeWNsZShzcmMsIHByb3BzKSB7XG4gICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVybkZhbHNlO1xuICAgIGlmIChzcmMgIT0gbnVsbCAmJiBzcmMucHJldmVudERlZmF1bHQpIHtcbiAgICAgIC8vIEJyb3dzZXIgRXZlbnQgb2JqZWN0XG4gICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuICAgICAgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcbiAgICB9IGVsc2UgaWYgKHNyYyAhPSBudWxsICYmIHNyYy50eXBlKSB7XG4gICAgICAvLyBQbGFpbiBvYmplY3QgY29udGFpbmluZyBhbGwgZXZlbnQgZGV0YWlsc1xuICAgICAgcHJvcHMgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW50IHN0cmluZ1xuICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH1cblxuICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgaWYgKHByb3BzICE9IG51bGwpIHtcbiAgICAgIC8vIG1vcmUgZWZmaWNpZW50IHRvIG1hbnVhbGx5IGNvcHkgZmllbGRzIHdlIHVzZVxuICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gcHJvcHMub3JpZ2luYWxFdmVudDtcbiAgICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT0gbnVsbCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgICB0aGlzLnRhcmdldCA9IHByb3BzLnRhcmdldDtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBwcm9wcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMucmVuZGVyZWRQb3NpdGlvbiA9IHByb3BzLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZTtcbiAgICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgIH1cbiAgICBpZiAodGhpcy5jeSAhPSBudWxsICYmIHRoaXMucG9zaXRpb24gIT0gbnVsbCAmJiB0aGlzLnJlbmRlcmVkUG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgLy8gY3JlYXRlIGEgcmVuZGVyZWQgcG9zaXRpb24gYmFzZWQgb24gdGhlIHBhc3NlZCBwb3NpdGlvblxuICAgICAgdmFyIHBvcyA9IHRoaXMucG9zaXRpb247XG4gICAgICB2YXIgem9vbSA9IHRoaXMuY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IHRoaXMuY3kucGFuKCk7XG4gICAgICB0aGlzLnJlbmRlcmVkUG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHBvcy54ICogem9vbSArIHBhbi54LFxuICAgICAgICB5OiBwb3MueSAqIHpvb20gKyBwYW4ueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuICAgIHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICBpZiAoIWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcbiAgICBpZiAoIWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICB9LFxuICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICB0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcbiAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuICBpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxufTtcblxudmFyIGV2ZW50UmVnZXggPSAvXihbXi5dKykoXFwuKD86W14uXSspKT8kLzsgLy8gcmVnZXggZm9yIG1hdGNoaW5nIGV2ZW50IHN0cmluZ3MgKGUuZy4gXCJjbGljay5uYW1lc3BhY2VcIilcbnZhciB1bml2ZXJzYWxOYW1lc3BhY2UgPSAnLionOyAvLyBtYXRjaGVzIGFzIGlmIG5vIG5hbWVzcGFjZSBzcGVjaWZpZWQgYW5kIHByZXZlbnRzIHVzZXJzIGZyb20gdW5iaW5kaW5nIGFjY2lkZW50YWxseVxuXG52YXIgZGVmYXVsdHMkOCA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShxMSwgcTIpIHtcbiAgICByZXR1cm4gcTEgPT09IHEyO1xuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcygvKmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiovXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBhZGRFdmVudEZpZWxkczogZnVuY3Rpb24gYWRkRXZlbnRGaWVsZHMoLypjb250ZXh0LCBldnQqL1xuICApIHt9LFxuICBjYWxsYmFja0NvbnRleHQ6IGZ1bmN0aW9uIGNhbGxiYWNrQ29udGV4dChjb250ZXh0IC8qLCBsaXN0ZW5lciwgZXZlbnRPYmoqLykge1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9LFxuICBiZWZvcmVFbWl0OiBmdW5jdGlvbiBiZWZvcmVFbWl0KC8qIGNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaiAqL1xuICApIHt9LFxuICBhZnRlckVtaXQ6IGZ1bmN0aW9uIGFmdGVyRW1pdCgvKiBjb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmogKi9cbiAgKSB7fSxcbiAgYnViYmxlOiBmdW5jdGlvbiBidWJibGUoLypjb250ZXh0Ki9cbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCgvKmNvbnRleHQqL1xuICApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcbiAgY29udGV4dDogbnVsbFxufTtcbnZhciBkZWZhdWx0c0tleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cyQ4KTtcbnZhciBlbXB0eU9wdHMgPSB7fTtcbmZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlbXB0eU9wdHM7XG4gIHZhciBjb250ZXh0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIC8vIG1pY3JvLW9wdGltaXNhdGlvbiB2cyBPYmplY3QuYXNzaWduKCkgLS0gcmVkdWNlcyBFbGVtZW50IGluc3RhbnRpYXRpb24gdGltZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlZmF1bHRzS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBkZWZhdWx0c0tleXNbaV07XG4gICAgdGhpc1trZXldID0gb3B0c1trZXldIHx8IGRlZmF1bHRzJDhba2V5XTtcbiAgfVxuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuY29udGV4dDtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5lbWl0dGluZyA9IDA7XG59XG52YXIgcCA9IEVtaXR0ZXIucHJvdG90eXBlO1xudmFyIGZvckVhY2hFdmVudCA9IGZ1bmN0aW9uIGZvckVhY2hFdmVudChzZWxmLCBoYW5kbGVyLCBldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpIHtcbiAgaWYgKGZuJDYocXVhbGlmaWVyKSkge1xuICAgIGNhbGxiYWNrID0gcXVhbGlmaWVyO1xuICAgIHF1YWxpZmllciA9IG51bGw7XG4gIH1cbiAgaWYgKGNvbmZPdmVycmlkZXMpIHtcbiAgICBpZiAoY29uZiA9PSBudWxsKSB7XG4gICAgICBjb25mID0gY29uZk92ZXJyaWRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uZiA9IGV4dGVuZCh7fSwgY29uZiwgY29uZk92ZXJyaWRlcyk7XG4gICAgfVxuICB9XG4gIHZhciBldmVudExpc3QgPSBhcnJheShldmVudHMpID8gZXZlbnRzIDogZXZlbnRzLnNwbGl0KC9cXHMrLyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGV2dCA9IGV2ZW50TGlzdFtpXTtcbiAgICBpZiAoZW1wdHlTdHJpbmcoZXZ0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaChldmVudFJlZ2V4KTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiBudWxsO1xuICAgICAgdmFyIHJldCA9IGhhbmRsZXIoc2VsZiwgZXZ0LCB0eXBlLCBuYW1lc3BhY2UsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYpO1xuICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIGFsbG93IGV4aXRpbmcgZWFybHlcbiAgICB9XG4gIH1cbn07XG52YXIgbWFrZUV2ZW50T2JqID0gZnVuY3Rpb24gbWFrZUV2ZW50T2JqKHNlbGYsIG9iaikge1xuICBzZWxmLmFkZEV2ZW50RmllbGRzKHNlbGYuY29udGV4dCwgb2JqKTtcbiAgcmV0dXJuIG5ldyBFdmVudChvYmoudHlwZSwgb2JqKTtcbn07XG52YXIgZm9yRWFjaEV2ZW50T2JqID0gZnVuY3Rpb24gZm9yRWFjaEV2ZW50T2JqKHNlbGYsIGhhbmRsZXIsIGV2ZW50cykge1xuICBpZiAoZXZlbnQoZXZlbnRzKSkge1xuICAgIGhhbmRsZXIoc2VsZiwgZXZlbnRzKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3QoZXZlbnRzKSkge1xuICAgIGhhbmRsZXIoc2VsZiwgbWFrZUV2ZW50T2JqKHNlbGYsIGV2ZW50cykpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZXZlbnRMaXN0ID0gYXJyYXkoZXZlbnRzKSA/IGV2ZW50cyA6IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBldnQgPSBldmVudExpc3RbaV07XG4gICAgaWYgKGVtcHR5U3RyaW5nKGV2dCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goZXZlbnRSZWdleCk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogbnVsbDtcbiAgICAgIHZhciBldmVudE9iaiA9IG1ha2VFdmVudE9iaihzZWxmLCB7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICB0YXJnZXQ6IHNlbGYuY29udGV4dFxuICAgICAgfSk7XG4gICAgICBoYW5kbGVyKHNlbGYsIGV2ZW50T2JqKTtcbiAgICB9XG4gIH1cbn07XG5wLm9uID0gcC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudHMsIHF1YWxpZmllciwgY2FsbGJhY2ssIGNvbmYsIGNvbmZPdmVycmlkZXMpIHtcbiAgZm9yRWFjaEV2ZW50KHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gICAgaWYgKGZuJDYoY2FsbGJhY2spKSB7XG4gICAgICBzZWxmLmxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAvLyBmdWxsIGV2ZW50IHN0cmluZ1xuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIC8vIGNhbGxiYWNrIHRvIHJ1blxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAvLyB0aGUgZXZlbnQgdHlwZSAoZS5nLiAnY2xpY2snKVxuICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICAgICAgLy8gdGhlIGV2ZW50IG5hbWVzcGFjZSAoZS5nLiBcIi5mb29cIilcbiAgICAgICAgcXVhbGlmaWVyOiBxdWFsaWZpZXIsXG4gICAgICAgIC8vIGEgcmVzdHJpY3Rpb24gb24gd2hldGhlciB0byBtYXRjaCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgY29uZjogY29uZiAvLyBhZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mLCBjb25mT3ZlcnJpZGVzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xucC5vbmUgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gIHJldHVybiB0aGlzLm9uKGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZiwge1xuICAgIG9uZTogdHJ1ZVxuICB9KTtcbn07XG5wLnJlbW92ZUxpc3RlbmVyID0gcC5vZmYgPSBmdW5jdGlvbiAoZXZlbnRzLCBxdWFsaWZpZXIsIGNhbGxiYWNrLCBjb25mKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIGlmICh0aGlzLmVtaXR0aW5nICE9PSAwKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBjb3B5QXJyYXkodGhpcy5saXN0ZW5lcnMpO1xuICB9XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycztcbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICBmb3JFYWNoRXZlbnQoX3RoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudCwgdHlwZSwgbmFtZXNwYWNlLCBxdWFsaWZpZXIsIGNhbGxiYWNrIC8qLCBjb25mKi8pIHtcbiAgICAgIGlmICgobGlzdGVuZXIudHlwZSA9PT0gdHlwZSB8fCBldmVudHMgPT09ICcqJykgJiYgKCFuYW1lc3BhY2UgJiYgbGlzdGVuZXIubmFtZXNwYWNlICE9PSAnLionIHx8IGxpc3RlbmVyLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSAmJiAoIXF1YWxpZmllciB8fCBzZWxmLnF1YWxpZmllckNvbXBhcmUobGlzdGVuZXIucXVhbGlmaWVyLCBxdWFsaWZpZXIpKSAmJiAoIWNhbGxiYWNrIHx8IGxpc3RlbmVyLmNhbGxiYWNrID09PSBjYWxsYmFjaykpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sIGV2ZW50cywgcXVhbGlmaWVyLCBjYWxsYmFjaywgY29uZik7XG4gIH07XG4gIGZvciAodmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBfbG9vcChpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5wLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlTGlzdGVuZXIoJyonKTtcbn07XG5wLmVtaXQgPSBwLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnRzLCBleHRyYVBhcmFtcywgbWFudWFsQ2FsbGJhY2spIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICB2YXIgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gIHRoaXMuZW1pdHRpbmcrKztcbiAgaWYgKCFhcnJheShleHRyYVBhcmFtcykpIHtcbiAgICBleHRyYVBhcmFtcyA9IFtleHRyYVBhcmFtc107XG4gIH1cbiAgZm9yRWFjaEV2ZW50T2JqKHRoaXMsIGZ1bmN0aW9uIChzZWxmLCBldmVudE9iaikge1xuICAgIGlmIChtYW51YWxDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbe1xuICAgICAgICBldmVudDogZXZlbnRPYmouZXZlbnQsXG4gICAgICAgIHR5cGU6IGV2ZW50T2JqLnR5cGUsXG4gICAgICAgIG5hbWVzcGFjZTogZXZlbnRPYmoubmFtZXNwYWNlLFxuICAgICAgICBjYWxsYmFjazogbWFudWFsQ2FsbGJhY2tcbiAgICAgIH1dO1xuICAgICAgbnVtTGlzdGVuZXJzQmVmb3JlRW1pdCA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBpZiAobGlzdGVuZXIudHlwZSA9PT0gZXZlbnRPYmoudHlwZSAmJiAoIWxpc3RlbmVyLm5hbWVzcGFjZSB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IGV2ZW50T2JqLm5hbWVzcGFjZSB8fCBsaXN0ZW5lci5uYW1lc3BhY2UgPT09IHVuaXZlcnNhbE5hbWVzcGFjZSkgJiYgc2VsZi5ldmVudE1hdGNoZXMoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopKSB7XG4gICAgICAgIHZhciBhcmdzID0gW2V2ZW50T2JqXTtcbiAgICAgICAgaWYgKGV4dHJhUGFyYW1zICE9IG51bGwpIHtcbiAgICAgICAgICBwdXNoKGFyZ3MsIGV4dHJhUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmJlZm9yZUVtaXQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuICAgICAgICBpZiAobGlzdGVuZXIuY29uZiAmJiBsaXN0ZW5lci5jb25mLm9uZSkge1xuICAgICAgICAgIHNlbGYubGlzdGVuZXJzID0gc2VsZi5saXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgICAgICByZXR1cm4gbCAhPT0gbGlzdGVuZXI7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSBzZWxmLmNhbGxiYWNrQ29udGV4dChzZWxmLmNvbnRleHQsIGxpc3RlbmVyLCBldmVudE9iaik7XG4gICAgICAgIHZhciByZXQgPSBsaXN0ZW5lci5jYWxsYmFjay5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgc2VsZi5hZnRlckVtaXQoc2VsZi5jb250ZXh0LCBsaXN0ZW5lciwgZXZlbnRPYmopO1xuICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGV2ZW50T2JqLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGV2ZW50T2JqLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gaWYgbGlzdGVuZXIgbWF0Y2hlc1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1MaXN0ZW5lcnNCZWZvcmVFbWl0OyBpKyspIHtcbiAgICAgIF9sb29wMigpO1xuICAgIH0gLy8gZm9yIGxpc3RlbmVyXG5cbiAgICBpZiAoc2VsZi5idWJibGUoc2VsZi5jb250ZXh0KSAmJiAhZXZlbnRPYmouaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgc2VsZi5wYXJlbnQoc2VsZi5jb250ZXh0KS5lbWl0KGV2ZW50T2JqLCBleHRyYVBhcmFtcyk7XG4gICAgfVxuICB9LCBldmVudHMpO1xuICB0aGlzLmVtaXR0aW5nLS07XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIGVtaXR0ZXJPcHRpb25zJDEgPSB7XG4gIHF1YWxpZmllckNvbXBhcmU6IGZ1bmN0aW9uIHF1YWxpZmllckNvbXBhcmUoc2VsZWN0b3IxLCBzZWxlY3RvcjIpIHtcbiAgICBpZiAoc2VsZWN0b3IxID09IG51bGwgfHwgc2VsZWN0b3IyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZWxlY3RvcjEgPT0gbnVsbCAmJiBzZWxlY3RvcjIgPT0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMS5zYW1lVGV4dChzZWxlY3RvcjIpO1xuICAgIH1cbiAgfSxcbiAgZXZlbnRNYXRjaGVzOiBmdW5jdGlvbiBldmVudE1hdGNoZXMoZWxlLCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBsaXN0ZW5lci5xdWFsaWZpZXI7XG4gICAgaWYgKHNlbGVjdG9yICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGUgIT09IGV2ZW50T2JqLnRhcmdldCAmJiBlbGVtZW50KGV2ZW50T2JqLnRhcmdldCkgJiYgc2VsZWN0b3IubWF0Y2hlcyhldmVudE9iai50YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKGVsZSwgZXZ0KSB7XG4gICAgZXZ0LmN5ID0gZWxlLmN5KCk7XG4gICAgZXZ0LnRhcmdldCA9IGVsZTtcbiAgfSxcbiAgY2FsbGJhY2tDb250ZXh0OiBmdW5jdGlvbiBjYWxsYmFja0NvbnRleHQoZWxlLCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICByZXR1cm4gbGlzdGVuZXIucXVhbGlmaWVyICE9IG51bGwgPyBldmVudE9iai50YXJnZXQgOiBlbGU7XG4gIH0sXG4gIGJlZm9yZUVtaXQ6IGZ1bmN0aW9uIGJlZm9yZUVtaXQoY29udGV4dCwgbGlzdGVuZXIgLyosIGV2ZW50T2JqKi8pIHtcbiAgICBpZiAobGlzdGVuZXIuY29uZiAmJiBsaXN0ZW5lci5jb25mLm9uY2UpIHtcbiAgICAgIGxpc3RlbmVyLmNvbmYub25jZUNvbGxlY3Rpb24ucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIuZXZlbnQsIGxpc3RlbmVyLnF1YWxpZmllciwgbGlzdGVuZXIuY2FsbGJhY2spO1xuICAgIH1cbiAgfSxcbiAgYnViYmxlOiBmdW5jdGlvbiBidWJibGUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIHBhcmVudDogZnVuY3Rpb24gcGFyZW50KGVsZSkge1xuICAgIHJldHVybiBlbGUuaXNDaGlsZCgpID8gZWxlLnBhcmVudCgpIDogZWxlLmN5KCk7XG4gIH1cbn07XG52YXIgYXJnU2VsZWN0b3IkMSA9IGZ1bmN0aW9uIGFyZ1NlbGVjdG9yKGFyZykge1xuICBpZiAoc3RyaW5nKGFyZykpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdG9yKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxufTtcbnZhciBlbGVzZm4kOSA9IHtcbiAgY3JlYXRlRW1pdHRlcjogZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgaWYgKCFfcC5lbWl0dGVyKSB7XG4gICAgICAgIF9wLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0aW9ucyQxLCBlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbWl0dGVyO1xuICB9LFxuICBvbjogZnVuY3Rpb24gb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkub24oZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5yZW1vdmVMaXN0ZW5lcihldmVudHMsIGFyZ1NlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvbmU6IGZ1bmN0aW9uIG9uZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdTZWwgPSBhcmdTZWxlY3RvciQxKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgZWxlLmVtaXR0ZXIoKS5vbmUoZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgYXJnU2VsID0gYXJnU2VsZWN0b3IkMShzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGVsZS5lbWl0dGVyKCkub24oZXZlbnRzLCBhcmdTZWwsIGNhbGxiYWNrLCB7XG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIG9uY2VDb2xsZWN0aW9uOiB0aGlzXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBlbGUuZW1pdHRlcigpLmVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0QW5kTm90aWZ5OiBmdW5jdGlvbiBlbWl0QW5kTm90aWZ5KGV2ZW50LCBleHRyYVBhcmFtcykge1xuICAgIC8vIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZW1wdHkgY29sbGVjdGlvbnMgZG9uJ3QgbmVlZCB0byBub3RpZnkgYW55dGhpbmdcblxuICAgIC8vIG5vdGlmeSByZW5kZXJlclxuICAgIHRoaXMuY3koKS5ub3RpZnkoZXZlbnQsIHRoaXMpO1xuICAgIHRoaXMuZW1pdChldmVudCwgZXh0cmFQYXJhbXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuZGVmaW5lLmV2ZW50QWxpYXNlc09uKGVsZXNmbiQ5KTtcblxudmFyIGVsZXNmbiQ4ID0ge1xuICBub2RlczogZnVuY3Rpb24gbm9kZXMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBlZGdlczogZnVuY3Rpb24gZWRnZXMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5pc0VkZ2UoKTtcbiAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICAvLyBpbnRlcm5hbCBoZWxwZXIgdG8gZ2V0IG5vZGVzIGFuZCBlZGdlcyBhcyBzZXBhcmF0ZSBjb2xsZWN0aW9ucyB3aXRoIHNpbmdsZSBpdGVyYXRpb24gb3ZlciBlbGVtZW50c1xuICBieUdyb3VwOiBmdW5jdGlvbiBieUdyb3VwKCkge1xuICAgIHZhciBub2RlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLnNwYXduKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZXMucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZXM6IG5vZGVzLFxuICAgICAgZWRnZXM6IGVkZ2VzXG4gICAgfTtcbiAgfSxcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoX2ZpbHRlciwgdGhpc0FyZykge1xuICAgIGlmIChfZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGNoZWNrIHRoaXMgZmlyc3QgYi9jIGl0J3MgdGhlIG1vc3QgY29tbW9uL3BlcmZvcm1hbnQgY2FzZVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIGlmIChzdHJpbmcoX2ZpbHRlcikgfHwgZWxlbWVudE9yQ29sbGVjdGlvbihfZmlsdGVyKSkge1xuICAgICAgcmV0dXJuIG5ldyBTZWxlY3RvcihfZmlsdGVyKS5maWx0ZXIodGhpcyk7XG4gICAgfSBlbHNlIGlmIChmbiQ2KF9maWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyRWxlcyA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIGluY2x1ZGUgPSB0aGlzQXJnID8gX2ZpbHRlci5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiBfZmlsdGVyKGVsZSwgaSwgZWxlcyk7XG4gICAgICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICAgICAgZmlsdGVyRWxlcy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWx0ZXJFbGVzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bigpOyAvLyBpZiBub3QgaGFuZGxlZCBieSBhYm92ZSwgZ2l2ZSAnZW0gYW4gZW1wdHkgY29sbGVjdGlvblxuICB9LFxuICBub3Q6IGZ1bmN0aW9uIG5vdCh0b1JlbW92ZSkge1xuICAgIGlmICghdG9SZW1vdmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RyaW5nKHRvUmVtb3ZlKSkge1xuICAgICAgICB0b1JlbW92ZSA9IHRoaXMuZmlsdGVyKHRvUmVtb3ZlKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuc3Bhd24oKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbaV07XG4gICAgICAgIHZhciByZW1vdmUgPSB0b1JlbW92ZS5oYXMoZWxlbWVudCk7XG4gICAgICAgIGlmICghcmVtb3ZlKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH1cbiAgfSxcbiAgYWJzb2x1dGVDb21wbGVtZW50OiBmdW5jdGlvbiBhYnNvbHV0ZUNvbXBsZW1lbnQoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHJldHVybiBjeS5tdXRhYmxlRWxlbWVudHMoKS5ub3QodGhpcyk7XG4gIH0sXG4gIGludGVyc2VjdDogZnVuY3Rpb24gaW50ZXJzZWN0KG90aGVyKSB7XG4gICAgLy8gaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWQsIHRoZW4gZmlsdGVyIGJ5IGl0IGluc3RlYWRcbiAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gb3RoZXI7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgdmFyIGNvbDFTbWFsbGVyID0gdGhpcy5sZW5ndGggPCBvdGhlci5sZW5ndGg7XG4gICAgdmFyIGNvbFMgPSBjb2wxU21hbGxlciA/IGNvbDEgOiBjb2wyO1xuICAgIHZhciBjb2xMID0gY29sMVNtYWxsZXIgPyBjb2wyIDogY29sMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbFMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBjb2xTW2ldO1xuICAgICAgaWYgKGNvbEwuaGFzKGVsZSkpIHtcbiAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sXG4gIHhvcjogZnVuY3Rpb24geG9yKG90aGVyKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICBpZiAoc3RyaW5nKG90aGVyKSkge1xuICAgICAgb3RoZXIgPSBjeS4kKG90aGVyKTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5zcGF3bigpO1xuICAgIHZhciBjb2wxID0gdGhpcztcbiAgICB2YXIgY29sMiA9IG90aGVyO1xuICAgIHZhciBhZGQgPSBmdW5jdGlvbiBhZGQoY29sLCBvdGhlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGNvbFtpXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuaGFzRWxlbWVudFdpdGhJZChpZCk7XG4gICAgICAgIGlmICghaW5PdGhlcikge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgYWRkKGNvbDEsIGNvbDIpO1xuICAgIGFkZChjb2wyLCBjb2wxKTtcbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sXG4gIGRpZmY6IGZ1bmN0aW9uIGRpZmYob3RoZXIpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIGlmIChzdHJpbmcob3RoZXIpKSB7XG4gICAgICBvdGhlciA9IGN5LiQob3RoZXIpO1xuICAgIH1cbiAgICB2YXIgbGVmdCA9IHRoaXMuc3Bhd24oKTtcbiAgICB2YXIgcmlnaHQgPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIGJvdGggPSB0aGlzLnNwYXduKCk7XG4gICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgdmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChjb2wsIG90aGVyLCByZXRFbGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5oYXNFbGVtZW50V2l0aElkKGlkKTtcbiAgICAgICAgaWYgKGluT3RoZXIpIHtcbiAgICAgICAgICBib3RoLm1lcmdlKGVsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0RWxlcy5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGFkZChjb2wxLCBjb2wyLCBsZWZ0KTtcbiAgICBhZGQoY29sMiwgY29sMSwgcmlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgYm90aDogYm90aFxuICAgIH07XG4gIH0sXG4gIGFkZDogZnVuY3Rpb24gYWRkKHRvQWRkKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICBpZiAoIXRvQWRkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWYgKHN0cmluZyh0b0FkZCkpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgdG9BZGQgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnNwYXduU2VsZigpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0b0FkZFtpXTtcbiAgICAgIHZhciBhZGQgPSAhdGhpcy5oYXMoZWxlKTtcbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sXG4gIC8vIGluIHBsYWNlIG1lcmdlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICBtZXJnZTogZnVuY3Rpb24gbWVyZ2UodG9BZGQpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciBjeSA9IF9wLmN5O1xuICAgIGlmICghdG9BZGQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodG9BZGQgJiYgc3RyaW5nKHRvQWRkKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICB0b0FkZCA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIHZhciBtYXAgPSBfcC5tYXA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRvQWRkRWxlID0gdG9BZGRbaV07XG4gICAgICB2YXIgaWQgPSB0b0FkZEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIGFkZCA9ICFtYXAuaGFzKGlkKTtcbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sZW5ndGgrKztcbiAgICAgICAgdGhpc1tpbmRleF0gPSB0b0FkZEVsZTtcbiAgICAgICAgbWFwLnNldChpZCwge1xuICAgICAgICAgIGVsZTogdG9BZGRFbGUsXG4gICAgICAgICAgaW5kZXg6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgdW5tZXJnZUF0OiBmdW5jdGlvbiB1bm1lcmdlQXQoaSkge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIG1hcCA9IF9wLm1hcDtcblxuICAgIC8vIHJlbW92ZSBlbGVcbiAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICAgIG1hcFtcImRlbGV0ZVwiXShpZCk7XG4gICAgdmFyIHVubWVyZ2VkTGFzdEVsZSA9IGkgPT09IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgIC8vIHJlcGxhY2UgZW1wdHkgc3BvdCB3aXRoIGxhc3QgZWxlIGluIGNvbGxlY3Rpb25cbiAgICBpZiAodGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUpIHtcbiAgICAgIHZhciBsYXN0RWxlSSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBsYXN0RWxlID0gdGhpc1tsYXN0RWxlSV07XG4gICAgICB2YXIgbGFzdEVsZUlkID0gbGFzdEVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdGhpc1tsYXN0RWxlSV0gPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzW2ldID0gbGFzdEVsZTtcbiAgICAgIG1hcC5zZXQobGFzdEVsZUlkLCB7XG4gICAgICAgIGVsZTogbGFzdEVsZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHRoZSBjb2xsZWN0aW9uIGlzIG5vdyAxIGVsZSBzbWFsbGVyXG4gICAgdGhpcy5sZW5ndGgtLTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2VPbmU6IGZ1bmN0aW9uIHVubWVyZ2VPbmUoZWxlKSB7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgdmFyIG1hcCA9IF9wLm1hcDtcbiAgICB2YXIgZW50cnkgPSBtYXAuZ2V0KGlkKTtcbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICByZXR1cm4gdGhpczsgLy8gbm8gbmVlZCB0byByZW1vdmVcbiAgICB9XG4gICAgdmFyIGkgPSBlbnRyeS5pbmRleDtcbiAgICB0aGlzLnVubWVyZ2VBdChpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gcmVtb3ZlIGVsZXMgaW4gcGxhY2Ugb24gY2FsbGluZyBjb2xsZWN0aW9uXG4gIHVubWVyZ2U6IGZ1bmN0aW9uIHVubWVyZ2UodG9SZW1vdmUpIHtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIGlmICghdG9SZW1vdmUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpZiAodG9SZW1vdmUgJiYgc3RyaW5nKHRvUmVtb3ZlKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gdG9SZW1vdmU7XG4gICAgICB0b1JlbW92ZSA9IGN5Lm11dGFibGVFbGVtZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMudW5tZXJnZU9uZSh0b1JlbW92ZVtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICB1bm1lcmdlQnk6IGZ1bmN0aW9uIHVubWVyZ2VCeSh0b1JtRm4pIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICBpZiAodG9SbUZuKGVsZSkpIHtcbiAgICAgICAgdGhpcy51bm1lcmdlQXQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtYXA6IGZ1bmN0aW9uIG1hcChtYXBGbiwgdGhpc0FyZykge1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gbWFwRm4uYXBwbHkodGhpc0FyZywgW2VsZSwgaSwgZWxlc10pIDogbWFwRm4oZWxlLCBpLCBlbGVzKTtcbiAgICAgIGFyci5wdXNoKHJldCk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH0sXG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgdmFsID0gaW5pdGlhbFZhbHVlO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbCA9IGZuKHZhbCwgZWxlc1tpXSwgaSwgZWxlcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH0sXG4gIG1heDogZnVuY3Rpb24gbWF4KHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICB2YXIgbWF4RWxlO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSh0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSkgOiB2YWxGbihlbGUsIGksIGVsZXMpO1xuICAgICAgaWYgKHZhbCA+IG1heCkge1xuICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgIG1heEVsZSA9IGVsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBtYXgsXG4gICAgICBlbGU6IG1heEVsZVxuICAgIH07XG4gIH0sXG4gIG1pbjogZnVuY3Rpb24gbWluKHZhbEZuLCB0aGlzQXJnKSB7XG4gICAgdmFyIG1pbiA9IEluZmluaXR5O1xuICAgIHZhciBtaW5FbGU7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgdmFsID0gdGhpc0FyZyA/IHZhbEZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdKSA6IHZhbEZuKGVsZSwgaSwgZWxlcyk7XG4gICAgICBpZiAodmFsIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgbWluRWxlID0gZWxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IG1pbixcbiAgICAgIGVsZTogbWluRWxlXG4gICAgfTtcbiAgfVxufTtcblxuLy8gYWxpYXNlc1xudmFyIGZuJDEgPSBlbGVzZm4kODtcbmZuJDFbJ3UnXSA9IGZuJDFbJ3wnXSA9IGZuJDFbJysnXSA9IGZuJDEudW5pb24gPSBmbiQxLm9yID0gZm4kMS5hZGQ7XG5mbiQxWydcXFxcJ10gPSBmbiQxWychJ10gPSBmbiQxWyctJ10gPSBmbiQxLmRpZmZlcmVuY2UgPSBmbiQxLnJlbGF0aXZlQ29tcGxlbWVudCA9IGZuJDEuc3VidHJhY3QgPSBmbiQxLm5vdDtcbmZuJDFbJ24nXSA9IGZuJDFbJyYnXSA9IGZuJDFbJy4nXSA9IGZuJDEuYW5kID0gZm4kMS5pbnRlcnNlY3Rpb24gPSBmbiQxLmludGVyc2VjdDtcbmZuJDFbJ14nXSA9IGZuJDFbJygrKSddID0gZm4kMVsnKC0pJ10gPSBmbiQxLnN5bW1ldHJpY0RpZmZlcmVuY2UgPSBmbiQxLnN5bWRpZmYgPSBmbiQxLnhvcjtcbmZuJDEuZm5GaWx0ZXIgPSBmbiQxLmZpbHRlckZuID0gZm4kMS5zdGRGaWx0ZXIgPSBmbiQxLmZpbHRlcjtcbmZuJDEuY29tcGxlbWVudCA9IGZuJDEuYWJzY29tcCA9IGZuJDEuYWJzb2x1dGVDb21wbGVtZW50O1xuXG52YXIgZWxlc2ZuJDcgPSB7XG4gIGlzTm9kZTogZnVuY3Rpb24gaXNOb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdub2Rlcyc7XG4gIH0sXG4gIGlzRWRnZTogZnVuY3Rpb24gaXNFZGdlKCkge1xuICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdlZGdlcyc7XG4gIH0sXG4gIGlzTG9vcDogZnVuY3Rpb24gaXNMb29wKCkge1xuICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKClbMF0gPT09IHRoaXMudGFyZ2V0KClbMF07XG4gIH0sXG4gIGlzU2ltcGxlOiBmdW5jdGlvbiBpc1NpbXBsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpWzBdICE9PSB0aGlzLnRhcmdldCgpWzBdO1xuICB9LFxuICBncm91cDogZnVuY3Rpb24gZ3JvdXAoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKGVsZSkge1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncm91cDtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogIEVsZW1lbnRzIGFyZSBkcmF3biBpbiBhIHNwZWNpZmljIG9yZGVyIGJhc2VkIG9uIGNvbXBvdW5kIGRlcHRoIChsb3cgdG8gaGlnaCksIHRoZSBlbGVtZW50IHR5cGUgKG5vZGVzIGFib3ZlIGVkZ2VzKSxcbiAqICBhbmQgei1pbmRleCAobG93IHRvIGhpZ2gpLiAgVGhlc2Ugc3R5bGVzIGFmZmVjdCBob3cgdGhpcyBhcHBsaWVzOlxuICpcbiAqICB6LWNvbXBvdW5kLWRlcHRoOiBNYXkgYmUgYGJvdHRvbSB8IG9ycGhhbiB8IGF1dG8gfCB0b3BgLiAgVGhlIGZpcnN0IGRyYXduIGlzIGBib3R0b21gLCB0aGVuIGBvcnBoYW5gIHdoaWNoIGlzIHRoZVxuICogICAgICBzYW1lIGRlcHRoIGFzIHRoZSByb290IG9mIHRoZSBjb21wb3VuZCBncmFwaCwgZm9sbG93ZWQgYnkgdGhlIGRlZmF1bHQgdmFsdWUgYGF1dG9gIHdoaWNoIGRyYXdzIGluIG9yZGVyIGZyb21cbiAqICAgICAgcm9vdCB0byBsZWF2ZXMgb2YgdGhlIGNvbXBvdW5kIGdyYXBoLiAgVGhlIGxhc3QgZHJhd24gaXMgYHRvcGAuXG4gKiAgei1pbmRleC1jb21wYXJlOiBNYXkgYmUgYGF1dG8gfCBtYW51YWxgLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgYGF1dG9gIHdoaWNoIGFsd2F5cyBkcmF3cyBlZGdlcyB1bmRlciBub2Rlcy5cbiAqICAgICAgYG1hbnVhbGAgaWdub3JlcyB0aGlzIGNvbnZlbnRpb24gYW5kIGRyYXdzIGJhc2VkIG9uIHRoZSBgei1pbmRleGAgdmFsdWUgc2V0dGluZy5cbiAqICB6LWluZGV4OiBBbiBpbnRlZ2VyIHZhbHVlIHRoYXQgYWZmZWN0cyB0aGUgcmVsYXRpdmUgZHJhdyBvcmRlciBvZiBlbGVtZW50cy4gIEluIGdlbmVyYWwsIGFuIGVsZW1lbnQgd2l0aCBhIGhpZ2hlclxuICogICAgICBgei1pbmRleGAgd2lsbCBiZSBkcmF3biBvbiB0b3Agb2YgYW4gZWxlbWVudCB3aXRoIGEgbG93ZXIgYHotaW5kZXhgLlxuICovXG52YXIgekluZGV4U29ydCA9IGZ1bmN0aW9uIHpJbmRleFNvcnQoYSwgYikge1xuICB2YXIgY3kgPSBhLmN5KCk7XG4gIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICBmdW5jdGlvbiBnZXREZXB0aChlbGUpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGUucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJyk7XG4gICAgaWYgKHN0eWxlLnZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnpEZXB0aCgpIDogMDtcbiAgICB9IGVsc2UgaWYgKHN0eWxlLnZhbHVlID09PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUudmFsdWUgPT09ICd0b3AnKSB7XG4gICAgICByZXR1cm4gTUFYX0lOVCQxO1xuICAgIH1cbiAgICAvLyAnb3JwaGFuJ1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBkZXB0aERpZmYgPSBnZXREZXB0aChhKSAtIGdldERlcHRoKGIpO1xuICBpZiAoZGVwdGhEaWZmICE9PSAwKSB7XG4gICAgcmV0dXJuIGRlcHRoRGlmZjtcbiAgfVxuICBmdW5jdGlvbiBnZXRFbGVEZXB0aChlbGUpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGUucHN0eWxlKCd6LWluZGV4LWNvbXBhcmUnKTtcbiAgICBpZiAoc3R5bGUudmFsdWUgPT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSA/IDEgOiAwO1xuICAgIH1cbiAgICAvLyAnbWFudWFsJ1xuICAgIHJldHVybiAwO1xuICB9XG4gIHZhciBlbGVEaWZmID0gZ2V0RWxlRGVwdGgoYSkgLSBnZXRFbGVEZXB0aChiKTtcbiAgaWYgKGVsZURpZmYgIT09IDApIHtcbiAgICByZXR1cm4gZWxlRGlmZjtcbiAgfVxuICB2YXIgekRpZmYgPSBhLnBzdHlsZSgnei1pbmRleCcpLnZhbHVlIC0gYi5wc3R5bGUoJ3otaW5kZXgnKS52YWx1ZTtcbiAgaWYgKHpEaWZmICE9PSAwKSB7XG4gICAgcmV0dXJuIHpEaWZmO1xuICB9XG4gIC8vIGNvbXBhcmUgaW5kaWNlcyBpbiB0aGUgY29yZSAob3JkZXIgYWRkZWQgdG8gZ3JhcGggdy8gbGFzdCBvbiB0b3ApXG4gIHJldHVybiBhLnBvb2xJbmRleCgpIC0gYi5wb29sSW5kZXgoKTtcbn07XG5cbnZhciBlbGVzZm4kNiA9IHtcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmbiwgdGhpc0FyZykge1xuICAgIGlmIChmbiQ2KGZuKSkge1xuICAgICAgdmFyIE4gPSB0aGlzLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gdGhpc0FyZyA/IGZuLmFwcGx5KHRoaXNBcmcsIFtlbGUsIGksIHRoaXNdKSA6IGZuKGVsZSwgaSwgdGhpcyk7XG4gICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2godGhpc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfSxcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgdGhpc1NpemUgPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPT0gbnVsbCkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICBzdGFydCA9IHRoaXNTaXplICsgc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oYXJyYXkpO1xuICB9LFxuICBzaXplOiBmdW5jdGlvbiBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgfSxcbiAgZXE6IGZ1bmN0aW9uIGVxKGkpIHtcbiAgICByZXR1cm4gdGhpc1tpXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG4gIGZpcnN0OiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpc1swXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG4gIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXSB8fCB0aGlzLnNwYXduKCk7XG4gIH0sXG4gIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gIH0sXG4gIG5vbmVtcHR5OiBmdW5jdGlvbiBub25lbXB0eSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZW1wdHkoKTtcbiAgfSxcbiAgc29ydDogZnVuY3Rpb24gc29ydChzb3J0Rm4pIHtcbiAgICBpZiAoIWZuJDYoc29ydEZuKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBzb3J0ZWQgPSB0aGlzLnRvQXJyYXkoKS5zb3J0KHNvcnRGbik7XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oc29ydGVkKTtcbiAgfSxcbiAgc29ydEJ5WkluZGV4OiBmdW5jdGlvbiBzb3J0QnlaSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc29ydCh6SW5kZXhTb3J0KTtcbiAgfSxcbiAgekRlcHRoOiBmdW5jdGlvbiB6RGVwdGgoKSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKCFlbGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gbGV0IGN5ID0gZWxlLmN5KCk7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBncm91cCA9IF9wLmdyb3VwO1xuICAgIGlmIChncm91cCA9PT0gJ25vZGVzJykge1xuICAgICAgdmFyIGRlcHRoID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpLnNpemUoKSA6IDA7XG4gICAgICBpZiAoIWVsZS5pc1BhcmVudCgpKSB7XG4gICAgICAgIHJldHVybiBNQVhfSU5UJDEgLSAxOyAvLyBjaGlsZGxlc3Mgbm9kZXMgYWx3YXlzIG9uIHRvcFxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlcHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgIHZhciBzcmNEZXB0aCA9IHNyYy56RGVwdGgoKTtcbiAgICAgIHZhciB0Z3REZXB0aCA9IHRndC56RGVwdGgoKTtcbiAgICAgIHJldHVybiBNYXRoLm1heChzcmNEZXB0aCwgdGd0RGVwdGgsIDApOyAvLyBkZXB0aCBvZiBkZWVwZXN0IHBhcmVudFxuICAgIH1cbiAgfVxufTtcbmVsZXNmbiQ2LmVhY2ggPSBlbGVzZm4kNi5mb3JFYWNoO1xudmFyIGRlZmluZVN5bWJvbEl0ZXJhdG9yID0gZnVuY3Rpb24gZGVmaW5lU3ltYm9sSXRlcmF0b3IoKSB7XG4gIHZhciB0eXBlb2ZVbmRlZiA9IFwidW5kZWZpbmVkXCIgO1xuICB2YXIgaXNJdGVyYXRvclN1cHBvcnRlZCA9ICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoU3ltYm9sKSkgIT0gdHlwZW9mVW5kZWYgJiYgX3R5cGVvZihTeW1ib2wuaXRlcmF0b3IpICE9IHR5cGVvZlVuZGVmO1xuICBpZiAoaXNJdGVyYXRvclN1cHBvcnRlZCkge1xuICAgIGVsZXNmbiQ2W1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkkMSh7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgaWYgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGVudHJ5LnZhbHVlID0gX3RoaXNbaSsrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50cnkudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBlbnRyeS5kb25lID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICB9XG4gICAgICB9LCBTeW1ib2wuaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG59O1xuZGVmaW5lU3ltYm9sSXRlcmF0b3IoKTtcblxudmFyIGdldExheW91dERpbWVuc2lvbk9wdGlvbnMgPSBkZWZhdWx0cyRnKHtcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZVxufSk7XG52YXIgZWxlc2ZuJDUgPSB7XG4gIC8vIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgbm9kZSBkaW1lbnNpb25zIHsgeCwgeSB9IGJhc2VkIG9uIG9wdGlvbnMgZ2l2ZW5cbiAgbGF5b3V0RGltZW5zaW9uczogZnVuY3Rpb24gbGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGdldExheW91dERpbWVuc2lvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgdmFyIGRpbXM7XG4gICAgaWYgKCF0aGlzLnRha2VzVXBTcGFjZSgpKSB7XG4gICAgICBkaW1zID0ge1xuICAgICAgICB3OiAwLFxuICAgICAgICBoOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgIHZhciBiYkRpbSA9IHRoaXMuYm91bmRpbmdCb3goKTtcbiAgICAgIGRpbXMgPSB7XG4gICAgICAgIHc6IGJiRGltLncsXG4gICAgICAgIGg6IGJiRGltLmhcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpbXMgPSB7XG4gICAgICAgIHc6IHRoaXMub3V0ZXJXaWR0aCgpLFxuICAgICAgICBoOiB0aGlzLm91dGVySGVpZ2h0KClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gc2FuaXRpc2UgdGhlIGRpbWVuc2lvbnMgZm9yIGV4dGVybmFsIGxheW91dHMgKGF2b2lkIGRpdmlzaW9uIGJ5IHplcm8pXG4gICAgaWYgKGRpbXMudyA9PT0gMCB8fCBkaW1zLmggPT09IDApIHtcbiAgICAgIGRpbXMudyA9IGRpbXMuaCA9IDE7XG4gICAgfVxuICAgIHJldHVybiBkaW1zO1xuICB9LFxuICAvLyB1c2luZyBzdGFuZGFyZCBsYXlvdXQgb3B0aW9ucywgYXBwbHkgcG9zaXRpb24gZnVuY3Rpb24gKHcvIG9yIHcvbyBhbmltYXRpb24pXG4gIGxheW91dFBvc2l0aW9uczogZnVuY3Rpb24gbGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZm4pIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gIW4uaXNQYXJlbnQoKTtcbiAgICB9KTtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGxheW91dEVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIG5vZGVzICYgZWRnZXNcbiAgICB2YXIgZ2V0TWVtb2l6ZUtleSA9IGZ1bmN0aW9uIGdldE1lbW9pemVLZXkobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuaWQoKTtcbiAgICB9O1xuICAgIHZhciBmbk1lbSA9IG1lbW9pemUoZm4sIGdldE1lbW9pemVLZXkpOyAvLyBtZW1vaXplZCB2ZXJzaW9uIG9mIHBvc2l0aW9uIGZ1bmN0aW9uXG5cbiAgICBsYXlvdXQuZW1pdCh7XG4gICAgICB0eXBlOiAnbGF5b3V0c3RhcnQnLFxuICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICB9KTtcbiAgICBsYXlvdXQuYW5pbWF0aW9ucyA9IFtdO1xuICAgIHZhciBjYWxjdWxhdGVTcGFjaW5nID0gZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBub2Rlc0JiLCBwb3MpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IG5vZGVzQmIueDEgKyBub2Rlc0JiLncgLyAyLFxuICAgICAgICB5OiBub2Rlc0JiLnkxICsgbm9kZXNCYi5oIC8gMlxuICAgICAgfTtcbiAgICAgIHZhciBzcGFjaW5nVmVjdG9yID0ge1xuICAgICAgICAvLyBzY2FsZSBmcm9tIGNlbnRlciBvZiBib3VuZGluZyBib3ggKG5vdCBuZWNlc3NhcmlseSAwLDApXG4gICAgICAgIHg6IChwb3MueCAtIGNlbnRlci54KSAqIHNwYWNpbmcsXG4gICAgICAgIHk6IChwb3MueSAtIGNlbnRlci55KSAqIHNwYWNpbmdcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHNwYWNpbmdWZWN0b3IueCxcbiAgICAgICAgeTogY2VudGVyLnkgKyBzcGFjaW5nVmVjdG9yLnlcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgdXNlU3BhY2luZ0ZhY3RvciA9IG9wdGlvbnMuc3BhY2luZ0ZhY3RvciAmJiBvcHRpb25zLnNwYWNpbmdGYWN0b3IgIT09IDE7XG4gICAgdmFyIHNwYWNpbmdCYiA9IGZ1bmN0aW9uIHNwYWNpbmdCYigpIHtcbiAgICAgIGlmICghdXNlU3BhY2luZ0ZhY3Rvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcG9zID0gZm5NZW0obm9kZSwgaSk7XG4gICAgICAgIGV4cGFuZEJvdW5kaW5nQm94QnlQb2ludChiYiwgcG9zLngsIHBvcy55KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYjtcbiAgICB9O1xuICAgIHZhciBiYiA9IHNwYWNpbmdCYigpO1xuICAgIHZhciBnZXRGaW5hbFBvcyA9IG1lbW9pemUoZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgIHZhciBuZXdQb3MgPSBmbk1lbShub2RlLCBpKTtcbiAgICAgIGlmICh1c2VTcGFjaW5nRmFjdG9yKSB7XG4gICAgICAgIHZhciBzcGFjaW5nID0gTWF0aC5hYnMob3B0aW9ucy5zcGFjaW5nRmFjdG9yKTtcbiAgICAgICAgbmV3UG9zID0gY2FsY3VsYXRlU3BhY2luZyhzcGFjaW5nLCBiYiwgbmV3UG9zKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyYW5zZm9ybSAhPSBudWxsKSB7XG4gICAgICAgIG5ld1BvcyA9IG9wdGlvbnMudHJhbnNmb3JtKG5vZGUsIG5ld1Bvcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UG9zO1xuICAgIH0sIGdldE1lbW9pemVLZXkpO1xuICAgIGlmIChvcHRpb25zLmFuaW1hdGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIG5ld1BvcyA9IGdldEZpbmFsUG9zKG5vZGUsIGkpO1xuICAgICAgICB2YXIgYW5pbWF0ZU5vZGUgPSBvcHRpb25zLmFuaW1hdGVGaWx0ZXIgPT0gbnVsbCB8fCBvcHRpb25zLmFuaW1hdGVGaWx0ZXIobm9kZSwgaSk7XG4gICAgICAgIGlmIChhbmltYXRlTm9kZSkge1xuICAgICAgICAgIHZhciBhbmkgPSBub2RlLmFuaW1hdGlvbih7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3UG9zLFxuICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmc6IG9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaChhbmkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUucG9zaXRpb24obmV3UG9zKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZml0KSB7XG4gICAgICAgIHZhciBmaXRBbmkgPSBjeS5hbmltYXRpb24oe1xuICAgICAgICAgIGZpdDoge1xuICAgICAgICAgICAgYm91bmRpbmdCb3g6IGxheW91dEVsZXMuYm91bmRpbmdCb3hBdChnZXRGaW5hbFBvcyksXG4gICAgICAgICAgICBwYWRkaW5nOiBvcHRpb25zLnBhZGRpbmdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogb3B0aW9ucy5hbmltYXRpb25FYXNpbmdcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dC5hbmltYXRpb25zLnB1c2goZml0QW5pKTtcbiAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy56b29tICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5wYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgem9vbVBhbkFuaSA9IGN5LmFuaW1hdGlvbih7XG4gICAgICAgICAgem9vbTogb3B0aW9ucy56b29tLFxuICAgICAgICAgIHBhbjogb3B0aW9ucy5wYW4sXG4gICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBvcHRpb25zLmFuaW1hdGlvbkVhc2luZ1xuICAgICAgICB9KTtcbiAgICAgICAgbGF5b3V0LmFuaW1hdGlvbnMucHVzaCh6b29tUGFuQW5pKTtcbiAgICAgIH1cbiAgICAgIGxheW91dC5hbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGFuaSkge1xuICAgICAgICByZXR1cm4gYW5pLnBsYXkoKTtcbiAgICAgIH0pO1xuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHJlYWR5JyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgICAgUHJvbWlzZSQxLmFsbChsYXlvdXQuYW5pbWF0aW9ucy5tYXAoZnVuY3Rpb24gKGFuaSkge1xuICAgICAgICByZXR1cm4gYW5pLnByb21pc2UoKTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZXMucG9zaXRpb25zKGdldEZpbmFsUG9zKTtcbiAgICAgIGlmIChvcHRpb25zLmZpdCkge1xuICAgICAgICBjeS5maXQob3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuem9vbSAhPSBudWxsKSB7XG4gICAgICAgIGN5Lnpvb20ob3B0aW9ucy56b29tKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnBhbikge1xuICAgICAgICBjeS5wYW4ob3B0aW9ucy5wYW4pO1xuICAgICAgfVxuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIGxheW91dC5lbWl0KHtcbiAgICAgICAgdHlwZTogJ2xheW91dHJlYWR5JyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICBsYXlvdXQuZW1pdCh7XG4gICAgICAgIHR5cGU6ICdsYXlvdXRzdG9wJyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgbGF5b3V0OiBmdW5jdGlvbiBsYXlvdXQob3B0aW9ucykge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICByZXR1cm4gY3kubWFrZUxheW91dChleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIGVsZXM6IHRoaXNcbiAgICB9KSk7XG4gIH1cbn07XG5cbi8vIGFsaWFzZXM6XG5lbGVzZm4kNS5jcmVhdGVMYXlvdXQgPSBlbGVzZm4kNS5tYWtlTGF5b3V0ID0gZWxlc2ZuJDUubGF5b3V0O1xuXG5mdW5jdGlvbiBzdHlsZUNhY2hlKGtleSwgZm4sIGVsZSkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBjYWNoZSA9IF9wLnN0eWxlQ2FjaGUgPSBfcC5zdHlsZUNhY2hlIHx8IFtdO1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGNhY2hlW2tleV0pICE9IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IGNhY2hlW2tleV0gPSBmbihlbGUpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNhY2hlU3R5bGVGdW5jdGlvbihrZXksIGZuKSB7XG4gIGtleSA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZFN0eWxlRnVuY3Rpb24oZWxlKSB7XG4gICAgcmV0dXJuIHN0eWxlQ2FjaGUoa2V5LCBmbiwgZWxlKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhY2hlUHJvdG90eXBlU3R5bGVGdW5jdGlvbihrZXksIGZuKSB7XG4gIGtleSA9IGhhc2hTdHJpbmcoa2V5KTtcbiAgdmFyIHNlbGZGbiA9IGZ1bmN0aW9uIHNlbGZGbihlbGUpIHtcbiAgICByZXR1cm4gZm4uY2FsbChlbGUpO1xuICB9O1xuICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkUHJvdG90eXBlU3R5bGVGdW5jdGlvbigpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gc3R5bGVDYWNoZShrZXksIHNlbGZGbiwgZWxlKTtcbiAgICB9XG4gIH07XG59XG52YXIgZWxlc2ZuJDQgPSB7XG4gIHJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZTogZnVuY3Rpb24gcmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKHVzZUNhY2hlKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciByZW5kZXJlciA9IGN5LnJlbmRlcmVyKCk7XG4gICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5LnN0eWxlRW5hYmxlZCgpO1xuICAgIGlmIChyZW5kZXJlciAmJiBzdHlsZUVuYWJsZWQpIHtcbiAgICAgIHJlbmRlcmVyLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSh0aGlzLCB1c2VDYWNoZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXJ0eVN0eWxlQ2FjaGU6IGZ1bmN0aW9uIGRpcnR5U3R5bGVDYWNoZSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgdmFyIGRpcnR5ID0gZnVuY3Rpb24gZGlydHkoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnN0eWxlQ2FjaGUgPSBudWxsO1xuICAgIH07XG4gICAgaWYgKGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgdmFyIGVsZXM7XG4gICAgICBlbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSh0aGlzLmRlc2NlbmRhbnRzKCkpLm1lcmdlKHRoaXMucGFyZW50cygpKTtcbiAgICAgIGVsZXMubWVyZ2UoZWxlcy5jb25uZWN0ZWRFZGdlcygpKTtcbiAgICAgIGVsZXMuZm9yRWFjaChkaXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIGRpcnR5KGVsZSk7XG4gICAgICAgIGVsZS5jb25uZWN0ZWRFZGdlcygpLmZvckVhY2goZGlydHkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBmdWxseSB1cGRhdGVzIChyZWNhbGN1bGF0ZXMpIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnRzXG4gIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiB1cGRhdGVTdHlsZShub3RpZnlSZW5kZXJlcikge1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmIChjeS5iYXRjaGluZygpKSB7XG4gICAgICB2YXIgYkVsZXMgPSBjeS5fcHJpdmF0ZS5iYXRjaFN0eWxlRWxlcztcbiAgICAgIGJFbGVzLm1lcmdlKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nIGFuZCBleGl0IGVhcmx5IHdoZW4gYmF0Y2hpbmdcbiAgICB9XG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgdXBkYXRlZEVsZXMgPSB0aGlzO1xuICAgIG5vdGlmeVJlbmRlcmVyID0gbm90aWZ5UmVuZGVyZXIgfHwgbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcbiAgICBpZiAoaGFzQ29tcG91bmRzKSB7XG4gICAgICAvLyB0aGVuIGFkZCBldmVyeXRoaW5nIHVwIGFuZCBkb3duIGZvciBjb21wb3VuZCBzZWxlY3RvciBjaGVja3NcbiAgICAgIHVwZGF0ZWRFbGVzID0gdGhpcy5zcGF3blNlbGYoKS5tZXJnZSh0aGlzLmRlc2NlbmRhbnRzKCkpLm1lcmdlKHRoaXMucGFyZW50cygpKTtcbiAgICB9XG5cbiAgICAvLyBsZXQgY2hhbmdlZEVsZXMgPSBzdHlsZS5hcHBseSggdXBkYXRlZEVsZXMgKTtcbiAgICB2YXIgY2hhbmdlZEVsZXMgPSB1cGRhdGVkRWxlcztcbiAgICBpZiAobm90aWZ5UmVuZGVyZXIpIHtcbiAgICAgIGNoYW5nZWRFbGVzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlZEVsZXMuZW1pdCgnc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgIH1cbiAgICB1cGRhdGVkRWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIC8vIHByaXZhdGU6IGNsZWFycyBkaXJ0eSBmbGFnIGFuZCByZWNhbGN1bGF0ZXMgc3R5bGVcbiAgY2xlYW5TdHlsZTogZnVuY3Rpb24gY2xlYW5TdHlsZSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgaWYgKGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5KSB7XG4gICAgICAgIC8vIG4uYi4gdGhpcyBmbGFnIHNob3VsZCBiZSBzZXQgYmVmb3JlIGFwcGx5KCkgdG8gYXZvaWQgcG90ZW50aWFsIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICBlbGUuX3ByaXZhdGUuc3R5bGVEaXJ0eSA9IGZhbHNlO1xuICAgICAgICBjeS5zdHlsZSgpLmFwcGx5KGVsZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvLyBnZXQgdGhlIGludGVybmFsIHBhcnNlZCBzdHlsZSBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAgcGFyc2VkU3R5bGU6IGZ1bmN0aW9uIHBhcnNlZFN0eWxlKHByb3BlcnR5KSB7XG4gICAgdmFyIGluY2x1ZGVOb25EZWZhdWx0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBjeSA9IGVsZS5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVsZSkge1xuICAgICAgLy8gdGhpcy5jbGVhblN0eWxlKCk7XG5cbiAgICAgIC8vIElubGluZSB0aGUgaW1wb3J0YW50IHBhcnQgb2YgY2xlYW5TdHlsZSgpLCBmb3IgcmF3IHBlcmZvcm1hbmNlXG4gICAgICBpZiAoZWxlLl9wcml2YXRlLnN0eWxlRGlydHkpIHtcbiAgICAgICAgLy8gbi5iLiB0aGlzIGZsYWcgc2hvdWxkIGJlIHNldCBiZWZvcmUgYXBwbHkoKSB0byBhdm9pZCBwb3RlbnRpYWwgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZURpcnR5ID0gZmFsc2U7XG4gICAgICAgIGN5LnN0eWxlKCkuYXBwbHkoZWxlKTtcbiAgICAgIH1cbiAgICAgIHZhciBvdmVycmlkZGVuU3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGVbcHJvcGVydHldO1xuICAgICAgaWYgKG92ZXJyaWRkZW5TdHlsZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvdmVycmlkZGVuU3R5bGU7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVOb25EZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBjeS5zdHlsZSgpLmdldERlZmF1bHRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG51bWVyaWNTdHlsZTogZnVuY3Rpb24gbnVtZXJpY1N0eWxlKHByb3BlcnR5KSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKCFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlKSB7XG4gICAgICB2YXIgcHN0eWxlID0gZWxlLnBzdHlsZShwcm9wZXJ0eSk7XG4gICAgICByZXR1cm4gcHN0eWxlLnBmVmFsdWUgIT09IHVuZGVmaW5lZCA/IHBzdHlsZS5wZlZhbHVlIDogcHN0eWxlLnZhbHVlO1xuICAgIH1cbiAgfSxcbiAgbnVtZXJpY1N0eWxlVW5pdHM6IGZ1bmN0aW9uIG51bWVyaWNTdHlsZVVuaXRzKHByb3BlcnR5KSB7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYgKCFlbGUuY3koKS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLnBzdHlsZShwcm9wZXJ0eSkudW5pdHM7XG4gICAgfVxuICB9LFxuICAvLyBnZXQgdGhlIHNwZWNpZmllZCBjc3MgcHJvcGVydHkgYXMgYSByZW5kZXJlZCB2YWx1ZSAoaS5lLiBvbi1zY3JlZW4gdmFsdWUpXG4gIC8vIG9yIGdldCB0aGUgd2hvbGUgcmVuZGVyZWQgc3R5bGUgaWYgbm8gcHJvcGVydHkgc3BlY2lmaWVkIChOQiBkb2Vzbid0IGFsbG93IHNldHRpbmcpXG4gIHJlbmRlcmVkU3R5bGU6IGZ1bmN0aW9uIHJlbmRlcmVkU3R5bGUocHJvcGVydHkpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHJldHVybiBjeS5zdHlsZSgpLmdldFJlbmRlcmVkU3R5bGUoZWxlLCBwcm9wZXJ0eSk7XG4gICAgfVxuICB9LFxuICAvLyByZWFkIHRoZSBjYWxjdWxhdGVkIGNzcyBzdHlsZSBvZiB0aGUgZWxlbWVudCBvciBvdmVycmlkZSB0aGUgc3R5bGUgKHZpYSBhIGJ5cGFzcylcbiAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIGlmIChwbGFpbk9iamVjdChuYW1lKSkge1xuICAgICAgLy8gdGhlbiBleHRlbmQgdGhlIGJ5cGFzc1xuICAgICAgdmFyIHByb3BzID0gbmFtZTtcbiAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKHRoaXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG4gICAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgfSBlbHNlIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRoZW4gZ2V0IHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBzdHlsZVxuICAgICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgIHJldHVybiBzdHlsZS5nZXRTdHlsZVByb3BlcnR5VmFsdWUoZWxlLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3ModGhpcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgX2VsZSA9IHRoaXNbMF07XG4gICAgICBpZiAoX2VsZSkge1xuICAgICAgICByZXR1cm4gc3R5bGUuZ2V0UmF3U3R5bGUoX2VsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgcmVtb3ZlU3R5bGU6IGZ1bmN0aW9uIHJlbW92ZVN0eWxlKG5hbWVzKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICBpZiAobmFtZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBzdHlsZS5yZW1vdmVBbGxCeXBhc3NlcyhlbGUsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfZWxlMiA9IGVsZXNbX2ldO1xuICAgICAgICBzdHlsZS5yZW1vdmVCeXBhc3NlcyhfZWxlMiwgbmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbWl0QW5kTm90aWZ5KCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgZWZmZWN0aXZlT3BhY2l0eTogZnVuY3Rpb24gZWZmZWN0aXZlT3BhY2l0eSgpIHtcbiAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuICAgICAgaWYgKCFoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgICAgfVxuICAgICAgdmFyIHBhcmVudHMgPSAhX3AuZGF0YS5wYXJlbnQgPyBudWxsIDogZWxlLnBhcmVudHMoKTtcbiAgICAgIGlmIChwYXJlbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50LnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuICAgICAgICAgIHBhcmVudE9wYWNpdHkgPSBvcGFjaXR5ICogcGFyZW50T3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgfVxuICB9LFxuICB0cmFuc3BhcmVudDogZnVuY3Rpb24gdHJhbnNwYXJlbnQoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgaWYgKGVsZSkge1xuICAgICAgaWYgKCFoYXNDb21wb3VuZE5vZGVzKSB7XG4gICAgICAgIHJldHVybiBlbGUucHN0eWxlKCdvcGFjaXR5JykudmFsdWUgPT09IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSA9PT0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJhY2tncm91bmRpbmc6IGZ1bmN0aW9uIGJhY2tncm91bmRpbmcoKSB7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIGlmICghY3kuc3R5bGVFbmFibGVkKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5iYWNrZ3JvdW5kaW5nID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG59O1xuZnVuY3Rpb24gY2hlY2tDb21wb3VuZChlbGUsIHBhcmVudE9rKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHBhcmVudHMgPSBfcC5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkgOiBudWxsO1xuICBpZiAocGFyZW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG4gICAgICBpZiAoIXBhcmVudE9rKHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRlZmluZURlcml2ZWRTdGF0ZUZ1bmN0aW9uKHNwZWNzKSB7XG4gIHZhciBvayA9IHNwZWNzLm9rO1xuICB2YXIgZWRnZU9rVmlhTm9kZSA9IHNwZWNzLmVkZ2VPa1ZpYU5vZGUgfHwgc3BlY3Mub2s7XG4gIHZhciBwYXJlbnRPayA9IHNwZWNzLnBhcmVudE9rIHx8IHNwZWNzLm9rO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgaWYgKGVsZSkge1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgaWYgKCFvayhlbGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgcmV0dXJuICFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQoZWxlLCBwYXJlbnRPayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgICByZXR1cm4gZWRnZU9rVmlhTm9kZShzcmMpICYmICghaGFzQ29tcG91bmROb2RlcyB8fCBjaGVja0NvbXBvdW5kKHNyYywgZWRnZU9rVmlhTm9kZSkpICYmIChzcmMgPT09IHRndCB8fCBlZGdlT2tWaWFOb2RlKHRndCkgJiYgKCFoYXNDb21wb3VuZE5vZGVzIHx8IGNoZWNrQ29tcG91bmQodGd0LCBlZGdlT2tWaWFOb2RlKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbnZhciBlbGVUYWtlc1VwU3BhY2UgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZVRha2VzVXBTcGFjZScsIGZ1bmN0aW9uIChlbGUpIHtcbiAgcmV0dXJuIGVsZS5wc3R5bGUoJ2Rpc3BsYXknKS52YWx1ZSA9PT0gJ2VsZW1lbnQnICYmIGVsZS53aWR0aCgpICE9PSAwICYmIChlbGUuaXNOb2RlKCkgPyBlbGUuaGVpZ2h0KCkgIT09IDAgOiB0cnVlKTtcbn0pO1xuZWxlc2ZuJDQudGFrZXNVcFNwYWNlID0gY2FjaGVQcm90b3R5cGVTdHlsZUZ1bmN0aW9uKCd0YWtlc1VwU3BhY2UnLCBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gIG9rOiBlbGVUYWtlc1VwU3BhY2Vcbn0pKTtcbnZhciBlbGVJbnRlcmFjdGl2ZSA9IGNhY2hlU3R5bGVGdW5jdGlvbignZWxlSW50ZXJhY3RpdmUnLCBmdW5jdGlvbiAoZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCdldmVudHMnKS52YWx1ZSA9PT0gJ3llcycgJiYgZWxlLnBzdHlsZSgndmlzaWJpbGl0eScpLnZhbHVlID09PSAndmlzaWJsZScgJiYgZWxlVGFrZXNVcFNwYWNlKGVsZSk7XG59KTtcbnZhciBwYXJlbnRJbnRlcmFjdGl2ZSA9IGNhY2hlU3R5bGVGdW5jdGlvbigncGFyZW50SW50ZXJhY3RpdmUnLCBmdW5jdGlvbiAocGFyZW50KSB7XG4gIHJldHVybiBwYXJlbnQucHN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT09ICd2aXNpYmxlJyAmJiBlbGVUYWtlc1VwU3BhY2UocGFyZW50KTtcbn0pO1xuZWxlc2ZuJDQuaW50ZXJhY3RpdmUgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ2ludGVyYWN0aXZlJywgZGVmaW5lRGVyaXZlZFN0YXRlRnVuY3Rpb24oe1xuICBvazogZWxlSW50ZXJhY3RpdmUsXG4gIHBhcmVudE9rOiBwYXJlbnRJbnRlcmFjdGl2ZSxcbiAgZWRnZU9rVmlhTm9kZTogZWxlVGFrZXNVcFNwYWNlXG59KSk7XG5lbGVzZm4kNC5ub25pbnRlcmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIGlmIChlbGUpIHtcbiAgICByZXR1cm4gIWVsZS5pbnRlcmFjdGl2ZSgpO1xuICB9XG59O1xudmFyIGVsZVZpc2libGUgPSBjYWNoZVN0eWxlRnVuY3Rpb24oJ2VsZVZpc2libGUnLCBmdW5jdGlvbiAoZWxlKSB7XG4gIHJldHVybiBlbGUucHN0eWxlKCd2aXNpYmlsaXR5JykudmFsdWUgPT09ICd2aXNpYmxlJyAmJiBlbGUucHN0eWxlKCdvcGFjaXR5JykucGZWYWx1ZSAhPT0gMCAmJiBlbGVUYWtlc1VwU3BhY2UoZWxlKTtcbn0pO1xudmFyIGVkZ2VWaXNpYmxlVmlhTm9kZSA9IGVsZVRha2VzVXBTcGFjZTtcbmVsZXNmbiQ0LnZpc2libGUgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ3Zpc2libGUnLCBkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbih7XG4gIG9rOiBlbGVWaXNpYmxlLFxuICBlZGdlT2tWaWFOb2RlOiBlZGdlVmlzaWJsZVZpYU5vZGVcbn0pKTtcbmVsZXNmbiQ0LmhpZGRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIGlmIChlbGUpIHtcbiAgICByZXR1cm4gIWVsZS52aXNpYmxlKCk7XG4gIH1cbn07XG5lbGVzZm4kNC5pc0J1bmRsZWRCZXppZXIgPSBjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24oJ2lzQnVuZGxlZEJlemllcicsIGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmN5KCkuc3R5bGVFbmFibGVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICF0aGlzLnJlbW92ZWQoKSAmJiB0aGlzLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZSA9PT0gJ2JlemllcicgJiYgdGhpcy50YWtlc1VwU3BhY2UoKTtcbn0pO1xuZWxlc2ZuJDQuYnlwYXNzID0gZWxlc2ZuJDQuY3NzID0gZWxlc2ZuJDQuc3R5bGU7XG5lbGVzZm4kNC5yZW5kZXJlZENzcyA9IGVsZXNmbiQ0LnJlbmRlcmVkU3R5bGU7XG5lbGVzZm4kNC5yZW1vdmVCeXBhc3MgPSBlbGVzZm4kNC5yZW1vdmVDc3MgPSBlbGVzZm4kNC5yZW1vdmVTdHlsZTtcbmVsZXNmbiQ0LnBzdHlsZSA9IGVsZXNmbiQ0LnBhcnNlZFN0eWxlO1xuXG52YXIgZWxlc2ZuJDMgPSB7fTtcbmZ1bmN0aW9uIGRlZmluZVN3aXRjaEZ1bmN0aW9uKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBjaGFuZ2VkRWxlcyA9IFtdO1xuXG4gICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggZGF0YSwgaGFuZGxlciApXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgZGF0YSA9IGFyZ3NbMF07XG4gICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICB0aGlzLm9uKHBhcmFtcy5ldmVudCwgZGF0YSwgaGFuZGxlcik7XG4gICAgfVxuXG4gICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggaGFuZGxlciApXG4gICAgZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgZm4kNihhcmdzWzBdKSkge1xuICAgICAgdmFyIF9oYW5kbGVyID0gYXJnc1swXTtcbiAgICAgIHRoaXMub24ocGFyYW1zLmV2ZW50LCBfaGFuZGxlcik7XG4gICAgfVxuXG4gICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCgpXG4gICAgLy8gZS5nLiAocHJpdmF0ZSkgY3kubm9kZXMoKS5zZWxlY3QoWyd0YXBzZWxlY3QnXSlcbiAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMCB8fCBhcmdzLmxlbmd0aCA9PT0gMSAmJiBhcnJheShhcmdzWzBdKSkge1xuICAgICAgdmFyIGFkZGxFdmVudHMgPSBhcmdzLmxlbmd0aCA9PT0gMSA/IGFyZ3NbMF0gOiBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgYWJsZSA9ICFwYXJhbXMuYWJsZUZpZWxkIHx8IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYWJsZUZpZWxkXTtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSAhPSBwYXJhbXMudmFsdWU7XG4gICAgICAgIGlmIChwYXJhbXMub3ZlcnJpZGVBYmxlKSB7XG4gICAgICAgICAgdmFyIG92ZXJyaWRlQWJsZSA9IHBhcmFtcy5vdmVycmlkZUFibGUoZWxlKTtcbiAgICAgICAgICBpZiAob3ZlcnJpZGVBYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFibGUgPSBvdmVycmlkZUFibGU7XG4gICAgICAgICAgICBpZiAoIW92ZXJyaWRlQWJsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gLy8gdG8gc2F2ZSBjeWNsZXMgYXNzdW1lIG5vdCBhYmxlIGZvciBhbGwgb24gb3ZlcnJpZGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFibGUpIHtcbiAgICAgICAgICBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSA9IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgY2hhbmdlZEVsZXMucHVzaChlbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoYW5nZWRDb2xsID0gdGhpcy5zcGF3bihjaGFuZ2VkRWxlcyk7XG4gICAgICBjaGFuZ2VkQ29sbC51cGRhdGVTdHlsZSgpOyAvLyBjaGFuZ2Ugb2Ygc3RhdGUgPT4gcG9zc2libGUgY2hhbmdlIG9mIHN0eWxlXG4gICAgICBjaGFuZ2VkQ29sbC5lbWl0KHBhcmFtcy5ldmVudCk7XG4gICAgICBpZiAoYWRkbEV2ZW50cykge1xuICAgICAgICBjaGFuZ2VkQ29sbC5lbWl0KGFkZGxFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmluZVN3aXRjaFNldChwYXJhbXMpIHtcbiAgZWxlc2ZuJDNbcGFyYW1zLmZpZWxkXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiAoZWxlKSB7XG4gICAgICBpZiAocGFyYW1zLm92ZXJyaWRlRmllbGQpIHtcbiAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKGVsZSk7XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXTtcbiAgICB9XG4gIH07XG4gIGVsZXNmbiQzW3BhcmFtcy5vbl0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGVsZXNmbiQzW3BhcmFtcy5vZmZdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgIGV2ZW50OiBwYXJhbXMub2ZmLFxuICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICB2YWx1ZTogZmFsc2VcbiAgfSk7XG59XG5kZWZpbmVTd2l0Y2hTZXQoe1xuICBmaWVsZDogJ2xvY2tlZCcsXG4gIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uIG92ZXJyaWRlRmllbGQoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5jeSgpLmF1dG9sb2NrKCkgPyB0cnVlIDogdW5kZWZpbmVkO1xuICB9LFxuICBvbjogJ2xvY2snLFxuICBvZmY6ICd1bmxvY2snXG59KTtcbmRlZmluZVN3aXRjaFNldCh7XG4gIGZpZWxkOiAnZ3JhYmJhYmxlJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3VuZ3JhYmlmeSgpIHx8IGVsZS5wYW5uYWJsZSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIH0sXG4gIG9uOiAnZ3JhYmlmeScsXG4gIG9mZjogJ3VuZ3JhYmlmeSdcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdzZWxlY3RlZCcsXG4gIGFibGVGaWVsZDogJ3NlbGVjdGFibGUnLFxuICBvdmVycmlkZUFibGU6IGZ1bmN0aW9uIG92ZXJyaWRlQWJsZShlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdzZWxlY3QnLFxuICBvZmY6ICd1bnNlbGVjdCdcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24gb3ZlcnJpZGVGaWVsZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgfSxcbiAgb246ICdzZWxlY3RpZnknLFxuICBvZmY6ICd1bnNlbGVjdGlmeSdcbn0pO1xuZWxlc2ZuJDMuZGVzZWxlY3QgPSBlbGVzZm4kMy51bnNlbGVjdDtcbmVsZXNmbiQzLmdyYWJiZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlbGUgPSB0aGlzWzBdO1xuICBpZiAoZWxlKSB7XG4gICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncmFiYmVkO1xuICB9XG59O1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdhY3RpdmUnLFxuICBvbjogJ2FjdGl2YXRlJyxcbiAgb2ZmOiAndW5hY3RpdmF0ZSdcbn0pO1xuZGVmaW5lU3dpdGNoU2V0KHtcbiAgZmllbGQ6ICdwYW5uYWJsZScsXG4gIG9uOiAncGFuaWZ5JyxcbiAgb2ZmOiAndW5wYW5pZnknXG59KTtcbmVsZXNmbiQzLmluYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgaWYgKGVsZSkge1xuICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgfVxufTtcblxudmFyIGVsZXNmbiQyID0ge307XG5cbi8vIERBRyBmdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy9cblxudmFyIGRlZmluZURhZ0V4dHJlbWl0eSA9IGZ1bmN0aW9uIGRlZmluZURhZ0V4dHJlbWl0eShwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGRhZ0V4dHJlbWl0eUltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICBpZiAoIWVsZS5pc05vZGUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXNxdWFsaWZpZWQgPSBmYWxzZTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZS5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdO1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCk7XG4gICAgICAgIGlmIChwYXJhbXMubm9JbmNvbWluZ0VkZ2VzICYmIHRndCA9PT0gZWxlICYmIHNyYyAhPT0gZWxlIHx8IHBhcmFtcy5ub091dGdvaW5nRWRnZXMgJiYgc3JjID09PSBlbGUgJiYgdGd0ICE9PSBlbGUpIHtcbiAgICAgICAgICBkaXNxdWFsaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRpc3F1YWxpZmllZCkge1xuICAgICAgICByZXQucHVzaChlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihyZXQsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59O1xudmFyIGRlZmluZURhZ09uZUhvcCA9IGZ1bmN0aW9uIGRlZmluZURhZ09uZUhvcChwYXJhbXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciBlbGVzID0gdGhpcztcbiAgICB2YXIgb0VsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgaWYgKCFlbGUuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZWRnZXMgPSBlbGUuY29ubmVjdGVkRWRnZXMoKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICBpZiAocGFyYW1zLm91dGdvaW5nICYmIHNyYyA9PT0gZWxlKSB7XG4gICAgICAgICAgb0VsZXMucHVzaChlZGdlKTtcbiAgICAgICAgICBvRWxlcy5wdXNoKHRndCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmluY29taW5nICYmIHRndCA9PT0gZWxlKSB7XG4gICAgICAgICAgb0VsZXMucHVzaChlZGdlKTtcbiAgICAgICAgICBvRWxlcy5wdXNoKHNyYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24ob0VsZXMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59O1xudmFyIGRlZmluZURhZ0FsbEhvcHMgPSBmdW5jdGlvbiBkZWZpbmVEYWdBbGxIb3BzKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIHZhciBzRWxlcyA9IFtdO1xuICAgIHZhciBzRWxlc0lkcyA9IHt9O1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBuZXh0ID0gcGFyYW1zLm91dGdvaW5nID8gZWxlcy5vdXRnb2VycygpIDogZWxlcy5pbmNvbWVycygpO1xuICAgICAgaWYgKG5leHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBkb25lIGlmIG5vbmUgbGVmdFxuXG4gICAgICB2YXIgbmV3TmV4dCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gbmV4dFtpXTtcbiAgICAgICAgdmFyIG5pZCA9IG4uaWQoKTtcbiAgICAgICAgaWYgKCFzRWxlc0lkc1tuaWRdKSB7XG4gICAgICAgICAgc0VsZXNJZHNbbmlkXSA9IHRydWU7XG4gICAgICAgICAgc0VsZXMucHVzaChuKTtcbiAgICAgICAgICBuZXdOZXh0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFuZXdOZXh0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBkb25lIGlmIHRvdWNoZWQgYWxsIG91dGdvZXJzIGFscmVhZHlcblxuICAgICAgZWxlcyA9IG5leHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNwYXduKHNFbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufTtcbmVsZXNmbiQyLmNsZWFyVHJhdmVyc2FsQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXNbaV0uX3ByaXZhdGUudHJhdmVyc2FsQ2FjaGUgPSBudWxsO1xuICB9XG59O1xuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIC8vIGdldCB0aGUgcm9vdCBub2RlcyBpbiB0aGUgREFHXG4gIHJvb3RzOiBkZWZpbmVEYWdFeHRyZW1pdHkoe1xuICAgIG5vSW5jb21pbmdFZGdlczogdHJ1ZVxuICB9KSxcbiAgLy8gZ2V0IHRoZSBsZWFmIG5vZGVzIGluIHRoZSBEQUdcbiAgbGVhdmVzOiBkZWZpbmVEYWdFeHRyZW1pdHkoe1xuICAgIG5vT3V0Z29pbmdFZGdlczogdHJ1ZVxuICB9KSxcbiAgLy8gbm9ybWFsbHkgY2FsbGVkIGNoaWxkcmVuIGluIGdyYXBoIHRoZW9yeVxuICAvLyB0aGVzZSBub2RlcyA9ZWRnZXM9PiBvdXRnb2luZyBub2Rlc1xuICBvdXRnb2VyczogY2FjaGUoZGVmaW5lRGFnT25lSG9wKHtcbiAgICBvdXRnb2luZzogdHJ1ZVxuICB9KSwgJ291dGdvZXJzJyksXG4gIC8vIGFrYSBEQUcgZGVzY2VuZGFudHNcbiAgc3VjY2Vzc29yczogZGVmaW5lRGFnQWxsSG9wcyh7XG4gICAgb3V0Z29pbmc6IHRydWVcbiAgfSksXG4gIC8vIG5vcm1hbGx5IGNhbGxlZCBwYXJlbnRzIGluIGdyYXBoIHRoZW9yeVxuICAvLyB0aGVzZSBub2RlcyA8PWVkZ2VzPSBpbmNvbWluZyBub2Rlc1xuICBpbmNvbWVyczogY2FjaGUoZGVmaW5lRGFnT25lSG9wKHtcbiAgICBpbmNvbWluZzogdHJ1ZVxuICB9KSwgJ2luY29tZXJzJyksXG4gIC8vIGFrYSBEQUcgYW5jZXN0b3JzXG4gIHByZWRlY2Vzc29yczogZGVmaW5lRGFnQWxsSG9wcyh7XG4gICAgfSlcbn0pO1xuXG4vLyBOZWlnaGJvdXJob29kIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIG5laWdoYm9yaG9vZDogY2FjaGUoZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIGZvciBhbGwgbm9kZXNcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIC8vIGZvciBlYWNoIGNvbm5lY3RlZCBlZGdlLCBhZGQgdGhlIGVkZ2UgYW5kIHRoZSBvdGhlciBub2RlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgIHZhciBzcmMgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IG5vZGUgPT09IHNyYyA/IHRndCA6IHNyYztcblxuICAgICAgICAvLyBuZWVkIGNoZWNrIGluIGNhc2Ugb2YgbG9vcFxuICAgICAgICBpZiAob3RoZXJOb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKG90aGVyTm9kZVswXSk7IC8vIGFkZCBub2RlIDEgaG9wIGF3YXlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBjb25uZWN0ZWQgZWRnZVxuICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2VbMF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgfSwgJ25laWdoYm9yaG9vZCcpLFxuICBjbG9zZWROZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uIGNsb3NlZE5laWdoYm9yaG9vZChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmFkZCh0aGlzKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LFxuICBvcGVuTmVpZ2hib3Job29kOiBmdW5jdGlvbiBvcGVuTmVpZ2hib3Job29kKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKHNlbGVjdG9yKTtcbiAgfVxufSk7XG5cbi8vIGFsaWFzZXNcbmVsZXNmbiQyLm5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5uZWlnaGJvcmhvb2Q7XG5lbGVzZm4kMi5jbG9zZWROZWlnaGJvdXJob29kID0gZWxlc2ZuJDIuY2xvc2VkTmVpZ2hib3Job29kO1xuZWxlc2ZuJDIub3Blbk5laWdoYm91cmhvb2QgPSBlbGVzZm4kMi5vcGVuTmVpZ2hib3Job29kO1xuXG4vLyBFZGdlIGZ1bmN0aW9uc1xuLy8vLy8vLy8vLy8vLy8vLy9cblxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIHNvdXJjZTogY2FjaGUoZnVuY3Rpb24gc291cmNlSW1wbChzZWxlY3Rvcikge1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHZhciBzcmM7XG4gICAgaWYgKGVsZSkge1xuICAgICAgc3JjID0gZWxlLl9wcml2YXRlLnNvdXJjZSB8fCBlbGUuY3koKS5jb2xsZWN0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBzcmMgJiYgc2VsZWN0b3IgPyBzcmMuZmlsdGVyKHNlbGVjdG9yKSA6IHNyYztcbiAgfSwgJ3NvdXJjZScpLFxuICB0YXJnZXQ6IGNhY2hlKGZ1bmN0aW9uIHRhcmdldEltcGwoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICB2YXIgdGd0O1xuICAgIGlmIChlbGUpIHtcbiAgICAgIHRndCA9IGVsZS5fcHJpdmF0ZS50YXJnZXQgfHwgZWxlLmN5KCkuY29sbGVjdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGd0ICYmIHNlbGVjdG9yID8gdGd0LmZpbHRlcihzZWxlY3RvcikgOiB0Z3Q7XG4gIH0sICd0YXJnZXQnKSxcbiAgc291cmNlczogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgIGF0dHI6ICdzb3VyY2UnXG4gIH0pLFxuICB0YXJnZXRzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgYXR0cjogJ3RhcmdldCdcbiAgfSlcbn0pO1xuZnVuY3Rpb24gZGVmaW5lU291cmNlRnVuY3Rpb24ocGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbiBzb3VyY2VJbXBsKHNlbGVjdG9yKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYXR0cl07XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIHNvdXJjZXMucHVzaChzcmMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihzb3VyY2VzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9O1xufVxuZXh0ZW5kKGVsZXNmbiQyLCB7XG4gIGVkZ2VzV2l0aDogY2FjaGUoZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSwgJ2VkZ2VzV2l0aCcpLFxuICBlZGdlc1RvOiBjYWNoZShkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbih7XG4gICAgdGhpc0lzU3JjOiB0cnVlXG4gIH0pLCAnZWRnZXNUbycpXG59KTtcbmZ1bmN0aW9uIGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24gZWRnZXNXaXRoSW1wbChvdGhlck5vZGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgcCA9IHBhcmFtcyB8fCB7fTtcblxuICAgIC8vIGdldCBlbGVtZW50cyBpZiBhIHNlbGVjdG9yIGlzIHNwZWNpZmllZFxuICAgIGlmIChzdHJpbmcob3RoZXJOb2RlcykpIHtcbiAgICAgIG90aGVyTm9kZXMgPSBjeS4kKG90aGVyTm9kZXMpO1xuICAgIH1cbiAgICBmb3IgKHZhciBoID0gMDsgaCA8IG90aGVyTm9kZXMubGVuZ3RoOyBoKyspIHtcbiAgICAgIHZhciBlZGdlcyA9IG90aGVyTm9kZXNbaF0uX3ByaXZhdGUuZWRnZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBlZGdlRGF0YSA9IGVkZ2UuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRoaXNUb090aGVyID0gdGhpcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnNvdXJjZSkgJiYgb3RoZXJOb2Rlcy5oYXNFbGVtZW50V2l0aElkKGVkZ2VEYXRhLnRhcmdldCk7XG4gICAgICAgIHZhciBvdGhlclRvVGhpcyA9IG90aGVyTm9kZXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS5zb3VyY2UpICYmIHRoaXMuaGFzRWxlbWVudFdpdGhJZChlZGdlRGF0YS50YXJnZXQpO1xuICAgICAgICB2YXIgZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyID0gdGhpc1RvT3RoZXIgfHwgb3RoZXJUb1RoaXM7XG4gICAgICAgIGlmICghZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAudGhpc0lzU3JjIHx8IHAudGhpc0lzVGd0KSB7XG4gICAgICAgICAgaWYgKHAudGhpc0lzU3JjICYmICF0aGlzVG9PdGhlcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwLnRoaXNJc1RndCAmJiAhb3RoZXJUb1RoaXMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50cy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihlbGVtZW50cywgdHJ1ZSk7XG4gIH07XG59XG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgY29ubmVjdGVkRWRnZXM6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciByZXRFbGVzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBlbGVzW2ldO1xuICAgICAgaWYgKCFub2RlLmlzTm9kZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihyZXRFbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LCAnY29ubmVjdGVkRWRnZXMnKSxcbiAgY29ubmVjdGVkTm9kZXM6IGNhY2hlKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgIHZhciByZXRFbGVzID0gW107XG4gICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlbGVzW2ldO1xuICAgICAgaWYgKCFlZGdlLmlzRWRnZSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0RWxlcy5wdXNoKGVkZ2Uuc291cmNlKClbMF0pO1xuICAgICAgcmV0RWxlcy5wdXNoKGVkZ2UudGFyZ2V0KClbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zcGF3bihyZXRFbGVzLCB0cnVlKS5maWx0ZXIoc2VsZWN0b3IpO1xuICB9LCAnY29ubmVjdGVkTm9kZXMnKSxcbiAgcGFyYWxsZWxFZGdlczogY2FjaGUoZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCksICdwYXJhbGxlbEVkZ2VzJyksXG4gIGNvZGlyZWN0ZWRFZGdlczogY2FjaGUoZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHtcbiAgICBjb2RpcmVjdGVkOiB0cnVlXG4gIH0pLCAnY29kaXJlY3RlZEVkZ2VzJylcbn0pO1xuZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgY29kaXJlY3RlZDogZmFsc2VcbiAgfTtcbiAgcGFyYW1zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBhcmFsbGVsRWRnZXNJbXBsKHNlbGVjdG9yKSB7XG4gICAgLy8gbWljcm8tb3B0aW1pc2VkIGZvciByZW5kZXJlclxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgIC8vIGxvb2sgYXQgYWxsIHRoZSBlZGdlcyBpbiB0aGUgY29sbGVjdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlMSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIGVkZ2UxX3AgPSBlZGdlMS5fcHJpdmF0ZTtcbiAgICAgIHZhciBzcmMxID0gZWRnZTFfcC5zb3VyY2U7XG4gICAgICB2YXIgc3JjaWQxID0gc3JjMS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgdmFyIHRndGlkMSA9IGVkZ2UxX3AuZGF0YS50YXJnZXQ7XG4gICAgICB2YXIgc3JjRWRnZXMxID0gc3JjMS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgLy8gbG9vayBhdCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIHNyYyBub2RlIG9mIHRoaXMgZWRnZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzcmNFZGdlczEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxW2pdO1xuICAgICAgICB2YXIgZWRnZTJkYXRhID0gZWRnZTIuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgdmFyIHRndGlkMiA9IGVkZ2UyZGF0YS50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgY29kaXJlY3RlZCA9IHRndGlkMiA9PT0gdGd0aWQxICYmIHNyY2lkMiA9PT0gc3JjaWQxO1xuICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcbiAgICAgICAgaWYgKHAuY29kaXJlY3RlZCAmJiBjb2RpcmVjdGVkIHx8ICFwLmNvZGlyZWN0ZWQgJiYgKGNvZGlyZWN0ZWQgfHwgb3BwZGlyZWN0ZWQpKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlZGdlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3Bhd24oZWxlbWVudHMsIHRydWUpLmZpbHRlcihzZWxlY3Rvcik7XG4gIH07XG59XG5cbi8vIE1pc2MgZnVuY3Rpb25zXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHRlbmQoZWxlc2ZuJDIsIHtcbiAgY29tcG9uZW50czogZnVuY3Rpb24gY29tcG9uZW50cyhyb290KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgICB2YXIgdmlzaXRlZCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICB2YXIgdW52aXNpdGVkID0gcm9vdCA9PSBudWxsID8gc2VsZi5ub2RlcygpIDogcm9vdC5ub2RlcygpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgaWYgKHJvb3QgIT0gbnVsbCAmJiB1bnZpc2l0ZWQuZW1wdHkoKSkge1xuICAgICAgLy8gcm9vdCBtYXkgY29udGFpbiBvbmx5IGVkZ2VzXG4gICAgICB1bnZpc2l0ZWQgPSByb290LnNvdXJjZXMoKTsgLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggbm9kZSB0byB1c2UgKHVuZGlyZWN0ZWQpLCBzbyBqdXN0IHVzZSB0aGUgc291cmNlIHNpZGVzXG4gICAgfVxuICAgIHZhciB2aXNpdEluQ29tcG9uZW50ID0gZnVuY3Rpb24gdmlzaXRJbkNvbXBvbmVudChub2RlLCBjb21wb25lbnQpIHtcbiAgICAgIHZpc2l0ZWQubWVyZ2Uobm9kZSk7XG4gICAgICB1bnZpc2l0ZWQudW5tZXJnZShub2RlKTtcbiAgICAgIGNvbXBvbmVudC5tZXJnZShub2RlKTtcbiAgICB9O1xuICAgIGlmICh1bnZpc2l0ZWQuZW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHNlbGYuc3Bhd24oKTtcbiAgICB9XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAvLyBlYWNoIGl0ZXJhdGlvbiB5aWVsZHMgYSBjb21wb25lbnRcbiAgICAgIHZhciBjbXB0ID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKGNtcHQpO1xuICAgICAgdmFyIHJvb3QgPSB1bnZpc2l0ZWRbMF07XG4gICAgICB2aXNpdEluQ29tcG9uZW50KHJvb3QsIGNtcHQpO1xuICAgICAgc2VsZi5iZnMoe1xuICAgICAgICBkaXJlY3RlZDogZmFsc2UsXG4gICAgICAgIHJvb3RzOiByb290LFxuICAgICAgICB2aXNpdDogZnVuY3Rpb24gdmlzaXQodikge1xuICAgICAgICAgIHJldHVybiB2aXNpdEluQ29tcG9uZW50KHYsIGNtcHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNtcHQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLmNvbm5lY3RlZEVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIC8vIGNvbm5lY3RlZEVkZ2VzKCkgdXN1YWxseSBjYWNoZWRcbiAgICAgICAgICBpZiAoc2VsZi5oYXMoZSkgJiYgY21wdC5oYXMoZS5zb3VyY2UoKSkgJiYgY21wdC5oYXMoZS50YXJnZXQoKSkpIHtcbiAgICAgICAgICAgIC8vIGhhcygpIGlzIGNoZWFwXG4gICAgICAgICAgICBjbXB0Lm1lcmdlKGUpOyAvLyBmb3JFYWNoKCkgb25seSBjb25zaWRlcnMgbm9kZXMgLS0gc2V0cyBOIGF0IGNhbGwgdGltZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGRvIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfSB3aGlsZSAodW52aXNpdGVkLmxlbmd0aCA+IDApO1xuICAgIHJldHVybiBjb21wb25lbnRzO1xuICB9LFxuICBjb21wb25lbnQ6IGZ1bmN0aW9uIGNvbXBvbmVudCgpIHtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlLmN5KCkubXV0YWJsZUVsZW1lbnRzKCkuY29tcG9uZW50cyhlbGUpWzBdO1xuICB9XG59KTtcbmVsZXNmbiQyLmNvbXBvbmVudHNPZiA9IGVsZXNmbiQyLmNvbXBvbmVudHM7XG5cbi8vIHJlcHJlc2VudHMgYSBzZXQgb2Ygbm9kZXMsIGVkZ2VzLCBvciBib3RoIHRvZ2V0aGVyXG52YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIENvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKSB7XG4gIHZhciB1bmlxdWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICB2YXIgcmVtb3ZlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIGlmIChjeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXJyb3IoJ0EgY29sbGVjdGlvbiBtdXN0IGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGNvcmUnKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hcCA9IG5ldyBNYXAkMSgpO1xuICB2YXIgY3JlYXRlZEVsZW1lbnRzID0gZmFsc2U7XG4gIGlmICghZWxlbWVudHMpIHtcbiAgICBlbGVtZW50cyA9IFtdO1xuICB9IGVsc2UgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgcGxhaW5PYmplY3QoZWxlbWVudHNbMF0pICYmICFlbGVtZW50KGVsZW1lbnRzWzBdKSkge1xuICAgIGNyZWF0ZWRFbGVtZW50cyA9IHRydWU7XG5cbiAgICAvLyBtYWtlIGVsZW1lbnRzIGZyb20ganNvbiBhbmQgcmVzdG9yZSBhbGwgYXQgb25jZSBsYXRlclxuICAgIHZhciBlbGVzID0gW107XG4gICAgdmFyIGVsZXNJZHMgPSBuZXcgU2V0JDEoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChqc29uLmRhdGEgPT0gbnVsbCkge1xuICAgICAgICBqc29uLmRhdGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBfZGF0YSA9IGpzb24uZGF0YTtcblxuICAgICAgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcbiAgICAgIGlmIChfZGF0YS5pZCA9PSBudWxsKSB7XG4gICAgICAgIF9kYXRhLmlkID0gdXVpZCgpO1xuICAgICAgfSBlbHNlIGlmIChjeS5oYXNFbGVtZW50V2l0aElkKF9kYXRhLmlkKSB8fCBlbGVzSWRzLmhhcyhfZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7IC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIHByaW9yIGlkIGFscmVhZHkgZXhpc3RzXG4gICAgICB9XG4gICAgICB2YXIgZWxlID0gbmV3IEVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTtcbiAgICAgIGVsZXMucHVzaChlbGUpO1xuICAgICAgZWxlc0lkcy5hZGQoX2RhdGEuaWQpO1xuICAgIH1cbiAgICBlbGVtZW50cyA9IGVsZXM7XG4gIH1cbiAgdGhpcy5sZW5ndGggPSAwO1xuICBmb3IgKHZhciBfaSA9IDAsIF9sID0gZWxlbWVudHMubGVuZ3RoOyBfaSA8IF9sOyBfaSsrKSB7XG4gICAgdmFyIGVsZW1lbnQkMSA9IGVsZW1lbnRzW19pXVswXTsgLy8gWzBdIGluIGNhc2UgZWxlbWVudHMgaXMgYW4gYXJyYXkgb2YgY29sbGVjdGlvbnMsIHJhdGhlciB0aGFuIGFycmF5IG9mIGVsZW1lbnRzXG4gICAgaWYgKGVsZW1lbnQkMSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlkID0gZWxlbWVudCQxLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgaWYgKCF1bmlxdWUgfHwgIW1hcC5oYXMoaWQpKSB7XG4gICAgICBpZiAodW5pcXVlKSB7XG4gICAgICAgIG1hcC5zZXQoaWQsIHtcbiAgICAgICAgICBpbmRleDogdGhpcy5sZW5ndGgsXG4gICAgICAgICAgZWxlOiBlbGVtZW50JDFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzW3RoaXMubGVuZ3RoXSA9IGVsZW1lbnQkMTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgfVxuICB9XG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgZWxlczogdGhpcyxcbiAgICBjeTogY3ksXG4gICAgZ2V0IG1hcCgpIHtcbiAgICAgIGlmICh0aGlzLmxhenlNYXAgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlYnVpbGRNYXAoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxhenlNYXA7XG4gICAgfSxcbiAgICBzZXQgbWFwKG0pIHtcbiAgICAgIHRoaXMubGF6eU1hcCA9IG07XG4gICAgfSxcbiAgICByZWJ1aWxkTWFwOiBmdW5jdGlvbiByZWJ1aWxkTWFwKCkge1xuICAgICAgdmFyIG0gPSB0aGlzLmxhenlNYXAgPSBuZXcgTWFwJDEoKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcy5lbGVzO1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBfZWxlID0gZWxlc1tfaTJdO1xuICAgICAgICBtLnNldChfZWxlLmlkKCksIHtcbiAgICAgICAgICBpbmRleDogX2kyLFxuICAgICAgICAgIGVsZTogX2VsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGlmICh1bmlxdWUpIHtcbiAgICB0aGlzLl9wcml2YXRlLm1hcCA9IG1hcDtcbiAgfVxuXG4gIC8vIHJlc3RvcmUgdGhlIGVsZW1lbnRzIGlmIHdlIGNyZWF0ZWQgdGhlbSBmcm9tIGpzb25cbiAgaWYgKGNyZWF0ZWRFbGVtZW50cyAmJiAhcmVtb3ZlZCkge1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG59O1xuXG4vLyBGdW5jdGlvbnNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8ga2VlcCB0aGUgcHJvdG90eXBlcyBpbiBzeW5jIChhbiBlbGVtZW50IGhhcyB0aGUgc2FtZSBmdW5jdGlvbnMgYXMgYSBjb2xsZWN0aW9uKVxuLy8gYW5kIHVzZSBlbGVmbiBhbmQgZWxlc2ZuIGFzIHNob3J0aGFuZHMgdG8gdGhlIHByb3RvdHlwZXNcbnZhciBlbGVzZm4kMSA9IEVsZW1lbnQucHJvdG90eXBlID0gQ29sbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEFycmF5LnByb3RvdHlwZSk7XG5lbGVzZm4kMS5pbnN0YW5jZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdjb2xsZWN0aW9uJztcbn07XG5lbGVzZm4kMS5zcGF3biA9IGZ1bmN0aW9uIChlbGVzLCB1bmlxdWUpIHtcbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuY3koKSwgZWxlcywgdW5pcXVlKTtcbn07XG5lbGVzZm4kMS5zcGF3blNlbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNwYXduKHRoaXMpO1xufTtcbmVsZXNmbiQxLmN5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeTtcbn07XG5lbGVzZm4kMS5yZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3kucmVuZGVyZXIoKTtcbn07XG5lbGVzZm4kMS5lbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpc1swXTtcbn07XG5lbGVzZm4kMS5jb2xsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICBpZiAoY29sbGVjdGlvbih0aGlzKSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIC8vIGFuIGVsZW1lbnRcbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgW3RoaXNdKTtcbiAgfVxufTtcbmVsZXNmbiQxLnVuaXF1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIHRoaXMsIHRydWUpO1xufTtcbmVsZXNmbiQxLmhhc0VsZW1lbnRXaXRoSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5oYXMoaWQpO1xufTtcbmVsZXNmbiQxLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlkID0gJycgKyBpZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZW50cnkgPSB0aGlzLl9wcml2YXRlLm1hcC5nZXQoaWQpO1xuICByZXR1cm4gZW50cnkgPyBlbnRyeS5lbGUgOiBuZXcgQ29sbGVjdGlvbihjeSk7IC8vIGdldCBlbGUgb3IgZW1wdHkgY29sbGVjdGlvblxufTtcbmVsZXNmbiQxLiRpZCA9IGVsZXNmbiQxLmdldEVsZW1lbnRCeUlkO1xuZWxlc2ZuJDEucG9vbEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICB2YXIgaWQgPSB0aGlzWzBdLl9wcml2YXRlLmRhdGEuaWQ7XG4gIHJldHVybiBlbGVzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xufTtcbmVsZXNmbiQxLmluZGV4T2YgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBpZCA9IGVsZVswXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXAuZ2V0KGlkKS5pbmRleDtcbn07XG5lbGVzZm4kMS5pbmRleE9mSWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWQgPSAnJyArIGlkOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuXG4gIHJldHVybiB0aGlzLl9wcml2YXRlLm1hcC5nZXQoaWQpLmluZGV4O1xufTtcbmVsZXNmbiQxLmpzb24gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBlbGUgPSB0aGlzLmVsZW1lbnQoKTtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICBpZiAoZWxlID09IG51bGwgJiYgb2JqKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gY2FuJ3Qgc2V0IHRvIG5vIGVsZXNcblxuICBpZiAoZWxlID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IC8vIGNhbid0IGdldCBmcm9tIG5vIGVsZXNcblxuICB2YXIgcCA9IGVsZS5fcHJpdmF0ZTtcbiAgaWYgKHBsYWluT2JqZWN0KG9iaikpIHtcbiAgICAvLyBzZXRcblxuICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICBpZiAob2JqLmRhdGEpIHtcbiAgICAgIGVsZS5kYXRhKG9iai5kYXRhKTtcbiAgICAgIHZhciBfZGF0YTIgPSBwLmRhdGE7XG4gICAgICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgICAgIC8vIHNvdXJjZSBhbmQgdGFyZ2V0IGFyZSBpbW11dGFibGUgdmlhIGRhdGEoKVxuICAgICAgICB2YXIgbW92ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgc3BlYyA9IHt9O1xuICAgICAgICB2YXIgc3JjID0gb2JqLmRhdGEuc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gb2JqLmRhdGEudGFyZ2V0O1xuICAgICAgICBpZiAoc3JjICE9IG51bGwgJiYgc3JjICE9IF9kYXRhMi5zb3VyY2UpIHtcbiAgICAgICAgICBzcGVjLnNvdXJjZSA9ICcnICsgc3JjOyAvLyBpZCBtdXN0IGJlIHN0cmluZ1xuICAgICAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0Z3QgIT0gbnVsbCAmJiB0Z3QgIT0gX2RhdGEyLnRhcmdldCkge1xuICAgICAgICAgIHNwZWMudGFyZ2V0ID0gJycgKyB0Z3Q7IC8vIGlkIG11c3QgYmUgc3RyaW5nXG4gICAgICAgICAgbW92ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgICBlbGUgPSBlbGUubW92ZShzcGVjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFyZW50IGlzIGltbXV0YWJsZSB2aWEgZGF0YSgpXG4gICAgICAgIHZhciBuZXdQYXJlbnRWYWxTcGVjZCA9ICdwYXJlbnQnIGluIG9iai5kYXRhO1xuICAgICAgICB2YXIgcGFyZW50ID0gb2JqLmRhdGEucGFyZW50O1xuICAgICAgICBpZiAobmV3UGFyZW50VmFsU3BlY2QgJiYgKHBhcmVudCAhPSBudWxsIHx8IF9kYXRhMi5wYXJlbnQgIT0gbnVsbCkgJiYgcGFyZW50ICE9IF9kYXRhMi5wYXJlbnQpIHtcbiAgICAgICAgICBpZiAocGFyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGNhbid0IHNldCB1bmRlZmluZWQgaW1wZXJhdGl2ZWx5LCBzbyB1c2UgbnVsbFxuICAgICAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSAnJyArIHBhcmVudDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlID0gZWxlLm1vdmUoe1xuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqLnBvc2l0aW9uKSB7XG4gICAgICBlbGUucG9zaXRpb24ob2JqLnBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgZ3JvdXAgLS0gaW1tdXRhYmxlXG5cbiAgICB2YXIgY2hlY2tTd2l0Y2ggPSBmdW5jdGlvbiBjaGVja1N3aXRjaChrLCB0cnVlRm5OYW1lLCBmYWxzZUZuTmFtZSkge1xuICAgICAgdmFyIG9ial9rID0gb2JqW2tdO1xuICAgICAgaWYgKG9ial9rICE9IG51bGwgJiYgb2JqX2sgIT09IHBba10pIHtcbiAgICAgICAgaWYgKG9ial9rKSB7XG4gICAgICAgICAgZWxlW3RydWVGbk5hbWVdKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlW2ZhbHNlRm5OYW1lXSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjaGVja1N3aXRjaCgncmVtb3ZlZCcsICdyZW1vdmUnLCAncmVzdG9yZScpO1xuICAgIGNoZWNrU3dpdGNoKCdzZWxlY3RlZCcsICdzZWxlY3QnLCAndW5zZWxlY3QnKTtcbiAgICBjaGVja1N3aXRjaCgnc2VsZWN0YWJsZScsICdzZWxlY3RpZnknLCAndW5zZWxlY3RpZnknKTtcbiAgICBjaGVja1N3aXRjaCgnbG9ja2VkJywgJ2xvY2snLCAndW5sb2NrJyk7XG4gICAgY2hlY2tTd2l0Y2goJ2dyYWJiYWJsZScsICdncmFiaWZ5JywgJ3VuZ3JhYmlmeScpO1xuICAgIGNoZWNrU3dpdGNoKCdwYW5uYWJsZScsICdwYW5pZnknLCAndW5wYW5pZnknKTtcbiAgICBpZiAob2JqLmNsYXNzZXMgIT0gbnVsbCkge1xuICAgICAgZWxlLmNsYXNzZXMob2JqLmNsYXNzZXMpO1xuICAgIH1cbiAgICBjeS5lbmRCYXRjaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2UgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gZ2V0XG5cbiAgICB2YXIganNvbiA9IHtcbiAgICAgIGRhdGE6IGNvcHkocC5kYXRhKSxcbiAgICAgIHBvc2l0aW9uOiBjb3B5KHAucG9zaXRpb24pLFxuICAgICAgZ3JvdXA6IHAuZ3JvdXAsXG4gICAgICByZW1vdmVkOiBwLnJlbW92ZWQsXG4gICAgICBzZWxlY3RlZDogcC5zZWxlY3RlZCxcbiAgICAgIHNlbGVjdGFibGU6IHAuc2VsZWN0YWJsZSxcbiAgICAgIGxvY2tlZDogcC5sb2NrZWQsXG4gICAgICBncmFiYmFibGU6IHAuZ3JhYmJhYmxlLFxuICAgICAgcGFubmFibGU6IHAucGFubmFibGUsXG4gICAgICBjbGFzc2VzOiBudWxsXG4gICAgfTtcbiAgICBqc29uLmNsYXNzZXMgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgcC5jbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNscykge1xuICAgICAgcmV0dXJuIGpzb24uY2xhc3NlcyArPSBpKysgPT09IDAgPyBjbHMgOiAnICcgKyBjbHM7XG4gICAgfSk7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbn07XG5lbGVzZm4kMS5qc29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGpzb25zID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICBqc29ucy5wdXNoKGpzb24pO1xuICB9XG4gIHJldHVybiBqc29ucztcbn07XG5lbGVzZm4kMS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICB2YXIgZWxlc0FyciA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICB2YXIganNvbiA9IGVsZS5qc29uKCk7XG4gICAgdmFyIGNsb25lID0gbmV3IEVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTsgLy8gTkIgbm8gcmVzdG9yZVxuXG4gICAgZWxlc0Fyci5wdXNoKGNsb25lKTtcbiAgfVxuICByZXR1cm4gbmV3IENvbGxlY3Rpb24oY3ksIGVsZXNBcnIpO1xufTtcbmVsZXNmbiQxLmNvcHkgPSBlbGVzZm4kMS5jbG9uZTtcbmVsZXNmbiQxLnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub3RpZnlSZW5kZXJlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIGFkZFRvUG9vbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gIHZhciBjeV9wID0gY3kuX3ByaXZhdGU7XG5cbiAgLy8gY3JlYXRlIGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMsIHNpbmNlIHdlIG5lZWQgdG9cbiAgLy8gcmVzdG9yZSB0aGUgbm9kZXMgZmlyc3RcbiAgdmFyIG5vZGVzID0gW107XG4gIHZhciBlZGdlcyA9IFtdO1xuICB2YXIgZWxlbWVudHM7XG4gIGZvciAodmFyIF9pMyA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgX2kzIDwgbDsgX2kzKyspIHtcbiAgICB2YXIgZWxlID0gc2VsZltfaTNdO1xuICAgIGlmIChhZGRUb1Bvb2wgJiYgIWVsZS5yZW1vdmVkKCkpIHtcbiAgICAgIC8vIGRvbid0IG5lZWQgdG8gaGFuZGxlIHRoaXMgZWxlXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBrZWVwIG5vZGVzIGZpcnN0IGluIHRoZSBhcnJheSBhbmQgZWRnZXMgYWZ0ZXJcbiAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAvLyBwdXQgdG8gZnJvbnQgb2YgYXJyYXkgaWYgbm9kZVxuICAgICAgbm9kZXMucHVzaChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwdXQgdG8gZW5kIG9mIGFycmF5IGlmIGVkZ2VcbiAgICAgIGVkZ2VzLnB1c2goZWxlKTtcbiAgICB9XG4gIH1cbiAgZWxlbWVudHMgPSBub2Rlcy5jb25jYXQoZWRnZXMpO1xuICB2YXIgaTtcbiAgdmFyIHJlbW92ZUZyb21FbGVtZW50cyA9IGZ1bmN0aW9uIHJlbW92ZUZyb21FbGVtZW50cygpIHtcbiAgICBlbGVtZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgaS0tO1xuICB9O1xuXG4gIC8vIG5vdywgcmVzdG9yZSBlYWNoIGVsZW1lbnRcbiAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9lbGUyID0gZWxlbWVudHNbaV07XG4gICAgdmFyIF9wcml2YXRlID0gX2VsZTIuX3ByaXZhdGU7XG4gICAgdmFyIF9kYXRhMyA9IF9wcml2YXRlLmRhdGE7XG5cbiAgICAvLyB0aGUgdHJhdmVyc2FsIGNhY2hlIHNob3VsZCBzdGFydCBmcmVzaCB3aGVuIGVsZSBpcyBhZGRlZFxuICAgIF9lbGUyLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcblxuICAgIC8vIHNldCBpZCBhbmQgdmFsaWRhdGVcbiAgICBpZiAoIWFkZFRvUG9vbCAmJiAhX3ByaXZhdGUucmVtb3ZlZCkgOyBlbHNlIGlmIChfZGF0YTMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgX2RhdGEzLmlkID0gdXVpZCgpO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyJDEoX2RhdGEzLmlkKSkge1xuICAgICAgX2RhdGEzLmlkID0gJycgKyBfZGF0YTMuaWQ7IC8vIG5vdyBpdCdzIGEgc3RyaW5nXG4gICAgfSBlbHNlIGlmIChlbXB0eVN0cmluZyhfZGF0YTMuaWQpIHx8ICFzdHJpbmcoX2RhdGEzLmlkKSkge1xuICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVsZW1lbnQgd2l0aCBpbnZhbGlkIHN0cmluZyBJRCBgJyArIF9kYXRhMy5pZCArICdgJyk7XG5cbiAgICAgIC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIGl0IGhhcyBlbXB0eSBzdHJpbmcgYXMgaWQgb3Igbm9uLXN0cmluZyBpZFxuICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGN5Lmhhc0VsZW1lbnRXaXRoSWQoX2RhdGEzLmlkKSkge1xuICAgICAgZXJyb3IoJ0NhbiBub3QgY3JlYXRlIHNlY29uZCBlbGVtZW50IHdpdGggSUQgYCcgKyBfZGF0YTMuaWQgKyAnYCcpO1xuXG4gICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBvbmUgYWxyZWFkeSBoYXMgdGhhdCBpZFxuICAgICAgcmVtb3ZlRnJvbUVsZW1lbnRzKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlkID0gX2RhdGEzLmlkOyAvLyBpZCBpcyBmaW5hbGlzZWQsIG5vdyBsZXQncyBrZWVwIGEgcmVmXG5cbiAgICBpZiAoX2VsZTIuaXNOb2RlKCkpIHtcbiAgICAgIC8vIGV4dHJhIGNoZWNrcyBmb3Igbm9kZXNcbiAgICAgIHZhciBwb3MgPSBfcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgLy8gbWFrZSBzdXJlIHRoZSBub2RlcyBoYXZlIGEgZGVmaW5lZCBwb3NpdGlvblxuXG4gICAgICBpZiAocG9zLnggPT0gbnVsbCkge1xuICAgICAgICBwb3MueCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocG9zLnkgPT0gbnVsbCkge1xuICAgICAgICBwb3MueSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfZWxlMi5pc0VkZ2UoKSkge1xuICAgICAgLy8gZXh0cmEgY2hlY2tzIGZvciBlZGdlc1xuXG4gICAgICB2YXIgZWRnZSA9IF9lbGUyO1xuICAgICAgdmFyIGZpZWxkcyA9IFsnc291cmNlJywgJ3RhcmdldCddO1xuICAgICAgdmFyIGZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICB2YXIgYmFkU291cmNlT3JUYXJnZXQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2pdO1xuICAgICAgICB2YXIgdmFsID0gX2RhdGEzW2ZpZWxkXTtcbiAgICAgICAgaWYgKG51bWJlciQxKHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSBfZGF0YTNbZmllbGRdID0gJycgKyBfZGF0YTNbZmllbGRdOyAvLyBub3cgc3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gJycpIHtcbiAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgaWYgc291cmNlIG9yIHRhcmdldCBpcyBub3QgZGVmaW5lZCBwcm9wZXJseVxuICAgICAgICAgIGVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIHVuc3BlY2lmaWVkICcgKyBmaWVsZCk7XG4gICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFjeS5oYXNFbGVtZW50V2l0aElkKHZhbCkpIHtcbiAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWRnZSBpZiBvbmUgb2YgaXRzIG5vZGVzIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICBlcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCBub25leGlzdGFudCAnICsgZmllbGQgKyAnIGAnICsgdmFsICsgJ2AnKTtcbiAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChiYWRTb3VyY2VPclRhcmdldCkge1xuICAgICAgICByZW1vdmVGcm9tRWxlbWVudHMoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIGNhbid0IGNyZWF0ZSB0aGlzXG5cbiAgICAgIHZhciBzcmMgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMuc291cmNlKTtcbiAgICAgIHZhciB0Z3QgPSBjeS5nZXRFbGVtZW50QnlJZChfZGF0YTMudGFyZ2V0KTtcblxuICAgICAgLy8gb25seSBvbmUgZWRnZSBpbiBub2RlIGlmIGxvb3BcbiAgICAgIGlmIChzcmMuc2FtZSh0Z3QpKSB7XG4gICAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3JjLl9wcml2YXRlLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIHRndC5fcHJpdmF0ZS5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgICAgZWRnZS5fcHJpdmF0ZS5zb3VyY2UgPSBzcmM7XG4gICAgICBlZGdlLl9wcml2YXRlLnRhcmdldCA9IHRndDtcbiAgICB9IC8vIGlmIGlzIGVkZ2VcblxuICAgIC8vIGNyZWF0ZSBtb2NrIGlkcyAvIGluZGV4ZXMgbWFwcyBmb3IgZWxlbWVudCBzbyBpdCBjYW4gYmUgdXNlZCBsaWtlIGNvbGxlY3Rpb25zXG4gICAgX3ByaXZhdGUubWFwID0gbmV3IE1hcCQxKCk7XG4gICAgX3ByaXZhdGUubWFwLnNldChpZCwge1xuICAgICAgZWxlOiBfZWxlMixcbiAgICAgIGluZGV4OiAwXG4gICAgfSk7XG4gICAgX3ByaXZhdGUucmVtb3ZlZCA9IGZhbHNlO1xuICAgIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgIGN5LmFkZFRvUG9vbChfZWxlMik7XG4gICAgfVxuICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcblxuICAvLyBkbyBjb21wb3VuZCBub2RlIHNhbml0eSBjaGVja3NcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZXMubGVuZ3RoOyBfaTQrKykge1xuICAgIC8vIGVhY2ggbm9kZVxuICAgIHZhciBub2RlID0gbm9kZXNbX2k0XTtcbiAgICB2YXIgX2RhdGE0ID0gbm9kZS5fcHJpdmF0ZS5kYXRhO1xuICAgIGlmIChudW1iZXIkMShfZGF0YTQucGFyZW50KSkge1xuICAgICAgLy8gdGhlbiBhdXRvbWFrZSBzdHJpbmdcbiAgICAgIF9kYXRhNC5wYXJlbnQgPSAnJyArIF9kYXRhNC5wYXJlbnQ7XG4gICAgfVxuICAgIHZhciBwYXJlbnRJZCA9IF9kYXRhNC5wYXJlbnQ7XG4gICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG4gICAgaWYgKHNwZWNpZmllZFBhcmVudCB8fCBub2RlLl9wcml2YXRlLnBhcmVudCkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUuX3ByaXZhdGUucGFyZW50ID8gY3kuY29sbGVjdGlvbigpLm1lcmdlKG5vZGUuX3ByaXZhdGUucGFyZW50KSA6IGN5LmdldEVsZW1lbnRCeUlkKHBhcmVudElkKTtcbiAgICAgIGlmIChwYXJlbnQuZW1wdHkoKSkge1xuICAgICAgICAvLyBub24tZXhpc3RhbnQgcGFyZW50OyBqdXN0IHJlbW92ZSBpdFxuICAgICAgICBfZGF0YTQucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnRbMF0ucmVtb3ZlZCgpKSB7XG4gICAgICAgIHdhcm4oJ05vZGUgYWRkZWQgd2l0aCBtaXNzaW5nIHBhcmVudCwgcmVmZXJlbmNlIHRvIHBhcmVudCByZW1vdmVkJyk7XG4gICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmQXNQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgICB3aGlsZSAoIWFuY2VzdG9yLmVtcHR5KCkpIHtcbiAgICAgICAgICBpZiAobm9kZS5zYW1lKGFuY2VzdG9yKSkge1xuICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9kYXRhNC5wYXJlbnQgPSB1bmRlZmluZWQ7IC8vIHJlbW92ZSBwYXJlbnQgcmVmZXJlbmNlXG5cbiAgICAgICAgICAgIC8vIGV4aXQgb3Igd2UgbG9vcCBmb3JldmVyXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGZBc1BhcmVudCkge1xuICAgICAgICAgIC8vIGNvbm5lY3Qgd2l0aCBjaGlsZHJlblxuICAgICAgICAgIHBhcmVudFswXS5fcHJpdmF0ZS5jaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgICAgICAgLy8gbGV0IHRoZSBjb3JlIGtub3cgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoXG4gICAgICAgICAgY3lfcC5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbHNlXG4gICAgfSAvLyBpZiBzcGVjaWZpZWQgcGFyZW50XG4gIH0gLy8gZm9yIGVhY2ggbm9kZVxuXG4gIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHJlc3RvcmVkID0gZWxlbWVudHMubGVuZ3RoID09PSBzZWxmLmxlbmd0aCA/IHNlbGYgOiBuZXcgQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpO1xuICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHJlc3RvcmVkLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgIHZhciBfZWxlMyA9IHJlc3RvcmVkW19pNV07XG4gICAgICBpZiAoX2VsZTMuaXNOb2RlKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcbiAgICAgIF9lbGUzLnBhcmFsbGVsRWRnZXMoKS5jbGVhclRyYXZlcnNhbENhY2hlKCk7XG5cbiAgICAgIC8vIGFkZGluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIHRoZSBjb25uZWN0ZWQgbm9kZXNcbiAgICAgIF9lbGUzLnNvdXJjZSgpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgICAgIF9lbGUzLnRhcmdldCgpLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgICB9XG4gICAgdmFyIHRvVXBkYXRlU3R5bGU7XG4gICAgaWYgKGN5X3AuaGFzQ29tcG91bmROb2Rlcykge1xuICAgICAgdG9VcGRhdGVTdHlsZSA9IGN5LmNvbGxlY3Rpb24oKS5tZXJnZShyZXN0b3JlZCkubWVyZ2UocmVzdG9yZWQuY29ubmVjdGVkTm9kZXMoKSkubWVyZ2UocmVzdG9yZWQucGFyZW50KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1VwZGF0ZVN0eWxlID0gcmVzdG9yZWQ7XG4gICAgfVxuICAgIHRvVXBkYXRlU3R5bGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCkuZGlydHlCb3VuZGluZ0JveENhY2hlKCkudXBkYXRlU3R5bGUobm90aWZ5UmVuZGVyZXIpO1xuICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgcmVzdG9yZWQuZW1pdEFuZE5vdGlmeSgnYWRkJyk7XG4gICAgfSBlbHNlIGlmIChhZGRUb1Bvb2wpIHtcbiAgICAgIHJlc3RvcmVkLmVtaXQoJ2FkZCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VsZjsgLy8gY2hhaW5hYmlsaXR5XG59O1xuZWxlc2ZuJDEucmVtb3ZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVsZSA9IHRoaXNbMF07XG4gIHJldHVybiBlbGUgJiYgZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuZWxlc2ZuJDEuaW5zaWRlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlID0gdGhpc1swXTtcbiAgcmV0dXJuIGVsZSAmJiAhZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG59O1xuZWxlc2ZuJDEucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciByZW1vdmVGcm9tUG9vbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZWxlc1RvUmVtb3ZlID0gW107XG4gIHZhciBlbGVzVG9SZW1vdmVJZHMgPSB7fTtcbiAgdmFyIGN5ID0gc2VsZi5fcHJpdmF0ZS5jeTtcblxuICAvLyBhZGQgY29ubmVjdGVkIGVkZ2VzXG4gIGZ1bmN0aW9uIGFkZENvbm5lY3RlZEVkZ2VzKG5vZGUpIHtcbiAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFkZChlZGdlc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIGRlc2NlbmRhbnQgbm9kZXNcbiAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4obm9kZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWRkKGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYWRkKGVsZSkge1xuICAgIHZhciBhbHJlYWR5QWRkZWQgPSBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldO1xuICAgIGlmIChyZW1vdmVGcm9tUG9vbCAmJiBlbGUucmVtb3ZlZCgpIHx8IGFscmVhZHlBZGRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzVG9SZW1vdmVJZHNbZWxlLmlkKCldID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgZWxlc1RvUmVtb3ZlLnB1c2goZWxlKTsgLy8gbm9kZXMgYXJlIHJlbW92ZWQgbGFzdFxuXG4gICAgICBhZGRDb25uZWN0ZWRFZGdlcyhlbGUpO1xuICAgICAgYWRkQ2hpbGRyZW4oZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlc1RvUmVtb3ZlLnVuc2hpZnQoZWxlKTsgLy8gZWRnZXMgYXJlIHJlbW92ZWQgZmlyc3RcbiAgICB9XG4gIH1cblxuICAvLyBtYWtlIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICAvLyAobWF5IGJlIHJlbW92aW5nIG1vcmUgdGhhbiBzcGVjaWZpZWQgZHVlIHRvIGNvbm5lY3RlZCBlZGdlcyBldGMpXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuICAgIGFkZChlbGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUVkZ2VSZWYobm9kZSwgZWRnZSkge1xuICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgcmVtb3ZlRnJvbUFycmF5KGNvbm5lY3RlZEVkZ2VzLCBlZGdlKTtcblxuICAgIC8vIHJlbW92aW5nIGFuIGVkZ2VzIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGUgZm9yIGl0cyBub2Rlc1xuICAgIG5vZGUuY2xlYXJUcmF2ZXJzYWxDYWNoZSgpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVBhcmFsbGVsUmVmKHBsbEVkZ2UpIHtcbiAgICAvLyByZW1vdmluZyBhbiBlZGdlIGludmFsaWRhdGVzIHRoZSB0cmF2ZXJzYWwgY2FjaGVzIGZvciB0aGUgcGFyYWxsZWwgZWRnZXNcbiAgICBwbGxFZGdlLmNsZWFyVHJhdmVyc2FsQ2FjaGUoKTtcbiAgfVxuICB2YXIgYWx0ZXJlZFBhcmVudHMgPSBbXTtcbiAgYWx0ZXJlZFBhcmVudHMuaWRzID0ge307XG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgZWxlKSB7XG4gICAgZWxlID0gZWxlWzBdO1xuICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX3ByaXZhdGUuY2hpbGRyZW47XG4gICAgdmFyIHBpZCA9IHBhcmVudC5pZCgpO1xuICAgIHJlbW92ZUZyb21BcnJheShjaGlsZHJlbiwgZWxlKTsgLy8gcmVtb3ZlIHBhcmVudCA9PiBjaGlsZCByZWZcblxuICAgIGVsZS5fcHJpdmF0ZS5wYXJlbnQgPSBudWxsOyAvLyByZW1vdmUgY2hpbGQgPT4gcGFyZW50IHJlZlxuXG4gICAgaWYgKCFhbHRlcmVkUGFyZW50cy5pZHNbcGlkXSkge1xuICAgICAgYWx0ZXJlZFBhcmVudHMuaWRzW3BpZF0gPSB0cnVlO1xuICAgICAgYWx0ZXJlZFBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgIH1cbiAgfVxuICBzZWxmLmRpcnR5Q29tcG91bmRCb3VuZHNDYWNoZSgpO1xuICBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICBjeS5yZW1vdmVGcm9tUG9vbChlbGVzVG9SZW1vdmUpOyAvLyByZW1vdmUgZnJvbSBjb3JlIHBvb2xcbiAgfVxuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBlbGVzVG9SZW1vdmUubGVuZ3RoOyBfaTYrKykge1xuICAgIHZhciBfZWxlNCA9IGVsZXNUb1JlbW92ZVtfaTZdO1xuICAgIGlmIChfZWxlNC5pc0VkZ2UoKSkge1xuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gdGhpcyBlZGdlIGluIGl0cyBjb25uZWN0ZWQgbm9kZXNcbiAgICAgIHZhciBzcmMgPSBfZWxlNC5zb3VyY2UoKVswXTtcbiAgICAgIHZhciB0Z3QgPSBfZWxlNC50YXJnZXQoKVswXTtcbiAgICAgIHJlbW92ZUVkZ2VSZWYoc3JjLCBfZWxlNCk7XG4gICAgICByZW1vdmVFZGdlUmVmKHRndCwgX2VsZTQpO1xuICAgICAgdmFyIHBsbEVkZ2VzID0gX2VsZTQucGFyYWxsZWxFZGdlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwbGxFZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgcGxsRWRnZSA9IHBsbEVkZ2VzW2pdO1xuICAgICAgICByZW1vdmVQYXJhbGxlbFJlZihwbGxFZGdlKTtcbiAgICAgICAgaWYgKHBsbEVkZ2UuaXNCdW5kbGVkQmV6aWVyKCkpIHtcbiAgICAgICAgICBwbGxFZGdlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gcGFyZW50XG4gICAgICB2YXIgcGFyZW50ID0gX2VsZTQucGFyZW50KCk7XG4gICAgICBpZiAocGFyZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZW1vdmVDaGlsZFJlZihwYXJlbnQsIF9lbGU0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbW92ZUZyb21Qb29sKSB7XG4gICAgICAvLyBtYXJrIGFzIHJlbW92ZWRcbiAgICAgIF9lbGU0Ll9wcml2YXRlLnJlbW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGggb3Igbm90XG4gIHZhciBlbGVzU3RpbGxJbnNpZGUgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IGZhbHNlO1xuICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBfaTcrKykge1xuICAgIHZhciBfZWxlNSA9IGVsZXNTdGlsbEluc2lkZVtfaTddO1xuICAgIGlmIChfZWxlNS5pc1BhcmVudCgpKSB7XG4gICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgcmVtb3ZlZEVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24odGhpcy5jeSgpLCBlbGVzVG9SZW1vdmUpO1xuICBpZiAocmVtb3ZlZEVsZW1lbnRzLnNpemUoKSA+IDApIHtcbiAgICAvLyBtdXN0IG1hbnVhbGx5IG5vdGlmeSBzaW5jZSB0cmlnZ2VyIHdvbid0IGRvIHRoaXMgYXV0b21hdGljYWxseSBvbmNlIHJlbW92ZWRcblxuICAgIGlmIChub3RpZnlSZW5kZXJlcikge1xuICAgICAgcmVtb3ZlZEVsZW1lbnRzLmVtaXRBbmROb3RpZnkoJ3JlbW92ZScpO1xuICAgIH0gZWxzZSBpZiAocmVtb3ZlRnJvbVBvb2wpIHtcbiAgICAgIHJlbW92ZWRFbGVtZW50cy5lbWl0KCdyZW1vdmUnKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgcGFyZW50cyB3aG8gd2VyZSBtb2RpZmllZCBieSB0aGUgcmVtb3ZhbCBuZWVkIHRoZWlyIHN0eWxlIHVwZGF0ZWRcbiAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgYWx0ZXJlZFBhcmVudHMubGVuZ3RoOyBfaTgrKykge1xuICAgIHZhciBfZWxlNiA9IGFsdGVyZWRQYXJlbnRzW19pOF07XG4gICAgaWYgKCFyZW1vdmVGcm9tUG9vbCB8fCAhX2VsZTYucmVtb3ZlZCgpKSB7XG4gICAgICBfZWxlNi51cGRhdGVTdHlsZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVtb3ZlZEVsZW1lbnRzO1xufTtcbmVsZXNmbiQxLm1vdmUgPSBmdW5jdGlvbiAoc3RydWN0KSB7XG4gIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gIHZhciBlbGVzID0gdGhpcztcblxuICAvLyBqdXN0IGNsZWFuIHVwIHJlZnMsIGNhY2hlcywgZXRjLiBpbiB0aGUgc2FtZSB3YXkgYXMgd2hlbiByZW1vdmluZyBhbmQgdGhlbiByZXN0b3JpbmdcbiAgLy8gKG91ciBjYWxscyB0byByZW1vdmUvcmVzdG9yZSBkbyBub3QgcmVtb3ZlIGZyb20gdGhlIGdyYXBoIG9yIG1ha2UgZXZlbnRzKVxuICB2YXIgbm90aWZ5UmVuZGVyZXIgPSBmYWxzZTtcbiAgdmFyIG1vZGlmeVBvb2wgPSBmYWxzZTtcbiAgdmFyIHRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoaWQpIHtcbiAgICByZXR1cm4gaWQgPT0gbnVsbCA/IGlkIDogJycgKyBpZDtcbiAgfTsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcblxuICBpZiAoc3RydWN0LnNvdXJjZSAhPT0gdW5kZWZpbmVkIHx8IHN0cnVjdC50YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzcmNJZCA9IHRvU3RyaW5nKHN0cnVjdC5zb3VyY2UpO1xuICAgIHZhciB0Z3RJZCA9IHRvU3RyaW5nKHN0cnVjdC50YXJnZXQpO1xuICAgIHZhciBzcmNFeGlzdHMgPSBzcmNJZCAhPSBudWxsICYmIGN5Lmhhc0VsZW1lbnRXaXRoSWQoc3JjSWQpO1xuICAgIHZhciB0Z3RFeGlzdHMgPSB0Z3RJZCAhPSBudWxsICYmIGN5Lmhhc0VsZW1lbnRXaXRoSWQodGd0SWQpO1xuICAgIGlmIChzcmNFeGlzdHMgfHwgdGd0RXhpc3RzKSB7XG4gICAgICBjeS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGF2b2lkIGR1cGxpY2F0ZSBzdHlsZSB1cGRhdGVzXG4gICAgICAgIGVsZXMucmVtb3ZlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gY2xlYW4gdXAgcmVmcyBldGMuXG4gICAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZW91dCcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICB2YXIgX2RhdGE1ID0gZWxlLl9wcml2YXRlLmRhdGE7XG4gICAgICAgICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgICAgICAgaWYgKHNyY0V4aXN0cykge1xuICAgICAgICAgICAgICBfZGF0YTUuc291cmNlID0gc3JjSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGd0RXhpc3RzKSB7XG4gICAgICAgICAgICAgIF9kYXRhNS50YXJnZXQgPSB0Z3RJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlcy5yZXN0b3JlKG5vdGlmeVJlbmRlcmVyLCBtb2RpZnlQb29sKTsgLy8gbWFrZSBuZXcgcmVmcywgc3R5bGUsIGV0Yy5cbiAgICAgIH0pO1xuICAgICAgZWxlcy5lbWl0QW5kTm90aWZ5KCdtb3ZlJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0cnVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIG1vdmUgbm9kZSB0byBuZXcgcGFyZW50XG4gICAgdmFyIHBhcmVudElkID0gdG9TdHJpbmcoc3RydWN0LnBhcmVudCk7XG4gICAgdmFyIHBhcmVudEV4aXN0cyA9IHBhcmVudElkID09PSBudWxsIHx8IGN5Lmhhc0VsZW1lbnRXaXRoSWQocGFyZW50SWQpO1xuICAgIGlmIChwYXJlbnRFeGlzdHMpIHtcbiAgICAgIHZhciBwaWRUb0Fzc2lnbiA9IHBhcmVudElkID09PSBudWxsID8gdW5kZWZpbmVkIDogcGFyZW50SWQ7XG4gICAgICBjeS5iYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGF2b2lkIGR1cGxpY2F0ZSBzdHlsZSB1cGRhdGVzXG4gICAgICAgIHZhciB1cGRhdGVkID0gZWxlcy5yZW1vdmUobm90aWZ5UmVuZGVyZXIsIG1vZGlmeVBvb2wpOyAvLyBjbGVhbiB1cCByZWZzIGV0Yy5cbiAgICAgICAgdXBkYXRlZC5lbWl0QW5kTm90aWZ5KCdtb3Zlb3V0Jyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHZhciBfZGF0YTYgPSBlbGUuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgICBpZiAoZWxlLmlzTm9kZSgpKSB7XG4gICAgICAgICAgICBfZGF0YTYucGFyZW50ID0gcGlkVG9Bc3NpZ247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZWQucmVzdG9yZShub3RpZnlSZW5kZXJlciwgbW9kaWZ5UG9vbCk7IC8vIG1ha2UgbmV3IHJlZnMsIHN0eWxlLCBldGMuXG4gICAgICB9KTtcbiAgICAgIGVsZXMuZW1pdEFuZE5vdGlmeSgnbW92ZScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5bZWxlc2ZuJGosIGVsZXNmbiRpLCBlbGVzZm4kaCwgZWxlc2ZuJGcsIGVsZXNmbiRmLCBkYXRhLCBlbGVzZm4kZCwgZGltZW5zaW9ucywgZWxlc2ZuJDksIGVsZXNmbiQ4LCBlbGVzZm4kNywgZWxlc2ZuJDYsIGVsZXNmbiQ1LCBlbGVzZm4kNCwgZWxlc2ZuJDMsIGVsZXNmbiQyXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICBleHRlbmQoZWxlc2ZuJDEsIHByb3BzKTtcbn0pO1xuXG52YXIgY29yZWZuJDkgPSB7XG4gIGFkZDogZnVuY3Rpb24gYWRkKG9wdHMpIHtcbiAgICB2YXIgZWxlbWVudHM7XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIC8vIGFkZCB0aGUgZWxlbWVudHNcbiAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihvcHRzKSkge1xuICAgICAgdmFyIGVsZXMgPSBvcHRzO1xuICAgICAgaWYgKGVsZXMuX3ByaXZhdGUuY3kgPT09IGN5KSB7XG4gICAgICAgIC8vIHNhbWUgaW5zdGFuY2UgPT4ganVzdCByZXN0b3JlXG4gICAgICAgIGVsZW1lbnRzID0gZWxlcy5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UsIGNvcHkgZnJvbSBqc29uXG4gICAgICAgIHZhciBqc29ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICBqc29ucy5wdXNoKGVsZS5qc29uKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIGpzb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzcGVjaWZ5IGFuIGFycmF5IG9mIG9wdGlvbnNcbiAgICBlbHNlIGlmIChhcnJheShvcHRzKSkge1xuICAgICAgdmFyIF9qc29ucyA9IG9wdHM7XG4gICAgICBlbGVtZW50cyA9IG5ldyBDb2xsZWN0aW9uKGN5LCBfanNvbnMpO1xuICAgIH1cblxuICAgIC8vIHNwZWNpZnkgdmlhIG9wdHMubm9kZXMgYW5kIG9wdHMuZWRnZXNcbiAgICBlbHNlIGlmIChwbGFpbk9iamVjdChvcHRzKSAmJiAoYXJyYXkob3B0cy5ub2RlcykgfHwgYXJyYXkob3B0cy5lZGdlcykpKSB7XG4gICAgICB2YXIgZWxlc0J5R3JvdXAgPSBvcHRzO1xuICAgICAgdmFyIF9qc29uczIgPSBbXTtcbiAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIGlsID0gZ3JzLmxlbmd0aDsgX2kgPCBpbDsgX2krKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBncnNbX2ldO1xuICAgICAgICB2YXIgZWxlc0FycmF5ID0gZWxlc0J5R3JvdXBbZ3JvdXBdO1xuICAgICAgICBpZiAoYXJyYXkoZWxlc0FycmF5KSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqbCA9IGVsZXNBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrKSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IGV4dGVuZCh7XG4gICAgICAgICAgICAgIGdyb3VwOiBncm91cFxuICAgICAgICAgICAgfSwgZWxlc0FycmF5W2pdKTtcbiAgICAgICAgICAgIF9qc29uczIucHVzaChqc29uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsZW1lbnRzID0gbmV3IENvbGxlY3Rpb24oY3ksIF9qc29uczIpO1xuICAgIH1cblxuICAgIC8vIHNwZWNpZnkgb3B0aW9ucyBmb3Igb25lIGVsZW1lbnRcbiAgICBlbHNlIHtcbiAgICAgIHZhciBfanNvbiA9IG9wdHM7XG4gICAgICBlbGVtZW50cyA9IG5ldyBFbGVtZW50KGN5LCBfanNvbikuY29sbGVjdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudHM7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNvbGxlY3Rpb24pIHtcbiAgICBpZiAoZWxlbWVudE9yQ29sbGVjdGlvbihjb2xsZWN0aW9uKSkgOyBlbHNlIGlmIChzdHJpbmcoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBzZWxlY3RvciA9IGNvbGxlY3Rpb247XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy4kKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24ucmVtb3ZlKCk7XG4gIH1cbn07XG5cbi8qIGdsb2JhbCBGbG9hdDMyQXJyYXkgKi9cblxuLyohIEJlemllciBjdXJ2ZSBmdW5jdGlvbiBnZW5lcmF0b3IuIENvcHlyaWdodCBHYWV0YW4gUmVuYXVkZWF1LiBNSVQgTGljZW5zZTogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NSVRfTGljZW5zZSAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVDdWJpY0JlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgdmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNCxcbiAgICBORVdUT05fTUlOX1NMT1BFID0gMC4wMDEsXG4gICAgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxLFxuICAgIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTAsXG4gICAga1NwbGluZVRhYmxlU2l6ZSA9IDExLFxuICAgIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKSxcbiAgICBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJztcblxuICAvKiBNdXN0IGNvbnRhaW4gZm91ciBhcmd1bWVudHMuICovXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSA0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyogQXJndW1lbnRzIG11c3QgYmUgbnVtYmVycy4gKi9cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSAhPT0gXCJudW1iZXJcIiB8fCBpc05hTihhcmd1bWVudHNbaV0pIHx8ICFpc0Zpbml0ZShhcmd1bWVudHNbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyogWCB2YWx1ZXMgbXVzdCBiZSBpbiB0aGUgWzAsIDFdIHJhbmdlLiAqL1xuICBtWDEgPSBNYXRoLm1pbihtWDEsIDEpO1xuICBtWDIgPSBNYXRoLm1pbihtWDIsIDEpO1xuICBtWDEgPSBNYXRoLm1heChtWDEsIDApO1xuICBtWDIgPSBNYXRoLm1heChtWDIsIDApO1xuICB2YXIgbVNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExO1xuICB9XG4gIGZ1bmN0aW9uIEIoYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMy4wICogYUEyIC0gNi4wICogYUExO1xuICB9XG4gIGZ1bmN0aW9uIEMoYUExKSB7XG4gICAgcmV0dXJuIDMuMCAqIGFBMTtcbiAgfVxuICBmdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikge1xuICAgIHJldHVybiAoKEEoYUExLCBhQTIpICogYVQgKyBCKGFBMSwgYUEyKSkgKiBhVCArIEMoYUExKSkgKiBhVDtcbiAgfVxuICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTtcbiAgfVxuICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCkge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBORVdUT05fSVRFUkFUSU9OUzsgKytfaSkge1xuICAgICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cbiAgICByZXR1cm4gYUd1ZXNzVDtcbiAgfVxuICBmdW5jdGlvbiBjYWxjU2FtcGxlVmFsdWVzKCkge1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGtTcGxpbmVUYWJsZVNpemU7ICsrX2kyKSB7XG4gICAgICBtU2FtcGxlVmFsdWVzW19pMl0gPSBjYWxjQmV6aWVyKF9pMiAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQikge1xuICAgIHZhciBjdXJyZW50WCxcbiAgICAgIGN1cnJlbnRULFxuICAgICAgaSA9IDA7XG4gICAgZG8ge1xuICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gU1VCRElWSVNJT05fUFJFQ0lTSU9OICYmICsraSA8IFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TKTtcbiAgICByZXR1cm4gY3VycmVudFQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICB2YXIgaW50ZXJ2YWxTdGFydCA9IDAuMCxcbiAgICAgIGN1cnJlbnRTYW1wbGUgPSAxLFxuICAgICAgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgfVxuICAgIC0tY3VycmVudFNhbXBsZTtcbiAgICB2YXIgZGlzdCA9IChhWCAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSksXG4gICAgICBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZSxcbiAgICAgIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUpO1xuICAgIH1cbiAgfVxuICB2YXIgX3ByZWNvbXB1dGVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gICAgX3ByZWNvbXB1dGVkID0gdHJ1ZTtcbiAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgIGNhbGNTYW1wbGVWYWx1ZXMoKTtcbiAgICB9XG4gIH1cbiAgdmFyIGYgPSBmdW5jdGlvbiBmKGFYKSB7XG4gICAgaWYgKCFfcHJlY29tcHV0ZWQpIHtcbiAgICAgIHByZWNvbXB1dGUoKTtcbiAgICB9XG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKSB7XG4gICAgICByZXR1cm4gYVg7XG4gICAgfVxuICAgIGlmIChhWCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChhWCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKGFYKSwgbVkxLCBtWTIpO1xuICB9O1xuICBmLmdldENvbnRyb2xQb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICB4OiBtWDEsXG4gICAgICB5OiBtWTFcbiAgICB9LCB7XG4gICAgICB4OiBtWDIsXG4gICAgICB5OiBtWTJcbiAgICB9XTtcbiAgfTtcbiAgdmFyIHN0ciA9IFwiZ2VuZXJhdGVCZXppZXIoXCIgKyBbbVgxLCBtWTEsIG1YMiwgbVkyXSArIFwiKVwiO1xuICBmLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdHI7XG4gIH07XG4gIHJldHVybiBmO1xufVxuXG4vKiEgUnVuZ2UtS3V0dGEgc3ByaW5nIHBoeXNpY3MgZnVuY3Rpb24gZ2VuZXJhdG9yLiBBZGFwdGVkIGZyb20gRnJhbWVyLmpzLCBjb3B5cmlnaHQgS29lbiBCb2suIE1JVCBMaWNlbnNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlICovXG4vKiBHaXZlbiBhIHRlbnNpb24sIGZyaWN0aW9uLCBhbmQgZHVyYXRpb24sIGEgc2ltdWxhdGlvbiBhdCA2MEZQUyB3aWxsIGZpcnN0IHJ1biB3aXRob3V0IGEgZGVmaW5lZCBkdXJhdGlvbiBpbiBvcmRlciB0byBjYWxjdWxhdGUgdGhlIGZ1bGwgcGF0aC4gQSBzZWNvbmQgcGFzc1xuICAgdGhlbiBhZGp1c3RzIHRoZSB0aW1lIGRlbHRhIC0tIHVzaW5nIHRoZSByZWxhdGlvbiBiZXR3ZWVuIGFjdHVhbCB0aW1lIGFuZCBkdXJhdGlvbiAtLSB0byBjYWxjdWxhdGUgdGhlIHBhdGggZm9yIHRoZSBkdXJhdGlvbi1jb25zdHJhaW5lZCBhbmltYXRpb24uICovXG52YXIgZ2VuZXJhdGVTcHJpbmdSSzQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIC1zdGF0ZS50ZW5zaW9uICogc3RhdGUueCAtIHN0YXRlLmZyaWN0aW9uICogc3RhdGUudjtcbiAgfVxuICBmdW5jdGlvbiBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoaW5pdGlhbFN0YXRlLCBkdCwgZGVyaXZhdGl2ZSkge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHg6IGluaXRpYWxTdGF0ZS54ICsgZGVyaXZhdGl2ZS5keCAqIGR0LFxuICAgICAgdjogaW5pdGlhbFN0YXRlLnYgKyBkZXJpdmF0aXZlLmR2ICogZHQsXG4gICAgICB0ZW5zaW9uOiBpbml0aWFsU3RhdGUudGVuc2lvbixcbiAgICAgIGZyaWN0aW9uOiBpbml0aWFsU3RhdGUuZnJpY3Rpb25cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBkeDogc3RhdGUudixcbiAgICAgIGR2OiBzcHJpbmdBY2NlbGVyYXRpb25Gb3JTdGF0ZShzdGF0ZSlcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNwcmluZ0ludGVncmF0ZVN0YXRlKHN0YXRlLCBkdCkge1xuICAgIHZhciBhID0ge1xuICAgICAgICBkeDogc3RhdGUudixcbiAgICAgICAgZHY6IHNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlKHN0YXRlKVxuICAgICAgfSxcbiAgICAgIGIgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBhKSxcbiAgICAgIGMgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0ICogMC41LCBiKSxcbiAgICAgIGQgPSBzcHJpbmdFdmFsdWF0ZVN0YXRlV2l0aERlcml2YXRpdmUoc3RhdGUsIGR0LCBjKSxcbiAgICAgIGR4ZHQgPSAxLjAgLyA2LjAgKiAoYS5keCArIDIuMCAqIChiLmR4ICsgYy5keCkgKyBkLmR4KSxcbiAgICAgIGR2ZHQgPSAxLjAgLyA2LjAgKiAoYS5kdiArIDIuMCAqIChiLmR2ICsgYy5kdikgKyBkLmR2KTtcbiAgICBzdGF0ZS54ID0gc3RhdGUueCArIGR4ZHQgKiBkdDtcbiAgICBzdGF0ZS52ID0gc3RhdGUudiArIGR2ZHQgKiBkdDtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG4gICAgdmFyIGluaXRTdGF0ZSA9IHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHY6IDAsXG4gICAgICAgIHRlbnNpb246IG51bGwsXG4gICAgICAgIGZyaWN0aW9uOiBudWxsXG4gICAgICB9LFxuICAgICAgcGF0aCA9IFswXSxcbiAgICAgIHRpbWVfbGFwc2VkID0gMCxcbiAgICAgIHRvbGVyYW5jZSA9IDEgLyAxMDAwMCxcbiAgICAgIERUID0gMTYgLyAxMDAwLFxuICAgICAgaGF2ZV9kdXJhdGlvbixcbiAgICAgIGR0LFxuICAgICAgbGFzdF9zdGF0ZTtcbiAgICB0ZW5zaW9uID0gcGFyc2VGbG9hdCh0ZW5zaW9uKSB8fCA1MDA7XG4gICAgZnJpY3Rpb24gPSBwYXJzZUZsb2F0KGZyaWN0aW9uKSB8fCAyMDtcbiAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IG51bGw7XG4gICAgaW5pdFN0YXRlLnRlbnNpb24gPSB0ZW5zaW9uO1xuICAgIGluaXRTdGF0ZS5mcmljdGlvbiA9IGZyaWN0aW9uO1xuICAgIGhhdmVfZHVyYXRpb24gPSBkdXJhdGlvbiAhPT0gbnVsbDtcblxuICAgIC8qIENhbGN1bGF0ZSB0aGUgYWN0dWFsIHRpbWUgaXQgdGFrZXMgZm9yIHRoaXMgYW5pbWF0aW9uIHRvIGNvbXBsZXRlIHdpdGggdGhlIHByb3ZpZGVkIGNvbmRpdGlvbnMuICovXG4gICAgaWYgKGhhdmVfZHVyYXRpb24pIHtcbiAgICAgIC8qIFJ1biB0aGUgc2ltdWxhdGlvbiB3aXRob3V0IGEgZHVyYXRpb24uICovXG4gICAgICB0aW1lX2xhcHNlZCA9IHNwcmluZ1JLNEZhY3RvcnkodGVuc2lvbiwgZnJpY3Rpb24pO1xuICAgICAgLyogQ29tcHV0ZSB0aGUgYWRqdXN0ZWQgdGltZSBkZWx0YS4gKi9cbiAgICAgIGR0ID0gdGltZV9sYXBzZWQgLyBkdXJhdGlvbiAqIERUO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdCA9IERUO1xuICAgIH1cbiAgICBmb3IgKDs7KSB7XG4gICAgICAvKiBOZXh0L3N0ZXAgZnVuY3Rpb24gLiovXG4gICAgICBsYXN0X3N0YXRlID0gc3ByaW5nSW50ZWdyYXRlU3RhdGUobGFzdF9zdGF0ZSB8fCBpbml0U3RhdGUsIGR0KTtcbiAgICAgIC8qIFN0b3JlIHRoZSBwb3NpdGlvbi4gKi9cbiAgICAgIHBhdGgucHVzaCgxICsgbGFzdF9zdGF0ZS54KTtcbiAgICAgIHRpbWVfbGFwc2VkICs9IDE2O1xuICAgICAgLyogSWYgdGhlIGNoYW5nZSB0aHJlc2hvbGQgaXMgcmVhY2hlZCwgYnJlYWsuICovXG4gICAgICBpZiAoIShNYXRoLmFicyhsYXN0X3N0YXRlLngpID4gdG9sZXJhbmNlICYmIE1hdGguYWJzKGxhc3Rfc3RhdGUudikgPiB0b2xlcmFuY2UpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIElmIGR1cmF0aW9uIGlzIG5vdCBkZWZpbmVkLCByZXR1cm4gdGhlIGFjdHVhbCB0aW1lIHJlcXVpcmVkIGZvciBjb21wbGV0aW5nIHRoaXMgYW5pbWF0aW9uLiBPdGhlcndpc2UsIHJldHVybiBhIGNsb3N1cmUgdGhhdCBob2xkcyB0aGVcbiAgICAgICBjb21wdXRlZCBwYXRoIGFuZCByZXR1cm5zIGEgc25hcHNob3Qgb2YgdGhlIHBvc2l0aW9uIGFjY29yZGluZyB0byBhIGdpdmVuIHBlcmNlbnRDb21wbGV0ZS4gKi9cbiAgICByZXR1cm4gIWhhdmVfZHVyYXRpb24gPyB0aW1lX2xhcHNlZCA6IGZ1bmN0aW9uIChwZXJjZW50Q29tcGxldGUpIHtcbiAgICAgIHJldHVybiBwYXRoW3BlcmNlbnRDb21wbGV0ZSAqIChwYXRoLmxlbmd0aCAtIDEpIHwgMF07XG4gICAgfTtcbiAgfTtcbn0oKTtcblxudmFyIGN1YmljQmV6aWVyID0gZnVuY3Rpb24gY3ViaWNCZXppZXIodDEsIHAxLCB0MiwgcDIpIHtcbiAgdmFyIGJlemllciA9IGdlbmVyYXRlQ3ViaWNCZXppZXIodDEsIHAxLCB0MiwgcDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogYmV6aWVyKHBlcmNlbnQpO1xuICB9O1xufTtcbnZhciBlYXNpbmdzID0ge1xuICAnbGluZWFyJzogZnVuY3Rpb24gbGluZWFyKHN0YXJ0LCBlbmQsIHBlcmNlbnQpIHtcbiAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogcGVyY2VudDtcbiAgfSxcbiAgLy8gZGVmYXVsdCBlYXNpbmdzXG4gICdlYXNlJzogY3ViaWNCZXppZXIoMC4yNSwgMC4xLCAwLjI1LCAxKSxcbiAgJ2Vhc2UtaW4nOiBjdWJpY0JlemllcigwLjQyLCAwLCAxLCAxKSxcbiAgJ2Vhc2Utb3V0JzogY3ViaWNCZXppZXIoMCwgMCwgMC41OCwgMSksXG4gICdlYXNlLWluLW91dCc6IGN1YmljQmV6aWVyKDAuNDIsIDAsIDAuNTgsIDEpLFxuICAvLyBzaW5lXG4gICdlYXNlLWluLXNpbmUnOiBjdWJpY0JlemllcigwLjQ3LCAwLCAwLjc0NSwgMC43MTUpLFxuICAnZWFzZS1vdXQtc2luZSc6IGN1YmljQmV6aWVyKDAuMzksIDAuNTc1LCAwLjU2NSwgMSksXG4gICdlYXNlLWluLW91dC1zaW5lJzogY3ViaWNCZXppZXIoMC40NDUsIDAuMDUsIDAuNTUsIDAuOTUpLFxuICAvLyBxdWFkXG4gICdlYXNlLWluLXF1YWQnOiBjdWJpY0JlemllcigwLjU1LCAwLjA4NSwgMC42OCwgMC41MyksXG4gICdlYXNlLW91dC1xdWFkJzogY3ViaWNCZXppZXIoMC4yNSwgMC40NiwgMC40NSwgMC45NCksXG4gICdlYXNlLWluLW91dC1xdWFkJzogY3ViaWNCZXppZXIoMC40NTUsIDAuMDMsIDAuNTE1LCAwLjk1NSksXG4gIC8vIGN1YmljXG4gICdlYXNlLWluLWN1YmljJzogY3ViaWNCZXppZXIoMC41NSwgMC4wNTUsIDAuNjc1LCAwLjE5KSxcbiAgJ2Vhc2Utb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC4yMTUsIDAuNjEsIDAuMzU1LCAxKSxcbiAgJ2Vhc2UtaW4tb3V0LWN1YmljJzogY3ViaWNCZXppZXIoMC42NDUsIDAuMDQ1LCAwLjM1NSwgMSksXG4gIC8vIHF1YXJ0XG4gICdlYXNlLWluLXF1YXJ0JzogY3ViaWNCZXppZXIoMC44OTUsIDAuMDMsIDAuNjg1LCAwLjIyKSxcbiAgJ2Vhc2Utb3V0LXF1YXJ0JzogY3ViaWNCZXppZXIoMC4xNjUsIDAuODQsIDAuNDQsIDEpLFxuICAnZWFzZS1pbi1vdXQtcXVhcnQnOiBjdWJpY0JlemllcigwLjc3LCAwLCAwLjE3NSwgMSksXG4gIC8vIHF1aW50XG4gICdlYXNlLWluLXF1aW50JzogY3ViaWNCZXppZXIoMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2KSxcbiAgJ2Vhc2Utb3V0LXF1aW50JzogY3ViaWNCZXppZXIoMC4yMywgMSwgMC4zMiwgMSksXG4gICdlYXNlLWluLW91dC1xdWludCc6IGN1YmljQmV6aWVyKDAuODYsIDAsIDAuMDcsIDEpLFxuICAvLyBleHBvXG4gICdlYXNlLWluLWV4cG8nOiBjdWJpY0JlemllcigwLjk1LCAwLjA1LCAwLjc5NSwgMC4wMzUpLFxuICAnZWFzZS1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDAuMTksIDEsIDAuMjIsIDEpLFxuICAnZWFzZS1pbi1vdXQtZXhwbyc6IGN1YmljQmV6aWVyKDEsIDAsIDAsIDEpLFxuICAvLyBjaXJjXG4gICdlYXNlLWluLWNpcmMnOiBjdWJpY0JlemllcigwLjYsIDAuMDQsIDAuOTgsIDAuMzM1KSxcbiAgJ2Vhc2Utb3V0LWNpcmMnOiBjdWJpY0JlemllcigwLjA3NSwgMC44MiwgMC4xNjUsIDEpLFxuICAnZWFzZS1pbi1vdXQtY2lyYyc6IGN1YmljQmV6aWVyKDAuNzg1LCAwLjEzNSwgMC4xNSwgMC44NiksXG4gIC8vIHVzZXIgcGFyYW0gZWFzaW5ncy4uLlxuXG4gICdzcHJpbmcnOiBmdW5jdGlvbiBzcHJpbmcodGVuc2lvbiwgZnJpY3Rpb24sIGR1cmF0aW9uKSB7XG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAvLyBjYW4ndCBnZXQgYSBzcHJpbmcgdy8gZHVyYXRpb24gMFxuICAgICAgcmV0dXJuIGVhc2luZ3MubGluZWFyOyAvLyBkdXJhdGlvbiAwID0+IGp1bXAgdG8gZW5kIHNvIGltcGwgZG9lc24ndCBtYXR0ZXJcbiAgICB9XG4gICAgdmFyIHNwcmluZyA9IGdlbmVyYXRlU3ByaW5nUks0KHRlbnNpb24sIGZyaWN0aW9uLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGFydCwgZW5kLCBwZXJjZW50KSB7XG4gICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogc3ByaW5nKHBlcmNlbnQpO1xuICAgIH07XG4gIH0sXG4gICdjdWJpYy1iZXppZXInOiBjdWJpY0JlemllclxufTtcblxuZnVuY3Rpb24gZ2V0RWFzZWRWYWx1ZSh0eXBlLCBzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmdGbikge1xuICBpZiAocGVyY2VudCA9PT0gMSkge1xuICAgIHJldHVybiBlbmQ7XG4gIH1cbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICByZXR1cm4gZW5kO1xuICB9XG4gIHZhciB2YWwgPSBlYXNpbmdGbihzdGFydCwgZW5kLCBwZXJjZW50KTtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGUucm91bmRWYWx1ZSB8fCB0eXBlLmNvbG9yKSB7XG4gICAgdmFsID0gTWF0aC5yb3VuZCh2YWwpO1xuICB9XG4gIGlmICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gTWF0aC5tYXgodmFsLCB0eXBlLm1pbik7XG4gIH1cbiAgaWYgKHR5cGUubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBNYXRoLm1pbih2YWwsIHR5cGUubWF4KTtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUocHJvcCwgc3BlYykge1xuICBpZiAocHJvcC5wZlZhbHVlICE9IG51bGwgfHwgcHJvcC52YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsICYmIChzcGVjID09IG51bGwgfHwgc3BlYy50eXBlLnVuaXRzICE9PSAnJScpKSB7XG4gICAgICByZXR1cm4gcHJvcC5wZlZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcHJvcC52YWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByb3A7XG4gIH1cbn1cbmZ1bmN0aW9uIGVhc2Uoc3RhcnRQcm9wLCBlbmRQcm9wLCBwZXJjZW50LCBlYXNpbmdGbiwgcHJvcFNwZWMpIHtcbiAgdmFyIHR5cGUgPSBwcm9wU3BlYyAhPSBudWxsID8gcHJvcFNwZWMudHlwZSA6IG51bGw7XG4gIGlmIChwZXJjZW50IDwgMCkge1xuICAgIHBlcmNlbnQgPSAwO1xuICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH1cbiAgdmFyIHN0YXJ0ID0gZ2V0VmFsdWUoc3RhcnRQcm9wLCBwcm9wU3BlYyk7XG4gIHZhciBlbmQgPSBnZXRWYWx1ZShlbmRQcm9wLCBwcm9wU3BlYyk7XG4gIGlmIChudW1iZXIkMShzdGFydCkgJiYgbnVtYmVyJDEoZW5kKSkge1xuICAgIHJldHVybiBnZXRFYXNlZFZhbHVlKHR5cGUsIHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGVhc2luZ0ZuKTtcbiAgfSBlbHNlIGlmIChhcnJheShzdGFydCkgJiYgYXJyYXkoZW5kKSkge1xuICAgIHZhciBlYXNlZEFyciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2kgPSBzdGFydFtpXTtcbiAgICAgIHZhciBlaSA9IGVuZFtpXTtcbiAgICAgIGlmIChzaSAhPSBudWxsICYmIGVpICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHZhbCA9IGdldEVhc2VkVmFsdWUodHlwZSwgc2ksIGVpLCBwZXJjZW50LCBlYXNpbmdGbik7XG4gICAgICAgIGVhc2VkQXJyLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhc2VkQXJyLnB1c2goZWkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWFzZWRBcnI7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc3RlcCQxKHNlbGYsIGFuaSwgbm93LCBpc0NvcmUpIHtcbiAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgdmFyIHBFYXNpbmcgPSBhbmlfcC5lYXNpbmc7XG4gIHZhciBzdGFydFRpbWUgPSBhbmlfcC5zdGFydFRpbWU7XG4gIHZhciBjeSA9IGlzQ29yZSA/IHNlbGYgOiBzZWxmLmN5KCk7XG4gIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gIGlmICghYW5pX3AuZWFzaW5nSW1wbCkge1xuICAgIGlmIChwRWFzaW5nID09IG51bGwpIHtcbiAgICAgIC8vIHVzZSBkZWZhdWx0XG4gICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1snbGluZWFyJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZW4gZGVmaW5lIHcvIG5hbWVcbiAgICAgIHZhciBlYXNpbmdWYWxzO1xuICAgICAgaWYgKHN0cmluZyhwRWFzaW5nKSkge1xuICAgICAgICB2YXIgZWFzaW5nUHJvcCA9IHN0eWxlLnBhcnNlKCd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsIHBFYXNpbmcpO1xuICAgICAgICBlYXNpbmdWYWxzID0gZWFzaW5nUHJvcC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZW4gYXNzdW1lIHByZXBhcnNlZCBhcnJheVxuICAgICAgICBlYXNpbmdWYWxzID0gcEVhc2luZztcbiAgICAgIH1cbiAgICAgIHZhciBuYW1lLCBhcmdzO1xuICAgICAgaWYgKHN0cmluZyhlYXNpbmdWYWxzKSkge1xuICAgICAgICBuYW1lID0gZWFzaW5nVmFscztcbiAgICAgICAgYXJncyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IGVhc2luZ1ZhbHNbMV07XG4gICAgICAgIGFyZ3MgPSBlYXNpbmdWYWxzLnNsaWNlKDIpLm1hcChmdW5jdGlvbiAobikge1xuICAgICAgICAgIHJldHVybiArbjtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGNyZWF0ZSB3aXRoIGFyZ3NcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzcHJpbmcnKSB7XG4gICAgICAgICAgYXJncy5wdXNoKGFuaV9wLmR1cmF0aW9uKTsgLy8gbmVlZCBkdXJhdGlvbiB0byBnZW5lcmF0ZSBzcHJpbmdcbiAgICAgICAgfVxuICAgICAgICBhbmlfcC5lYXNpbmdJbXBsID0gZWFzaW5nc1tuYW1lXS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0YXRpYyBpbXBsIGJ5IG5hbWVcbiAgICAgICAgYW5pX3AuZWFzaW5nSW1wbCA9IGVhc2luZ3NbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBlYXNpbmcgPSBhbmlfcC5lYXNpbmdJbXBsO1xuICB2YXIgcGVyY2VudDtcbiAgaWYgKGFuaV9wLmR1cmF0aW9uID09PSAwKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcGVyY2VudCA9IChub3cgLSBzdGFydFRpbWUpIC8gYW5pX3AuZHVyYXRpb247XG4gIH1cbiAgaWYgKGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgcGVyY2VudCA9IGFuaV9wLnByb2dyZXNzO1xuICB9XG4gIGlmIChwZXJjZW50IDwgMCkge1xuICAgIHBlcmNlbnQgPSAwO1xuICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgcGVyY2VudCA9IDE7XG4gIH1cbiAgaWYgKGFuaV9wLmRlbGF5ID09IG51bGwpIHtcbiAgICAvLyB0aGVuIHVwZGF0ZVxuXG4gICAgdmFyIHN0YXJ0UG9zID0gYW5pX3Auc3RhcnRQb3NpdGlvbjtcbiAgICB2YXIgZW5kUG9zID0gYW5pX3AucG9zaXRpb247XG4gICAgaWYgKGVuZFBvcyAmJiBpc0VsZXMgJiYgIXNlbGYubG9ja2VkKCkpIHtcbiAgICAgIHZhciBuZXdQb3MgPSB7fTtcbiAgICAgIGlmICh2YWxpZChzdGFydFBvcy54LCBlbmRQb3MueCkpIHtcbiAgICAgICAgbmV3UG9zLnggPSBlYXNlKHN0YXJ0UG9zLngsIGVuZFBvcy54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkKHN0YXJ0UG9zLnksIGVuZFBvcy55KSkge1xuICAgICAgICBuZXdQb3MueSA9IGVhc2Uoc3RhcnRQb3MueSwgZW5kUG9zLnksIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG4gICAgICBzZWxmLnBvc2l0aW9uKG5ld1Bvcyk7XG4gICAgfVxuICAgIHZhciBzdGFydFBhbiA9IGFuaV9wLnN0YXJ0UGFuO1xuICAgIHZhciBlbmRQYW4gPSBhbmlfcC5wYW47XG4gICAgdmFyIHBhbiA9IF9wLnBhbjtcbiAgICB2YXIgYW5pbWF0aW5nUGFuID0gZW5kUGFuICE9IG51bGwgJiYgaXNDb3JlO1xuICAgIGlmIChhbmltYXRpbmdQYW4pIHtcbiAgICAgIGlmICh2YWxpZChzdGFydFBhbi54LCBlbmRQYW4ueCkpIHtcbiAgICAgICAgcGFuLnggPSBlYXNlKHN0YXJ0UGFuLngsIGVuZFBhbi54LCBwZXJjZW50LCBlYXNpbmcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbGlkKHN0YXJ0UGFuLnksIGVuZFBhbi55KSkge1xuICAgICAgICBwYW4ueSA9IGVhc2Uoc3RhcnRQYW4ueSwgZW5kUGFuLnksIHBlcmNlbnQsIGVhc2luZyk7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoJ3BhbicpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRab29tID0gYW5pX3Auc3RhcnRab29tO1xuICAgIHZhciBlbmRab29tID0gYW5pX3Auem9vbTtcbiAgICB2YXIgYW5pbWF0aW5nWm9vbSA9IGVuZFpvb20gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgaWYgKGFuaW1hdGluZ1pvb20pIHtcbiAgICAgIGlmICh2YWxpZChzdGFydFpvb20sIGVuZFpvb20pKSB7XG4gICAgICAgIF9wLnpvb20gPSBib3VuZChfcC5taW5ab29tLCBlYXNlKHN0YXJ0Wm9vbSwgZW5kWm9vbSwgcGVyY2VudCwgZWFzaW5nKSwgX3AubWF4Wm9vbSk7XG4gICAgICB9XG4gICAgICBzZWxmLmVtaXQoJ3pvb20nKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tKSB7XG4gICAgICBzZWxmLmVtaXQoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuICAgIHZhciBwcm9wcyA9IGFuaV9wLnN0eWxlO1xuICAgIGlmIChwcm9wcyAmJiBwcm9wcy5sZW5ndGggPiAwICYmIGlzRWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgX25hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciBlbmQgPSBwcm9wO1xuICAgICAgICB2YXIgc3RhcnQgPSBhbmlfcC5zdGFydFN0eWxlW19uYW1lXTtcbiAgICAgICAgdmFyIHByb3BTcGVjID0gc3R5bGUucHJvcGVydGllc1tzdGFydC5uYW1lXTtcbiAgICAgICAgdmFyIGVhc2VkVmFsID0gZWFzZShzdGFydCwgZW5kLCBwZXJjZW50LCBlYXNpbmcsIHByb3BTcGVjKTtcbiAgICAgICAgc3R5bGUub3ZlcnJpZGVCeXBhc3Moc2VsZiwgX25hbWUsIGVhc2VkVmFsKTtcbiAgICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICAgIHNlbGYuZW1pdCgnc3R5bGUnKTtcbiAgICB9IC8vIGlmXG4gIH1cbiAgYW5pX3AucHJvZ3Jlc3MgPSBwZXJjZW50O1xuICByZXR1cm4gcGVyY2VudDtcbn1cbmZ1bmN0aW9uIHZhbGlkKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG51bWJlciQxKHN0YXJ0KSAmJiBudW1iZXIkMShlbmQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdGFydEFuaW1hdGlvbihzZWxmLCBhbmksIG5vdywgaXNDb3JlKSB7XG4gIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgYW5pX3Auc3RhcnRlZCA9IHRydWU7XG4gIGFuaV9wLnN0YXJ0VGltZSA9IG5vdyAtIGFuaV9wLnByb2dyZXNzICogYW5pX3AuZHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIHN0ZXBBbGwobm93LCBjeSkge1xuICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmFuaUVsZXM7XG4gIHZhciBkb25lRWxlcyA9IFtdO1xuICBmdW5jdGlvbiBzdGVwT25lKGVsZSwgaXNDb3JlKSB7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBjdXJyZW50ID0gX3AuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgdmFyIHF1ZXVlID0gX3AuYW5pbWF0aW9uLnF1ZXVlO1xuICAgIHZhciByYW5BbmlzID0gZmFsc2U7XG5cbiAgICAvLyBpZiBub3RoaW5nIGN1cnJlbnRseSBhbmltYXRpbmcsIGdldCBzb21ldGhpbmcgZnJvbSB0aGUgcXVldWVcbiAgICBpZiAoY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBuZXh0ID0gcXVldWUuc2hpZnQoKTtcbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNhbGxiYWNrcyA9IGZ1bmN0aW9uIGNhbGxiYWNrcyhfY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gX2NhbGxiYWNrcy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgY2IgPSBfY2FsbGJhY2tzW2pdO1xuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgICAgX2NhbGxiYWNrcy5zcGxpY2UoMCwgX2NhbGxiYWNrcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICAvLyBzdGVwIGFuZCByZW1vdmUgaWYgZG9uZVxuICAgIGZvciAodmFyIGkgPSBjdXJyZW50Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYW5pID0gY3VycmVudFtpXTtcbiAgICAgIHZhciBhbmlfcCA9IGFuaS5fcHJpdmF0ZTtcbiAgICAgIGlmIChhbmlfcC5zdG9wcGVkKSB7XG4gICAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xuICAgICAgICBhbmlfcC5ob29rZWQgPSBmYWxzZTtcbiAgICAgICAgYW5pX3AucGxheWluZyA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNhbGxiYWNrcyhhbmlfcC5mcmFtZXMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYW5pX3AucGxheWluZyAmJiAhYW5pX3AuYXBwbHlpbmcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFuIGFwcGx5KCkgd2hpbGUgcGxheWluZyBzaG91bGRuJ3QgZG8gYW55dGhpbmdcbiAgICAgIGlmIChhbmlfcC5wbGF5aW5nICYmIGFuaV9wLmFwcGx5aW5nKSB7XG4gICAgICAgIGFuaV9wLmFwcGx5aW5nID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIWFuaV9wLnN0YXJ0ZWQpIHtcbiAgICAgICAgc3RhcnRBbmltYXRpb24oZWxlLCBhbmksIG5vdyk7XG4gICAgICB9XG4gICAgICBzdGVwJDEoZWxlLCBhbmksIG5vdywgaXNDb3JlKTtcbiAgICAgIGlmIChhbmlfcC5hcHBseWluZykge1xuICAgICAgICBhbmlfcC5hcHBseWluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzKGFuaV9wLmZyYW1lcyk7XG4gICAgICBpZiAoYW5pX3Auc3RlcCAhPSBudWxsKSB7XG4gICAgICAgIGFuaV9wLnN0ZXAobm93KTtcbiAgICAgIH1cbiAgICAgIGlmIChhbmkuY29tcGxldGVkKCkpIHtcbiAgICAgICAgY3VycmVudC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGFuaV9wLmhvb2tlZCA9IGZhbHNlO1xuICAgICAgICBhbmlfcC5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIGFuaV9wLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2tzKGFuaV9wLmNvbXBsZXRlcyk7XG4gICAgICB9XG4gICAgICByYW5BbmlzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFpc0NvcmUgJiYgY3VycmVudC5sZW5ndGggPT09IDAgJiYgcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBkb25lRWxlcy5wdXNoKGVsZSk7XG4gICAgfVxuICAgIHJldHVybiByYW5BbmlzO1xuICB9IC8vIHN0ZXBFbGVtZW50XG5cbiAgLy8gaGFuZGxlIGFsbCBlbGVzXG4gIHZhciByYW5FbGVBbmkgPSBmYWxzZTtcbiAgZm9yICh2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbZV07XG4gICAgdmFyIGhhbmRsZWRUaGlzRWxlID0gc3RlcE9uZShlbGUpO1xuICAgIHJhbkVsZUFuaSA9IHJhbkVsZUFuaSB8fCBoYW5kbGVkVGhpc0VsZTtcbiAgfSAvLyBlYWNoIGVsZW1lbnRcblxuICB2YXIgcmFuQ29yZUFuaSA9IHN0ZXBPbmUoY3ksIHRydWUpO1xuXG4gIC8vIG5vdGlmeSByZW5kZXJlclxuICBpZiAocmFuRWxlQW5pIHx8IHJhbkNvcmVBbmkpIHtcbiAgICBpZiAoZWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjeS5ub3RpZnkoJ2RyYXcnLCBlbGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3kubm90aWZ5KCdkcmF3Jyk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gbGlzdCBvZiBjdXJyZW50bHkgYW5pbWF0aW5nIGlmIGl0cyBxdWV1ZXMgYXJlIGVtcHR5XG4gIGVsZXMudW5tZXJnZShkb25lRWxlcyk7XG4gIGN5LmVtaXQoJ3N0ZXAnKTtcbn0gLy8gc3RlcEFsbFxuXG52YXIgY29yZWZuJDggPSB7XG4gIC8vIHB1bGwgaW4gYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICBhbmltYXRlOiBkZWZpbmUuYW5pbWF0ZSgpLFxuICBhbmltYXRpb246IGRlZmluZS5hbmltYXRpb24oKSxcbiAgYW5pbWF0ZWQ6IGRlZmluZS5hbmltYXRlZCgpLFxuICBjbGVhclF1ZXVlOiBkZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICBkZWxheTogZGVmaW5lLmRlbGF5KCksXG4gIGRlbGF5QW5pbWF0aW9uOiBkZWZpbmUuZGVsYXlBbmltYXRpb24oKSxcbiAgc3RvcDogZGVmaW5lLnN0b3AoKSxcbiAgYWRkVG9BbmltYXRpb25Qb29sOiBmdW5jdGlvbiBhZGRUb0FuaW1hdGlvblBvb2woZWxlcykge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgaWYgKCFjeS5zdHlsZUVuYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2F2ZSBjeWNsZXMgd2hlbiBubyBzdHlsZSB1c2VkXG5cbiAgICBjeS5fcHJpdmF0ZS5hbmlFbGVzLm1lcmdlKGVsZXMpO1xuICB9LFxuICBzdG9wQW5pbWF0aW9uTG9vcDogZnVuY3Rpb24gc3RvcEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5hbmltYXRpb25zUnVubmluZyA9IGZhbHNlO1xuICB9LFxuICBzdGFydEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uTG9vcCgpIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIGN5Ll9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nID0gdHJ1ZTtcbiAgICBpZiAoIWN5LnN0eWxlRW5hYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgIC8vIE5CIHRoZSBhbmltYXRpb24gbG9vcCB3aWxsIGV4ZWMgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzIGlmIHN0eWxlIGVuYWJsZWRcbiAgICAvLyBhbmQgZXhwbGljaXQgY3kuZGVzdHJveSgpIGlzIG5lY2Vzc2FyeSB0byBzdG9wIHRoZSBsb29wXG5cbiAgICBmdW5jdGlvbiBoZWFkbGVzc1N0ZXAoKSB7XG4gICAgICBpZiAoIWN5Ll9wcml2YXRlLmFuaW1hdGlvbnNSdW5uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBhbmltYXRpb25TdGVwKG5vdykge1xuICAgICAgICBzdGVwQWxsKG5vdywgY3kpO1xuICAgICAgICBoZWFkbGVzc1N0ZXAoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcmVuZGVyZXIgPSBjeS5yZW5kZXJlcigpO1xuICAgIGlmIChyZW5kZXJlciAmJiByZW5kZXJlci5iZWZvcmVSZW5kZXIpIHtcbiAgICAgIC8vIGxldCB0aGUgcmVuZGVyZXIgc2NoZWR1bGUgYW5pbWF0aW9uc1xuICAgICAgcmVuZGVyZXIuYmVmb3JlUmVuZGVyKGZ1bmN0aW9uIHJlbmRlcmVyQW5pbWF0aW9uU3RlcCh3aWxsRHJhdywgbm93KSB7XG4gICAgICAgIHN0ZXBBbGwobm93LCBjeSk7XG4gICAgICB9LCByZW5kZXJlci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmFuaW1hdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtYW5hZ2UgdGhlIGFuaW1hdGlvbiBsb29wIG91cnNlbHZlc1xuICAgICAgaGVhZGxlc3NTdGVwKCk7IC8vIGZpcnN0IGNhbGxcbiAgICB9XG4gIH1cbn07XG5cbnZhciBlbWl0dGVyT3B0aW9ucyA9IHtcbiAgcXVhbGlmaWVyQ29tcGFyZTogZnVuY3Rpb24gcXVhbGlmaWVyQ29tcGFyZShzZWxlY3RvcjEsIHNlbGVjdG9yMikge1xuICAgIGlmIChzZWxlY3RvcjEgPT0gbnVsbCB8fCBzZWxlY3RvcjIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlbGVjdG9yMSA9PSBudWxsICYmIHNlbGVjdG9yMiA9PSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3IxLnNhbWVUZXh0KHNlbGVjdG9yMik7XG4gICAgfVxuICB9LFxuICBldmVudE1hdGNoZXM6IGZ1bmN0aW9uIGV2ZW50TWF0Y2hlcyhjeSwgbGlzdGVuZXIsIGV2ZW50T2JqKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gbGlzdGVuZXIucXVhbGlmaWVyO1xuICAgIGlmIChzZWxlY3RvciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gY3kgIT09IGV2ZW50T2JqLnRhcmdldCAmJiBlbGVtZW50KGV2ZW50T2JqLnRhcmdldCkgJiYgc2VsZWN0b3IubWF0Y2hlcyhldmVudE9iai50YXJnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgYWRkRXZlbnRGaWVsZHM6IGZ1bmN0aW9uIGFkZEV2ZW50RmllbGRzKGN5LCBldnQpIHtcbiAgICBldnQuY3kgPSBjeTtcbiAgICBldnQudGFyZ2V0ID0gY3k7XG4gIH0sXG4gIGNhbGxiYWNrQ29udGV4dDogZnVuY3Rpb24gY2FsbGJhY2tDb250ZXh0KGN5LCBsaXN0ZW5lciwgZXZlbnRPYmopIHtcbiAgICByZXR1cm4gbGlzdGVuZXIucXVhbGlmaWVyICE9IG51bGwgPyBldmVudE9iai50YXJnZXQgOiBjeTtcbiAgfVxufTtcbnZhciBhcmdTZWxlY3RvciA9IGZ1bmN0aW9uIGFyZ1NlbGVjdG9yKGFyZykge1xuICBpZiAoc3RyaW5nKGFyZykpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdG9yKGFyZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfVxufTtcbnZhciBlbGVzZm4gPSB7XG4gIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoIV9wLmVtaXR0ZXIpIHtcbiAgICAgIF9wLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcihlbWl0dGVyT3B0aW9ucywgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbWl0dGVyOiBmdW5jdGlvbiBlbWl0dGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVtaXR0ZXI7XG4gIH0sXG4gIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLm9uKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvbmU6IGZ1bmN0aW9uIG9uZShldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlcigpLm9uZShldmVudHMsIGFyZ1NlbGVjdG9yKHNlbGVjdG9yKSwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBvbmNlOiBmdW5jdGlvbiBvbmNlKGV2ZW50cywgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5lbWl0dGVyKCkub25lKGV2ZW50cywgYXJnU2VsZWN0b3Ioc2VsZWN0b3IpLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcykge1xuICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoZXZlbnRzLCBleHRyYVBhcmFtcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtaXRBbmROb3RpZnk6IGZ1bmN0aW9uIGVtaXRBbmROb3RpZnkoZXZlbnQsIGVsZXMpIHtcbiAgICB0aGlzLmVtaXQoZXZlbnQpO1xuICAgIHRoaXMubm90aWZ5KGV2ZW50LCBlbGVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbmRlZmluZS5ldmVudEFsaWFzZXNPbihlbGVzZm4pO1xuXG52YXIgY29yZWZuJDcgPSB7XG4gIHBuZzogZnVuY3Rpb24gcG5nKG9wdGlvbnMpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiByZW5kZXJlci5wbmcob3B0aW9ucyk7XG4gIH0sXG4gIGpwZzogZnVuY3Rpb24ganBnKG9wdGlvbnMpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMuYmcgPSBvcHRpb25zLmJnIHx8ICcjZmZmJztcbiAgICByZXR1cm4gcmVuZGVyZXIuanBnKG9wdGlvbnMpO1xuICB9XG59O1xuY29yZWZuJDcuanBlZyA9IGNvcmVmbiQ3LmpwZztcblxudmFyIGNvcmVmbiQ2ID0ge1xuICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dChvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBlcnJvcignTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5uYW1lID09IG51bGwpIHtcbiAgICAgIGVycm9yKCdBIGBuYW1lYCBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHZhciBMYXlvdXQgPSBjeS5leHRlbnNpb24oJ2xheW91dCcsIG5hbWUpO1xuICAgIGlmIChMYXlvdXQgPT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ05vIHN1Y2ggbGF5b3V0IGAnICsgbmFtZSArICdgIGZvdW5kLiAgRGlkIHlvdSBmb3JnZXQgdG8gaW1wb3J0IGl0IGFuZCBgY3l0b3NjYXBlLnVzZSgpYCBpdD8nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVsZXM7XG4gICAgaWYgKHN0cmluZyhvcHRpb25zLmVsZXMpKSB7XG4gICAgICBlbGVzID0gY3kuJChvcHRpb25zLmVsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzID0gb3B0aW9ucy5lbGVzICE9IG51bGwgPyBvcHRpb25zLmVsZXMgOiBjeS4kKCk7XG4gICAgfVxuICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgY3k6IGN5LFxuICAgICAgZWxlczogZWxlc1xuICAgIH0pKTtcbiAgICByZXR1cm4gbGF5b3V0O1xuICB9XG59O1xuY29yZWZuJDYuY3JlYXRlTGF5b3V0ID0gY29yZWZuJDYubWFrZUxheW91dCA9IGNvcmVmbiQ2LmxheW91dDtcblxudmFyIGNvcmVmbiQ1ID0ge1xuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeShldmVudE5hbWUsIGV2ZW50RWxlcykge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKHRoaXMuYmF0Y2hpbmcoKSkge1xuICAgICAgX3AuYmF0Y2hOb3RpZmljYXRpb25zID0gX3AuYmF0Y2hOb3RpZmljYXRpb25zIHx8IHt9O1xuICAgICAgdmFyIGVsZXMgPSBfcC5iYXRjaE5vdGlmaWNhdGlvbnNbZXZlbnROYW1lXSA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdIHx8IHRoaXMuY29sbGVjdGlvbigpO1xuICAgICAgaWYgKGV2ZW50RWxlcyAhPSBudWxsKSB7XG4gICAgICAgIGVsZXMubWVyZ2UoZXZlbnRFbGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgfVxuICAgIGlmICghX3Aubm90aWZpY2F0aW9uc0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGV4aXQgb24gZGlzYWJsZWRcblxuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKTtcblxuICAgIC8vIGV4aXQgaWYgZGVzdHJveSgpIGNhbGxlZCBvbiBjb3JlIG9yIHJlbmRlcmVyIGluIGJldHdlZW4gZnJhbWVzICMxNDk5ICMxNTI4XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKCkgfHwgIXJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlbmRlcmVyLm5vdGlmeShldmVudE5hbWUsIGV2ZW50RWxlcyk7XG4gIH0sXG4gIG5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIG5vdGlmaWNhdGlvbnMoYm9vbCkge1xuICAgIHZhciBwID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAoYm9vbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcC5ub3RpZmljYXRpb25zRW5hYmxlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5ub3RpZmljYXRpb25zRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBub05vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uIG5vTm90aWZpY2F0aW9ucyhjYWxsYmFjaykge1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyhmYWxzZSk7XG4gICAgY2FsbGJhY2soKTtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gIH0sXG4gIGJhdGNoaW5nOiBmdW5jdGlvbiBiYXRjaGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5iYXRjaENvdW50ID4gMDtcbiAgfSxcbiAgc3RhcnRCYXRjaDogZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmIChfcC5iYXRjaENvdW50ID09IG51bGwpIHtcbiAgICAgIF9wLmJhdGNoQ291bnQgPSAwO1xuICAgIH1cbiAgICBpZiAoX3AuYmF0Y2hDb3VudCA9PT0gMCkge1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMgPSB0aGlzLmNvbGxlY3Rpb24oKTtcbiAgICAgIF9wLmJhdGNoTm90aWZpY2F0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBfcC5iYXRjaENvdW50Kys7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVuZEJhdGNoOiBmdW5jdGlvbiBlbmRCYXRjaCgpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIGlmIChfcC5iYXRjaENvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgX3AuYmF0Y2hDb3VudC0tO1xuICAgIGlmIChfcC5iYXRjaENvdW50ID09PSAwKSB7XG4gICAgICAvLyB1cGRhdGUgc3R5bGUgZm9yIGRpcnR5IGVsZXNcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzLnVwZGF0ZVN0eWxlKCk7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7XG5cbiAgICAgIC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgcXVldWVkIGVsZXMgYW5kIGV2ZW50IHR5cGVzXG4gICAgICBPYmplY3Qua2V5cyhfcC5iYXRjaE5vdGlmaWNhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICB2YXIgZWxlcyA9IF9wLmJhdGNoTm90aWZpY2F0aW9uc1tldmVudE5hbWVdO1xuICAgICAgICBpZiAoZWxlcy5lbXB0eSgpKSB7XG4gICAgICAgICAgcmVuZGVyZXIubm90aWZ5KGV2ZW50TmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyZXIubm90aWZ5KGV2ZW50TmFtZSwgZWxlcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYmF0Y2g6IGZ1bmN0aW9uIGJhdGNoKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gICAgY2FsbGJhY2soKTtcbiAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICBiYXRjaERhdGE6IGZ1bmN0aW9uIGJhdGNoRGF0YShtYXApIHtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzLmJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZHMgPSBPYmplY3Qua2V5cyhtYXApO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gaWRzW2ldO1xuICAgICAgICB2YXIgZGF0YSA9IG1hcFtpZF07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIGVsZS5kYXRhKGRhdGEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgcmVuZGVyZXJEZWZhdWx0cyA9IGRlZmF1bHRzJGcoe1xuICBoaWRlRWRnZXNPblZpZXdwb3J0OiBmYWxzZSxcbiAgdGV4dHVyZU9uVmlld3BvcnQ6IGZhbHNlLFxuICBtb3Rpb25CbHVyOiBmYWxzZSxcbiAgbW90aW9uQmx1ck9wYWNpdHk6IDAuMDUsXG4gIHBpeGVsUmF0aW86IHVuZGVmaW5lZCxcbiAgZGVza3RvcFRhcFRocmVzaG9sZDogNCxcbiAgdG91Y2hUYXBUaHJlc2hvbGQ6IDgsXG4gIHdoZWVsU2Vuc2l0aXZpdHk6IDEsXG4gIGRlYnVnOiBmYWxzZSxcbiAgc2hvd0ZwczogZmFsc2UsXG4gIC8vIHdlYmdsIG9wdGlvbnNcbiAgd2ViZ2w6IGZhbHNlLFxuICB3ZWJnbERlYnVnOiBmYWxzZSxcbiAgd2ViZ2xEZWJ1Z1Nob3dBdGxhc2VzOiBmYWxzZSxcbiAgLy8gZGVmYXVsdHMgZ29vZCBmb3IgbW9iaWxlXG4gIHdlYmdsVGV4U2l6ZTogMjA0OCxcbiAgd2ViZ2xUZXhSb3dzOiAzNixcbiAgd2ViZ2xUZXhSb3dzTm9kZXM6IDE4LFxuICB3ZWJnbEJhdGNoU2l6ZTogMjA0OCxcbiAgd2ViZ2xUZXhQZXJCYXRjaDogMTQsXG4gIHdlYmdsQmdDb2xvcjogWzI1NSwgMjU1LCAyNTVdXG59KTtcbnZhciBjb3JlZm4kNCA9IHtcbiAgcmVuZGVyVG86IGZ1bmN0aW9uIHJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbykge1xuICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICByLnJlbmRlclRvKGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbmRlcmVyOiBmdW5jdGlvbiByZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgfSxcbiAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uIGZvcmNlUmVuZGVyKCkge1xuICAgIHRoaXMubm90aWZ5KCdkcmF3Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgIHRoaXMuaW52YWxpZGF0ZVNpemUoKTtcbiAgICB0aGlzLmVtaXRBbmROb3RpZnkoJ3Jlc2l6ZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uIGluaXRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICB2YXIgUmVuZGVyZXJQcm90byA9IGN5LmV4dGVuc2lvbigncmVuZGVyZXInLCBvcHRpb25zLm5hbWUpO1xuICAgIGlmIChSZW5kZXJlclByb3RvID09IG51bGwpIHtcbiAgICAgIGVycm9yKFwiQ2FuIG5vdCBpbml0aWFsaXNlOiBObyBzdWNoIHJlbmRlcmVyIGBcIi5jb25jYXQob3B0aW9ucy5uYW1lLCBcImAgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGltcG9ydCBpdCBhbmQgYGN5dG9zY2FwZS51c2UoKWAgaXQ/XCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB3YXJuKFwiWW91IGhhdmUgc2V0IGEgY3VzdG9tIHdoZWVsIHNlbnNpdGl2aXR5LiAgVGhpcyB3aWxsIG1ha2UgeW91ciBhcHAgem9vbSB1bm5hdHVyYWxseSB3aGVuIHVzaW5nIG1haW5zdHJlYW0gbWljZS4gIFlvdSBzaG91bGQgY2hhbmdlIHRoaXMgdmFsdWUgZnJvbSB0aGUgZGVmYXVsdCBvbmx5IGlmIHlvdSBjYW4gZ3VhcmFudGVlIHRoYXQgYWxsIHlvdXIgdXNlcnMgd2lsbCB1c2UgdGhlIHNhbWUgaGFyZHdhcmUgYW5kIE9TIGNvbmZpZ3VyYXRpb24gYXMgeW91ciBjdXJyZW50IG1hY2hpbmUuXCIpO1xuICAgIH1cbiAgICB2YXIgck9wdHMgPSByZW5kZXJlckRlZmF1bHRzKG9wdGlvbnMpO1xuICAgIHJPcHRzLmN5ID0gY3k7XG4gICAgY3kuX3ByaXZhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJQcm90byhyT3B0cyk7XG4gICAgdGhpcy5ub3RpZnkoJ2luaXQnKTtcbiAgfSxcbiAgZGVzdHJveVJlbmRlcmVyOiBmdW5jdGlvbiBkZXN0cm95UmVuZGVyZXIoKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBjeS5ub3RpZnkoJ2Rlc3Ryb3knKTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgIHZhciBkb21FbGUgPSBjeS5jb250YWluZXIoKTtcbiAgICBpZiAoZG9tRWxlKSB7XG4gICAgICBkb21FbGUuX2N5cmVnID0gbnVsbDtcbiAgICAgIHdoaWxlIChkb21FbGUuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvbUVsZS5yZW1vdmVDaGlsZChkb21FbGUuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGN5Ll9wcml2YXRlLnJlbmRlcmVyID0gbnVsbDsgLy8gdG8gYmUgZXh0cmEgc2FmZSwgcmVtb3ZlIHRoZSByZWZcbiAgICBjeS5tdXRhYmxlRWxlbWVudHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIF9wLnJzY3JhdGNoID0ge307XG4gICAgICBfcC5yc3R5bGUgPSB7fTtcbiAgICAgIF9wLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICBfcC5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICB9KTtcbiAgfSxcbiAgb25SZW5kZXI6IGZ1bmN0aW9uIG9uUmVuZGVyKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMub24oJ3JlbmRlcicsIGZuKTtcbiAgfSxcbiAgb2ZmUmVuZGVyOiBmdW5jdGlvbiBvZmZSZW5kZXIoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5vZmYoJ3JlbmRlcicsIGZuKTtcbiAgfVxufTtcbmNvcmVmbiQ0LmludmFsaWRhdGVEaW1lbnNpb25zID0gY29yZWZuJDQucmVzaXplO1xuXG52YXIgY29yZWZuJDMgPSB7XG4gIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgLy8gLSBlbXB0eSBjb2xsZWN0aW9uIG9uIG5vIGFyZ3NcbiAgLy8gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGluIHRoZSBncmFwaCBvbiBzZWxlY3RvciBhcmdcbiAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgY29sbGVjdGlvbjogZnVuY3Rpb24gY29sbGVjdGlvbihlbGVzLCBvcHRzKSB7XG4gICAgaWYgKHN0cmluZyhlbGVzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuJChlbGVzKTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRPckNvbGxlY3Rpb24oZWxlcykpIHtcbiAgICAgIHJldHVybiBlbGVzLmNvbGxlY3Rpb24oKTtcbiAgICB9IGVsc2UgaWYgKGFycmF5KGVsZXMpKSB7XG4gICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBDb2xsZWN0aW9uKHRoaXMsIGVsZXMsIG9wdHMudW5pcXVlLCBvcHRzLnJlbW92ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IENvbGxlY3Rpb24odGhpcyk7XG4gIH0sXG4gIG5vZGVzOiBmdW5jdGlvbiBub2RlcyhzZWxlY3Rvcikge1xuICAgIHZhciBub2RlcyA9IHRoaXMuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmlzTm9kZSgpO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfSxcbiAgZWRnZXM6IGZ1bmN0aW9uIGVkZ2VzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy4kKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgIHJldHVybiBlbGUuaXNFZGdlKCk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWRnZXMuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkZ2VzO1xuICB9LFxuICAvLyBzZWFyY2ggdGhlIGdyYXBoIGxpa2UgalF1ZXJ5XG4gICQ6IGZ1bmN0aW9uICQoc2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlcyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gZWxlcy5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlcy5zcGF3blNlbGYoKTtcbiAgICB9XG4gIH0sXG4gIG11dGFibGVFbGVtZW50czogZnVuY3Rpb24gbXV0YWJsZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICB9XG59O1xuXG4vLyBhbGlhc2VzXG5jb3JlZm4kMy5lbGVtZW50cyA9IGNvcmVmbiQzLmZpbHRlciA9IGNvcmVmbiQzLiQ7XG5cbnZhciBzdHlmbiQ4ID0ge307XG5cbi8vIGtleXMgZm9yIHN0eWxlIGJsb2NrcywgZS5nLiB0dGZmdHRcbnZhciBUUlVFID0gJ3QnO1xudmFyIEZBTFNFID0gJ2YnO1xuXG4vLyAocG90ZW50aWFsbHkgZXhwZW5zaXZlIGNhbGN1bGF0aW9uKVxuLy8gYXBwbHkgdGhlIHN0eWxlIHRvIHRoZSBlbGVtZW50IGJhc2VkIG9uXG4vLyAtIGl0cyBieXBhc3Ncbi8vIC0gd2hhdCBzZWxlY3RvcnMgbWF0Y2ggaXRcbnN0eWZuJDguYXBwbHkgPSBmdW5jdGlvbiAoZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBfcCA9IHNlbGYuX3ByaXZhdGU7XG4gIHZhciBjeSA9IF9wLmN5O1xuICB2YXIgdXBkYXRlZEVsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gIGZvciAodmFyIGllID0gMDsgaWUgPCBlbGVzLmxlbmd0aDsgaWUrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2llXTtcbiAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoZWxlKTtcbiAgICBpZiAoY3h0TWV0YS5lbXB0eSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBjeHRTdHlsZSA9IHNlbGYuZ2V0Q29udGV4dFN0eWxlKGN4dE1ldGEpO1xuICAgIHZhciBhcHAgPSBzZWxmLmFwcGx5Q29udGV4dFN0eWxlKGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUpO1xuICAgIGlmIChlbGUuX3ByaXZhdGUuYXBwbGllZEluaXRTdHlsZSkge1xuICAgICAgc2VsZi51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGFwcC5kaWZmUHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGUuX3ByaXZhdGUuYXBwbGllZEluaXRTdHlsZSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBoaW50c0RpZmYgPSBzZWxmLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcbiAgICBpZiAoaGludHNEaWZmKSB7XG4gICAgICB1cGRhdGVkRWxlcy5wdXNoKGVsZSk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVtZW50c1xuXG4gIHJldHVybiB1cGRhdGVkRWxlcztcbn07XG5zdHlmbiQ4LmdldFByb3BlcnRpZXNEaWZmID0gZnVuY3Rpb24gKG9sZEN4dEtleSwgbmV3Q3h0S2V5KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNhY2hlID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyB8fCB7fTtcbiAgdmFyIGR1YWxDeHRLZXkgPSBvbGRDeHRLZXkgKyAnLScgKyBuZXdDeHRLZXk7XG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtkdWFsQ3h0S2V5XTtcbiAgaWYgKGNhY2hlZFZhbCkge1xuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH1cbiAgdmFyIGRpZmZQcm9wcyA9IFtdO1xuICB2YXIgYWRkZWRQcm9wID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgIHZhciBvbGRIYXNDeHQgPSBvbGRDeHRLZXlbaV0gPT09IFRSVUU7XG4gICAgdmFyIG5ld0hhc0N4dCA9IG5ld0N4dEtleVtpXSA9PT0gVFJVRTtcbiAgICB2YXIgY3h0SGFzRGlmZmVkID0gb2xkSGFzQ3h0ICE9PSBuZXdIYXNDeHQ7XG4gICAgdmFyIGN4dEhhc01hcHBlZFByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXMubGVuZ3RoID4gMDtcbiAgICBpZiAoY3h0SGFzRGlmZmVkIHx8IG5ld0hhc0N4dCAmJiBjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgdmFyIHByb3BzID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGN4dEhhc0RpZmZlZCAmJiBjeHRIYXNNYXBwZWRQcm9wcykge1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBzdWZmaWNlcyBiL2MgbWFwcGVkUHJvcGVydGllcyBpcyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzXG4gICAgICB9IGVsc2UgaWYgKGN4dEhhc0RpZmZlZCkge1xuICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBuZWVkIHRvIGNoZWNrIHRoZW0gYWxsXG4gICAgICB9IGVsc2UgaWYgKGN4dEhhc01hcHBlZFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXM7IC8vIG9ubHkgbmVlZCB0byBjaGVjayBtYXBwZWRcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG5cbiAgICAgICAgLy8gaWYgYSBsYXRlciBjb250ZXh0IG92ZXJyaWRlcyB0aGlzIHByb3BlcnR5LCB0aGVuIHRoZSBmYWN0IHRoYXQgdGhpcyBjb250ZXh0IGhhcyBzd2l0Y2hlZC9kaWZmZWQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgLy8gKHNlbWkgZXhwZW5zaXZlIGNoZWNrIHNpbmNlIGl0IG1ha2VzIHRoaXMgZnVuY3Rpb24gTyhuXjIpIG9uIGNvbnRleHQgbGVuZ3RoLCBidXQgd29ydGggaXQgc2luY2Ugb3ZlcmFsbCByZXN1bHRcbiAgICAgICAgLy8gaXMgY2FjaGVkKVxuICAgICAgICB2YXIgbGF0ZXJDeHRPdmVycmlkZXMgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgayA9IGkgKyAxOyBrIDwgc2VsZi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIHZhciBsYXRlckN4dCA9IHNlbGZba107XG4gICAgICAgICAgdmFyIGhhc0xhdGVyQ3h0ID0gbmV3Q3h0S2V5W2tdID09PSBUUlVFO1xuICAgICAgICAgIGlmICghaGFzTGF0ZXJDeHQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gY2FuJ3Qgb3ZlcnJpZGUgdW5sZXNzIHRoZSBjb250ZXh0IGlzIGFjdGl2ZVxuXG4gICAgICAgICAgbGF0ZXJDeHRPdmVycmlkZXMgPSBsYXRlckN4dC5wcm9wZXJ0aWVzW3Byb3AubmFtZV0gIT0gbnVsbDtcbiAgICAgICAgICBpZiAobGF0ZXJDeHRPdmVycmlkZXMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gZXhpdCBlYXJseSBhcyBsb25nIGFzIG9uZSBsYXRlciBjb250ZXh0IG92ZXJyaWRlc1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWRkZWRQcm9wW25hbWVdICYmICFsYXRlckN4dE92ZXJyaWRlcykge1xuICAgICAgICAgIGFkZGVkUHJvcFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgZGlmZlByb3BzLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yIHByb3BzXG4gICAgfSAvLyBpZlxuICB9IC8vIGZvciBjb250ZXh0c1xuXG4gIGNhY2hlW2R1YWxDeHRLZXldID0gZGlmZlByb3BzO1xuICByZXR1cm4gZGlmZlByb3BzO1xufTtcbnN0eWZuJDguZ2V0Q29udGV4dE1ldGEgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGN4dEtleSA9ICcnO1xuICB2YXIgZGlmZlByb3BzO1xuICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJztcblxuICAvLyBnZXQgdGhlIGN4dCBrZXlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbnRleHQgPSBzZWxmW2ldO1xuICAgIHZhciBjb250ZXh0U2VsZWN0b3JNYXRjaGVzID0gY29udGV4dC5zZWxlY3RvciAmJiBjb250ZXh0LnNlbGVjdG9yLm1hdGNoZXMoZWxlKTsgLy8gTkI6IGNvbnRleHQuc2VsZWN0b3IgbWF5IGJlIG51bGwgZm9yICdjb3JlJ1xuXG4gICAgaWYgKGNvbnRleHRTZWxlY3Rvck1hdGNoZXMpIHtcbiAgICAgIGN4dEtleSArPSBUUlVFO1xuICAgIH0gZWxzZSB7XG4gICAgICBjeHRLZXkgKz0gRkFMU0U7XG4gICAgfVxuICB9IC8vIGZvciBjb250ZXh0XG5cbiAgZGlmZlByb3BzID0gc2VsZi5nZXRQcm9wZXJ0aWVzRGlmZihwcmV2S2V5LCBjeHRLZXkpO1xuICBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgPSBjeHRLZXk7XG4gIHJldHVybiB7XG4gICAga2V5OiBjeHRLZXksXG4gICAgZGlmZlByb3BOYW1lczogZGlmZlByb3BzLFxuICAgIGVtcHR5OiBkaWZmUHJvcHMubGVuZ3RoID09PSAwXG4gIH07XG59O1xuXG4vLyBnZXRzIGEgY29tcHV0ZWQgZWxlIHN0eWxlIG9iamVjdCBiYXNlZCBvbiBtYXRjaGVkIGNvbnRleHRzXG5zdHlmbiQ4LmdldENvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhKSB7XG4gIHZhciBjeHRLZXkgPSBjeHRNZXRhLmtleTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY3h0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzIHx8IHt9O1xuXG4gIC8vIGlmIGFscmVhZHkgY29tcHV0ZWQgc3R5bGUsIHJldHVybmVkIGNhY2hlZCBjb3B5XG4gIGlmIChjeHRTdHlsZXNbY3h0S2V5XSkge1xuICAgIHJldHVybiBjeHRTdHlsZXNbY3h0S2V5XTtcbiAgfVxuICB2YXIgc3R5bGUgPSB7XG4gICAgX3ByaXZhdGU6IHtcbiAgICAgIGtleTogY3h0S2V5XG4gICAgfVxuICB9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICB2YXIgaGFzQ3h0ID0gY3h0S2V5W2ldID09PSBUUlVFO1xuICAgIGlmICghaGFzQ3h0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjeHQucHJvcGVydGllcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHByb3AgPSBjeHQucHJvcGVydGllc1tqXTtcbiAgICAgIHN0eWxlW3Byb3AubmFtZV0gPSBwcm9wO1xuICAgIH1cbiAgfVxuICBjeHRTdHlsZXNbY3h0S2V5XSA9IHN0eWxlO1xuICByZXR1cm4gc3R5bGU7XG59O1xuc3R5Zm4kOC5hcHBseUNvbnRleHRTdHlsZSA9IGZ1bmN0aW9uIChjeHRNZXRhLCBjeHRTdHlsZSwgZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGRpZmZQcm9wcyA9IGN4dE1ldGEuZGlmZlByb3BOYW1lcztcbiAgdmFyIHJldERpZmZQcm9wcyA9IHt9O1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmZQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaWZmUHJvcE5hbWUgPSBkaWZmUHJvcHNbaV07XG4gICAgdmFyIGN4dFByb3AgPSBjeHRTdHlsZVtkaWZmUHJvcE5hbWVdO1xuICAgIHZhciBlbGVQcm9wID0gZWxlLnBzdHlsZShkaWZmUHJvcE5hbWUpO1xuICAgIGlmICghY3h0UHJvcCkge1xuICAgICAgLy8gbm8gY29udGV4dCBwcm9wIG1lYW5zIGRlbGV0ZVxuICAgICAgaWYgKCFlbGVQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBubyBleGlzdGluZyBwcm9wIG1lYW5zIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAvLyBuYiBhZmZlY3RzIGluaXRpYWwgYXBwbGljYXRpb24gb24gbWFwcGVkIHZhbHVlcyBsaWtlIGNvbnRyb2wtcG9pbnQtZGlzdGFuY2VzXG4gICAgICB9IGVsc2UgaWYgKGVsZVByb3AuYnlwYXNzKSB7XG4gICAgICAgIGN4dFByb3AgPSB7XG4gICAgICAgICAgbmFtZTogZGlmZlByb3BOYW1lLFxuICAgICAgICAgIGRlbGV0ZUJ5cGFzc2VkOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeHRQcm9wID0ge1xuICAgICAgICAgIG5hbWU6IGRpZmZQcm9wTmFtZSxcbiAgICAgICAgICBcImRlbGV0ZVwiOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2F2ZSBjeWNsZXMgd2hlbiB0aGUgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG4gICAgaWYgKGVsZVByb3AgPT09IGN4dFByb3ApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHNhdmUgY3ljbGVzIHdoZW4gYSBtYXBwZWQgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG4gICAgaWYgKGN4dFByb3AubWFwcGVkID09PSB0eXBlcy5mbiAvLyBjb250ZXh0IHByb3AgaXMgZnVuY3Rpb24gbWFwcGVyXG4gICAgJiYgZWxlUHJvcCAhPSBudWxsIC8vIHNvbWUgcHJvcHMgY2FuIGJlIG51bGwgZXZlbiBieSBkZWZhdWx0IChlLmcuIGEgcHJvcCB0aGF0IG92ZXJyaWRlcyBhbm90aGVyIG9uZSlcbiAgICAmJiBlbGVQcm9wLm1hcHBpbmcgIT0gbnVsbCAvLyBlbGUgcHJvcCBpcyBhIGNvbmNyZXRlIHZhbHVlIGZyb20gZnJvbSBhIG1hcHBlclxuICAgICYmIGVsZVByb3AubWFwcGluZy52YWx1ZSA9PT0gY3h0UHJvcC52YWx1ZSAvLyB0aGUgY3VycmVudCBwcm9wIG9uIHRoZSBlbGUgaXMgYSBmbGF0IHByb3AgdmFsdWUgZm9yIHRoZSBmdW5jdGlvbiBtYXBwZXJcbiAgICApIHtcbiAgICAgIC8vIE5CIGRvbid0IHdyaXRlIHRvIGN4dFByb3AsIGFzIGl0J3Mgc2hhcmVkIGFtb25nIGVsZXMgKHN0b3JlZCBpbiBzdHlsZXNoZWV0KVxuICAgICAgdmFyIG1hcHBpbmcgPSBlbGVQcm9wLm1hcHBpbmc7IC8vIGNhbiB3cml0ZSB0byBtYXBwaW5nLCBhcyBpdCdzIGEgcGVyLWVsZSBjb3B5XG4gICAgICB2YXIgZm5WYWx1ZSA9IG1hcHBpbmcuZm5WYWx1ZSA9IGN4dFByb3AudmFsdWUoZWxlKTsgLy8gdGVtcG9yYXJpbHkgY2FjaGUgdGhlIHZhbHVlIGluIGNhc2Ugb2YgYSBtaXNzXG5cbiAgICAgIGlmIChmblZhbHVlID09PSBtYXBwaW5nLnByZXZGblZhbHVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgcmV0RGlmZlByb3AgPSByZXREaWZmUHJvcHNbZGlmZlByb3BOYW1lXSA9IHtcbiAgICAgIHByZXY6IGVsZVByb3BcbiAgICB9O1xuICAgIHNlbGYuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIGN4dFByb3ApO1xuICAgIHJldERpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKGRpZmZQcm9wTmFtZSk7XG4gICAgaWYgKHJldERpZmZQcm9wLm5leHQgJiYgcmV0RGlmZlByb3AubmV4dC5ieXBhc3MpIHtcbiAgICAgIHJldERpZmZQcm9wLm5leHQgPSByZXREaWZmUHJvcC5uZXh0LmJ5cGFzc2VkO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGRpZmZQcm9wczogcmV0RGlmZlByb3BzXG4gIH07XG59O1xuc3R5Zm4kOC51cGRhdGVTdHlsZUhpbnRzID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHByb3BOYW1lcyA9IHNlbGYucHJvcGVydHlHcm91cE5hbWVzO1xuICB2YXIgcHJvcEdyS2V5cyA9IHNlbGYucHJvcGVydHlHcm91cEtleXM7XG4gIHZhciBwcm9wSGFzaCA9IGZ1bmN0aW9uIHByb3BIYXNoKGVsZSwgcHJvcE5hbWVzLCBzZWVkS2V5KSB7XG4gICAgcmV0dXJuIHNlbGYuZ2V0UHJvcGVydGllc0hhc2goZWxlLCBwcm9wTmFtZXMsIHNlZWRLZXkpO1xuICB9O1xuICB2YXIgb2xkU3R5bGVLZXkgPSBfcC5zdHlsZUtleTtcbiAgaWYgKGVsZS5yZW1vdmVkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGlzTm9kZSA9IF9wLmdyb3VwID09PSAnbm9kZXMnO1xuXG4gIC8vIGdldCB0aGUgc3R5bGUga2V5IGhhc2hlcyBwZXIgcHJvcCBncm91cFxuICAvLyBidXQgbGF6aWx5IC0tIG9ubHkgdXNlIG5vbi1kZWZhdWx0IHByb3AgdmFsdWVzIHRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGhhc2hlc1xuICAvL1xuXG4gIHZhciBvdmVycmlkZGVuU3R5bGVzID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICBwcm9wTmFtZXMgPSBPYmplY3Qua2V5cyhvdmVycmlkZGVuU3R5bGVzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wR3JLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGdyS2V5ID0gcHJvcEdyS2V5c1tpXTtcbiAgICBfcC5zdHlsZUtleXNbZ3JLZXldID0gW0RFRkFVTFRfSEFTSF9TRUVELCBERUZBVUxUX0hBU0hfU0VFRF9BTFRdO1xuICB9XG4gIHZhciB1cGRhdGVHcktleTEgPSBmdW5jdGlvbiB1cGRhdGVHcktleTEodmFsLCBncktleSkge1xuICAgIHJldHVybiBfcC5zdHlsZUtleXNbZ3JLZXldWzBdID0gaGFzaEludCh2YWwsIF9wLnN0eWxlS2V5c1tncktleV1bMF0pO1xuICB9O1xuICB2YXIgdXBkYXRlR3JLZXkyID0gZnVuY3Rpb24gdXBkYXRlR3JLZXkyKHZhbCwgZ3JLZXkpIHtcbiAgICByZXR1cm4gX3Auc3R5bGVLZXlzW2dyS2V5XVsxXSA9IGhhc2hJbnRBbHQodmFsLCBfcC5zdHlsZUtleXNbZ3JLZXldWzFdKTtcbiAgfTtcbiAgdmFyIHVwZGF0ZUdyS2V5ID0gZnVuY3Rpb24gdXBkYXRlR3JLZXkodmFsLCBncktleSkge1xuICAgIHVwZGF0ZUdyS2V5MSh2YWwsIGdyS2V5KTtcbiAgICB1cGRhdGVHcktleTIodmFsLCBncktleSk7XG4gIH07XG4gIHZhciB1cGRhdGVHcktleVdTdHIgPSBmdW5jdGlvbiB1cGRhdGVHcktleVdTdHIoc3RyVmFsLCBncktleSkge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RyVmFsLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgY2ggPSBzdHJWYWwuY2hhckNvZGVBdChqKTtcbiAgICAgIHVwZGF0ZUdyS2V5MShjaCwgZ3JLZXkpO1xuICAgICAgdXBkYXRlR3JLZXkyKGNoLCBncktleSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIC0gaGFzaGluZyB3b3JrcyBvbiAzMiBiaXQgaW50cyBiL2Mgd2UgdXNlIGJpdHdpc2Ugb3BzXG4gIC8vIC0gc21hbGwgbnVtYmVycyBnZXQgY3V0IG9mZiAoZS5nLiAwLjEyMyBpcyBzZWVuIGFzIDAgYnkgdGhlIGhhc2hpbmcgZnVuY3Rpb24pXG4gIC8vIC0gcmFpc2UgdXAgc21hbGwgbnVtYmVycyBzbyBtb3JlIHNpZ25pZmljYW50IGRpZ2l0cyBhcmUgc2VlbiBieSBoYXNoaW5nXG4gIC8vIC0gbWFrZSBzbWFsbCBudW1iZXJzIGxhcmdlciB0aGFuIGEgbm9ybWFsIHZhbHVlIHRvIGF2b2lkIGNvbGxpc2lvbnNcbiAgLy8gLSB3b3JrcyBpbiBwcmFjdGljZSBhbmQgaXQncyByZWxhdGl2ZWx5IGNoZWFwXG4gIHZhciBOID0gMjAwMDAwMDAwMDtcbiAgdmFyIGNsZWFuTnVtID0gZnVuY3Rpb24gY2xlYW5OdW0odmFsKSB7XG4gICAgcmV0dXJuIC0xMjggPCB2YWwgJiYgdmFsIDwgMTI4ICYmIE1hdGguZmxvb3IodmFsKSAhPT0gdmFsID8gTiAtICh2YWwgKiAxMDI0IHwgMCkgOiB2YWw7XG4gIH07XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBwcm9wTmFtZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wTmFtZXNbX2ldO1xuICAgIHZhciBwYXJzZWRQcm9wID0gb3ZlcnJpZGRlblN0eWxlc1tuYW1lXTtcbiAgICBpZiAocGFyc2VkUHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHByb3BJbmZvID0gdGhpcy5wcm9wZXJ0aWVzW25hbWVdO1xuICAgIHZhciB0eXBlID0gcHJvcEluZm8udHlwZTtcbiAgICB2YXIgX2dyS2V5ID0gcHJvcEluZm8uZ3JvdXBLZXk7XG4gICAgdmFyIG5vcm1hbGl6ZWROdW1iZXJWYWwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb3BJbmZvLmhhc2hPdmVycmlkZSAhPSBudWxsKSB7XG4gICAgICBub3JtYWxpemVkTnVtYmVyVmFsID0gcHJvcEluZm8uaGFzaE92ZXJyaWRlKGVsZSwgcGFyc2VkUHJvcCk7XG4gICAgfSBlbHNlIGlmIChwYXJzZWRQcm9wLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgbm9ybWFsaXplZE51bWJlclZhbCA9IHBhcnNlZFByb3AucGZWYWx1ZTtcbiAgICB9XG5cbiAgICAvLyBtaWdodCBub3QgYmUgYSBudW1iZXIgaWYgaXQgYWxsb3dzIGVudW1zXG4gICAgdmFyIG51bWJlclZhbCA9IHByb3BJbmZvLmVudW1zID09IG51bGwgPyBwYXJzZWRQcm9wLnZhbHVlIDogbnVsbDtcbiAgICB2YXIgaGF2ZU5vcm1OdW0gPSBub3JtYWxpemVkTnVtYmVyVmFsICE9IG51bGw7XG4gICAgdmFyIGhhdmVVbml0ZWROdW0gPSBudW1iZXJWYWwgIT0gbnVsbDtcbiAgICB2YXIgaGF2ZU51bSA9IGhhdmVOb3JtTnVtIHx8IGhhdmVVbml0ZWROdW07XG4gICAgdmFyIHVuaXRzID0gcGFyc2VkUHJvcC51bml0cztcblxuICAgIC8vIG51bWJlcnMgYXJlIGNoZWFwZXIgdG8gaGFzaCB0aGFuIHN0cmluZ3NcbiAgICAvLyAxIGhhc2ggb3AgdnMgbiBoYXNoIG9wcyAoZm9yIGxlbmd0aCBuIHN0cmluZylcbiAgICBpZiAodHlwZS5udW1iZXIgJiYgaGF2ZU51bSAmJiAhdHlwZS5tdWx0aXBsZSkge1xuICAgICAgdmFyIHYgPSBoYXZlTm9ybU51bSA/IG5vcm1hbGl6ZWROdW1iZXJWYWwgOiBudW1iZXJWYWw7XG4gICAgICB1cGRhdGVHcktleShjbGVhbk51bSh2KSwgX2dyS2V5KTtcbiAgICAgIGlmICghaGF2ZU5vcm1OdW0gJiYgdW5pdHMgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVHcktleVdTdHIodW5pdHMsIF9ncktleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUdyS2V5V1N0cihwYXJzZWRQcm9wLnN0clZhbHVlLCBfZ3JLZXkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG92ZXJhbGwgc3R5bGUga2V5XG4gIC8vXG5cbiAgdmFyIGhhc2ggPSBbREVGQVVMVF9IQVNIX1NFRUQsIERFRkFVTFRfSEFTSF9TRUVEX0FMVF07XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHByb3BHcktleXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfZ3JLZXkyID0gcHJvcEdyS2V5c1tfaTJdO1xuICAgIHZhciBnckhhc2ggPSBfcC5zdHlsZUtleXNbX2dyS2V5Ml07XG4gICAgaGFzaFswXSA9IGhhc2hJbnQoZ3JIYXNoWzBdLCBoYXNoWzBdKTtcbiAgICBoYXNoWzFdID0gaGFzaEludEFsdChnckhhc2hbMV0sIGhhc2hbMV0pO1xuICB9XG4gIF9wLnN0eWxlS2V5ID0gY29tYmluZUhhc2hlcyhoYXNoWzBdLCBoYXNoWzFdKTtcblxuICAvLyBsYWJlbCBkaW1zXG4gIC8vXG5cbiAgdmFyIHNrID0gX3Auc3R5bGVLZXlzO1xuICBfcC5sYWJlbERpbXNLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoc2subGFiZWxEaW1lbnNpb25zKTtcbiAgdmFyIGxhYmVsS2V5cyA9IHByb3BIYXNoKGVsZSwgWydsYWJlbCddLCBzay5sYWJlbERpbWVuc2lvbnMpO1xuICBfcC5sYWJlbEtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShsYWJlbEtleXMpO1xuICBfcC5sYWJlbFN0eWxlS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KGhhc2hBcnJheXMoc2suY29tbW9uTGFiZWwsIGxhYmVsS2V5cykpO1xuICBpZiAoIWlzTm9kZSkge1xuICAgIHZhciBzb3VyY2VMYWJlbEtleXMgPSBwcm9wSGFzaChlbGUsIFsnc291cmNlLWxhYmVsJ10sIHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gICAgX3Auc291cmNlTGFiZWxLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkoc291cmNlTGFiZWxLZXlzKTtcbiAgICBfcC5zb3VyY2VMYWJlbFN0eWxlS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KGhhc2hBcnJheXMoc2suY29tbW9uTGFiZWwsIHNvdXJjZUxhYmVsS2V5cykpO1xuICAgIHZhciB0YXJnZXRMYWJlbEtleXMgPSBwcm9wSGFzaChlbGUsIFsndGFyZ2V0LWxhYmVsJ10sIHNrLmxhYmVsRGltZW5zaW9ucyk7XG4gICAgX3AudGFyZ2V0TGFiZWxLZXkgPSBjb21iaW5lSGFzaGVzQXJyYXkodGFyZ2V0TGFiZWxLZXlzKTtcbiAgICBfcC50YXJnZXRMYWJlbFN0eWxlS2V5ID0gY29tYmluZUhhc2hlc0FycmF5KGhhc2hBcnJheXMoc2suY29tbW9uTGFiZWwsIHRhcmdldExhYmVsS2V5cykpO1xuICB9XG5cbiAgLy8gbm9kZVxuICAvL1xuXG4gIGlmIChpc05vZGUpIHtcbiAgICB2YXIgX3Akc3R5bGVLZXlzID0gX3Auc3R5bGVLZXlzLFxuICAgICAgbm9kZUJvZHkgPSBfcCRzdHlsZUtleXMubm9kZUJvZHksXG4gICAgICBub2RlQm9yZGVyID0gX3Akc3R5bGVLZXlzLm5vZGVCb3JkZXIsXG4gICAgICBub2RlT3V0bGluZSA9IF9wJHN0eWxlS2V5cy5ub2RlT3V0bGluZSxcbiAgICAgIGJhY2tncm91bmRJbWFnZSA9IF9wJHN0eWxlS2V5cy5iYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICBjb21wb3VuZCA9IF9wJHN0eWxlS2V5cy5jb21wb3VuZCxcbiAgICAgIHBpZSA9IF9wJHN0eWxlS2V5cy5waWUsXG4gICAgICBzdHJpcGUgPSBfcCRzdHlsZUtleXMuc3RyaXBlO1xuICAgIHZhciBub2RlS2V5cyA9IFtub2RlQm9keSwgbm9kZUJvcmRlciwgbm9kZU91dGxpbmUsIGJhY2tncm91bmRJbWFnZSwgY29tcG91bmQsIHBpZSwgc3RyaXBlXS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiBrICE9IG51bGw7XG4gICAgfSkucmVkdWNlKGhhc2hBcnJheXMsIFtERUZBVUxUX0hBU0hfU0VFRCwgREVGQVVMVF9IQVNIX1NFRURfQUxUXSk7XG4gICAgX3Aubm9kZUtleSA9IGNvbWJpbmVIYXNoZXNBcnJheShub2RlS2V5cyk7XG4gICAgX3AuaGFzUGllID0gcGllICE9IG51bGwgJiYgcGllWzBdICE9PSBERUZBVUxUX0hBU0hfU0VFRCAmJiBwaWVbMV0gIT09IERFRkFVTFRfSEFTSF9TRUVEX0FMVDtcbiAgICBfcC5oYXNTdHJpcGUgPSBzdHJpcGUgIT0gbnVsbCAmJiBzdHJpcGVbMF0gIT09IERFRkFVTFRfSEFTSF9TRUVEICYmIHN0cmlwZVsxXSAhPT0gREVGQVVMVF9IQVNIX1NFRURfQUxUO1xuICB9XG4gIHJldHVybiBvbGRTdHlsZUtleSAhPT0gX3Auc3R5bGVLZXk7XG59O1xuc3R5Zm4kOC5jbGVhclN0eWxlSGludHMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgX3Auc3R5bGVDeHRLZXkgPSAnJztcbiAgX3Auc3R5bGVLZXlzID0ge307XG4gIF9wLnN0eWxlS2V5ID0gbnVsbDtcbiAgX3AubGFiZWxLZXkgPSBudWxsO1xuICBfcC5sYWJlbFN0eWxlS2V5ID0gbnVsbDtcbiAgX3Auc291cmNlTGFiZWxLZXkgPSBudWxsO1xuICBfcC5zb3VyY2VMYWJlbFN0eWxlS2V5ID0gbnVsbDtcbiAgX3AudGFyZ2V0TGFiZWxLZXkgPSBudWxsO1xuICBfcC50YXJnZXRMYWJlbFN0eWxlS2V5ID0gbnVsbDtcbiAgX3Aubm9kZUtleSA9IG51bGw7XG4gIF9wLmhhc1BpZSA9IG51bGw7XG4gIF9wLmhhc1N0cmlwZSA9IG51bGw7XG59O1xuXG4vLyBhcHBseSBhIHByb3BlcnR5IHRvIHRoZSBzdHlsZSAoZm9yIGludGVybmFsIHVzZSlcbi8vIHJldHVybnMgd2hldGhlciBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuLy9cbi8vIG5vdywgdGhpcyBmdW5jdGlvbiBmbGF0dGVucyB0aGUgcHJvcGVydHksIGFuZCBoZXJlJ3MgaG93OlxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlLCBkZWxldGVCeXBhc3M6IHRydWUgfVxuLy8gbm8gcHJvcGVydHkgaXMgZ2VuZXJhdGVkLCBpbnN0ZWFkIHRoZSBieXBhc3MgcHJvcGVydHkgaW4gdGhlXG4vLyBlbGVtZW50J3Mgc3R5bGUgaXMgcmVwbGFjZWQgYnkgd2hhdCdzIHBvaW50ZWQgdG8gYnkgdGhlIGBieXBhc3NlZGBcbi8vIGZpZWxkIGluIHRoZSBieXBhc3MgcHJvcGVydHkgKGkuZS4gcmVzdG9yaW5nIHRoZSBwcm9wZXJ0eSB0aGVcbi8vIGJ5cGFzcyB3YXMgb3ZlcnJpZGluZylcbi8vXG4vLyBmb3IgcGFyc2VkUHJvcDp7IG1hcHBlZDogdHJ1dGh5IH1cbi8vIHRoZSBnZW5lcmF0ZWQgZmxhdHRlbmVkUHJvcDp7IG1hcHBpbmc6IHByb3AgfVxuLy9cbi8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlIH1cbi8vIHRoZSBnZW5lcmF0ZWQgZmxhdHRlbmVkUHJvcDp7IGJ5cGFzc2VkOiBwYXJzZWRQcm9wIH1cbnN0eWZuJDguYXBwbHlQYXJzZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChlbGUsIHBhcnNlZFByb3ApIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcHJvcCA9IHBhcnNlZFByb3A7XG4gIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgdmFyIGZsYXRQcm9wO1xuICB2YXIgdHlwZXMgPSBzZWxmLnR5cGVzO1xuICB2YXIgdHlwZSA9IHNlbGYucHJvcGVydGllc1twcm9wLm5hbWVdLnR5cGU7XG4gIHZhciBwcm9wSXNCeXBhc3MgPSBwcm9wLmJ5cGFzcztcbiAgdmFyIG9yaWdQcm9wID0gc3R5bGVbcHJvcC5uYW1lXTtcbiAgdmFyIG9yaWdQcm9wSXNCeXBhc3MgPSBvcmlnUHJvcCAmJiBvcmlnUHJvcC5ieXBhc3M7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIGZsYXRQcm9wTWFwcGluZyA9ICdtYXBwaW5nJztcbiAgdmFyIGdldFZhbCA9IGZ1bmN0aW9uIGdldFZhbChwKSB7XG4gICAgaWYgKHAgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChwLnBmVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHAucGZWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHAudmFsdWU7XG4gICAgfVxuICB9O1xuICB2YXIgY2hlY2tUcmlnZ2VycyA9IGZ1bmN0aW9uIGNoZWNrVHJpZ2dlcnMoKSB7XG4gICAgdmFyIGZyb21WYWwgPSBnZXRWYWwob3JpZ1Byb3ApO1xuICAgIHZhciB0b1ZhbCA9IGdldFZhbChwcm9wKTtcbiAgICBzZWxmLmNoZWNrVHJpZ2dlcnMoZWxlLCBwcm9wLm5hbWUsIGZyb21WYWwsIHRvVmFsKTtcbiAgfTtcblxuICAvLyBlZGdlIHNhbml0eSBjaGVja3MgdG8gcHJldmVudCB0aGUgY2xpZW50IGZyb20gbWFraW5nIHNlcmlvdXMgbWlzdGFrZXNcbiAgaWYgKHBhcnNlZFByb3AubmFtZSA9PT0gJ2N1cnZlLXN0eWxlJyAmJiBlbGUuaXNFZGdlKCkgJiYgKFxuICAvLyBsb29wcyBtdXN0IGJlIGJ1bmRsZWQgYmV6aWVyc1xuICBwYXJzZWRQcm9wLnZhbHVlICE9PSAnYmV6aWVyJyAmJiBlbGUuaXNMb29wKCkgfHxcbiAgLy8gZWRnZXMgY29ubmVjdGVkIHRvIGNvbXBvdW5kIG5vZGVzIGNhbiBub3QgYmUgaGF5c3RhY2tzXG4gIHBhcnNlZFByb3AudmFsdWUgPT09ICdoYXlzdGFjaycgJiYgKGVsZS5zb3VyY2UoKS5pc1BhcmVudCgpIHx8IGVsZS50YXJnZXQoKS5pc1BhcmVudCgpKSkpIHtcbiAgICBwcm9wID0gcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UocGFyc2VkUHJvcC5uYW1lLCAnYmV6aWVyJywgcHJvcElzQnlwYXNzKTtcbiAgfVxuICBpZiAocHJvcFtcImRlbGV0ZVwiXSkge1xuICAgIC8vIGRlbGV0ZSB0aGUgcHJvcGVydHkgYW5kIHVzZSB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBmYWxzZXkgdmFsdWVcbiAgICBzdHlsZVtwcm9wLm5hbWVdID0gdW5kZWZpbmVkO1xuICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocHJvcC5kZWxldGVCeXBhc3NlZCkge1xuICAgIC8vIGRlbGV0ZSB0aGUgcHJvcGVydHkgdGhhdCB0aGVcbiAgICBpZiAoIW9yaWdQcm9wKSB7XG4gICAgICBjaGVja1RyaWdnZXJzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gY2FuJ3QgZGVsZXRlIGlmIG5vIHByb3BcbiAgICB9IGVsc2UgaWYgKG9yaWdQcm9wLmJ5cGFzcykge1xuICAgICAgLy8gZGVsZXRlIGJ5cGFzc2VkXG4gICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHVuZGVmaW5lZDtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzZWRcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBieXBhc3NcbiAgaWYgKHByb3AuZGVsZXRlQnlwYXNzKSB7XG4gICAgLy8gdGhlbiB0aGlzIHByb3BlcnR5IGlzIGp1c3QgaGVyZSB0byBpbmRpY2F0ZSB3ZSBuZWVkIHRvIGRlbGV0ZVxuICAgIGlmICghb3JpZ1Byb3ApIHtcbiAgICAgIGNoZWNrVHJpZ2dlcnMoKTtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBwcm9wZXJ0eSBpcyBhbHJlYWR5IG5vdCBkZWZpbmVkXG4gICAgfSBlbHNlIGlmIChvcmlnUHJvcC5ieXBhc3MpIHtcbiAgICAgIC8vIHRoZW4gcmVwbGFjZSB0aGUgYnlwYXNzIHByb3BlcnR5IHdpdGggdGhlIG9yaWdpbmFsXG4gICAgICAvLyBiZWNhdXNlIHRoZSBieXBhc3NlZCBwcm9wZXJ0eSB3YXMgYWxyZWFkeSBhcHBsaWVkIChhbmQgdGhlcmVmb3JlIHBhcnNlZCksIHdlIGNhbiBqdXN0IHJlcGxhY2UgaXQgKG5vIHJlYXBwbHlpbmcgbmVjZXNzYXJ5KVxuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IG9yaWdQcm9wLmJ5cGFzc2VkO1xuICAgICAgY2hlY2tUcmlnZ2VycygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NcbiAgICB9XG4gIH1cbiAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uIHByaW50TWFwcGluZ0VycigpIHtcbiAgICB3YXJuKCdEbyBub3QgYXNzaWduIG1hcHBpbmdzIHRvIGVsZW1lbnRzIHdpdGhvdXQgY29ycmVzcG9uZGluZyBkYXRhIChpLmUuIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaGFzIG5vIG1hcHBpbmcgZm9yIHByb3BlcnR5IGAnICsgcHJvcC5uYW1lICsgJ2Agd2l0aCBkYXRhIGZpZWxkIGAnICsgcHJvcC5maWVsZCArICdgKTsgdHJ5IGEgYFsnICsgcHJvcC5maWVsZCArICddYCBzZWxlY3RvciB0byBsaW1pdCBzY29wZSB0byBlbGVtZW50cyB3aXRoIGAnICsgcHJvcC5maWVsZCArICdgIGRlZmluZWQnKTtcbiAgfTtcblxuICAvLyBwdXQgdGhlIHByb3BlcnR5IGluIHRoZSBzdHlsZSBvYmplY3RzXG4gIHN3aXRjaCAocHJvcC5tYXBwZWQpIHtcbiAgICAvLyBmbGF0dGVuIHRoZSBwcm9wZXJ0eSBpZiBtYXBwZWRcbiAgICBjYXNlIHR5cGVzLm1hcERhdGE6XG4gICAgICB7XG4gICAgICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICAgICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIGZpZWxkVmFsID0gX3AuZGF0YTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoICYmIGZpZWxkVmFsOyBpKyspIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgZmllbGRWYWwgPSBmaWVsZFZhbFtmaWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkVmFsID09IG51bGwpIHtcbiAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBlcmNlbnQ7XG4gICAgICAgIGlmICghbnVtYmVyJDEoZmllbGRWYWwpKSB7XG4gICAgICAgICAgLy8gdGhlbiBkb24ndCBhcHBseSBhbmQgZmFsbCBiYWNrIG9uIHRoZSBleGlzdGluZyBzdHlsZVxuICAgICAgICAgIHdhcm4oJ0RvIG5vdCB1c2UgY29udGludW91cyBtYXBwZXJzIHdpdGhvdXQgc3BlY2lmeWluZyBudW1lcmljIGRhdGEgKGkuZS4gYCcgKyBwcm9wLmZpZWxkICsgJzogJyArIGZpZWxkVmFsICsgJ2AgZm9yIGAnICsgZWxlLmlkKCkgKyAnYCBpcyBub24tbnVtZXJpYyknKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZpZWxkV2lkdGggPSBwcm9wLmZpZWxkTWF4IC0gcHJvcC5maWVsZE1pbjtcbiAgICAgICAgICBpZiAoZmllbGRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gc2FmZXR5IGNoZWNrIC0tIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgYXMgbm8gcHJvcHMgb2YgemVybyByYW5nZSBzaG91bGQgYmUgcGFzc2VkIGhlcmVcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gKGZpZWxkVmFsIC0gcHJvcC5maWVsZE1pbikgLyBmaWVsZFdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBib3VuZCBwZXJjZW50IHZhbHVlXG4gICAgICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPiAxKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUuY29sb3IpIHtcbiAgICAgICAgICB2YXIgcjEgPSBwcm9wLnZhbHVlTWluWzBdO1xuICAgICAgICAgIHZhciByMiA9IHByb3AudmFsdWVNYXhbMF07XG4gICAgICAgICAgdmFyIGcxID0gcHJvcC52YWx1ZU1pblsxXTtcbiAgICAgICAgICB2YXIgZzIgPSBwcm9wLnZhbHVlTWF4WzFdO1xuICAgICAgICAgIHZhciBiMSA9IHByb3AudmFsdWVNaW5bMl07XG4gICAgICAgICAgdmFyIGIyID0gcHJvcC52YWx1ZU1heFsyXTtcbiAgICAgICAgICB2YXIgYTEgPSBwcm9wLnZhbHVlTWluWzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1pblszXTtcbiAgICAgICAgICB2YXIgYTIgPSBwcm9wLnZhbHVlTWF4WzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1heFszXTtcbiAgICAgICAgICB2YXIgY2xyID0gW01hdGgucm91bmQocjEgKyAocjIgLSByMSkgKiBwZXJjZW50KSwgTWF0aC5yb3VuZChnMSArIChnMiAtIGcxKSAqIHBlcmNlbnQpLCBNYXRoLnJvdW5kKGIxICsgKGIyIC0gYjEpICogcGVyY2VudCksIE1hdGgucm91bmQoYTEgKyAoYTIgLSBhMSkgKiBwZXJjZW50KV07XG4gICAgICAgICAgZmxhdFByb3AgPSB7XG4gICAgICAgICAgICAvLyBjb2xvdXJzIGFyZSBzaW1wbGUsIHNvIGp1c3QgY3JlYXRlIHRoZSBmbGF0IHByb3BlcnR5IGluc3RlYWQgb2YgZXhwZW5zaXZlIHN0cmluZyBwYXJzaW5nXG4gICAgICAgICAgICBieXBhc3M6IHByb3AuYnlwYXNzLFxuICAgICAgICAgICAgLy8gd2UncmUgYSBieXBhc3MgaWYgdGhlIG1hcHBpbmcgcHJvcGVydHkgaXMgYSBieXBhc3NcbiAgICAgICAgICAgIG5hbWU6IHByb3AubmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBjbHIsXG4gICAgICAgICAgICBzdHJWYWx1ZTogJ3JnYignICsgY2xyWzBdICsgJywgJyArIGNsclsxXSArICcsICcgKyBjbHJbMl0gKyAnKSdcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgdmFyIGNhbGNWYWx1ZSA9IHByb3AudmFsdWVNaW4gKyAocHJvcC52YWx1ZU1heCAtIHByb3AudmFsdWVNaW4pICogcGVyY2VudDtcbiAgICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCBjYWxjVmFsdWUsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FuIG9ubHkgbWFwIHRvIGNvbG91cnMgYW5kIG51bWJlcnNcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgdGhlIHByb3BlcnR5IGFuZCBmYWxsIGJhY2sgb24gdGhlIGV4aXN0aW5nIHN0eWxlXG4gICAgICAgICAgcHJpbnRNYXBwaW5nRXJyKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIGRpcmVjdCBtYXBwaW5nXG4gICAgY2FzZSB0eXBlcy5kYXRhOlxuICAgICAge1xuICAgICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICAgIHZhciBfZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgX2ZpZWxkVmFsID0gX3AuZGF0YTtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgX2ZpZWxkcy5sZW5ndGggJiYgX2ZpZWxkVmFsOyBfaTMrKykge1xuICAgICAgICAgIHZhciBfZmllbGQgPSBfZmllbGRzW19pM107XG4gICAgICAgICAgX2ZpZWxkVmFsID0gX2ZpZWxkVmFsW19maWVsZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9maWVsZFZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgX2ZpZWxkVmFsLCBwcm9wLmJ5cGFzcywgZmxhdFByb3BNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gZG9uJ3QgYXBwbHkgYW5kIGZhbGwgYmFjayBvbiB0aGUgZXhpc3Rpbmcgc3R5bGVcbiAgICAgICAgICBwcmludE1hcHBpbmdFcnIoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgdHlwZXMuZm46XG4gICAgICB7XG4gICAgICAgIHZhciBmbiA9IHByb3AudmFsdWU7XG4gICAgICAgIHZhciBmblJldFZhbCA9IHByb3AuZm5WYWx1ZSAhPSBudWxsID8gcHJvcC5mblZhbHVlIDogZm4oZWxlKTsgLy8gY2hlY2sgZm9yIGNhY2hlZCB2YWx1ZSBiZWZvcmUgY2FsbGluZyBmdW5jdGlvblxuXG4gICAgICAgIHByb3AucHJldkZuVmFsdWUgPSBmblJldFZhbDtcbiAgICAgICAgaWYgKGZuUmV0VmFsID09IG51bGwpIHtcbiAgICAgICAgICB3YXJuKCdDdXN0b20gZnVuY3Rpb24gbWFwcGVycyBtYXkgbm90IHJldHVybiBudWxsIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgbnVsbCknKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgZm5SZXRWYWwsIHByb3AuYnlwYXNzLCBmbGF0UHJvcE1hcHBpbmcpO1xuICAgICAgICBpZiAoIWZsYXRQcm9wKSB7XG4gICAgICAgICAgd2FybignQ3VzdG9tIGZ1bmN0aW9uIG1hcHBlcnMgbWF5IG5vdCByZXR1cm4gaW52YWxpZCB2YWx1ZXMgZm9yIHRoZSBwcm9wZXJ0eSB0eXBlIChpLmUuIGAnICsgcHJvcC5uYW1lICsgJ2AgZm9yIGVsZSBgJyArIGVsZS5pZCgpICsgJ2AgaXMgaW52YWxpZCknKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmxhdFByb3AubWFwcGluZyA9IGNvcHkocHJvcCk7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgYnJlYWs7XG4gICAgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIG5vdCBhIHZhbGlkIG1hcHBpbmdcbiAgfVxuXG4gIC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eSwgdGhlbiBsaW5rIHRoZSByZXN1bHRhbnQgcHJvcGVydHkgdG8gdGhlIG9yaWdpbmFsIG9uZVxuICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgaWYgKG9yaWdQcm9wSXNCeXBhc3MpIHtcbiAgICAgIC8vIHRoZW4gdGhpcyBieXBhc3Mgb3ZlcnJpZGVzIHRoZSBleGlzdGluZyBvbmVcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcC5ieXBhc3NlZDsgLy8gc3RlYWwgYnlwYXNzZWQgcHJvcCBmcm9tIG9sZCBieXBhc3NcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBsaW5rIHRoZSBvcmlnIHByb3AgdG8gdGhlIG5ldyBieXBhc3NcbiAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcDtcbiAgICB9XG4gICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7IC8vIGFuZCBzZXRcbiAgfSBlbHNlIHtcbiAgICAvLyBwcm9wIGlzIG5vdCBieXBhc3NcbiAgICBpZiAob3JpZ1Byb3BJc0J5cGFzcykge1xuICAgICAgLy8gdGhlbiBrZWVwIHRoZSBvcmlnIHByb3AgKHNpbmNlIGl0J3MgYSBieXBhc3MpIGFuZCBsaW5rIHRvIHRoZSBuZXcgcHJvcFxuICAgICAgb3JpZ1Byb3AuYnlwYXNzZWQgPSBwcm9wO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0aGVuIGp1c3QgcmVwbGFjZSB0aGUgb2xkIHByb3Agd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgc3R5bGVbcHJvcC5uYW1lXSA9IHByb3A7XG4gICAgfVxuICB9XG4gIGNoZWNrVHJpZ2dlcnMoKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuc3R5Zm4kOC5jbGVhbkVsZW1lbnRzID0gZnVuY3Rpb24gKGVsZXMsIGtlZXBCeXBhc3Nlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB0aGlzLmNsZWFyU3R5bGVIaW50cyhlbGUpO1xuICAgIGVsZS5kaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUoKTtcbiAgICBlbGUuZGlydHlCb3VuZGluZ0JveENhY2hlKCk7XG4gICAgaWYgKCFrZWVwQnlwYXNzZXMpIHtcbiAgICAgIGVsZS5fcHJpdmF0ZS5zdHlsZSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMoc3R5bGUpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9wTmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcE5hbWVzW2pdO1xuICAgICAgICB2YXIgZWxlUHJvcCA9IHN0eWxlW3Byb3BOYW1lXTtcbiAgICAgICAgaWYgKGVsZVByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChlbGVQcm9wLmJ5cGFzcykge1xuICAgICAgICAgICAgZWxlUHJvcC5ieXBhc3NlZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlW3Byb3BOYW1lXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyB1cGRhdGVzIHRoZSB2aXN1YWwgc3R5bGUgZm9yIGFsbCBlbGVtZW50cyAodXNlZnVsIGZvciBtYW51YWwgc3R5bGUgbW9kaWZpY2F0aW9uIGFmdGVyIGluaXQpXG5zdHlmbiQ4LnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgZWxlcy51cGRhdGVTdHlsZSgpO1xufTtcblxuLy8gZGlmZlByb3BzIDogeyBuYW1lID0+IHsgcHJldiwgbmV4dCB9IH1cbnN0eWZuJDgudXBkYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoZWxlLCBkaWZmUHJvcHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBwcm9wcyA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tcHJvcGVydHknKS52YWx1ZTtcbiAgdmFyIGR1cmF0aW9uID0gZWxlLnBzdHlsZSgndHJhbnNpdGlvbi1kdXJhdGlvbicpLnBmVmFsdWU7XG4gIHZhciBkZWxheSA9IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tZGVsYXknKS5wZlZhbHVlO1xuICBpZiAocHJvcHMubGVuZ3RoID4gMCAmJiBkdXJhdGlvbiA+IDApIHtcbiAgICB2YXIgc3R5bGUgPSB7fTtcblxuICAgIC8vIGJ1aWxkIHVwIHRoZSBzdHlsZSB0byBhbmltYXRlIHRvd2FyZHNcbiAgICB2YXIgYW55UHJldiA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICB2YXIgc3R5UHJvcCA9IGVsZS5wc3R5bGUocHJvcCk7XG4gICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbcHJvcF07XG4gICAgICBpZiAoIWRpZmZQcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByZXZQcm9wID0gZGlmZlByb3AucHJldjtcbiAgICAgIHZhciBmcm9tUHJvcCA9IHByZXZQcm9wO1xuICAgICAgdmFyIHRvUHJvcCA9IGRpZmZQcm9wLm5leHQgIT0gbnVsbCA/IGRpZmZQcm9wLm5leHQgOiBzdHlQcm9wO1xuICAgICAgdmFyIGRpZmYgPSBmYWxzZTtcbiAgICAgIHZhciBpbml0VmFsID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGluaXREdCA9IDAuMDAwMDAxOyAvLyBkZWx0YSB0aW1lICUgdmFsdWUgZm9yIGluaXRWYWwgKGFsbG93cyBhbmltYXRpbmcgb3V0IG9mIGluaXQgemVybyBvcGFjaXR5KVxuXG4gICAgICBpZiAoIWZyb21Qcm9wKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zaWRlciBweCB2YWx1ZXNcbiAgICAgIGlmIChudW1iZXIkMShmcm9tUHJvcC5wZlZhbHVlKSAmJiBudW1iZXIkMSh0b1Byb3AucGZWYWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC5wZlZhbHVlIC0gZnJvbVByb3AucGZWYWx1ZTsgLy8gbm9uemVybyBpcyB0cnV0aHlcbiAgICAgICAgaW5pdFZhbCA9IGZyb21Qcm9wLnBmVmFsdWUgKyBpbml0RHQgKiBkaWZmO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIG51bWVyaWNhbCB2YWx1ZXNcbiAgICAgIH0gZWxzZSBpZiAobnVtYmVyJDEoZnJvbVByb3AudmFsdWUpICYmIG51bWJlciQxKHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IHRvUHJvcC52YWx1ZSAtIGZyb21Qcm9wLnZhbHVlOyAvLyBub256ZXJvIGlzIHRydXRoeVxuICAgICAgICBpbml0VmFsID0gZnJvbVByb3AudmFsdWUgKyBpbml0RHQgKiBkaWZmO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIGNvbG91ciB2YWx1ZXNcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXkoZnJvbVByb3AudmFsdWUpICYmIGFycmF5KHRvUHJvcC52YWx1ZSkpIHtcbiAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF0gfHwgZnJvbVByb3AudmFsdWVbMV0gIT09IHRvUHJvcC52YWx1ZVsxXSB8fCBmcm9tUHJvcC52YWx1ZVsyXSAhPT0gdG9Qcm9wLnZhbHVlWzJdO1xuICAgICAgICBpbml0VmFsID0gZnJvbVByb3Auc3RyVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRoZSBwcmV2aW91cyB2YWx1ZSBpcyBnb29kIGZvciBhbiBhbmltYXRpb24gb25seSBpZiBpdCdzIGRpZmZlcmVudFxuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgc3R5bGVbcHJvcF0gPSB0b1Byb3Auc3RyVmFsdWU7IC8vIHRvIHZhbFxuICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKGVsZSwgcHJvcCwgaW5pdFZhbCk7IC8vIGZyb20gdmFsXG4gICAgICAgIGFueVByZXYgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gZW5kIGlmIHByb3BzIGFsbG93IGFuaVxuXG4gICAgLy8gY2FuJ3QgdHJhbnNpdGlvbiBpZiB0aGVyZSdzIG5vdGhpbmcgcHJldmlvdXMgdG8gdHJhbnNpdGlvbiBmcm9tXG4gICAgaWYgKCFhbnlQcmV2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9wLnRyYW5zaXRpb25pbmcgPSB0cnVlO1xuICAgIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGlmIChkZWxheSA+IDApIHtcbiAgICAgICAgZWxlLmRlbGF5QW5pbWF0aW9uKGRlbGF5KS5wbGF5KCkucHJvbWlzZSgpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZWxlLmFuaW1hdGlvbih7XG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6IGVsZS5wc3R5bGUoJ3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uJykudmFsdWUsXG4gICAgICAgIHF1ZXVlOiBmYWxzZVxuICAgICAgfSkucGxheSgpLnByb21pc2UoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGlmKCAhaXNCeXBhc3MgKXtcbiAgICAgIHNlbGYucmVtb3ZlQnlwYXNzZXMoZWxlLCBwcm9wcyk7XG4gICAgICBlbGUuZW1pdEFuZE5vdGlmeSgnc3R5bGUnKTtcbiAgICAgIC8vIH1cblxuICAgICAgX3AudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKF9wLnRyYW5zaXRpb25pbmcpIHtcbiAgICB0aGlzLnJlbW92ZUJ5cGFzc2VzKGVsZSwgcHJvcHMpO1xuICAgIGVsZS5lbWl0QW5kTm90aWZ5KCdzdHlsZScpO1xuICAgIF9wLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgfVxufTtcbnN0eWZuJDguY2hlY2tUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBnZXRUcmlnZ2VyLCBvblRyaWdnZXIpIHtcbiAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbbmFtZV07XG4gIHZhciB0cmlnZ2VyQ2hlY2sgPSBnZXRUcmlnZ2VyKHByb3ApO1xuICBpZiAoZWxlLnJlbW92ZWQoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHJpZ2dlckNoZWNrICE9IG51bGwgJiYgdHJpZ2dlckNoZWNrKGZyb21WYWx1ZSwgdG9WYWx1ZSwgZWxlKSkge1xuICAgIG9uVHJpZ2dlcihwcm9wKTtcbiAgfVxufTtcbnN0eWZuJDguY2hlY2taT3JkZXJUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHRoaXMuY2hlY2tUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiBwcm9wLnRyaWdnZXJzWk9yZGVyO1xuICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMuX3ByaXZhdGUuY3kubm90aWZ5KCd6b3JkZXInLCBlbGUpO1xuICB9KTtcbn07XG5zdHlmbiQ4LmNoZWNrQm91bmRzVHJpZ2dlciA9IGZ1bmN0aW9uIChlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICB0aGlzLmNoZWNrVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcC50cmlnZ2Vyc0JvdW5kcztcbiAgfSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICBlbGUuZGlydHlDb21wb3VuZEJvdW5kc0NhY2hlKCk7XG4gICAgZWxlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICB9KTtcbn07XG5zdHlmbiQ4LmNoZWNrQ29ubmVjdGVkRWRnZXNCb3VuZHNUcmlnZ2VyID0gZnVuY3Rpb24gKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKSB7XG4gIHRoaXMuY2hlY2tUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlLCBmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiBwcm9wLnRyaWdnZXJzQm91bmRzT2ZDb25uZWN0ZWRFZGdlcztcbiAgfSwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICBlbGUuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICBlZGdlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgIH0pO1xuICB9KTtcbn07XG5zdHlmbiQ4LmNoZWNrUGFyYWxsZWxFZGdlc0JvdW5kc1RyaWdnZXIgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgdGhpcy5jaGVja1RyaWdnZXIoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuIHByb3AudHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsRWRnZXM7XG4gIH0sIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZWxlLnBhcmFsbGVsRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChwbGxFZGdlKSB7XG4gICAgICBwbGxFZGdlLmRpcnR5Qm91bmRpbmdCb3hDYWNoZSgpO1xuICAgIH0pO1xuICB9KTtcbn07XG5zdHlmbiQ4LmNoZWNrVHJpZ2dlcnMgPSBmdW5jdGlvbiAoZWxlLCBuYW1lLCBmcm9tVmFsdWUsIHRvVmFsdWUpIHtcbiAgZWxlLmRpcnR5U3R5bGVDYWNoZSgpO1xuICB0aGlzLmNoZWNrWk9yZGVyVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSk7XG4gIHRoaXMuY2hlY2tCb3VuZHNUcmlnZ2VyKGVsZSwgbmFtZSwgZnJvbVZhbHVlLCB0b1ZhbHVlKTtcbiAgdGhpcy5jaGVja0Nvbm5lY3RlZEVkZ2VzQm91bmRzVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSk7XG4gIHRoaXMuY2hlY2tQYXJhbGxlbEVkZ2VzQm91bmRzVHJpZ2dlcihlbGUsIG5hbWUsIGZyb21WYWx1ZSwgdG9WYWx1ZSk7XG59O1xuXG52YXIgc3R5Zm4kNyA9IHt9O1xuXG4vLyBieXBhc3NlcyBhcmUgYXBwbGllZCB0byBhbiBleGlzdGluZyBzdHlsZSBvbiBhbiBlbGVtZW50LCBhbmQganVzdCB0YWNrZWQgb24gdGVtcG9yYXJpbHlcbi8vIHJldHVybnMgdHJ1ZSBpZmYgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWwgZm9yIGF0IGxlYXN0IDEgc3BlY2lmaWVkIHByb3BlcnR5XG5zdHlmbiQ3LmFwcGx5QnlwYXNzID0gZnVuY3Rpb24gKGVsZXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwcm9wcyA9IFtdO1xuICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gIC8vIHB1dCBhbGwgdGhlIHByb3BlcnRpZXMgKGNhbiBzcGVjaWZ5IG9uZSBvciBtYW55KSBpbiBhbiBhcnJheSBhZnRlciBwYXJzaW5nIHRoZW1cbiAgaWYgKG5hbWUgPT09ICcqJyB8fCBuYW1lID09PSAnKionKSB7XG4gICAgLy8gYXBwbHkgdG8gYWxsIHByb3BlcnR5IG5hbWVzXG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKF9uYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChwYXJzZWRQcm9wKSB7XG4gICAgICAgICAgcHJvcHMucHVzaChwYXJzZWRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICAvLyB0aGVuIHBhcnNlIHRoZSBzaW5nbGUgcHJvcGVydHlcbiAgICB2YXIgX3BhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICBpZiAoX3BhcnNlZFByb3ApIHtcbiAgICAgIHByb3BzLnB1c2goX3BhcnNlZFByb3ApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwbGFpbk9iamVjdChuYW1lKSkge1xuICAgIC8vIHRoZW4gcGFyc2UgZWFjaCBwcm9wZXJ0eVxuICAgIHZhciBzcGVjaWZpZWRQcm9wcyA9IG5hbWU7XG4gICAgdXBkYXRlVHJhbnNpdGlvbnMgPSB2YWx1ZTtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhzcGVjaWZpZWRQcm9wcyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5hbWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9uYW1lMiA9IG5hbWVzW19pXTtcbiAgICAgIHZhciBfdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1tfbmFtZTJdO1xuICAgICAgaWYgKF92YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgIF92YWx1ZSA9IHNwZWNpZmllZFByb3BzW2Rhc2gyY2FtZWwoX25hbWUyKV07XG4gICAgICB9XG4gICAgICBpZiAoX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9wYXJzZWRQcm9wMiA9IHRoaXMucGFyc2UoX25hbWUyLCBfdmFsdWUsIHRydWUpO1xuICAgICAgICBpZiAoX3BhcnNlZFByb3AyKSB7XG4gICAgICAgICAgcHJvcHMucHVzaChfcGFyc2VkUHJvcDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGNhbid0IGRvIGFueXRoaW5nIHdpdGhvdXQgd2VsbCBkZWZpbmVkIHByb3BlcnRpZXNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB3ZSd2ZSBmYWlsZWQgaWYgdGhlcmUgYXJlIG5vIHZhbGlkIHByb3BlcnRpZXNcbiAgaWYgKHByb3BzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG5vdywgYXBwbHkgdGhlIGJ5cGFzcyBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50c1xuICB2YXIgcmV0ID0gZmFsc2U7IC8vIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzdWNjZXNmdWwgYnlwYXNzIGFwcGxpZWRcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgLy8gZm9yIGVhY2ggZWxlXG4gICAgdmFyIGVsZSA9IGVsZXNbX2kyXTtcbiAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgdmFyIGRpZmZQcm9wID0gdW5kZWZpbmVkO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vIGZvciBlYWNoIHByb3BcbiAgICAgIHZhciBfcHJvcCA9IHByb3BzW2pdO1xuICAgICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUoX3Byb3AubmFtZSk7XG4gICAgICAgIGRpZmZQcm9wID0gZGlmZlByb3BzW19wcm9wLm5hbWVdID0ge1xuICAgICAgICAgIHByZXY6IHByZXZQcm9wXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXQgPSB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBjb3B5KF9wcm9wKSkgfHwgcmV0O1xuICAgICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICAgIGRpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKF9wcm9wLm5hbWUpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICBpZiAocmV0KSB7XG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZVRyYW5zaXRpb25zKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyk7XG4gICAgfVxuICB9IC8vIGZvciBlbGVzXG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8vIG9ubHkgdXNlZnVsIGluIHNwZWNpZmljIGNhc2VzIGxpa2UgYW5pbWF0aW9uXG5zdHlmbiQ3Lm92ZXJyaWRlQnlwYXNzID0gZnVuY3Rpb24gKGVsZXMsIG5hbWUsIHZhbHVlKSB7XG4gIG5hbWUgPSBjYW1lbDJkYXNoKG5hbWUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVtuYW1lXTtcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcGVydGllc1tuYW1lXS50eXBlO1xuICAgIHZhciBpc0NvbG9yID0gdHlwZS5jb2xvcjtcbiAgICB2YXIgaXNNdWx0aSA9IHR5cGUubXV0aXBsZTtcbiAgICB2YXIgb2xkVmFsdWUgPSAhcHJvcCA/IG51bGwgOiBwcm9wLnBmVmFsdWUgIT0gbnVsbCA/IHByb3AucGZWYWx1ZSA6IHByb3AudmFsdWU7XG4gICAgaWYgKCFwcm9wIHx8ICFwcm9wLmJ5cGFzcykge1xuICAgICAgLy8gbmVlZCBhIGJ5cGFzcyBpZiBvbmUgZG9lc24ndCBleGlzdFxuICAgICAgdGhpcy5hcHBseUJ5cGFzcyhlbGUsIG5hbWUsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvcC52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHByb3AucGZWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHByb3AucGZWYWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ29sb3IpIHtcbiAgICAgICAgcHJvcC5zdHJWYWx1ZSA9ICdyZ2IoJyArIHZhbHVlLmpvaW4oJywnKSArICcpJztcbiAgICAgIH0gZWxzZSBpZiAoaXNNdWx0aSkge1xuICAgICAgICBwcm9wLnN0clZhbHVlID0gdmFsdWUuam9pbignICcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5zdHJWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoZWxlKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1RyaWdnZXJzKGVsZSwgbmFtZSwgb2xkVmFsdWUsIHZhbHVlKTtcbiAgfVxufTtcbnN0eWZuJDcucmVtb3ZlQWxsQnlwYXNzZXMgPSBmdW5jdGlvbiAoZWxlcywgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMucmVtb3ZlQnlwYXNzZXMoZWxlcywgdGhpcy5wcm9wZXJ0eU5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyk7XG59O1xuc3R5Zm4kNy5yZW1vdmVCeXBhc3NlcyA9IGZ1bmN0aW9uIChlbGVzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMpIHtcbiAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbal07XG4gICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcHNbaV07XG4gICAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tuYW1lXTtcbiAgICAgIHZhciBwcmV2UHJvcCA9IGVsZS5wc3R5bGUocHJvcC5uYW1lKTtcbiAgICAgIGlmICghcHJldlByb3AgfHwgIXByZXZQcm9wLmJ5cGFzcykge1xuICAgICAgICAvLyBpZiBhIGJ5cGFzcyBkb2Vzbid0IGV4aXN0IGZvciB0aGUgcHJvcCwgbm90aGluZyBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gJyc7IC8vIGVtcHR5ID0+IHJlbW92ZSBieXBhc3NcbiAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbcHJvcC5uYW1lXSA9IHtcbiAgICAgICAgcHJldjogcHJldlByb3BcbiAgICAgIH07XG4gICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBwYXJzZWRQcm9wKTtcbiAgICAgIGRpZmZQcm9wLm5leHQgPSBlbGUucHN0eWxlKHByb3AubmFtZSk7XG4gICAgfSAvLyBmb3IgcHJvcHNcblxuICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyhlbGUpO1xuICAgIGlmICh1cGRhdGVUcmFuc2l0aW9ucykge1xuICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyhlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MpO1xuICAgIH1cbiAgfSAvLyBmb3IgZWxlc1xufTtcblxudmFyIHN0eWZuJDYgPSB7fTtcblxuLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcbnN0eWZuJDYuZ2V0RW1TaXplSW5QaXhlbHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBweCA9IHRoaXMuY29udGFpbmVyQ3NzKCdmb250LXNpemUnKTtcbiAgaWYgKHB4ICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChweCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDE7IC8vIGZvciBoZWFkbGVzc1xuICB9XG59O1xuXG4vLyBnZXRzIGNzcyBwcm9wZXJ0eSBmcm9tIHRoZSBjb3JlIGNvbnRhaW5lclxuc3R5Zm4kNi5jb250YWluZXJDc3MgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IGN5LndpbmRvdygpO1xuICBpZiAoY29udGFpbmVyV2luZG93ICYmIGRvbUVsZW1lbnQgJiYgY29udGFpbmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tRWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSk7XG4gIH1cbn07XG5cbnZhciBzdHlmbiQ1ID0ge307XG5cbi8vIGdldHMgdGhlIHJlbmRlcmVkIHN0eWxlIGZvciBhbiBlbGVtZW50XG5zdHlmbiQ1LmdldFJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wKSB7XG4gIGlmIChwcm9wKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgcHJvcCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmF3U3R5bGUoZWxlLCB0cnVlKTtcbiAgfVxufTtcblxuLy8gZ2V0cyB0aGUgcmF3IHN0eWxlIGZvciBhbiBlbGVtZW50XG5zdHlmbiQ1LmdldFJhd1N0eWxlID0gZnVuY3Rpb24gKGVsZSwgaXNSZW5kZXJlZFZhbCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmIChlbGUpIHtcbiAgICB2YXIgcnN0eWxlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW2ldO1xuICAgICAgdmFyIHZhbCA9IHNlbGYuZ2V0U3R5bGVQcm9wZXJ0eVZhbHVlKGVsZSwgcHJvcC5uYW1lLCBpc1JlbmRlcmVkVmFsKTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICByc3R5bGVbcHJvcC5uYW1lXSA9IHZhbDtcbiAgICAgICAgcnN0eWxlW2Rhc2gyY2FtZWwocHJvcC5uYW1lKV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByc3R5bGU7XG4gIH1cbn07XG5zdHlmbiQ1LmdldEluZGV4ZWRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIHByb3BlcnR5LCBzdWJwcm9wZXJ0eSwgaW5kZXgpIHtcbiAgdmFyIHBzdHlsZSA9IGVsZS5wc3R5bGUocHJvcGVydHkpW3N1YnByb3BlcnR5XVtpbmRleF07XG4gIHJldHVybiBwc3R5bGUgIT0gbnVsbCA/IHBzdHlsZSA6IGVsZS5jeSgpLnN0eWxlKCkuZ2V0RGVmYXVsdFByb3BlcnR5KHByb3BlcnR5KVtzdWJwcm9wZXJ0eV1bMF07XG59O1xuc3R5Zm4kNS5nZXRTdHlsZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbiAoZWxlLCBwcm9wTmFtZSwgaXNSZW5kZXJlZFZhbCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gIGlmIChlbGUpIHtcbiAgICB2YXIgcHJvcCA9IHNlbGYucHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgaWYgKHByb3AuYWxpYXMpIHtcbiAgICAgIHByb3AgPSBwcm9wLnBvaW50c1RvO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICB2YXIgc3R5bGVQcm9wID0gZWxlLnBzdHlsZShwcm9wLm5hbWUpO1xuICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0eWxlUHJvcC52YWx1ZSxcbiAgICAgICAgdW5pdHMgPSBzdHlsZVByb3AudW5pdHMsXG4gICAgICAgIHN0clZhbHVlID0gc3R5bGVQcm9wLnN0clZhbHVlO1xuICAgICAgaWYgKGlzUmVuZGVyZWRWYWwgJiYgdHlwZS5udW1iZXIgJiYgdmFsdWUgIT0gbnVsbCAmJiBudW1iZXIkMSh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIHpvb20gPSBlbGUuY3koKS56b29tKCk7XG4gICAgICAgIHZhciBnZXRSZW5kZXJlZFZhbHVlID0gZnVuY3Rpb24gZ2V0UmVuZGVyZWRWYWx1ZSh2YWwpIHtcbiAgICAgICAgICByZXR1cm4gdmFsICogem9vbTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFZhbHVlU3RyaW5nV2l0aFVuaXRzID0gZnVuY3Rpb24gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModmFsLCB1bml0cykge1xuICAgICAgICAgIHJldHVybiBnZXRSZW5kZXJlZFZhbHVlKHZhbCkgKyB1bml0cztcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGlzQXJyYXlWYWx1ZSA9IGFycmF5KHZhbHVlKTtcbiAgICAgICAgdmFyIGhhdmVVbml0cyA9IGlzQXJyYXlWYWx1ZSA/IHVuaXRzLmV2ZXJ5KGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgcmV0dXJuIHUgIT0gbnVsbDtcbiAgICAgICAgfSkgOiB1bml0cyAhPSBudWxsO1xuICAgICAgICBpZiAoaGF2ZVVuaXRzKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModiwgdW5pdHNbaV0pO1xuICAgICAgICAgICAgfSkuam9pbignICcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VmFsdWVTdHJpbmdXaXRoVW5pdHModmFsdWUsIHVuaXRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXlWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nKHYpID8gdiA6ICcnICsgZ2V0UmVuZGVyZWRWYWx1ZSh2KTtcbiAgICAgICAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgZ2V0UmVuZGVyZWRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0clZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN0clZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcbnN0eWZuJDUuZ2V0QW5pbWF0aW9uU3RhcnRTdHlsZSA9IGZ1bmN0aW9uIChlbGUsIGFuaVByb3BzKSB7XG4gIHZhciByc3R5bGUgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmlQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhbmlQcm9wID0gYW5pUHJvcHNbaV07XG4gICAgdmFyIG5hbWUgPSBhbmlQcm9wLm5hbWU7XG4gICAgdmFyIHN0eWxlUHJvcCA9IGVsZS5wc3R5bGUobmFtZSk7XG4gICAgaWYgKHN0eWxlUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0aGVuIG1ha2UgYSBwcm9wIG9mIGl0XG4gICAgICBpZiAocGxhaW5PYmplY3Qoc3R5bGVQcm9wKSkge1xuICAgICAgICBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHN0eWxlUHJvcC5zdHJWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHN0eWxlUHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdHlsZVByb3ApIHtcbiAgICAgIHJzdHlsZVtuYW1lXSA9IHN0eWxlUHJvcDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJzdHlsZTtcbn07XG5zdHlmbiQ1LmdldFByb3BzTGlzdCA9IGZ1bmN0aW9uIChwcm9wc09iaikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByc3R5bGUgPSBbXTtcbiAgdmFyIHN0eWxlID0gcHJvcHNPYmo7XG4gIHZhciBwcm9wcyA9IHNlbGYucHJvcGVydGllcztcbiAgaWYgKHN0eWxlKSB7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMoc3R5bGUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgdmFsID0gc3R5bGVbbmFtZV07XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW25hbWVdIHx8IHByb3BzW2NhbWVsMmRhc2gobmFtZSldO1xuICAgICAgdmFyIHN0eWxlUHJvcCA9IHRoaXMucGFyc2UocHJvcC5uYW1lLCB2YWwpO1xuICAgICAgaWYgKHN0eWxlUHJvcCkge1xuICAgICAgICByc3R5bGUucHVzaChzdHlsZVByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcnN0eWxlO1xufTtcbnN0eWZuJDUuZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoID0gZnVuY3Rpb24gKGVsZSwgcHJvcE5hbWVzLCBzZWVkKSB7XG4gIHZhciBoYXNoID0gc2VlZC5zbGljZSgpO1xuICB2YXIgbmFtZSwgdmFsLCBzdHJWYWwsIGNoVmFsO1xuICB2YXIgaSwgajtcbiAgZm9yIChpID0gMDsgaSA8IHByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIG5hbWUgPSBwcm9wTmFtZXNbaV07XG4gICAgdmFsID0gZWxlLnBzdHlsZShuYW1lLCBmYWxzZSk7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKHZhbC5wZlZhbHVlICE9IG51bGwpIHtcbiAgICAgIGhhc2hbMF0gPSBoYXNoSW50KGNoVmFsLCBoYXNoWzBdKTtcbiAgICAgIGhhc2hbMV0gPSBoYXNoSW50QWx0KGNoVmFsLCBoYXNoWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyVmFsID0gdmFsLnN0clZhbHVlO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHN0clZhbC5sZW5ndGg7IGorKykge1xuICAgICAgICBjaFZhbCA9IHN0clZhbC5jaGFyQ29kZUF0KGopO1xuICAgICAgICBoYXNoWzBdID0gaGFzaEludChjaFZhbCwgaGFzaFswXSk7XG4gICAgICAgIGhhc2hbMV0gPSBoYXNoSW50QWx0KGNoVmFsLCBoYXNoWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59O1xuc3R5Zm4kNS5nZXRQcm9wZXJ0aWVzSGFzaCA9IHN0eWZuJDUuZ2V0Tm9uRGVmYXVsdFByb3BlcnRpZXNIYXNoO1xuXG52YXIgc3R5Zm4kNCA9IHt9O1xuc3R5Zm4kNC5hcHBlbmRGcm9tSnNvbiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb250ZXh0ID0ganNvbltpXTtcbiAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGNvbnRleHQuc3R5bGUgfHwgY29udGV4dC5jc3M7XG4gICAgdmFyIG5hbWVzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmFtZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuYW1lID0gbmFtZXNbal07XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wc1tuYW1lXTtcbiAgICAgIHN0eWxlLmNzcyhuYW1lLCB2YWx1ZSk7IC8vIGFwcGx5IHByb3BlcnR5XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZTtcbn07XG5cbi8vIGFjY2Vzc2libGUgY3kuc3R5bGUoKSBmdW5jdGlvblxuc3R5Zm4kNC5mcm9tSnNvbiA9IGZ1bmN0aW9uIChqc29uKSB7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gIHN0eWxlLmFwcGVuZEZyb21Kc29uKGpzb24pO1xuICByZXR1cm4gc3R5bGU7XG59O1xuXG4vLyBnZXQganNvbiBmcm9tIGN5LnN0eWxlKCkgYXBpXG5zdHlmbiQ0Lmpzb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBqc29uID0gW107XG4gIGZvciAodmFyIGkgPSB0aGlzLmRlZmF1bHRMZW5ndGg7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN4dCA9IHRoaXNbaV07XG4gICAgdmFyIHNlbGVjdG9yID0gY3h0LnNlbGVjdG9yO1xuICAgIHZhciBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzO1xuICAgIHZhciBjc3MgPSB7fTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgY3NzW3Byb3AubmFtZV0gPSBwcm9wLnN0clZhbHVlO1xuICAgIH1cbiAgICBqc29uLnB1c2goe1xuICAgICAgc2VsZWN0b3I6ICFzZWxlY3RvciA/ICdjb3JlJyA6IHNlbGVjdG9yLnRvU3RyaW5nKCksXG4gICAgICBzdHlsZTogY3NzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGpzb247XG59O1xuXG52YXIgc3R5Zm4kMyA9IHt9O1xuc3R5Zm4kMy5hcHBlbmRGcm9tU3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgdmFyIHNlbEFuZEJsb2NrU3RyO1xuICB2YXIgYmxvY2tSZW07XG4gIHZhciBwcm9wQW5kVmFsU3RyO1xuXG4gIC8vIHJlbW92ZSBjb21tZW50cyBmcm9tIHRoZSBzdHlsZSBzdHJpbmdcbiAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1svXVsqXShcXHN8LikrP1sqXVsvXS9nLCAnJyk7XG4gIGZ1bmN0aW9uIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpIHtcbiAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBzZWxlY3RvciBhbmQgYmxvY2sgZnJvbSB0aGUgcmVtYWluaW5nIHRleHQgdG8gcGFyc2VcbiAgICBpZiAocmVtYWluaW5nLmxlbmd0aCA+IHNlbEFuZEJsb2NrU3RyLmxlbmd0aCkge1xuICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cihzZWxBbmRCbG9ja1N0ci5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1haW5pbmcgPSAnJztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKSB7XG4gICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgcHJvcGVydHkgYW5kIHZhbHVlIGZyb20gdGhlIHJlbWFpbmluZyBibG9jayB0ZXh0IHRvIHBhcnNlXG4gICAgaWYgKGJsb2NrUmVtLmxlbmd0aCA+IHByb3BBbmRWYWxTdHIubGVuZ3RoKSB7XG4gICAgICBibG9ja1JlbSA9IGJsb2NrUmVtLnN1YnN0cihwcm9wQW5kVmFsU3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJsb2NrUmVtID0gJyc7XG4gICAgfVxuICB9XG4gIGZvciAoOzspIHtcbiAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKTtcbiAgICBpZiAobm90aGluZ0xlZnRUb1BhcnNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHNlbEFuZEJsb2NrID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKigoPzoufFxccykrPylcXHMqXFx7KCg/Oi58XFxzKSs/KVxcfS8pO1xuICAgIGlmICghc2VsQW5kQmxvY2spIHtcbiAgICAgIHdhcm4oJ0hhbHRpbmcgc3R5bGVzaGVldCBwYXJzaW5nOiBTdHJpbmcgc3R5bGVzaGVldCBjb250YWlucyBtb3JlIHRvIHBhcnNlIGJ1dCBubyBzZWxlY3RvciBhbmQgYmxvY2sgZm91bmQgaW46ICcgKyByZW1haW5pbmcpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNlbEFuZEJsb2NrU3RyID0gc2VsQW5kQmxvY2tbMF07XG5cbiAgICAvLyBwYXJzZSB0aGUgc2VsZWN0b3JcbiAgICB2YXIgc2VsZWN0b3JTdHIgPSBzZWxBbmRCbG9ja1sxXTtcbiAgICBpZiAoc2VsZWN0b3JTdHIgIT09ICdjb3JlJykge1xuICAgICAgdmFyIHNlbGVjdG9yID0gbmV3IFNlbGVjdG9yKHNlbGVjdG9yU3RyKTtcbiAgICAgIGlmIChzZWxlY3Rvci5pbnZhbGlkKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgc2VsZWN0b3IgZm91bmQgaW4gc3RyaW5nIHN0eWxlc2hlZXQ6ICcgKyBzZWxlY3RvclN0cik7XG5cbiAgICAgICAgLy8gc2tpcCB0aGlzIHNlbGVjdG9yIGFuZCBibG9ja1xuICAgICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgdGhlIGJsb2NrIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICAgIHZhciBibG9ja1N0ciA9IHNlbEFuZEJsb2NrWzJdO1xuICAgIHZhciBpbnZhbGlkQmxvY2sgPSBmYWxzZTtcbiAgICBibG9ja1JlbSA9IGJsb2NrU3RyO1xuICAgIHZhciBwcm9wcyA9IFtdO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBfbm90aGluZ0xlZnRUb1BhcnNlID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqJC8pO1xuICAgICAgaWYgKF9ub3RoaW5nTGVmdFRvUGFyc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcEFuZFZhbCA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiguKz8pXFxzKjpcXHMqKC4rPykoPzpcXHMqO3xcXHMqJCkvKTtcbiAgICAgIGlmICghcHJvcEFuZFZhbCkge1xuICAgICAgICB3YXJuKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIGZvcm1hdHRpbmcgb2Ygc3R5bGUgcHJvcGVydHkgYW5kIHZhbHVlIGRlZmluaXRpb25zIGZvdW5kIGluOicgKyBibG9ja1N0cik7XG4gICAgICAgIGludmFsaWRCbG9jayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcHJvcEFuZFZhbFN0ciA9IHByb3BBbmRWYWxbMF07XG4gICAgICB2YXIgcHJvcFN0ciA9IHByb3BBbmRWYWxbMV07XG4gICAgICB2YXIgdmFsU3RyID0gcHJvcEFuZFZhbFsyXTtcbiAgICAgIHZhciBwcm9wID0gc2VsZi5wcm9wZXJ0aWVzW3Byb3BTdHJdO1xuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IG5hbWUgaW46ICcgKyBwcm9wQW5kVmFsU3RyKTtcblxuICAgICAgICAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHBhcnNlZFByb3AgPSBzdHlsZS5wYXJzZShwcm9wU3RyLCB2YWxTdHIpO1xuICAgICAgaWYgKCFwYXJzZWRQcm9wKSB7XG4gICAgICAgIHdhcm4oJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IGRlZmluaXRpb24gaW46ICcgKyBwcm9wQW5kVmFsU3RyKTtcblxuICAgICAgICAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcHJvcHMucHVzaCh7XG4gICAgICAgIG5hbWU6IHByb3BTdHIsXG4gICAgICAgIHZhbDogdmFsU3RyXG4gICAgICB9KTtcbiAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgfVxuICAgIGlmIChpbnZhbGlkQmxvY2spIHtcbiAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gcHV0IHRoZSBwYXJzZWQgYmxvY2sgaW4gdGhlIHN0eWxlXG4gICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBfcHJvcCA9IHByb3BzW2ldO1xuICAgICAgc3R5bGUuY3NzKF9wcm9wLm5hbWUsIF9wcm9wLnZhbCk7XG4gICAgfVxuICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICB9XG4gIHJldHVybiBzdHlsZTtcbn07XG5zdHlmbiQzLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHZhciBzdHlsZSA9IHRoaXM7XG4gIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG4gIHN0eWxlLmFwcGVuZEZyb21TdHJpbmcoc3RyaW5nKTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxudmFyIHN0eWZuJDIgPSB7fTtcbihmdW5jdGlvbiAoKSB7XG4gIHZhciBudW1iZXIkMSA9IG51bWJlcjtcbiAgdmFyIHJnYmEgPSByZ2JhTm9CYWNrUmVmcztcbiAgdmFyIGhzbGEgPSBoc2xhTm9CYWNrUmVmcztcbiAgdmFyIGhleDMkMSA9IGhleDM7XG4gIHZhciBoZXg2JDEgPSBoZXg2O1xuICB2YXIgZGF0YSA9IGZ1bmN0aW9uIGRhdGEocHJlZml4KSB7XG4gICAgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKFxcXFxzKihbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwpJCc7XG4gIH07XG4gIHZhciBtYXBEYXRhID0gZnVuY3Rpb24gbWFwRGF0YShwcmVmaXgpIHtcbiAgICB2YXIgbWFwQXJnID0gbnVtYmVyJDEgKyAnfFxcXFx3K3wnICsgcmdiYSArICd8JyArIGhzbGEgKyAnfCcgKyBoZXgzJDEgKyAnfCcgKyBoZXg2JDE7XG4gICAgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKChbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBtYXBBcmcgKyAnKVxcXFwpJCc7XG4gIH07XG4gIHZhciB1cmxSZWdleGVzID0gWydedXJsXFxcXHMqXFxcXChcXFxccypbXFwnXCJdPyguKz8pW1xcJ1wiXT9cXFxccypcXFxcKSQnLCAnXihub25lKSQnLCAnXiguKykkJ107XG5cbiAgLy8gZWFjaCB2aXN1YWwgc3R5bGUgcHJvcGVydHkgaGFzIGEgdHlwZSBhbmQgbmVlZHMgdG8gYmUgdmFsaWRhdGVkIGFjY29yZGluZyB0byBpdFxuICBzdHlmbiQyLnR5cGVzID0ge1xuICAgIHRpbWU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHVuaXRzOiAnc3xtcycsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAnbXMnXG4gICAgfSxcbiAgICBwZXJjZW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEwMCxcbiAgICAgIHVuaXRzOiAnJScsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAnJSdcbiAgICB9LFxuICAgIHBlcmNlbnRhZ2VzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEwMCxcbiAgICAgIHVuaXRzOiAnJScsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAnJScsXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgemVyb09uZU51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIHplcm9PbmVOdW1iZXJzOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBtYXg6IDEsXG4gICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBuT25lT25lTnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IC0xLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIG5vbk5lZ2F0aXZlSW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBpbnRlZ2VyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIG5vbk5lZ2F0aXZlTnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICB1bml0bGVzczogdHJ1ZVxuICAgIH0sXG4gICAgcG9zaXRpb246IHtcbiAgICAgIGVudW1zOiBbJ3BhcmVudCcsICdvcmlnaW4nXVxuICAgIH0sXG4gICAgbm9kZVNpemU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIGVudW1zOiBbJ2xhYmVsJ11cbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIG51bWJlcnM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRsZXNzOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIHBvc2l0aXZlTnVtYmVyOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0bGVzczogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHN0cmljdE1pbjogdHJ1ZVxuICAgIH0sXG4gICAgc2l6ZToge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbWluOiAwXG4gICAgfSxcbiAgICBiaWRpcmVjdGlvbmFsU2l6ZToge1xuICAgICAgbnVtYmVyOiB0cnVlXG4gICAgfSxcbiAgICAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICBiaWRpcmVjdGlvbmFsU2l6ZU1heWJlUGVyY2VudDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgYWxsb3dQZXJjZW50OiB0cnVlXG4gICAgfSxcbiAgICAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICBiaWRpcmVjdGlvbmFsU2l6ZXM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICAvLyBhbGxvd3MgbmVnYXRpdmVcbiAgICBzaXplTWF5YmVQZXJjZW50OiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWVcbiAgICB9LFxuICAgIGF4aXNEaXJlY3Rpb246IHtcbiAgICAgIGVudW1zOiBbJ2hvcml6b250YWwnLCAnbGVmdHdhcmQnLCAncmlnaHR3YXJkJywgJ3ZlcnRpY2FsJywgJ3Vwd2FyZCcsICdkb3dud2FyZCcsICdhdXRvJ11cbiAgICB9LFxuICAgIGF4aXNEaXJlY3Rpb25FeHBsaWNpdDoge1xuICAgICAgZW51bXM6IFsnbGVmdHdhcmQnLCAncmlnaHR3YXJkJywgJ3Vwd2FyZCcsICdkb3dud2FyZCddXG4gICAgfSxcbiAgICBheGlzRGlyZWN0aW9uUHJpbWFyeToge1xuICAgICAgZW51bXM6IFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddXG4gICAgfSxcbiAgICBwYWRkaW5nUmVsYXRpdmVUbzoge1xuICAgICAgZW51bXM6IFsnd2lkdGgnLCAnaGVpZ2h0JywgJ2F2ZXJhZ2UnLCAnbWluJywgJ21heCddXG4gICAgfSxcbiAgICBiZ1dIOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICBtaW46IDAsXG4gICAgICBhbGxvd1BlcmNlbnQ6IHRydWUsXG4gICAgICBlbnVtczogWydhdXRvJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdQb3M6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIGFsbG93UGVyY2VudDogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBiZ1JlbGF0aXZlVG86IHtcbiAgICAgIGVudW1zOiBbJ2lubmVyJywgJ2luY2x1ZGUtcGFkZGluZyddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnUmVwZWF0OiB7XG4gICAgICBlbnVtczogWydyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCAnbm8tcmVwZWF0J10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdGaXQ6IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAnY29udGFpbicsICdjb3ZlciddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnQ3Jvc3NPcmlnaW46IHtcbiAgICAgIGVudW1zOiBbJ2Fub255bW91cycsICd1c2UtY3JlZGVudGlhbHMnLCAnbnVsbCddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGJnQ2xpcDoge1xuICAgICAgZW51bXM6IFsnbm9uZScsICdub2RlJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgYmdDb250YWlubWVudDoge1xuICAgICAgZW51bXM6IFsnaW5zaWRlJywgJ292ZXInXSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBib3hTZWxlY3Rpb246IHtcbiAgICAgIGVudW1zOiBbJ2NvbnRhaW4nLCAnb3ZlcmxhcCcsICdub25lJ11cbiAgICB9LFxuICAgIGNvbG9yOiB7XG4gICAgICBjb2xvcjogdHJ1ZVxuICAgIH0sXG4gICAgY29sb3JzOiB7XG4gICAgICBjb2xvcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlXG4gICAgfSxcbiAgICBmaWxsOiB7XG4gICAgICBlbnVtczogWydzb2xpZCcsICdsaW5lYXItZ3JhZGllbnQnLCAncmFkaWFsLWdyYWRpZW50J11cbiAgICB9LFxuICAgIGJvb2w6IHtcbiAgICAgIGVudW1zOiBbJ3llcycsICdubyddXG4gICAgfSxcbiAgICBib29sczoge1xuICAgICAgZW51bXM6IFsneWVzJywgJ25vJ10sXG4gICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgIH0sXG4gICAgbGluZVN0eWxlOiB7XG4gICAgICBlbnVtczogWydzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJ11cbiAgICB9LFxuICAgIGxpbmVDYXA6IHtcbiAgICAgIGVudW1zOiBbJ2J1dHQnLCAncm91bmQnLCAnc3F1YXJlJ11cbiAgICB9LFxuICAgIGxpbmVQb3NpdGlvbjoge1xuICAgICAgZW51bXM6IFsnY2VudGVyJywgJ2luc2lkZScsICdvdXRzaWRlJ11cbiAgICB9LFxuICAgIGxpbmVKb2luOiB7XG4gICAgICBlbnVtczogWydyb3VuZCcsICdiZXZlbCcsICdtaXRlciddXG4gICAgfSxcbiAgICBib3JkZXJTdHlsZToge1xuICAgICAgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCcsICdkb3VibGUnXVxuICAgIH0sXG4gICAgY3VydmVTdHlsZToge1xuICAgICAgZW51bXM6IFsnYmV6aWVyJywgJ3VuYnVuZGxlZC1iZXppZXInLCAnaGF5c3RhY2snLCAnc2VnbWVudHMnLCAnc3RyYWlnaHQnLCAnc3RyYWlnaHQtdHJpYW5nbGUnLCAndGF4aScsICdyb3VuZC1zZWdtZW50cycsICdyb3VuZC10YXhpJ11cbiAgICB9LFxuICAgIHJhZGl1c1R5cGU6IHtcbiAgICAgIGVudW1zOiBbJ2FyYy1yYWRpdXMnLCAnaW5mbHVlbmNlLXJhZGl1cyddLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIGZvbnRGYW1pbHk6IHtcbiAgICAgIHJlZ2V4OiAnXihbXFxcXHctIFxcXFxcIl0rKD86XFxcXHMqLFxcXFxzKltcXFxcdy0gXFxcXFwiXSspKikkJ1xuICAgIH0sXG4gICAgZm9udFN0eWxlOiB7XG4gICAgICBlbnVtczogWydpdGFsaWMnLCAnbm9ybWFsJywgJ29ibGlxdWUnXVxuICAgIH0sXG4gICAgZm9udFdlaWdodDoge1xuICAgICAgZW51bXM6IFsnbm9ybWFsJywgJ2JvbGQnLCAnYm9sZGVyJywgJ2xpZ2h0ZXInLCAnMTAwJywgJzIwMCcsICczMDAnLCAnNDAwJywgJzUwMCcsICc2MDAnLCAnODAwJywgJzkwMCcsIDEwMCwgMjAwLCAzMDAsIDQwMCwgNTAwLCA2MDAsIDcwMCwgODAwLCA5MDBdXG4gICAgfSxcbiAgICB0ZXh0RGVjb3JhdGlvbjoge1xuICAgICAgZW51bXM6IFsnbm9uZScsICd1bmRlcmxpbmUnLCAnb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJ11cbiAgICB9LFxuICAgIHRleHRUcmFuc2Zvcm06IHtcbiAgICAgIGVudW1zOiBbJ25vbmUnLCAndXBwZXJjYXNlJywgJ2xvd2VyY2FzZSddXG4gICAgfSxcbiAgICB0ZXh0V3JhcDoge1xuICAgICAgZW51bXM6IFsnbm9uZScsICd3cmFwJywgJ2VsbGlwc2lzJ11cbiAgICB9LFxuICAgIHRleHRPdmVyZmxvd1dyYXA6IHtcbiAgICAgIGVudW1zOiBbJ3doaXRlc3BhY2UnLCAnYW55d2hlcmUnXVxuICAgIH0sXG4gICAgdGV4dEJhY2tncm91bmRTaGFwZToge1xuICAgICAgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ3JvdW5kLXJlY3RhbmdsZScsICdjaXJjbGUnXVxuICAgIH0sXG4gICAgbm9kZVNoYXBlOiB7XG4gICAgICBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJywgJ2N1dHJlY3RhbmdsZScsICdjdXQtcmVjdGFuZ2xlJywgJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJywgJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnLCAnYmFycmVsJywgJ2VsbGlwc2UnLCAndHJpYW5nbGUnLCAncm91bmQtdHJpYW5nbGUnLCAnc3F1YXJlJywgJ3BlbnRhZ29uJywgJ3JvdW5kLXBlbnRhZ29uJywgJ2hleGFnb24nLCAncm91bmQtaGV4YWdvbicsICdjb25jYXZlaGV4YWdvbicsICdjb25jYXZlLWhleGFnb24nLCAnaGVwdGFnb24nLCAncm91bmQtaGVwdGFnb24nLCAnb2N0YWdvbicsICdyb3VuZC1vY3RhZ29uJywgJ3RhZycsICdyb3VuZC10YWcnLCAnc3RhcicsICdkaWFtb25kJywgJ3JvdW5kLWRpYW1vbmQnLCAndmVlJywgJ3Job21ib2lkJywgJ3JpZ2h0LXJob21ib2lkJywgJ3BvbHlnb24nXVxuICAgIH0sXG4gICAgb3ZlcmxheVNoYXBlOiB7XG4gICAgICBlbnVtczogWydyb3VuZHJlY3RhbmdsZScsICdyb3VuZC1yZWN0YW5nbGUnLCAnZWxsaXBzZSddXG4gICAgfSxcbiAgICBjb3JuZXJSYWRpdXM6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG1pbjogMCxcbiAgICAgIHVuaXRzOiAncHh8ZW0nLFxuICAgICAgaW1wbGljaXRVbml0czogJ3B4JyxcbiAgICAgIGVudW1zOiBbJ2F1dG8nXVxuICAgIH0sXG4gICAgY29tcG91bmRJbmNsdWRlTGFiZWxzOiB7XG4gICAgICBlbnVtczogWydpbmNsdWRlJywgJ2V4Y2x1ZGUnXVxuICAgIH0sXG4gICAgYXJyb3dTaGFwZToge1xuICAgICAgZW51bXM6IFsndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICdjaXJjbGUtdHJpYW5nbGUnLCAndHJpYW5nbGUtY3Jvc3MnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ3ZlZScsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnY2hldnJvbicsICdub25lJ11cbiAgICB9LFxuICAgIGFycm93RmlsbDoge1xuICAgICAgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddXG4gICAgfSxcbiAgICBhcnJvd1dpZHRoOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0czogJyV8cHh8ZW0nLFxuICAgICAgaW1wbGljaXRVbml0czogJ3B4JyxcbiAgICAgIGVudW1zOiBbJ21hdGNoLWxpbmUnXVxuICAgIH0sXG4gICAgZGlzcGxheToge1xuICAgICAgZW51bXM6IFsnZWxlbWVudCcsICdub25lJ11cbiAgICB9LFxuICAgIHZpc2liaWxpdHk6IHtcbiAgICAgIGVudW1zOiBbJ2hpZGRlbicsICd2aXNpYmxlJ11cbiAgICB9LFxuICAgIHpDb21wb3VuZERlcHRoOiB7XG4gICAgICBlbnVtczogWydib3R0b20nLCAnb3JwaGFuJywgJ2F1dG8nLCAndG9wJ11cbiAgICB9LFxuICAgIHpJbmRleENvbXBhcmU6IHtcbiAgICAgIGVudW1zOiBbJ2F1dG8nLCAnbWFudWFsJ11cbiAgICB9LFxuICAgIHZhbGlnbjoge1xuICAgICAgZW51bXM6IFsndG9wJywgJ2NlbnRlcicsICdib3R0b20nXVxuICAgIH0sXG4gICAgaGFsaWduOiB7XG4gICAgICBlbnVtczogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddXG4gICAgfSxcbiAgICBqdXN0aWZpY2F0aW9uOiB7XG4gICAgICBlbnVtczogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcsICdhdXRvJ11cbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHN0cmluZzogdHJ1ZVxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBkYXRhKCdkYXRhJylcbiAgICB9LFxuICAgIGxheW91dERhdGE6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogZGF0YSgnbGF5b3V0RGF0YScpXG4gICAgfSxcbiAgICBzY3JhdGNoOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IGRhdGEoJ3NjcmF0Y2gnKVxuICAgIH0sXG4gICAgbWFwRGF0YToge1xuICAgICAgbWFwcGluZzogdHJ1ZSxcbiAgICAgIHJlZ2V4OiBtYXBEYXRhKCdtYXBEYXRhJylcbiAgICB9LFxuICAgIG1hcExheW91dERhdGE6IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICByZWdleDogbWFwRGF0YSgnbWFwTGF5b3V0RGF0YScpXG4gICAgfSxcbiAgICBtYXBTY3JhdGNoOiB7XG4gICAgICBtYXBwaW5nOiB0cnVlLFxuICAgICAgcmVnZXg6IG1hcERhdGEoJ21hcFNjcmF0Y2gnKVxuICAgIH0sXG4gICAgZm46IHtcbiAgICAgIG1hcHBpbmc6IHRydWUsXG4gICAgICBmbjogdHJ1ZVxuICAgIH0sXG4gICAgdXJsOiB7XG4gICAgICByZWdleGVzOiB1cmxSZWdleGVzLFxuICAgICAgc2luZ2xlUmVnZXhNYXRjaFZhbHVlOiB0cnVlXG4gICAgfSxcbiAgICB1cmxzOiB7XG4gICAgICByZWdleGVzOiB1cmxSZWdleGVzLFxuICAgICAgc2luZ2xlUmVnZXhNYXRjaFZhbHVlOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWVcbiAgICB9LFxuICAgIHByb3BMaXN0OiB7XG4gICAgICBwcm9wTGlzdDogdHJ1ZVxuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIHVuaXRzOiAnZGVnfHJhZCcsXG4gICAgICBpbXBsaWNpdFVuaXRzOiAncmFkJ1xuICAgIH0sXG4gICAgdGV4dFJvdGF0aW9uOiB7XG4gICAgICBudW1iZXI6IHRydWUsXG4gICAgICB1bml0czogJ2RlZ3xyYWQnLFxuICAgICAgaW1wbGljaXRVbml0czogJ3JhZCcsXG4gICAgICBlbnVtczogWydub25lJywgJ2F1dG9yb3RhdGUnXVxuICAgIH0sXG4gICAgcG9seWdvblBvaW50TGlzdDoge1xuICAgICAgbnVtYmVyOiB0cnVlLFxuICAgICAgbXVsdGlwbGU6IHRydWUsXG4gICAgICBldmVuTXVsdGlwbGU6IHRydWUsXG4gICAgICBtaW46IC0xLFxuICAgICAgbWF4OiAxLFxuICAgICAgdW5pdGxlc3M6IHRydWVcbiAgICB9LFxuICAgIGVkZ2VEaXN0YW5jZXM6IHtcbiAgICAgIGVudW1zOiBbJ2ludGVyc2VjdGlvbicsICdub2RlLXBvc2l0aW9uJywgJ2VuZHBvaW50cyddXG4gICAgfSxcbiAgICBlZGdlRW5kcG9pbnQ6IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgdW5pdHM6ICclfHB4fGVtfGRlZ3xyYWQnLFxuICAgICAgaW1wbGljaXRVbml0czogJ3B4JyxcbiAgICAgIGVudW1zOiBbJ2luc2lkZS10by1ub2RlJywgJ291dHNpZGUtdG8tbm9kZScsICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnLCAnb3V0c2lkZS10by1saW5lJywgJ291dHNpZGUtdG8tbGluZS1vci1sYWJlbCddLFxuICAgICAgc2luZ2xlRW51bTogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZSh2YWxBcnIsIHVuaXRzQXJyKSB7XG4gICAgICAgIHN3aXRjaCAodmFsQXJyLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIGNhbiBiZSAlIG9yIHB4IG9ubHlcbiAgICAgICAgICAgIHJldHVybiB1bml0c0FyclswXSAhPT0gJ2RlZycgJiYgdW5pdHNBcnJbMF0gIT09ICdyYWQnICYmIHVuaXRzQXJyWzFdICE9PSAnZGVnJyAmJiB1bml0c0FyclsxXSAhPT0gJ3JhZCc7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gY2FuIGJlIGVudW0sIGRlZywgb3IgcmFkIG9ubHlcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcodmFsQXJyWzBdKSB8fCB1bml0c0FyclswXSA9PT0gJ2RlZycgfHwgdW5pdHNBcnJbMF0gPT09ICdyYWQnO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGVhc2luZzoge1xuICAgICAgcmVnZXhlczogWydeKHNwcmluZylcXFxccypcXFxcKFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccypcXFxcKSQnLCAnXihjdWJpYy1iZXppZXIpXFxcXHMqXFxcXChcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIkMSArICcpXFxcXHMqLFxcXFxzKignICsgbnVtYmVyJDEgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciQxICsgJylcXFxccypcXFxcKSQnXSxcbiAgICAgIGVudW1zOiBbJ2xpbmVhcicsICdlYXNlJywgJ2Vhc2UtaW4nLCAnZWFzZS1vdXQnLCAnZWFzZS1pbi1vdXQnLCAnZWFzZS1pbi1zaW5lJywgJ2Vhc2Utb3V0LXNpbmUnLCAnZWFzZS1pbi1vdXQtc2luZScsICdlYXNlLWluLXF1YWQnLCAnZWFzZS1vdXQtcXVhZCcsICdlYXNlLWluLW91dC1xdWFkJywgJ2Vhc2UtaW4tY3ViaWMnLCAnZWFzZS1vdXQtY3ViaWMnLCAnZWFzZS1pbi1vdXQtY3ViaWMnLCAnZWFzZS1pbi1xdWFydCcsICdlYXNlLW91dC1xdWFydCcsICdlYXNlLWluLW91dC1xdWFydCcsICdlYXNlLWluLXF1aW50JywgJ2Vhc2Utb3V0LXF1aW50JywgJ2Vhc2UtaW4tb3V0LXF1aW50JywgJ2Vhc2UtaW4tZXhwbycsICdlYXNlLW91dC1leHBvJywgJ2Vhc2UtaW4tb3V0LWV4cG8nLCAnZWFzZS1pbi1jaXJjJywgJ2Vhc2Utb3V0LWNpcmMnLCAnZWFzZS1pbi1vdXQtY2lyYyddXG4gICAgfSxcbiAgICBncmFkaWVudERpcmVjdGlvbjoge1xuICAgICAgZW51bXM6IFsndG8tYm90dG9tJywgJ3RvLXRvcCcsICd0by1sZWZ0JywgJ3RvLXJpZ2h0JywgJ3RvLWJvdHRvbS1yaWdodCcsICd0by1ib3R0b20tbGVmdCcsICd0by10b3AtcmlnaHQnLCAndG8tdG9wLWxlZnQnLCAndG8tcmlnaHQtYm90dG9tJywgJ3RvLWxlZnQtYm90dG9tJywgJ3RvLXJpZ2h0LXRvcCcsICd0by1sZWZ0LXRvcCcgLy8gZGlmZmVyZW50IG9yZGVyXG4gICAgICBdXG4gICAgfSxcbiAgICBib3VuZHNFeHBhbnNpb246IHtcbiAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgIG11bHRpcGxlOiB0cnVlLFxuICAgICAgbWluOiAwLFxuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbEFycikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsQXJyLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA9PT0gMSB8fCBsZW5ndGggPT09IDIgfHwgbGVuZ3RoID09PSA0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGRpZmYgPSB7XG4gICAgemVyb05vblplcm86IGZ1bmN0aW9uIHplcm9Ob25aZXJvKHZhbDEsIHZhbDIpIHtcbiAgICAgIGlmICgodmFsMSA9PSBudWxsIHx8IHZhbDIgPT0gbnVsbCkgJiYgdmFsMSAhPT0gdmFsMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbnVsbCBjYXNlcyBjb3VsZCByZXByZXNlbnQgYW55IHZhbHVlXG4gICAgICB9XG4gICAgICBpZiAodmFsMSA9PSAwICYmIHZhbDIgIT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsMSAhPSAwICYmIHZhbDIgPT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFueTogZnVuY3Rpb24gYW55KHZhbDEsIHZhbDIpIHtcbiAgICAgIHJldHVybiB2YWwxICE9IHZhbDI7XG4gICAgfSxcbiAgICBlbXB0eU5vbkVtcHR5OiBmdW5jdGlvbiBlbXB0eU5vbkVtcHR5KHN0cjEsIHN0cjIpIHtcbiAgICAgIHZhciBlbXB0eTEgPSBlbXB0eVN0cmluZyhzdHIxKTtcbiAgICAgIHZhciBlbXB0eTIgPSBlbXB0eVN0cmluZyhzdHIyKTtcbiAgICAgIHJldHVybiBlbXB0eTEgJiYgIWVtcHR5MiB8fCAhZW1wdHkxICYmIGVtcHR5MjtcbiAgICB9XG4gIH07XG5cbiAgLy8gZGVmaW5lIHZpc3VhbCBzdHlsZSBwcm9wZXJ0aWVzXG4gIC8vXG4gIC8vIC0gbi5iLiBhZGRpbmcgYSBuZXcgZ3JvdXAgb2YgcHJvcHMgbWF5IHJlcXVpcmUgdXBkYXRlcyB0byB1cGRhdGVTdHlsZUhpbnRzKClcbiAgLy8gLSBhZGRpbmcgbmV3IHByb3BzIHRvIGFuIGV4aXN0aW5nIGdyb3VwIGdldHMgaGFuZGxlZCBhdXRvbWF0aWNhbGx5XG5cbiAgdmFyIHQgPSBzdHlmbiQyLnR5cGVzO1xuICB2YXIgbWFpbkxhYmVsID0gW3tcbiAgICBuYW1lOiAnbGFiZWwnLFxuICAgIHR5cGU6IHQudGV4dCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuZW1wdHlOb25FbXB0eVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtcm90YXRpb24nLFxuICAgIHR5cGU6IHQudGV4dFJvdGF0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtbWFyZ2luLXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1tYXJnaW4teScsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBzb3VyY2VMYWJlbCA9IFt7XG4gICAgbmFtZTogJ3NvdXJjZS1sYWJlbCcsXG4gICAgdHlwZTogdC50ZXh0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS10ZXh0LXJvdGF0aW9uJyxcbiAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1tYXJnaW4teCcsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1tYXJnaW4teScsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzb3VyY2UtdGV4dC1vZmZzZXQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciB0YXJnZXRMYWJlbCA9IFt7XG4gICAgbmFtZTogJ3RhcmdldC1sYWJlbCcsXG4gICAgdHlwZTogdC50ZXh0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC10ZXh0LXJvdGF0aW9uJyxcbiAgICB0eXBlOiB0LnRleHRSb3RhdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1tYXJnaW4teCcsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1tYXJnaW4teScsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXJnZXQtdGV4dC1vZmZzZXQnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBsYWJlbERpbWVuc2lvbnMgPSBbe1xuICAgIG5hbWU6ICdmb250LWZhbWlseScsXG4gICAgdHlwZTogdC5mb250RmFtaWx5LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2ZvbnQtc3R5bGUnLFxuICAgIHR5cGU6IHQuZm9udFN0eWxlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2ZvbnQtd2VpZ2h0JyxcbiAgICB0eXBlOiB0LmZvbnRXZWlnaHQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZm9udC1zaXplJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC10cmFuc2Zvcm0nLFxuICAgIHR5cGU6IHQudGV4dFRyYW5zZm9ybSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LXdyYXAnLFxuICAgIHR5cGU6IHQudGV4dFdyYXAsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vdmVyZmxvdy13cmFwJyxcbiAgICB0eXBlOiB0LnRleHRPdmVyZmxvd1dyYXAsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1tYXgtd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW91dGxpbmUtd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWhlaWdodCcsXG4gICAgdHlwZTogdC5wb3NpdGl2ZU51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBjb21tb25MYWJlbCA9IFt7XG4gICAgbmFtZTogJ3RleHQtdmFsaWduJyxcbiAgICB0eXBlOiB0LnZhbGlnbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWhhbGlnbicsXG4gICAgdHlwZTogdC5oYWxpZ24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW91dGxpbmUtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LW91dGxpbmUtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1ib3JkZXItY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICd0ZXh0LWJvcmRlci13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYm9yZGVyLXN0eWxlJyxcbiAgICB0eXBlOiB0LmJvcmRlclN0eWxlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtYmFja2dyb3VuZC1zaGFwZScsXG4gICAgdHlwZTogdC50ZXh0QmFja2dyb3VuZFNoYXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtanVzdGlmaWNhdGlvbicsXG4gICAgdHlwZTogdC5qdXN0aWZpY2F0aW9uXG4gIH0sIHtcbiAgICBuYW1lOiAnYm94LXNlbGVjdC1sYWJlbHMnLFxuICAgIHR5cGU6IHQuYm9vbCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBiZWhhdmlvciA9IFt7XG4gICAgbmFtZTogJ2V2ZW50cycsXG4gICAgdHlwZTogdC5ib29sLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RleHQtZXZlbnRzJyxcbiAgICB0eXBlOiB0LmJvb2wsXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYm94LXNlbGVjdGlvbicsXG4gICAgdHlwZTogdC5ib3hTZWxlY3Rpb24sXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgdmlzaWJpbGl0eSA9IFt7XG4gICAgbmFtZTogJ2Rpc3BsYXknLFxuICAgIHR5cGU6IHQuZGlzcGxheSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIHRyaWdnZXJzQm91bmRzT2ZDb25uZWN0ZWRFZGdlczogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsRWRnZXM6IGZ1bmN0aW9uIHRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEVkZ2VzKGZyb21WYWx1ZSwgdG9WYWx1ZSwgZWxlKSB7XG4gICAgICBpZiAoZnJvbVZhbHVlID09PSB0b1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gb25seSBpZiBlZGdlIGlzIGJ1bmRsZWQgYmV6aWVyIChzbyBhcyBub3QgdG8gYWZmZWN0IHBlcmZvcm1hbmNlIG9mIG90aGVyIGVkZ2VzKVxuICAgICAgcmV0dXJuIGVsZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWUgPT09ICdiZXppZXInO1xuICAgIH1cbiAgfSwge1xuICAgIG5hbWU6ICd2aXNpYmlsaXR5JyxcbiAgICB0eXBlOiB0LnZpc2liaWxpdHksXG4gICAgdHJpZ2dlcnNaT3JkZXI6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgIHRyaWdnZXJzWk9yZGVyOiBkaWZmLnplcm9Ob25aZXJvXG4gIH0sIHtcbiAgICBuYW1lOiAndGV4dC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4tem9vbWVkLWZvbnQtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplXG4gIH0sIHtcbiAgICBuYW1lOiAnei1jb21wb3VuZC1kZXB0aCcsXG4gICAgdHlwZTogdC56Q29tcG91bmREZXB0aCxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd6LWluZGV4LWNvbXBhcmUnLFxuICAgIHR5cGU6IHQuekluZGV4Q29tcGFyZSxcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd6LWluZGV4JyxcbiAgICB0eXBlOiB0Lm51bWJlcixcbiAgICB0cmlnZ2Vyc1pPcmRlcjogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBvdmVybGF5ID0gW3tcbiAgICBuYW1lOiAnb3ZlcmxheS1wYWRkaW5nJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnb3ZlcmxheS1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ292ZXJsYXktb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLnplcm9Ob25aZXJvXG4gIH0sIHtcbiAgICBuYW1lOiAnb3ZlcmxheS1zaGFwZScsXG4gICAgdHlwZTogdC5vdmVybGF5U2hhcGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnb3ZlcmxheS1jb3JuZXItcmFkaXVzJyxcbiAgICB0eXBlOiB0LmNvcm5lclJhZGl1c1xuICB9XTtcbiAgdmFyIHVuZGVybGF5ID0gW3tcbiAgICBuYW1lOiAndW5kZXJsYXktcGFkZGluZycsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3VuZGVybGF5LWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAndW5kZXJsYXktb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLnplcm9Ob25aZXJvXG4gIH0sIHtcbiAgICBuYW1lOiAndW5kZXJsYXktc2hhcGUnLFxuICAgIHR5cGU6IHQub3ZlcmxheVNoYXBlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3VuZGVybGF5LWNvcm5lci1yYWRpdXMnLFxuICAgIHR5cGU6IHQuY29ybmVyUmFkaXVzXG4gIH1dO1xuICB2YXIgdHJhbnNpdGlvbiA9IFt7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24tcHJvcGVydHknLFxuICAgIHR5cGU6IHQucHJvcExpc3RcbiAgfSwge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uLWR1cmF0aW9uJyxcbiAgICB0eXBlOiB0LnRpbWVcbiAgfSwge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uLWRlbGF5JyxcbiAgICB0eXBlOiB0LnRpbWVcbiAgfSwge1xuICAgIG5hbWU6ICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbicsXG4gICAgdHlwZTogdC5lYXNpbmdcbiAgfV07XG4gIHZhciBub2RlU2l6ZUhhc2hPdmVycmlkZSA9IGZ1bmN0aW9uIG5vZGVTaXplSGFzaE92ZXJyaWRlKGVsZSwgcGFyc2VkUHJvcCkge1xuICAgIGlmIChwYXJzZWRQcm9wLnZhbHVlID09PSAnbGFiZWwnKSB7XG4gICAgICByZXR1cm4gLWVsZS5wb29sSW5kZXgoKTsgLy8gbm8gaGFzaCBrZXkgaGl0cyBpcyB1c2luZyBsYWJlbCBzaXplIChoaXRyYXRlIGZvciBwZXJmIHByb2JhYmx5IGxvdyBhbnl3YXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZWRQcm9wLnBmVmFsdWU7XG4gICAgfVxuICB9O1xuICB2YXIgbm9kZUJvZHkgPSBbe1xuICAgIG5hbWU6ICdoZWlnaHQnLFxuICAgIHR5cGU6IHQubm9kZVNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55LFxuICAgIGhhc2hPdmVycmlkZTogbm9kZVNpemVIYXNoT3ZlcnJpZGVcbiAgfSwge1xuICAgIG5hbWU6ICd3aWR0aCcsXG4gICAgdHlwZTogdC5ub2RlU2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgaGFzaE92ZXJyaWRlOiBub2RlU2l6ZUhhc2hPdmVycmlkZVxuICB9LCB7XG4gICAgbmFtZTogJ3NoYXBlJyxcbiAgICB0eXBlOiB0Lm5vZGVTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzaGFwZS1wb2x5Z29uLXBvaW50cycsXG4gICAgdHlwZTogdC5wb2x5Z29uUG9pbnRMaXN0LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2Nvcm5lci1yYWRpdXMnLFxuICAgIHR5cGU6IHQuY29ybmVyUmFkaXVzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZmlsbCcsXG4gICAgdHlwZTogdC5maWxsXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWJsYWNrZW4nLFxuICAgIHR5cGU6IHQubk9uZU9uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtc3RvcC1jb2xvcnMnLFxuICAgIHR5cGU6IHQuY29sb3JzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucycsXG4gICAgdHlwZTogdC5wZXJjZW50YWdlc1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtZ3JhZGllbnQtZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmdyYWRpZW50RGlyZWN0aW9uXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZycsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmctcmVsYXRpdmUtdG8nLFxuICAgIHR5cGU6IHQucGFkZGluZ1JlbGF0aXZlVG8sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnYm91bmRzLWV4cGFuc2lvbicsXG4gICAgdHlwZTogdC5ib3VuZHNFeHBhbnNpb24sXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgbm9kZUJvcmRlciA9IFt7XG4gICAgbmFtZTogJ2JvcmRlci1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItc3R5bGUnLFxuICAgIHR5cGU6IHQuYm9yZGVyU3R5bGVcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItY2FwJyxcbiAgICB0eXBlOiB0LmxpbmVDYXBcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItam9pbicsXG4gICAgdHlwZTogdC5saW5lSm9pblxuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1kYXNoLXBhdHRlcm4nLFxuICAgIHR5cGU6IHQubnVtYmVyc1xuICB9LCB7XG4gICAgbmFtZTogJ2JvcmRlci1kYXNoLW9mZnNldCcsXG4gICAgdHlwZTogdC5udW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdib3JkZXItcG9zaXRpb24nLFxuICAgIHR5cGU6IHQubGluZVBvc2l0aW9uXG4gIH1dO1xuICB2YXIgbm9kZU91dGxpbmUgPSBbe1xuICAgIG5hbWU6ICdvdXRsaW5lLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnb3V0bGluZS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdvdXRsaW5lLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnb3V0bGluZS1zdHlsZScsXG4gICAgdHlwZTogdC5ib3JkZXJTdHlsZVxuICB9LCB7XG4gICAgbmFtZTogJ291dGxpbmUtb2Zmc2V0JyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgYmFja2dyb3VuZEltYWdlID0gW3tcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZScsXG4gICAgdHlwZTogdC51cmxzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1jcm9zc29yaWdpbicsXG4gICAgdHlwZTogdC5iZ0Nyb3NzT3JpZ2luXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJzXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1jb250YWlubWVudCcsXG4gICAgdHlwZTogdC5iZ0NvbnRhaW5tZW50XG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1zbW9vdGhpbmcnLFxuICAgIHR5cGU6IHQuYm9vbHNcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLFxuICAgIHR5cGU6IHQuYmdQb3NcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLFxuICAgIHR5cGU6IHQuYmdQb3NcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJyxcbiAgICB0eXBlOiB0LmJnUmVsYXRpdmVUb1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJyxcbiAgICB0eXBlOiB0LmJnUmVsYXRpdmVUb1xuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtcmVwZWF0JyxcbiAgICB0eXBlOiB0LmJnUmVwZWF0XG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1maXQnLFxuICAgIHR5cGU6IHQuYmdGaXRcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLWNsaXAnLFxuICAgIHR5cGU6IHQuYmdDbGlwXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC13aWR0aCcsXG4gICAgdHlwZTogdC5iZ1dIXG4gIH0sIHtcbiAgICBuYW1lOiAnYmFja2dyb3VuZC1oZWlnaHQnLFxuICAgIHR5cGU6IHQuYmdXSFxuICB9LCB7XG4gICAgbmFtZTogJ2JhY2tncm91bmQtb2Zmc2V0LXgnLFxuICAgIHR5cGU6IHQuYmdQb3NcbiAgfSwge1xuICAgIG5hbWU6ICdiYWNrZ3JvdW5kLW9mZnNldC15JyxcbiAgICB0eXBlOiB0LmJnUG9zXG4gIH1dO1xuICB2YXIgY29tcG91bmQgPSBbe1xuICAgIG5hbWU6ICdwb3NpdGlvbicsXG4gICAgdHlwZTogdC5wb3NpdGlvbixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscycsXG4gICAgdHlwZTogdC5jb21wb3VuZEluY2x1ZGVMYWJlbHMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLXdpZHRoJyxcbiAgICB0eXBlOiB0LnNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLXdpZHRoLWJpYXMtbGVmdCcsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi13aWR0aC1iaWFzLXJpZ2h0JyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnbWluLWhlaWdodCcsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ21pbi1oZWlnaHQtYmlhcy10b3AnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH1dO1xuICB2YXIgZWRnZUxpbmUgPSBbe1xuICAgIG5hbWU6ICdsaW5lLXN0eWxlJyxcbiAgICB0eXBlOiB0LmxpbmVTdHlsZVxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWZpbGwnLFxuICAgIHR5cGU6IHQuZmlsbFxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtY2FwJyxcbiAgICB0eXBlOiB0LmxpbmVDYXBcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtZGFzaC1wYXR0ZXJuJyxcbiAgICB0eXBlOiB0Lm51bWJlcnNcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWRhc2gtb2Zmc2V0JyxcbiAgICB0eXBlOiB0Lm51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ2xpbmUtb3V0bGluZS13aWR0aCcsXG4gICAgdHlwZTogdC5zaXplXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1vdXRsaW5lLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZS1ncmFkaWVudC1zdG9wLWNvbG9ycycsXG4gICAgdHlwZTogdC5jb2xvcnNcbiAgfSwge1xuICAgIG5hbWU6ICdsaW5lLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJyxcbiAgICB0eXBlOiB0LnBlcmNlbnRhZ2VzXG4gIH0sIHtcbiAgICBuYW1lOiAnY3VydmUtc3R5bGUnLFxuICAgIHR5cGU6IHQuY3VydmVTdHlsZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnksXG4gICAgdHJpZ2dlcnNCb3VuZHNPZlBhcmFsbGVsRWRnZXM6IGZ1bmN0aW9uIHRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEVkZ2VzKGZyb21WYWx1ZSwgdG9WYWx1ZSkge1xuICAgICAgaWYgKGZyb21WYWx1ZSA9PT0gdG9WYWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IC8vIG11c3QgaGF2ZSBkaWZmXG5cbiAgICAgIHJldHVybiBmcm9tVmFsdWUgPT09ICdiZXppZXInIHx8XG4gICAgICAvLyByZW1vdmUgZnJvbSBidW5kbGVcbiAgICAgIHRvVmFsdWUgPT09ICdiZXppZXInOyAvLyBhZGQgdG8gYnVuZGxlXG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogJ2hheXN0YWNrLXJhZGl1cycsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3NvdXJjZS1lbmRwb2ludCcsXG4gICAgdHlwZTogdC5lZGdlRW5kcG9pbnQsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGFyZ2V0LWVuZHBvaW50JyxcbiAgICB0eXBlOiB0LmVkZ2VFbmRwb2ludCxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplcyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodHMnLFxuICAgIHR5cGU6IHQubnVtYmVycyxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdzZWdtZW50LWRpc3RhbmNlcycsXG4gICAgdHlwZTogdC5iaWRpcmVjdGlvbmFsU2l6ZXMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc2VnbWVudC13ZWlnaHRzJyxcbiAgICB0eXBlOiB0Lm51bWJlcnMsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc2VnbWVudC1yYWRpaScsXG4gICAgdHlwZTogdC5udW1iZXJzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3JhZGl1cy10eXBlJyxcbiAgICB0eXBlOiB0LnJhZGl1c1R5cGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAndGF4aS10dXJuJyxcbiAgICB0eXBlOiB0LmJpZGlyZWN0aW9uYWxTaXplTWF5YmVQZXJjZW50LFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RheGktdHVybi1taW4tZGlzdGFuY2UnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICd0YXhpLWRpcmVjdGlvbicsXG4gICAgdHlwZTogdC5heGlzRGlyZWN0aW9uLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RheGktcmFkaXVzJyxcbiAgICB0eXBlOiB0Lm51bWJlcixcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdlZGdlLWRpc3RhbmNlcycsXG4gICAgdHlwZTogdC5lZGdlRGlzdGFuY2VzLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LXNjYWxlJyxcbiAgICB0eXBlOiB0LnBvc2l0aXZlTnVtYmVyLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2xvb3AtZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmFuZ2xlLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ2xvb3Atc3dlZXAnLFxuICAgIHR5cGU6IHQuYW5nbGUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZScsXG4gICAgdHlwZTogdC5zaXplLFxuICAgIHRyaWdnZXJzQm91bmRzOiBkaWZmLmFueVxuICB9LCB7XG4gICAgbmFtZTogJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnLFxuICAgIHR5cGU6IHQuc2l6ZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfV07XG4gIHZhciBnaG9zdCA9IFt7XG4gICAgbmFtZTogJ2dob3N0JyxcbiAgICB0eXBlOiB0LmJvb2wsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZ2hvc3Qtb2Zmc2V0LXgnLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZ2hvc3Qtb2Zmc2V0LXknLFxuICAgIHR5cGU6IHQuYmlkaXJlY3Rpb25hbFNpemUsXG4gICAgdHJpZ2dlcnNCb3VuZHM6IGRpZmYuYW55XG4gIH0sIHtcbiAgICBuYW1lOiAnZ2hvc3Qtb3BhY2l0eScsXG4gICAgdHlwZTogdC56ZXJvT25lTnVtYmVyXG4gIH1dO1xuICB2YXIgY29yZSA9IFt7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtY29sb3InLFxuICAgIHR5cGU6IHQuY29sb3JcbiAgfSwge1xuICAgIG5hbWU6ICdzZWxlY3Rpb24tYm94LW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9LCB7XG4gICAgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnLFxuICAgIHR5cGU6IHQuc2l6ZVxuICB9LCB7XG4gICAgbmFtZTogJ2FjdGl2ZS1iZy1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2FjdGl2ZS1iZy1vcGFjaXR5JyxcbiAgICB0eXBlOiB0Lnplcm9PbmVOdW1iZXJcbiAgfSwge1xuICAgIG5hbWU6ICdhY3RpdmUtYmctc2l6ZScsXG4gICAgdHlwZTogdC5zaXplXG4gIH0sIHtcbiAgICBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJyxcbiAgICB0eXBlOiB0LmNvbG9yXG4gIH0sIHtcbiAgICBuYW1lOiAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknLFxuICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICB9XTtcblxuICAvLyBwaWUgYmFja2dyb3VuZHMgZm9yIG5vZGVzXG4gIHZhciBwaWUgPSBbXTtcbiAgc3R5Zm4kMi5waWVCYWNrZ3JvdW5kTiA9IDE2OyAvLyBiZWNhdXNlIHRoZSBwaWUgcHJvcGVydGllcyBhcmUgbnVtYmVyZWQsIGdpdmUgYWNjZXNzIHRvIGEgY29uc3RhbnQgTiAoZm9yIHJlbmRlcmVyIHVzZSlcbiAgcGllLnB1c2goe1xuICAgIG5hbWU6ICdwaWUtc2l6ZScsXG4gICAgdHlwZTogdC5zaXplTWF5YmVQZXJjZW50XG4gIH0pO1xuICBwaWUucHVzaCh7XG4gICAgbmFtZTogJ3BpZS1ob2xlJyxcbiAgICB0eXBlOiB0LnNpemVNYXliZVBlcmNlbnRcbiAgfSk7XG4gIHBpZS5wdXNoKHtcbiAgICBuYW1lOiAncGllLXN0YXJ0LWFuZ2xlJyxcbiAgICB0eXBlOiB0LmFuZ2xlXG4gIH0pO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHlmbiQyLnBpZUJhY2tncm91bmROOyBpKyspIHtcbiAgICBwaWUucHVzaCh7XG4gICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICAgIHR5cGU6IHQuY29sb3JcbiAgICB9KTtcbiAgICBwaWUucHVzaCh7XG4gICAgICBuYW1lOiAncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnLFxuICAgICAgdHlwZTogdC5wZXJjZW50XG4gICAgfSk7XG4gICAgcGllLnB1c2goe1xuICAgICAgbmFtZTogJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RyaXBlIGJhY2tncm91bmRzIGZvciBub2Rlc1xuICB2YXIgc3RyaXBlID0gW107XG4gIHN0eWZuJDIuc3RyaXBlQmFja2dyb3VuZE4gPSAxNjsgLy8gYmVjYXVzZSB0aGUgc3RyaXBlIHByb3BlcnRpZXMgYXJlIG51bWJlcmVkLCBnaXZlIGFjY2VzcyB0byBhIGNvbnN0YW50IE4gKGZvciByZW5kZXJlciB1c2UpXG4gIHN0cmlwZS5wdXNoKHtcbiAgICBuYW1lOiAnc3RyaXBlLXNpemUnLFxuICAgIHR5cGU6IHQuc2l6ZU1heWJlUGVyY2VudFxuICB9KTtcbiAgc3RyaXBlLnB1c2goe1xuICAgIG5hbWU6ICdzdHJpcGUtZGlyZWN0aW9uJyxcbiAgICB0eXBlOiB0LmF4aXNEaXJlY3Rpb25QcmltYXJ5XG4gIH0pO1xuICBmb3IgKHZhciBfaSA9IDE7IF9pIDw9IHN0eWZuJDIuc3RyaXBlQmFja2dyb3VuZE47IF9pKyspIHtcbiAgICBzdHJpcGUucHVzaCh7XG4gICAgICBuYW1lOiAnc3RyaXBlLScgKyBfaSArICctYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICB0eXBlOiB0LmNvbG9yXG4gICAgfSk7XG4gICAgc3RyaXBlLnB1c2goe1xuICAgICAgbmFtZTogJ3N0cmlwZS0nICsgX2kgKyAnLWJhY2tncm91bmQtc2l6ZScsXG4gICAgICB0eXBlOiB0LnBlcmNlbnRcbiAgICB9KTtcbiAgICBzdHJpcGUucHVzaCh7XG4gICAgICBuYW1lOiAnc3RyaXBlLScgKyBfaSArICctYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICAgIHR5cGU6IHQuemVyb09uZU51bWJlclxuICAgIH0pO1xuICB9XG5cbiAgLy8gZWRnZSBhcnJvd3NcbiAgdmFyIGVkZ2VBcnJvdyA9IFtdO1xuICB2YXIgYXJyb3dQcmVmaXhlcyA9IHN0eWZuJDIuYXJyb3dQcmVmaXhlcyA9IFsnc291cmNlJywgJ21pZC1zb3VyY2UnLCAndGFyZ2V0JywgJ21pZC10YXJnZXQnXTtcbiAgW3tcbiAgICBuYW1lOiAnYXJyb3ctc2hhcGUnLFxuICAgIHR5cGU6IHQuYXJyb3dTaGFwZSxcbiAgICB0cmlnZ2Vyc0JvdW5kczogZGlmZi5hbnlcbiAgfSwge1xuICAgIG5hbWU6ICdhcnJvdy1jb2xvcicsXG4gICAgdHlwZTogdC5jb2xvclxuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LWZpbGwnLFxuICAgIHR5cGU6IHQuYXJyb3dGaWxsXG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctd2lkdGgnLFxuICAgIHR5cGU6IHQuYXJyb3dXaWR0aFxuICB9XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgYXJyb3dQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgIHZhciBuYW1lID0gcHJlZml4ICsgJy0nICsgcHJvcC5uYW1lO1xuICAgICAgdmFyIHR5cGUgPSBwcm9wLnR5cGUsXG4gICAgICAgIHRyaWdnZXJzQm91bmRzID0gcHJvcC50cmlnZ2Vyc0JvdW5kcztcbiAgICAgIGVkZ2VBcnJvdy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdHJpZ2dlcnNCb3VuZHM6IHRyaWdnZXJzQm91bmRzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwge30pO1xuICB2YXIgcHJvcHMgPSBzdHlmbiQyLnByb3BlcnRpZXMgPSBbXS5jb25jYXQoYmVoYXZpb3IsIHRyYW5zaXRpb24sIHZpc2liaWxpdHksIG92ZXJsYXksIHVuZGVybGF5LCBnaG9zdCwgY29tbW9uTGFiZWwsIGxhYmVsRGltZW5zaW9ucywgbWFpbkxhYmVsLCBzb3VyY2VMYWJlbCwgdGFyZ2V0TGFiZWwsIG5vZGVCb2R5LCBub2RlQm9yZGVyLCBub2RlT3V0bGluZSwgYmFja2dyb3VuZEltYWdlLCBwaWUsIHN0cmlwZSwgY29tcG91bmQsIGVkZ2VMaW5lLCBlZGdlQXJyb3csIGNvcmUpO1xuICB2YXIgcHJvcEdyb3VwcyA9IHN0eWZuJDIucHJvcGVydHlHcm91cHMgPSB7XG4gICAgLy8gY29tbW9uIHRvIGFsbCBlbGVzXG4gICAgYmVoYXZpb3I6IGJlaGF2aW9yLFxuICAgIHRyYW5zaXRpb246IHRyYW5zaXRpb24sXG4gICAgdmlzaWJpbGl0eTogdmlzaWJpbGl0eSxcbiAgICBvdmVybGF5OiBvdmVybGF5LFxuICAgIHVuZGVybGF5OiB1bmRlcmxheSxcbiAgICBnaG9zdDogZ2hvc3QsXG4gICAgLy8gbGFiZWxzXG4gICAgY29tbW9uTGFiZWw6IGNvbW1vbkxhYmVsLFxuICAgIGxhYmVsRGltZW5zaW9uczogbGFiZWxEaW1lbnNpb25zLFxuICAgIG1haW5MYWJlbDogbWFpbkxhYmVsLFxuICAgIHNvdXJjZUxhYmVsOiBzb3VyY2VMYWJlbCxcbiAgICB0YXJnZXRMYWJlbDogdGFyZ2V0TGFiZWwsXG4gICAgLy8gbm9kZSBwcm9wc1xuICAgIG5vZGVCb2R5OiBub2RlQm9keSxcbiAgICBub2RlQm9yZGVyOiBub2RlQm9yZGVyLFxuICAgIG5vZGVPdXRsaW5lOiBub2RlT3V0bGluZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGJhY2tncm91bmRJbWFnZSxcbiAgICBwaWU6IHBpZSxcbiAgICBzdHJpcGU6IHN0cmlwZSxcbiAgICBjb21wb3VuZDogY29tcG91bmQsXG4gICAgLy8gZWRnZSBwcm9wc1xuICAgIGVkZ2VMaW5lOiBlZGdlTGluZSxcbiAgICBlZGdlQXJyb3c6IGVkZ2VBcnJvdyxcbiAgICBjb3JlOiBjb3JlXG4gIH07XG4gIHZhciBwcm9wR3JvdXBOYW1lcyA9IHN0eWZuJDIucHJvcGVydHlHcm91cE5hbWVzID0ge307XG4gIHZhciBwcm9wR3JvdXBLZXlzID0gc3R5Zm4kMi5wcm9wZXJ0eUdyb3VwS2V5cyA9IE9iamVjdC5rZXlzKHByb3BHcm91cHMpO1xuICBwcm9wR3JvdXBLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHByb3BHcm91cE5hbWVzW2tleV0gPSBwcm9wR3JvdXBzW2tleV0ubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gcHJvcC5uYW1lO1xuICAgIH0pO1xuICAgIHByb3BHcm91cHNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gcHJvcC5ncm91cEtleSA9IGtleTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gZGVmaW5lIGFsaWFzZXNcbiAgdmFyIGFsaWFzZXMgPSBzdHlmbiQyLmFsaWFzZXMgPSBbe1xuICAgIG5hbWU6ICdjb250ZW50JyxcbiAgICBwb2ludHNUbzogJ2xhYmVsJ1xuICB9LCB7XG4gICAgbmFtZTogJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnLFxuICAgIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnY29udHJvbC1wb2ludC13ZWlnaHQnLFxuICAgIHBvaW50c1RvOiAnY29udHJvbC1wb2ludC13ZWlnaHRzJ1xuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtZGlzdGFuY2UnLFxuICAgIHBvaW50c1RvOiAnc2VnbWVudC1kaXN0YW5jZXMnXG4gIH0sIHtcbiAgICBuYW1lOiAnc2VnbWVudC13ZWlnaHQnLFxuICAgIHBvaW50c1RvOiAnc2VnbWVudC13ZWlnaHRzJ1xuICB9LCB7XG4gICAgbmFtZTogJ3NlZ21lbnQtcmFkaXVzJyxcbiAgICBwb2ludHNUbzogJ3NlZ21lbnQtcmFkaWknXG4gIH0sIHtcbiAgICBuYW1lOiAnZWRnZS10ZXh0LXJvdGF0aW9uJyxcbiAgICBwb2ludHNUbzogJ3RleHQtcm90YXRpb24nXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1sZWZ0JyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1yaWdodCcsXG4gICAgcG9pbnRzVG86ICdwYWRkaW5nJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BhZGRpbmctdG9wJyxcbiAgICBwb2ludHNUbzogJ3BhZGRpbmcnXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZy1ib3R0b20nLFxuICAgIHBvaW50c1RvOiAncGFkZGluZydcbiAgfV07XG5cbiAgLy8gbGlzdCBvZiBwcm9wZXJ0eSBuYW1lc1xuICBzdHlmbiQyLnByb3BlcnR5TmFtZXMgPSBwcm9wcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcC5uYW1lO1xuICB9KTtcblxuICAvLyBhbGxvdyBhY2Nlc3Mgb2YgcHJvcGVydGllcyBieSBuYW1lICggZS5nLiBzdHlsZS5wcm9wZXJ0aWVzLmhlaWdodCApXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHByb3BzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW19pMl07XG4gICAgcHJvcHNbcHJvcC5uYW1lXSA9IHByb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gIH1cblxuICAvLyBtYXAgYWxpYXNlc1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBhbGlhc2VzLmxlbmd0aDsgX2kzKyspIHtcbiAgICB2YXIgYWxpYXMgPSBhbGlhc2VzW19pM107XG4gICAgdmFyIHBvaW50c1RvUHJvcCA9IHByb3BzW2FsaWFzLnBvaW50c1RvXTtcbiAgICB2YXIgYWxpYXNQcm9wID0ge1xuICAgICAgbmFtZTogYWxpYXMubmFtZSxcbiAgICAgIGFsaWFzOiB0cnVlLFxuICAgICAgcG9pbnRzVG86IHBvaW50c1RvUHJvcFxuICAgIH07XG5cbiAgICAvLyBhZGQgYWxpYXMgcHJvcCBmb3IgcGFyc2luZ1xuICAgIHByb3BzLnB1c2goYWxpYXNQcm9wKTtcbiAgICBwcm9wc1thbGlhcy5uYW1lXSA9IGFsaWFzUHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgfVxufSkoKTtcbnN0eWZuJDIuZ2V0RGVmYXVsdFByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdFByb3BlcnRpZXMoKVtuYW1lXTtcbn07XG5zdHlmbiQyLmdldERlZmF1bHRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICBpZiAoX3AuZGVmYXVsdFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgIHJldHVybiBfcC5kZWZhdWx0UHJvcGVydGllcztcbiAgfVxuICB2YXIgcmF3UHJvcHMgPSBleHRlbmQoe1xuICAgIC8vIGNvcmUgcHJvcHNcbiAgICAnc2VsZWN0aW9uLWJveC1jb2xvcic6ICcjZGRkJyxcbiAgICAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JzogMC42NSxcbiAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InOiAnI2FhYScsXG4gICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJzogMSxcbiAgICAnYWN0aXZlLWJnLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAnYWN0aXZlLWJnLW9wYWNpdHknOiAwLjE1LFxuICAgICdhY3RpdmUtYmctc2l6ZSc6IDMwLFxuICAgICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InOiAnIzAwMCcsXG4gICAgJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JzogMC4xMjUsXG4gICAgLy8gY29tbW9uIG5vZGUvZWRnZSBwcm9wc1xuICAgICdldmVudHMnOiAneWVzJyxcbiAgICAndGV4dC1ldmVudHMnOiAnbm8nLFxuICAgICd0ZXh0LXZhbGlnbic6ICd0b3AnLFxuICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICd0ZXh0LWp1c3RpZmljYXRpb24nOiAnYXV0bycsXG4gICAgJ2xpbmUtaGVpZ2h0JzogMSxcbiAgICAnY29sb3InOiAnIzAwMCcsXG4gICAgJ2JveC1zZWxlY3Rpb24nOiAnY29udGFpbicsXG4gICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJyxcbiAgICAndGV4dC1vdXRsaW5lLXdpZHRoJzogMCxcbiAgICAndGV4dC1vdXRsaW5lLW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICd0ZXh0LWRlY29yYXRpb24nOiAnbm9uZScsXG4gICAgJ3RleHQtdHJhbnNmb3JtJzogJ25vbmUnLFxuICAgICd0ZXh0LXdyYXAnOiAnbm9uZScsXG4gICAgJ3RleHQtb3ZlcmZsb3ctd3JhcCc6ICd3aGl0ZXNwYWNlJyxcbiAgICAndGV4dC1tYXgtd2lkdGgnOiA5OTk5LFxuICAgICd0ZXh0LWJhY2tncm91bmQtY29sb3InOiAnIzAwMCcsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JzogMCxcbiAgICAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJzogJ3JlY3RhbmdsZScsXG4gICAgJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJzogMCxcbiAgICAndGV4dC1ib3JkZXItb3BhY2l0eSc6IDAsXG4gICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogMCxcbiAgICAndGV4dC1ib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICd0ZXh0LWJvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAnZm9udC1mYW1pbHknOiAnSGVsdmV0aWNhIE5ldWUsIEhlbHZldGljYSwgc2Fucy1zZXJpZicsXG4gICAgJ2ZvbnQtc3R5bGUnOiAnbm9ybWFsJyxcbiAgICAnZm9udC13ZWlnaHQnOiAnbm9ybWFsJyxcbiAgICAnZm9udC1zaXplJzogMTYsXG4gICAgJ21pbi16b29tZWQtZm9udC1zaXplJzogMCxcbiAgICAndGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAnc291cmNlLXRleHQtcm90YXRpb24nOiAnbm9uZScsXG4gICAgJ3RhcmdldC10ZXh0LXJvdGF0aW9uJzogJ25vbmUnLFxuICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICdkaXNwbGF5JzogJ2VsZW1lbnQnLFxuICAgICdvcGFjaXR5JzogMSxcbiAgICAnei1jb21wb3VuZC1kZXB0aCc6ICdhdXRvJyxcbiAgICAnei1pbmRleC1jb21wYXJlJzogJ2F1dG8nLFxuICAgICd6LWluZGV4JzogMCxcbiAgICAnbGFiZWwnOiAnJyxcbiAgICAndGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3RleHQtbWFyZ2luLXknOiAwLFxuICAgICdzb3VyY2UtbGFiZWwnOiAnJyxcbiAgICAnc291cmNlLXRleHQtb2Zmc2V0JzogMCxcbiAgICAnc291cmNlLXRleHQtbWFyZ2luLXgnOiAwLFxuICAgICdzb3VyY2UtdGV4dC1tYXJnaW4teSc6IDAsXG4gICAgJ3RhcmdldC1sYWJlbCc6ICcnLFxuICAgICd0YXJnZXQtdGV4dC1vZmZzZXQnOiAwLFxuICAgICd0YXJnZXQtdGV4dC1tYXJnaW4teCc6IDAsXG4gICAgJ3RhcmdldC10ZXh0LW1hcmdpbi15JzogMCxcbiAgICAnb3ZlcmxheS1vcGFjaXR5JzogMCxcbiAgICAnb3ZlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgJ292ZXJsYXktc2hhcGUnOiAncm91bmQtcmVjdGFuZ2xlJyxcbiAgICAnb3ZlcmxheS1jb3JuZXItcmFkaXVzJzogJ2F1dG8nLFxuICAgICd1bmRlcmxheS1vcGFjaXR5JzogMCxcbiAgICAndW5kZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgJ3VuZGVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAndW5kZXJsYXktc2hhcGUnOiAncm91bmQtcmVjdGFuZ2xlJyxcbiAgICAndW5kZXJsYXktY29ybmVyLXJhZGl1cyc6ICdhdXRvJyxcbiAgICAndHJhbnNpdGlvbi1wcm9wZXJ0eSc6ICdub25lJyxcbiAgICAndHJhbnNpdGlvbi1kdXJhdGlvbic6IDAsXG4gICAgJ3RyYW5zaXRpb24tZGVsYXknOiAwLFxuICAgICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbic6ICdsaW5lYXInLFxuICAgICdib3gtc2VsZWN0LWxhYmVscyc6ICdubycsXG4gICAgLy8gbm9kZSBwcm9wc1xuICAgICdiYWNrZ3JvdW5kLWJsYWNrZW4nOiAwLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyM5OTknLFxuICAgICdiYWNrZ3JvdW5kLWZpbGwnOiAnc29saWQnLFxuICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlJzogJ25vbmUnLFxuICAgICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJzogJ2Fub255bW91cycsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSc6IDEsXG4gICAgJ2JhY2tncm91bmQtaW1hZ2UtY29udGFpbm1lbnQnOiAnaW5zaWRlJyxcbiAgICAnYmFja2dyb3VuZC1pbWFnZS1zbW9vdGhpbmcnOiAneWVzJyxcbiAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogJzUwJScsXG4gICAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6ICc1MCUnLFxuICAgICdiYWNrZ3JvdW5kLW9mZnNldC14JzogMCxcbiAgICAnYmFja2dyb3VuZC1vZmZzZXQteSc6IDAsXG4gICAgJ2JhY2tncm91bmQtd2lkdGgtcmVsYXRpdmUtdG8nOiAnaW5jbHVkZS1wYWRkaW5nJyxcbiAgICAnYmFja2dyb3VuZC1oZWlnaHQtcmVsYXRpdmUtdG8nOiAnaW5jbHVkZS1wYWRkaW5nJyxcbiAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub2RlJyxcbiAgICAnYmFja2dyb3VuZC13aWR0aCc6ICdhdXRvJyxcbiAgICAnYmFja2dyb3VuZC1oZWlnaHQnOiAnYXV0bycsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjMDAwJyxcbiAgICAnYm9yZGVyLW9wYWNpdHknOiAxLFxuICAgICdib3JkZXItd2lkdGgnOiAwLFxuICAgICdib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICdib3JkZXItZGFzaC1wYXR0ZXJuJzogWzQsIDJdLFxuICAgICdib3JkZXItZGFzaC1vZmZzZXQnOiAwLFxuICAgICdib3JkZXItY2FwJzogJ2J1dHQnLFxuICAgICdib3JkZXItam9pbic6ICdtaXRlcicsXG4gICAgJ2JvcmRlci1wb3NpdGlvbic6ICdjZW50ZXInLFxuICAgICdvdXRsaW5lLWNvbG9yJzogJyM5OTknLFxuICAgICdvdXRsaW5lLW9wYWNpdHknOiAxLFxuICAgICdvdXRsaW5lLXdpZHRoJzogMCxcbiAgICAnb3V0bGluZS1vZmZzZXQnOiAwLFxuICAgICdvdXRsaW5lLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAnaGVpZ2h0JzogMzAsXG4gICAgJ3dpZHRoJzogMzAsXG4gICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuICAgICdzaGFwZS1wb2x5Z29uLXBvaW50cyc6ICctMSwgLTEsICAgMSwgLTEsICAgMSwgMSwgICAtMSwgMScsXG4gICAgJ2Nvcm5lci1yYWRpdXMnOiAnYXV0bycsXG4gICAgJ2JvdW5kcy1leHBhbnNpb24nOiAwLFxuICAgIC8vIG5vZGUgZ3JhZGllbnRcbiAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1kaXJlY3Rpb24nOiAndG8tYm90dG9tJyxcbiAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLWNvbG9ycyc6ICcjOTk5JyxcbiAgICAnYmFja2dyb3VuZC1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucyc6ICcwJScsXG4gICAgLy8gZ2hvc3QgcHJvcHNcbiAgICAnZ2hvc3QnOiAnbm8nLFxuICAgICdnaG9zdC1vZmZzZXQteSc6IDAsXG4gICAgJ2dob3N0LW9mZnNldC14JzogMCxcbiAgICAnZ2hvc3Qtb3BhY2l0eSc6IDAsXG4gICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAncGFkZGluZyc6IDAsXG4gICAgJ3BhZGRpbmctcmVsYXRpdmUtdG8nOiAnd2lkdGgnLFxuICAgICdwb3NpdGlvbic6ICdvcmlnaW4nLFxuICAgICdjb21wb3VuZC1zaXppbmctd3J0LWxhYmVscyc6ICdpbmNsdWRlJyxcbiAgICAnbWluLXdpZHRoJzogMCxcbiAgICAnbWluLXdpZHRoLWJpYXMtbGVmdCc6IDAsXG4gICAgJ21pbi13aWR0aC1iaWFzLXJpZ2h0JzogMCxcbiAgICAnbWluLWhlaWdodCc6IDAsXG4gICAgJ21pbi1oZWlnaHQtYmlhcy10b3AnOiAwLFxuICAgICdtaW4taGVpZ2h0LWJpYXMtYm90dG9tJzogMFxuICB9LCB7XG4gICAgLy8gbm9kZSBwaWUgYmdcbiAgICAncGllLXNpemUnOiAnMTAwJScsXG4gICAgJ3BpZS1ob2xlJzogMCxcbiAgICAncGllLXN0YXJ0LWFuZ2xlJzogJzBkZWcnXG4gIH0sIFt7XG4gICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICB2YWx1ZTogJ2JsYWNrJ1xuICB9LCB7XG4gICAgbmFtZTogJ3BpZS17e2l9fS1iYWNrZ3JvdW5kLXNpemUnLFxuICAgIHZhbHVlOiAnMCUnXG4gIH0sIHtcbiAgICBuYW1lOiAncGllLXt7aX19LWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgdmFsdWU6IDFcbiAgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHlmbiQyLnBpZUJhY2tncm91bmROOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lLnJlcGxhY2UoJ3t7aX19JywgaSk7XG4gICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcbiAgICAgIGNzc1tuYW1lXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGNzcztcbiAgfSwge30pLCB7XG4gICAgLy8gbm9kZSBzdHJpcGVzIGJnXG4gICAgJ3N0cmlwZS1zaXplJzogJzEwMCUnLFxuICAgICdzdHJpcGUtZGlyZWN0aW9uJzogJ2hvcml6b250YWwnXG4gIH0sIFt7XG4gICAgbmFtZTogJ3N0cmlwZS17e2l9fS1iYWNrZ3JvdW5kLWNvbG9yJyxcbiAgICB2YWx1ZTogJ2JsYWNrJ1xuICB9LCB7XG4gICAgbmFtZTogJ3N0cmlwZS17e2l9fS1iYWNrZ3JvdW5kLXNpemUnLFxuICAgIHZhbHVlOiAnMCUnXG4gIH0sIHtcbiAgICBuYW1lOiAnc3RyaXBlLXt7aX19LWJhY2tncm91bmQtb3BhY2l0eScsXG4gICAgdmFsdWU6IDFcbiAgfV0ucmVkdWNlKGZ1bmN0aW9uIChjc3MsIHByb3ApIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBzdHlmbiQyLnN0cmlwZUJhY2tncm91bmROOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lLnJlcGxhY2UoJ3t7aX19JywgaSk7XG4gICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcbiAgICAgIGNzc1tuYW1lXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGNzcztcbiAgfSwge30pLCB7XG4gICAgLy8gZWRnZSBwcm9wc1xuICAgICdsaW5lLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAnbGluZS1jb2xvcic6ICcjOTk5JyxcbiAgICAnbGluZS1maWxsJzogJ3NvbGlkJyxcbiAgICAnbGluZS1jYXAnOiAnYnV0dCcsXG4gICAgJ2xpbmUtb3BhY2l0eSc6IDEsXG4gICAgJ2xpbmUtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgJ2xpbmUtb3V0bGluZS1jb2xvcic6ICcjMDAwJyxcbiAgICAnbGluZS1ncmFkaWVudC1zdG9wLWNvbG9ycyc6ICcjOTk5JyxcbiAgICAnbGluZS1ncmFkaWVudC1zdG9wLXBvc2l0aW9ucyc6ICcwJScsXG4gICAgJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJzogNDAsXG4gICAgJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0cyc6IDAuNSxcbiAgICAnc2VnbWVudC13ZWlnaHRzJzogMC41LFxuICAgICdzZWdtZW50LWRpc3RhbmNlcyc6IDIwLFxuICAgICdzZWdtZW50LXJhZGlpJzogMTUsXG4gICAgJ3JhZGl1cy10eXBlJzogJ2FyYy1yYWRpdXMnLFxuICAgICd0YXhpLXR1cm4nOiAnNTAlJyxcbiAgICAndGF4aS1yYWRpdXMnOiAxNSxcbiAgICAndGF4aS10dXJuLW1pbi1kaXN0YW5jZSc6IDEwLFxuICAgICd0YXhpLWRpcmVjdGlvbic6ICdhdXRvJyxcbiAgICAnZWRnZS1kaXN0YW5jZXMnOiAnaW50ZXJzZWN0aW9uJyxcbiAgICAnY3VydmUtc3R5bGUnOiAnaGF5c3RhY2snLFxuICAgICdoYXlzdGFjay1yYWRpdXMnOiAwLFxuICAgICdhcnJvdy1zY2FsZSc6IDEsXG4gICAgJ2xvb3AtZGlyZWN0aW9uJzogJy00NWRlZycsXG4gICAgJ2xvb3Atc3dlZXAnOiAnLTkwZGVnJyxcbiAgICAnc291cmNlLWRpc3RhbmNlLWZyb20tbm9kZSc6IDAsXG4gICAgJ3RhcmdldC1kaXN0YW5jZS1mcm9tLW5vZGUnOiAwLFxuICAgICdzb3VyY2UtZW5kcG9pbnQnOiAnb3V0c2lkZS10by1ub2RlJyxcbiAgICAndGFyZ2V0LWVuZHBvaW50JzogJ291dHNpZGUtdG8tbm9kZScsXG4gICAgJ2xpbmUtZGFzaC1wYXR0ZXJuJzogWzYsIDNdLFxuICAgICdsaW5lLWRhc2gtb2Zmc2V0JzogMFxuICB9LCBbe1xuICAgIG5hbWU6ICdhcnJvdy1zaGFwZScsXG4gICAgdmFsdWU6ICdub25lJ1xuICB9LCB7XG4gICAgbmFtZTogJ2Fycm93LWNvbG9yJyxcbiAgICB2YWx1ZTogJyM5OTknXG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctZmlsbCcsXG4gICAgdmFsdWU6ICdmaWxsZWQnXG4gIH0sIHtcbiAgICBuYW1lOiAnYXJyb3ctd2lkdGgnLFxuICAgIHZhbHVlOiAxXG4gIH1dLnJlZHVjZShmdW5jdGlvbiAoY3NzLCBwcm9wKSB7XG4gICAgc3R5Zm4kMi5hcnJvd1ByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgdmFyIG5hbWUgPSBwcmVmaXggKyAnLScgKyBwcm9wLm5hbWU7XG4gICAgICB2YXIgdmFsID0gcHJvcC52YWx1ZTtcbiAgICAgIGNzc1tuYW1lXSA9IHZhbDtcbiAgICB9KTtcbiAgICByZXR1cm4gY3NzO1xuICB9LCB7fSkpO1xuICB2YXIgcGFyc2VkUHJvcHMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHRoaXMucHJvcGVydGllc1tpXTtcbiAgICBpZiAocHJvcC5wb2ludHNUbykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgIHZhciB2YWwgPSByYXdQcm9wc1tuYW1lXTtcbiAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsKTtcbiAgICBwYXJzZWRQcm9wc1tuYW1lXSA9IHBhcnNlZFByb3A7XG4gIH1cbiAgX3AuZGVmYXVsdFByb3BlcnRpZXMgPSBwYXJzZWRQcm9wcztcbiAgcmV0dXJuIF9wLmRlZmF1bHRQcm9wZXJ0aWVzO1xufTtcbnN0eWZuJDIuYWRkRGVmYXVsdFN0eWxlc2hlZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VsZWN0b3IoJzpwYXJlbnQnKS5jc3Moe1xuICAgICdzaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICdwYWRkaW5nJzogMTAsXG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnI2VlZScsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjY2NjJyxcbiAgICAnYm9yZGVyLXdpZHRoJzogMVxuICB9KS5zZWxlY3RvcignZWRnZScpLmNzcyh7XG4gICAgJ3dpZHRoJzogM1xuICB9KS5zZWxlY3RvcignOmxvb3AnKS5jc3Moe1xuICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInXG4gIH0pLnNlbGVjdG9yKCdlZGdlOmNvbXBvdW5kJykuY3NzKHtcbiAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJyxcbiAgICAnc291cmNlLWVuZHBvaW50JzogJ291dHNpZGUtdG8tbGluZScsXG4gICAgJ3RhcmdldC1lbmRwb2ludCc6ICdvdXRzaWRlLXRvLWxpbmUnXG4gIH0pLnNlbGVjdG9yKCc6c2VsZWN0ZWQnKS5jc3Moe1xuICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdsaW5lLWNvbG9yJzogJyMwMTY5RDknLFxuICAgICdzb3VyY2UtYXJyb3ctY29sb3InOiAnIzAxNjlEOScsXG4gICAgJ3RhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbWlkLXNvdXJjZS1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5JyxcbiAgICAnbWlkLXRhcmdldC1hcnJvdy1jb2xvcic6ICcjMDE2OUQ5J1xuICB9KS5zZWxlY3RvcignOnBhcmVudDpzZWxlY3RlZCcpLmNzcyh7XG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnI0NDRTFGOScsXG4gICAgJ2JvcmRlci1jb2xvcic6ICcjYWVjOGU1J1xuICB9KS5zZWxlY3RvcignOmFjdGl2ZScpLmNzcyh7XG4gICAgJ292ZXJsYXktY29sb3InOiAnYmxhY2snLFxuICAgICdvdmVybGF5LXBhZGRpbmcnOiAxMCxcbiAgICAnb3ZlcmxheS1vcGFjaXR5JzogMC4yNVxuICB9KTtcbiAgdGhpcy5kZWZhdWx0TGVuZ3RoID0gdGhpcy5sZW5ndGg7XG59O1xuXG52YXIgc3R5Zm4kMSA9IHt9O1xuXG4vLyBhIGNhY2hpbmcgbGF5ZXIgZm9yIHByb3BlcnR5IHBhcnNpbmdcbnN0eWZuJDEucGFyc2UgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gZnVuY3Rpb24gdmFsdWVzIGNhbid0IGJlIGNhY2hlZCBpbiBhbGwgY2FzZXMsIGFuZCB0aGVyZSBpc24ndCBtdWNoIGJlbmVmaXQgb2YgY2FjaGluZyB0aGVtIGFueXdheVxuICBpZiAoZm4kNih2YWx1ZSkpIHtcbiAgICByZXR1cm4gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICB9XG4gIHZhciBmbGF0S2V5ID0gcHJvcElzRmxhdCA9PT0gJ21hcHBpbmcnIHx8IHByb3BJc0ZsYXQgPT09IHRydWUgfHwgcHJvcElzRmxhdCA9PT0gZmFsc2UgfHwgcHJvcElzRmxhdCA9PSBudWxsID8gJ2RvbnRjYXJlJyA6IHByb3BJc0ZsYXQ7XG4gIHZhciBieXBhc3NLZXkgPSBwcm9wSXNCeXBhc3MgPyAndCcgOiAnZic7XG4gIHZhciB2YWx1ZUtleSA9ICcnICsgdmFsdWU7XG4gIHZhciBhcmdIYXNoID0gaGFzaFN0cmluZ3MobmFtZSwgdmFsdWVLZXksIGJ5cGFzc0tleSwgZmxhdEtleSk7XG4gIHZhciBwcm9wQ2FjaGUgPSBzZWxmLnByb3BDYWNoZSA9IHNlbGYucHJvcENhY2hlIHx8IFtdO1xuICB2YXIgcmV0O1xuICBpZiAoIShyZXQgPSBwcm9wQ2FjaGVbYXJnSGFzaF0pKSB7XG4gICAgcmV0ID0gcHJvcENhY2hlW2FyZ0hhc2hdID0gc2VsZi5wYXJzZUltcGxXYXJuKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICB9XG5cbiAgLy8gLSBieXBhc3NlcyBjYW4ndCBiZSBzaGFyZWQgYi9jIHRoZSB2YWx1ZSBjYW4gYmUgY2hhbmdlZCBieSBhbmltYXRpb25zIG9yIG90aGVyd2lzZSBvdmVycmlkZGVuXG4gIC8vIC0gbWFwcGluZ3MgY2FuJ3QgYmUgc2hhcmVkIGIvYyBtYXBwaW5ncyBhcmUgcGVyLWVsZW1lbnRcbiAgaWYgKHByb3BJc0J5cGFzcyB8fCBwcm9wSXNGbGF0ID09PSAnbWFwcGluZycpIHtcbiAgICAvLyBuZWVkIGEgY29weSBzaW5jZSBwcm9wcyBhcmUgbXV0YXRlZCBsYXRlciBpbiB0aGVpciBsaWZlY3ljbGVzXG4gICAgcmV0ID0gY29weShyZXQpO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIHJldC52YWx1ZSA9IGNvcHkocmV0LnZhbHVlKTsgLy8gYmVjYXVzZSBpdCBjb3VsZCBiZSBhbiBhcnJheSwgZS5nLiBjb2xvdXJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5zdHlmbiQxLnBhcnNlSW1wbFdhcm4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCkge1xuICB2YXIgcHJvcCA9IHRoaXMucGFyc2VJbXBsKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpO1xuICBpZiAoIXByb3AgJiYgdmFsdWUgIT0gbnVsbCkge1xuICAgIHdhcm4oXCJUaGUgc3R5bGUgcHJvcGVydHkgYFwiLmNvbmNhdChuYW1lLCBcIjogXCIpLmNvbmNhdCh2YWx1ZSwgXCJgIGlzIGludmFsaWRcIikpO1xuICB9XG4gIGlmIChwcm9wICYmIChwcm9wLm5hbWUgPT09ICd3aWR0aCcgfHwgcHJvcC5uYW1lID09PSAnaGVpZ2h0JykgJiYgdmFsdWUgPT09ICdsYWJlbCcpIHtcbiAgICB3YXJuKCdUaGUgc3R5bGUgdmFsdWUgb2YgYGxhYmVsYCBpcyBkZXByZWNhdGVkIGZvciBgJyArIHByb3AubmFtZSArICdgJyk7XG4gIH1cbiAgcmV0dXJuIHByb3A7XG59O1xuXG4vLyBwYXJzZSBhIHByb3BlcnR5OyByZXR1cm4gbnVsbCBvbiBpbnZhbGlkOyByZXR1cm4gcGFyc2VkIHByb3BlcnR5IG90aGVyd2lzZVxuLy8gZmllbGRzIDpcbi8vIC0gbmFtZSA6IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuLy8gLSB2YWx1ZSA6IHRoZSBwYXJzZWQsIG5hdGl2ZS10eXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbi8vIC0gc3RyVmFsdWUgOiBhIHN0cmluZyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIHByb3BlcnR5IHZhbHVlIGluIHZhbGlkIGNzc1xuLy8gLSBieXBhc3MgOiB0cnVlIGlmZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHlcbnN0eWZuJDEucGFyc2VJbXBsID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBuYW1lID0gY2FtZWwyZGFzaChuYW1lKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuXG4gIHZhciBwcm9wZXJ0eSA9IHNlbGYucHJvcGVydGllc1tuYW1lXTtcbiAgdmFyIHBhc3NlZFZhbHVlID0gdmFsdWU7XG4gIHZhciB0eXBlcyA9IHNlbGYudHlwZXM7XG4gIGlmICghcHJvcGVydHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyByZXR1cm4gbnVsbCBvbiBwcm9wZXJ0eSBvZiB1bmtub3duIG5hbWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBjYW4ndCBhc3NpZ24gdW5kZWZpbmVkXG5cbiAgLy8gdGhlIHByb3BlcnR5IG1heSBiZSBhbiBhbGlhc1xuICBpZiAocHJvcGVydHkuYWxpYXMpIHtcbiAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnBvaW50c1RvO1xuICAgIG5hbWUgPSBwcm9wZXJ0eS5uYW1lO1xuICB9XG4gIHZhciB2YWx1ZUlzU3RyaW5nID0gc3RyaW5nKHZhbHVlKTtcbiAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAvLyB0cmltIHRoZSB2YWx1ZSB0byBtYWtlIHBhcnNpbmcgZWFzaWVyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wZXJ0eS50eXBlO1xuICBpZiAoIXR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBubyB0eXBlLCBubyBsdWNrXG5cbiAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcbiAgaWYgKHByb3BJc0J5cGFzcyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYnlwYXNzOiB0cnVlLFxuICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIGEgZnVuY3Rpb24gdXNlZCBhcyBhIG1hcHBlclxuICBpZiAoZm4kNih2YWx1ZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHN0clZhbHVlOiAnZm4nLFxuICAgICAgbWFwcGVkOiB0eXBlcy5mbixcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuICB2YXIgZGF0YSwgbWFwRGF0YTtcbiAgaWYgKCF2YWx1ZUlzU3RyaW5nIHx8IHByb3BJc0ZsYXQgfHwgdmFsdWUubGVuZ3RoIDwgNyB8fCB2YWx1ZVsxXSAhPT0gJ2EnKSA7IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSA3ICYmIHZhbHVlWzBdID09PSAnZCcgJiYgKGRhdGEgPSBuZXcgUmVnRXhwKHR5cGVzLmRhdGEucmVnZXgpLmV4ZWModmFsdWUpKSkge1xuICAgIGlmIChwcm9wSXNCeXBhc3MpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG5cbiAgICB2YXIgbWFwcGVkID0gdHlwZXMuZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgIGZpZWxkOiBkYXRhWzFdLFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+PSAxMCAmJiB2YWx1ZVswXSA9PT0gJ20nICYmIChtYXBEYXRhID0gbmV3IFJlZ0V4cCh0eXBlcy5tYXBEYXRhLnJlZ2V4KS5leGVjKHZhbHVlKSkpIHtcbiAgICBpZiAocHJvcElzQnlwYXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuICAgIGlmICh0eXBlLm11bHRpcGxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBpbXBvc3NpYmxlIHRvIG1hcCB0byBudW1cblxuICAgIHZhciBfbWFwcGVkID0gdHlwZXMubWFwRGF0YTtcblxuICAgIC8vIHdlIGNhbiBtYXAgb25seSBpZiB0aGUgdHlwZSBpcyBhIGNvbG91ciBvciBhIG51bWJlclxuICAgIGlmICghKHR5cGUuY29sb3IgfHwgdHlwZS5udW1iZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UobmFtZSwgbWFwRGF0YVs0XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgaWYgKCF2YWx1ZU1pbiB8fCB2YWx1ZU1pbi5tYXBwZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG5cbiAgICB2YXIgdmFsdWVNYXggPSB0aGlzLnBhcnNlKG5hbWUsIG1hcERhdGFbNV0pOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuICAgIGlmICghdmFsdWVNYXggfHwgdmFsdWVNYXgubWFwcGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBjYW4ndCBiZSBpbnZhbGlkIG9yIG1hcHBlZFxuXG4gICAgLy8gY2hlY2sgaWYgdmFsdWVNaW4gYW5kIHZhbHVlTWF4IGFyZSB0aGUgc2FtZVxuICAgIGlmICh2YWx1ZU1pbi5wZlZhbHVlID09PSB2YWx1ZU1heC5wZlZhbHVlIHx8IHZhbHVlTWluLnN0clZhbHVlID09PSB2YWx1ZU1heC5zdHJWYWx1ZSkge1xuICAgICAgd2FybignYCcgKyBuYW1lICsgJzogJyArIHZhbHVlICsgJ2AgaXMgbm90IGEgdmFsaWQgbWFwcGVyIGJlY2F1c2UgdGhlIG91dHB1dCByYW5nZSBpcyB6ZXJvOyBjb252ZXJ0aW5nIHRvIGAnICsgbmFtZSArICc6ICcgKyB2YWx1ZU1pbi5zdHJWYWx1ZSArICdgJyk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZU1pbi5zdHJWYWx1ZSk7IC8vIGNhbid0IG1ha2UgbXVjaCBvZiBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcbiAgICB9IGVsc2UgaWYgKHR5cGUuY29sb3IpIHtcbiAgICAgIHZhciBjMSA9IHZhbHVlTWluLnZhbHVlO1xuICAgICAgdmFyIGMyID0gdmFsdWVNYXgudmFsdWU7XG4gICAgICB2YXIgc2FtZSA9IGMxWzBdID09PSBjMlswXSAvLyByZWRcbiAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgJiYgYzFbMl0gPT09IGMyWzJdIC8vIGJsdWVcbiAgICAgICYmIChcbiAgICAgIC8vIG9wdGlvbmFsIGFscGhhXG4gICAgICBjMVszXSA9PT0gYzJbM10gLy8gc2FtZSBhbHBoYSBvdXRyaWdodFxuICAgICAgfHwgKGMxWzNdID09IG51bGwgfHwgYzFbM10gPT09IDEgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMT9cbiAgICAgICkgJiYgKGMyWzNdID09IG51bGwgfHwgYzJbM10gPT09IDEpIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDI/XG4gICAgICApO1xuICAgICAgaWYgKHNhbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBjYW4ndCBtYWtlIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBtYXBEYXRhLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBtYXBwZWQ6IF9tYXBwZWQsXG4gICAgICBmaWVsZDogbWFwRGF0YVsxXSxcbiAgICAgIGZpZWxkTWluOiBwYXJzZUZsb2F0KG1hcERhdGFbMl0pLFxuICAgICAgLy8gbWluICYgbWF4IGFyZSBudW1lcmljXG4gICAgICBmaWVsZE1heDogcGFyc2VGbG9hdChtYXBEYXRhWzNdKSxcbiAgICAgIHZhbHVlTWluOiB2YWx1ZU1pbi52YWx1ZSxcbiAgICAgIHZhbHVlTWF4OiB2YWx1ZU1heC52YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfVxuICBpZiAodHlwZS5tdWx0aXBsZSAmJiBwcm9wSXNGbGF0ICE9PSAnbXVsdGlwbGUnKSB7XG4gICAgdmFyIHZhbHM7XG4gICAgaWYgKHZhbHVlSXNTdHJpbmcpIHtcbiAgICAgIHZhbHMgPSB2YWx1ZS5zcGxpdCgvXFxzKy8pO1xuICAgIH0gZWxzZSBpZiAoYXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWxzID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHMgPSBbdmFsdWVdO1xuICAgIH1cbiAgICBpZiAodHlwZS5ldmVuTXVsdGlwbGUgJiYgdmFscy5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHZhbEFyciA9IFtdO1xuICAgIHZhciB1bml0c0FyciA9IFtdO1xuICAgIHZhciBwZlZhbEFyciA9IFtdO1xuICAgIHZhciBzdHJWYWwgPSAnJztcbiAgICB2YXIgaGFzRW51bSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHAgPSBzZWxmLnBhcnNlKG5hbWUsIHZhbHNbaV0sIHByb3BJc0J5cGFzcywgJ211bHRpcGxlJyk7XG4gICAgICBoYXNFbnVtID0gaGFzRW51bSB8fCBzdHJpbmcocC52YWx1ZSk7XG4gICAgICB2YWxBcnIucHVzaChwLnZhbHVlKTtcbiAgICAgIHBmVmFsQXJyLnB1c2gocC5wZlZhbHVlICE9IG51bGwgPyBwLnBmVmFsdWUgOiBwLnZhbHVlKTtcbiAgICAgIHVuaXRzQXJyLnB1c2gocC51bml0cyk7XG4gICAgICBzdHJWYWwgKz0gKGkgPiAwID8gJyAnIDogJycpICsgcC5zdHJWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUudmFsaWRhdGUgJiYgIXR5cGUudmFsaWRhdGUodmFsQXJyLCB1bml0c0FycikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZS5zaW5nbGVFbnVtICYmIGhhc0VudW0pIHtcbiAgICAgIGlmICh2YWxBcnIubGVuZ3RoID09PSAxICYmIHN0cmluZyh2YWxBcnJbMF0pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsQXJyWzBdLFxuICAgICAgICAgIHN0clZhbHVlOiB2YWxBcnJbMF0sXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiB2YWxBcnIsXG4gICAgICBwZlZhbHVlOiBwZlZhbEFycixcbiAgICAgIHN0clZhbHVlOiBzdHJWYWwsXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzcyxcbiAgICAgIHVuaXRzOiB1bml0c0FyclxuICAgIH07XG4gIH1cblxuICAvLyBzZXZlcmFsIHR5cGVzIGFsc28gYWxsb3cgZW51bXNcbiAgdmFyIGNoZWNrRW51bXMgPSBmdW5jdGlvbiBjaGVja0VudW1zKCkge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0eXBlLmVudW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIGVuID0gdHlwZS5lbnVtc1tfaV07XG4gICAgICBpZiAoZW4gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG4gIGlmICh0eXBlLm51bWJlcikge1xuICAgIHZhciB1bml0cztcbiAgICB2YXIgaW1wbGljaXRVbml0cyA9ICdweCc7IC8vIG5vdCBzZXQgPT4gcHhcblxuICAgIGlmICh0eXBlLnVuaXRzKSB7XG4gICAgICAvLyB1c2Ugc3BlY2lmaWVkIHVuaXRzIGlmIHNldFxuICAgICAgdW5pdHMgPSB0eXBlLnVuaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZS5pbXBsaWNpdFVuaXRzKSB7XG4gICAgICBpbXBsaWNpdFVuaXRzID0gdHlwZS5pbXBsaWNpdFVuaXRzO1xuICAgIH1cbiAgICBpZiAoIXR5cGUudW5pdGxlc3MpIHtcbiAgICAgIGlmICh2YWx1ZUlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB1bml0c1JlZ2V4ID0gJ3B4fGVtJyArICh0eXBlLmFsbG93UGVyY2VudCA/ICd8XFxcXCUnIDogJycpO1xuICAgICAgICBpZiAodW5pdHMpIHtcbiAgICAgICAgICB1bml0c1JlZ2V4ID0gdW5pdHM7XG4gICAgICAgIH0gLy8gb25seSBhbGxvdyBleHBsaWNpdCB1bml0cyBpZiBzbyBzZXRcbiAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goJ14oJyArIG51bWJlciArICcpKCcgKyB1bml0c1JlZ2V4ICsgJyk/JyArICckJyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgdW5pdHMgPSBtYXRjaFsyXSB8fCBpbXBsaWNpdFVuaXRzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF1bml0cyB8fCB0eXBlLmltcGxpY2l0VW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBpbXBsaWNpdFVuaXRzOyAvLyBpbXBsaWNpdGx5IHB4IGlmIHVuc3BlY2lmaWVkXG4gICAgICB9XG4gICAgfVxuICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICAvLyBpZiBub3QgYSBudW1iZXIgYW5kIGVudW1zIG5vdCBhbGxvd2VkLCB0aGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoaXMgbnVtYmVyIHR5cGUgYWxzbyBhY2NlcHRzIHNwZWNpYWwga2V5d29yZHMgaW4gcGxhY2Ugb2YgbnVtYmVyc1xuICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG4gICAgaWYgKGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhbHVlID0gcGFzc2VkVmFsdWU7XG4gICAgICByZXR1cm4gY2hlY2tFbnVtcygpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlclxuICAgIGlmICh0eXBlLmludGVnZXIgJiYgIWludGVnZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB2YWx1ZSBpcyB3aXRoaW4gcmFuZ2VcbiAgICBpZiAodHlwZS5taW4gIT09IHVuZGVmaW5lZCAmJiAodmFsdWUgPCB0eXBlLm1pbiB8fCB0eXBlLnN0cmljdE1pbiAmJiB2YWx1ZSA9PT0gdHlwZS5taW4pIHx8IHR5cGUubWF4ICE9PSB1bmRlZmluZWQgJiYgKHZhbHVlID4gdHlwZS5tYXggfHwgdHlwZS5zdHJpY3RNYXggJiYgdmFsdWUgPT09IHR5cGUubWF4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByZXQgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUgKyAodW5pdHMgPyB1bml0cyA6ICcnKSxcbiAgICAgIHVuaXRzOiB1bml0cyxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBwaXhlbHNcbiAgICBpZiAodHlwZS51bml0bGVzcyB8fCB1bml0cyAhPT0gJ3B4JyAmJiB1bml0cyAhPT0gJ2VtJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnBmVmFsdWUgPSB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyB2YWx1ZSA6IHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBtc1xuICAgIGlmICh1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAnbXMnID8gdmFsdWUgOiAxMDAwICogdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHJhZFxuICAgIGlmICh1bml0cyA9PT0gJ2RlZycgfHwgdW5pdHMgPT09ICdyYWQnKSB7XG4gICAgICByZXQucGZWYWx1ZSA9IHVuaXRzID09PSAncmFkJyA/IHZhbHVlIDogZGVnMnJhZCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gbm9ybWFsaXplIHZhbHVlIGluICVcbiAgICBpZiAodW5pdHMgPT09ICclJykge1xuICAgICAgcmV0LnBmVmFsdWUgPSB2YWx1ZSAvIDEwMDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSBlbHNlIGlmICh0eXBlLnByb3BMaXN0KSB7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgdmFyIHByb3BzU3RyID0gJycgKyB2YWx1ZTtcbiAgICBpZiAocHJvcHNTdHIgPT09ICdub25lJykgOyBlbHNlIHtcbiAgICAgIC8vIGdvIG92ZXIgZWFjaCBwcm9wXG5cbiAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoL1xccyosXFxzKnxcXHMrLyk7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcHNTcGxpdFtfaTJdLnRyaW0oKTtcbiAgICAgICAgaWYgKHNlbGYucHJvcGVydGllc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICBwcm9wcy5wdXNoKHByb3BOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKCdgJyArIHByb3BOYW1lICsgJ2AgaXMgbm90IGEgdmFsaWQgcHJvcGVydHkgbmFtZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHZhbHVlOiBwcm9wcyxcbiAgICAgIHN0clZhbHVlOiBwcm9wcy5sZW5ndGggPT09IDAgPyAnbm9uZScgOiBwcm9wcy5qb2luKCcgJyksXG4gICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZS5jb2xvcikge1xuICAgIHZhciB0dXBsZSA9IGNvbG9yMnR1cGxlKHZhbHVlKTtcbiAgICBpZiAoIXR1cGxlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB2YWx1ZTogdHVwbGUsXG4gICAgICBwZlZhbHVlOiB0dXBsZSxcbiAgICAgIHN0clZhbHVlOiAncmdiKCcgKyB0dXBsZVswXSArICcsJyArIHR1cGxlWzFdICsgJywnICsgdHVwbGVbMl0gKyAnKScsXG4gICAgICAvLyBuLmIuIG5vIHNwYWNlcyBiL2Mgb2YgbXVsdGlwbGUgc3VwcG9ydFxuICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGUucmVnZXggfHwgdHlwZS5yZWdleGVzKSB7XG4gICAgLy8gZmlyc3QgY2hlY2sgZW51bXNcbiAgICBpZiAodHlwZS5lbnVtcykge1xuICAgICAgdmFyIGVudW1Qcm9wID0gY2hlY2tFbnVtcygpO1xuICAgICAgaWYgKGVudW1Qcm9wKSB7XG4gICAgICAgIHJldHVybiBlbnVtUHJvcDtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlZ2V4ZXMgPSB0eXBlLnJlZ2V4ZXMgPyB0eXBlLnJlZ2V4ZXMgOiBbdHlwZS5yZWdleF07XG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgcmVnZXhlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4ZXNbX2kzXSk7IC8vIG1ha2UgYSByZWdleCBmcm9tIHRoZSB0eXBlIHN0cmluZ1xuICAgICAgdmFyIG0gPSByZWdleC5leGVjKHZhbHVlKTtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIC8vIHJlZ2V4IG1hdGNoZXNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgIHZhbHVlOiB0eXBlLnNpbmdsZVJlZ2V4TWF0Y2hWYWx1ZSA/IG1bMV0gOiBtLFxuICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsOyAvLyBkaWRuJ3QgbWF0Y2ggYW55XG4gIH0gZWxzZSBpZiAodHlwZS5zdHJpbmcpIHtcbiAgICAvLyBqdXN0IHJldHVyblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlLmVudW1zKSB7XG4gICAgLy8gY2hlY2sgZW51bXMgbGFzdCBiZWNhdXNlIGl0J3MgYSBjb21ibyB0eXBlIGluIG90aGVyc1xuICAgIHJldHVybiBjaGVja0VudW1zKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vdCBhIHR5cGUgd2UgY2FuIGhhbmRsZVxuICB9XG59O1xuXG52YXIgX1N0eWxlID0gZnVuY3Rpb24gU3R5bGUoY3kpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF9TdHlsZSkpIHtcbiAgICByZXR1cm4gbmV3IF9TdHlsZShjeSk7XG4gIH1cbiAgaWYgKCFjb3JlKGN5KSkge1xuICAgIGVycm9yKCdBIHN0eWxlIG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY3k6IGN5LFxuICAgIGNvcmVTdHlsZToge31cbiAgfTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnJlc2V0VG9EZWZhdWx0KCk7XG59O1xudmFyIHN0eWZuID0gX1N0eWxlLnByb3RvdHlwZTtcbnN0eWZuLmluc3RhbmNlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJ3N0eWxlJztcbn07XG5cbi8vIHJlbW92ZSBhbGwgY29udGV4dHNcbnN0eWZuLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICB2YXIgY3kgPSBfcC5jeTtcbiAgdmFyIGVsZXMgPSBjeS5lbGVtZW50cygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdW5kZWZpbmVkO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgX3AuY29udGV4dFN0eWxlcyA9IHt9O1xuICBfcC5wcm9wRGlmZnMgPSB7fTtcbiAgdGhpcy5jbGVhbkVsZW1lbnRzKGVsZXMsIHRydWUpO1xuICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBlbGVfcCA9IGVsZVswXS5fcHJpdmF0ZTtcbiAgICBlbGVfcC5zdHlsZURpcnR5ID0gdHJ1ZTtcbiAgICBlbGVfcC5hcHBsaWVkSW5pdFN0eWxlID0gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5zdHlmbi5yZXNldFRvRGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbGVhcigpO1xuICB0aGlzLmFkZERlZmF1bHRTdHlsZXNoZWV0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gYnVpbGRzIGEgc3R5bGUgb2JqZWN0IGZvciB0aGUgJ2NvcmUnIHNlbGVjdG9yXG5zdHlmbi5jb3JlID0gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gIHJldHVybiB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZVtwcm9wTmFtZV0gfHwgdGhpcy5nZXREZWZhdWx0UHJvcGVydHkocHJvcE5hbWUpO1xufTtcblxuLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuc3R5Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3JTdHIpIHtcbiAgLy8gJ2NvcmUnIGlzIGEgc3BlY2lhbCBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkIGEgc2VsZWN0b3JcbiAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgU2VsZWN0b3Ioc2VsZWN0b3JTdHIpO1xuICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7IC8vIG5ldyBjb250ZXh0IG1lYW5zIG5ldyBpbmRleFxuICB0aGlzW2ldID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICBtYXBwZWRQcm9wZXJ0aWVzOiBbXSxcbiAgICBpbmRleDogaVxuICB9O1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGFkZCBvbmUgb3IgbWFueSBjc3MgcnVsZXMgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuc3R5Zm4uY3NzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbWFwID0gYXJnc1swXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBzZWxmLnByb3BlcnRpZXNbaV07XG4gICAgICB2YXIgbWFwVmFsID0gbWFwW3Byb3AubmFtZV07XG4gICAgICBpZiAobWFwVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWFwVmFsID0gbWFwW2Rhc2gyY2FtZWwocHJvcC5uYW1lKV07XG4gICAgICB9XG4gICAgICBpZiAobWFwVmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jc3NSdWxlKHByb3AubmFtZSwgbWFwVmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICB0aGlzLmNzc1J1bGUoYXJnc1swXSwgYXJnc1sxXSk7XG4gIH1cblxuICAvLyBkbyBub3RoaW5nIGlmIGFyZ3MgYXJlIGludmFsaWRcblxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5zdHlmbi5zdHlsZSA9IHN0eWZuLmNzcztcblxuLy8gYWRkIGEgc2luZ2xlIGNzcyBydWxlIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbnN0eWZuLmNzc1J1bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUpO1xuXG4gIC8vIGFkZCBwcm9wZXJ0eSB0byBjdXJyZW50IGNvbnRleHQgaWYgdmFsaWRcbiAgaWYgKHByb3BlcnR5KSB7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuICAgIHRoaXNbaV0ucHJvcGVydGllc1twcm9wZXJ0eS5uYW1lXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICBpZiAocHJvcGVydHkubmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKSAmJiBwcm9wZXJ0eS52YWx1ZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHkubmFtZS5tYXRjaCgvc3RyaXBlLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKSAmJiBwcm9wZXJ0eS52YWx1ZSkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNTdHJpcGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHkubWFwcGVkKSB7XG4gICAgICB0aGlzW2ldLm1hcHBlZFByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHRvIGNvcmUgc3R5bGUgaWYgbmVjZXNzYXJ5XG4gICAgdmFyIGN1cnJlbnRTZWxlY3RvcklzQ29yZSA9ICF0aGlzW2ldLnNlbGVjdG9yO1xuICAgIGlmIChjdXJyZW50U2VsZWN0b3JJc0NvcmUpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlW3Byb3BlcnR5Lm5hbWVdID0gcHJvcGVydHk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcbnN0eWZuLmFwcGVuZCA9IGZ1bmN0aW9uIChzdHlsZSkge1xuICBpZiAoc3R5bGVzaGVldChzdHlsZSkpIHtcbiAgICBzdHlsZS5hcHBlbmRUb1N0eWxlKHRoaXMpO1xuICB9IGVsc2UgaWYgKGFycmF5KHN0eWxlKSkge1xuICAgIHRoaXMuYXBwZW5kRnJvbUpzb24oc3R5bGUpO1xuICB9IGVsc2UgaWYgKHN0cmluZyhzdHlsZSkpIHtcbiAgICB0aGlzLmFwcGVuZEZyb21TdHJpbmcoc3R5bGUpO1xuICB9IC8vIHlvdSBwcm9iYWJseSB3b3VsZG4ndCB3YW50IHRvIGFwcGVuZCBhIFN0eWxlLCBzaW5jZSB5b3UnZCBkdXBsaWNhdGUgdGhlIGRlZmF1bHQgcGFydHNcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHN0YXRpYyBmdW5jdGlvblxuX1N0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24gKGN5LCBqc29uKSB7XG4gIHZhciBzdHlsZSA9IG5ldyBfU3R5bGUoY3kpO1xuICBzdHlsZS5mcm9tSnNvbihqc29uKTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcbl9TdHlsZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKGN5LCBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBfU3R5bGUoY3kpLmZyb21TdHJpbmcoc3RyaW5nKTtcbn07XG5bc3R5Zm4kOCwgc3R5Zm4kNywgc3R5Zm4kNiwgc3R5Zm4kNSwgc3R5Zm4kNCwgc3R5Zm4kMywgc3R5Zm4kMiwgc3R5Zm4kMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKHN0eWZuLCBwcm9wcyk7XG59KTtcbl9TdHlsZS50eXBlcyA9IHN0eWZuLnR5cGVzO1xuX1N0eWxlLnByb3BlcnRpZXMgPSBzdHlmbi5wcm9wZXJ0aWVzO1xuX1N0eWxlLnByb3BlcnR5R3JvdXBzID0gc3R5Zm4ucHJvcGVydHlHcm91cHM7XG5fU3R5bGUucHJvcGVydHlHcm91cE5hbWVzID0gc3R5Zm4ucHJvcGVydHlHcm91cE5hbWVzO1xuX1N0eWxlLnByb3BlcnR5R3JvdXBLZXlzID0gc3R5Zm4ucHJvcGVydHlHcm91cEtleXM7XG5cbnZhciBjb3JlZm4kMiA9IHtcbiAgc3R5bGU6IGZ1bmN0aW9uIHN0eWxlKG5ld1N0eWxlKSB7XG4gICAgaWYgKG5ld1N0eWxlKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuc2V0U3R5bGUobmV3U3R5bGUpO1xuICAgICAgcy51cGRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGU7XG4gIH0sXG4gIHNldFN0eWxlOiBmdW5jdGlvbiBzZXRTdHlsZShzdHlsZSkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKHN0eWxlc2hlZXQoc3R5bGUpKSB7XG4gICAgICBfcC5zdHlsZSA9IHN0eWxlLmdlbmVyYXRlU3R5bGUodGhpcyk7XG4gICAgfSBlbHNlIGlmIChhcnJheShzdHlsZSkpIHtcbiAgICAgIF9wLnN0eWxlID0gX1N0eWxlLmZyb21Kc29uKHRoaXMsIHN0eWxlKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyhzdHlsZSkpIHtcbiAgICAgIF9wLnN0eWxlID0gX1N0eWxlLmZyb21TdHJpbmcodGhpcywgc3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcC5zdHlsZSA9IF9TdHlsZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wLnN0eWxlO1xuICB9LFxuICAvLyBlLmcuIGN5LmRhdGEoKSBjaGFuZ2VkID0+IHJlY2FsYyBlbGUgbWFwcGVyc1xuICB1cGRhdGVTdHlsZTogZnVuY3Rpb24gdXBkYXRlU3R5bGUoKSB7XG4gICAgdGhpcy5tdXRhYmxlRWxlbWVudHMoKS51cGRhdGVTdHlsZSgpOyAvLyBqdXN0IHNlbmQgdG8gYWxsIGVsZXNcbiAgfVxufTtcblxudmFyIGRlZmF1bHRTZWxlY3Rpb25UeXBlID0gJ3NpbmdsZSc7XG52YXIgY29yZWZuJDEgPSB7XG4gIGF1dG9sb2NrOiBmdW5jdGlvbiBhdXRvbG9jayhib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvbG9jayA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG9sb2NrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgYXV0b3VuZ3JhYmlmeTogZnVuY3Rpb24gYXV0b3VuZ3JhYmlmeShib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGF1dG91bnNlbGVjdGlmeTogZnVuY3Rpb24gYXV0b3Vuc2VsZWN0aWZ5KGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uIHNlbGVjdGlvblR5cGUoc2VsVHlwZSkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgaWYgKF9wLnNlbGVjdGlvblR5cGUgPT0gbnVsbCkge1xuICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9IGRlZmF1bHRTZWxlY3Rpb25UeXBlO1xuICAgIH1cbiAgICBpZiAoc2VsVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoc2VsVHlwZSA9PT0gJ2FkZGl0aXZlJyB8fCBzZWxUeXBlID09PSAnc2luZ2xlJykge1xuICAgICAgICBfcC5zZWxlY3Rpb25UeXBlID0gc2VsVHlwZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9wLnNlbGVjdGlvblR5cGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24gcGFubmluZ0VuYWJsZWQoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHVzZXJQYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24gdXNlclBhbm5pbmdFbmFibGVkKGJvb2wpIHtcbiAgICBpZiAoYm9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiB6b29taW5nRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgdXNlclpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiB1c2VyWm9vbWluZ0VuYWJsZWQoYm9vbCkge1xuICAgIGlmIChib29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24gYm94U2VsZWN0aW9uRW5hYmxlZChib29sKSB7XG4gICAgaWYgKGJvb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHBhbjogZnVuY3Rpb24gcGFuKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvLyAucGFuKClcbiAgICAgICAgcmV0dXJuIHBhbjtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKHN0cmluZyhhcmdzWzBdKSkge1xuICAgICAgICAgIC8vIC5wYW4oJ3gnKVxuICAgICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgICAgcmV0dXJuIHBhbltkaW1dO1xuICAgICAgICB9IGVsc2UgaWYgKHBsYWluT2JqZWN0KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgLy8gLnBhbih7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcbiAgICAgICAgICBpZiAobnVtYmVyJDEoeCkpIHtcbiAgICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG51bWJlciQxKHkpKSB7XG4gICAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIC8vIC5wYW4oJ3gnLCAxMDApXG4gICAgICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHZhbCA9IGFyZ3NbMV07XG4gICAgICAgIGlmICgoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmIG51bWJlciQxKHZhbCkpIHtcbiAgICAgICAgICBwYW5bZGltXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIGludmFsaWRcbiAgICB9XG4gICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIHBhbkJ5OiBmdW5jdGlvbiBwYW5CeShhcmcwLCBhcmcxKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChwbGFpbk9iamVjdChhcmcwKSkge1xuICAgICAgICAgIC8vIC5wYW5CeSh7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcbiAgICAgICAgICBpZiAobnVtYmVyJDEoeCkpIHtcbiAgICAgICAgICAgIHBhbi54ICs9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChudW1iZXIkMSh5KSkge1xuICAgICAgICAgICAgcGFuLnkgKz0geTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbWl0KCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLy8gLnBhbkJ5KCd4JywgMTAwKVxuICAgICAgICBkaW0gPSBhcmcwO1xuICAgICAgICB2YWwgPSBhcmcxO1xuICAgICAgICBpZiAoKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiBudW1iZXIkMSh2YWwpKSB7XG4gICAgICAgICAgcGFuW2RpbV0gKz0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gaW52YWxpZFxuICAgIH1cbiAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfSxcbiAgZ2M6IGZ1bmN0aW9uIGdjKCkge1xuICAgIHRoaXMubm90aWZ5KCdnYycpO1xuICB9LFxuICBmaXQ6IGZ1bmN0aW9uIGZpdChlbGVtZW50cywgcGFkZGluZykge1xuICAgIHZhciB2aWV3cG9ydFN0YXRlID0gdGhpcy5nZXRGaXRWaWV3cG9ydChlbGVtZW50cywgcGFkZGluZyk7XG4gICAgaWYgKHZpZXdwb3J0U3RhdGUpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBfcC56b29tID0gdmlld3BvcnRTdGF0ZS56b29tO1xuICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG4gICAgICB0aGlzLmVtaXQoJ3BhbiB6b29tIHZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH0sXG4gIGdldEZpdFZpZXdwb3J0OiBmdW5jdGlvbiBnZXRGaXRWaWV3cG9ydChlbGVtZW50cywgcGFkZGluZykge1xuICAgIGlmIChudW1iZXIkMShlbGVtZW50cykgJiYgcGFkZGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgcGFkZGluZyA9IGVsZW1lbnRzO1xuICAgICAgZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYmI7XG4gICAgaWYgKHN0cmluZyhlbGVtZW50cykpIHtcbiAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgIGVsZW1lbnRzID0gdGhpcy4kKHNlbCk7XG4gICAgfSBlbHNlIGlmIChib3VuZGluZ0JveChlbGVtZW50cykpIHtcbiAgICAgIC8vIGFzc3VtZSBiYlxuICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgYmIgPSB7XG4gICAgICAgIHgxOiBiYmUueDEsXG4gICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgIHgyOiBiYmUueDIsXG4gICAgICAgIHkyOiBiYmUueTJcbiAgICAgIH07XG4gICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuICAgIH0gZWxzZSBpZiAoIWVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSAmJiBlbGVtZW50cy5lbXB0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjYW4ndCBmaXQgdG8gbm90aGluZ1xuXG4gICAgYmIgPSBiYiB8fCBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICB2YXIgem9vbTtcbiAgICBwYWRkaW5nID0gbnVtYmVyJDEocGFkZGluZykgPyBwYWRkaW5nIDogMDtcbiAgICBpZiAoIWlzTmFOKHcpICYmICFpc05hTihoKSAmJiB3ID4gMCAmJiBoID4gMCAmJiAhaXNOYU4oYmIudykgJiYgIWlzTmFOKGJiLmgpICYmIGJiLncgPiAwICYmIGJiLmggPiAwKSB7XG4gICAgICB6b29tID0gTWF0aC5taW4oKHcgLSAyICogcGFkZGluZykgLyBiYi53LCAoaCAtIDIgKiBwYWRkaW5nKSAvIGJiLmgpO1xuXG4gICAgICAvLyBjcm9wIHpvb21cbiAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcbiAgICAgIHZhciBwYW4gPSB7XG4gICAgICAgIC8vIG5vdyBwYW4gdG8gbWlkZGxlXG4gICAgICAgIHg6ICh3IC0gem9vbSAqIChiYi54MSArIGJiLngyKSkgLyAyLFxuICAgICAgICB5OiAoaCAtIHpvb20gKiAoYmIueTEgKyBiYi55MikpIC8gMlxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb206IHpvb20sXG4gICAgICAgIHBhbjogcGFuXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0sXG4gIHpvb21SYW5nZTogZnVuY3Rpb24gem9vbVJhbmdlKG1pbiwgbWF4KSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIHZhciBvcHRzID0gbWluO1xuICAgICAgbWluID0gb3B0cy5taW47XG4gICAgICBtYXggPSBvcHRzLm1heDtcbiAgICB9XG4gICAgaWYgKG51bWJlciQxKG1pbikgJiYgbnVtYmVyJDEobWF4KSAmJiBtaW4gPD0gbWF4KSB7XG4gICAgICBfcC5taW5ab29tID0gbWluO1xuICAgICAgX3AubWF4Wm9vbSA9IG1heDtcbiAgICB9IGVsc2UgaWYgKG51bWJlciQxKG1pbikgJiYgbWF4ID09PSB1bmRlZmluZWQgJiYgbWluIDw9IF9wLm1heFpvb20pIHtcbiAgICAgIF9wLm1pblpvb20gPSBtaW47XG4gICAgfSBlbHNlIGlmIChudW1iZXIkMShtYXgpICYmIG1pbiA9PT0gdW5kZWZpbmVkICYmIG1heCA+PSBfcC5taW5ab29tKSB7XG4gICAgICBfcC5tYXhab29tID0gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbWluWm9vbTogZnVuY3Rpb24gbWluWm9vbSh6b29tKSB7XG4gICAgaWYgKHpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWluWm9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuem9vbVJhbmdlKHtcbiAgICAgICAgbWluOiB6b29tXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIG1heFpvb206IGZ1bmN0aW9uIG1heFpvb20oem9vbSkge1xuICAgIGlmICh6b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1heFpvb207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnpvb21SYW5nZSh7XG4gICAgICAgIG1heDogem9vbVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBnZXRab29tZWRWaWV3cG9ydDogZnVuY3Rpb24gZ2V0Wm9vbWVkVmlld3BvcnQocGFyYW1zKSB7XG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICB2YXIgY3VycmVudFBhbiA9IF9wLnBhbjtcbiAgICB2YXIgY3VycmVudFpvb20gPSBfcC56b29tO1xuICAgIHZhciBwb3M7IC8vIGluIHJlbmRlcmVkIHB4XG4gICAgdmFyIHpvb207XG4gICAgdmFyIGJhaWwgPSBmYWxzZTtcbiAgICBpZiAoIV9wLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICAvLyB6b29taW5nIGRpc2FibGVkXG4gICAgICBiYWlsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG51bWJlciQxKHBhcmFtcykpIHtcbiAgICAgIC8vIHRoZW4gc2V0IHRoZSB6b29tXG4gICAgICB6b29tID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAocGxhaW5PYmplY3QocGFyYW1zKSkge1xuICAgICAgLy8gdGhlbiB6b29tIGFib3V0IGEgcG9pbnRcbiAgICAgIHpvb20gPSBwYXJhbXMubGV2ZWw7XG4gICAgICBpZiAocGFyYW1zLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgcG9zID0gbW9kZWxUb1JlbmRlcmVkUG9zaXRpb24kMShwYXJhbXMucG9zaXRpb24sIGN1cnJlbnRab29tLCBjdXJyZW50UGFuKTtcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgICBwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3MgIT0gbnVsbCAmJiAhX3AucGFubmluZ0VuYWJsZWQpIHtcbiAgICAgICAgLy8gcGFubmluZyBkaXNhYmxlZFxuICAgICAgICBiYWlsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjcm9wIHpvb21cbiAgICB6b29tID0gem9vbSA+IF9wLm1heFpvb20gPyBfcC5tYXhab29tIDogem9vbTtcbiAgICB6b29tID0gem9vbSA8IF9wLm1pblpvb20gPyBfcC5taW5ab29tIDogem9vbTtcblxuICAgIC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuICAgIGlmIChiYWlsIHx8ICFudW1iZXIkMSh6b29tKSB8fCB6b29tID09PSBjdXJyZW50Wm9vbSB8fCBwb3MgIT0gbnVsbCAmJiAoIW51bWJlciQxKHBvcy54KSB8fCAhbnVtYmVyJDEocG9zLnkpKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwb3MgIT0gbnVsbCkge1xuICAgICAgLy8gc2V0IHpvb20gYWJvdXQgcG9zaXRpb25cbiAgICAgIHZhciBwYW4xID0gY3VycmVudFBhbjtcbiAgICAgIHZhciB6b29tMSA9IGN1cnJlbnRab29tO1xuICAgICAgdmFyIHpvb20yID0gem9vbTtcbiAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICB4OiAtem9vbTIgLyB6b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgeTogLXpvb20yIC8gem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB6b29tZWQ6IHRydWUsXG4gICAgICAgIHBhbm5lZDogdHJ1ZSxcbiAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgIHBhbjogcGFuMlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8ganVzdCBzZXQgdGhlIHpvb21cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHpvb21lZDogdHJ1ZSxcbiAgICAgICAgcGFubmVkOiBmYWxzZSxcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgcGFuOiBjdXJyZW50UGFuXG4gICAgICB9O1xuICAgIH1cbiAgfSxcbiAgem9vbTogZnVuY3Rpb24gem9vbShwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGdldFxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2V0XG4gICAgICB2YXIgdnAgPSB0aGlzLmdldFpvb21lZFZpZXdwb3J0KHBhcmFtcyk7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgaWYgKHZwID09IG51bGwgfHwgIXZwLnpvb21lZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIF9wLnpvb20gPSB2cC56b29tO1xuICAgICAgaWYgKHZwLnBhbm5lZCkge1xuICAgICAgICBfcC5wYW4ueCA9IHZwLnBhbi54O1xuICAgICAgICBfcC5wYW4ueSA9IHZwLnBhbi55O1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCd6b29tJyArICh2cC5wYW5uZWQgPyAnIHBhbicgOiAnJykgKyAnIHZpZXdwb3J0Jyk7XG4gICAgICB0aGlzLm5vdGlmeSgndmlld3BvcnQnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH1cbiAgfSxcbiAgdmlld3BvcnQ6IGZ1bmN0aW9uIHZpZXdwb3J0KG9wdHMpIHtcbiAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgIHZhciB6b29tRGVmZCA9IHRydWU7XG4gICAgdmFyIHBhbkRlZmQgPSB0cnVlO1xuICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuICAgIHZhciB6b29tRmFpbGVkID0gZmFsc2U7XG4gICAgdmFyIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICghbnVtYmVyJDEob3B0cy56b29tKSkge1xuICAgICAgem9vbURlZmQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwbGFpbk9iamVjdChvcHRzLnBhbikpIHtcbiAgICAgIHBhbkRlZmQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF6b29tRGVmZCAmJiAhcGFuRGVmZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh6b29tRGVmZCkge1xuICAgICAgdmFyIHogPSBvcHRzLnpvb207XG4gICAgICBpZiAoeiA8IF9wLm1pblpvb20gfHwgeiA+IF9wLm1heFpvb20gfHwgIV9wLnpvb21pbmdFbmFibGVkKSB7XG4gICAgICAgIHpvb21GYWlsZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Auem9vbSA9IHo7XG4gICAgICAgIGV2ZW50cy5wdXNoKCd6b29tJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYW5EZWZkICYmICghem9vbUZhaWxlZCB8fCAhb3B0cy5jYW5jZWxPbkZhaWxlZFpvb20pICYmIF9wLnBhbm5pbmdFbmFibGVkKSB7XG4gICAgICB2YXIgcCA9IG9wdHMucGFuO1xuICAgICAgaWYgKG51bWJlciQxKHAueCkpIHtcbiAgICAgICAgX3AucGFuLnggPSBwLng7XG4gICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG51bWJlciQxKHAueSkpIHtcbiAgICAgICAgX3AucGFuLnkgPSBwLnk7XG4gICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFwYW5GYWlsZWQpIHtcbiAgICAgICAgZXZlbnRzLnB1c2goJ3BhbicpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGV2ZW50cy5wdXNoKCd2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5lbWl0KGV2ZW50cy5qb2luKCcgJykpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBjZW50ZXI6IGZ1bmN0aW9uIGNlbnRlcihlbGVtZW50cykge1xuICAgIHZhciBwYW4gPSB0aGlzLmdldENlbnRlclBhbihlbGVtZW50cyk7XG4gICAgaWYgKHBhbikge1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW47XG4gICAgICB0aGlzLmVtaXQoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgdGhpcy5ub3RpZnkoJ3ZpZXdwb3J0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBnZXRDZW50ZXJQYW46IGZ1bmN0aW9uIGdldENlbnRlclBhbihlbGVtZW50cywgem9vbSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nKGVsZW1lbnRzKSkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gZWxlbWVudHM7XG4gICAgICBlbGVtZW50cyA9IHRoaXMubXV0YWJsZUVsZW1lbnRzKCkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9IGVsc2UgaWYgKCFlbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSkge1xuICAgICAgZWxlbWVudHMgPSB0aGlzLm11dGFibGVFbGVtZW50cygpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBjYW4ndCBjZW50cmUgcGFuIHRvIG5vdGhpbmdcblxuICAgIHZhciBiYiA9IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHcgPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9wcml2YXRlLnpvb20gOiB6b29tO1xuICAgIHZhciBwYW4gPSB7XG4gICAgICAvLyBtaWRkbGVcbiAgICAgIHg6ICh3IC0gem9vbSAqIChiYi54MSArIGJiLngyKSkgLyAyLFxuICAgICAgeTogKGggLSB6b29tICogKGJiLnkxICsgYmIueTIpKSAvIDJcbiAgICB9O1xuICAgIHJldHVybiBwYW47XG4gIH0sXG4gIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLnZpZXdwb3J0KHtcbiAgICAgIHBhbjoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgem9vbTogMVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICBpbnZhbGlkYXRlU2l6ZTogZnVuY3Rpb24gaW52YWxpZGF0ZVNpemUoKSB7XG4gICAgdGhpcy5fcHJpdmF0ZS5zaXplQ2FjaGUgPSBudWxsO1xuICB9LFxuICBzaXplOiBmdW5jdGlvbiBzaXplKCkge1xuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgdmFyIGNvbnRhaW5lciA9IF9wLmNvbnRhaW5lcjtcbiAgICB2YXIgY3kgPSB0aGlzO1xuICAgIHJldHVybiBfcC5zaXplQ2FjaGUgPSBfcC5zaXplQ2FjaGUgfHwgKGNvbnRhaW5lciA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHlsZSA9IGN5LndpbmRvdygpLmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIHZhciB2YWwgPSBmdW5jdGlvbiB2YWwobmFtZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogY29udGFpbmVyLmNsaWVudFdpZHRoIC0gdmFsKCdwYWRkaW5nLWxlZnQnKSAtIHZhbCgncGFkZGluZy1yaWdodCcpLFxuICAgICAgICBoZWlnaHQ6IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgLSB2YWwoJ3BhZGRpbmctdG9wJykgLSB2YWwoJ3BhZGRpbmctYm90dG9tJylcbiAgICAgIH07XG4gICAgfSgpIDoge1xuICAgICAgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgICAgIHdpZHRoOiAxLFxuICAgICAgaGVpZ2h0OiAxXG4gICAgfSk7XG4gIH0sXG4gIHdpZHRoOiBmdW5jdGlvbiB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaXplKCkud2lkdGg7XG4gIH0sXG4gIGhlaWdodDogZnVuY3Rpb24gaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnNpemUoKS5oZWlnaHQ7XG4gIH0sXG4gIGV4dGVudDogZnVuY3Rpb24gZXh0ZW50KCkge1xuICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICB2YXIgem9vbSA9IHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICB2YXIgcmIgPSB0aGlzLnJlbmRlcmVkRXh0ZW50KCk7XG4gICAgdmFyIGIgPSB7XG4gICAgICB4MTogKHJiLngxIC0gcGFuLngpIC8gem9vbSxcbiAgICAgIHgyOiAocmIueDIgLSBwYW4ueCkgLyB6b29tLFxuICAgICAgeTE6IChyYi55MSAtIHBhbi55KSAvIHpvb20sXG4gICAgICB5MjogKHJiLnkyIC0gcGFuLnkpIC8gem9vbVxuICAgIH07XG4gICAgYi53ID0gYi54MiAtIGIueDE7XG4gICAgYi5oID0gYi55MiAtIGIueTE7XG4gICAgcmV0dXJuIGI7XG4gIH0sXG4gIHJlbmRlcmVkRXh0ZW50OiBmdW5jdGlvbiByZW5kZXJlZEV4dGVudCgpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHgxOiAwLFxuICAgICAgeTE6IDAsXG4gICAgICB4Mjogd2lkdGgsXG4gICAgICB5MjogaGVpZ2h0LFxuICAgICAgdzogd2lkdGgsXG4gICAgICBoOiBoZWlnaHRcbiAgICB9O1xuICB9LFxuICBtdWx0aUNsaWNrRGVib3VuY2VUaW1lOiBmdW5jdGlvbiBtdWx0aUNsaWNrRGVib3VuY2VUaW1lKF9pbnQpIHtcbiAgICBpZiAoX2ludCkgdGhpcy5fcHJpdmF0ZS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lID0gX2ludDtlbHNlIHJldHVybiB0aGlzLl9wcml2YXRlLm11bHRpQ2xpY2tEZWJvdW5jZVRpbWU7XG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH1cbn07XG5cbi8vIGFsaWFzZXNcbmNvcmVmbiQxLmNlbnRyZSA9IGNvcmVmbiQxLmNlbnRlcjtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbmNvcmVmbiQxLmF1dG9sb2NrTm9kZXMgPSBjb3JlZm4kMS5hdXRvbG9jaztcbmNvcmVmbiQxLmF1dG91bmdyYWJpZnlOb2RlcyA9IGNvcmVmbiQxLmF1dG91bmdyYWJpZnk7XG5cbnZhciBmbiA9IHtcbiAgZGF0YTogZGVmaW5lLmRhdGEoe1xuICAgIGZpZWxkOiAnZGF0YScsXG4gICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogdHJ1ZSxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pLFxuICByZW1vdmVEYXRhOiBkZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgZmllbGQ6ICdkYXRhJyxcbiAgICBldmVudDogJ2RhdGEnLFxuICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgfSksXG4gIHNjcmF0Y2g6IGRlZmluZS5kYXRhKHtcbiAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgIGJpbmRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgc2V0dGluZ0V2ZW50OiAnc2NyYXRjaCcsXG4gICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICB9KSxcbiAgcmVtb3ZlU2NyYXRjaDogZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgZXZlbnQ6ICdzY3JhdGNoJyxcbiAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgIHVwZGF0ZVN0eWxlOiB0cnVlXG4gIH0pXG59O1xuXG4vLyBhbGlhc2VzXG5mbi5hdHRyID0gZm4uZGF0YTtcbmZuLnJlbW92ZUF0dHIgPSBmbi5yZW1vdmVEYXRhO1xuXG52YXIgQ29yZSA9IGZ1bmN0aW9uIENvcmUob3B0cykge1xuICB2YXIgY3kgPSB0aGlzO1xuICBvcHRzID0gZXh0ZW5kKHt9LCBvcHRzKTtcbiAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyO1xuXG4gIC8vIGFsbG93IGZvciBwYXNzaW5nIGEgd3JhcHBlZCBqcXVlcnkgb2JqZWN0XG4gIC8vIGUuZy4gY3l0b3NjYXBlKHsgY29udGFpbmVyOiAkKCcjY3knKSB9KVxuICBpZiAoY29udGFpbmVyICYmICFodG1sRWxlbWVudChjb250YWluZXIpICYmIGh0bWxFbGVtZW50KGNvbnRhaW5lclswXSkpIHtcbiAgICBjb250YWluZXIgPSBjb250YWluZXJbMF07XG4gIH1cbiAgdmFyIHJlZyA9IGNvbnRhaW5lciA/IGNvbnRhaW5lci5fY3lyZWcgOiBudWxsOyAvLyBlLmcuIGFscmVhZHkgcmVnaXN0ZXJlZCBzb21lIGluZm8gKGUuZy4gcmVhZGllcykgdmlhIGpxdWVyeVxuICByZWcgPSByZWcgfHwge307XG4gIGlmIChyZWcgJiYgcmVnLmN5KSB7XG4gICAgcmVnLmN5LmRlc3Ryb3koKTtcbiAgICByZWcgPSB7fTsgLy8gb2xkIGluc3RhbmNlID0+IHJlcGxhY2UgcmVnIGNvbXBsZXRlbHlcbiAgfVxuICB2YXIgcmVhZGllcyA9IHJlZy5yZWFkaWVzID0gcmVnLnJlYWRpZXMgfHwgW107XG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuX2N5cmVnID0gcmVnO1xuICB9IC8vIG1ha2Ugc3VyZSBjb250YWluZXIgYXNzb2MnZCByZWcgcG9pbnRzIHRvIHRoaXMgY3lcbiAgcmVnLmN5ID0gY3k7XG4gIHZhciBoZWFkID0gX3dpbmRvdyAhPT0gdW5kZWZpbmVkICYmIGNvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmICFvcHRzLmhlYWRsZXNzO1xuICB2YXIgb3B0aW9ucyA9IG9wdHM7XG4gIG9wdGlvbnMubGF5b3V0ID0gZXh0ZW5kKHtcbiAgICBuYW1lOiBoZWFkID8gJ2dyaWQnIDogJ251bGwnXG4gIH0sIG9wdGlvbnMubGF5b3V0KTtcbiAgb3B0aW9ucy5yZW5kZXJlciA9IGV4dGVuZCh7XG4gICAgbmFtZTogaGVhZCA/ICdjYW52YXMnIDogJ251bGwnXG4gIH0sIG9wdGlvbnMucmVuZGVyZXIpO1xuICB2YXIgZGVmVmFsID0gZnVuY3Rpb24gZGVmVmFsKGRlZiwgdmFsLCBhbHRWYWwpIHtcbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIGlmIChhbHRWYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGFsdFZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gIH07XG4gIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgLy8gaHRtbCBkb20gZWxlIGNvbnRhaW5lclxuICAgIHJlYWR5OiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIHJlYWR5IGhhcyBiZWVuIHRyaWdnZXJlZFxuICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgLy8gY2FjaGVkIG9wdGlvbnNcbiAgICBlbGVtZW50czogbmV3IENvbGxlY3Rpb24odGhpcyksXG4gICAgLy8gZWxlbWVudHMgaW4gdGhlIGdyYXBoXG4gICAgbGlzdGVuZXJzOiBbXSxcbiAgICAvLyBsaXN0IG9mIGxpc3RlbmVyc1xuICAgIGFuaUVsZXM6IG5ldyBDb2xsZWN0aW9uKHRoaXMpLFxuICAgIC8vIGVsZW1lbnRzIGJlaW5nIGFuaW1hdGVkXG4gICAgZGF0YTogb3B0aW9ucy5kYXRhIHx8IHt9LFxuICAgIC8vIGRhdGEgZm9yIHRoZSBjb3JlXG4gICAgc2NyYXRjaDoge30sXG4gICAgLy8gc2NyYXRjaCBvYmplY3QgZm9yIGNvcmVcbiAgICBsYXlvdXQ6IG51bGwsXG4gICAgcmVuZGVyZXI6IG51bGwsXG4gICAgZGVzdHJveWVkOiBmYWxzZSxcbiAgICAvLyB3aGV0aGVyIGRlc3Ryb3kgd2FzIGNhbGxlZFxuICAgIG5vdGlmaWNhdGlvbnNFbmFibGVkOiB0cnVlLFxuICAgIC8vIHdoZXRoZXIgbm90aWZpY2F0aW9ucyBhcmUgc2VudCB0byB0aGUgcmVuZGVyZXJcbiAgICBtaW5ab29tOiAxZS01MCxcbiAgICBtYXhab29tOiAxZTUwLFxuICAgIHpvb21pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy56b29taW5nRW5hYmxlZCksXG4gICAgdXNlclpvb21pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy51c2VyWm9vbWluZ0VuYWJsZWQpLFxuICAgIHBhbm5pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5wYW5uaW5nRW5hYmxlZCksXG4gICAgdXNlclBhbm5pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy51c2VyUGFubmluZ0VuYWJsZWQpLFxuICAgIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLmJveFNlbGVjdGlvbkVuYWJsZWQpLFxuICAgIGF1dG9sb2NrOiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b2xvY2ssIG9wdGlvbnMuYXV0b2xvY2tOb2RlcyksXG4gICAgYXV0b3VuZ3JhYmlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bmdyYWJpZnksIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeU5vZGVzKSxcbiAgICBhdXRvdW5zZWxlY3RpZnk6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5hdXRvdW5zZWxlY3RpZnkpLFxuICAgIHN0eWxlRW5hYmxlZDogb3B0aW9ucy5zdHlsZUVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IGhlYWQgOiBvcHRpb25zLnN0eWxlRW5hYmxlZCxcbiAgICB6b29tOiBudW1iZXIkMShvcHRpb25zLnpvb20pID8gb3B0aW9ucy56b29tIDogMSxcbiAgICBwYW46IHtcbiAgICAgIHg6IHBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiBudW1iZXIkMShvcHRpb25zLnBhbi54KSA/IG9wdGlvbnMucGFuLnggOiAwLFxuICAgICAgeTogcGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmIG51bWJlciQxKG9wdGlvbnMucGFuLnkpID8gb3B0aW9ucy5wYW4ueSA6IDBcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICBjdXJyZW50OiBbXSxcbiAgICAgIHF1ZXVlOiBbXVxuICAgIH0sXG4gICAgaGFzQ29tcG91bmROb2RlczogZmFsc2UsXG4gICAgbXVsdGlDbGlja0RlYm91bmNlVGltZTogZGVmVmFsKDI1MCwgb3B0aW9ucy5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKVxuICB9O1xuICB0aGlzLmNyZWF0ZUVtaXR0ZXIoKTtcblxuICAvLyBzZXQgc2VsZWN0aW9uIHR5cGVcbiAgdGhpcy5zZWxlY3Rpb25UeXBlKG9wdGlvbnMuc2VsZWN0aW9uVHlwZSk7XG5cbiAgLy8gaW5pdCB6b29tIGJvdW5kc1xuICB0aGlzLnpvb21SYW5nZSh7XG4gICAgbWluOiBvcHRpb25zLm1pblpvb20sXG4gICAgbWF4OiBvcHRpb25zLm1heFpvb21cbiAgfSk7XG4gIHZhciBsb2FkRXh0RGF0YSA9IGZ1bmN0aW9uIGxvYWRFeHREYXRhKGV4dERhdGEsIG5leHQpIHtcbiAgICB2YXIgYW55SXNQcm9taXNlID0gZXh0RGF0YS5zb21lKHByb21pc2UpO1xuICAgIGlmIChhbnlJc1Byb21pc2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlJDEuYWxsKGV4dERhdGEpLnRoZW4obmV4dCk7IC8vIGxvYWQgYWxsIGRhdGEgYXN5bmNocm9ub3VzbHksIHRoZW4gZXhlYyByZXN0IG9mIGluaXRcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dChleHREYXRhKTsgLy8gZXhlYyBzeW5jaHJvbm91c2x5IGZvciBjb252ZW5pZW5jZVxuICAgIH1cbiAgfTtcblxuICAvLyBzdGFydCB3aXRoIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQgc28gd2UgaGF2ZSBzb21ldGhpbmcgYmVmb3JlIGxvYWRpbmcgYW4gZXh0ZXJuYWwgc3R5bGVzaGVldFxuICBpZiAoX3Auc3R5bGVFbmFibGVkKSB7XG4gICAgY3kuc2V0U3R5bGUoW10pO1xuICB9XG5cbiAgLy8gY3JlYXRlIHRoZSByZW5kZXJlclxuICB2YXIgcmVuZGVyZXJPcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCBvcHRpb25zLnJlbmRlcmVyKTsgLy8gYWxsb3cgcmVuZGVyaW5nIGhpbnRzIGluIHRvcCBsZXZlbCBvcHRpb25zXG4gIGN5LmluaXRSZW5kZXJlcihyZW5kZXJlck9wdGlvbnMpO1xuICB2YXIgc2V0RWxlc0FuZExheW91dCA9IGZ1bmN0aW9uIHNldEVsZXNBbmRMYXlvdXQoZWxlbWVudHMsIG9ubG9hZCwgb25kb25lKSB7XG4gICAgY3kubm90aWZpY2F0aW9ucyhmYWxzZSk7XG5cbiAgICAvLyByZW1vdmUgb2xkIGVsZW1lbnRzXG4gICAgdmFyIG9sZEVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICBpZiAob2xkRWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBvbGRFbGVzLnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudHMgIT0gbnVsbCkge1xuICAgICAgaWYgKHBsYWluT2JqZWN0KGVsZW1lbnRzKSB8fCBhcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgY3kuYWRkKGVsZW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3kub25lKCdsYXlvdXRyZWFkeScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBjeS5ub3RpZmljYXRpb25zKHRydWUpO1xuICAgICAgY3kuZW1pdChlKTsgLy8gd2UgbWlzc2VkIHRoaXMgZXZlbnQgYnkgdHVybmluZyBub3RpZmljYXRpb25zIG9mZiwgc28gcGFzcyBpdCBvblxuXG4gICAgICBjeS5vbmUoJ2xvYWQnLCBvbmxvYWQpO1xuICAgICAgY3kuZW1pdEFuZE5vdGlmeSgnbG9hZCcpO1xuICAgIH0pLm9uZSgnbGF5b3V0c3RvcCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGN5Lm9uZSgnZG9uZScsIG9uZG9uZSk7XG4gICAgICBjeS5lbWl0KCdkb25lJyk7XG4gICAgfSk7XG4gICAgdmFyIGxheW91dE9wdHMgPSBleHRlbmQoe30sIGN5Ll9wcml2YXRlLm9wdGlvbnMubGF5b3V0KTtcbiAgICBsYXlvdXRPcHRzLmVsZXMgPSBjeS5lbGVtZW50cygpO1xuICAgIGN5LmxheW91dChsYXlvdXRPcHRzKS5ydW4oKTtcbiAgfTtcbiAgbG9hZEV4dERhdGEoW29wdGlvbnMuc3R5bGUsIG9wdGlvbnMuZWxlbWVudHNdLCBmdW5jdGlvbiAodGhlbnMpIHtcbiAgICB2YXIgaW5pdFN0eWxlID0gdGhlbnNbMF07XG4gICAgdmFyIGluaXRFbGVzID0gdGhlbnNbMV07XG5cbiAgICAvLyBpbml0IHN0eWxlXG4gICAgaWYgKF9wLnN0eWxlRW5hYmxlZCkge1xuICAgICAgY3kuc3R5bGUoKS5hcHBlbmQoaW5pdFN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsIGxvYWRcbiAgICBzZXRFbGVzQW5kTGF5b3V0KGluaXRFbGVzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBvbnJlYWR5XG4gICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIF9wLnJlYWR5ID0gdHJ1ZTtcblxuICAgICAgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuICAgICAgaWYgKGZuJDYob3B0aW9ucy5yZWFkeSkpIHtcbiAgICAgICAgY3kub24oJ3JlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZuID0gcmVhZGllc1tpXTtcbiAgICAgICAgY3kub24oJ3JlYWR5JywgZm4pO1xuICAgICAgfVxuICAgICAgaWYgKHJlZykge1xuICAgICAgICByZWcucmVhZGllcyA9IFtdO1xuICAgICAgfSAvLyBjbGVhciBiL2Mgd2UndmUgYm91bmQgdGhlbSBhbGwgYW5kIGRvbid0IHdhbnQgdG8ga2VlcCBpdCBhcm91bmQgaW4gY2FzZSBhIG5ldyBjb3JlIHVzZXMgdGhlIHNhbWUgZGl2IGV0Y1xuXG4gICAgICBjeS5lbWl0KCdyZWFkeScpO1xuICAgIH0sIG9wdGlvbnMuZG9uZSk7XG4gIH0pO1xufTtcbnZhciBjb3JlZm4gPSBDb3JlLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxuZXh0ZW5kKGNvcmVmbiwge1xuICBpbnN0YW5jZVN0cmluZzogZnVuY3Rpb24gaW5zdGFuY2VTdHJpbmcoKSB7XG4gICAgcmV0dXJuICdjb3JlJztcbiAgfSxcbiAgaXNSZWFkeTogZnVuY3Rpb24gaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZWFkeTtcbiAgfSxcbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZGVzdHJveWVkO1xuICB9LFxuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoZm4pIHtcbiAgICBpZiAodGhpcy5pc1JlYWR5KCkpIHtcbiAgICAgIHRoaXMuZW1pdHRlcigpLmVtaXQoJ3JlYWR5JywgW10sIGZuKTsgLy8ganVzdCBjYWxscyBmbiBhcyB0aG91Z2ggdHJpZ2dlcmVkIHZpYSByZWFkeSBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9uKCdyZWFkeScsIGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICBpZiAoY3kuZGVzdHJveWVkKCkpIHJldHVybjtcbiAgICBjeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LmRlc3Ryb3lSZW5kZXJlcigpO1xuICAgIHRoaXMuZW1pdCgnZGVzdHJveScpO1xuICAgIGN5Ll9wcml2YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgcmV0dXJuIGN5O1xuICB9LFxuICBoYXNFbGVtZW50V2l0aElkOiBmdW5jdGlvbiBoYXNFbGVtZW50V2l0aElkKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMuaGFzRWxlbWVudFdpdGhJZChpZCk7XG4gIH0sXG4gIGdldEVsZW1lbnRCeUlkOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlJZChpZCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgfSxcbiAgaGFzQ29tcG91bmROb2RlczogZnVuY3Rpb24gaGFzQ29tcG91bmROb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzO1xuICB9LFxuICBoZWFkbGVzczogZnVuY3Rpb24gaGVhZGxlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVuZGVyZXIuaXNIZWFkbGVzcygpO1xuICB9LFxuICBzdHlsZUVuYWJsZWQ6IGZ1bmN0aW9uIHN0eWxlRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG4gIH0sXG4gIGFkZFRvUG9vbDogZnVuY3Rpb24gYWRkVG9Qb29sKGVsZXMpIHtcbiAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLm1lcmdlKGVsZXMpO1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9LFxuICByZW1vdmVGcm9tUG9vbDogZnVuY3Rpb24gcmVtb3ZlRnJvbVBvb2woZWxlcykge1xuICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMudW5tZXJnZShlbGVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29udGFpbmVyOiBmdW5jdGlvbiBjb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29udGFpbmVyIHx8IG51bGw7XG4gIH0sXG4gIHdpbmRvdzogZnVuY3Rpb24gd2luZG93KCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcbiAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHJldHVybiBfd2luZG93O1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5fcHJpdmF0ZS5jb250YWluZXIub3duZXJEb2N1bWVudDtcbiAgICBpZiAob3duZXJEb2N1bWVudCA9PT0gdW5kZWZpbmVkIHx8IG93bmVyRG9jdW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIF93aW5kb3c7XG4gICAgfVxuICAgIHJldHVybiBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IF93aW5kb3c7XG4gIH0sXG4gIG1vdW50OiBmdW5jdGlvbiBtb3VudChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN5ID0gdGhpcztcbiAgICB2YXIgX3AgPSBjeS5fcHJpdmF0ZTtcbiAgICB2YXIgb3B0aW9ucyA9IF9wLm9wdGlvbnM7XG4gICAgaWYgKCFodG1sRWxlbWVudChjb250YWluZXIpICYmIGh0bWxFbGVtZW50KGNvbnRhaW5lclswXSkpIHtcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lclswXTtcbiAgICB9XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBfcC5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgX3Auc3R5bGVFbmFibGVkID0gdHJ1ZTtcbiAgICBjeS5pbnZhbGlkYXRlU2l6ZSgpO1xuICAgIGN5LmluaXRSZW5kZXJlcihleHRlbmQoe30sIG9wdGlvbnMsIG9wdGlvbnMucmVuZGVyZXIsIHtcbiAgICAgIC8vIGFsbG93IGN1c3RvbSByZW5kZXJlciBuYW1lIHRvIGJlIHJlLXVzZWQsIG90aGVyd2lzZSB1c2UgY2FudmFzXG4gICAgICBuYW1lOiBvcHRpb25zLnJlbmRlcmVyLm5hbWUgPT09ICdudWxsJyA/ICdjYW52YXMnIDogb3B0aW9ucy5yZW5kZXJlci5uYW1lXG4gICAgfSkpO1xuICAgIGN5LnN0YXJ0QW5pbWF0aW9uTG9vcCgpO1xuICAgIGN5LnN0eWxlKG9wdGlvbnMuc3R5bGUpO1xuICAgIGN5LmVtaXQoJ21vdW50Jyk7XG4gICAgcmV0dXJuIGN5O1xuICB9LFxuICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgY3kuc3RvcEFuaW1hdGlvbkxvb3AoKTtcbiAgICBjeS5kZXN0cm95UmVuZGVyZXIoKTtcbiAgICBjeS5pbml0UmVuZGVyZXIoe1xuICAgICAgbmFtZTogJ251bGwnXG4gICAgfSk7XG4gICAgY3kuZW1pdCgndW5tb3VudCcpO1xuICAgIHJldHVybiBjeTtcbiAgfSxcbiAgb3B0aW9uczogZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgICByZXR1cm4gY29weSh0aGlzLl9wcml2YXRlLm9wdGlvbnMpO1xuICB9LFxuICBqc29uOiBmdW5jdGlvbiBqc29uKG9iaikge1xuICAgIHZhciBjeSA9IHRoaXM7XG4gICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgdmFyIGVsZXMgPSBjeS5tdXRhYmxlRWxlbWVudHMoKTtcbiAgICB2YXIgZ2V0RnJlc2hSZWYgPSBmdW5jdGlvbiBnZXRGcmVzaFJlZihlbGUpIHtcbiAgICAgIHJldHVybiBjeS5nZXRFbGVtZW50QnlJZChlbGUuaWQoKSk7XG4gICAgfTtcbiAgICBpZiAocGxhaW5PYmplY3Qob2JqKSkge1xuICAgICAgLy8gc2V0XG5cbiAgICAgIGN5LnN0YXJ0QmF0Y2goKTtcbiAgICAgIGlmIChvYmouZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGlkSW5Kc29uID0ge307XG4gICAgICAgIHZhciB1cGRhdGVFbGVzID0gZnVuY3Rpb24gdXBkYXRlRWxlcyhqc29ucywgZ3IpIHtcbiAgICAgICAgICB2YXIgdG9BZGQgPSBbXTtcbiAgICAgICAgICB2YXIgdG9Nb2QgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuICAgICAgICAgICAgaWYgKCFqc29uLmRhdGEuaWQpIHtcbiAgICAgICAgICAgICAgd2FybignY3kuanNvbigpIGNhbm5vdCBoYW5kbGUgZWxlbWVudHMgd2l0aG91dCBhbiBJRCBhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWQgPSAnJyArIGpzb24uZGF0YS5pZDsgLy8gaWQgbXVzdCBiZSBzdHJpbmdcbiAgICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICBpZEluSnNvbltpZF0gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGVsZS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgZWxlbWVudCBzaG91bGQgYmUgdXBkYXRlZFxuICAgICAgICAgICAgICB0b01vZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbGU6IGVsZSxcbiAgICAgICAgICAgICAgICBqc29uOiBqc29uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHNob3VsZCBiZSBhZGRlZFxuICAgICAgICAgICAgICBpZiAoZ3IpIHtcbiAgICAgICAgICAgICAgICBqc29uLmdyb3VwID0gZ3I7XG4gICAgICAgICAgICAgICAgdG9BZGQucHVzaChqc29uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKGpzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGN5LmFkZCh0b0FkZCk7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRvTW9kLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF90b01vZCRfaSA9IHRvTW9kW19pXSxcbiAgICAgICAgICAgICAgX2VsZSA9IF90b01vZCRfaS5lbGUsXG4gICAgICAgICAgICAgIF9qc29uID0gX3RvTW9kJF9pLmpzb247XG4gICAgICAgICAgICBfZWxlLmpzb24oX2pzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGFycmF5KG9iai5lbGVtZW50cykpIHtcbiAgICAgICAgICAvLyBlbGVtZW50czogW11cbiAgICAgICAgICB1cGRhdGVFbGVzKG9iai5lbGVtZW50cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZWxlbWVudHM6IHsgbm9kZXM6IFtdLCBlZGdlczogW10gfVxuICAgICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBnciA9IGdyc1tpXTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IG9iai5lbGVtZW50c1tncl07XG4gICAgICAgICAgICBpZiAoYXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUVsZXMoZWxlbWVudHMsIGdyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcmVudHNUb1JlbW92ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiAhaWRJbkpzb25bZWxlLmlkKCldO1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICBpZiAoZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgIHBhcmVudHNUb1JlbW92ZS5tZXJnZShlbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGUucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzbyB0aGF0IGNoaWxkcmVuIGFyZSBub3QgcmVtb3ZlZCB3L3BhcmVudFxuICAgICAgICBwYXJlbnRzVG9SZW1vdmUuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5jaGlsZHJlbigpLm1vdmUoe1xuICAgICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGludGVybWVkaWF0ZSBwYXJlbnRzIG1heSBiZSBtb3ZlZCBieSBwcmlvciBsaW5lLCBzbyBtYWtlIHN1cmUgd2UgcmVtb3ZlIGJ5IGZyZXNoIHJlZnNcbiAgICAgICAgcGFyZW50c1RvUmVtb3ZlLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBnZXRGcmVzaFJlZihlbGUpLnJlbW92ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouc3R5bGUpIHtcbiAgICAgICAgY3kuc3R5bGUob2JqLnN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvYmouem9vbSAhPSBudWxsICYmIG9iai56b29tICE9PSBfcC56b29tKSB7XG4gICAgICAgIGN5Lnpvb20ob2JqLnpvb20pO1xuICAgICAgfVxuICAgICAgaWYgKG9iai5wYW4pIHtcbiAgICAgICAgaWYgKG9iai5wYW4ueCAhPT0gX3AucGFuLnggfHwgb2JqLnBhbi55ICE9PSBfcC5wYW4ueSkge1xuICAgICAgICAgIGN5LnBhbihvYmoucGFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iai5kYXRhKSB7XG4gICAgICAgIGN5LmRhdGEob2JqLmRhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIGZpZWxkcyA9IFsnbWluWm9vbScsICdtYXhab29tJywgJ3pvb21pbmdFbmFibGVkJywgJ3VzZXJab29taW5nRW5hYmxlZCcsICdwYW5uaW5nRW5hYmxlZCcsICd1c2VyUGFubmluZ0VuYWJsZWQnLCAnYm94U2VsZWN0aW9uRW5hYmxlZCcsICdhdXRvbG9jaycsICdhdXRvdW5ncmFiaWZ5JywgJ2F1dG91bnNlbGVjdGlmeScsICdtdWx0aUNsaWNrRGVib3VuY2VUaW1lJ107XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBmaWVsZHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgZiA9IGZpZWxkc1tfaTJdO1xuICAgICAgICBpZiAob2JqW2ZdICE9IG51bGwpIHtcbiAgICAgICAgICBjeVtmXShvYmpbZl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjeS5lbmRCYXRjaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdldFxuICAgICAgdmFyIGZsYXQgPSAhIW9iajtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICBpZiAoZmxhdCkge1xuICAgICAgICBqc29uLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cygpLm1hcChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5qc29uKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAganNvbi5lbGVtZW50cyA9IHt9O1xuICAgICAgICBlbGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHZhciBncm91cCA9IGVsZS5ncm91cCgpO1xuICAgICAgICAgIGlmICghanNvbi5lbGVtZW50c1tncm91cF0pIHtcbiAgICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdLnB1c2goZWxlLmpzb24oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3ByaXZhdGUuc3R5bGVFbmFibGVkKSB7XG4gICAgICAgIGpzb24uc3R5bGUgPSBjeS5zdHlsZSgpLmpzb24oKTtcbiAgICAgIH1cbiAgICAgIGpzb24uZGF0YSA9IGNvcHkoY3kuZGF0YSgpKTtcbiAgICAgIHZhciBvcHRpb25zID0gX3Aub3B0aW9ucztcbiAgICAgIGpzb24uem9vbWluZ0VuYWJsZWQgPSBfcC56b29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclpvb21pbmdFbmFibGVkID0gX3AudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi56b29tID0gX3Auem9vbTtcbiAgICAgIGpzb24ubWluWm9vbSA9IF9wLm1pblpvb207XG4gICAgICBqc29uLm1heFpvb20gPSBfcC5tYXhab29tO1xuICAgICAganNvbi5wYW5uaW5nRW5hYmxlZCA9IF9wLnBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyUGFubmluZ0VuYWJsZWQgPSBfcC51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnBhbiA9IGNvcHkoX3AucGFuKTtcbiAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IF9wLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICBqc29uLnJlbmRlcmVyID0gY29weShvcHRpb25zLnJlbmRlcmVyKTtcbiAgICAgIGpzb24uaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBvcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gb3B0aW9ucy5tb3Rpb25CbHVyO1xuICAgICAganNvbi5tdWx0aUNsaWNrRGVib3VuY2VUaW1lID0gb3B0aW9ucy5tdWx0aUNsaWNrRGVib3VuY2VUaW1lO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICB9XG59KTtcbmNvcmVmbi4kaWQgPSBjb3JlZm4uZ2V0RWxlbWVudEJ5SWQ7XG5bY29yZWZuJDksIGNvcmVmbiQ4LCBlbGVzZm4sIGNvcmVmbiQ3LCBjb3JlZm4kNiwgY29yZWZuJDUsIGNvcmVmbiQ0LCBjb3JlZm4kMywgY29yZWZuJDIsIGNvcmVmbiQxLCBmbl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKGNvcmVmbiwgcHJvcHMpO1xufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZGVmYXVsdHMkNyA9IHtcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gIGRpcmVjdGVkOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0aGUgdHJlZSBpcyBkaXJlY3RlZCBkb3dud2FyZHMgKG9yIGVkZ2VzIGNhbiBwb2ludCBpbiBhbnkgZGlyZWN0aW9uIGlmIGZhbHNlKVxuICBkaXJlY3Rpb246ICdkb3dud2FyZCcsXG4gIC8vIGRldGVybWluZXMgdGhlIGRpcmVjdGlvbiBpbiB3aGljaCB0aGUgdHJlZSBzdHJ1Y3R1cmUgaXMgZHJhd24uICBUaGUgcG9zc2libGUgdmFsdWVzIGFyZSAnZG93bndhcmQnLCAndXB3YXJkJywgJ3JpZ2h0d2FyZCcsIG9yICdsZWZ0d2FyZCcuXG4gIHBhZGRpbmc6IDMwLFxuICAvLyBwYWRkaW5nIG9uIGZpdFxuICBjaXJjbGU6IGZhbHNlLFxuICAvLyBwdXQgZGVwdGhzIGluIGNvbmNlbnRyaWMgY2lyY2xlcyBpZiB0cnVlLCBwdXQgZGVwdGhzIHRvcCBkb3duIGlmIGZhbHNlXG4gIGdyaWQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIGNyZWF0ZSBhbiBldmVuIGdyaWQgaW50byB3aGljaCB0aGUgREFHIGlzIHBsYWNlZCAoY2lyY2xlOmZhbHNlIG9ubHkpXG4gIHNwYWNpbmdGYWN0b3I6IDEuNzUsXG4gIC8vIHBvc2l0aXZlIHNwYWNpbmcgZmFjdG9yLCBsYXJnZXIgPT4gbW9yZSBzcGFjZSBiZXR3ZWVuIG5vZGVzIChOLkIuIG4vYSBpZiBjYXVzZXMgb3ZlcmxhcClcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICByb290czogdW5kZWZpbmVkLFxuICAvLyB0aGUgcm9vdHMgb2YgdGhlIHRyZWVzXG4gIGRlcHRoU29ydDogdW5kZWZpbmVkLFxuICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgbm9kZXMgYXQgZXF1YWwgZGVwdGguIGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWQsXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcbn07XG52YXIgZGVwcmVjYXRlZE9wdGlvbkRlZmF1bHRzID0ge1xuICBtYXhpbWFsOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byBzaGlmdCBub2RlcyBkb3duIHRoZWlyIG5hdHVyYWwgQkZTIGRlcHRocyBpbiBvcmRlciB0byBhdm9pZCB1cHdhcmRzIGVkZ2VzIChEQUdTIG9ubHkpOyBzZXR0aW5nIGFjeWNsaWMgdG8gdHJ1ZSBzZXRzIG1heGltYWwgdG8gdHJ1ZSBhbHNvXG4gIGFjeWNsaWM6IGZhbHNlIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgYWN5Y2xpYyBhbmQgdGh1cyBhIG5vZGUgY291bGQgYmUgc2hpZnRlZCAoZHVlIHRvIHRoZSBtYXhpbWFsIG9wdGlvbikgbXVsdGlwbGUgdGltZXMgd2l0aG91dCBjYXVzaW5nIGFuIGluZmluaXRlIGxvb3A7IHNldHRpbmcgdG8gdHJ1ZSBzZXRzIG1heGltYWwgdG8gdHJ1ZSBhbHNvOyBpZiB5b3UgYXJlIHVuY2VydGFpbiB3aGV0aGVyIGEgdHJlZSBpcyBhY3ljbGljLCBzZXQgdG8gZmFsc2UgdG8gYXZvaWQgcG90ZW50aWFsIGluZmluaXRlIGxvb3BzXG59O1xuXG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbnZhciBnZXRJbmZvID0gZnVuY3Rpb24gZ2V0SW5mbyhlbGUpIHtcbiAgcmV0dXJuIGVsZS5zY3JhdGNoKCdicmVhZHRoZmlyc3QnKTtcbn07XG52YXIgc2V0SW5mbyA9IGZ1bmN0aW9uIHNldEluZm8oZWxlLCBvYmopIHtcbiAgcmV0dXJuIGVsZS5zY3JhdGNoKCdicmVhZHRoZmlyc3QnLCBvYmopO1xufTtcbmZ1bmN0aW9uIEJyZWFkdGhGaXJzdExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkNywgZGVwcmVjYXRlZE9wdGlvbkRlZmF1bHRzLCBvcHRpb25zKTtcbn1cbkJyZWFkdGhGaXJzdExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICByZXR1cm4gbi5pc0NoaWxkbGVzcygpO1xuICB9KTtcbiAgdmFyIGdyYXBoID0gZWxlcztcbiAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgdmFyIG1heGltYWwgPSBvcHRpb25zLmFjeWNsaWMgfHwgb3B0aW9ucy5tYXhpbWFsIHx8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzID4gMDsgLy8gbWF4aW1hbEFkanVzdG1lbnRzIGZvciBjb21wYXQuIHcvIG9sZCBjb2RlOyBhbHNvLCBzZXR0aW5nIGFjeWNsaWMgdG8gdHJ1ZSBzZXRzIG1heGltYWwgdG8gdHJ1ZVxuXG4gIHZhciBoYXNCb3VuZGluZ0JveCA9ICEhb3B0aW9ucy5ib3VuZGluZ0JveDtcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KGhhc0JvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHN0cnVjdHVyZWRDbG9uZShjeS5leHRlbnQoKSkpO1xuICB2YXIgcm9vdHM7XG4gIGlmIChlbGVtZW50T3JDb2xsZWN0aW9uKG9wdGlvbnMucm9vdHMpKSB7XG4gICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzO1xuICB9IGVsc2UgaWYgKGFycmF5KG9wdGlvbnMucm9vdHMpKSB7XG4gICAgdmFyIHJvb3RzQXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbaV07XG4gICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgcm9vdHNBcnJheS5wdXNoKGVsZSk7XG4gICAgfVxuICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbihyb290c0FycmF5KTtcbiAgfSBlbHNlIGlmIChzdHJpbmcob3B0aW9ucy5yb290cykpIHtcbiAgICByb290cyA9IGN5LiQob3B0aW9ucy5yb290cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gZWxlcy5jb21wb25lbnRzKCk7XG4gICAgICByb290cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgY29tcCA9IGNvbXBvbmVudHNbX2ldO1xuICAgICAgICB2YXIgbWF4RGVncmVlID0gY29tcC5tYXhEZWdyZWUoZmFsc2UpO1xuICAgICAgICB2YXIgY29tcFJvb3RzID0gY29tcC5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuZGVncmVlKGZhbHNlKSA9PT0gbWF4RGVncmVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcm9vdHMgPSByb290cy5hZGQoY29tcFJvb3RzKTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgY29tcG9uZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgX2xvb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGRlcHRocyA9IFtdO1xuICB2YXIgZm91bmRCeUJmcyA9IHt9O1xuICB2YXIgYWRkVG9EZXB0aCA9IGZ1bmN0aW9uIGFkZFRvRGVwdGgoZWxlLCBkKSB7XG4gICAgaWYgKGRlcHRoc1tkXSA9PSBudWxsKSB7XG4gICAgICBkZXB0aHNbZF0gPSBbXTtcbiAgICB9XG4gICAgdmFyIGkgPSBkZXB0aHNbZF0ubGVuZ3RoO1xuICAgIGRlcHRoc1tkXS5wdXNoKGVsZSk7XG4gICAgc2V0SW5mbyhlbGUsIHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgZGVwdGg6IGRcbiAgICB9KTtcbiAgfTtcbiAgdmFyIGNoYW5nZURlcHRoID0gZnVuY3Rpb24gY2hhbmdlRGVwdGgoZWxlLCBuZXdEZXB0aCkge1xuICAgIHZhciBfZ2V0SW5mbyA9IGdldEluZm8oZWxlKSxcbiAgICAgIGRlcHRoID0gX2dldEluZm8uZGVwdGgsXG4gICAgICBpbmRleCA9IF9nZXRJbmZvLmluZGV4O1xuICAgIGRlcHRoc1tkZXB0aF1baW5kZXhdID0gbnVsbDtcblxuICAgIC8vIGFkZCBvbmx5IGNoaWxkbGVzcyBub2Rlc1xuICAgIGlmIChlbGUuaXNDaGlsZGxlc3MoKSkgYWRkVG9EZXB0aChlbGUsIG5ld0RlcHRoKTtcbiAgfTtcblxuICAvLyBmaW5kIHRoZSBkZXB0aHMgb2YgdGhlIG5vZGVzXG4gIGdyYXBoLmJmcyh7XG4gICAgcm9vdHM6IHJvb3RzLFxuICAgIGRpcmVjdGVkOiBvcHRpb25zLmRpcmVjdGVkLFxuICAgIHZpc2l0OiBmdW5jdGlvbiB2aXNpdChub2RlLCBlZGdlLCBwTm9kZSwgaSwgZGVwdGgpIHtcbiAgICAgIHZhciBlbGUgPSBub2RlWzBdO1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgIC8vIGFkZCBvbmx5IGNoaWxkbGVzcyBub2Rlc1xuICAgICAgaWYgKGVsZS5pc0NoaWxkbGVzcygpKSBhZGRUb0RlcHRoKGVsZSwgZGVwdGgpO1xuICAgICAgZm91bmRCeUJmc1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gY2hlY2sgZm9yIG5vZGVzIG5vdCBmb3VuZCBieSBiZnNcbiAgdmFyIG9ycGhhbk5vZGVzID0gW107XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX2VsZSA9IG5vZGVzW19pMl07XG4gICAgaWYgKGZvdW5kQnlCZnNbX2VsZS5pZCgpXSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ycGhhbk5vZGVzLnB1c2goX2VsZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzaWduIHRoZSBub2RlcyBhIGRlcHRoIGFuZCBpbmRleFxuICB2YXIgYXNzaWduRGVwdGhzQXQgPSBmdW5jdGlvbiBhc3NpZ25EZXB0aHNBdChpKSB7XG4gICAgdmFyIGVsZXMgPSBkZXB0aHNbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgX2VsZTIgPSBlbGVzW2pdO1xuICAgICAgaWYgKF9lbGUyID09IG51bGwpIHtcbiAgICAgICAgZWxlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGotLTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzZXRJbmZvKF9lbGUyLCB7XG4gICAgICAgIGRlcHRoOiBpLFxuICAgICAgICBpbmRleDogalxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICB2YXIgYWRqdXN0TWF4aW1hbGx5ID0gZnVuY3Rpb24gYWRqdXN0TWF4aW1hbGx5KGVsZSwgc2hpZnRlZCkge1xuICAgIHZhciBlSW5mbyA9IGdldEluZm8oZWxlKTtcbiAgICB2YXIgaW5jb21lcnMgPSBlbGUuaW5jb21lcnMoKS5maWx0ZXIoZnVuY3Rpb24gKGVsKSB7XG4gICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgIH0pO1xuICAgIHZhciBtYXhEZXB0aCA9IC0xO1xuICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaW5jb21lcnMubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBpbmNtciA9IGluY29tZXJzW2tdO1xuICAgICAgdmFyIGlJbmZvID0gZ2V0SW5mbyhpbmNtcik7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBpSW5mby5kZXB0aCk7XG4gICAgfVxuICAgIGlmIChlSW5mby5kZXB0aCA8PSBtYXhEZXB0aCkge1xuICAgICAgaWYgKCFvcHRpb25zLmFjeWNsaWMgJiYgc2hpZnRlZFtpZF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGVwdGggPSBtYXhEZXB0aCArIDE7XG4gICAgICBjaGFuZ2VEZXB0aChlbGUsIG5ld0RlcHRoKTtcbiAgICAgIHNoaWZ0ZWRbaWRdID0gbmV3RGVwdGg7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIGZvciB0aGUgZGlyZWN0ZWQgY2FzZSwgdHJ5IHRvIG1ha2UgdGhlIGVkZ2VzIGFsbCBnbyBkb3duIChpLmUuIGRlcHRoIGkgPT4gZGVwdGggaSArIDEpXG4gIGlmIChkaXJlY3RlZCAmJiBtYXhpbWFsKSB7XG4gICAgdmFyIFEgPSBbXTtcbiAgICB2YXIgc2hpZnRlZCA9IHt9O1xuICAgIHZhciBlbnF1ZXVlID0gZnVuY3Rpb24gZW5xdWV1ZShuKSB7XG4gICAgICByZXR1cm4gUS5wdXNoKG4pO1xuICAgIH07XG4gICAgdmFyIGRlcXVldWUgPSBmdW5jdGlvbiBkZXF1ZXVlKCkge1xuICAgICAgcmV0dXJuIFEuc2hpZnQoKTtcbiAgICB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgIHJldHVybiBRLnB1c2gobik7XG4gICAgfSk7XG4gICAgd2hpbGUgKFEubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIF9lbGUzID0gZGVxdWV1ZSgpO1xuICAgICAgdmFyIGRpZFNoaWZ0ID0gYWRqdXN0TWF4aW1hbGx5KF9lbGUzLCBzaGlmdGVkKTtcbiAgICAgIGlmIChkaWRTaGlmdCkge1xuICAgICAgICBfZWxlMy5vdXRnb2VycygpLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICByZXR1cm4gZWwuaXNOb2RlKCkgJiYgZWxlcy5oYXMoZWwpO1xuICAgICAgICB9KS5mb3JFYWNoKGVucXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChkaWRTaGlmdCA9PT0gbnVsbCkge1xuICAgICAgICB3YXJuKCdEZXRlY3RlZCBkb3VibGUgbWF4aW1hbCBzaGlmdCBmb3Igbm9kZSBgJyArIF9lbGUzLmlkKCkgKyAnYC4gIEJhaWxpbmcgbWF4aW1hbCBhZGp1c3RtZW50IGR1ZSB0byBjeWNsZS4gIFVzZSBgb3B0aW9ucy5tYXhpbWFsOiB0cnVlYCBvbmx5IG9uIERBR3MuJyk7XG4gICAgICAgIGJyZWFrOyAvLyBleGl0IG9uIGZhaWx1cmVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBmaW5kIG1pbiBkaXN0YW5jZSB3ZSBuZWVkIHRvIGxlYXZlIGJldHdlZW4gbm9kZXNcbiAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgaWYgKG9wdGlvbnMuYXZvaWRPdmVybGFwKSB7XG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgdmFyIG4gPSBub2Rlc1tfaTNdO1xuICAgICAgdmFyIG5iYiA9IG4ubGF5b3V0RGltZW5zaW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciB3ID0gbmJiLnc7XG4gICAgICB2YXIgaCA9IG5iYi5oO1xuICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgfVxuICB9XG5cbiAgLy8gZ2V0IHRoZSB3ZWlnaHRlZCBwZXJjZW50IGZvciBhbiBlbGVtZW50IGJhc2VkIG9uIGl0cyBjb25uZWN0aXZpdHkgdG8gb3RoZXIgbGV2ZWxzXG4gIHZhciBjYWNoZWRXZWlnaHRlZFBlcmNlbnQgPSB7fTtcbiAgdmFyIGdldFdlaWdodGVkUGVyY2VudCA9IGZ1bmN0aW9uIGdldFdlaWdodGVkUGVyY2VudChlbGUpIHtcbiAgICBpZiAoY2FjaGVkV2VpZ2h0ZWRQZXJjZW50W2VsZS5pZCgpXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV07XG4gICAgfVxuICAgIHZhciBlbGVEZXB0aCA9IGdldEluZm8oZWxlKS5kZXB0aDtcbiAgICB2YXIgbmVpZ2hib3JzID0gZWxlLm5laWdoYm9yaG9vZCgpO1xuICAgIHZhciBwZXJjZW50ID0gMDtcbiAgICB2YXIgc2FtcGxlcyA9IDA7XG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbmVpZ2hib3JzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tfaTRdO1xuICAgICAgaWYgKG5laWdoYm9yLmlzRWRnZSgpIHx8IG5laWdoYm9yLmlzUGFyZW50KCkgfHwgIW5vZGVzLmhhcyhuZWlnaGJvcikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgYmYgPSBnZXRJbmZvKG5laWdoYm9yKTtcbiAgICAgIGlmIChiZiA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gYmYuaW5kZXg7XG4gICAgICB2YXIgZGVwdGggPSBiZi5kZXB0aDtcblxuICAgICAgLy8gdW5hc3NpZ25lZCBuZWlnaGJvdXJzIHNob3VsZG4ndCBhZmZlY3QgdGhlIG9yZGVyaW5nXG4gICAgICBpZiAoaW5kZXggPT0gbnVsbCB8fCBkZXB0aCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuICAgICAgaWYgKGRlcHRoIDwgZWxlRGVwdGgpIHtcbiAgICAgICAgLy8gb25seSBnZXQgaW5mbHVlbmNlZCBieSBlbGVtZW50cyBhYm92ZVxuICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICBzYW1wbGVzKys7XG4gICAgICB9XG4gICAgfVxuICAgIHNhbXBsZXMgPSBNYXRoLm1heCgxLCBzYW1wbGVzKTtcbiAgICBwZXJjZW50ID0gcGVyY2VudCAvIHNhbXBsZXM7XG4gICAgaWYgKHNhbXBsZXMgPT09IDApIHtcbiAgICAgIC8vIHB1dCBsb25lIG5vZGVzIGF0IHRoZSBzdGFydFxuICAgICAgcGVyY2VudCA9IDA7XG4gICAgfVxuICAgIGNhY2hlZFdlaWdodGVkUGVyY2VudFtlbGUuaWQoKV0gPSBwZXJjZW50O1xuICAgIHJldHVybiBwZXJjZW50O1xuICB9O1xuXG4gIC8vIHJlYXJyYW5nZSB0aGUgaW5kaWNlcyBpbiBlYWNoIGRlcHRoIGxldmVsIGJhc2VkIG9uIGNvbm5lY3Rpdml0eVxuICB2YXIgc29ydEZuID0gZnVuY3Rpb24gc29ydEZuKGEsIGIpIHtcbiAgICB2YXIgYXBjdCA9IGdldFdlaWdodGVkUGVyY2VudChhKTtcbiAgICB2YXIgYnBjdCA9IGdldFdlaWdodGVkUGVyY2VudChiKTtcbiAgICB2YXIgZGlmZiA9IGFwY3QgLSBicGN0O1xuICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICByZXR1cm4gYXNjZW5kaW5nKGEuaWQoKSwgYi5pZCgpKTsgLy8gbWFrZSBzdXJlIHNvcnQgZG9lc24ndCBoYXZlIGRvbid0LWNhcmUgY29tcGFyaXNvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfVxuICB9O1xuICBpZiAob3B0aW9ucy5kZXB0aFNvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHNvcnRGbiA9IG9wdGlvbnMuZGVwdGhTb3J0O1xuICB9XG4gIHZhciBkZXB0aHNMZW4gPSBkZXB0aHMubGVuZ3RoO1xuXG4gIC8vIHNvcnQgZWFjaCBsZXZlbCB0byBtYWtlIGNvbm5lY3RlZCBub2RlcyBjbG9zZXJcbiAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgZGVwdGhzTGVuOyBfaTUrKykge1xuICAgIGRlcHRoc1tfaTVdLnNvcnQoc29ydEZuKTtcbiAgICBhc3NpZ25EZXB0aHNBdChfaTUpO1xuICB9XG5cbiAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0byBhIG5ldyB0b3AtbGV2ZWwgZGVwdGhcbiAgdmFyIG9ycGhhbkRlcHRoID0gW107XG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG9ycGhhbk5vZGVzLmxlbmd0aDsgX2k2KyspIHtcbiAgICBvcnBoYW5EZXB0aC5wdXNoKG9ycGhhbk5vZGVzW19pNl0pO1xuICB9XG4gIHZhciBhc3NpZ25EZXB0aHMgPSBmdW5jdGlvbiBhc3NpZ25EZXB0aHMoKSB7XG4gICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgZGVwdGhzTGVuOyBfaTcrKykge1xuICAgICAgYXNzaWduRGVwdGhzQXQoX2k3KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gYWRkIGEgbmV3IHRvcC1sZXZlbCBkZXB0aCBvbmx5IHdoZW4gdGhlcmUgYXJlIG9ycGhhbiBub2Rlc1xuICBpZiAob3JwaGFuRGVwdGgubGVuZ3RoKSB7XG4gICAgZGVwdGhzLnVuc2hpZnQob3JwaGFuRGVwdGgpO1xuICAgIGRlcHRoc0xlbiA9IGRlcHRocy5sZW5ndGg7XG4gICAgYXNzaWduRGVwdGhzKCk7XG4gIH1cbiAgdmFyIGJpZ2dlc3REZXB0aFNpemUgPSAwO1xuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBkZXB0aHNMZW47IF9pOCsrKSB7XG4gICAgYmlnZ2VzdERlcHRoU2l6ZSA9IE1hdGgubWF4KGRlcHRoc1tfaThdLmxlbmd0aCwgYmlnZ2VzdERlcHRoU2l6ZSk7XG4gIH1cbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcblxuICAvLyBhdmVyYWdlIG5vZGUgc2l6ZVxuICB2YXIgYXZlTm9kZVNpemUgPSBub2Rlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYm94KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3OiBhY2MudyA9PT0gLTEgPyBib3gudyA6IChhY2MudyArIGJveC53KSAvIDIsXG4gICAgICAgIGg6IGFjYy5oID09PSAtMSA/IGJveC5oIDogKGFjYy5oICsgYm94LmgpIC8gMlxuICAgICAgfTtcbiAgICB9KG5vZGUuYm91bmRpbmdCb3goe1xuICAgICAgaW5jbHVkZUxhYmVsczogb3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHNcbiAgICB9KSk7XG4gIH0sIHtcbiAgICB3OiAtMSxcbiAgICBoOiAtMVxuICB9KTtcbiAgdmFyIGRpc3RhbmNlWSA9IE1hdGgubWF4KFxuICAvLyBvbmx5IG9uZSBkZXB0aFxuICBkZXB0aHNMZW4gPT09IDEgPyAwIDpcbiAgLy8gaW5zaWRlIGEgYm91bmRpbmcgYm94LCBubyBuZWVkIGZvciB0b3AgJiBib3R0b20gcGFkZGluZ1xuICBoYXNCb3VuZGluZ0JveCA/IChiYi5oIC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIGF2ZU5vZGVTaXplLmgpIC8gKGRlcHRoc0xlbiAtIDEpIDogKGJiLmggLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gYXZlTm9kZVNpemUuaCkgLyAoZGVwdGhzTGVuICsgMSksIG1pbkRpc3RhbmNlKTtcbiAgdmFyIG1heERlcHRoU2l6ZSA9IGRlcHRocy5yZWR1Y2UoZnVuY3Rpb24gKG1heCwgZWxlcykge1xuICAgIHJldHVybiBNYXRoLm1heChtYXgsIGVsZXMubGVuZ3RoKTtcbiAgfSwgMCk7XG4gIHZhciBnZXRQb3NpdGlvblRvcEJvdHRvbSA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uVG9wQm90dG9tKGVsZSkge1xuICAgIHZhciBfZ2V0SW5mbzIgPSBnZXRJbmZvKGVsZSksXG4gICAgICBkZXB0aCA9IF9nZXRJbmZvMi5kZXB0aCxcbiAgICAgIGluZGV4ID0gX2dldEluZm8yLmluZGV4O1xuICAgIGlmIChvcHRpb25zLmNpcmNsZSkge1xuICAgICAgdmFyIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5taW4oYmIudyAvIDIgLyBkZXB0aHNMZW4sIGJiLmggLyAyIC8gZGVwdGhzTGVuKTtcbiAgICAgIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5tYXgocmFkaXVzU3RlcFNpemUsIG1pbkRpc3RhbmNlKTtcbiAgICAgIHZhciByYWRpdXMgPSByYWRpdXNTdGVwU2l6ZSAqIGRlcHRoICsgcmFkaXVzU3RlcFNpemUgLSAoZGVwdGhzTGVuID4gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoIDw9IDMgPyByYWRpdXNTdGVwU2l6ZSAvIDIgOiAwKTtcbiAgICAgIHZhciB0aGV0YSA9IDIgKiBNYXRoLlBJIC8gZGVwdGhzW2RlcHRoXS5sZW5ndGggKiBpbmRleDtcbiAgICAgIGlmIChkZXB0aCA9PT0gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJhZGl1cyA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHJhZGl1cyAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgeTogY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkZXB0aFNpemUgPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcbiAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLm1heChcbiAgICAgIC8vIG9ubHkgb25lIGRlcHRoXG4gICAgICBkZXB0aFNpemUgPT09IDEgPyAwIDpcbiAgICAgIC8vIGluc2lkZSBhIGJvdW5kaW5nIGJveCwgbm8gbmVlZCBmb3IgbGVmdCAmIHJpZ2h0IHBhZGRpbmdcbiAgICAgIGhhc0JvdW5kaW5nQm94ID8gKGJiLncgLSBvcHRpb25zLnBhZGRpbmcgKiAyIC0gYXZlTm9kZVNpemUudykgLyAoKG9wdGlvbnMuZ3JpZCA/IG1heERlcHRoU2l6ZSA6IGRlcHRoU2l6ZSkgLSAxKSA6IChiYi53IC0gb3B0aW9ucy5wYWRkaW5nICogMiAtIGF2ZU5vZGVTaXplLncpIC8gKChvcHRpb25zLmdyaWQgPyBtYXhEZXB0aFNpemUgOiBkZXB0aFNpemUpICsgMSksIG1pbkRpc3RhbmNlKTtcbiAgICAgIHZhciBlcG9zID0ge1xuICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkgLyAyKSAqIGRpc3RhbmNlWCxcbiAgICAgICAgeTogY2VudGVyLnkgKyAoZGVwdGggKyAxIC0gKGRlcHRoc0xlbiArIDEpIC8gMikgKiBkaXN0YW5jZVlcbiAgICAgIH07XG4gICAgICByZXR1cm4gZXBvcztcbiAgICB9XG4gIH07XG4gIHZhciByb3RhdGVEZWdyZWVzID0ge1xuICAgICdkb3dud2FyZCc6IDAsXG4gICAgJ2xlZnR3YXJkJzogOTAsXG4gICAgJ3Vwd2FyZCc6IDE4MCxcbiAgICAncmlnaHR3YXJkJzogLTkwXG4gIH07XG4gIGlmIChPYmplY3Qua2V5cyhyb3RhdGVEZWdyZWVzKS5pbmRleE9mKG9wdGlvbnMuZGlyZWN0aW9uKSA9PT0gLTEpIHtcbiAgICBlcnJvcihcIkludmFsaWQgZGlyZWN0aW9uICdcIi5jb25jYXQob3B0aW9ucy5kaXJlY3Rpb24sIFwiJyBzcGVjaWZpZWQgZm9yIGJyZWFkdGhmaXJzdCBsYXlvdXQuIFZhbGlkIHZhbHVlcyBhcmU6IFwiKS5jb25jYXQoT2JqZWN0LmtleXMocm90YXRlRGVncmVlcykuam9pbignLCAnKSkpO1xuICB9XG4gIHZhciBnZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsZSkge1xuICAgIHJldHVybiByb3RhdGVQb3NBbmRTa2V3QnlCb3goZ2V0UG9zaXRpb25Ub3BCb3R0b20oZWxlKSwgYmIsIHJvdGF0ZURlZ3JlZXNbb3B0aW9ucy5kaXJlY3Rpb25dKTtcbiAgfTtcbiAgZWxlcy5ub2RlcygpLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBnZXRQb3NpdGlvbik7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzJDYgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGFuZCByYWRpdXMgaWYgbm90IGVub3VnaCBzcGFjZVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBFeGNsdWRlcyB0aGUgbGFiZWwgd2hlbiBjYWxjdWxhdGluZyBub2RlIGJvdW5kaW5nIGJveGVzIGZvciB0aGUgbGF5b3V0IGFsZ29yaXRobVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIHJhZGl1czogdW5kZWZpbmVkLFxuICAvLyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgc3RhcnRBbmdsZTogMyAvIDIgKiBNYXRoLlBJLFxuICAvLyB3aGVyZSBub2RlcyBzdGFydCBpbiByYWRpYW5zXG4gIHN3ZWVwOiB1bmRlZmluZWQsXG4gIC8vIGhvdyBtYW55IHJhZGlhbnMgc2hvdWxkIGJlIGJldHdlZW4gdGhlIGZpcnN0IGFuZCBsYXN0IG5vZGUgKGRlZmF1bHRzIHRvIGZ1bGwgY2lyY2xlKVxuICBjbG9ja3dpc2U6IHRydWUsXG4gIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY2xvY2t3aXNlICh0cnVlKSBvciBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKGZhbHNlKVxuICBzb3J0OiB1bmRlZmluZWQsXG4gIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcbn07XG5mdW5jdGlvbiBDaXJjbGVMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDYsIG9wdGlvbnMpO1xufVxuQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgY2xvY2t3aXNlID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlICE9PSB1bmRlZmluZWQgPyAhb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlIDogb3B0aW9ucy5jbG9ja3dpc2U7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgaWYgKG9wdGlvbnMuc29ydCkge1xuICAgIG5vZGVzID0gbm9kZXMuc29ydChvcHRpb25zLnNvcnQpO1xuICB9XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgY2VudGVyID0ge1xuICAgIHg6IGJiLngxICsgYmIudyAvIDIsXG4gICAgeTogYmIueTEgKyBiYi5oIC8gMlxuICB9O1xuICB2YXIgc3dlZXAgPSBvcHRpb25zLnN3ZWVwID09PSB1bmRlZmluZWQgPyAyICogTWF0aC5QSSAtIDIgKiBNYXRoLlBJIC8gbm9kZXMubGVuZ3RoIDogb3B0aW9ucy5zd2VlcDtcbiAgdmFyIGRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbm9kZXMubGVuZ3RoIC0gMSk7XG4gIHZhciByO1xuICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG4gPSBub2Rlc1tpXTtcbiAgICB2YXIgbmJiID0gbi5sYXlvdXREaW1lbnNpb25zKG9wdGlvbnMpO1xuICAgIHZhciB3ID0gbmJiLnc7XG4gICAgdmFyIGggPSBuYmIuaDtcbiAgICBtaW5EaXN0YW5jZSA9IE1hdGgubWF4KG1pbkRpc3RhbmNlLCB3LCBoKTtcbiAgfVxuICBpZiAobnVtYmVyJDEob3B0aW9ucy5yYWRpdXMpKSB7XG4gICAgciA9IG9wdGlvbnMucmFkaXVzO1xuICB9IGVsc2UgaWYgKG5vZGVzLmxlbmd0aCA8PSAxKSB7XG4gICAgciA9IDA7XG4gIH0gZWxzZSB7XG4gICAgciA9IE1hdGgubWluKGJiLmgsIGJiLncpIC8gMiAtIG1pbkRpc3RhbmNlO1xuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgaWYgKG5vZGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgbWluRGlzdGFuY2UgKj0gMS43NTsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG5cbiAgICB2YXIgZGNvcyA9IE1hdGguY29zKGRUaGV0YSkgLSBNYXRoLmNvcygwKTtcbiAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICB2YXIgck1pbiA9IE1hdGguc3FydChtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlIC8gKGRjb3MgKiBkY29zICsgZHNpbiAqIGRzaW4pKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuICAgIHIgPSBNYXRoLm1heChyTWluLCByKTtcbiAgfVxuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKGVsZSwgaSkge1xuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZSArIGkgKiBkVGhldGEgKiAoY2xvY2t3aXNlID8gMSA6IC0xKTtcbiAgICB2YXIgcnggPSByICogTWF0aC5jb3ModGhldGEpO1xuICAgIHZhciByeSA9IHIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgdmFyIHBvcyA9IHtcbiAgICAgIHg6IGNlbnRlci54ICsgcngsXG4gICAgICB5OiBjZW50ZXIueSArIHJ5XG4gICAgfTtcbiAgICByZXR1cm4gcG9zO1xuICB9O1xuICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGRlZmF1bHRzJDUgPSB7XG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gIHN0YXJ0QW5nbGU6IDMgLyAyICogTWF0aC5QSSxcbiAgLy8gd2hlcmUgbm9kZXMgc3RhcnQgaW4gcmFkaWFuc1xuICBzd2VlcDogdW5kZWZpbmVkLFxuICAvLyBob3cgbWFueSByYWRpYW5zIHNob3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub2RlIChkZWZhdWx0cyB0byBmdWxsIGNpcmNsZSlcbiAgY2xvY2t3aXNlOiB0cnVlLFxuICAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNsb2Nrd2lzZSAodHJ1ZSkgb3IgY291bnRlcmNsb2Nrd2lzZS9hbnRpY2xvY2t3aXNlIChmYWxzZSlcbiAgZXF1aWRpc3RhbnQ6IGZhbHNlLFxuICAvLyB3aGV0aGVyIGxldmVscyBoYXZlIGFuIGVxdWFsIHJhZGlhbCBkaXN0YW5jZSBiZXR3ZW4gdGhlbSwgbWF5IGNhdXNlIGJvdW5kaW5nIGJveCBvdmVyZmxvd1xuICBtaW5Ob2RlU3BhY2luZzogMTAsXG4gIC8vIG1pbiBzcGFjaW5nIGJldHdlZW4gb3V0c2lkZSBvZiBub2RlcyAodXNlZCBmb3IgcmFkaXVzIGFkanVzdG1lbnQpXG4gIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsXG4gIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICBhdm9pZE92ZXJsYXA6IHRydWUsXG4gIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgaGVpZ2h0OiB1bmRlZmluZWQsXG4gIC8vIGhlaWdodCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciBoZWlnaHQpXG4gIHdpZHRoOiB1bmRlZmluZWQsXG4gIC8vIHdpZHRoIG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIHdpZHRoKVxuICBzcGFjaW5nRmFjdG9yOiB1bmRlZmluZWQsXG4gIC8vIEFwcGxpZXMgYSBtdWx0aXBsaWNhdGl2ZSBmYWN0b3IgKD4wKSB0byBleHBhbmQgb3IgY29tcHJlc3MgdGhlIG92ZXJhbGwgYXJlYSB0aGF0IHRoZSBub2RlcyB0YWtlIHVwXG4gIGNvbmNlbnRyaWM6IGZ1bmN0aW9uIGNvbmNlbnRyaWMobm9kZSkge1xuICAgIC8vIHJldHVybnMgbnVtZXJpYyB2YWx1ZSBmb3IgZWFjaCBub2RlLCBwbGFjaW5nIGhpZ2hlciBub2RlcyBpbiBsZXZlbHMgdG93YXJkcyB0aGUgY2VudHJlXG4gICAgcmV0dXJuIG5vZGUuZGVncmVlKCk7XG4gIH0sXG4gIGxldmVsV2lkdGg6IGZ1bmN0aW9uIGxldmVsV2lkdGgobm9kZXMpIHtcbiAgICAvLyB0aGUgdmFyaWF0aW9uIG9mIGNvbmNlbnRyaWMgdmFsdWVzIGluIGVhY2ggbGV2ZWxcbiAgICByZXR1cm4gbm9kZXMubWF4RGVncmVlKCkgLyA0O1xuICB9LFxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHNcbn07XG5mdW5jdGlvbiBDb25jZW50cmljTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ1LCBvcHRpb25zKTtcbn1cbkNvbmNlbnRyaWNMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gIHZhciBjbG9ja3dpc2UgPSBvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgIT09IHVuZGVmaW5lZCA/ICFvcHRpb25zLmNvdW50ZXJjbG9ja3dpc2UgOiBvcHRpb25zLmNsb2Nrd2lzZTtcbiAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgdmFyIGNlbnRlciA9IHtcbiAgICB4OiBiYi54MSArIGJiLncgLyAyLFxuICAgIHk6IGJiLnkxICsgYmIuaCAvIDJcbiAgfTtcbiAgdmFyIG5vZGVWYWx1ZXMgPSBbXTsgLy8geyBub2RlLCB2YWx1ZSB9XG4gIHZhciBtYXhOb2RlU2l6ZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSB2YWx1ZVxuICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljKG5vZGUpO1xuICAgIG5vZGVWYWx1ZXMucHVzaCh7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBub2RlOiBub2RlXG4gICAgfSk7XG5cbiAgICAvLyBmb3Igc3R5bGUgbWFwcGluZ1xuICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb25jZW50cmljID0gdmFsdWU7XG4gIH1cblxuICAvLyBpbiBjYXNlIHdlIHVzZWQgdGhlIGBjb25jZW50cmljYCBpbiBzdHlsZVxuICBub2Rlcy51cGRhdGVTdHlsZSgpO1xuXG4gIC8vIGNhbGN1bGF0ZSBtYXggc2l6ZSBub3cgYmFzZWQgb24gcG90ZW50aWFsbHkgdXBkYXRlZCBtYXBwZXJzXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgdmFyIG5iYiA9IF9ub2RlLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgbWF4Tm9kZVNpemUgPSBNYXRoLm1heChtYXhOb2RlU2l6ZSwgbmJiLncsIG5iYi5oKTtcbiAgfVxuXG4gIC8vIHNvcnQgbm9kZSB2YWx1ZXMgaW4gZGVzY3JlYXNpbmcgb3JkZXJcbiAgbm9kZVZhbHVlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICB9KTtcbiAgdmFyIGxldmVsV2lkdGggPSBvcHRpb25zLmxldmVsV2lkdGgobm9kZXMpO1xuXG4gIC8vIHB1dCB0aGUgdmFsdWVzIGludG8gbGV2ZWxzXG4gIHZhciBsZXZlbHMgPSBbW11dO1xuICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlVmFsdWVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgdmFsID0gbm9kZVZhbHVlc1tfaTJdO1xuICAgIGlmIChjdXJyZW50TGV2ZWwubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGRpZmYgPSBNYXRoLmFicyhjdXJyZW50TGV2ZWxbMF0udmFsdWUgLSB2YWwudmFsdWUpO1xuICAgICAgaWYgKGRpZmYgPj0gbGV2ZWxXaWR0aCkge1xuICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgbGV2ZWxzLnB1c2goY3VycmVudExldmVsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudExldmVsLnB1c2godmFsKTtcbiAgfVxuXG4gIC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuICB2YXIgbWluRGlzdCA9IG1heE5vZGVTaXplICsgb3B0aW9ucy5taW5Ob2RlU3BhY2luZzsgLy8gbWluIGRpc3QgYmV0d2VlbiBub2Rlc1xuXG4gIGlmICghb3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAvLyB0aGVuIHN0cmljdGx5IGNvbnN0cmFpbiB0byBiYlxuICAgIHZhciBmaXJzdEx2bEhhc011bHRpID0gbGV2ZWxzLmxlbmd0aCA+IDAgJiYgbGV2ZWxzWzBdLmxlbmd0aCA+IDE7XG4gICAgdmFyIG1heFIgPSBNYXRoLm1pbihiYi53LCBiYi5oKSAvIDIgLSBtaW5EaXN0O1xuICAgIHZhciByU3RlcCA9IG1heFIgLyAobGV2ZWxzLmxlbmd0aCArIGZpcnN0THZsSGFzTXVsdGkgPyAxIDogMCk7XG4gICAgbWluRGlzdCA9IE1hdGgubWluKG1pbkRpc3QsIHJTdGVwKTtcbiAgfVxuXG4gIC8vIGZpbmQgdGhlIG1ldHJpY3MgZm9yIGVhY2ggbGV2ZWxcbiAgdmFyIHIgPSAwO1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBsZXZlbHMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBsZXZlbCA9IGxldmVsc1tfaTNdO1xuICAgIHZhciBzd2VlcCA9IG9wdGlvbnMuc3dlZXAgPT09IHVuZGVmaW5lZCA/IDIgKiBNYXRoLlBJIC0gMiAqIE1hdGguUEkgLyBsZXZlbC5sZW5ndGggOiBvcHRpb25zLnN3ZWVwO1xuICAgIHZhciBkVGhldGEgPSBsZXZlbC5kVGhldGEgPSBzd2VlcCAvIE1hdGgubWF4KDEsIGxldmVsLmxlbmd0aCAtIDEpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgICBpZiAobGV2ZWwubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCkge1xuICAgICAgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICAgIHZhciByTWluID0gTWF0aC5zcXJ0KG1pbkRpc3QgKiBtaW5EaXN0IC8gKGRjb3MgKiBkY29zICsgZHNpbiAqIGRzaW4pKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuXG4gICAgICByID0gTWF0aC5tYXgock1pbiwgcik7XG4gICAgfVxuICAgIGxldmVsLnIgPSByO1xuICAgIHIgKz0gbWluRGlzdDtcbiAgfVxuICBpZiAob3B0aW9ucy5lcXVpZGlzdGFudCkge1xuICAgIHZhciByRGVsdGFNYXggPSAwO1xuICAgIHZhciBfciA9IDA7XG4gICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbGV2ZWxzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciBfbGV2ZWwgPSBsZXZlbHNbX2k0XTtcbiAgICAgIHZhciByRGVsdGEgPSBfbGV2ZWwuciAtIF9yO1xuICAgICAgckRlbHRhTWF4ID0gTWF0aC5tYXgockRlbHRhTWF4LCByRGVsdGEpO1xuICAgIH1cbiAgICBfciA9IDA7XG4gICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbGV2ZWxzLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgIHZhciBfbGV2ZWwyID0gbGV2ZWxzW19pNV07XG4gICAgICBpZiAoX2k1ID09PSAwKSB7XG4gICAgICAgIF9yID0gX2xldmVsMi5yO1xuICAgICAgfVxuICAgICAgX2xldmVsMi5yID0gX3I7XG4gICAgICBfciArPSByRGVsdGFNYXg7XG4gICAgfVxuICB9XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHBvc2l0aW9uc1xuICB2YXIgcG9zID0ge307IC8vIGlkID0+IHBvc2l0aW9uXG4gIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGxldmVscy5sZW5ndGg7IF9pNisrKSB7XG4gICAgdmFyIF9sZXZlbDMgPSBsZXZlbHNbX2k2XTtcbiAgICB2YXIgX2RUaGV0YSA9IF9sZXZlbDMuZFRoZXRhO1xuICAgIHZhciBfcjIgPSBfbGV2ZWwzLnI7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBfbGV2ZWwzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgX3ZhbCA9IF9sZXZlbDNbal07XG4gICAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyAoY2xvY2t3aXNlID8gMSA6IC0xKSAqIF9kVGhldGEgKiBqO1xuICAgICAgdmFyIHAgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgX3IyICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICB5OiBjZW50ZXIueSArIF9yMiAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgfTtcbiAgICAgIHBvc1tfdmFsLm5vZGUuaWQoKV0gPSBwO1xuICAgIH1cbiAgfVxuXG4gIC8vIHBvc2l0aW9uIHRoZSBub2Rlc1xuICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICByZXR1cm4gcG9zW2lkXTtcbiAgfSk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxuLypcblRoZSBDb1NFIGxheW91dCB3YXMgd3JpdHRlbiBieSBHZXJhcmRvIEh1Y2suXG5odHRwczovL3d3dy5saW5rZWRpbi5jb20vaW4vZ2VyYXJkb2h1Y2svXG5cbkJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgYXJ0aWNsZTpcbmh0dHA6Ly9kbC5hY20ub3JnL2NpdGF0aW9uLmNmbT9pZD0xNDk4MDQ3XG5cbk1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG52YXIgREVCVUc7XG5cbi8qKlxuICogQGJyaWVmIDogIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIGRlZmF1bHRzJDQgPSB7XG4gIC8vIENhbGxlZCBvbiBgbGF5b3V0cmVhZHlgXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LFxuICAvLyBDYWxsZWQgb24gYGxheW91dHN0b3BgXG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSxcbiAgLy8gV2hldGhlciB0byBhbmltYXRlIHdoaWxlIHJ1bm5pbmcgdGhlIGxheW91dFxuICAvLyB0cnVlIDogQW5pbWF0ZSBjb250aW51b3VzbHkgYXMgdGhlIGxheW91dCBpcyBydW5uaW5nXG4gIC8vIGZhbHNlIDogSnVzdCBzaG93IHRoZSBlbmQgcmVzdWx0XG4gIC8vICdlbmQnIDogQW5pbWF0ZSB3aXRoIHRoZSBlbmQgcmVzdWx0LCBmcm9tIHRoZSBpbml0aWFsIHBvc2l0aW9ucyB0byB0aGUgZW5kIHBvc2l0aW9uc1xuICBhbmltYXRlOiB0cnVlLFxuICAvLyBFYXNpbmcgb2YgdGhlIGFuaW1hdGlvbiBmb3IgYW5pbWF0ZTonZW5kJ1xuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gVGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gZm9yIGFuaW1hdGU6J2VuZCdcbiAgYW5pbWF0aW9uRHVyYXRpb246IHVuZGVmaW5lZCxcbiAgLy8gQSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWRcbiAgLy8gQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkXG4gIC8vIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBUaGUgbGF5b3V0IGFuaW1hdGVzIG9ubHkgYWZ0ZXIgdGhpcyBtYW55IG1pbGxpc2Vjb25kcyBmb3IgYW5pbWF0ZTp0cnVlXG4gIC8vIChwcmV2ZW50cyBmbGFzaGluZyBvbiBmYXN0IHJ1bnMpXG4gIGFuaW1hdGlvblRocmVzaG9sZDogMjUwLFxuICAvLyBOdW1iZXIgb2YgaXRlcmF0aW9ucyBiZXR3ZWVuIGNvbnNlY3V0aXZlIHNjcmVlbiBwb3NpdGlvbnMgdXBkYXRlXG4gIHJlZnJlc2g6IDIwLFxuICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICBmaXQ6IHRydWUsXG4gIC8vIFBhZGRpbmcgb24gZml0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gUmFuZG9taXplIHRoZSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgKHRydWUpIG9yIHVzZSBleGlzdGluZyBwb3NpdGlvbnMgKGZhbHNlKVxuICByYW5kb21pemU6IGZhbHNlLFxuICAvLyBFeHRyYSBzcGFjaW5nIGJldHdlZW4gY29tcG9uZW50cyBpbiBub24tY29tcG91bmQgZ3JhcGhzXG4gIGNvbXBvbmVudFNwYWNpbmc6IDQwLFxuICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVSZXB1bHNpb246IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZSkge1xuICAgIHJldHVybiAyMDQ4O1xuICB9LFxuICAvLyBOb2RlIHJlcHVsc2lvbiAob3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZU92ZXJsYXA6IDQsXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IGZ1bmN0aW9uIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgcmV0dXJuIDMyO1xuICB9LFxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHk6IGZ1bmN0aW9uIGVkZ2VFbGFzdGljaXR5KGVkZ2UpIHtcbiAgICByZXR1cm4gMzI7XG4gIH0sXG4gIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgbmVzdGluZ0ZhY3RvcjogMS4yLFxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogMSxcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXI6IDEwMDAsXG4gIC8vIEluaXRpYWwgdGVtcGVyYXR1cmUgKG1heGltdW0gbm9kZSBkaXNwbGFjZW1lbnQpXG4gIGluaXRpYWxUZW1wOiAxMDAwLFxuICAvLyBDb29saW5nIGZhY3RvciAoaG93IHRoZSB0ZW1wZXJhdHVyZSBpcyByZWR1Y2VkIGJldHdlZW4gY29uc2VjdXRpdmUgaXRlcmF0aW9uc1xuICBjb29saW5nRmFjdG9yOiAwLjk5LFxuICAvLyBMb3dlciB0ZW1wZXJhdHVyZSB0aHJlc2hvbGQgKGJlbG93IHRoaXMgcG9pbnQgdGhlIGxheW91dCB3aWxsIGVuZClcbiAgbWluVGVtcDogMS4wXG59O1xuXG4vKipcbiAqIEBicmllZiAgICAgICA6IGNvbnN0cnVjdG9yXG4gKiBAYXJnIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBDb3NlTGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQ0LCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zLmxheW91dCA9IHRoaXM7XG5cbiAgLy8gRXhjbHVkZSBhbnkgZWRnZSB0aGF0IGhhcyBhIHNvdXJjZSBvciB0YXJnZXQgbm9kZSB0aGF0IGlzIG5vdCBpbiB0aGUgc2V0IG9mIHBhc3NlZC1pbiBub2Rlc1xuICB2YXIgbm9kZXMgPSB0aGlzLm9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgZWRnZXMgPSB0aGlzLm9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICB2YXIgbm90RWRnZXMgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgc291cmNlSWQgPSBlLnNvdXJjZSgpLmRhdGEoJ2lkJyk7XG4gICAgdmFyIHRhcmdldElkID0gZS50YXJnZXQoKS5kYXRhKCdpZCcpO1xuICAgIHZhciBoYXNTb3VyY2UgPSBub2Rlcy5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gbi5kYXRhKCdpZCcpID09PSBzb3VyY2VJZDtcbiAgICB9KTtcbiAgICB2YXIgaGFzVGFyZ2V0ID0gbm9kZXMuc29tZShmdW5jdGlvbiAobikge1xuICAgICAgcmV0dXJuIG4uZGF0YSgnaWQnKSA9PT0gdGFyZ2V0SWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuICFoYXNTb3VyY2UgfHwgIWhhc1RhcmdldDtcbiAgfSk7XG4gIHRoaXMub3B0aW9ucy5lbGVzID0gdGhpcy5vcHRpb25zLmVsZXMubm90KG5vdEVkZ2VzKTtcbn1cblxuLyoqXG4gKiBAYnJpZWYgOiBydW5zIHRoZSBsYXlvdXRcbiAqL1xuQ29zZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGxheW91dCA9IHRoaXM7XG4gIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG4gIGlmIChvcHRpb25zLmFuaW1hdGUgPT09IHRydWUgfHwgb3B0aW9ucy5hbmltYXRlID09PSBmYWxzZSkge1xuICAgIGxheW91dC5lbWl0KHtcbiAgICAgIHR5cGU6ICdsYXlvdXRzdGFydCcsXG4gICAgICBsYXlvdXQ6IGxheW91dFxuICAgIH0pO1xuICB9XG5cbiAgLy8gU2V0IERFQlVHIC0gR2xvYmFsIHZhcmlhYmxlXG4gIGlmICh0cnVlID09PSBvcHRpb25zLmRlYnVnKSB7XG4gICAgREVCVUcgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIERFQlVHID0gZmFsc2U7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIGxheW91dCBpbmZvXG4gIHZhciBsYXlvdXRJbmZvID0gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKTtcblxuICAvLyBTaG93IExheW91dEluZm8gY29udGVudHMgaWYgZGVidWdnaW5nXG4gIGlmIChERUJVRykge1xuICAgIHByaW50TGF5b3V0SW5mbyhsYXlvdXRJbmZvKTtcbiAgfVxuXG4gIC8vIElmIHJlcXVpcmVkLCByYW5kb21pemUgbm9kZSBwb3NpdGlvbnNcbiAgaWYgKG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8pO1xuICB9XG4gIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICB2YXIgcmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG5cbiAgICAvLyBGaXQgdGhlIGdyYXBoIGlmIG5lY2Vzc2FyeVxuICAgIGlmICh0cnVlID09PSBvcHRpb25zLmZpdCkge1xuICAgICAgY3kuZml0KG9wdGlvbnMucGFkZGluZyk7XG4gICAgfVxuICB9O1xuICB2YXIgbWFpbkxvb3AgPSBmdW5jdGlvbiBtYWluTG9vcChpKSB7XG4gICAgaWYgKGxheW91dC5zdG9wcGVkIHx8IGkgPj0gb3B0aW9ucy5udW1JdGVyKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhcIkxheW91dCBtYW51YWxseSBzdG9wcGVkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRG8gb25lIHN0ZXAgaW4gdGhlIHBoaXNpY2FsIHNpbXVsYXRpb25cbiAgICBzdGVwKGxheW91dEluZm8sIG9wdGlvbnMpO1xuXG4gICAgLy8gVXBkYXRlIHRlbXBlcmF0dXJlXG4gICAgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSA9IGxheW91dEluZm8udGVtcGVyYXR1cmUgKiBvcHRpb25zLmNvb2xpbmdGYWN0b3I7XG4gICAgLy8gbG9nRGVidWcoXCJOZXcgdGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG5cbiAgICBpZiAobGF5b3V0SW5mby50ZW1wZXJhdHVyZSA8IG9wdGlvbnMubWluVGVtcCkge1xuICAgICAgLy8gbG9nRGVidWcoXCJUZW1wZXJhdHVyZSBkcm9wIGJlbG93IG1pbmltdW0gdGhyZXNob2xkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICB2YXIgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmFuaW1hdGUgPT09IGZhbHNlKSB7XG4gICAgICByZWZyZXNoKCk7XG5cbiAgICAgIC8vIExheW91dCBoYXMgZmluaXNoZWRcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgbGF5b3V0LmVtaXQoe1xuICAgICAgICB0eXBlOiAnbGF5b3V0c3RvcCcsXG4gICAgICAgIGxheW91dDogbGF5b3V0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gICAgICB2YXIgZ2V0U2NhbGVkUG9zID0gZ2V0U2NhbGVJbkJvdW5kc0ZuKGxheW91dEluZm8sIG9wdGlvbnMsIG5vZGVzKTtcbiAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGdldFNjYWxlZFBvcyk7XG4gICAgfVxuICB9O1xuICB2YXIgaSA9IDA7XG4gIHZhciBsb29wUmV0ID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMuYW5pbWF0ZSA9PT0gdHJ1ZSkge1xuICAgIHZhciBfZnJhbWUgPSBmdW5jdGlvbiBmcmFtZSgpIHtcbiAgICAgIHZhciBmID0gMDtcbiAgICAgIHdoaWxlIChsb29wUmV0ICYmIGYgPCBvcHRpb25zLnJlZnJlc2gpIHtcbiAgICAgICAgbG9vcFJldCA9IG1haW5Mb29wKGkpO1xuICAgICAgICBpKys7XG4gICAgICAgIGYrKztcbiAgICAgIH1cbiAgICAgIGlmICghbG9vcFJldCkge1xuICAgICAgICAvLyBpdCdzIGRvbmVcbiAgICAgICAgc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm93ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgaWYgKG5vdyAtIHN0YXJ0VGltZSA+PSBvcHRpb25zLmFuaW1hdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2ZyYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIF9mcmFtZSgpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChsb29wUmV0KSB7XG4gICAgICBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHNlcGFyYXRlQ29tcG9uZW50cyhsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICBkb25lKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG4vKipcbiAqIEBicmllZiA6IGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICovXG5Db3NlTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICBpZiAodGhpcy50aHJlYWQpIHtcbiAgICB0aGlzLnRocmVhZC5zdG9wKCk7XG4gIH1cbiAgdGhpcy5lbWl0KCdsYXlvdXRzdG9wJyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcbkNvc2VMYXlvdXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnRocmVhZCkge1xuICAgIHRoaXMudGhyZWFkLnN0b3AoKTtcbiAgfVxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8qKlxuICogQGJyaWVmICAgICA6IENyZWF0ZXMgYW4gb2JqZWN0IHdoaWNoIGlzIGNvbnRhaW5zIGFsbCB0aGUgZGF0YVxuICogICAgICAgICAgICAgIHVzZWQgaW4gdGhlIGxheW91dCBwcm9jZXNzXG4gKiBAYXJnIGN5ICAgIDogY3l0b3NjYXBlLmpzIG9iamVjdFxuICogQHJldHVybiAgICA6IGxheW91dEluZm8gb2JqZWN0IGluaXRpYWxpemVkXG4gKi9cbnZhciBjcmVhdGVMYXlvdXRJbmZvID0gZnVuY3Rpb24gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKSB7XG4gIC8vIFNob3J0Y3V0XG4gIHZhciBlZGdlcyA9IG9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgdmFyIGJiID0gbWFrZUJvdW5kaW5nQm94KG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHc6IGN5LndpZHRoKCksXG4gICAgaDogY3kuaGVpZ2h0KClcbiAgfSk7XG4gIHZhciBsYXlvdXRJbmZvID0ge1xuICAgIGlzQ29tcG91bmQ6IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSxcbiAgICBsYXlvdXROb2RlczogW10sXG4gICAgaWRUb0luZGV4OiB7fSxcbiAgICBub2RlU2l6ZTogbm9kZXMuc2l6ZSgpLFxuICAgIGdyYXBoU2V0OiBbXSxcbiAgICBpbmRleFRvR3JhcGg6IFtdLFxuICAgIGxheW91dEVkZ2VzOiBbXSxcbiAgICBlZGdlU2l6ZTogZWRnZXMuc2l6ZSgpLFxuICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLmluaXRpYWxUZW1wLFxuICAgIGNsaWVudFdpZHRoOiBiYi53LFxuICAgIGNsaWVudEhlaWdodDogYmIuaCxcbiAgICBib3VuZGluZ0JveDogYmJcbiAgfTtcbiAgdmFyIGNvbXBvbmVudHMgPSBvcHRpb25zLmVsZXMuY29tcG9uZW50cygpO1xuICB2YXIgaWQyY21wdElkID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2ldO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29tcG9uZW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFtqXTtcbiAgICAgIGlkMmNtcHRJZFtub2RlLmlkKCldID0gaTtcbiAgICB9XG4gIH1cblxuICAvLyBJdGVyYXRlIG92ZXIgYWxsIG5vZGVzLCBjcmVhdGluZyBsYXlvdXQgbm9kZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IG5vZGVzW2ldO1xuICAgIHZhciBuYmIgPSBuLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgdmFyIHRlbXBOb2RlID0ge307XG4gICAgdGVtcE5vZGUuaXNMb2NrZWQgPSBuLmxvY2tlZCgpO1xuICAgIHRlbXBOb2RlLmlkID0gbi5kYXRhKCdpZCcpO1xuICAgIHRlbXBOb2RlLnBhcmVudElkID0gbi5kYXRhKCdwYXJlbnQnKTtcbiAgICB0ZW1wTm9kZS5jbXB0SWQgPSBpZDJjbXB0SWRbbi5pZCgpXTtcbiAgICB0ZW1wTm9kZS5jaGlsZHJlbiA9IFtdO1xuICAgIHRlbXBOb2RlLnBvc2l0aW9uWCA9IG4ucG9zaXRpb24oJ3gnKTtcbiAgICB0ZW1wTm9kZS5wb3NpdGlvblkgPSBuLnBvc2l0aW9uKCd5Jyk7XG4gICAgdGVtcE5vZGUub2Zmc2V0WCA9IDA7XG4gICAgdGVtcE5vZGUub2Zmc2V0WSA9IDA7XG4gICAgdGVtcE5vZGUuaGVpZ2h0ID0gbmJiLnc7XG4gICAgdGVtcE5vZGUud2lkdGggPSBuYmIuaDtcbiAgICB0ZW1wTm9kZS5tYXhYID0gdGVtcE5vZGUucG9zaXRpb25YICsgdGVtcE5vZGUud2lkdGggLyAyO1xuICAgIHRlbXBOb2RlLm1pblggPSB0ZW1wTm9kZS5wb3NpdGlvblggLSB0ZW1wTm9kZS53aWR0aCAvIDI7XG4gICAgdGVtcE5vZGUubWF4WSA9IHRlbXBOb2RlLnBvc2l0aW9uWSArIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgdGVtcE5vZGUubWluWSA9IHRlbXBOb2RlLnBvc2l0aW9uWSAtIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgdGVtcE5vZGUucGFkTGVmdCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRSaWdodCA9IHBhcnNlRmxvYXQobi5zdHlsZSgncGFkZGluZycpKTtcbiAgICB0ZW1wTm9kZS5wYWRUb3AgPSBwYXJzZUZsb2F0KG4uc3R5bGUoJ3BhZGRpbmcnKSk7XG4gICAgdGVtcE5vZGUucGFkQm90dG9tID0gcGFyc2VGbG9hdChuLnN0eWxlKCdwYWRkaW5nJykpO1xuXG4gICAgLy8gZm9yY2VzXG4gICAgdGVtcE5vZGUubm9kZVJlcHVsc2lvbiA9IGZuJDYob3B0aW9ucy5ub2RlUmVwdWxzaW9uKSA/IG9wdGlvbnMubm9kZVJlcHVsc2lvbihuKSA6IG9wdGlvbnMubm9kZVJlcHVsc2lvbjtcblxuICAgIC8vIEFkZCBuZXcgbm9kZVxuICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXMucHVzaCh0ZW1wTm9kZSk7XG4gICAgLy8gQWRkIGVudHJ5IHRvIGlkLWluZGV4IG1hcFxuICAgIGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLmlkXSA9IGk7XG4gIH1cblxuICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gIHZhciBxdWV1ZSA9IFtdO1xuICB2YXIgc3RhcnQgPSAwOyAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICB2YXIgZW5kID0gLTE7IC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gIHZhciB0ZW1wR3JhcGggPSBbXTtcblxuICAvLyBTZWNvbmQgcGFzcyB0byBhZGQgY2hpbGQgaW5mb3JtYXRpb24gYW5kXG4gIC8vIGluaXRpYWxpemUgcXVldWUgZm9yIGhpZXJhcmNoaWNhbCB0cmF2ZXJzYWxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgdmFyIHBfaWQgPSBuLnBhcmVudElkO1xuICAgIC8vIENoZWNrIGlmIG5vZGUgbiBoYXMgYSBwYXJlbnQgbm9kZVxuICAgIGlmIChudWxsICE9IHBfaWQpIHtcbiAgICAgIC8vIEFkZCBub2RlIElkIHRvIHBhcmVudCdzIGxpc3Qgb2YgY2hpbGRyZW5cbiAgICAgIGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcF9pZF1dLmNoaWxkcmVuLnB1c2gobi5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGEgbm9kZSBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHRoZW4gaXQncyBpbiB0aGUgcm9vdCBncmFwaFxuICAgICAgcXVldWVbKytlbmRdID0gbi5pZDtcbiAgICAgIHRlbXBHcmFwaC5wdXNoKG4uaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCByb290IGdyYXBoIHRvIGdyYXBoU2V0XG4gIGxheW91dEluZm8uZ3JhcGhTZXQucHVzaCh0ZW1wR3JhcGgpO1xuXG4gIC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgdmFyIG5vZGVfaWQgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICB2YXIgbm9kZV9peCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVfaWRdO1xuICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlX2l4XTtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBBZGQgY2hpbGRyZW4gbm9kZXMgYXMgYSBuZXcgZ3JhcGggdG8gZ3JhcGggc2V0XG4gICAgICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2goY2hpbGRyZW4pO1xuICAgICAgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZSBxdWV1ZSB0byBiZSB2aXNpdGVkXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBpbmRleFRvR3JhcGggbWFwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBncmFwaC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dO1xuICAgICAgbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbaW5kZXhdID0gaTtcbiAgICB9XG4gIH1cblxuICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzLCBjcmVhdGluZyBMYXlvdXQgRWRnZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgIHZhciB0ZW1wRWRnZSA9IHt9O1xuICAgIHRlbXBFZGdlLmlkID0gZS5kYXRhKCdpZCcpO1xuICAgIHRlbXBFZGdlLnNvdXJjZUlkID0gZS5kYXRhKCdzb3VyY2UnKTtcbiAgICB0ZW1wRWRnZS50YXJnZXRJZCA9IGUuZGF0YSgndGFyZ2V0Jyk7XG5cbiAgICAvLyBDb21wdXRlIGlkZWFsIGxlbmd0aFxuICAgIHZhciBpZGVhbExlbmd0aCA9IGZuJDYob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgpID8gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgoZSkgOiBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aDtcbiAgICB2YXIgZWxhc3RpY2l0eSA9IGZuJDYob3B0aW9ucy5lZGdlRWxhc3RpY2l0eSkgPyBvcHRpb25zLmVkZ2VFbGFzdGljaXR5KGUpIDogb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTtcblxuICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gaW50ZXIgZ3JhcGggZWRnZVxuICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnNvdXJjZUlkXTtcbiAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wRWRnZS50YXJnZXRJZF07XG4gICAgdmFyIHNvdXJjZUdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbc291cmNlSXhdO1xuICAgIHZhciB0YXJnZXRHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3RhcmdldEl4XTtcbiAgICBpZiAoc291cmNlR3JhcGggIT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIC8vIEZpbmQgbG93ZXN0IGNvbW1vbiBncmFwaCBhbmNlc3RvclxuICAgICAgdmFyIGxjYSA9IGZpbmRMQ0EodGVtcEVkZ2Uuc291cmNlSWQsIHRlbXBFZGdlLnRhcmdldElkLCBsYXlvdXRJbmZvKTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdW0gb2Ygbm9kZSBkZXB0aHMsIHJlbGF0aXZlIHRvIGxjYSBncmFwaFxuICAgICAgdmFyIGxjYUdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtsY2FdO1xuICAgICAgdmFyIGRlcHRoID0gMDtcblxuICAgICAgLy8gU291cmNlIGRlcHRoXG4gICAgICB2YXIgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcmdldCBkZXB0aFxuICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcbiAgICAgIHdoaWxlICgtMSA9PT0gbGNhR3JhcGguaW5kZXhPZih0ZW1wTm9kZS5pZCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKCdMQ0Egb2Ygbm9kZXMgJyArIHRlbXBFZGdlLnNvdXJjZUlkICsgJyBhbmQgJyArIHRlbXBFZGdlLnRhcmdldElkICtcbiAgICAgIC8vICBcIi4gSW5kZXg6IFwiICsgbGNhICsgXCIgQ29udGVudHM6IFwiICsgbGNhR3JhcGgudG9TdHJpbmcoKSArXG4gICAgICAvLyAgXCIuIERlcHRoOiBcIiArIGRlcHRoKTtcblxuICAgICAgLy8gVXBkYXRlIGlkZWFsTGVuZ3RoXG4gICAgICBpZGVhbExlbmd0aCAqPSBkZXB0aCAqIG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgICB9XG4gICAgdGVtcEVkZ2UuaWRlYWxMZW5ndGggPSBpZGVhbExlbmd0aDtcbiAgICB0ZW1wRWRnZS5lbGFzdGljaXR5ID0gZWxhc3RpY2l0eTtcbiAgICBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLnB1c2godGVtcEVkZ2UpO1xuICB9XG5cbiAgLy8gRmluYWxseSwgcmV0dXJuIGxheW91dEluZm8gb2JqZWN0XG4gIHJldHVybiBsYXlvdXRJbmZvO1xufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbG93ZXN0IGNvbW1vblxuICogICAgICAgICAgZ3JhcGggYW5jZXN0b3IgYmV0d2VlbiAyIG5vZGVzIGluIHRoZSBzdWJ0cmVlXG4gKiAgICAgICAgICAoZnJvbSB0aGUgZ3JhcGggaGllcmFyY2h5IGluZHVjZWQgdHJlZSkgd2hvc2VcbiAqICAgICAgICAgIHJvb3QgaXMgZ3JhcGhJeFxuICpcbiAqIEBhcmcgbm9kZTE6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTI6IG5vZGUyJ3MgSURcbiAqIEBhcmcgbGF5b3V0SW5mbzogbGF5b3V0SW5mbyBvYmplY3RcbiAqXG4gKi9cbnZhciBmaW5kTENBID0gZnVuY3Rpb24gZmluZExDQShub2RlMSwgbm9kZTIsIGxheW91dEluZm8pIHtcbiAgLy8gRmluZCB0aGVpciBjb21tb24gYW5jZXN0ZXIsIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QgZ3JhcGhcbiAgdmFyIHJlcyA9IF9maW5kTENBX2F1eChub2RlMSwgbm9kZTIsIDAsIGxheW91dEluZm8pO1xuICBpZiAoMiA+IHJlcy5jb3VudCkge1xuICAgIC8vIElmIGF1eCBmdW5jdGlvbiBjb3VsZG4ndCBmaW5kIHRoZSBjb21tb24gYW5jZXN0ZXIsXG4gICAgLy8gdGhlbiBpdCBpcyB0aGUgcm9vdCBncmFwaFxuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXMuZ3JhcGg7XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogQXV4aWxpYXJ5IGZ1bmN0aW9uIHVzZWQgZm9yIExDQSBjb21wdXRhdGlvblxuICpcbiAqIEBhcmcgbm9kZTEgICAgICA6IG5vZGUxJ3MgSURcbiAqIEBhcmcgbm9kZTIgICAgICA6IG5vZGUyJ3MgSURcbiAqIEBhcmcgZ3JhcGhJeCAgICA6IHN1YmdyYXBoIGluZGV4XG4gKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIG9iamVjdFxuICpcbiAqIEByZXR1cm4gICAgICAgICA6IG9iamVjdCBvZiB0aGUgZm9ybSB7Y291bnQ6IFgsIGdyYXBoOiBZfSwgd2hlcmU6XG4gKiAgICAgICAgICAgICAgICAgICBYIGlzIHRoZSBudW1iZXIgb2YgYW5jZXN0b3JzIChtYXg6IDIpIGZvdW5kIGluXG4gKiAgICAgICAgICAgICAgICAgICBncmFwaEl4IChhbmQgaXQncyBzdWJncmFwaHMpLFxuICogICAgICAgICAgICAgICAgICAgWSBpcyB0aGUgZ3JhcGggaW5kZXggb2YgdGhlIGxvd2VzdCBncmFwaCBjb250YWluaW5nXG4gKiAgICAgICAgICAgICAgICAgICBhbGwgWCBub2Rlc1xuICovXG52YXIgX2ZpbmRMQ0FfYXV4ID0gZnVuY3Rpb24gZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBncmFwaEl4LCBsYXlvdXRJbmZvKSB7XG4gIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbZ3JhcGhJeF07XG4gIC8vIElmIGJvdGggbm9kZXMgYmVsb25ncyB0byBncmFwaEl4XG4gIGlmICgtMSA8IGdyYXBoLmluZGV4T2Yobm9kZTEpICYmIC0xIDwgZ3JhcGguaW5kZXhPZihub2RlMikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY291bnQ6IDIsXG4gICAgICBncmFwaDogZ3JhcGhJeFxuICAgIH07XG4gIH1cblxuICAvLyBNYWtlIHJlY3Vyc2l2ZSBjYWxscyBmb3IgYWxsIHN1YmdyYXBoc1xuICB2YXIgYyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZUlkID0gZ3JhcGhbaV07XG4gICAgdmFyIG5vZGVJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgdmFyIGNoaWxkcmVuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSXhdLmNoaWxkcmVuO1xuXG4gICAgLy8gSWYgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBza2lwIGl0XG4gICAgaWYgKDAgPT09IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlblswXV1dO1xuICAgIHZhciByZXN1bHQgPSBfZmluZExDQV9hdXgobm9kZTEsIG5vZGUyLCBjaGlsZEdyYXBoSXgsIGxheW91dEluZm8pO1xuICAgIGlmICgwID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE5laXRoZXIgbm9kZTEgbm9yIG5vZGUyIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoMSA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAvLyBPbmUgb2YgKG5vZGUxLCBub2RlMikgaXMgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjKys7XG4gICAgICBpZiAoMiA9PT0gYykge1xuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGZvdW5kIGJvdGggbm9kZXMsIG5vIG5lZWQgdG8ga2VlcCBzZWFyY2hpbmdcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEJvdGggbm9kZXMgYXJlIHByZXNlbnQgaW4gdGhpcyBzdWJncmFwaFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb3VudDogYyxcbiAgICBncmFwaDogZ3JhcGhJeFxuICB9O1xufTtcblxuLyoqXG4gKiBAYnJpZWY6IHByaW50c0xheW91dEluZm8gaW50byBqcyBjb25zb2xlXG4gKiAgICAgICAgIE9ubHkgdXNlZCBmb3IgZGViYnVnaW5nXG4gKi9cbnZhciBwcmludExheW91dEluZm87IFxuXG4vKipcbiAqIEBicmllZiA6IFJhbmRvbWl6ZXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBub2Rlc1xuICovXG52YXIgcmFuZG9taXplUG9zaXRpb25zID0gZnVuY3Rpb24gcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8sIGN5KSB7XG4gIHZhciB3aWR0aCA9IGxheW91dEluZm8uY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBsYXlvdXRJbmZvLmNsaWVudEhlaWdodDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG5cbiAgICAvLyBObyBuZWVkIHRvIHJhbmRvbWl6ZSBjb21wb3VuZCBub2RlcyBvciBsb2NrZWQgbm9kZXNcbiAgICBpZiAoMCA9PT0gbi5jaGlsZHJlbi5sZW5ndGggJiYgIW4uaXNMb2NrZWQpIHtcbiAgICAgIG4ucG9zaXRpb25YID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoO1xuICAgICAgbi5wb3NpdGlvblkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0O1xuICAgIH1cbiAgfVxufTtcbnZhciBnZXRTY2FsZUluQm91bmRzRm4gPSBmdW5jdGlvbiBnZXRTY2FsZUluQm91bmRzRm4obGF5b3V0SW5mbywgb3B0aW9ucywgbm9kZXMpIHtcbiAgdmFyIGJiID0gbGF5b3V0SW5mby5ib3VuZGluZ0JveDtcbiAgdmFyIGNvc2VCQiA9IHtcbiAgICB4MTogSW5maW5pdHksXG4gICAgeDI6IC1JbmZpbml0eSxcbiAgICB5MTogSW5maW5pdHksXG4gICAgeTI6IC1JbmZpbml0eVxuICB9O1xuICBpZiAob3B0aW9ucy5ib3VuZGluZ0JveCkge1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZS5kYXRhKCdpZCcpXV07XG4gICAgICBjb3NlQkIueDEgPSBNYXRoLm1pbihjb3NlQkIueDEsIGxub2RlLnBvc2l0aW9uWCk7XG4gICAgICBjb3NlQkIueDIgPSBNYXRoLm1heChjb3NlQkIueDIsIGxub2RlLnBvc2l0aW9uWCk7XG4gICAgICBjb3NlQkIueTEgPSBNYXRoLm1pbihjb3NlQkIueTEsIGxub2RlLnBvc2l0aW9uWSk7XG4gICAgICBjb3NlQkIueTIgPSBNYXRoLm1heChjb3NlQkIueTIsIGxub2RlLnBvc2l0aW9uWSk7XG4gICAgfSk7XG4gICAgY29zZUJCLncgPSBjb3NlQkIueDIgLSBjb3NlQkIueDE7XG4gICAgY29zZUJCLmggPSBjb3NlQkIueTIgLSBjb3NlQkIueTE7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICB2YXIgbG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2VsZS5kYXRhKCdpZCcpXV07XG4gICAgaWYgKG9wdGlvbnMuYm91bmRpbmdCb3gpIHtcbiAgICAgIC8vIHRoZW4gYWRkIGV4dHJhIGJvdW5kaW5nIGJveCBjb25zdHJhaW50XG4gICAgICAvLyBIYW5kbGUgc2luZ2xlIG5vZGUgY2FzZSB3aGVyZSBjb3NlQkIudyBvciBjb3NlQkIuaCBpcyAwXG4gICAgICB2YXIgcGN0WCA9IGNvc2VCQi53ID09PSAwID8gMC41IDogKGxub2RlLnBvc2l0aW9uWCAtIGNvc2VCQi54MSkgLyBjb3NlQkIudztcbiAgICAgIHZhciBwY3RZID0gY29zZUJCLmggPT09IDAgPyAwLjUgOiAobG5vZGUucG9zaXRpb25ZIC0gY29zZUJCLnkxKSAvIGNvc2VCQi5oO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYmIueDEgKyBwY3RYICogYmIudyxcbiAgICAgICAgeTogYmIueTEgKyBwY3RZICogYmIuaFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogbG5vZGUucG9zaXRpb25YLFxuICAgICAgICB5OiBsbm9kZS5wb3NpdGlvbllcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBVcGRhdGVzIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgaW4gdGhlIG5ldHdvcmtcbiAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0XG4gKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG52YXIgcmVmcmVzaFBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJlZnJlc2hQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgLy8gdmFyIHMgPSAnUmVmcmVzaGluZyBwb3NpdGlvbnMnO1xuICAvLyBsb2dEZWJ1ZyhzKTtcblxuICB2YXIgbGF5b3V0ID0gb3B0aW9ucy5sYXlvdXQ7XG4gIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuICB2YXIgZ2V0U2NhbGVkUG9zID0gZ2V0U2NhbGVJbkJvdW5kc0ZuKGxheW91dEluZm8sIG9wdGlvbnMsIG5vZGVzKTtcbiAgbm9kZXMucG9zaXRpb25zKGdldFNjYWxlZFBvcyk7XG5cbiAgLy8gVHJpZ2dlciBsYXlvdXRSZWFkeSBvbmx5IG9uIGZpcnN0IGNhbGxcbiAgaWYgKHRydWUgIT09IGxheW91dEluZm8ucmVhZHkpIHtcbiAgICAvLyBzID0gJ1RyaWdnZXJpbmcgbGF5b3V0cmVhZHknO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIGxheW91dEluZm8ucmVhZHkgPSB0cnVlO1xuICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgbGF5b3V0LmVtaXQoe1xuICAgICAgdHlwZTogJ2xheW91dHJlYWR5JyxcbiAgICAgIGxheW91dDogdGhpc1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IExvZ3MgYSBkZWJ1ZyBtZXNzYWdlIGluIEpTIGNvbnNvbGUsIGlmIERFQlVHIGlzIE9OXG4gKi9cbi8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKHRleHQpIHtcbi8vICAgaWYgKERFQlVHKSB7XG4vLyAgICAgY29uc29sZS5kZWJ1Zyh0ZXh0KTtcbi8vICAgfVxuLy8gfTtcblxuLyoqXG4gKiBAYnJpZWYgICAgICAgICAgOiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRoZSBwaHlzaWNhbCBzaW11bGF0aW9uXG4gKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXG4gKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICovXG52YXIgc3RlcCA9IGZ1bmN0aW9uIHN0ZXAobGF5b3V0SW5mbywgb3B0aW9ucywgX3N0ZXApIHtcbiAgLy8gdmFyIHMgPSBcIlxcblxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcIjtcbiAgLy8gcyArPSBcIlxcblNURVA6IFwiICsgc3RlcDtcbiAgLy8gcyArPSBcIlxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcXG5cIjtcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgLy8gQ2FsY3VsYXRlIG5vZGUgcmVwdWxzaW9uc1xuICBjYWxjdWxhdGVOb2RlRm9yY2VzKGxheW91dEluZm8sIG9wdGlvbnMpO1xuICAvLyBDYWxjdWxhdGUgZWRnZSBmb3JjZXNcbiAgY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvKTtcbiAgLy8gQ2FsY3VsYXRlIGdyYXZpdHkgZm9yY2VzXG4gIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucyk7XG4gIC8vIFByb3BhZ2F0ZSBmb3JjZXMgZnJvbSBwYXJlbnQgdG8gY2hpbGRcbiAgcHJvcGFnYXRlRm9yY2VzKGxheW91dEluZm8pO1xuICAvLyBVcGRhdGUgcG9zaXRpb25zIGJhc2VkIG9uIGNhbGN1bGF0ZWQgZm9yY2VzXG4gIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvKTtcbn07XG5cbi8qKlxuICogQGJyaWVmIDogQ29tcHV0ZXMgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlc1xuICovXG52YXIgY2FsY3VsYXRlTm9kZUZvcmNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZU5vZGVGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICAvLyBHbyB0aHJvdWdoIGVhY2ggb2YgdGhlIGdyYXBocyBpbiBncmFwaFNldFxuICAvLyBOb2RlcyBvbmx5IHJlcGVsIGVhY2ggb3RoZXIgaWYgdGhleSBiZWxvbmcgdG8gdGhlIHNhbWUgZ3JhcGhcbiAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlTm9kZUZvcmNlcyc7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDtcblxuICAgIC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gTm93IGdldCBhbGwgdGhlIHBhaXJzIG9mIG5vZGVzXG4gICAgLy8gT25seSBnZXQgZWFjaCBwYWlyIG9uY2UsIChBLCBCKSA9IChCLCBBKVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgdmFyIG5vZGUxID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtqXV1dO1xuICAgICAgZm9yICh2YXIgayA9IGogKyAxOyBrIDwgbnVtTm9kZXM7IGsrKykge1xuICAgICAgICB2YXIgbm9kZTIgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2tdXV07XG4gICAgICAgIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgcmFuZG9tRGlzdGFuY2UgPSBmdW5jdGlvbiByYW5kb21EaXN0YW5jZShtYXgpIHtcbiAgcmV0dXJuIC0xICsgMiAqIG1heCAqIE1hdGgucmFuZG9tKCk7XG59O1xuXG4vKipcbiAqIEBicmllZiA6IENvbXB1dGUgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGEgcGFpciBvZiBub2Rlc1xuICovXG52YXIgbm9kZVJlcHVsc2lvbiA9IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcblxuICB2YXIgY21wdElkMSA9IG5vZGUxLmNtcHRJZDtcbiAgdmFyIGNtcHRJZDIgPSBub2RlMi5jbXB0SWQ7XG4gIGlmIChjbXB0SWQxICE9PSBjbXB0SWQyICYmICFsYXlvdXRJbmZvLmlzQ29tcG91bmQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICB2YXIgZGlyZWN0aW9uWCA9IG5vZGUyLnBvc2l0aW9uWCAtIG5vZGUxLnBvc2l0aW9uWDtcbiAgdmFyIGRpcmVjdGlvblkgPSBub2RlMi5wb3NpdGlvblkgLSBub2RlMS5wb3NpdGlvblk7XG4gIHZhciBtYXhSYW5kRGlzdCA9IDE7XG4gIC8vIHMgKz0gXCJcXG5kaXJlY3Rpb25YOiBcIiArIGRpcmVjdGlvblggKyBcIiwgZGlyZWN0aW9uWTogXCIgKyBkaXJlY3Rpb25ZO1xuXG4gIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGFwcGx5IGEgcmFuZG9tIGZvcmNlXG4gIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICBkaXJlY3Rpb25YID0gcmFuZG9tRGlzdGFuY2UobWF4UmFuZERpc3QpO1xuICAgIGRpcmVjdGlvblkgPSByYW5kb21EaXN0YW5jZShtYXhSYW5kRGlzdCk7XG4gIH1cbiAgdmFyIG92ZXJsYXAgPSBub2Rlc092ZXJsYXAobm9kZTEsIG5vZGUyLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgaWYgKG92ZXJsYXAgPiAwKSB7XG4gICAgLy8gcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgLy8gcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAvLyBJZiBub2RlcyBvdmVybGFwLCByZXB1bHNpb24gZm9yY2UgaXMgcHJvcG9ydGlvbmFsXG4gICAgLy8gdG8gdGhlIG92ZXJsYXBcbiAgICB2YXIgZm9yY2UgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpcmVjdGlvblggKiBkaXJlY3Rpb25YICsgZGlyZWN0aW9uWSAqIGRpcmVjdGlvblkpO1xuICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcbiAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBkaXJlY3Rpb25YIC8gZGlzdGFuY2U7XG4gICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlyZWN0aW9uWSAvIGRpc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBkbyBOT1Qgb3ZlcmxhcC5cIjtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIG92ZXJsYXAsIGZvcmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWxcbiAgICAvLyB0byBzcXVhcmVkIGRpc3RhbmNlXG5cbiAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUxLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTIsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTtcblxuICAgIC8vIFVzZSBjbGlwcGluZyBwb2ludHMgdG8gY29tcHV0ZSBkaXN0YW5jZVxuICAgIHZhciBkaXN0YW5jZVggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgIHZhciBkaXN0YW5jZVkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgIHZhciBkaXN0YW5jZVNxciA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpO1xuICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcblxuICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgdmFyIGZvcmNlID0gKG5vZGUxLm5vZGVSZXB1bHNpb24gKyBub2RlMi5ub2RlUmVwdWxzaW9uKSAvIGRpc3RhbmNlU3FyO1xuICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuICB9XG5cbiAgLy8gQXBwbHkgZm9yY2VcbiAgaWYgKCFub2RlMS5pc0xvY2tlZCkge1xuICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgIG5vZGUxLm9mZnNldFkgLT0gZm9yY2VZO1xuICB9XG4gIGlmICghbm9kZTIuaXNMb2NrZWQpIHtcbiAgICBub2RlMi5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICBub2RlMi5vZmZzZXRZICs9IGZvcmNlWTtcbiAgfVxuXG4gIC8vIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICovXG52YXIgbm9kZXNPdmVybGFwID0gZnVuY3Rpb24gbm9kZXNPdmVybGFwKG5vZGUxLCBub2RlMiwgZFgsIGRZKSB7XG4gIGlmIChkWCA+IDApIHtcbiAgICB2YXIgb3ZlcmxhcFggPSBub2RlMS5tYXhYIC0gbm9kZTIubWluWDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3ZlcmxhcFggPSBub2RlMi5tYXhYIC0gbm9kZTEubWluWDtcbiAgfVxuICBpZiAoZFkgPiAwKSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gIH1cbiAgaWYgKG92ZXJsYXBYID49IDAgJiYgb3ZlcmxhcFkgPj0gMCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQob3ZlcmxhcFggKiBvdmVybGFwWCArIG92ZXJsYXBZICogb3ZlcmxhcFkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBicmllZiA6IEZpbmRzIHRoZSBwb2ludCBpbiB3aGljaCBhbiBlZGdlIChkaXJlY3Rpb24gZFgsIGRZKSBpbnRlcnNlY3RzXG4gKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlXG4gKi9cbnZhciBmaW5kQ2xpcHBpbmdQb2ludCA9IGZ1bmN0aW9uIGZpbmRDbGlwcGluZ1BvaW50KG5vZGUsIGRYLCBkWSkge1xuICAvLyBTaG9yY3V0c1xuICB2YXIgWCA9IG5vZGUucG9zaXRpb25YO1xuICB2YXIgWSA9IG5vZGUucG9zaXRpb25ZO1xuICB2YXIgSCA9IG5vZGUuaGVpZ2h0IHx8IDE7XG4gIHZhciBXID0gbm9kZS53aWR0aCB8fCAxO1xuICB2YXIgZGlyU2xvcGUgPSBkWSAvIGRYO1xuICB2YXIgbm9kZVNsb3BlID0gSCAvIFc7XG5cbiAgLy8gdmFyIHMgPSAnQ29tcHV0aW5nIGNsaXBwaW5nIHBvaW50IG9mIG5vZGUgJyArIG5vZGUuaWQgK1xuICAvLyAgIFwiIC4gSGVpZ2h0OiAgXCIgKyBIICsgXCIsIFdpZHRoOiBcIiArIFcgK1xuICAvLyAgIFwiXFxuRGlyZWN0aW9uIFwiICsgZFggKyBcIiwgXCIgKyBkWTtcbiAgLy9cbiAgLy8gQ29tcHV0ZSBpbnRlcnNlY3Rpb25cbiAgdmFyIHJlcyA9IHt9O1xuXG4gIC8vIENhc2U6IFZlcnRpY2FsIGRpcmVjdGlvbiAodXApXG4gIGlmICgwID09PSBkWCAmJiAwIDwgZFkpIHtcbiAgICByZXMueCA9IFg7XG4gICAgLy8gcyArPSBcIlxcblVwIGRpcmVjdGlvblwiO1xuICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKGRvd24pXG4gIGlmICgwID09PSBkWCAmJiAwID4gZFkpIHtcbiAgICByZXMueCA9IFg7XG4gICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgLy8gcyArPSBcIlxcbkRvd24gZGlyZWN0aW9uXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgcmlnaHQgYm9yZGVyXG4gIGlmICgwIDwgZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgcmVzLnkgPSBZICsgVyAqIGRZIC8gMiAvIGRYO1xuICAgIC8vIHMgKz0gXCJcXG5SaWdodGJvcmRlclwiO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGxlZnQgYm9yZGVyXG4gIGlmICgwID4gZFggJiYgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgcmVzLnkgPSBZIC0gVyAqIGRZIC8gMiAvIGRYO1xuICAgIC8vIHMgKz0gXCJcXG5MZWZ0Ym9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgdG9wIGJvcmRlclxuICBpZiAoMCA8IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYICsgSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgIC8vIHMgKz0gXCJcXG5Ub3AgYm9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgYm90dG9tIGJvcmRlclxuICBpZiAoMCA+IGRZICYmIChkaXJTbG9wZSA8PSAtMSAqIG5vZGVTbG9wZSB8fCBkaXJTbG9wZSA+PSBub2RlU2xvcGUpKSB7XG4gICAgcmVzLnggPSBYIC0gSCAqIGRYIC8gMiAvIGRZO1xuICAgIHJlcy55ID0gWSAtIEggLyAyO1xuICAgIC8vIHMgKz0gXCJcXG5Cb3R0b20gYm9yZGVyXCI7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLy8gcyArPSBcIlxcbkNsaXBwaW5nIHBvaW50IGZvdW5kIGF0IFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueTtcbiAgLy8gbG9nRGVidWcocyk7XG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIEBicmllZiA6IENhbGN1bGF0ZXMgYWxsIGVkZ2UgZm9yY2VzXG4gKi9cbnZhciBjYWxjdWxhdGVFZGdlRm9yY2VzID0gZnVuY3Rpb24gY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICAvLyBHZXQgZWRnZSwgc291cmNlICYgdGFyZ2V0IG5vZGVzXG4gICAgdmFyIGVkZ2UgPSBsYXlvdXRJbmZvLmxheW91dEVkZ2VzW2ldO1xuICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2Uuc291cmNlSWRdO1xuICAgIHZhciBzb3VyY2UgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnRhcmdldElkXTtcbiAgICB2YXIgdGFyZ2V0ID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG5cbiAgICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgdmFyIGRpcmVjdGlvblkgPSB0YXJnZXQucG9zaXRpb25ZIC0gc291cmNlLnBvc2l0aW9uWTtcblxuICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcuXG4gICAgLy8gQSByYW5kb20gZm9yY2UgaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIGFzIG5vZGUgcmVwdWxzaW9uXG4gICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChzb3VyY2UsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludCh0YXJnZXQsIC0xICogZGlyZWN0aW9uWCwgLTEgKiBkaXJlY3Rpb25ZKTtcbiAgICB2YXIgbHggPSBwb2ludDIueCAtIHBvaW50MS54O1xuICAgIHZhciBseSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQobHggKiBseCArIGx5ICogbHkpO1xuICAgIHZhciBmb3JjZSA9IE1hdGgucG93KGVkZ2UuaWRlYWxMZW5ndGggLSBsLCAyKSAvIGVkZ2UuZWxhc3RpY2l0eTtcbiAgICBpZiAoMCAhPT0gbCkge1xuICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogbHggLyBsO1xuICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZm9yY2VYID0gMDtcbiAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGlzIGZvcmNlIHRvIHRhcmdldCBhbmQgc291cmNlIG5vZGVzXG4gICAgaWYgKCFzb3VyY2UuaXNMb2NrZWQpIHtcbiAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICB9XG4gICAgaWYgKCF0YXJnZXQuaXNMb2NrZWQpIHtcbiAgICAgIHRhcmdldC5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgIHRhcmdldC5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICB9XG5cbiAgICAvLyB2YXIgcyA9ICdFZGdlIGZvcmNlIGJldHdlZW4gbm9kZXMgJyArIHNvdXJjZS5pZCArICcgYW5kICcgKyB0YXJnZXQuaWQ7XG4gICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGwgKyBcIiBGb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmIDogQ29tcHV0ZXMgZ3Jhdml0eSBmb3JjZXMgZm9yIGFsbCBub2Rlc1xuICovXG52YXIgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMobGF5b3V0SW5mbywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5ncmF2aXR5ID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBkaXN0VGhyZXNob2xkID0gMTtcblxuICAvLyB2YXIgcyA9ICdjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzJztcbiAgLy8gbG9nRGVidWcocyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBncmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuICAgIGlmICgwID09PSBpKSB7XG4gICAgICB2YXIgY2VudGVyWCA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgIHZhciBjZW50ZXJZID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEdldCBQYXJlbnQgbm9kZSBmb3IgdGhpcyBncmFwaCwgYW5kIHVzZSBpdHMgcG9zaXRpb24gYXMgY2VudGVyXG4gICAgICB2YXIgdGVtcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbMF1dXTtcbiAgICAgIHZhciBwYXJlbnQgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXAucGFyZW50SWRdXTtcbiAgICAgIHZhciBjZW50ZXJYID0gcGFyZW50LnBvc2l0aW9uWDtcbiAgICAgIHZhciBjZW50ZXJZID0gcGFyZW50LnBvc2l0aW9uWTtcbiAgICB9XG4gICAgLy8gcyA9IFwiQ2VudGVyIGZvdW5kIGF0OiBcIiArIGNlbnRlclggKyBcIiwgXCIgKyBjZW50ZXJZO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gQXBwbHkgZm9yY2UgdG8gYWxsIG5vZGVzIGluIGdyYXBoXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbm9kZS5pZDtcblxuICAgICAgaWYgKG5vZGUuaXNMb2NrZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgZHggPSBjZW50ZXJYIC0gbm9kZS5wb3NpdGlvblg7XG4gICAgICB2YXIgZHkgPSBjZW50ZXJZIC0gbm9kZS5wb3NpdGlvblk7XG4gICAgICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBpZiAoZCA+IGRpc3RUaHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIGZ4ID0gb3B0aW9ucy5ncmF2aXR5ICogZHggLyBkO1xuICAgICAgICB2YXIgZnkgPSBvcHRpb25zLmdyYXZpdHkgKiBkeSAvIGQ7XG4gICAgICAgIG5vZGUub2Zmc2V0WCArPSBmeDtcbiAgICAgICAgbm9kZS5vZmZzZXRZICs9IGZ5O1xuICAgICAgICAvLyBzICs9IFwiOiBBcHBsaWVkIGZvcmNlOiBcIiArIGZ4ICsgXCIsIFwiICsgZnk7XG4gICAgICB9XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQGJyaWVmICAgICAgICAgIDogVGhpcyBmdW5jdGlvbiBwcm9wYWdhdGVzIHRoZSBleGlzdGluZyBvZmZzZXRzIGZyb21cbiAqICAgICAgICAgICAgICAgICAgIHBhcmVudCBub2RlcyB0byBpdHMgZGVzY2VuZGVudHMuXG4gKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIE9iamVjdFxuICogQGFyZyBjeSAgICAgICAgIDogY3l0b3NjYXBlIE9iamVjdFxuICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAqL1xudmFyIHByb3BhZ2F0ZUZvcmNlcyA9IGZ1bmN0aW9uIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvLCBvcHRpb25zKSB7XG4gIC8vIElubGluZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHF1ZXVlLCB1c2VkIGZvciB0cmF2ZXJzaW5nIHRoZSBncmFwaCBpbiBCRlMgb3JkZXJcbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBzdGFydCA9IDA7IC8vIFBvaW50cyB0byB0aGUgc3RhcnQgdGhlIHF1ZXVlXG4gIHZhciBlbmQgPSAtMTsgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgLy8gbG9nRGVidWcoJ3Byb3BhZ2F0ZUZvcmNlcycpO1xuXG4gIC8vIFN0YXJ0IGJ5IHZpc2l0aW5nIHRoZSBub2RlcyBpbiB0aGUgcm9vdCBncmFwaFxuICBxdWV1ZS5wdXNoLmFwcGx5KHF1ZXVlLCBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdKTtcbiAgZW5kICs9IGxheW91dEluZm8uZ3JhcGhTZXRbMF0ubGVuZ3RoO1xuXG4gIC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsXG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgdmFyIG5vZGVJZCA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgIHZhciBub2RlSW5kZXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgIHZhciBub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSW5kZXhdO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgbm9kZSBpZiBpdCdzIGNvbXBvdW5kXG4gICAgaWYgKDAgPCBjaGlsZHJlbi5sZW5ndGggJiYgIW5vZGUuaXNMb2NrZWQpIHtcbiAgICAgIHZhciBvZmZYID0gbm9kZS5vZmZzZXRYO1xuICAgICAgdmFyIG9mZlkgPSBub2RlLm9mZnNldFk7XG5cbiAgICAgIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBvZmZzZXQgZnJvbSBwYXJlbnQgbm9kZSA6IFwiICsgbm9kZS5pZCArXG4gICAgICAvLyAgIFwiLiBPZmZzZXRYOiBcIiArIG9mZlggKyBcIi4gT2Zmc2V0WTogXCIgKyBvZmZZO1xuICAgICAgLy8gcyArPSBcIlxcbiBDaGlsZHJlbjogXCIgKyBjaGlsZHJlbi50b1N0cmluZygpO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5baV1dXTtcbiAgICAgICAgLy8gUHJvcGFnYXRlIG9mZnNldFxuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WCArPSBvZmZYO1xuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WSArPSBvZmZZO1xuICAgICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzZXQgcGFyZW50IG9mZnNldHNcbiAgICAgIG5vZGUub2Zmc2V0WCA9IDA7XG4gICAgICBub2RlLm9mZnNldFkgPSAwO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBVcGRhdGVzIHRoZSBsYXlvdXQgbW9kZWwgcG9zaXRpb25zLCBiYXNlZCBvblxuICogICAgICAgICAgdGhlIGFjY3VtdWxhdGVkIGZvcmNlc1xuICovXG52YXIgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24gdXBkYXRlUG9zaXRpb25zKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgLy8gdmFyIHMgPSAnVXBkYXRpbmcgcG9zaXRpb25zJztcbiAgLy8gbG9nRGVidWcocyk7XG5cbiAgLy8gUmVzZXQgYm91bmRhcmllcyBmb3IgY29tcG91bmQgbm9kZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gbG9nRGVidWcoXCJSZXNldHRpbmcgYm91bmRhcmllcyBvZiBjb21wb3VuZCBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgbi5tYXhYID0gdW5kZWZpbmVkO1xuICAgICAgbi5taW5YID0gdW5kZWZpbmVkO1xuICAgICAgbi5tYXhZID0gdW5kZWZpbmVkO1xuICAgICAgbi5taW5ZID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoIHx8IG4uaXNMb2NrZWQpIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGNvbXBvdW5kIG9yIGxvY2tlZCBub2RlIHBvc2l0aW9uXG4gICAgICAvLyBsb2dEZWJ1ZyhcIlNraXBwaW5nIHBvc2l0aW9uIHVwZGF0ZSBvZiBub2RlOiBcIiArIG4uaWQpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbi5pZCArIFwiIFByZXZpb3VzIHBvc2l0aW9uOiAoXCIgK1xuICAgIC8vIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG5cbiAgICAvLyBMaW1pdCBkaXNwbGFjZW1lbnQgaW4gb3JkZXIgdG8gaW1wcm92ZSBzdGFiaWxpdHlcbiAgICB2YXIgdGVtcEZvcmNlID0gbGltaXRGb3JjZShuLm9mZnNldFgsIG4ub2Zmc2V0WSwgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG4gICAgbi5wb3NpdGlvblggKz0gdGVtcEZvcmNlLng7XG4gICAgbi5wb3NpdGlvblkgKz0gdGVtcEZvcmNlLnk7XG4gICAgbi5vZmZzZXRYID0gMDtcbiAgICBuLm9mZnNldFkgPSAwO1xuICAgIG4ubWluWCA9IG4ucG9zaXRpb25YIC0gbi53aWR0aDtcbiAgICBuLm1heFggPSBuLnBvc2l0aW9uWCArIG4ud2lkdGg7XG4gICAgbi5taW5ZID0gbi5wb3NpdGlvblkgLSBuLmhlaWdodDtcbiAgICBuLm1heFkgPSBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0O1xuICAgIC8vIHMgKz0gXCIgTmV3IFBvc2l0aW9uOiAoXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gVXBkYXRlIGFuY2VzdHJ5IGJvdWRhcmllc1xuICAgIF91cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMobiwgbGF5b3V0SW5mbyk7XG4gIH1cblxuICAvLyBVcGRhdGUgc2l6ZSwgcG9zaXRpb24gb2YgY29tcHVuZCBub2Rlc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoICYmICFuLmlzTG9ja2VkKSB7XG4gICAgICBuLnBvc2l0aW9uWCA9IChuLm1heFggKyBuLm1pblgpIC8gMjtcbiAgICAgIG4ucG9zaXRpb25ZID0gKG4ubWF4WSArIG4ubWluWSkgLyAyO1xuICAgICAgbi53aWR0aCA9IG4ubWF4WCAtIG4ubWluWDtcbiAgICAgIG4uaGVpZ2h0ID0gbi5tYXhZIC0gbi5taW5ZO1xuICAgICAgLy8gcyA9IFwiVXBkYXRpbmcgcG9zaXRpb24sIHNpemUgb2YgY29tcG91bmQgbm9kZSBcIiArIG4uaWQ7XG4gICAgICAvLyBzICs9IFwiXFxuUG9zaXRpb25YOiBcIiArIG4ucG9zaXRpb25YICsgXCIsIFBvc2l0aW9uWTogXCIgKyBuLnBvc2l0aW9uWTtcbiAgICAgIC8vIHMgKz0gXCJcXG5XaWR0aDogXCIgKyBuLndpZHRoICsgXCIsIEhlaWdodDogXCIgKyBuLmhlaWdodDtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAYnJpZWYgOiBMaW1pdHMgYSBmb3JjZSAoZm9yY2VYLCBmb3JjZVkpIHRvIGJlIG5vdFxuICogICAgICAgICAgZ3JlYXRlciAoaW4gbW9kdWxvKSB0aGFuIG1heC5cbiA4ICAgICAgICAgIFByZXNlcnZlcyBmb3JjZSBkaXJlY3Rpb24uXG4gICovXG52YXIgbGltaXRGb3JjZSA9IGZ1bmN0aW9uIGxpbWl0Rm9yY2UoZm9yY2VYLCBmb3JjZVksIG1heCkge1xuICAvLyB2YXIgcyA9IFwiTGltaXRpbmcgZm9yY2U6IChcIiArIGZvcmNlWCArIFwiLCBcIiArIGZvcmNlWSArIFwiKS4gTWF4OiBcIiArIG1heDtcbiAgdmFyIGZvcmNlID0gTWF0aC5zcXJ0KGZvcmNlWCAqIGZvcmNlWCArIGZvcmNlWSAqIGZvcmNlWSk7XG4gIGlmIChmb3JjZSA+IG1heCkge1xuICAgIHZhciByZXMgPSB7XG4gICAgICB4OiBtYXggKiBmb3JjZVggLyBmb3JjZSxcbiAgICAgIHk6IG1heCAqIGZvcmNlWSAvIGZvcmNlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgeDogZm9yY2VYLFxuICAgICAgeTogZm9yY2VZXG4gICAgfTtcbiAgfVxuXG4gIC8vIHMgKz0gXCIuXFxuUmVzdWx0OiAoXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55ICsgXCIpXCI7XG4gIC8vIGxvZ0RlYnVnKHMpO1xuXG4gIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIEBicmllZiA6IEZ1bmN0aW9uIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgY29tcG91bmQgbm9kZVxuICogICAgICAgICAgc2l6ZXMsIHNpbmNlIHRoZXkgc2hvdWxkIGJvdW5kIGFsbCB0aGVpciBzdWJub2Rlcy5cbiAqL1xudmFyIF91cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMgPSBmdW5jdGlvbiB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMobm9kZSwgbGF5b3V0SW5mbykge1xuICAvLyB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgbmV3IHBvc2l0aW9uL3NpemUgb2Ygbm9kZSBcIiArIG5vZGUuaWQ7XG4gIHZhciBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG4gIGlmIChudWxsID09IHBhcmVudElkKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlIGFyZSBkb25lXG4gICAgLy8gcyArPSBcIi4gTm8gcGFyZW50IG5vZGUuXCI7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gR2V0IFBhcmVudCBOb2RlXG4gIHZhciBwID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwYXJlbnRJZF1dO1xuICB2YXIgZmxhZyA9IGZhbHNlO1xuXG4gIC8vIE1heFhcbiAgaWYgKG51bGwgPT0gcC5tYXhYIHx8IG5vZGUubWF4WCArIHAucGFkUmlnaHQgPiBwLm1heFgpIHtcbiAgICBwLm1heFggPSBub2RlLm1heFggKyBwLnBhZFJpZ2h0O1xuICAgIGZsYWcgPSB0cnVlO1xuICAgIC8vIHMgKz0gXCJcXG5OZXcgbWF4WCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhYO1xuICB9XG5cbiAgLy8gTWluWFxuICBpZiAobnVsbCA9PSBwLm1pblggfHwgbm9kZS5taW5YIC0gcC5wYWRMZWZ0IDwgcC5taW5YKSB7XG4gICAgcC5taW5YID0gbm9kZS5taW5YIC0gcC5wYWRMZWZ0O1xuICAgIGZsYWcgPSB0cnVlO1xuICAgIC8vIHMgKz0gXCJcXG5OZXcgbWluWCBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5YO1xuICB9XG5cbiAgLy8gTWF4WVxuICBpZiAobnVsbCA9PSBwLm1heFkgfHwgbm9kZS5tYXhZICsgcC5wYWRCb3R0b20gPiBwLm1heFkpIHtcbiAgICBwLm1heFkgPSBub2RlLm1heFkgKyBwLnBhZEJvdHRvbTtcbiAgICBmbGFnID0gdHJ1ZTtcbiAgICAvLyBzICs9IFwiXFxuTmV3IG1heFkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WTtcbiAgfVxuXG4gIC8vIE1pbllcbiAgaWYgKG51bGwgPT0gcC5taW5ZIHx8IG5vZGUubWluWSAtIHAucGFkVG9wIDwgcC5taW5ZKSB7XG4gICAgcC5taW5ZID0gbm9kZS5taW5ZIC0gcC5wYWRUb3A7XG4gICAgZmxhZyA9IHRydWU7XG4gICAgLy8gcyArPSBcIlxcbk5ldyBtaW5ZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblk7XG4gIH1cblxuICAvLyBJZiB1cGRhdGVkIGJvdW5kYXJpZXMsIHByb3BhZ2F0ZSBjaGFuZ2VzIHVwd2FyZFxuICBpZiAoZmxhZykge1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIHJldHVybiBfdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKHAsIGxheW91dEluZm8pO1xuICB9XG5cbiAgLy8gcyArPSBcIi4gTm8gY2hhbmdlcyBpbiBib3VuZGFyaWVzL3Bvc2l0aW9uIG9mIHBhcmVudCBub2RlIFwiICsgcC5pZDtcbiAgLy8gbG9nRGVidWcocyk7XG4gIHJldHVybjtcbn07XG52YXIgc2VwYXJhdGVDb21wb25lbnRzID0gZnVuY3Rpb24gc2VwYXJhdGVDb21wb25lbnRzKGxheW91dEluZm8sIG9wdGlvbnMpIHtcbiAgdmFyIG5vZGVzID0gbGF5b3V0SW5mby5sYXlvdXROb2RlcztcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgdmFyIGNpZCA9IG5vZGUuY21wdElkO1xuICAgIHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW2NpZF0gPSBjb21wb25lbnRzW2NpZF0gfHwgW107XG4gICAgY29tcG9uZW50LnB1c2gobm9kZSk7XG4gIH1cbiAgdmFyIHRvdGFsQSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcbiAgICBpZiAoIWMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjLngxID0gSW5maW5pdHk7XG4gICAgYy54MiA9IC1JbmZpbml0eTtcbiAgICBjLnkxID0gSW5maW5pdHk7XG4gICAgYy55MiA9IC1JbmZpbml0eTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBuID0gY1tqXTtcbiAgICAgIGMueDEgPSBNYXRoLm1pbihjLngxLCBuLnBvc2l0aW9uWCAtIG4ud2lkdGggLyAyKTtcbiAgICAgIGMueDIgPSBNYXRoLm1heChjLngyLCBuLnBvc2l0aW9uWCArIG4ud2lkdGggLyAyKTtcbiAgICAgIGMueTEgPSBNYXRoLm1pbihjLnkxLCBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0IC8gMik7XG4gICAgICBjLnkyID0gTWF0aC5tYXgoYy55Miwgbi5wb3NpdGlvblkgKyBuLmhlaWdodCAvIDIpO1xuICAgIH1cbiAgICBjLncgPSBjLngyIC0gYy54MTtcbiAgICBjLmggPSBjLnkyIC0gYy55MTtcbiAgICB0b3RhbEEgKz0gYy53ICogYy5oO1xuICB9XG4gIGNvbXBvbmVudHMuc29ydChmdW5jdGlvbiAoYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMyLncgKiBjMi5oIC0gYzEudyAqIGMxLmg7XG4gIH0pO1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIHVzZWRXID0gMDtcbiAgdmFyIHJvd0ggPSAwO1xuICB2YXIgbWF4Um93VyA9IE1hdGguc3FydCh0b3RhbEEpICogbGF5b3V0SW5mby5jbGllbnRXaWR0aCAvIGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG4gICAgaWYgKCFjKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbiA9IGNbal07XG4gICAgICBpZiAoIW4uaXNMb2NrZWQpIHtcbiAgICAgICAgbi5wb3NpdGlvblggKz0geCAtIGMueDE7XG4gICAgICAgIG4ucG9zaXRpb25ZICs9IHkgLSBjLnkxO1xuICAgICAgfVxuICAgIH1cbiAgICB4ICs9IGMudyArIG9wdGlvbnMuY29tcG9uZW50U3BhY2luZztcbiAgICB1c2VkVyArPSBjLncgKyBvcHRpb25zLmNvbXBvbmVudFNwYWNpbmc7XG4gICAgcm93SCA9IE1hdGgubWF4KHJvd0gsIGMuaCk7XG4gICAgaWYgKHVzZWRXID4gbWF4Um93Vykge1xuICAgICAgeSArPSByb3dIICsgb3B0aW9ucy5jb21wb25lbnRTcGFjaW5nO1xuICAgICAgeCA9IDA7XG4gICAgICB1c2VkVyA9IDA7XG4gICAgICByb3dIID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0cyQzID0ge1xuICBmaXQ6IHRydWUsXG4gIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgdXNlZCBvbiBmaXRcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGF2b2lkT3ZlcmxhcDogdHJ1ZSxcbiAgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICBhdm9pZE92ZXJsYXBQYWRkaW5nOiAxMCxcbiAgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXMgd2hlbiBhdm9pZE92ZXJsYXA6IHRydWVcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gRXhjbHVkZXMgdGhlIGxhYmVsIHdoZW4gY2FsY3VsYXRpbmcgbm9kZSBib3VuZGluZyBib3hlcyBmb3IgdGhlIGxheW91dCBhbGdvcml0aG1cbiAgc3BhY2luZ0ZhY3RvcjogdW5kZWZpbmVkLFxuICAvLyBBcHBsaWVzIGEgbXVsdGlwbGljYXRpdmUgZmFjdG9yICg+MCkgdG8gZXhwYW5kIG9yIGNvbXByZXNzIHRoZSBvdmVyYWxsIGFyZWEgdGhhdCB0aGUgbm9kZXMgdGFrZSB1cFxuICBjb25kZW5zZTogZmFsc2UsXG4gIC8vIHVzZXMgYWxsIGF2YWlsYWJsZSBzcGFjZSBvbiBmYWxzZSwgdXNlcyBtaW5pbWFsIHNwYWNlIG9uIHRydWVcbiAgcm93czogdW5kZWZpbmVkLFxuICAvLyBmb3JjZSBudW0gb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICBjb2xzOiB1bmRlZmluZWQsXG4gIC8vIGZvcmNlIG51bSBvZiBjb2x1bW5zIGluIHRoZSBncmlkXG4gIHBvc2l0aW9uOiBmdW5jdGlvbiBwb3NpdGlvbihub2RlKSB7fSxcbiAgLy8gcmV0dXJucyB7IHJvdywgY29sIH0gZm9yIGVsZW1lbnRcbiAgc29ydDogdW5kZWZpbmVkLFxuICAvLyBhIHNvcnRpbmcgZnVuY3Rpb24gdG8gb3JkZXIgdGhlIG5vZGVzOyBlLmcuIGZ1bmN0aW9uKGEsIGIpeyByZXR1cm4gYS5kYXRhKCd3ZWlnaHQnKSAtIGIuZGF0YSgnd2VpZ2h0JykgfVxuICBhbmltYXRlOiBmYWxzZSxcbiAgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxuICAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gZWFzaW5nIG9mIGFuaW1hdGlvbiBpZiBlbmFibGVkXG4gIGFuaW1hdGVGaWx0ZXI6IGZ1bmN0aW9uIGFuaW1hdGVGaWx0ZXIobm9kZSwgaSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICAvLyBhIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBiZSBhbmltYXRlZC4gIEFsbCBub2RlcyBhbmltYXRlZCBieSBkZWZhdWx0IG9uIGFuaW1hdGUgZW5hYmxlZC4gIE5vbi1hbmltYXRlZCBub2RlcyBhcmUgcG9zaXRpb25lZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBsYXlvdXQgc3RhcnRzXG4gIHJlYWR5OiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIHRyYW5zZm9ybShub2RlLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyB0cmFuc2Zvcm0gYSBnaXZlbiBub2RlIHBvc2l0aW9uLiBVc2VmdWwgZm9yIGNoYW5naW5nIGZsb3cgZGlyZWN0aW9uIGluIGRpc2NyZXRlIGxheW91dHMgXG59O1xuZnVuY3Rpb24gR3JpZExheW91dChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7fSwgZGVmYXVsdHMkMywgb3B0aW9ucyk7XG59XG5HcmlkTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gIGlmIChvcHRpb25zLnNvcnQpIHtcbiAgICBub2RlcyA9IG5vZGVzLnNvcnQob3B0aW9ucy5zb3J0KTtcbiAgfVxuICB2YXIgYmIgPSBtYWtlQm91bmRpbmdCb3gob3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgeDE6IDAsXG4gICAgeTE6IDAsXG4gICAgdzogY3kud2lkdGgoKSxcbiAgICBoOiBjeS5oZWlnaHQoKVxuICB9KTtcbiAgaWYgKGJiLmggPT09IDAgfHwgYmIudyA9PT0gMCkge1xuICAgIGVsZXMubm9kZXMoKS5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYmIueDEsXG4gICAgICAgIHk6IGJiLnkxXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIHdpZHRoL2hlaWdodCAqIHNwbGl0c14yID0gY2VsbHMgd2hlcmUgc3BsaXRzIGlzIG51bWJlciBvZiB0aW1lcyB0byBzcGxpdCB3aWR0aFxuICAgIHZhciBjZWxscyA9IG5vZGVzLnNpemUoKTtcbiAgICB2YXIgc3BsaXRzID0gTWF0aC5zcXJ0KGNlbGxzICogYmIuaCAvIGJiLncpO1xuICAgIHZhciByb3dzID0gTWF0aC5yb3VuZChzcGxpdHMpO1xuICAgIHZhciBjb2xzID0gTWF0aC5yb3VuZChiYi53IC8gYmIuaCAqIHNwbGl0cyk7XG4gICAgdmFyIHNtYWxsID0gZnVuY3Rpb24gc21hbGwodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICBpZiAobWluID09IHJvd3MpIHtcbiAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBsYXJnZSA9IGZ1bmN0aW9uIGxhcmdlKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChyb3dzLCBjb2xzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyb3dzLCBjb2xzKTtcbiAgICAgICAgaWYgKG1heCA9PSByb3dzKSB7XG4gICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb1Jvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgdmFyIG9Db2xzID0gb3B0aW9ucy5jb2xzICE9IG51bGwgPyBvcHRpb25zLmNvbHMgOiBvcHRpb25zLmNvbHVtbnM7XG5cbiAgICAvLyBpZiByb3dzIG9yIGNvbHVtbnMgd2VyZSBzZXQgaW4gb3B0aW9ucywgdXNlIHRob3NlIHZhbHVlc1xuICAgIGlmIChvUm93cyAhPSBudWxsICYmIG9Db2xzICE9IG51bGwpIHtcbiAgICAgIHJvd3MgPSBvUm93cztcbiAgICAgIGNvbHMgPSBvQ29scztcbiAgICB9IGVsc2UgaWYgKG9Sb3dzICE9IG51bGwgJiYgb0NvbHMgPT0gbnVsbCkge1xuICAgICAgcm93cyA9IG9Sb3dzO1xuICAgICAgY29scyA9IE1hdGguY2VpbChjZWxscyAvIHJvd3MpO1xuICAgIH0gZWxzZSBpZiAob1Jvd3MgPT0gbnVsbCAmJiBvQ29scyAhPSBudWxsKSB7XG4gICAgICBjb2xzID0gb0NvbHM7XG4gICAgICByb3dzID0gTWF0aC5jZWlsKGNlbGxzIC8gY29scyk7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgYXV0b21hdGljIHZhbHVlcyBhbmQgYWRqdXN0IGFjY29yZGluZ2x5XG5cbiAgICAvLyBpZiByb3VuZGluZyB3YXMgdXAsIHNlZSBpZiB3ZSBjYW4gcmVkdWNlIHJvd3Mgb3IgY29sdW1uc1xuICAgIGVsc2UgaWYgKGNvbHMgKiByb3dzID4gY2VsbHMpIHtcbiAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICB2YXIgbGcgPSBsYXJnZSgpO1xuXG4gICAgICAvLyByZWR1Y2luZyB0aGUgc21hbGwgc2lkZSB0YWtlcyBhd2F5IHRoZSBtb3N0IGNlbGxzLCBzbyB0cnkgaXQgZmlyc3RcbiAgICAgIGlmICgoc20gLSAxKSAqIGxnID49IGNlbGxzKSB7XG4gICAgICAgIHNtYWxsKHNtIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKChsZyAtIDEpICogc20gPj0gY2VsbHMpIHtcbiAgICAgICAgbGFyZ2UobGcgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHRvbyBsb3csIGFkZCByb3dzIG9yIGNvbHVtbnNcbiAgICAgIHdoaWxlIChjb2xzICogcm93cyA8IGNlbGxzKSB7XG4gICAgICAgIHZhciBfc20gPSBzbWFsbCgpO1xuICAgICAgICB2YXIgX2xnID0gbGFyZ2UoKTtcblxuICAgICAgICAvLyB0cnkgdG8gYWRkIHRvIGxhcmdlciBzaWRlIGZpcnN0IChhZGRzIGxlc3MgaW4gbXVsdGlwbGljYXRpb24pXG4gICAgICAgIGlmICgoX2xnICsgMSkgKiBfc20gPj0gY2VsbHMpIHtcbiAgICAgICAgICBsYXJnZShfbGcgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbWFsbChfc20gKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2VsbFdpZHRoID0gYmIudyAvIGNvbHM7XG4gICAgdmFyIGNlbGxIZWlnaHQgPSBiYi5oIC8gcm93cztcbiAgICBpZiAob3B0aW9ucy5jb25kZW5zZSkge1xuICAgICAgY2VsbFdpZHRoID0gMDtcbiAgICAgIGNlbGxIZWlnaHQgPSAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hdm9pZE92ZXJsYXApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIGlmIChwb3MueCA9PSBudWxsIHx8IHBvcy55ID09IG51bGwpIHtcbiAgICAgICAgICAvLyBmb3IgYmJcbiAgICAgICAgICBwb3MueCA9IDA7XG4gICAgICAgICAgcG9zLnkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYmIgPSBub2RlLmxheW91dERpbWVuc2lvbnMob3B0aW9ucyk7XG4gICAgICAgIHZhciBwID0gb3B0aW9ucy5hdm9pZE92ZXJsYXBQYWRkaW5nO1xuICAgICAgICB2YXIgdyA9IG5iYi53ICsgcDtcbiAgICAgICAgdmFyIGggPSBuYmIuaCArIHA7XG4gICAgICAgIGNlbGxXaWR0aCA9IE1hdGgubWF4KGNlbGxXaWR0aCwgdyk7XG4gICAgICAgIGNlbGxIZWlnaHQgPSBNYXRoLm1heChjZWxsSGVpZ2h0LCBoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG5cbiAgICB2YXIgdXNlZCA9IGZ1bmN0aW9uIHVzZWQocm93LCBjb2wpIHtcbiAgICAgIHJldHVybiBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA/IHRydWUgOiBmYWxzZTtcbiAgICB9O1xuICAgIHZhciB1c2UgPSBmdW5jdGlvbiB1c2Uocm93LCBjb2wpIHtcbiAgICAgIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gdG8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGNlbGwgcG9zaXRpb25cbiAgICB2YXIgcm93ID0gMDtcbiAgICB2YXIgY29sID0gMDtcbiAgICB2YXIgbW92ZVRvTmV4dENlbGwgPSBmdW5jdGlvbiBtb3ZlVG9OZXh0Q2VsbCgpIHtcbiAgICAgIGNvbCsrO1xuICAgICAgaWYgKGNvbCA+PSBjb2xzKSB7XG4gICAgICAgIGNvbCA9IDA7XG4gICAgICAgIHJvdysrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBnZXQgYSBjYWNoZSBvZiBhbGwgdGhlIG1hbnVhbCBwb3NpdGlvbnNcbiAgICB2YXIgaWQybWFuUG9zID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9ub2RlID0gbm9kZXNbX2ldO1xuICAgICAgdmFyIHJjUG9zID0gb3B0aW9ucy5wb3NpdGlvbihfbm9kZSk7XG4gICAgICBpZiAocmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICB2YXIgX3BvcyA9IHtcbiAgICAgICAgICByb3c6IHJjUG9zLnJvdyxcbiAgICAgICAgICBjb2w6IHJjUG9zLmNvbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoX3Bvcy5jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGZpbmQgdW51c2VkIGNvbFxuICAgICAgICAgIF9wb3MuY29sID0gMDtcbiAgICAgICAgICB3aGlsZSAodXNlZChfcG9zLnJvdywgX3Bvcy5jb2wpKSB7XG4gICAgICAgICAgICBfcG9zLmNvbCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChfcG9zLnJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gZmluZCB1bnVzZWQgcm93XG4gICAgICAgICAgX3Bvcy5yb3cgPSAwO1xuICAgICAgICAgIHdoaWxlICh1c2VkKF9wb3Mucm93LCBfcG9zLmNvbCkpIHtcbiAgICAgICAgICAgIF9wb3Mucm93Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlkMm1hblBvc1tfbm9kZS5pZCgpXSA9IF9wb3M7XG4gICAgICAgIHVzZShfcG9zLnJvdywgX3Bvcy5jb2wpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKGVsZW1lbnQsIGkpIHtcbiAgICAgIHZhciB4LCB5O1xuICAgICAgaWYgKGVsZW1lbnQubG9ja2VkKCkgfHwgZWxlbWVudC5pc1BhcmVudCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgYSBtYW51YWwgcG9zaXRpb24gc2V0XG4gICAgICB2YXIgcmNQb3MgPSBpZDJtYW5Qb3NbZWxlbWVudC5pZCgpXTtcbiAgICAgIGlmIChyY1Bvcykge1xuICAgICAgICB4ID0gcmNQb3MuY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJiLngxO1xuICAgICAgICB5ID0gcmNQb3Mucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmIueTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2Ugc2V0IGF1dG9tYXRpY2FsbHlcblxuICAgICAgICB3aGlsZSAodXNlZChyb3csIGNvbCkpIHtcbiAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHggPSBjb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmIueDE7XG4gICAgICAgIHkgPSByb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiYi55MTtcbiAgICAgICAgdXNlKHJvdywgY29sKTtcbiAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfTtcbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZ2V0UG9zKTtcbiAgfVxuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbnZhciBkZWZhdWx0cyQyID0ge1xuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSxcbiAgLy8gb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9IC8vIG9uIGxheW91dHN0b3Bcbn07XG5cbi8vIGNvbnN0cnVjdG9yXG4vLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbmZ1bmN0aW9uIE51bGxMYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzJDIsIG9wdGlvbnMpO1xufVxuXG4vLyBydW5zIHRoZSBsYXlvdXRcbk51bGxMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBlbGVtZW50cyB0byBjb25zaWRlciBpbiB0aGUgbGF5b3V0XG4gIHZhciBsYXlvdXQgPSB0aGlzO1xuXG4gIC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgLy8gKGRpc2FibGUgZXNsaW50IGZvciBuZXh0IGxpbmUgYXMgdGhpcyBzZXJ2ZXMgYXMgZXhhbXBsZSBsYXlvdXQgY29kZSB0byBleHRlcm5hbCBkZXZlbG9wZXJzKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgb3B0aW9ucy5jeTtcbiAgbGF5b3V0LmVtaXQoJ2xheW91dHN0YXJ0Jyk7XG5cbiAgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gIC8vIG4uYi4gbW9zdCBsYXlvdXRzIHdvdWxkIHVzZSBsYXlvdXRQb3NpdGlvbnMoKSwgaW5zdGVhZCBvZiBwb3NpdGlvbnMoKSBhbmQgbWFudWFsIGV2ZW50c1xuICBlbGVzLm5vZGVzKCkucG9zaXRpb25zKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9KTtcblxuICAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG4gIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gIGxheW91dC5lbWl0KCdsYXlvdXRyZWFkeScpO1xuXG4gIC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG4gIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICBsYXlvdXQuZW1pdCgnbGF5b3V0c3RvcCcpO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuTnVsbExheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuXG52YXIgZGVmYXVsdHMkMSA9IHtcbiAgcG9zaXRpb25zOiB1bmRlZmluZWQsXG4gIC8vIG1hcCBvZiAobm9kZSBpZCkgPT4gKHBvc2l0aW9uIG9iaik7IG9yIGZ1bmN0aW9uKG5vZGUpeyByZXR1cm4gc29tUG9zOyB9XG4gIHpvb206IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHpvb20gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICBwYW46IHVuZGVmaW5lZCxcbiAgLy8gdGhlIHBhbiBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gIGZpdDogdHJ1ZSxcbiAgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgcGFkZGluZzogMzAsXG4gIC8vIHBhZGRpbmcgb24gZml0XG4gIHNwYWNpbmdGYWN0b3I6IHVuZGVmaW5lZCxcbiAgLy8gQXBwbGllcyBhIG11bHRpcGxpY2F0aXZlIGZhY3RvciAoPjApIHRvIGV4cGFuZCBvciBjb21wcmVzcyB0aGUgb3ZlcmFsbCBhcmVhIHRoYXQgdGhlIG5vZGVzIHRha2UgdXBcbiAgYW5pbWF0ZTogZmFsc2UsXG4gIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCxcbiAgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIGVhc2luZyBvZiBhbmltYXRpb24gaWYgZW5hYmxlZFxuICBhbmltYXRlRmlsdGVyOiBmdW5jdGlvbiBhbmltYXRlRmlsdGVyKG5vZGUsIGkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgYmUgYW5pbWF0ZWQuICBBbGwgbm9kZXMgYW5pbWF0ZWQgYnkgZGVmYXVsdCBvbiBhbmltYXRlIGVuYWJsZWQuICBOb24tYW5pbWF0ZWQgbm9kZXMgYXJlIHBvc2l0aW9uZWQgaW1tZWRpYXRlbHkgd2hlbiB0aGUgbGF5b3V0IHN0YXJ0c1xuICByZWFkeTogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiB1bmRlZmluZWQsXG4gIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiB0cmFuc2Zvcm0obm9kZSwgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0gLy8gdHJhbnNmb3JtIGEgZ2l2ZW4gbm9kZSBwb3NpdGlvbi4gVXNlZnVsIGZvciBjaGFuZ2luZyBmbG93IGRpcmVjdGlvbiBpbiBkaXNjcmV0ZSBsYXlvdXRzXG59O1xuZnVuY3Rpb24gUHJlc2V0TGF5b3V0KG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gZXh0ZW5kKHt9LCBkZWZhdWx0cyQxLCBvcHRpb25zKTtcbn1cblByZXNldExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgdmFyIHBvc0lzRm4gPSBmbiQ2KG9wdGlvbnMucG9zaXRpb25zKTtcbiAgZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgIGlmIChvcHRpb25zLnBvc2l0aW9ucyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29weVBvc2l0aW9uKG5vZGUucG9zaXRpb24oKSk7XG4gICAgfVxuICAgIGlmIChwb3NJc0ZuKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5wb3NpdGlvbnMobm9kZSk7XG4gICAgfVxuICAgIHZhciBwb3MgPSBvcHRpb25zLnBvc2l0aW9uc1tub2RlLl9wcml2YXRlLmRhdGEuaWRdO1xuICAgIGlmIChwb3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24obm9kZSk7XG4gICAgaWYgKG5vZGUubG9ja2VkKCkgfHwgcG9zaXRpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH0pO1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgZml0OiB0cnVlLFxuICAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gZml0IHBhZGRpbmdcbiAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCxcbiAgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIGFuaW1hdGU6IGZhbHNlLFxuICAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXG4gIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBlYXNpbmcgb2YgYW5pbWF0aW9uIGlmIGVuYWJsZWRcbiAgYW5pbWF0ZUZpbHRlcjogZnVuY3Rpb24gYW5pbWF0ZUZpbHRlcihub2RlLCBpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIGEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5vZGUgc2hvdWxkIGJlIGFuaW1hdGVkLiAgQWxsIG5vZGVzIGFuaW1hdGVkIGJ5IGRlZmF1bHQgb24gYW5pbWF0ZSBlbmFibGVkLiAgTm9uLWFuaW1hdGVkIG5vZGVzIGFyZSBwb3NpdGlvbmVkIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGxheW91dCBzdGFydHNcbiAgcmVhZHk6IHVuZGVmaW5lZCxcbiAgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogdW5kZWZpbmVkLFxuICAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9IC8vIHRyYW5zZm9ybSBhIGdpdmVuIG5vZGUgcG9zaXRpb24uIFVzZWZ1bCBmb3IgY2hhbmdpbmcgZmxvdyBkaXJlY3Rpb24gaW4gZGlzY3JldGUgbGF5b3V0cyBcbn07XG5mdW5jdGlvbiBSYW5kb21MYXlvdXQob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn1cblJhbmRvbUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBiYiA9IG1ha2VCb3VuZGluZ0JveChvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICB4MTogMCxcbiAgICB5MTogMCxcbiAgICB3OiBjeS53aWR0aCgpLFxuICAgIGg6IGN5LmhlaWdodCgpXG4gIH0pO1xuICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24gZ2V0UG9zKG5vZGUsIGkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogYmIueDEgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBiYi53KSxcbiAgICAgIHk6IGJiLnkxICsgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogYmIuaClcbiAgICB9O1xuICB9O1xuICBlbGVzLm5vZGVzKCkubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGdldFBvcyk7XG4gIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xufTtcblxudmFyIGxheW91dCA9IFt7XG4gIG5hbWU6ICdicmVhZHRoZmlyc3QnLFxuICBpbXBsOiBCcmVhZHRoRmlyc3RMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2NpcmNsZScsXG4gIGltcGw6IENpcmNsZUxheW91dFxufSwge1xuICBuYW1lOiAnY29uY2VudHJpYycsXG4gIGltcGw6IENvbmNlbnRyaWNMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ2Nvc2UnLFxuICBpbXBsOiBDb3NlTGF5b3V0XG59LCB7XG4gIG5hbWU6ICdncmlkJyxcbiAgaW1wbDogR3JpZExheW91dFxufSwge1xuICBuYW1lOiAnbnVsbCcsXG4gIGltcGw6IE51bGxMYXlvdXRcbn0sIHtcbiAgbmFtZTogJ3ByZXNldCcsXG4gIGltcGw6IFByZXNldExheW91dFxufSwge1xuICBuYW1lOiAncmFuZG9tJyxcbiAgaW1wbDogUmFuZG9tTGF5b3V0XG59XTtcblxuZnVuY3Rpb24gTnVsbFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5ub3RpZmljYXRpb25zID0gMDsgLy8gZm9yIHRlc3Rpbmdcbn1cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xudmFyIHRocm93SW1nRXJyID0gZnVuY3Rpb24gdGhyb3dJbWdFcnIoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQSBoZWFkbGVzcyBpbnN0YW5jZSBjYW4gbm90IHJlbmRlciBpbWFnZXMnKTtcbn07XG5OdWxsUmVuZGVyZXIucHJvdG90eXBlID0ge1xuICByZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGU6IG5vb3AsXG4gIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgIHRoaXMubm90aWZpY2F0aW9ucysrO1xuICB9LFxuICBpbml0OiBub29wLFxuICBpc0hlYWRsZXNzOiBmdW5jdGlvbiBpc0hlYWRsZXNzKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBwbmc6IHRocm93SW1nRXJyLFxuICBqcGc6IHRocm93SW1nRXJyXG59O1xuXG52YXIgQlJwJGYgPSB7fTtcbkJScCRmLmFycm93U2hhcGVXaWR0aCA9IDAuMztcbkJScCRmLnJlZ2lzdGVyQXJyb3dTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJvd1NoYXBlcyA9IHRoaXMuYXJyb3dTaGFwZXMgPSB7fTtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuICAvLyBDb250cmFjdCBmb3IgYXJyb3cgc2hhcGVzOlxuICAvLyAwLCAwIGlzIGFycm93IHRpcFxuICAvLyAoMCwgMSkgaXMgZGlyZWN0aW9uIHRvd2FyZHMgbm9kZVxuICAvLyAoMSwgMCkgaXMgcmlnaHRcbiAgLy9cbiAgLy8gZnVuY3Rpb25hbCBhcGk6XG4gIC8vIGNvbGxpZGU6IGNoZWNrIHgsIHkgaW4gc2hhcGVcbiAgLy8gcm91Z2hDb2xsaWRlOiBjYWxsZWQgYmVmb3JlIGNvbGxpZGUsIG5vIGZhbHNlIG5lZ2F0aXZlc1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIHNwYWNpbmc6IGRpc3QoYXJyb3dUaXAsIG5vZGVCb3VuZGFyeSlcbiAgLy8gZ2FwOiBkaXN0KGVkZ2VUaXAsIG5vZGVCb3VuZGFyeSksIGVkZ2VUaXAgbWF5ICE9IGFycm93VGlwXG5cbiAgdmFyIGJiQ29sbGlkZSA9IGZ1bmN0aW9uIGJiQ29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgIHZhciB4MSA9IHRyYW5zbGF0aW9uLnggLSBzaXplIC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHgyID0gdHJhbnNsYXRpb24ueCArIHNpemUgLyAyICsgcGFkZGluZztcbiAgICB2YXIgeTEgPSB0cmFuc2xhdGlvbi55IC0gc2l6ZSAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciB5MiA9IHRyYW5zbGF0aW9uLnkgKyBzaXplIC8gMiArIHBhZGRpbmc7XG4gICAgdmFyIGluc2lkZSA9IHgxIDw9IHggJiYgeCA8PSB4MiAmJiB5MSA8PSB5ICYmIHkgPD0geTI7XG4gICAgcmV0dXJuIGluc2lkZTtcbiAgfTtcbiAgdmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICB2YXIgeFJvdGF0ZWQgPSB4ICogTWF0aC5jb3MoYW5nbGUpIC0geSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgeVJvdGF0ZWQgPSB4ICogTWF0aC5zaW4oYW5nbGUpICsgeSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICB2YXIgeFNjYWxlZCA9IHhSb3RhdGVkICogc2l6ZTtcbiAgICB2YXIgeVNjYWxlZCA9IHlSb3RhdGVkICogc2l6ZTtcbiAgICB2YXIgeFRyYW5zbGF0ZWQgPSB4U2NhbGVkICsgdHJhbnNsYXRpb24ueDtcbiAgICB2YXIgeVRyYW5zbGF0ZWQgPSB5U2NhbGVkICsgdHJhbnNsYXRpb24ueTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeFRyYW5zbGF0ZWQsXG4gICAgICB5OiB5VHJhbnNsYXRlZFxuICAgIH07XG4gIH07XG4gIHZhciB0cmFuc2Zvcm1Qb2ludHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocHRzLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICB2YXIgcmV0UHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciB4ID0gcHRzW2ldO1xuICAgICAgdmFyIHkgPSBwdHNbaSArIDFdO1xuICAgICAgcmV0UHRzLnB1c2godHJhbnNmb3JtKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0UHRzO1xuICB9O1xuICB2YXIgcG9pbnRzVG9BcnIgPSBmdW5jdGlvbiBwb2ludHNUb0FycihwdHMpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcHRzW2ldO1xuICAgICAgcmV0LnB1c2gocC54LCBwLnkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuICB2YXIgc3RhbmRhcmRHYXAgPSBmdW5jdGlvbiBzdGFuZGFyZEdhcChlZGdlKSB7XG4gICAgcmV0dXJuIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS5wZlZhbHVlICogMjtcbiAgfTtcbiAgdmFyIGRlZmluZUFycm93U2hhcGUgPSBmdW5jdGlvbiBkZWZpbmVBcnJvd1NoYXBlKG5hbWUsIGRlZm4pIHtcbiAgICBpZiAoc3RyaW5nKGRlZm4pKSB7XG4gICAgICBkZWZuID0gYXJyb3dTaGFwZXNbZGVmbl07XG4gICAgfVxuICAgIGFycm93U2hhcGVzW25hbWVdID0gZXh0ZW5kKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwb2ludHM6IFstMC4xNSwgLTAuMywgMC4xNSwgLTAuMywgMC4xNSwgMC4zLCAtMC4xNSwgMC4zXSxcbiAgICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBwYWRkaW5nKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICAgIHZhciBpbnNpZGUgPSBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKTtcbiAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICAgIH0sXG4gICAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKCdwb2x5Z29uJykoY29udGV4dCwgcG9pbnRzKTtcbiAgICAgIH0sXG4gICAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9LFxuICAgICAgZ2FwOiBzdGFuZGFyZEdhcFxuICAgIH0sIGRlZm4pO1xuICB9O1xuICBkZWZpbmVBcnJvd1NoYXBlKCdub25lJywge1xuICAgIGNvbGxpZGU6IGZhbHNpZnksXG4gICAgcm91Z2hDb2xsaWRlOiBmYWxzaWZ5LFxuICAgIGRyYXc6IG5vb3AkMSxcbiAgICBzcGFjaW5nOiB6ZXJvaWZ5LFxuICAgIGdhcDogemVyb2lmeVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgndHJpYW5nbGUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAsIDAsIDAuMTUsIC0wLjNdXG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdhcnJvdycsICd0cmlhbmdsZScpO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZS1iYWNrY3VydmUnLCB7XG4gICAgcG9pbnRzOiBhcnJvd1NoYXBlc1sndHJpYW5nbGUnXS5wb2ludHMsXG4gICAgY29udHJvbFBvaW50OiBbMCwgLTAuMTVdLFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHZhciBwdHNUcmFucyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHZhciBjdHJsUHQgPSB0aGlzLmNvbnRyb2xQb2ludDtcbiAgICAgIHZhciBjdHJsUHRUcmFucyA9IHRyYW5zZm9ybShjdHJsUHRbMF0sIGN0cmxQdFsxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgcHRzVHJhbnMsIGN0cmxQdFRyYW5zKTtcbiAgICB9LFxuICAgIGdhcDogZnVuY3Rpb24gZ2FwKGVkZ2UpIHtcbiAgICAgIHJldHVybiBzdGFuZGFyZEdhcChlZGdlKSAqIDAuODtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZS10ZWUnLCB7XG4gICAgcG9pbnRzOiBbMCwgMCwgMC4xNSwgLTAuMywgLTAuMTUsIC0wLjMsIDAsIDBdLFxuICAgIHBvaW50c1RlZTogWy0wLjE1LCAtMC40LCAtMC4xNSwgLTAuNSwgMC4xNSwgLTAuNSwgMC4xNSwgLTAuNF0sXG4gICAgY29sbGlkZTogZnVuY3Rpb24gY29sbGlkZSh4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCwgcGFkZGluZykge1xuICAgICAgdmFyIHRyaVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSArIDIgKiBwYWRkaW5nLCBhbmdsZSwgdHJhbnNsYXRpb24pKTtcbiAgICAgIHZhciB0ZWVQdHMgPSBwb2ludHNUb0Fycih0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHNUZWUsIHNpemUgKyAyICogcGFkZGluZywgYW5nbGUsIHRyYW5zbGF0aW9uKSk7XG4gICAgICB2YXIgaW5zaWRlID0gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRyaVB0cykgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHRlZVB0cyk7XG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24sIGVkZ2VXaWR0aCkge1xuICAgICAgdmFyIHRyaVB0cyA9IHRyYW5zZm9ybVBvaW50cyh0aGlzLnBvaW50cywgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHZhciB0ZWVQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHNUZWUsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgdGVlUHRzKTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdjaXJjbGUtdHJpYW5nbGUnLCB7XG4gICAgcmFkaXVzOiAwLjE1LFxuICAgIHBvaW50c1RyOiBbMCwgLTAuMTUsIDAuMTUsIC0wLjQ1LCAtMC4xNSwgLTAuNDUsIDAsIC0wLjE1XSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdCA9IHRyYW5zbGF0aW9uO1xuICAgICAgdmFyIGNpcmNsZUluc2lkZSA9IE1hdGgucG93KHQueCAtIHgsIDIpICsgTWF0aC5wb3codC55IC0geSwgMikgPD0gTWF0aC5wb3coKHNpemUgKyAyICogcGFkZGluZykgKiB0aGlzLnJhZGl1cywgMik7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IGNpcmNsZUluc2lkZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHNUciwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICAgIHJlbmRlcmVyLmFycm93U2hhcGVJbXBsKHRoaXMubmFtZSkoY29udGV4dCwgdHJpUHRzLCB0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55LCB0aGlzLnJhZGl1cyAqIHNpemUpO1xuICAgIH0sXG4gICAgc3BhY2luZzogZnVuY3Rpb24gc3BhY2luZyhlZGdlKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0QXJyb3dXaWR0aChlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlLCBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZSkgKiB0aGlzLnJhZGl1cztcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd0cmlhbmdsZS1jcm9zcycsIHtcbiAgICBwb2ludHM6IFswLCAwLCAwLjE1LCAtMC4zLCAtMC4xNSwgLTAuMywgMCwgMF0sXG4gICAgYmFzZUNyb3NzTGluZVB0czogWy0wLjE1LCAtMC40LFxuICAgIC8vIGZpcnN0IGhhbGYgb2YgdGhlIHJlY3RhbmdsZVxuICAgIC0wLjE1LCAtMC40LCAwLjE1LCAtMC40LFxuICAgIC8vIHNlY29uZCBoYWxmIG9mIHRoZSByZWN0YW5nbGVcbiAgICAwLjE1LCAtMC40XSxcbiAgICBjcm9zc0xpbmVQdHM6IGZ1bmN0aW9uIGNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpIHtcbiAgICAgIC8vIHNoaWZ0IHBvaW50cyBzbyB0aGF0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBjcm9zcyBwb2ludHMgbWF0Y2hlcyBlZGdlIHdpZHRoXG4gICAgICB2YXIgcCA9IHRoaXMuYmFzZUNyb3NzTGluZVB0cy5zbGljZSgpO1xuICAgICAgdmFyIHNoaWZ0RmFjdG9yID0gZWRnZVdpZHRoIC8gc2l6ZTtcbiAgICAgIHZhciB5MCA9IDM7XG4gICAgICB2YXIgeTEgPSA1O1xuICAgICAgcFt5MF0gPSBwW3kwXSAtIHNoaWZ0RmFjdG9yO1xuICAgICAgcFt5MV0gPSBwW3kxXSAtIHNoaWZ0RmFjdG9yO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBjb2xsaWRlOiBmdW5jdGlvbiBjb2xsaWRlKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gcG9pbnRzVG9BcnIodHJhbnNmb3JtUG9pbnRzKHRoaXMucG9pbnRzLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIHRlZVB0cyA9IHBvaW50c1RvQXJyKHRyYW5zZm9ybVBvaW50cyh0aGlzLmNyb3NzTGluZVB0cyhzaXplLCBlZGdlV2lkdGgpLCBzaXplICsgMiAqIHBhZGRpbmcsIGFuZ2xlLCB0cmFuc2xhdGlvbikpO1xuICAgICAgdmFyIGluc2lkZSA9IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0cmlQdHMpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCB0ZWVQdHMpO1xuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgpIHtcbiAgICAgIHZhciB0cmlQdHMgPSB0cmFuc2Zvcm1Qb2ludHModGhpcy5wb2ludHMsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICB2YXIgY3Jvc3NMaW5lUHRzID0gdHJhbnNmb3JtUG9pbnRzKHRoaXMuY3Jvc3NMaW5lUHRzKHNpemUsIGVkZ2VXaWR0aCksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbik7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyaVB0cywgY3Jvc3NMaW5lUHRzKTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCd2ZWUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIC0wLjMsIDAsIDAsIDAuMTUsIC0wLjMsIDAsIC0wLjE1XSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gc3RhbmRhcmRHYXAoZWRnZSkgKiAwLjUyNTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdjaXJjbGUnLCB7XG4gICAgcmFkaXVzOiAwLjE1LFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uIGNvbGxpZGUoeCwgeSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uLCBlZGdlV2lkdGgsIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0ID0gdHJhbnNsYXRpb247XG4gICAgICB2YXIgaW5zaWRlID0gTWF0aC5wb3codC54IC0geCwgMikgKyBNYXRoLnBvdyh0LnkgLSB5LCAyKSA8PSBNYXRoLnBvdygoc2l6ZSArIDIgKiBwYWRkaW5nKSAqIHRoaXMucmFkaXVzLCAyKTtcbiAgICAgIHJldHVybiBpbnNpZGU7XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKSB7XG4gICAgICByZW5kZXJlci5hcnJvd1NoYXBlSW1wbCh0aGlzLm5hbWUpKGNvbnRleHQsIHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIHRoaXMucmFkaXVzICogc2l6ZSk7XG4gICAgfSxcbiAgICBzcGFjaW5nOiBmdW5jdGlvbiBzcGFjaW5nKGVkZ2UpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMucmFkaXVzO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ3RlZScsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgMCwgLTAuMTUsIC0wLjEsIDAuMTUsIC0wLjEsIDAuMTUsIDBdLFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uIHNwYWNpbmcoZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0pO1xuICBkZWZpbmVBcnJvd1NoYXBlKCdzcXVhcmUnLCB7XG4gICAgcG9pbnRzOiBbLTAuMTUsIDAuMDAsIDAuMTUsIDAuMDAsIDAuMTUsIC0wLjMsIC0wLjE1LCAtMC4zXVxuICB9KTtcbiAgZGVmaW5lQXJyb3dTaGFwZSgnZGlhbW9uZCcsIHtcbiAgICBwb2ludHM6IFstMC4xNSwgLTAuMTUsIDAsIC0wLjMsIDAuMTUsIC0wLjE1LCAwLCAwXSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZSAqIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIH1cbiAgfSk7XG4gIGRlZmluZUFycm93U2hhcGUoJ2NoZXZyb24nLCB7XG4gICAgcG9pbnRzOiBbMCwgMCwgLTAuMTUsIC0wLjE1LCAtMC4xLCAtMC4yLCAwLCAtMC4xLCAwLjEsIC0wLjIsIDAuMTUsIC0wLjE1XSxcbiAgICBnYXA6IGZ1bmN0aW9uIGdhcChlZGdlKSB7XG4gICAgICByZXR1cm4gMC45NSAqIGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUgKiBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIEJScCRlID0ge307XG5cbi8vIFByb2plY3QgbW91c2VcbkJScCRlLnByb2plY3RJbnRvVmlld3BvcnQgPSBmdW5jdGlvbiAoY2xpZW50WCwgY2xpZW50WSkge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgb2Zmc2V0cyA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gIHZhciBvZmZzZXRUb3AgPSBvZmZzZXRzWzFdO1xuICB2YXIgc2NhbGUgPSBvZmZzZXRzWzRdO1xuICB2YXIgcGFuID0gY3kucGFuKCk7XG4gIHZhciB6b29tID0gY3kuem9vbSgpO1xuICB2YXIgeCA9ICgoY2xpZW50WCAtIG9mZnNldExlZnQpIC8gc2NhbGUgLSBwYW4ueCkgLyB6b29tO1xuICB2YXIgeSA9ICgoY2xpZW50WSAtIG9mZnNldFRvcCkgLyBzY2FsZSAtIHBhbi55KSAvIHpvb207XG4gIHJldHVybiBbeCwgeV07XG59O1xuQlJwJGUuZmluZENvbnRhaW5lckNsaWVudENvb3JkcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY29udGFpbmVyQkIpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXJCQjtcbiAgfVxuICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gIHZhciByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc3R5bGUgPSB0aGlzLmN5LndpbmRvdygpLmdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgdmFyIHN0eWxlVmFsdWUgPSBmdW5jdGlvbiBzdHlsZVZhbHVlKG5hbWUpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgfTtcbiAgdmFyIHBhZGRpbmcgPSB7XG4gICAgbGVmdDogc3R5bGVWYWx1ZSgncGFkZGluZy1sZWZ0JyksXG4gICAgcmlnaHQ6IHN0eWxlVmFsdWUoJ3BhZGRpbmctcmlnaHQnKSxcbiAgICB0b3A6IHN0eWxlVmFsdWUoJ3BhZGRpbmctdG9wJyksXG4gICAgYm90dG9tOiBzdHlsZVZhbHVlKCdwYWRkaW5nLWJvdHRvbScpXG4gIH07XG4gIHZhciBib3JkZXIgPSB7XG4gICAgbGVmdDogc3R5bGVWYWx1ZSgnYm9yZGVyLWxlZnQtd2lkdGgnKSxcbiAgICByaWdodDogc3R5bGVWYWx1ZSgnYm9yZGVyLXJpZ2h0LXdpZHRoJyksXG4gICAgdG9wOiBzdHlsZVZhbHVlKCdib3JkZXItdG9wLXdpZHRoJyksXG4gICAgYm90dG9tOiBzdHlsZVZhbHVlKCdib3JkZXItYm90dG9tLXdpZHRoJylcbiAgfTtcbiAgdmFyIGNsaWVudFdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICB2YXIgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgdmFyIHBhZGRpbmdIb3IgPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICB2YXIgcGFkZGluZ1ZlciA9IHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gIHZhciBib3JkZXJIb3IgPSBib3JkZXIubGVmdCArIGJvcmRlci5yaWdodDtcbiAgdmFyIHNjYWxlID0gcmVjdC53aWR0aCAvIChjbGllbnRXaWR0aCArIGJvcmRlckhvcik7XG4gIHZhciB1bnNjYWxlZFcgPSBjbGllbnRXaWR0aCAtIHBhZGRpbmdIb3I7XG4gIHZhciB1bnNjYWxlZEggPSBjbGllbnRIZWlnaHQgLSBwYWRkaW5nVmVyO1xuICB2YXIgbGVmdCA9IHJlY3QubGVmdCArIHBhZGRpbmcubGVmdCArIGJvcmRlci5sZWZ0O1xuICB2YXIgdG9wID0gcmVjdC50b3AgKyBwYWRkaW5nLnRvcCArIGJvcmRlci50b3A7XG4gIHJldHVybiB0aGlzLmNvbnRhaW5lckJCID0gW2xlZnQsIHRvcCwgdW5zY2FsZWRXLCB1bnNjYWxlZEgsIHNjYWxlXTtcbn07XG5CUnAkZS5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29udGFpbmVyQkIgPSBudWxsO1xufTtcbkJScCRlLmZpbmROZWFyZXN0RWxlbWVudCA9IGZ1bmN0aW9uICh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaCkge1xuICByZXR1cm4gdGhpcy5maW5kTmVhcmVzdEVsZW1lbnRzKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKVswXTtcbn07XG5CUnAkZS5maW5kTmVhcmVzdEVsZW1lbnRzID0gZnVuY3Rpb24gKHgsIHksIGludGVyYWN0aXZlRWxlbWVudHNPbmx5LCBpc1RvdWNoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgdmFyIG5lYXIgPSBbXTsgLy8gMSBub2RlIG1heCwgMSBlZGdlIG1heFxuICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICB2YXIgaGFzQ29tcG91bmRzID0gci5jeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBlZGdlVGhyZXNob2xkID0gKGlzVG91Y2ggPyAyNCA6IDgpIC8gem9vbTtcbiAgdmFyIG5vZGVUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDggOiAyKSAvIHpvb207XG4gIHZhciBsYWJlbFRocmVzaG9sZCA9IChpc1RvdWNoID8gOCA6IDIpIC8gem9vbTtcbiAgdmFyIG1pblNxRGlzdCA9IEluZmluaXR5O1xuICB2YXIgbmVhckVkZ2U7XG4gIHZhciBuZWFyTm9kZTtcbiAgaWYgKGludGVyYWN0aXZlRWxlbWVudHNPbmx5KSB7XG4gICAgZWxlcyA9IGVsZXMuaW50ZXJhY3RpdmU7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRWxlKGVsZSwgc3FEaXN0KSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgaWYgKG5lYXJOb2RlKSB7XG4gICAgICAgIHJldHVybjsgLy8gY2FuJ3QgcmVwbGFjZSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWFyTm9kZSA9IGVsZTtcbiAgICAgICAgbmVhci5wdXNoKGVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbGUuaXNFZGdlKCkgJiYgKHNxRGlzdCA9PSBudWxsIHx8IHNxRGlzdCA8IG1pblNxRGlzdCkpIHtcbiAgICAgIGlmIChuZWFyRWRnZSkge1xuICAgICAgICAvLyB0aGVuIHJlcGxhY2UgZXhpc3RpbmcgZWRnZVxuICAgICAgICAvLyBjYW4gcmVwbGFjZSBvbmx5IGlmIHNhbWUgei1pbmRleFxuICAgICAgICBpZiAobmVhckVkZ2UucHN0eWxlKCd6LWNvbXBvdW5kLWRlcHRoJykudmFsdWUgPT09IGVsZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSAmJiBuZWFyRWRnZS5wc3R5bGUoJ3otY29tcG91bmQtZGVwdGgnKS52YWx1ZSA9PT0gZWxlLnBzdHlsZSgnei1jb21wb3VuZC1kZXB0aCcpLnZhbHVlKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobmVhcltpXS5pc0VkZ2UoKSkge1xuICAgICAgICAgICAgICBuZWFyW2ldID0gZWxlO1xuICAgICAgICAgICAgICBuZWFyRWRnZSA9IGVsZTtcbiAgICAgICAgICAgICAgbWluU3FEaXN0ID0gc3FEaXN0ICE9IG51bGwgPyBzcURpc3QgOiBtaW5TcURpc3Q7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVhci5wdXNoKGVsZSk7XG4gICAgICAgIG5lYXJFZGdlID0gZWxlO1xuICAgICAgICBtaW5TcURpc3QgPSBzcURpc3QgIT0gbnVsbCA/IHNxRGlzdCA6IG1pblNxRGlzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tOb2RlKG5vZGUpIHtcbiAgICB2YXIgd2lkdGggPSBub2RlLm91dGVyV2lkdGgoKSArIDIgKiBub2RlVGhyZXNob2xkO1xuICAgIHZhciBoZWlnaHQgPSBub2RlLm91dGVySGVpZ2h0KCkgKyAyICogbm9kZVRocmVzaG9sZDtcbiAgICB2YXIgaHcgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlID09PSAnYXV0bycgPyAnYXV0bycgOiBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gICAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBpZiAocG9zLnggLSBodyA8PSB4ICYmIHggPD0gcG9zLnggKyBodyAvLyBiYiBjaGVjayB4XG4gICAgJiYgcG9zLnkgLSBoaCA8PSB5ICYmIHkgPD0gcG9zLnkgKyBoaCAvLyBiYiBjaGVjayB5XG4gICAgKSB7XG4gICAgICB2YXIgc2hhcGUgPSByLm5vZGVTaGFwZXNbc2VsZi5nZXROb2RlU2hhcGUobm9kZSldO1xuICAgICAgaWYgKHNoYXBlLmNoZWNrUG9pbnQoeCwgeSwgMCwgd2lkdGgsIGhlaWdodCwgcG9zLngsIHBvcy55LCBjb3JuZXJSYWRpdXMsIHJzKSkge1xuICAgICAgICBhZGRFbGUobm9kZSwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjaGVja0VkZ2UoZWRnZSkge1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgdmFyIHN0eWxlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBzY2FsZSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgIHZhciB3aWR0aCA9IHN0eWxlV2lkdGggLyAyICsgZWRnZVRocmVzaG9sZDsgLy8gbW9yZSBsaWtlIGEgZGlzdGFuY2UgcmFkaXVzIGZyb20gY2VudHJlXG4gICAgdmFyIHdpZHRoU3EgPSB3aWR0aCAqIHdpZHRoO1xuICAgIHZhciB3aWR0aDIgPSB3aWR0aCAqIDI7XG4gICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgIHZhciBzcURpc3Q7XG4gICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnIHx8IHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnIHx8IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgKyAzIDwgcHRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGlmIChpbkxpbmVWaWNpbml0eSh4LCB5LCBwdHNbaV0sIHB0c1tpICsgMV0sIHB0c1tpICsgMl0sIHB0c1tpICsgM10sIHdpZHRoMikgJiYgd2lkdGhTcSA+IChzcURpc3QgPSBzcWRpc3RUb0Zpbml0ZUxpbmUoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdKSkpIHtcbiAgICAgICAgICBhZGRFbGUoZWRnZSwgc3FEaXN0KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdiZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcpIHtcbiAgICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSArIDUgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgaWYgKGluQmV6aWVyVmljaW5pdHkoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdLCBwdHNbaSArIDRdLCBwdHNbaSArIDVdLCB3aWR0aDIpICYmIHdpZHRoU3EgPiAoc3FEaXN0ID0gc3FkaXN0VG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdLCBwdHNbaSArIDRdLCBwdHNbaSArIDVdKSkpIHtcbiAgICAgICAgICBhZGRFbGUoZWRnZSwgc3FEaXN0KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGNsb3NlIHRvIHRoZSBlZGdlIGJ1dCBkaWRuJ3QgaGl0IGl0LCBtYXliZSB3ZSBoaXQgaXRzIGFycm93c1xuXG4gICAgdmFyIHNyYyA9IHNyYyB8fCBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IHRndCB8fCBfcC50YXJnZXQ7XG4gICAgdmFyIGFyU2l6ZSA9IHNlbGYuZ2V0QXJyb3dXaWR0aChzdHlsZVdpZHRoLCBzY2FsZSk7XG4gICAgdmFyIGFycm93cyA9IFt7XG4gICAgICBuYW1lOiAnc291cmNlJyxcbiAgICAgIHg6IHJzLmFycm93U3RhcnRYLFxuICAgICAgeTogcnMuYXJyb3dTdGFydFksXG4gICAgICBhbmdsZTogcnMuc3JjQXJyb3dBbmdsZVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICd0YXJnZXQnLFxuICAgICAgeDogcnMuYXJyb3dFbmRYLFxuICAgICAgeTogcnMuYXJyb3dFbmRZLFxuICAgICAgYW5nbGU6IHJzLnRndEFycm93QW5nbGVcbiAgICB9LCB7XG4gICAgICBuYW1lOiAnbWlkLXNvdXJjZScsXG4gICAgICB4OiBycy5taWRYLFxuICAgICAgeTogcnMubWlkWSxcbiAgICAgIGFuZ2xlOiBycy5taWRzcmNBcnJvd0FuZ2xlXG4gICAgfSwge1xuICAgICAgbmFtZTogJ21pZC10YXJnZXQnLFxuICAgICAgeDogcnMubWlkWCxcbiAgICAgIHk6IHJzLm1pZFksXG4gICAgICBhbmdsZTogcnMubWlkdGd0QXJyb3dBbmdsZVxuICAgIH1dO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXIgPSBhcnJvd3NbaV07XG4gICAgICB2YXIgc2hhcGUgPSByLmFycm93U2hhcGVzW2VkZ2UucHN0eWxlKGFyLm5hbWUgKyAnLWFycm93LXNoYXBlJykudmFsdWVdO1xuICAgICAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICBpZiAoc2hhcGUucm91Z2hDb2xsaWRlKHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHtcbiAgICAgICAgeDogYXIueCxcbiAgICAgICAgeTogYXIueVxuICAgICAgfSwgZWRnZVdpZHRoLCBlZGdlVGhyZXNob2xkKSAmJiBzaGFwZS5jb2xsaWRlKHgsIHksIGFyU2l6ZSwgYXIuYW5nbGUsIHtcbiAgICAgICAgeDogYXIueCxcbiAgICAgICAgeTogYXIueVxuICAgICAgfSwgZWRnZVdpZHRoLCBlZGdlVGhyZXNob2xkKSkge1xuICAgICAgICBhZGRFbGUoZWRnZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZvciBjb21wb3VuZCBncmFwaHMsIGhpdHRpbmcgZWRnZSBtYXkgYWN0dWFsbHkgd2FudCBhIGNvbm5lY3RlZCBub2RlIGluc3RlYWQgKGIvYyBlZGdlIG1heSBoYXZlIGdyZWF0ZXIgei1pbmRleCBwcmVjZWRlbmNlKVxuICAgIGlmIChoYXNDb21wb3VuZHMgJiYgbmVhci5sZW5ndGggPiAwKSB7XG4gICAgICBjaGVja05vZGUoc3JjKTtcbiAgICAgIGNoZWNrTm9kZSh0Z3QpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcmVwcm9wKG9iaiwgbmFtZSwgcHJlKSB7XG4gICAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBuYW1lLCBwcmUpO1xuICB9XG4gIGZ1bmN0aW9uIGNoZWNrTGFiZWwoZWxlLCBwcmVmaXgpIHtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHRoID0gbGFiZWxUaHJlc2hvbGQ7XG4gICAgdmFyIHByZWZpeERhc2g7XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgcHJlZml4RGFzaCA9IHByZWZpeCArICctJztcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4RGFzaCA9ICcnO1xuICAgIH1cbiAgICBlbGUuYm91bmRpbmdCb3goKTtcbiAgICB2YXIgYmIgPSBfcC5sYWJlbEJvdW5kc1twcmVmaXggfHwgJ21haW4nXTtcbiAgICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUocHJlZml4RGFzaCArICdsYWJlbCcpLnZhbHVlO1xuICAgIHZhciBldmVudHNFbmFibGVkID0gZWxlLnBzdHlsZSgndGV4dC1ldmVudHMnKS5zdHJWYWx1ZSA9PT0gJ3llcyc7XG4gICAgaWYgKCFldmVudHNFbmFibGVkIHx8ICF0ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBseCA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciBseSA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbFknLCBwcmVmaXgpO1xuICAgIHZhciB0aGV0YSA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbEFuZ2xlJywgcHJlZml4KTtcbiAgICB2YXIgb3ggPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgdmFyIG95ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlO1xuICAgIHZhciBseDEgPSBiYi54MSAtIHRoIC0gb3g7IC8vICgtb3gsIC1veSkgYXMgYmIgYWxyZWFkeSBpbmNsdWRlcyBtYXJnaW5cbiAgICB2YXIgbHgyID0gYmIueDIgKyB0aCAtIG94OyAvLyBhbmQgcm90YXRpb24gaXMgYWJvdXQgKGx4LCBseSlcbiAgICB2YXIgbHkxID0gYmIueTEgLSB0aCAtIG95O1xuICAgIHZhciBseTIgPSBiYi55MiArIHRoIC0gb3k7XG4gICAgaWYgKHRoZXRhKSB7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSkge1xuICAgICAgICB4ID0geCAtIGx4O1xuICAgICAgICB5ID0geSAtIGx5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHggKiBjb3MgLSB5ICogc2luICsgbHgsXG4gICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyBseVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHZhciBweDF5MSA9IHJvdGF0ZShseDEsIGx5MSk7XG4gICAgICB2YXIgcHgxeTIgPSByb3RhdGUobHgxLCBseTIpO1xuICAgICAgdmFyIHB4MnkxID0gcm90YXRlKGx4MiwgbHkxKTtcbiAgICAgIHZhciBweDJ5MiA9IHJvdGF0ZShseDIsIGx5Mik7XG4gICAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgLy8gd2l0aCB0aGUgbWFyZ2luIGFkZGVkIGFmdGVyIHRoZSByb3RhdGlvbiBpcyBhcHBsaWVkXG4gICAgICBweDF5MS54ICsgb3gsIHB4MXkxLnkgKyBveSwgcHgyeTEueCArIG94LCBweDJ5MS55ICsgb3ksIHB4MnkyLnggKyBveCwgcHgyeTIueSArIG95LCBweDF5Mi54ICsgb3gsIHB4MXkyLnkgKyBveV07XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIHBvaW50cykpIHtcbiAgICAgICAgYWRkRWxlKGVsZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkbyBhIGNoZWFwZXIgYmIgY2hlY2tcbiAgICAgIGlmIChpbkJvdW5kaW5nQm94KGJiLCB4LCB5KSkge1xuICAgICAgICBhZGRFbGUoZWxlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSBlbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgLy8gcmV2ZXJzZSBvcmRlciBmb3IgcHJlY2VkZW5jZVxuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIGNoZWNrTm9kZShlbGUpIHx8IGNoZWNrTGFiZWwoZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGhlbiBlZGdlXG4gICAgICBjaGVja0VkZ2UoZWxlKSB8fCBjaGVja0xhYmVsKGVsZSkgfHwgY2hlY2tMYWJlbChlbGUsICdzb3VyY2UnKSB8fCBjaGVja0xhYmVsKGVsZSwgJ3RhcmdldCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVhcjtcbn07XG5cbi8vICdHaXZlIG1lIGV2ZXJ5dGhpbmcgZnJvbSB0aGlzIGJveCdcbkJScCRlLmdldEFsbEluQm94ID0gZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBlbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpLmludGVyYWN0aXZlO1xuICB2YXIgem9vbSA9IHRoaXMuY3kuem9vbSgpO1xuICB2YXIgbGFiZWxUaHJlc2hvbGQgPSAyIC8gem9vbTtcbiAgdmFyIGJveCA9IFtdO1xuICB2YXIgeDFjID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgdmFyIHgyYyA9IE1hdGgubWF4KHgxLCB4Mik7XG4gIHZhciB5MWMgPSBNYXRoLm1pbih5MSwgeTIpO1xuICB2YXIgeTJjID0gTWF0aC5tYXgoeTEsIHkyKTtcbiAgeDEgPSB4MWM7XG4gIHgyID0geDJjO1xuICB5MSA9IHkxYztcbiAgeTIgPSB5MmM7XG4gIHZhciBib3hCYiA9IG1ha2VCb3VuZGluZ0JveCh7XG4gICAgeDE6IHgxLFxuICAgIHkxOiB5MSxcbiAgICB4MjogeDIsXG4gICAgeTI6IHkyXG4gIH0pO1xuICB2YXIgc2VsZWN0aW9uQm94ID0gW3tcbiAgICB4OiBib3hCYi54MSxcbiAgICB5OiBib3hCYi55MVxuICB9LCB7XG4gICAgeDogYm94QmIueDIsXG4gICAgeTogYm94QmIueTFcbiAgfSwge1xuICAgIHg6IGJveEJiLngyLFxuICAgIHk6IGJveEJiLnkyXG4gIH0sIHtcbiAgICB4OiBib3hCYi54MSxcbiAgICB5OiBib3hCYi55MlxuICB9XTtcbiAgdmFyIGJveEVkZ2VzID0gW1tzZWxlY3Rpb25Cb3hbMF0sIHNlbGVjdGlvbkJveFsxXV0sIFtzZWxlY3Rpb25Cb3hbMV0sIHNlbGVjdGlvbkJveFsyXV0sIFtzZWxlY3Rpb25Cb3hbMl0sIHNlbGVjdGlvbkJveFszXV0sIFtzZWxlY3Rpb25Cb3hbM10sIHNlbGVjdGlvbkJveFswXV1dO1xuICBmdW5jdGlvbiBwcmVwcm9wKG9iaiwgbmFtZSwgcHJlKSB7XG4gICAgcmV0dXJuIGdldFByZWZpeGVkUHJvcGVydHkob2JqLCBuYW1lLCBwcmUpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJvdGF0ZWRMYWJlbEJveChlbGUsIHByZWZpeCkge1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgdGggPSBsYWJlbFRocmVzaG9sZDtcbiAgICB2YXIgcHJlZml4RGFzaCA9ICcnO1xuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHZhciBiYiA9IF9wLmxhYmVsQm91bmRzWydtYWluJ107XG5cbiAgICAvLyBJZiB0aGUgYm91bmRpbmcgYm94IGlzIG5vdCBhdmFpbGFibGUsIHJldHVybiBudWxsLlxuICAgIC8vIFRoaXMgaW5kaWNhdGVzIHRoYXQgdGhlIGxhYmVsIGJveCBjYW5ub3QgYmUgY2FsY3VsYXRlZCwgd2hpY2ggaXMgY29uc2lzdGVudFxuICAgIC8vIHdpdGggdGhlIGV4cGVjdGVkIGJlaGF2aW9yIG9mIHRoaXMgZnVuY3Rpb24uIFJldHVybmluZyBudWxsIGFsbG93cyB0aGUgY2FsbGVyXG4gICAgLy8gdG8gaGFuZGxlIHRoZSBhYnNlbmNlIG9mIGEgYm91bmRpbmcgYm94IGV4cGxpY2l0bHkuXG4gICAgaWYgKCFiYikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBseCA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbFgnLCBwcmVmaXgpO1xuICAgIHZhciBseSA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbFknLCBwcmVmaXgpO1xuICAgIHZhciB0aGV0YSA9IHByZXByb3AoX3AucnNjcmF0Y2gsICdsYWJlbEFuZ2xlJywgcHJlZml4KTtcbiAgICB2YXIgb3ggPSBlbGUucHN0eWxlKHByZWZpeERhc2ggKyAndGV4dC1tYXJnaW4teCcpLnBmVmFsdWU7XG4gICAgdmFyIG95ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlO1xuICAgIHZhciBseDEgPSBiYi54MSAtIHRoIC0gb3g7XG4gICAgdmFyIGx4MiA9IGJiLngyICsgdGggLSBveDtcbiAgICB2YXIgbHkxID0gYmIueTEgLSB0aCAtIG95O1xuICAgIHZhciBseTIgPSBiYi55MiArIHRoIC0gb3k7XG4gICAgaWYgKHRoZXRhKSB7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKHRoZXRhKTtcbiAgICAgIHZhciByb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUoeCwgeSkge1xuICAgICAgICB4ID0geCAtIGx4O1xuICAgICAgICB5ID0geSAtIGx5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHggKiBjb3MgLSB5ICogc2luICsgbHgsXG4gICAgICAgICAgeTogeCAqIHNpbiArIHkgKiBjb3MgKyBseVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBbcm90YXRlKGx4MSwgbHkxKSwgcm90YXRlKGx4MiwgbHkxKSwgcm90YXRlKGx4MiwgbHkyKSwgcm90YXRlKGx4MSwgbHkyKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB4OiBseDEsXG4gICAgICAgIHk6IGx5MVxuICAgICAgfSwge1xuICAgICAgICB4OiBseDIsXG4gICAgICAgIHk6IGx5MVxuICAgICAgfSwge1xuICAgICAgICB4OiBseDIsXG4gICAgICAgIHk6IGx5MlxuICAgICAgfSwge1xuICAgICAgICB4OiBseDEsXG4gICAgICAgIHk6IGx5MlxuICAgICAgfV07XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRvTGluZXNJbnRlcnNlY3QocDEsIHAyLCBxMSwgcTIpIHtcbiAgICBmdW5jdGlvbiBjY3coYSwgYiwgYykge1xuICAgICAgcmV0dXJuIChjLnkgLSBhLnkpICogKGIueCAtIGEueCkgPiAoYi55IC0gYS55KSAqIChjLnggLSBhLngpO1xuICAgIH1cbiAgICByZXR1cm4gY2N3KHAxLCBxMSwgcTIpICE9PSBjY3cocDIsIHExLCBxMikgJiYgY2N3KHAxLCBwMiwgcTEpICE9PSBjY3cocDEsIHAyLCBxMik7XG4gIH1cbiAgZm9yICh2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbZV07XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgdmFyIG5vZGUgPSBlbGU7XG4gICAgICB2YXIgdGV4dEV2ZW50cyA9IG5vZGUucHN0eWxlKCd0ZXh0LWV2ZW50cycpLnN0clZhbHVlID09PSAneWVzJztcbiAgICAgIHZhciBub2RlQm94U2VsZWN0TW9kZSA9IG5vZGUucHN0eWxlKCdib3gtc2VsZWN0aW9uJykuc3RyVmFsdWU7XG4gICAgICB2YXIgbGFiZWxCb3hTZWxlY3RFbmFibGVkID0gbm9kZS5wc3R5bGUoJ2JveC1zZWxlY3QtbGFiZWxzJykuc3RyVmFsdWUgPT09ICd5ZXMnO1xuICAgICAgaWYgKG5vZGVCb3hTZWxlY3RNb2RlID09PSAnbm9uZScpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgaW5jbHVkZUxhYmVscyA9IChub2RlQm94U2VsZWN0TW9kZSA9PT0gJ292ZXJsYXAnIHx8IGxhYmVsQm94U2VsZWN0RW5hYmxlZCkgJiYgdGV4dEV2ZW50cztcbiAgICAgIHZhciBub2RlQmIgPSBub2RlLmJvdW5kaW5nQm94KHtcbiAgICAgICAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICAgICAgICBpbmNsdWRlRWRnZXM6IGZhbHNlLFxuICAgICAgICBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzXG4gICAgICB9KTtcbiAgICAgIGlmIChub2RlQm94U2VsZWN0TW9kZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobGFiZWxCb3hTZWxlY3RFbmFibGVkICYmIHRleHRFdmVudHMpIHtcbiAgICAgICAgICB2YXIgcm90YXRlZExhYmVsQm94ID0gZ2V0Um90YXRlZExhYmVsQm94KG5vZGUpO1xuICAgICAgICAgIGlmIChyb3RhdGVkTGFiZWxCb3ggJiYgc2F0UG9seWdvbkludGVyc2VjdGlvbihyb3RhdGVkTGFiZWxCb3gsIHNlbGVjdGlvbkJveCkpIHtcbiAgICAgICAgICAgIGJveC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGVjdGVkICYmIGJvdW5kaW5nQm94SW5Cb3VuZGluZ0JveChib3hCYiwgbm9kZUJiKSkge1xuICAgICAgICAgIGJveC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGVCb3hTZWxlY3RNb2RlID09PSAnb3ZlcmxhcCcpIHtcbiAgICAgICAgaWYgKGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYm94QmIsIG5vZGVCYikpIHtcbiAgICAgICAgICB2YXIgbm9kZUJvZHlCYiA9IG5vZGUuYm91bmRpbmdCb3goe1xuICAgICAgICAgICAgaW5jbHVkZU5vZGVzOiB0cnVlLFxuICAgICAgICAgICAgaW5jbHVkZUVkZ2VzOiB0cnVlLFxuICAgICAgICAgICAgaW5jbHVkZUxhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBpbmNsdWRlTWFpbkxhYmVsczogZmFsc2UsXG4gICAgICAgICAgICBpbmNsdWRlU291cmNlTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGluY2x1ZGVUYXJnZXRMYWJlbHM6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIG5vZGVCb2R5Q29ybmVycyA9IFt7XG4gICAgICAgICAgICB4OiBub2RlQm9keUJiLngxLFxuICAgICAgICAgICAgeTogbm9kZUJvZHlCYi55MVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IG5vZGVCb2R5QmIueDIsXG4gICAgICAgICAgICB5OiBub2RlQm9keUJiLnkxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogbm9kZUJvZHlCYi54MixcbiAgICAgICAgICAgIHk6IG5vZGVCb2R5QmIueTJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB4OiBub2RlQm9keUJiLngxLFxuICAgICAgICAgICAgeTogbm9kZUJvZHlCYi55MlxuICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgLy8gaWYgbm9kZSBib2R5IGludGVyc2VjdHMsIG5vIG5lZWQgdG8gY2hlY2sgbGFiZWxcbiAgICAgICAgICBpZiAoc2F0UG9seWdvbkludGVyc2VjdGlvbihub2RlQm9keUNvcm5lcnMsIHNlbGVjdGlvbkJveCkpIHtcbiAgICAgICAgICAgIGJveC5wdXNoKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIGxhYmVsIGlmIG5vZGUgYm9keSBkaWRuJ3QgaW50ZXJzZWN0XG4gICAgICAgICAgICB2YXIgX3JvdGF0ZWRMYWJlbEJveCA9IGdldFJvdGF0ZWRMYWJlbEJveChub2RlKTtcbiAgICAgICAgICAgIGlmIChfcm90YXRlZExhYmVsQm94ICYmIHNhdFBvbHlnb25JbnRlcnNlY3Rpb24oX3JvdGF0ZWRMYWJlbEJveCwgc2VsZWN0aW9uQm94KSkge1xuICAgICAgICAgICAgICBib3gucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgICB2YXIgZWRnZUJveFNlbGVjdE1vZGUgPSBlZGdlLnBzdHlsZSgnYm94LXNlbGVjdGlvbicpLnN0clZhbHVlO1xuICAgICAgaWYgKGVkZ2VCb3hTZWxlY3RNb2RlID09PSAnbm9uZScpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoZWRnZUJveFNlbGVjdE1vZGUgPT09ICdjb250YWluJykge1xuICAgICAgICBpZiAocnMuc3RhcnRYICE9IG51bGwgJiYgcnMuc3RhcnRZICE9IG51bGwgJiYgIWluQm91bmRpbmdCb3goYm94QmIsIHJzLnN0YXJ0WCwgcnMuc3RhcnRZKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChycy5lbmRYICE9IG51bGwgJiYgcnMuZW5kWSAhPSBudWxsICYmICFpbkJvdW5kaW5nQm94KGJveEJiLCBycy5lbmRYLCBycy5lbmRZKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2NvbXBvdW5kJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlZ21lbnRzJyB8fCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICAgIHZhciBwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzIHx8IF9wLnJzdHlsZS5saW5lUHRzIHx8IF9wLnJzdHlsZS5oYXlzdGFja1B0cztcbiAgICAgICAgICB2YXIgYWxsSW5zaWRlID0gdHJ1ZTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFwb2ludEluQm91bmRpbmdCb3goYm94QmIsIHB0c1tpXSkpIHtcbiAgICAgICAgICAgICAgYWxsSW5zaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYWxsSW5zaWRlKSB7XG4gICAgICAgICAgICBib3gucHVzaChlZGdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgICBib3gucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlZGdlQm94U2VsZWN0TW9kZSA9PT0gJ292ZXJsYXAnKSB7XG4gICAgICAgIHZhciBfc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBDaGVjazogZWl0aGVyIGVuZHBvaW50IGluc2lkZSBib3hcbiAgICAgICAgaWYgKHJzLnN0YXJ0WCAhPSBudWxsICYmIHJzLnN0YXJ0WSAhPSBudWxsICYmIHJzLmVuZFggIT0gbnVsbCAmJiBycy5lbmRZICE9IG51bGwgJiYgKGluQm91bmRpbmdCb3goYm94QmIsIHJzLnN0YXJ0WCwgcnMuc3RhcnRZKSB8fCBpbkJvdW5kaW5nQm94KGJveEJiLCBycy5lbmRYLCBycy5lbmRZKSkpIHtcbiAgICAgICAgICBib3gucHVzaChlZGdlKTtcbiAgICAgICAgICBfc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGF5c3RhY2sgZmFsbGJhY2sgKG9ubHkgY2hlY2sgaWYgbm90IGFscmVhZHkgc2VsZWN0ZWQpXG4gICAgICAgIGVsc2UgaWYgKCFfc2VsZWN0ZWQgJiYgcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgICB2YXIgaGF5c3RhY2tQdHMgPSBfcC5yc3R5bGUuaGF5c3RhY2tQdHM7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGhheXN0YWNrUHRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgaWYgKHBvaW50SW5Cb3VuZGluZ0JveChib3hCYiwgaGF5c3RhY2tQdHNbX2ldKSkge1xuICAgICAgICAgICAgICBib3gucHVzaChlZGdlKTtcbiAgICAgICAgICAgICAgX3NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VnbWVudCBpbnRlcnNlY3Rpb24gY2hlY2sgKG9ubHkgaWYgbm90IGFscmVhZHkgc2VsZWN0ZWQpXG4gICAgICAgIGlmICghX3NlbGVjdGVkKSB7XG4gICAgICAgICAgdmFyIF9wdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzIHx8IF9wLnJzdHlsZS5saW5lUHRzIHx8IF9wLnJzdHlsZS5oYXlzdGFja1B0cztcblxuICAgICAgICAgIC8vIHN0cmFpZ2h0IGVkZ2VzXG4gICAgICAgICAgaWYgKCghX3B0cyB8fCBfcHRzLmxlbmd0aCA8IDIpICYmIHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICAgICAgICBpZiAocnMuc3RhcnRYICE9IG51bGwgJiYgcnMuc3RhcnRZICE9IG51bGwgJiYgcnMuZW5kWCAhPSBudWxsICYmIHJzLmVuZFkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBfcHRzID0gW3tcbiAgICAgICAgICAgICAgICB4OiBycy5zdGFydFgsXG4gICAgICAgICAgICAgICAgeTogcnMuc3RhcnRZXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiBycy5lbmRYLFxuICAgICAgICAgICAgICAgIHk6IHJzLmVuZFlcbiAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX3B0cyB8fCBfcHRzLmxlbmd0aCA8IDIpIGNvbnRpbnVlO1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IF9wdHMubGVuZ3RoIC0gMTsgX2kyKyspIHtcbiAgICAgICAgICAgIHZhciBzZWdTdGFydCA9IF9wdHNbX2kyXTtcbiAgICAgICAgICAgIHZhciBzZWdFbmQgPSBfcHRzW19pMiArIDFdO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBib3hFZGdlcy5sZW5ndGg7IGIrKykge1xuICAgICAgICAgICAgICB2YXIgX2JveEVkZ2VzJGIgPSBfc2xpY2VkVG9BcnJheShib3hFZGdlc1tiXSwgMiksXG4gICAgICAgICAgICAgICAgYm94U3RhcnQgPSBfYm94RWRnZXMkYlswXSxcbiAgICAgICAgICAgICAgICBib3hFbmQgPSBfYm94RWRnZXMkYlsxXTtcbiAgICAgICAgICAgICAgaWYgKGRvTGluZXNJbnRlcnNlY3Qoc2VnU3RhcnQsIHNlZ0VuZCwgYm94U3RhcnQsIGJveEVuZCkpIHtcbiAgICAgICAgICAgICAgICBib3gucHVzaChlZGdlKTtcbiAgICAgICAgICAgICAgICBfc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3NlbGVjdGVkKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJveDtcbn07XG5cbnZhciBCUnAkZCA9IHt9O1xuQlJwJGQuY2FsY3VsYXRlQXJyb3dBbmdsZXMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuICB2YXIgaXNCZXppZXIgPSBycy5lZGdlVHlwZSA9PT0gJ2Jlemllcic7XG4gIHZhciBpc011bHRpYmV6aWVyID0gcnMuZWRnZVR5cGUgPT09ICdtdWx0aWJlemllcic7XG4gIHZhciBpc1NlZ21lbnRzID0gcnMuZWRnZVR5cGUgPT09ICdzZWdtZW50cyc7XG4gIHZhciBpc0NvbXBvdW5kID0gcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCc7XG4gIHZhciBpc1NlbGYgPSBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnO1xuXG4gIC8vIERpc3BsYWNlbWVudCBnaXZlcyBkaXJlY3Rpb24gZm9yIGFycm93aGVhZCBvcmllbnRhdGlvblxuICB2YXIgZGlzcFgsIGRpc3BZO1xuICB2YXIgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIG1pZFgsIG1pZFk7XG4gIGlmIChpc0hheXN0YWNrKSB7XG4gICAgc3RhcnRYID0gcnMuaGF5c3RhY2tQdHNbMF07XG4gICAgc3RhcnRZID0gcnMuaGF5c3RhY2tQdHNbMV07XG4gICAgZW5kWCA9IHJzLmhheXN0YWNrUHRzWzJdO1xuICAgIGVuZFkgPSBycy5oYXlzdGFja1B0c1szXTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydFggPSBycy5hcnJvd1N0YXJ0WDtcbiAgICBzdGFydFkgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICBlbmRYID0gcnMuYXJyb3dFbmRYO1xuICAgIGVuZFkgPSBycy5hcnJvd0VuZFk7XG4gIH1cbiAgbWlkWCA9IHJzLm1pZFg7XG4gIG1pZFkgPSBycy5taWRZO1xuXG4gIC8vIHNvdXJjZVxuICAvL1xuXG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgZGlzcFggPSBzdGFydFggLSBycy5zZWdwdHNbMF07XG4gICAgZGlzcFkgPSBzdGFydFkgLSBycy5zZWdwdHNbMV07XG4gIH0gZWxzZSBpZiAoaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZiB8fCBpc0Jlemllcikge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgdmFyIGJYID0gcWJlemllckF0KHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuMSk7XG4gICAgdmFyIGJZID0gcWJlemllckF0KHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuMSk7XG4gICAgZGlzcFggPSBzdGFydFggLSBiWDtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIGJZO1xuICB9IGVsc2Uge1xuICAgIGRpc3BYID0gc3RhcnRYIC0gbWlkWDtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIG1pZFk7XG4gIH1cbiAgcnMuc3JjQXJyb3dBbmdsZSA9IGdldEFuZ2xlRnJvbURpc3AoZGlzcFgsIGRpc3BZKTtcblxuICAvLyBtaWQgdGFyZ2V0XG4gIC8vXG5cbiAgdmFyIG1pZFggPSBycy5taWRYO1xuICB2YXIgbWlkWSA9IHJzLm1pZFk7XG4gIGlmIChpc0hheXN0YWNrKSB7XG4gICAgbWlkWCA9IChzdGFydFggKyBlbmRYKSAvIDI7XG4gICAgbWlkWSA9IChzdGFydFkgKyBlbmRZKSAvIDI7XG4gIH1cbiAgZGlzcFggPSBlbmRYIC0gc3RhcnRYO1xuICBkaXNwWSA9IGVuZFkgLSBzdGFydFk7XG4gIGlmIChpc1NlZ21lbnRzKSB7XG4gICAgdmFyIHB0cyA9IHJzLmFsbHB0cztcbiAgICBpZiAocHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICB2YXIgaTIgPSBwdHMubGVuZ3RoIC8gMjtcbiAgICAgIHZhciBpMSA9IGkyIC0gMjtcbiAgICAgIGRpc3BYID0gcHRzW2kyXSAtIHB0c1tpMV07XG4gICAgICBkaXNwWSA9IHB0c1tpMiArIDFdIC0gcHRzW2kxICsgMV07XG4gICAgfSBlbHNlIGlmIChycy5pc1JvdW5kKSB7XG4gICAgICBkaXNwWCA9IHJzLm1pZFZlY3RvclsxXTtcbiAgICAgIGRpc3BZID0gLXJzLm1pZFZlY3RvclswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGkyID0gcHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgZGlzcFggPSBwdHNbaTJdIC0gcHRzW2kxXTtcbiAgICAgIGRpc3BZID0gcHRzW2kyICsgMV0gLSBwdHNbaTEgKyAxXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZikge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgdmFyIGNwdHMgPSBycy5jdHJscHRzO1xuICAgIHZhciBicDB4LCBicDB5O1xuICAgIHZhciBicDF4LCBicDF5O1xuICAgIGlmIChjcHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICB2YXIgcDAgPSBwdHMubGVuZ3RoIC8gMiAtIDE7IC8vIHN0YXJ0cHRcbiAgICAgIHZhciBpYyA9IHAwICsgMjtcbiAgICAgIHZhciBwMSA9IGljICsgMjtcbiAgICAgIGJwMHggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC4wKTtcbiAgICAgIGJwMHkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC4wKTtcbiAgICAgIGJwMXggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC4wMDAxKTtcbiAgICAgIGJwMXkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC4wMDAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGljID0gcHRzLmxlbmd0aCAvIDIgLSAxOyAvLyBjdHJwdFxuICAgICAgdmFyIHAwID0gaWMgLSAyOyAvLyBzdGFydHB0XG4gICAgICB2YXIgcDEgPSBpYyArIDI7IC8vIGVuZHB0XG5cbiAgICAgIGJwMHggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC40OTk5KTtcbiAgICAgIGJwMHkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC40OTk5KTtcbiAgICAgIGJwMXggPSBxYmV6aWVyQXQocHRzW3AwXSwgcHRzW2ljXSwgcHRzW3AxXSwgMC41KTtcbiAgICAgIGJwMXkgPSBxYmV6aWVyQXQocHRzW3AwICsgMV0sIHB0c1tpYyArIDFdLCBwdHNbcDEgKyAxXSwgMC41KTtcbiAgICB9XG4gICAgZGlzcFggPSBicDF4IC0gYnAweDtcbiAgICBkaXNwWSA9IGJwMXkgLSBicDB5O1xuICB9XG4gIHJzLm1pZHRndEFycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7XG4gIHJzLm1pZERpc3BYID0gZGlzcFg7XG4gIHJzLm1pZERpc3BZID0gZGlzcFk7XG5cbiAgLy8gbWlkIHNvdXJjZVxuICAvL1xuXG4gIGRpc3BYICo9IC0xO1xuICBkaXNwWSAqPSAtMTtcbiAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICB2YXIgcHRzID0gcnMuYWxscHRzO1xuICAgIGlmIChwdHMubGVuZ3RoIC8gMiAlIDIgPT09IDApIDsgZWxzZSBpZiAoIXJzLmlzUm91bmQpIHtcbiAgICAgIHZhciBpMiA9IHB0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIHZhciBpMyA9IGkyICsgMjtcbiAgICAgIGRpc3BYID0gLShwdHNbaTNdIC0gcHRzW2kyXSk7XG4gICAgICBkaXNwWSA9IC0ocHRzW2kzICsgMV0gLSBwdHNbaTIgKyAxXSk7XG4gICAgfVxuICB9XG4gIHJzLm1pZHNyY0Fycm93QW5nbGUgPSBnZXRBbmdsZUZyb21EaXNwKGRpc3BYLCBkaXNwWSk7XG5cbiAgLy8gdGFyZ2V0XG4gIC8vXG5cbiAgaWYgKGlzU2VnbWVudHMpIHtcbiAgICBkaXNwWCA9IGVuZFggLSBycy5zZWdwdHNbcnMuc2VncHRzLmxlbmd0aCAtIDJdO1xuICAgIGRpc3BZID0gZW5kWSAtIHJzLnNlZ3B0c1tycy5zZWdwdHMubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSBpZiAoaXNNdWx0aWJlemllciB8fCBpc0NvbXBvdW5kIHx8IGlzU2VsZiB8fCBpc0Jlemllcikge1xuICAgIHZhciBwdHMgPSBycy5hbGxwdHM7XG4gICAgdmFyIGwgPSBwdHMubGVuZ3RoO1xuICAgIHZhciBiWCA9IHFiZXppZXJBdChwdHNbbCAtIDZdLCBwdHNbbCAtIDRdLCBwdHNbbCAtIDJdLCAwLjkpO1xuICAgIHZhciBiWSA9IHFiZXppZXJBdChwdHNbbCAtIDVdLCBwdHNbbCAtIDNdLCBwdHNbbCAtIDFdLCAwLjkpO1xuICAgIGRpc3BYID0gZW5kWCAtIGJYO1xuICAgIGRpc3BZID0gZW5kWSAtIGJZO1xuICB9IGVsc2Uge1xuICAgIGRpc3BYID0gZW5kWCAtIG1pZFg7XG4gICAgZGlzcFkgPSBlbmRZIC0gbWlkWTtcbiAgfVxuICBycy50Z3RBcnJvd0FuZ2xlID0gZ2V0QW5nbGVGcm9tRGlzcChkaXNwWCwgZGlzcFkpO1xufTtcbkJScCRkLmdldEFycm93V2lkdGggPSBCUnAkZC5nZXRBcnJvd0hlaWdodCA9IGZ1bmN0aW9uIChlZGdlV2lkdGgsIHNjYWxlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgfHwge307XG4gIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtlZGdlV2lkdGggKyAnLCAnICsgc2NhbGVdO1xuICBpZiAoY2FjaGVkVmFsKSB7XG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfVxuICBjYWNoZWRWYWwgPSBNYXRoLm1heChNYXRoLnBvdyhlZGdlV2lkdGggKiAxMy4zNywgMC45KSwgMjkpICogc2NhbGU7XG4gIGNhY2hlW2VkZ2VXaWR0aCArICcsICcgKyBzY2FsZV0gPSBjYWNoZWRWYWw7XG4gIHJldHVybiBjYWNoZWRWYWw7XG59O1xuXG4vKipcbiAqIEV4cGxhaW5lZCBieSBCbGluZG1hbjY3IGF0IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NDg1NjkyNS8xMTAyODgyOFxuICovXG5cbi8vIERlY2xhcmUgcmV1c2VkIHZhcmlhYmxlIHRvIGF2b2lkIHJlYWxsb2NhdGluZyB2YXJpYWJsZXMgZXZlcnkgdGltZSB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkXG52YXIgeCxcbiAgeSxcbiAgdjEgPSB7fSxcbiAgdjIgPSB7fSxcbiAgc2luQSxcbiAgc2luQTkwLFxuICByYWREaXJlY3Rpb24sXG4gIGRyYXdEaXJlY3Rpb24sXG4gIGFuZ2xlLFxuICBoYWxmQW5nbGUsXG4gIGNSYWRpdXMsXG4gIGxlbk91dCxcbiAgcmFkaXVzLFxuICBsaW1pdDtcbnZhciBzdGFydFgsIHN0YXJ0WSwgc3RvcFgsIHN0b3BZO1xudmFyIGxhc3RQb2ludDtcblxuLy8gY29udmVydCAyIHBvaW50cyBpbnRvIHZlY3RvciBmb3JtLCBwb2xhciBmb3JtLCBhbmQgbm9ybWFsaXNlZFxudmFyIGFzVmVjID0gZnVuY3Rpb24gYXNWZWMocCwgcHAsIHYpIHtcbiAgdi54ID0gcHAueCAtIHAueDtcbiAgdi55ID0gcHAueSAtIHAueTtcbiAgdi5sZW4gPSBNYXRoLnNxcnQodi54ICogdi54ICsgdi55ICogdi55KTtcbiAgdi5ueCA9IHYueCAvIHYubGVuO1xuICB2Lm55ID0gdi55IC8gdi5sZW47XG4gIHYuYW5nID0gTWF0aC5hdGFuMih2Lm55LCB2Lm54KTtcbn07XG52YXIgaW52ZXJ0VmVjID0gZnVuY3Rpb24gaW52ZXJ0VmVjKG9yaWdpbmFsViwgaW52ZXJ0ZWRWKSB7XG4gIGludmVydGVkVi54ID0gb3JpZ2luYWxWLnggKiAtMTtcbiAgaW52ZXJ0ZWRWLnkgPSBvcmlnaW5hbFYueSAqIC0xO1xuICBpbnZlcnRlZFYubnggPSBvcmlnaW5hbFYubnggKiAtMTtcbiAgaW52ZXJ0ZWRWLm55ID0gb3JpZ2luYWxWLm55ICogLTE7XG4gIGludmVydGVkVi5hbmcgPSBvcmlnaW5hbFYuYW5nID4gMCA/IC0oTWF0aC5QSSAtIG9yaWdpbmFsVi5hbmcpIDogTWF0aC5QSSArIG9yaWdpbmFsVi5hbmc7XG59O1xudmFyIGNhbGNDb3JuZXJBcmMgPSBmdW5jdGlvbiBjYWxjQ29ybmVyQXJjKHByZXZpb3VzUG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50LCByYWRpdXNNYXgsIGlzQXJjUmFkaXVzKSB7XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUGFydCAxXG4gIHByZXZpb3VzUG9pbnQgIT09IGxhc3RQb2ludCA/IGFzVmVjKGN1cnJlbnRQb2ludCwgcHJldmlvdXNQb2ludCwgdjEpIDogaW52ZXJ0VmVjKHYyLCB2MSk7IC8vIEF2b2lkIHJlY2FsY3VsYXRpbmcgdmVjIGlmIGl0IGlzIHRoZSBpbnZlcnQgb2YgdGhlIGxhc3Qgb25lIGNhbGN1bGF0ZWRcbiAgYXNWZWMoY3VycmVudFBvaW50LCBuZXh0UG9pbnQsIHYyKTtcbiAgc2luQSA9IHYxLm54ICogdjIubnkgLSB2MS5ueSAqIHYyLm54O1xuICBzaW5BOTAgPSB2MS5ueCAqIHYyLm54IC0gdjEubnkgKiAtdjIubnk7XG4gIGFuZ2xlID0gTWF0aC5hc2luKE1hdGgubWF4KC0xLCBNYXRoLm1pbigxLCBzaW5BKSkpO1xuICBpZiAoTWF0aC5hYnMoYW5nbGUpIDwgMWUtNikge1xuICAgIHggPSBjdXJyZW50UG9pbnQueDtcbiAgICB5ID0gY3VycmVudFBvaW50Lnk7XG4gICAgY1JhZGl1cyA9IHJhZGl1cyA9IDA7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcmFkRGlyZWN0aW9uID0gMTtcbiAgZHJhd0RpcmVjdGlvbiA9IGZhbHNlO1xuICBpZiAoc2luQTkwIDwgMCkge1xuICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgIGFuZ2xlID0gTWF0aC5QSSArIGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IE1hdGguUEkgLSBhbmdsZTtcbiAgICAgIHJhZERpcmVjdGlvbiA9IC0xO1xuICAgICAgZHJhd0RpcmVjdGlvbiA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChhbmdsZSA+IDApIHtcbiAgICAgIHJhZERpcmVjdGlvbiA9IC0xO1xuICAgICAgZHJhd0RpcmVjdGlvbiA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjdXJyZW50UG9pbnQucmFkaXVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByYWRpdXMgPSBjdXJyZW50UG9pbnQucmFkaXVzO1xuICB9IGVsc2Uge1xuICAgIHJhZGl1cyA9IHJhZGl1c01heDtcbiAgfVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBhcnQgMlxuICBoYWxmQW5nbGUgPSBhbmdsZSAvIDI7XG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBsaW1pdCA9IE1hdGgubWluKHYxLmxlbiAvIDIsIHYyLmxlbiAvIDIpO1xuICBpZiAoaXNBcmNSYWRpdXMpIHtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUGFydCAzXG4gICAgbGVuT3V0ID0gTWF0aC5hYnMoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIHJhZGl1cyAvIE1hdGguc2luKGhhbGZBbmdsZSkpO1xuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFNwZWNpYWwgcGFydCBBXG4gICAgaWYgKGxlbk91dCA+IGxpbWl0KSB7XG4gICAgICBsZW5PdXQgPSBsaW1pdDtcbiAgICAgIGNSYWRpdXMgPSBNYXRoLmFicyhsZW5PdXQgKiBNYXRoLnNpbihoYWxmQW5nbGUpIC8gTWF0aC5jb3MoaGFsZkFuZ2xlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNSYWRpdXMgPSByYWRpdXM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlbk91dCA9IE1hdGgubWluKGxpbWl0LCByYWRpdXMpO1xuICAgIGNSYWRpdXMgPSBNYXRoLmFicyhsZW5PdXQgKiBNYXRoLnNpbihoYWxmQW5nbGUpIC8gTWF0aC5jb3MoaGFsZkFuZ2xlKSk7XG4gIH1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUGFydCA0XG4gIHN0b3BYID0gY3VycmVudFBvaW50LnggKyB2Mi5ueCAqIGxlbk91dDtcbiAgc3RvcFkgPSBjdXJyZW50UG9pbnQueSArIHYyLm55ICogbGVuT3V0O1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFBhcnQgNVxuICB4ID0gc3RvcFggLSB2Mi5ueSAqIGNSYWRpdXMgKiByYWREaXJlY3Rpb247XG4gIHkgPSBzdG9wWSArIHYyLm54ICogY1JhZGl1cyAqIHJhZERpcmVjdGlvbjtcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBZGRpdGlvbmFsIFBhcnQgOiBjYWxjdWxhdGUgc3RhcnQgcG9pbnQgRVxuICBzdGFydFggPSBjdXJyZW50UG9pbnQueCArIHYxLm54ICogbGVuT3V0O1xuICBzdGFydFkgPSBjdXJyZW50UG9pbnQueSArIHYxLm55ICogbGVuT3V0O1xuXG4gIC8vIFNhdmUgbGFzdCBwb2ludCB0byBhdm9pZCByZWNhbGN1bGF0aW5nIHZlY3RvciB3aGVuIG5vdCBuZWVkZWRcbiAgbGFzdFBvaW50ID0gY3VycmVudFBvaW50O1xufTtcblxuLyoqXG4gKiBEcmF3IGNvcm5lciBwcm92aWRlZCBieSB7QGxpbmsgZ2V0Um91bmRDb3JuZXJ9XG4gKlxuICogQHBhcmFtIGN0eCA6Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG4gKiBAcGFyYW0gcm91bmRDb3JuZXIge3tjeDpudW1iZXIsIGN5Om51bWJlciwgcmFkaXVzOm51bWJlciwgZW5kQW5nbGU6IG51bWJlciwgc3RhcnRBbmdsZTogbnVtYmVyLCBjb3VudGVyQ2xvY2t3aXNlOiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gZHJhd1ByZXBhcmVkUm91bmRDb3JuZXIoY3R4LCByb3VuZENvcm5lcikge1xuICBpZiAocm91bmRDb3JuZXIucmFkaXVzID09PSAwKSBjdHgubGluZVRvKHJvdW5kQ29ybmVyLmN4LCByb3VuZENvcm5lci5jeSk7ZWxzZSBjdHguYXJjKHJvdW5kQ29ybmVyLmN4LCByb3VuZENvcm5lci5jeSwgcm91bmRDb3JuZXIucmFkaXVzLCByb3VuZENvcm5lci5zdGFydEFuZ2xlLCByb3VuZENvcm5lci5lbmRBbmdsZSwgcm91bmRDb3JuZXIuY291bnRlckNsb2Nrd2lzZSk7XG59XG5cbi8qKlxuICogR2V0IHJvdW5kIGNvcm5lciBmcm9tIGEgcG9pbnQgYW5kIGl0cyBwcmV2aW91cyBhbmQgbmV4dCBuZWlnaGJvdXJzIGluIGEgcGF0aFxuICpcbiAqIEBwYXJhbSBwcmV2aW91c1BvaW50IHt7eDogbnVtYmVyLCB5Om51bWJlciwgcmFkaXVzOiBudW1iZXI/fX1cbiAqIEBwYXJhbSBjdXJyZW50UG9pbnQge3t4OiBudW1iZXIsIHk6bnVtYmVyLCByYWRpdXM6IG51bWJlcj99fVxuICogQHBhcmFtIG5leHRQb2ludCB7e3g6IG51bWJlciwgeTpudW1iZXIsIHJhZGl1czogbnVtYmVyP319XG4gKiBAcGFyYW0gcmFkaXVzTWF4IDpudW1iZXJcbiAqIEBwYXJhbSBpc0FyY1JhZGl1cyA6Ym9vbGVhblxuICogQHJldHVybiB7e1xuICogY3g6bnVtYmVyLCBjeTpudW1iZXIsIHJhZGl1czpudW1iZXIsXG4gKiBzdGFydFg6bnVtYmVyLCBzdGFydFk6bnVtYmVyLFxuICogc3RvcFg6bnVtYmVyLCBzdG9wWTogbnVtYmVyLFxuICogZW5kQW5nbGU6IG51bWJlciwgc3RhcnRBbmdsZTogbnVtYmVyLCBjb3VudGVyQ2xvY2t3aXNlOiBib29sZWFuXG4gKiB9fVxuICovXG5mdW5jdGlvbiBnZXRSb3VuZENvcm5lcihwcmV2aW91c1BvaW50LCBjdXJyZW50UG9pbnQsIG5leHRQb2ludCwgcmFkaXVzTWF4KSB7XG4gIHZhciBpc0FyY1JhZGl1cyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgaWYgKHJhZGl1c01heCA9PT0gMCB8fCBjdXJyZW50UG9pbnQucmFkaXVzID09PSAwKSByZXR1cm4ge1xuICAgIGN4OiBjdXJyZW50UG9pbnQueCxcbiAgICBjeTogY3VycmVudFBvaW50LnksXG4gICAgcmFkaXVzOiAwLFxuICAgIHN0YXJ0WDogY3VycmVudFBvaW50LngsXG4gICAgc3RhcnRZOiBjdXJyZW50UG9pbnQueSxcbiAgICBzdG9wWDogY3VycmVudFBvaW50LngsXG4gICAgc3RvcFk6IGN1cnJlbnRQb2ludC55LFxuICAgIHN0YXJ0QW5nbGU6IHVuZGVmaW5lZCxcbiAgICBlbmRBbmdsZTogdW5kZWZpbmVkLFxuICAgIGNvdW50ZXJDbG9ja3dpc2U6IHVuZGVmaW5lZFxuICB9O1xuICBjYWxjQ29ybmVyQXJjKHByZXZpb3VzUG9pbnQsIGN1cnJlbnRQb2ludCwgbmV4dFBvaW50LCByYWRpdXNNYXgsIGlzQXJjUmFkaXVzKTtcbiAgcmV0dXJuIHtcbiAgICBjeDogeCxcbiAgICBjeTogeSxcbiAgICByYWRpdXM6IGNSYWRpdXMsXG4gICAgc3RhcnRYOiBzdGFydFgsXG4gICAgc3RhcnRZOiBzdGFydFksXG4gICAgc3RvcFg6IHN0b3BYLFxuICAgIHN0b3BZOiBzdG9wWSxcbiAgICBzdGFydEFuZ2xlOiB2MS5hbmcgKyBNYXRoLlBJIC8gMiAqIHJhZERpcmVjdGlvbixcbiAgICBlbmRBbmdsZTogdjIuYW5nIC0gTWF0aC5QSSAvIDIgKiByYWREaXJlY3Rpb24sXG4gICAgY291bnRlckNsb2Nrd2lzZTogZHJhd0RpcmVjdGlvblxuICB9O1xufVxuXG52YXIgQVZPSURfSU1QT1NTSUJMRV9CRVpJRVJfQ09OU1RBTlQgPSAwLjAxO1xudmFyIEFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UX0wgPSBNYXRoLnNxcnQoMiAqIEFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UKTtcbnZhciBCUnAkYyA9IHt9O1xuQlJwJGMuZmluZE1pZHB0UHRzRXRjID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgaW50ZXJzZWN0aW9uUHRzID0gcGFpckluZm8uaW50ZXJzZWN0aW9uUHRzLFxuICAgIHZlY3Rvck5vcm1JbnZlcnNlID0gcGFpckluZm8udmVjdG9yTm9ybUludmVyc2U7XG4gIHZhciBtaWRwdFB0cztcblxuICAvLyBuLmIuIGFzc3VtZXMgYWxsIGVkZ2VzIGluIGJlemllciBidW5kbGUgaGF2ZSBzYW1lIGVuZHBvaW50cyBzcGVjaWZpZWRcbiAgdmFyIHNyY01hbkVuZHB0ID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1lbmRwb2ludCcpO1xuICB2YXIgdGd0TWFuRW5kcHQgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWVuZHBvaW50Jyk7XG4gIHZhciBoYXZlTWFudWFsRW5kUHRzID0gc3JjTWFuRW5kcHQudW5pdHMgIT0gbnVsbCAmJiB0Z3RNYW5FbmRwdC51bml0cyAhPSBudWxsO1xuICB2YXIgcmVjYWxjVmVjdG9yTm9ybUludmVyc2UgPSBmdW5jdGlvbiByZWNhbGNWZWN0b3JOb3JtSW52ZXJzZSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBkeSA9IHkyIC0geTE7XG4gICAgdmFyIGR4ID0geDIgLSB4MTtcbiAgICB2YXIgbCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IC1keSAvIGwsXG4gICAgICB5OiBkeCAvIGxcbiAgICB9O1xuICB9O1xuICB2YXIgZWRnZURpc3RhbmNlcyA9IGVkZ2UucHN0eWxlKCdlZGdlLWRpc3RhbmNlcycpLnZhbHVlO1xuICBzd2l0Y2ggKGVkZ2VEaXN0YW5jZXMpIHtcbiAgICBjYXNlICdub2RlLXBvc2l0aW9uJzpcbiAgICAgIG1pZHB0UHRzID0gcG9zUHRzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW50ZXJzZWN0aW9uJzpcbiAgICAgIG1pZHB0UHRzID0gaW50ZXJzZWN0aW9uUHRzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kcG9pbnRzJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGhhdmVNYW51YWxFbmRQdHMpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkbWFudWFsRW5kcHRUb1B4ID0gdGhpcy5tYW51YWxFbmRwdFRvUHgoZWRnZS5zb3VyY2UoKVswXSwgc3JjTWFuRW5kcHQpLFxuICAgICAgICAgICAgX3RoaXMkbWFudWFsRW5kcHRUb1B4MiA9IF9zbGljZWRUb0FycmF5KF90aGlzJG1hbnVhbEVuZHB0VG9QeCwgMiksXG4gICAgICAgICAgICB4MSA9IF90aGlzJG1hbnVhbEVuZHB0VG9QeDJbMF0sXG4gICAgICAgICAgICB5MSA9IF90aGlzJG1hbnVhbEVuZHB0VG9QeDJbMV07XG4gICAgICAgICAgdmFyIF90aGlzJG1hbnVhbEVuZHB0VG9QeDMgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeChlZGdlLnRhcmdldCgpWzBdLCB0Z3RNYW5FbmRwdCksXG4gICAgICAgICAgICBfdGhpcyRtYW51YWxFbmRwdFRvUHg0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkbWFudWFsRW5kcHRUb1B4MywgMiksXG4gICAgICAgICAgICB4MiA9IF90aGlzJG1hbnVhbEVuZHB0VG9QeDRbMF0sXG4gICAgICAgICAgICB5MiA9IF90aGlzJG1hbnVhbEVuZHB0VG9QeDRbMV07XG4gICAgICAgICAgdmFyIGVuZFB0cyA9IHtcbiAgICAgICAgICAgIHgxOiB4MSxcbiAgICAgICAgICAgIHkxOiB5MSxcbiAgICAgICAgICAgIHgyOiB4MixcbiAgICAgICAgICAgIHkyOiB5MlxuICAgICAgICAgIH07XG4gICAgICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSByZWNhbGNWZWN0b3JOb3JtSW52ZXJzZSh4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgbWlkcHRQdHMgPSBlbmRQdHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihcIkVkZ2UgXCIuY29uY2F0KGVkZ2UuaWQoKSwgXCIgaGFzIGVkZ2UtZGlzdGFuY2VzOmVuZHBvaW50cyBzcGVjaWZpZWQgd2l0aG91dCBtYW51YWwgZW5kcG9pbnRzIHNwZWNpZmllZCB2aWEgc291cmNlLWVuZHBvaW50IGFuZCB0YXJnZXQtZW5kcG9pbnQuICBGYWxsaW5nIGJhY2sgb24gZWRnZS1kaXN0YW5jZXM6aW50ZXJzZWN0aW9uIChkZWZhdWx0KS5cIikpO1xuICAgICAgICAgIG1pZHB0UHRzID0gaW50ZXJzZWN0aW9uUHRzOyAvLyBiYWNrIHRvIGRlZmF1bHRcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1pZHB0UHRzOiBtaWRwdFB0cyxcbiAgICB2ZWN0b3JOb3JtSW52ZXJzZTogdmVjdG9yTm9ybUludmVyc2VcbiAgfTtcbn07XG5CUnAkYy5maW5kSGF5c3RhY2tQb2ludHMgPSBmdW5jdGlvbiAoZWRnZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICBpZiAoIXJzLmhheXN0YWNrKSB7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICBycy5zb3VyY2UgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgICAgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMiAqIE1hdGguUEk7XG4gICAgICBycy50YXJnZXQgPSB7XG4gICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgdmFyIHNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RQb3MgPSB0Z3QucG9zaXRpb24oKTtcbiAgICB2YXIgc3JjVyA9IHNyYy53aWR0aCgpO1xuICAgIHZhciB0Z3RXID0gdGd0LndpZHRoKCk7XG4gICAgdmFyIHNyY0ggPSBzcmMuaGVpZ2h0KCk7XG4gICAgdmFyIHRndEggPSB0Z3QuaGVpZ2h0KCk7XG4gICAgdmFyIHJhZGl1cyA9IGVkZ2UucHN0eWxlKCdoYXlzdGFjay1yYWRpdXMnKS52YWx1ZTtcbiAgICB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cyAvIDI7IC8vIGIvYyBoYXZlIHRvIGhhbGYgd2lkdGgvaGVpZ2h0XG5cbiAgICBycy5oYXlzdGFja1B0cyA9IHJzLmFsbHB0cyA9IFtycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzICsgc3JjUG9zLngsIHJzLnNvdXJjZS55ICogc3JjSCAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueSwgcnMudGFyZ2V0LnggKiB0Z3RXICogaGFsZlJhZGl1cyArIHRndFBvcy54LCBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzICsgdGd0UG9zLnldO1xuICAgIHJzLm1pZFggPSAocnMuYWxscHRzWzBdICsgcnMuYWxscHRzWzJdKSAvIDI7XG4gICAgcnMubWlkWSA9IChycy5hbGxwdHNbMV0gKyBycy5hbGxwdHNbM10pIC8gMjtcblxuICAgIC8vIGFsd2F5cyBvdmVycmlkZSBhcyBoYXlzdGFjayBpbiBjYXNlIHNldCB0byBkaWZmZXJlbnQgdHlwZSBwcmV2aW91c2x5XG4gICAgcnMuZWRnZVR5cGUgPSAnaGF5c3RhY2snO1xuICAgIHJzLmhheXN0YWNrID0gdHJ1ZTtcbiAgICB0aGlzLnN0b3JlRWRnZVByb2plY3Rpb25zKGVkZ2UpO1xuICAgIHRoaXMuY2FsY3VsYXRlQXJyb3dBbmdsZXMoZWRnZSk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zKGVkZ2UpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMoZWRnZSk7XG4gIH1cbn07XG5CUnAkYy5maW5kU2VnbWVudHNQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSwgcGFpckluZm8pIHtcbiAgLy8gU2VnbWVudHMgKG11bHRpcGxlIHN0cmFpZ2h0IGxpbmVzKVxuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBzZWdtZW50V3MgPSBlZGdlLnBzdHlsZSgnc2VnbWVudC13ZWlnaHRzJyk7XG4gIHZhciBzZWdtZW50RHMgPSBlZGdlLnBzdHlsZSgnc2VnbWVudC1kaXN0YW5jZXMnKTtcbiAgdmFyIHNlZ21lbnRScyA9IGVkZ2UucHN0eWxlKCdzZWdtZW50LXJhZGlpJyk7XG4gIHZhciBzZWdtZW50VHMgPSBlZGdlLnBzdHlsZSgncmFkaXVzLXR5cGUnKTtcbiAgdmFyIHNlZ21lbnRzTiA9IE1hdGgubWluKHNlZ21lbnRXcy5wZlZhbHVlLmxlbmd0aCwgc2VnbWVudERzLnBmVmFsdWUubGVuZ3RoKTtcbiAgdmFyIGxhc3RSYWRpdXMgPSBzZWdtZW50UnMucGZWYWx1ZVtzZWdtZW50UnMucGZWYWx1ZS5sZW5ndGggLSAxXTtcbiAgdmFyIGxhc3RSYWRpdXNUeXBlID0gc2VnbWVudFRzLnBmVmFsdWVbc2VnbWVudFRzLnBmVmFsdWUubGVuZ3RoIC0gMV07XG4gIHJzLmVkZ2VUeXBlID0gJ3NlZ21lbnRzJztcbiAgcnMuc2VncHRzID0gW107XG4gIHJzLnJhZGlpID0gW107XG4gIHJzLmlzQXJjUmFkaXVzID0gW107XG4gIGZvciAodmFyIHMgPSAwOyBzIDwgc2VnbWVudHNOOyBzKyspIHtcbiAgICB2YXIgdyA9IHNlZ21lbnRXcy5wZlZhbHVlW3NdO1xuICAgIHZhciBkID0gc2VnbWVudERzLnBmVmFsdWVbc107XG4gICAgdmFyIHcxID0gMSAtIHc7XG4gICAgdmFyIHcyID0gdztcbiAgICB2YXIgX3RoaXMkZmluZE1pZHB0UHRzRXRjID0gdGhpcy5maW5kTWlkcHRQdHNFdGMoZWRnZSwgcGFpckluZm8pLFxuICAgICAgbWlkcHRQdHMgPSBfdGhpcyRmaW5kTWlkcHRQdHNFdGMubWlkcHRQdHMsXG4gICAgICB2ZWN0b3JOb3JtSW52ZXJzZSA9IF90aGlzJGZpbmRNaWRwdFB0c0V0Yy52ZWN0b3JOb3JtSW52ZXJzZTtcbiAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICB9O1xuICAgIHJzLnNlZ3B0cy5wdXNoKGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkLCBhZGp1c3RlZE1pZHB0LnkgKyB2ZWN0b3JOb3JtSW52ZXJzZS55ICogZCk7XG4gICAgcnMucmFkaWkucHVzaChzZWdtZW50UnMucGZWYWx1ZVtzXSAhPT0gdW5kZWZpbmVkID8gc2VnbWVudFJzLnBmVmFsdWVbc10gOiBsYXN0UmFkaXVzKTtcbiAgICBycy5pc0FyY1JhZGl1cy5wdXNoKChzZWdtZW50VHMucGZWYWx1ZVtzXSAhPT0gdW5kZWZpbmVkID8gc2VnbWVudFRzLnBmVmFsdWVbc10gOiBsYXN0UmFkaXVzVHlwZSkgPT09ICdhcmMtcmFkaXVzJyk7XG4gIH1cbn07XG5CUnAkYy5maW5kTG9vcFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbywgaSwgZWRnZUlzVW5idW5kbGVkKSB7XG4gIC8vIFNlbGYtZWRnZVxuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBkaXJDb3VudHMgPSBwYWlySW5mby5kaXJDb3VudHMsXG4gICAgc3JjUG9zID0gcGFpckluZm8uc3JjUG9zO1xuICB2YXIgY3RybHB0RGlzdHMgPSBlZGdlLnBzdHlsZSgnY29udHJvbC1wb2ludC1kaXN0YW5jZXMnKTtcbiAgdmFyIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbMF0gOiB1bmRlZmluZWQ7XG4gIHZhciBsb29wRGlyID0gZWRnZS5wc3R5bGUoJ2xvb3AtZGlyZWN0aW9uJykucGZWYWx1ZTtcbiAgdmFyIGxvb3BTd3AgPSBlZGdlLnBzdHlsZSgnbG9vcC1zd2VlcCcpLnBmVmFsdWU7XG4gIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gIHJzLmVkZ2VUeXBlID0gJ3NlbGYnO1xuICB2YXIgaiA9IGk7XG4gIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgaiA9IDA7XG4gICAgbG9vcERpc3QgPSBjdHJscHREaXN0O1xuICB9XG4gIHZhciBsb29wQW5nbGUgPSBsb29wRGlyIC0gTWF0aC5QSSAvIDI7XG4gIHZhciBvdXRBbmdsZSA9IGxvb3BBbmdsZSAtIGxvb3BTd3AgLyAyO1xuICB2YXIgaW5BbmdsZSA9IGxvb3BBbmdsZSArIGxvb3BTd3AgLyAyO1xuXG4gIC8vIGluY3JlYXNlIGJ5IHN0ZXAgc2l6ZSBmb3Igb3ZlcmxhcHBpbmcgbG9vcHMsIGtleWVkIG9uIGRpcmVjdGlvbiBhbmQgc3dlZXAgdmFsdWVzXG4gIHZhciBkYyA9IFN0cmluZyhsb29wRGlyICsgJ18nICsgbG9vcFN3cCk7XG4gIGogPSBkaXJDb3VudHNbZGNdID09PSB1bmRlZmluZWQgPyBkaXJDb3VudHNbZGNdID0gMCA6ICsrZGlyQ291bnRzW2RjXTtcbiAgcnMuY3RybHB0cyA9IFtzcmNQb3MueCArIE1hdGguY29zKG91dEFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy55ICsgTWF0aC5zaW4ob3V0QW5nbGUpICogMS40ICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSwgc3JjUG9zLnggKyBNYXRoLmNvcyhpbkFuZ2xlKSAqIDEuNCAqIGxvb3BEaXN0ICogKGogLyAzICsgMSksIHNyY1Bvcy55ICsgTWF0aC5zaW4oaW5BbmdsZSkgKiAxLjQgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpXTtcbn07XG5CUnAkYy5maW5kQ29tcG91bmRMb29wUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgLy8gQ29tcG91bmQgZWRnZVxuXG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHJzLmVkZ2VUeXBlID0gJ2NvbXBvdW5kJztcbiAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyxcbiAgICB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MsXG4gICAgc3JjVyA9IHBhaXJJbmZvLnNyY1csXG4gICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgdGd0SCA9IHBhaXJJbmZvLnRndEg7XG4gIHZhciBzdGVwU2l6ZSA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScpLnBmVmFsdWU7XG4gIHZhciBjdHJscHREaXN0cyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LWRpc3RhbmNlcycpO1xuICB2YXIgY3RybHB0RGlzdCA9IGN0cmxwdERpc3RzID8gY3RybHB0RGlzdHMucGZWYWx1ZVswXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGogPSBpO1xuICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcbiAgaWYgKGVkZ2VJc1VuYnVuZGxlZCkge1xuICAgIGogPSAwO1xuICAgIGxvb3BEaXN0ID0gY3RybHB0RGlzdDtcbiAgfVxuICB2YXIgbG9vcFcgPSA1MDtcbiAgdmFyIGxvb3BhUG9zID0ge1xuICAgIHg6IHNyY1Bvcy54IC0gc3JjVyAvIDIsXG4gICAgeTogc3JjUG9zLnkgLSBzcmNIIC8gMlxuICB9O1xuICB2YXIgbG9vcGJQb3MgPSB7XG4gICAgeDogdGd0UG9zLnggLSB0Z3RXIC8gMixcbiAgICB5OiB0Z3RQb3MueSAtIHRndEggLyAyXG4gIH07XG4gIHZhciBsb29wUG9zID0ge1xuICAgIHg6IE1hdGgubWluKGxvb3BhUG9zLngsIGxvb3BiUG9zLngpLFxuICAgIHk6IE1hdGgubWluKGxvb3BhUG9zLnksIGxvb3BiUG9zLnkpXG4gIH07XG5cbiAgLy8gYXZvaWRzIGNhc2VzIHdpdGggaW1wb3NzaWJsZSBiZXppZXJzXG4gIHZhciBtaW5Db21wb3VuZFN0cmV0Y2ggPSAwLjU7XG4gIHZhciBjb21wb3VuZFN0cmV0Y2hBID0gTWF0aC5tYXgobWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyhzcmNXICogQVZPSURfSU1QT1NTSUJMRV9CRVpJRVJfQ09OU1RBTlQpKTtcbiAgdmFyIGNvbXBvdW5kU3RyZXRjaEIgPSBNYXRoLm1heChtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKHRndFcgKiBBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVCkpO1xuICBycy5jdHJscHRzID0gW2xvb3BQb3MueCwgbG9vcFBvcy55IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIGNvbXBvdW5kU3RyZXRjaEEsIGxvb3BQb3MueCAtICgxICsgTWF0aC5wb3cobG9vcFcsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSkgKiBjb21wb3VuZFN0cmV0Y2hCLCBsb29wUG9zLnldO1xufTtcbkJScCRjLmZpbmRTdHJhaWdodEVkZ2VQb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAvLyBTdHJhaWdodCBlZGdlIHdpdGhpbiBidW5kbGVcblxuICBlZGdlLl9wcml2YXRlLnJzY3JhdGNoLmVkZ2VUeXBlID0gJ3N0cmFpZ2h0Jztcbn07XG5CUnAkYy5maW5kQmV6aWVyUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvLCBpLCBlZGdlSXNVbmJ1bmRsZWQsIGVkZ2VJc1N3YXBwZWQpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIHN0ZXBTaXplID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJykucGZWYWx1ZTtcbiAgdmFyIGN0cmxwdERpc3RzID0gZWRnZS5wc3R5bGUoJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2VzJyk7XG4gIHZhciBjdHJscHRXcyA9IGVkZ2UucHN0eWxlKCdjb250cm9sLXBvaW50LXdlaWdodHMnKTtcbiAgdmFyIGJlemllck4gPSBjdHJscHREaXN0cyAmJiBjdHJscHRXcyA/IE1hdGgubWluKGN0cmxwdERpc3RzLnZhbHVlLmxlbmd0aCwgY3RybHB0V3MudmFsdWUubGVuZ3RoKSA6IDE7XG4gIHZhciBjdHJscHREaXN0ID0gY3RybHB0RGlzdHMgPyBjdHJscHREaXN0cy5wZlZhbHVlWzBdIDogdW5kZWZpbmVkO1xuICB2YXIgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbMF07XG5cbiAgLy8gKE11bHRpKWJlemllclxuXG4gIHZhciBtdWx0aSA9IGVkZ2VJc1VuYnVuZGxlZDtcbiAgcnMuZWRnZVR5cGUgPSBtdWx0aSA/ICdtdWx0aWJlemllcicgOiAnYmV6aWVyJztcbiAgcnMuY3RybHB0cyA9IFtdO1xuICBmb3IgKHZhciBiID0gMDsgYiA8IGJlemllck47IGIrKykge1xuICAgIHZhciBub3JtY3RybHB0RGlzdCA9ICgwLjUgLSBwYWlySW5mby5lbGVzLmxlbmd0aCAvIDIgKyBpKSAqIHN0ZXBTaXplICogKGVkZ2VJc1N3YXBwZWQgPyAtMSA6IDEpO1xuICAgIHZhciBtYW5jdHJscHREaXN0ID0gdW5kZWZpbmVkO1xuICAgIHZhciBzaWduID0gc2lnbnVtKG5vcm1jdHJscHREaXN0KTtcbiAgICBpZiAobXVsdGkpIHtcbiAgICAgIGN0cmxwdERpc3QgPSBjdHJscHREaXN0cyA/IGN0cmxwdERpc3RzLnBmVmFsdWVbYl0gOiBzdGVwU2l6ZTsgLy8gZmFsbCBiYWNrIG9uIHN0ZXAgc2l6ZVxuICAgICAgY3RybHB0V2VpZ2h0ID0gY3RybHB0V3MudmFsdWVbYl07XG4gICAgfVxuICAgIGlmIChlZGdlSXNVbmJ1bmRsZWQpIHtcbiAgICAgIC8vIG11bHRpIG9yIHNpbmdsZSB1bmJ1bmRsZWRcbiAgICAgIG1hbmN0cmxwdERpc3QgPSBjdHJscHREaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBtYW5jdHJscHREaXN0ID0gY3RybHB0RGlzdCAhPT0gdW5kZWZpbmVkID8gc2lnbiAqIGN0cmxwdERpc3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBkaXN0YW5jZUZyb21NaWRwb2ludCA9IG1hbmN0cmxwdERpc3QgIT09IHVuZGVmaW5lZCA/IG1hbmN0cmxwdERpc3QgOiBub3JtY3RybHB0RGlzdDtcbiAgICB2YXIgdzEgPSAxIC0gY3RybHB0V2VpZ2h0O1xuICAgIHZhciB3MiA9IGN0cmxwdFdlaWdodDtcbiAgICB2YXIgX3RoaXMkZmluZE1pZHB0UHRzRXRjMiA9IHRoaXMuZmluZE1pZHB0UHRzRXRjKGVkZ2UsIHBhaXJJbmZvKSxcbiAgICAgIG1pZHB0UHRzID0gX3RoaXMkZmluZE1pZHB0UHRzRXRjMi5taWRwdFB0cyxcbiAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0gX3RoaXMkZmluZE1pZHB0UHRzRXRjMi52ZWN0b3JOb3JtSW52ZXJzZTtcbiAgICB2YXIgYWRqdXN0ZWRNaWRwdCA9IHtcbiAgICAgIHg6IG1pZHB0UHRzLngxICogdzEgKyBtaWRwdFB0cy54MiAqIHcyLFxuICAgICAgeTogbWlkcHRQdHMueTEgKiB3MSArIG1pZHB0UHRzLnkyICogdzJcbiAgICB9O1xuICAgIHJzLmN0cmxwdHMucHVzaChhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQsIGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkaXN0YW5jZUZyb21NaWRwb2ludCk7XG4gIH1cbn07XG5CUnAkYy5maW5kVGF4aVBvaW50cyA9IGZ1bmN0aW9uIChlZGdlLCBwYWlySW5mbykge1xuICAvLyBUYXhpY2FiIGdlb21ldHJ5IHdpdGggdHdvIHR1cm5zIG1heGltdW1cblxuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICBycy5lZGdlVHlwZSA9ICdzZWdtZW50cyc7XG4gIHZhciBWRVJUSUNBTCA9ICd2ZXJ0aWNhbCc7XG4gIHZhciBIT1JJWk9OVEFMID0gJ2hvcml6b250YWwnO1xuICB2YXIgTEVGVFdBUkQgPSAnbGVmdHdhcmQnO1xuICB2YXIgUklHSFRXQVJEID0gJ3JpZ2h0d2FyZCc7XG4gIHZhciBET1dOV0FSRCA9ICdkb3dud2FyZCc7XG4gIHZhciBVUFdBUkQgPSAndXB3YXJkJztcbiAgdmFyIEFVVE8gPSAnYXV0byc7XG4gIHZhciBwb3NQdHMgPSBwYWlySW5mby5wb3NQdHMsXG4gICAgc3JjVyA9IHBhaXJJbmZvLnNyY1csXG4gICAgc3JjSCA9IHBhaXJJbmZvLnNyY0gsXG4gICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgdGd0SCA9IHBhaXJJbmZvLnRndEg7XG4gIHZhciBlZGdlRGlzdGFuY2VzID0gZWRnZS5wc3R5bGUoJ2VkZ2UtZGlzdGFuY2VzJykudmFsdWU7XG4gIHZhciBkSW5jbHVkZXNOb2RlQm9keSA9IGVkZ2VEaXN0YW5jZXMgIT09ICdub2RlLXBvc2l0aW9uJztcbiAgdmFyIHRheGlEaXIgPSBlZGdlLnBzdHlsZSgndGF4aS1kaXJlY3Rpb24nKS52YWx1ZTtcbiAgdmFyIHJhd1RheGlEaXIgPSB0YXhpRGlyOyAvLyB1bnByb2Nlc3NlZCB2YWx1ZVxuICB2YXIgdGF4aVR1cm4gPSBlZGdlLnBzdHlsZSgndGF4aS10dXJuJyk7XG4gIHZhciB0dXJuSXNQZXJjZW50ID0gdGF4aVR1cm4udW5pdHMgPT09ICclJztcbiAgdmFyIHRheGlUdXJuUGZWYWwgPSB0YXhpVHVybi5wZlZhbHVlO1xuICB2YXIgdHVybklzTmVnYXRpdmUgPSB0YXhpVHVyblBmVmFsIDwgMDsgLy8gaS5lLiBmcm9tIHRhcmdldCBzaWRlXG4gIHZhciBtaW5EID0gZWRnZS5wc3R5bGUoJ3RheGktdHVybi1taW4tZGlzdGFuY2UnKS5wZlZhbHVlO1xuICB2YXIgZHcgPSBkSW5jbHVkZXNOb2RlQm9keSA/IChzcmNXICsgdGd0VykgLyAyIDogMDtcbiAgdmFyIGRoID0gZEluY2x1ZGVzTm9kZUJvZHkgPyAoc3JjSCArIHRndEgpIC8gMiA6IDA7XG4gIHZhciBwZHggPSBwb3NQdHMueDIgLSBwb3NQdHMueDE7XG4gIHZhciBwZHkgPSBwb3NQdHMueTIgLSBwb3NQdHMueTE7XG5cbiAgLy8gdGFrZSBhd2F5IHRoZSBlZmZlY3RpdmUgdy9oIGZyb20gdGhlIG1hZ25pdHVkZSBvZiB0aGUgZGVsdGEgdmFsdWVcbiAgdmFyIHN1YkRXSCA9IGZ1bmN0aW9uIHN1YkRXSChkeHksIGR3aCkge1xuICAgIGlmIChkeHkgPiAwKSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoZHh5IC0gZHdoLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgubWluKGR4eSArIGR3aCwgMCk7XG4gICAgfVxuICB9O1xuICB2YXIgZHggPSBzdWJEV0gocGR4LCBkdyk7XG4gIHZhciBkeSA9IHN1YkRXSChwZHksIGRoKTtcbiAgdmFyIGlzRXhwbGljaXREaXIgPSBmYWxzZTtcbiAgaWYgKHJhd1RheGlEaXIgPT09IEFVVE8pIHtcbiAgICB0YXhpRGlyID0gTWF0aC5hYnMoZHgpID4gTWF0aC5hYnMoZHkpID8gSE9SSVpPTlRBTCA6IFZFUlRJQ0FMO1xuICB9IGVsc2UgaWYgKHJhd1RheGlEaXIgPT09IFVQV0FSRCB8fCByYXdUYXhpRGlyID09PSBET1dOV0FSRCkge1xuICAgIHRheGlEaXIgPSBWRVJUSUNBTDtcbiAgICBpc0V4cGxpY2l0RGlyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChyYXdUYXhpRGlyID09PSBMRUZUV0FSRCB8fCByYXdUYXhpRGlyID09PSBSSUdIVFdBUkQpIHtcbiAgICB0YXhpRGlyID0gSE9SSVpPTlRBTDtcbiAgICBpc0V4cGxpY2l0RGlyID0gdHJ1ZTtcbiAgfVxuICB2YXIgaXNWZXJ0ID0gdGF4aURpciA9PT0gVkVSVElDQUw7XG4gIHZhciBsID0gaXNWZXJ0ID8gZHkgOiBkeDtcbiAgdmFyIHBsID0gaXNWZXJ0ID8gcGR5IDogcGR4O1xuICB2YXIgc2duTCA9IHNpZ251bShwbCk7XG4gIHZhciBmb3JjZWREaXIgPSBmYWxzZTtcbiAgaWYgKCEoaXNFeHBsaWNpdERpciAmJiAodHVybklzUGVyY2VudCB8fCB0dXJuSXNOZWdhdGl2ZSkpIC8vIGZvcmNpbmcgaW4gdGhpcyBjYXNlIHdvdWxkIGNhdXNlIHdlaXJkIGdyb3dpbmcgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAmJiAocmF3VGF4aURpciA9PT0gRE9XTldBUkQgJiYgcGwgPCAwIHx8IHJhd1RheGlEaXIgPT09IFVQV0FSRCAmJiBwbCA+IDAgfHwgcmF3VGF4aURpciA9PT0gTEVGVFdBUkQgJiYgcGwgPiAwIHx8IHJhd1RheGlEaXIgPT09IFJJR0hUV0FSRCAmJiBwbCA8IDApKSB7XG4gICAgc2duTCAqPSAtMTtcbiAgICBsID0gc2duTCAqIE1hdGguYWJzKGwpO1xuICAgIGZvcmNlZERpciA9IHRydWU7XG4gIH1cbiAgdmFyIGQ7XG4gIGlmICh0dXJuSXNQZXJjZW50KSB7XG4gICAgdmFyIHAgPSB0YXhpVHVyblBmVmFsIDwgMCA/IDEgKyB0YXhpVHVyblBmVmFsIDogdGF4aVR1cm5QZlZhbDtcbiAgICBkID0gcCAqIGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGsgPSB0YXhpVHVyblBmVmFsIDwgMCA/IGwgOiAwO1xuICAgIGQgPSBrICsgdGF4aVR1cm5QZlZhbCAqIHNnbkw7XG4gIH1cbiAgdmFyIGdldElzVG9vQ2xvc2UgPSBmdW5jdGlvbiBnZXRJc1Rvb0Nsb3NlKGQpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoZCkgPCBtaW5EIHx8IE1hdGguYWJzKGQpID49IE1hdGguYWJzKGwpO1xuICB9O1xuICB2YXIgaXNUb29DbG9zZVNyYyA9IGdldElzVG9vQ2xvc2UoZCk7XG4gIHZhciBpc1Rvb0Nsb3NlVGd0ID0gZ2V0SXNUb29DbG9zZShNYXRoLmFicyhsKSAtIE1hdGguYWJzKGQpKTtcbiAgdmFyIGlzVG9vQ2xvc2UgPSBpc1Rvb0Nsb3NlU3JjIHx8IGlzVG9vQ2xvc2VUZ3Q7XG4gIGlmIChpc1Rvb0Nsb3NlICYmICFmb3JjZWREaXIpIHtcbiAgICAvLyBub24taWRlYWwgcm91dGluZ1xuICAgIGlmIChpc1ZlcnQpIHtcbiAgICAgIC8vIHZlcnRpY2FsIGZhbGxiYWNrc1xuICAgICAgdmFyIGxTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNIIC8gMjtcbiAgICAgIHZhciBsU2hhcGVJbnNpZGVUZ3QgPSBNYXRoLmFicyhwZHgpIDw9IHRndFcgLyAyO1xuICAgICAgaWYgKGxTaGFwZUluc2lkZVNyYykge1xuICAgICAgICAvLyBob3Jpem9udGFsIFotc2hhcGUgKGRpcmVjdGlvbiBub3QgcmVzcGVjdGVkKVxuICAgICAgICB2YXIgeCA9IChwb3NQdHMueDEgKyBwb3NQdHMueDIpIC8gMjtcbiAgICAgICAgdmFyIHkxID0gcG9zUHRzLnkxLFxuICAgICAgICAgIHkyID0gcG9zUHRzLnkyO1xuICAgICAgICBycy5zZWdwdHMgPSBbeCwgeTEsIHgsIHkyXTtcbiAgICAgIH0gZWxzZSBpZiAobFNoYXBlSW5zaWRlVGd0KSB7XG4gICAgICAgIC8vIHZlcnRpY2FsIFotc2hhcGUgKGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQpXG4gICAgICAgIHZhciB5ID0gKHBvc1B0cy55MSArIHBvc1B0cy55MikgLyAyO1xuICAgICAgICB2YXIgeDEgPSBwb3NQdHMueDEsXG4gICAgICAgICAgeDIgPSBwb3NQdHMueDI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFt4MSwgeSwgeDIsIHldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTC1zaGFwZSBmYWxsYmFjayAodHVybiBkaXN0YW5jZSBub3QgcmVzcGVjdGVkLCBidXQgd29ya3Mgd2VsbCB3aXRoIHRyZWUgc2libGluZ3MpXG4gICAgICAgIHJzLnNlZ3B0cyA9IFtwb3NQdHMueDEsIHBvc1B0cy55Ml07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvcml6b250YWwgZmFsbGJhY2tzXG4gICAgICB2YXIgX2xTaGFwZUluc2lkZVNyYyA9IE1hdGguYWJzKHBsKSA8PSBzcmNXIC8gMjtcbiAgICAgIHZhciBfbFNoYXBlSW5zaWRlVGd0ID0gTWF0aC5hYnMocGR5KSA8PSB0Z3RIIC8gMjtcbiAgICAgIGlmIChfbFNoYXBlSW5zaWRlU3JjKSB7XG4gICAgICAgIC8vIHZlcnRpY2FsIFotc2hhcGUgKGRpcmVjdGlvbiBub3QgcmVzcGVjdGVkKVxuICAgICAgICB2YXIgX3kgPSAocG9zUHRzLnkxICsgcG9zUHRzLnkyKSAvIDI7XG4gICAgICAgIHZhciBfeCA9IHBvc1B0cy54MSxcbiAgICAgICAgICBfeDIgPSBwb3NQdHMueDI7XG4gICAgICAgIHJzLnNlZ3B0cyA9IFtfeCwgX3ksIF94MiwgX3ldO1xuICAgICAgfSBlbHNlIGlmIChfbFNoYXBlSW5zaWRlVGd0KSB7XG4gICAgICAgIC8vIGhvcml6b250YWwgWi1zaGFwZSAodHVybiBkaXN0YW5jZSBub3QgcmVzcGVjdGVkKVxuICAgICAgICB2YXIgX3gzID0gKHBvc1B0cy54MSArIHBvc1B0cy54MikgLyAyO1xuICAgICAgICB2YXIgX3kyID0gcG9zUHRzLnkxLFxuICAgICAgICAgIF95MyA9IHBvc1B0cy55MjtcbiAgICAgICAgcnMuc2VncHRzID0gW194MywgX3kyLCBfeDMsIF95M107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMLXNoYXBlICh0dXJuIGRpc3RhbmNlIG5vdCByZXNwZWN0ZWQsIGJ1dCB3b3JrcyB3ZWxsIGZvciB0cmVlIHNpYmxpbmdzKVxuICAgICAgICBycy5zZWdwdHMgPSBbcG9zUHRzLngyLCBwb3NQdHMueTFdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZGVhbCByb3V0aW5nXG4gICAgaWYgKGlzVmVydCkge1xuICAgICAgdmFyIF95NCA9IHBvc1B0cy55MSArIGQgKyAoZEluY2x1ZGVzTm9kZUJvZHkgPyBzcmNIIC8gMiAqIHNnbkwgOiAwKTtcbiAgICAgIHZhciBfeDQgPSBwb3NQdHMueDEsXG4gICAgICAgIF94NSA9IHBvc1B0cy54MjtcbiAgICAgIHJzLnNlZ3B0cyA9IFtfeDQsIF95NCwgX3g1LCBfeTRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3Jpem9udGFsXG4gICAgICB2YXIgX3g2ID0gcG9zUHRzLngxICsgZCArIChkSW5jbHVkZXNOb2RlQm9keSA/IHNyY1cgLyAyICogc2duTCA6IDApO1xuICAgICAgdmFyIF95NSA9IHBvc1B0cy55MSxcbiAgICAgICAgX3k2ID0gcG9zUHRzLnkyO1xuICAgICAgcnMuc2VncHRzID0gW194NiwgX3k1LCBfeDYsIF95Nl07XG4gICAgfVxuICB9XG4gIGlmIChycy5pc1JvdW5kKSB7XG4gICAgdmFyIHJhZGl1cyA9IGVkZ2UucHN0eWxlKCd0YXhpLXJhZGl1cycpLnZhbHVlO1xuICAgIHZhciBpc0FyY1JhZGl1cyA9IGVkZ2UucHN0eWxlKCdyYWRpdXMtdHlwZScpLnZhbHVlWzBdID09PSAnYXJjLXJhZGl1cyc7XG4gICAgcnMucmFkaWkgPSBuZXcgQXJyYXkocnMuc2VncHRzLmxlbmd0aCAvIDIpLmZpbGwocmFkaXVzKTtcbiAgICBycy5pc0FyY1JhZGl1cyA9IG5ldyBBcnJheShycy5zZWdwdHMubGVuZ3RoIC8gMikuZmlsbChpc0FyY1JhZGl1cyk7XG4gIH1cbn07XG5CUnAkYy50cnlUb0NvcnJlY3RJbnZhbGlkUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UsIHBhaXJJbmZvKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgLy8gY2FuIG9ubHkgY29ycmVjdCBiZXppZXJzIGZvciBub3cuLi5cbiAgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJykge1xuICAgIHZhciBzcmNQb3MgPSBwYWlySW5mby5zcmNQb3MsXG4gICAgICB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MsXG4gICAgICBzcmNXID0gcGFpckluZm8uc3JjVyxcbiAgICAgIHNyY0ggPSBwYWlySW5mby5zcmNILFxuICAgICAgdGd0VyA9IHBhaXJJbmZvLnRndFcsXG4gICAgICB0Z3RIID0gcGFpckluZm8udGd0SCxcbiAgICAgIHNyY1NoYXBlID0gcGFpckluZm8uc3JjU2hhcGUsXG4gICAgICB0Z3RTaGFwZSA9IHBhaXJJbmZvLnRndFNoYXBlLFxuICAgICAgc3JjQ29ybmVyUmFkaXVzID0gcGFpckluZm8uc3JjQ29ybmVyUmFkaXVzLFxuICAgICAgdGd0Q29ybmVyUmFkaXVzID0gcGFpckluZm8udGd0Q29ybmVyUmFkaXVzLFxuICAgICAgc3JjUnMgPSBwYWlySW5mby5zcmNScyxcbiAgICAgIHRndFJzID0gcGFpckluZm8udGd0UnM7XG4gICAgdmFyIGJhZFN0YXJ0ID0gIW51bWJlciQxKHJzLnN0YXJ0WCkgfHwgIW51bWJlciQxKHJzLnN0YXJ0WSk7XG4gICAgdmFyIGJhZEFTdGFydCA9ICFudW1iZXIkMShycy5hcnJvd1N0YXJ0WCkgfHwgIW51bWJlciQxKHJzLmFycm93U3RhcnRZKTtcbiAgICB2YXIgYmFkRW5kID0gIW51bWJlciQxKHJzLmVuZFgpIHx8ICFudW1iZXIkMShycy5lbmRZKTtcbiAgICB2YXIgYmFkQUVuZCA9ICFudW1iZXIkMShycy5hcnJvd0VuZFgpIHx8ICFudW1iZXIkMShycy5hcnJvd0VuZFkpO1xuICAgIHZhciBtaW5DcEFEaXN0RmFjdG9yID0gMztcbiAgICB2YXIgYXJyb3dXID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMuYXJyb3dTaGFwZVdpZHRoO1xuICAgIHZhciBtaW5DcEFEaXN0ID0gbWluQ3BBRGlzdEZhY3RvciAqIGFycm93VztcbiAgICB2YXIgc3RhcnRBQ3BEaXN0ID0gZGlzdCh7XG4gICAgICB4OiBycy5jdHJscHRzWzBdLFxuICAgICAgeTogcnMuY3RybHB0c1sxXVxuICAgIH0sIHtcbiAgICAgIHg6IHJzLnN0YXJ0WCxcbiAgICAgIHk6IHJzLnN0YXJ0WVxuICAgIH0pO1xuICAgIHZhciBjbG9zZVN0YXJ0QUNwID0gc3RhcnRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICB2YXIgZW5kQUNwRGlzdCA9IGRpc3Qoe1xuICAgICAgeDogcnMuY3RybHB0c1swXSxcbiAgICAgIHk6IHJzLmN0cmxwdHNbMV1cbiAgICB9LCB7XG4gICAgICB4OiBycy5lbmRYLFxuICAgICAgeTogcnMuZW5kWVxuICAgIH0pO1xuICAgIHZhciBjbG9zZUVuZEFDcCA9IGVuZEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuICAgIHZhciBvdmVybGFwcGluZyA9IGZhbHNlO1xuICAgIGlmIChiYWRTdGFydCB8fCBiYWRBU3RhcnQgfHwgY2xvc2VTdGFydEFDcCkge1xuICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHNyYyBjZW50cmUgdG8gb3V0c2lkZSB0aGUgc3JjIHNoYXBlXG4gICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG4gICAgICB2YXIgY3BEID0ge1xuICAgICAgICAvLyBkZWx0YVxuICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gc3JjUG9zLngsXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gLSBzcmNQb3MueVxuICAgICAgfTtcbiAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoY3BELnggKiBjcEQueCArIGNwRC55ICogY3BELnkpOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgdmFyIGNwTSA9IHtcbiAgICAgICAgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgIH07XG4gICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICB2YXIgY3BQcm9qID0ge1xuICAgICAgICAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgIH07XG4gICAgICB2YXIgc3JjQ3RybFB0SW50biA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoc3JjUG9zLngsIHNyY1Bvcy55LCBzcmNXLCBzcmNILCBjcFByb2oueCwgY3BQcm9qLnksIDAsIHNyY0Nvcm5lclJhZGl1cywgc3JjUnMpO1xuICAgICAgaWYgKGNsb3NlU3RhcnRBQ3ApIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHJzLmN0cmxwdHNbMF0gKyBjcE0ueCAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSBzcmNDdHJsUHRJbnRuWzBdICsgY3BNLnggKiBtaW5DcEFEaXN0O1xuICAgICAgICBycy5jdHJscHRzWzFdID0gc3JjQ3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJhZEVuZCB8fCBiYWRBRW5kIHx8IGNsb3NlRW5kQUNwKSB7XG4gICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgIC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gdGd0IGNlbnRyZSB0byBvdXRzaWRlIHRoZSB0Z3Qgc2hhcGVcbiAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgIHZhciBfY3BEID0ge1xuICAgICAgICAvLyBkZWx0YVxuICAgICAgICB4OiBycy5jdHJscHRzWzBdIC0gdGd0UG9zLngsXG4gICAgICAgIHk6IHJzLmN0cmxwdHNbMV0gLSB0Z3RQb3MueVxuICAgICAgfTtcbiAgICAgIHZhciBfY3BMID0gTWF0aC5zcXJ0KF9jcEQueCAqIF9jcEQueCArIF9jcEQueSAqIF9jcEQueSk7IC8vIGxlbmd0aCBvZiBsaW5lXG4gICAgICB2YXIgX2NwTSA9IHtcbiAgICAgICAgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICB4OiBfY3BELnggLyBfY3BMLFxuICAgICAgICB5OiBfY3BELnkgLyBfY3BMXG4gICAgICB9O1xuICAgICAgdmFyIF9yYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcbiAgICAgIHZhciBfY3BQcm9qID0ge1xuICAgICAgICAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgIHg6IHJzLmN0cmxwdHNbMF0gKyBfY3BNLnggKiAyICogX3JhZGl1cyxcbiAgICAgICAgeTogcnMuY3RybHB0c1sxXSArIF9jcE0ueSAqIDIgKiBfcmFkaXVzXG4gICAgICB9O1xuICAgICAgdmFyIHRndEN0cmxQdEludG4gPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGd0VywgdGd0SCwgX2NwUHJvai54LCBfY3BQcm9qLnksIDAsIHRndENvcm5lclJhZGl1cywgdGd0UnMpO1xuICAgICAgaWYgKGNsb3NlRW5kQUNwKSB7XG4gICAgICAgIHJzLmN0cmxwdHNbMF0gPSBycy5jdHJscHRzWzBdICsgX2NwTS54ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTtcbiAgICAgICAgcnMuY3RybHB0c1sxXSA9IHJzLmN0cmxwdHNbMV0gKyBfY3BNLnkgKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMuY3RybHB0c1swXSA9IHRndEN0cmxQdEludG5bMF0gKyBfY3BNLnggKiBtaW5DcEFEaXN0O1xuICAgICAgICBycy5jdHJscHRzWzFdID0gdGd0Q3RybFB0SW50blsxXSArIF9jcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVybGFwcGluZykge1xuICAgICAgLy8gcmVjYWxjIGVuZHB0c1xuICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKGVkZ2UpO1xuICAgIH1cbiAgfVxufTtcbkJScCRjLnN0b3JlQWxscHRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgaWYgKHJzLmVkZ2VUeXBlID09PSAnbXVsdGliZXppZXInIHx8IHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgcnMuYWxscHRzID0gW107XG4gICAgcnMuYWxscHRzLnB1c2gocnMuc3RhcnRYLCBycy5zdGFydFkpO1xuICAgIGZvciAodmFyIGIgPSAwOyBiICsgMSA8IHJzLmN0cmxwdHMubGVuZ3RoOyBiICs9IDIpIHtcbiAgICAgIC8vIGN0cmwgcHQgaXRzZWxmXG4gICAgICBycy5hbGxwdHMucHVzaChycy5jdHJscHRzW2JdLCBycy5jdHJscHRzW2IgKyAxXSk7XG5cbiAgICAgIC8vIHRoZSBtaWRwdCBiZXR3ZWVuIGN0cmxwdHMgYXMgaW50ZXJtZWRpYXRlIGRlc3RpbmF0aW9uIHB0c1xuICAgICAgaWYgKGIgKyAzIDwgcnMuY3RybHB0cy5sZW5ndGgpIHtcbiAgICAgICAgcnMuYWxscHRzLnB1c2goKHJzLmN0cmxwdHNbYl0gKyBycy5jdHJscHRzW2IgKyAyXSkgLyAyLCAocnMuY3RybHB0c1tiICsgMV0gKyBycy5jdHJscHRzW2IgKyAzXSkgLyAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcnMuYWxscHRzLnB1c2gocnMuZW5kWCwgcnMuZW5kWSk7XG4gICAgdmFyIG0sIG10O1xuICAgIGlmIChycy5jdHJscHRzLmxlbmd0aCAvIDIgJSAyID09PSAwKSB7XG4gICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAxO1xuICAgICAgcnMubWlkWCA9IHJzLmFsbHB0c1ttXTtcbiAgICAgIHJzLm1pZFkgPSBycy5hbGxwdHNbbSArIDFdO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gcnMuYWxscHRzLmxlbmd0aCAvIDIgLSAzO1xuICAgICAgbXQgPSAwLjU7XG4gICAgICBycy5taWRYID0gcWJlemllckF0KHJzLmFsbHB0c1ttXSwgcnMuYWxscHRzW20gKyAyXSwgcnMuYWxscHRzW20gKyA0XSwgbXQpO1xuICAgICAgcnMubWlkWSA9IHFiZXppZXJBdChycy5hbGxwdHNbbSArIDFdLCBycy5hbGxwdHNbbSArIDNdLCBycy5hbGxwdHNbbSArIDVdLCBtdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgLy8gbmVlZCB0byBjYWxjIHRoZXNlIGFmdGVyIGVuZHB0c1xuICAgIHJzLmFsbHB0cyA9IFtycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWV07XG5cbiAgICAvLyBkZWZhdWx0IG1pZHB0IGZvciBsYWJlbHMgZXRjXG4gICAgcnMubWlkWCA9IChycy5zdGFydFggKyBycy5lbmRYICsgcnMuYXJyb3dTdGFydFggKyBycy5hcnJvd0VuZFgpIC8gNDtcbiAgICBycy5taWRZID0gKHJzLnN0YXJ0WSArIHJzLmVuZFkgKyBycy5hcnJvd1N0YXJ0WSArIHJzLmFycm93RW5kWSkgLyA0O1xuICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VnbWVudHMnKSB7XG4gICAgcnMuYWxscHRzID0gW107XG4gICAgcnMuYWxscHRzLnB1c2gocnMuc3RhcnRYLCBycy5zdGFydFkpO1xuICAgIHJzLmFsbHB0cy5wdXNoLmFwcGx5KHJzLmFsbHB0cywgcnMuc2VncHRzKTtcbiAgICBycy5hbGxwdHMucHVzaChycy5lbmRYLCBycy5lbmRZKTtcbiAgICBpZiAocnMuaXNSb3VuZCkge1xuICAgICAgcnMucm91bmRDb3JuZXJzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSArIDMgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHJzLnJhZGlpW2kgLyAyIC0gMV07XG4gICAgICAgIHZhciBpc0FyY1JhZGl1cyA9IHJzLmlzQXJjUmFkaXVzW2kgLyAyIC0gMV07XG4gICAgICAgIHJzLnJvdW5kQ29ybmVycy5wdXNoKGdldFJvdW5kQ29ybmVyKHtcbiAgICAgICAgICB4OiBycy5hbGxwdHNbaSAtIDJdLFxuICAgICAgICAgIHk6IHJzLmFsbHB0c1tpIC0gMV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHJzLmFsbHB0c1tpXSxcbiAgICAgICAgICB5OiBycy5hbGxwdHNbaSArIDFdLFxuICAgICAgICAgIHJhZGl1czogcmFkaXVzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBycy5hbGxwdHNbaSArIDJdLFxuICAgICAgICAgIHk6IHJzLmFsbHB0c1tpICsgM11cbiAgICAgICAgfSwgcmFkaXVzLCBpc0FyY1JhZGl1cykpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocnMuc2VncHRzLmxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAgIHZhciBpMiA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyO1xuICAgICAgdmFyIGkxID0gaTIgLSAyO1xuICAgICAgcnMubWlkWCA9IChycy5zZWdwdHNbaTFdICsgcnMuc2VncHRzW2kyXSkgLyAyO1xuICAgICAgcnMubWlkWSA9IChycy5zZWdwdHNbaTEgKyAxXSArIHJzLnNlZ3B0c1tpMiArIDFdKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfaSA9IHJzLnNlZ3B0cy5sZW5ndGggLyAyIC0gMTtcbiAgICAgIGlmICghcnMuaXNSb3VuZCkge1xuICAgICAgICBycy5taWRYID0gcnMuc2VncHRzW19pXTtcbiAgICAgICAgcnMubWlkWSA9IHJzLnNlZ3B0c1tfaSArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgIHg6IHJzLnNlZ3B0c1tfaV0sXG4gICAgICAgICAgeTogcnMuc2VncHRzW19pICsgMV1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvcm5lciA9IHJzLnJvdW5kQ29ybmVyc1tfaSAvIDJdO1xuICAgICAgICBpZiAoY29ybmVyLnJhZGl1cyA9PT0gMCkge1xuICAgICAgICAgIC8vIE9uIGNvbGxpbmVhciBwb2ludHNcbiAgICAgICAgICB2YXIgbmV4dFBvaW50ID0ge1xuICAgICAgICAgICAgeDogcnMuc2VncHRzW19pICsgMl0sXG4gICAgICAgICAgICB5OiBycy5zZWdwdHNbX2kgKyAzXVxuICAgICAgICAgIH07XG4gICAgICAgICAgcnMubWlkWCA9IHBvaW50Lng7XG4gICAgICAgICAgcnMubWlkWSA9IHBvaW50Lnk7XG4gICAgICAgICAgcnMubWlkVmVjdG9yID0gW3BvaW50LnkgLSBuZXh0UG9pbnQueSwgbmV4dFBvaW50LnggLSBwb2ludC54XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPbiByb3VuZGVkIHBvaW50c1xuICAgICAgICAgIHZhciB2ID0gW3BvaW50LnggLSBjb3JuZXIuY3gsIHBvaW50LnkgLSBjb3JuZXIuY3ldO1xuICAgICAgICAgIHZhciBmYWN0b3IgPSBjb3JuZXIucmFkaXVzIC8gTWF0aC5zcXJ0KE1hdGgucG93KHZbMF0sIDIpICsgTWF0aC5wb3codlsxXSwgMikpO1xuICAgICAgICAgIHYgPSB2Lm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgcmV0dXJuIGMgKiBmYWN0b3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcnMubWlkWCA9IGNvcm5lci5jeCArIHZbMF07XG4gICAgICAgICAgcnMubWlkWSA9IGNvcm5lci5jeSArIHZbMV07XG4gICAgICAgICAgcnMubWlkVmVjdG9yID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkJScCRjLmNoZWNrRm9ySW52YWxpZEVkZ2VXYXJuaW5nID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgaWYgKHJzLm5vZGVzT3ZlcmxhcCB8fCBudW1iZXIkMShycy5zdGFydFgpICYmIG51bWJlciQxKHJzLnN0YXJ0WSkgJiYgbnVtYmVyJDEocnMuZW5kWCkgJiYgbnVtYmVyJDEocnMuZW5kWSkpIHtcbiAgICBycy5sb2dnZWRFcnIgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXJzLmxvZ2dlZEVycikge1xuICAgICAgcnMubG9nZ2VkRXJyID0gdHJ1ZTtcbiAgICAgIHdhcm4oJ0VkZ2UgYCcgKyBlZGdlLmlkKCkgKyAnYCBoYXMgaW52YWxpZCBlbmRwb2ludHMgYW5kIHNvIGl0IGlzIGltcG9zc2libGUgdG8gZHJhdy4gIEFkanVzdCB5b3VyIGVkZ2Ugc3R5bGUgKGUuZy4gY29udHJvbCBwb2ludHMpIGFjY29yZGluZ2x5IG9yIHVzZSBhbiBhbHRlcm5hdGl2ZSBlZGdlIHR5cGUuICBUaGlzIGlzIGV4cGVjdGVkIGJlaGF2aW91ciB3aGVuIHRoZSBzb3VyY2Ugbm9kZSBhbmQgdGhlIHRhcmdldCBub2RlIG92ZXJsYXAuJyk7XG4gICAgfVxuICB9XG59O1xuQlJwJGMuZmluZEVkZ2VDb250cm9sUG9pbnRzID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIGlmICghZWRnZXMgfHwgZWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgdmFyIGhhc2hUYWJsZSA9IG5ldyBNYXAkMSgpO1xuICB2YXIgZ2V0S2V5ID0gZnVuY3Rpb24gZ2V0S2V5KHBhaXJJZCwgZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocGFpcklkKSwgW2VkZ2VJc1VuYnVuZGxlZCA/IDEgOiAwXSkuam9pbignLScpO1xuICB9O1xuICB2YXIgcGFpcklkcyA9IFtdO1xuICB2YXIgaGF5c3RhY2tFZGdlcyA9IFtdO1xuXG4gIC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICAgIHZhciBjdXJ2ZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2N1cnZlLXN0eWxlJykudmFsdWU7XG5cbiAgICAvLyBpZ25vcmUgZWRnZXMgd2hvIGFyZSBub3QgdG8gYmUgZGlzcGxheWVkXG4gICAgLy8gdGhleSBzaG91bGRuJ3QgdGFrZSB1cCBzcGFjZVxuICAgIGlmIChlZGdlLnJlbW92ZWQoKSB8fCAhZWRnZS50YWtlc1VwU3BhY2UoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjdXJ2ZVN0eWxlID09PSAnaGF5c3RhY2snKSB7XG4gICAgICBoYXlzdGFja0VkZ2VzLnB1c2goZWRnZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGVkZ2VJc1VuYnVuZGxlZCA9IGN1cnZlU3R5bGUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJyB8fCBlbmRzV2l0aChjdXJ2ZVN0eWxlLCAnc2VnbWVudHMnKSB8fCBjdXJ2ZVN0eWxlID09PSAnc3RyYWlnaHQnIHx8IGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodC10cmlhbmdsZScgfHwgZW5kc1dpdGgoY3VydmVTdHlsZSwgJ3RheGknKTtcbiAgICB2YXIgZWRnZUlzQmV6aWVyID0gY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGN1cnZlU3R5bGUgPT09ICdiZXppZXInO1xuICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICB2YXIgc3JjSW5kZXggPSBzcmMucG9vbEluZGV4KCk7XG4gICAgdmFyIHRndEluZGV4ID0gdGd0LnBvb2xJbmRleCgpO1xuICAgIHZhciBwYWlySWQgPSBbc3JjSW5kZXgsIHRndEluZGV4XS5zb3J0KCk7XG4gICAgdmFyIGtleSA9IGdldEtleShwYWlySWQsIGVkZ2VJc1VuYnVuZGxlZCk7XG4gICAgdmFyIHRhYmxlRW50cnkgPSBoYXNoVGFibGUuZ2V0KGtleSk7XG4gICAgaWYgKHRhYmxlRW50cnkgPT0gbnVsbCkge1xuICAgICAgdGFibGVFbnRyeSA9IHtcbiAgICAgICAgZWxlczogW11cbiAgICAgIH07XG4gICAgICBwYWlySWRzLnB1c2goe1xuICAgICAgICBwYWlySWQ6IHBhaXJJZCxcbiAgICAgICAgZWRnZUlzVW5idW5kbGVkOiBlZGdlSXNVbmJ1bmRsZWRcbiAgICAgIH0pO1xuICAgICAgaGFzaFRhYmxlLnNldChrZXksIHRhYmxlRW50cnkpO1xuICAgIH1cbiAgICB0YWJsZUVudHJ5LmVsZXMucHVzaChlZGdlKTtcbiAgICBpZiAoZWRnZUlzVW5idW5kbGVkKSB7XG4gICAgICB0YWJsZUVudHJ5Lmhhc1VuYnVuZGxlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChlZGdlSXNCZXppZXIpIHtcbiAgICAgIHRhYmxlRW50cnkuaGFzQmV6aWVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBmb3IgZWFjaCBwYWlyIChzcmMsIHRndCksIGNyZWF0ZSB0aGUgY3RybCBwdHNcbiAgLy8gTmVzdGVkIGZvciBsb29wIGlzIE9LOyB0b3RhbCBudW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgYm90aCBsb29wcyA9IGVkZ2VDb3VudFxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgX3BhaXJJZHMkcCA9IHBhaXJJZHNbcF0sXG4gICAgICBwYWlySWQgPSBfcGFpcklkcyRwLnBhaXJJZCxcbiAgICAgIGVkZ2VJc1VuYnVuZGxlZCA9IF9wYWlySWRzJHAuZWRnZUlzVW5idW5kbGVkO1xuICAgIHZhciBrZXkgPSBnZXRLZXkocGFpcklkLCBlZGdlSXNVbmJ1bmRsZWQpO1xuICAgIHZhciBwYWlySW5mbyA9IGhhc2hUYWJsZS5nZXQoa2V5KTtcbiAgICB2YXIgc3dhcHBlZHBhaXJJbmZvO1xuICAgIGlmICghcGFpckluZm8uaGFzVW5idW5kbGVkKSB7XG4gICAgICB2YXIgcGxsRWRnZXMgPSBwYWlySW5mby5lbGVzWzBdLnBhcmFsbGVsRWRnZXMoKS5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuaXNCdW5kbGVkQmV6aWVyKCk7XG4gICAgICB9KTtcbiAgICAgIGNsZWFyQXJyYXkocGFpckluZm8uZWxlcyk7XG4gICAgICBwbGxFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBwYWlySW5mby5lbGVzLnB1c2goZWRnZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gZm9yIGVhY2ggcGFpciBpZCwgdGhlIGVkZ2VzIHNob3VsZCBiZSBzb3J0ZWQgYnkgaW5kZXhcbiAgICAgIHBhaXJJbmZvLmVsZXMuc29ydChmdW5jdGlvbiAoZWRnZTEsIGVkZ2UyKSB7XG4gICAgICAgIHJldHVybiBlZGdlMS5wb29sSW5kZXgoKSAtIGVkZ2UyLnBvb2xJbmRleCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBmaXJzdEVkZ2UgPSBwYWlySW5mby5lbGVzWzBdO1xuICAgIHZhciBzcmMgPSBmaXJzdEVkZ2Uuc291cmNlKCk7XG4gICAgdmFyIHRndCA9IGZpcnN0RWRnZS50YXJnZXQoKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBzcmMvdGd0IGRpc3RpbmN0aW9uIGlzIGNvbnNpc3RlbnQgdy5yLnQuIHBhaXJJZFxuICAgIGlmIChzcmMucG9vbEluZGV4KCkgPiB0Z3QucG9vbEluZGV4KCkpIHtcbiAgICAgIHZhciB0ZW1wID0gc3JjO1xuICAgICAgc3JjID0gdGd0O1xuICAgICAgdGd0ID0gdGVtcDtcbiAgICB9XG4gICAgdmFyIHNyY1BvcyA9IHBhaXJJbmZvLnNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RQb3MgPSBwYWlySW5mby50Z3RQb3MgPSB0Z3QucG9zaXRpb24oKTtcbiAgICB2YXIgc3JjVyA9IHBhaXJJbmZvLnNyY1cgPSBzcmMub3V0ZXJXaWR0aCgpO1xuICAgIHZhciBzcmNIID0gcGFpckluZm8uc3JjSCA9IHNyYy5vdXRlckhlaWdodCgpO1xuICAgIHZhciB0Z3RXID0gcGFpckluZm8udGd0VyA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgdmFyIHRndEggPSBwYWlySW5mby50Z3RIID0gdGd0Lm91dGVySGVpZ2h0KCk7XG4gICAgdmFyIHNyY1NoYXBlID0gcGFpckluZm8uc3JjU2hhcGUgPSByLm5vZGVTaGFwZXNbX3RoaXMuZ2V0Tm9kZVNoYXBlKHNyYyldO1xuICAgIHZhciB0Z3RTaGFwZSA9IHBhaXJJbmZvLnRndFNoYXBlID0gci5ub2RlU2hhcGVzW190aGlzLmdldE5vZGVTaGFwZSh0Z3QpXTtcbiAgICB2YXIgc3JjQ29ybmVyUmFkaXVzID0gcGFpckluZm8uc3JjQ29ybmVyUmFkaXVzID0gc3JjLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlID09PSAnYXV0bycgPyAnYXV0bycgOiBzcmMucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgICB2YXIgdGd0Q29ybmVyUmFkaXVzID0gcGFpckluZm8udGd0Q29ybmVyUmFkaXVzID0gdGd0LnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlID09PSAnYXV0bycgPyAnYXV0bycgOiB0Z3QucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgICB2YXIgdGd0UnMgPSBwYWlySW5mby50Z3RScyA9IHRndC5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgc3JjUnMgPSBwYWlySW5mby5zcmNScyA9IHNyYy5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBwYWlySW5mby5kaXJDb3VudHMgPSB7XG4gICAgICAnbm9ydGgnOiAwLFxuICAgICAgJ3dlc3QnOiAwLFxuICAgICAgJ3NvdXRoJzogMCxcbiAgICAgICdlYXN0JzogMCxcbiAgICAgICdub3J0aHdlc3QnOiAwLFxuICAgICAgJ3NvdXRod2VzdCc6IDAsXG4gICAgICAnbm9ydGhlYXN0JzogMCxcbiAgICAgICdzb3V0aGVhc3QnOiAwXG4gICAgfTtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYWlySW5mby5lbGVzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIHZhciBfZWRnZSA9IHBhaXJJbmZvLmVsZXNbX2kyXTtcbiAgICAgIHZhciBycyA9IF9lZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIF9jdXJ2ZVN0eWxlID0gX2VkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuICAgICAgdmFyIF9lZGdlSXNVbmJ1bmRsZWQgPSBfY3VydmVTdHlsZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInIHx8IGVuZHNXaXRoKF9jdXJ2ZVN0eWxlLCAnc2VnbWVudHMnKSB8fCBlbmRzV2l0aChfY3VydmVTdHlsZSwgJ3RheGknKTtcblxuICAgICAgLy8gd2hldGhlciB0aGUgbm9ybWFsaXNlZCBwYWlyIG9yZGVyIGlzIHRoZSByZXZlcnNlIG9mIHRoZSBlZGdlJ3Mgc3JjLXRndCBvcmRlclxuICAgICAgdmFyIGVkZ2VJc1N3YXBwZWQgPSAhc3JjLnNhbWUoX2VkZ2Uuc291cmNlKCkpO1xuICAgICAgaWYgKCFwYWlySW5mby5jYWxjdWxhdGVkSW50ZXJzZWN0aW9uICYmIHNyYyAhPT0gdGd0ICYmIChwYWlySW5mby5oYXNCZXppZXIgfHwgcGFpckluZm8uaGFzVW5idW5kbGVkKSkge1xuICAgICAgICBwYWlySW5mby5jYWxjdWxhdGVkSW50ZXJzZWN0aW9uID0gdHJ1ZTtcblxuICAgICAgICAvLyBwdCBvdXRzaWRlIHNyYyBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcbiAgICAgICAgdmFyIHNyY091dHNpZGUgPSBzcmNTaGFwZS5pbnRlcnNlY3RMaW5lKHNyY1Bvcy54LCBzcmNQb3MueSwgc3JjVywgc3JjSCwgdGd0UG9zLngsIHRndFBvcy55LCAwLCBzcmNDb3JuZXJSYWRpdXMsIHNyY1JzKTtcbiAgICAgICAgdmFyIHNyY0ludG4gPSBwYWlySW5mby5zcmNJbnRuID0gc3JjT3V0c2lkZTtcblxuICAgICAgICAvLyBwdCBvdXRzaWRlIHRndCBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcbiAgICAgICAgdmFyIHRndE91dHNpZGUgPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGd0VywgdGd0SCwgc3JjUG9zLngsIHNyY1Bvcy55LCAwLCB0Z3RDb3JuZXJSYWRpdXMsIHRndFJzKTtcbiAgICAgICAgdmFyIHRndEludG4gPSBwYWlySW5mby50Z3RJbnRuID0gdGd0T3V0c2lkZTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvblB0cyA9IHBhaXJJbmZvLmludGVyc2VjdGlvblB0cyA9IHtcbiAgICAgICAgICB4MTogc3JjT3V0c2lkZVswXSxcbiAgICAgICAgICB4MjogdGd0T3V0c2lkZVswXSxcbiAgICAgICAgICB5MTogc3JjT3V0c2lkZVsxXSxcbiAgICAgICAgICB5MjogdGd0T3V0c2lkZVsxXVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9zUHRzID0gcGFpckluZm8ucG9zUHRzID0ge1xuICAgICAgICAgIHgxOiBzcmNQb3MueCxcbiAgICAgICAgICB4MjogdGd0UG9zLngsXG4gICAgICAgICAgeTE6IHNyY1Bvcy55LFxuICAgICAgICAgIHkyOiB0Z3RQb3MueVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZHkgPSB0Z3RPdXRzaWRlWzFdIC0gc3JjT3V0c2lkZVsxXTtcbiAgICAgICAgdmFyIGR4ID0gdGd0T3V0c2lkZVswXSAtIHNyY091dHNpZGVbMF07XG4gICAgICAgIHZhciBsID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgaWYgKG51bWJlciQxKGwpICYmIGwgPj0gQVZPSURfSU1QT1NTSUJMRV9CRVpJRVJfQ09OU1RBTlRfTCkgOyBlbHNlIHtcbiAgICAgICAgICBsID0gTWF0aC5zcXJ0KE1hdGgubWF4KGR4ICogZHgsIEFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UKSArIE1hdGgubWF4KGR5ICogZHksIEFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlY3RvciA9IHBhaXJJbmZvLnZlY3RvciA9IHtcbiAgICAgICAgICB4OiBkeCxcbiAgICAgICAgICB5OiBkeVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdmVjdG9yTm9ybSA9IHBhaXJJbmZvLnZlY3Rvck5vcm0gPSB7XG4gICAgICAgICAgeDogdmVjdG9yLnggLyBsLFxuICAgICAgICAgIHk6IHZlY3Rvci55IC8gbFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdmVjdG9yTm9ybUludmVyc2UgPSB7XG4gICAgICAgICAgeDogLXZlY3Rvck5vcm0ueSxcbiAgICAgICAgICB5OiB2ZWN0b3JOb3JtLnhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpZiBub2RlIHNoYXBlcyBvdmVybGFwLCB0aGVuIG5vIGN0cmwgcHRzIHRvIGRyYXdcbiAgICAgICAgcGFpckluZm8ubm9kZXNPdmVybGFwID0gIW51bWJlciQxKGwpIHx8IHRndFNoYXBlLmNoZWNrUG9pbnQoc3JjT3V0c2lkZVswXSwgc3JjT3V0c2lkZVsxXSwgMCwgdGd0VywgdGd0SCwgdGd0UG9zLngsIHRndFBvcy55LCB0Z3RDb3JuZXJSYWRpdXMsIHRndFJzKSB8fCBzcmNTaGFwZS5jaGVja1BvaW50KHRndE91dHNpZGVbMF0sIHRndE91dHNpZGVbMV0sIDAsIHNyY1csIHNyY0gsIHNyY1Bvcy54LCBzcmNQb3MueSwgc3JjQ29ybmVyUmFkaXVzLCBzcmNScyk7XG4gICAgICAgIHBhaXJJbmZvLnZlY3Rvck5vcm1JbnZlcnNlID0gdmVjdG9yTm9ybUludmVyc2U7XG4gICAgICAgIHN3YXBwZWRwYWlySW5mbyA9IHtcbiAgICAgICAgICBub2Rlc092ZXJsYXA6IHBhaXJJbmZvLm5vZGVzT3ZlcmxhcCxcbiAgICAgICAgICBkaXJDb3VudHM6IHBhaXJJbmZvLmRpckNvdW50cyxcbiAgICAgICAgICBjYWxjdWxhdGVkSW50ZXJzZWN0aW9uOiB0cnVlLFxuICAgICAgICAgIGhhc0JlemllcjogcGFpckluZm8uaGFzQmV6aWVyLFxuICAgICAgICAgIGhhc1VuYnVuZGxlZDogcGFpckluZm8uaGFzVW5idW5kbGVkLFxuICAgICAgICAgIGVsZXM6IHBhaXJJbmZvLmVsZXMsXG4gICAgICAgICAgc3JjUG9zOiB0Z3RQb3MsXG4gICAgICAgICAgc3JjUnM6IHRndFJzLFxuICAgICAgICAgIHRndFBvczogc3JjUG9zLFxuICAgICAgICAgIHRndFJzOiBzcmNScyxcbiAgICAgICAgICBzcmNXOiB0Z3RXLFxuICAgICAgICAgIHNyY0g6IHRndEgsXG4gICAgICAgICAgdGd0Vzogc3JjVyxcbiAgICAgICAgICB0Z3RIOiBzcmNILFxuICAgICAgICAgIHNyY0ludG46IHRndEludG4sXG4gICAgICAgICAgdGd0SW50bjogc3JjSW50bixcbiAgICAgICAgICBzcmNTaGFwZTogdGd0U2hhcGUsXG4gICAgICAgICAgdGd0U2hhcGU6IHNyY1NoYXBlLFxuICAgICAgICAgIHBvc1B0czoge1xuICAgICAgICAgICAgeDE6IHBvc1B0cy54MixcbiAgICAgICAgICAgIHkxOiBwb3NQdHMueTIsXG4gICAgICAgICAgICB4MjogcG9zUHRzLngxLFxuICAgICAgICAgICAgeTI6IHBvc1B0cy55MVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaW50ZXJzZWN0aW9uUHRzOiB7XG4gICAgICAgICAgICB4MTogaW50ZXJzZWN0aW9uUHRzLngyLFxuICAgICAgICAgICAgeTE6IGludGVyc2VjdGlvblB0cy55MixcbiAgICAgICAgICAgIHgyOiBpbnRlcnNlY3Rpb25QdHMueDEsXG4gICAgICAgICAgICB5MjogaW50ZXJzZWN0aW9uUHRzLnkxXG4gICAgICAgICAgfSxcbiAgICAgICAgICB2ZWN0b3I6IHtcbiAgICAgICAgICAgIHg6IC12ZWN0b3IueCxcbiAgICAgICAgICAgIHk6IC12ZWN0b3IueVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdmVjdG9yTm9ybToge1xuICAgICAgICAgICAgeDogLXZlY3Rvck5vcm0ueCxcbiAgICAgICAgICAgIHk6IC12ZWN0b3JOb3JtLnlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlOiB7XG4gICAgICAgICAgICB4OiAtdmVjdG9yTm9ybUludmVyc2UueCxcbiAgICAgICAgICAgIHk6IC12ZWN0b3JOb3JtSW52ZXJzZS55XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHBhc3NlZFBhaXJJbmZvID0gZWRnZUlzU3dhcHBlZCA/IHN3YXBwZWRwYWlySW5mbyA6IHBhaXJJbmZvO1xuICAgICAgcnMubm9kZXNPdmVybGFwID0gcGFzc2VkUGFpckluZm8ubm9kZXNPdmVybGFwO1xuICAgICAgcnMuc3JjSW50biA9IHBhc3NlZFBhaXJJbmZvLnNyY0ludG47XG4gICAgICBycy50Z3RJbnRuID0gcGFzc2VkUGFpckluZm8udGd0SW50bjtcbiAgICAgIHJzLmlzUm91bmQgPSBfY3VydmVTdHlsZS5zdGFydHNXaXRoKCdyb3VuZCcpO1xuICAgICAgaWYgKGhhc0NvbXBvdW5kcyAmJiAoc3JjLmlzUGFyZW50KCkgfHwgc3JjLmlzQ2hpbGQoKSB8fCB0Z3QuaXNQYXJlbnQoKSB8fCB0Z3QuaXNDaGlsZCgpKSAmJiAoc3JjLnBhcmVudHMoKS5hbnlTYW1lKHRndCkgfHwgdGd0LnBhcmVudHMoKS5hbnlTYW1lKHNyYykgfHwgc3JjLnNhbWUodGd0KSAmJiBzcmMuaXNQYXJlbnQoKSkpIHtcbiAgICAgICAgX3RoaXMuZmluZENvbXBvdW5kTG9vcFBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCk7XG4gICAgICB9IGVsc2UgaWYgKHNyYyA9PT0gdGd0KSB7XG4gICAgICAgIF90aGlzLmZpbmRMb29wUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbywgX2kyLCBfZWRnZUlzVW5idW5kbGVkKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUuZW5kc1dpdGgoJ3NlZ21lbnRzJykpIHtcbiAgICAgICAgX3RoaXMuZmluZFNlZ21lbnRzUG9pbnRzKF9lZGdlLCBwYXNzZWRQYWlySW5mbyk7XG4gICAgICB9IGVsc2UgaWYgKF9jdXJ2ZVN0eWxlLmVuZHNXaXRoKCd0YXhpJykpIHtcbiAgICAgICAgX3RoaXMuZmluZFRheGlQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcbiAgICAgIH0gZWxzZSBpZiAoX2N1cnZlU3R5bGUgPT09ICdzdHJhaWdodCcgfHwgIV9lZGdlSXNVbmJ1bmRsZWQgJiYgcGFpckluZm8uZWxlcy5sZW5ndGggJSAyID09PSAxICYmIF9pMiA9PT0gTWF0aC5mbG9vcihwYWlySW5mby5lbGVzLmxlbmd0aCAvIDIpKSB7XG4gICAgICAgIF90aGlzLmZpbmRTdHJhaWdodEVkZ2VQb2ludHMoX2VkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuZmluZEJlemllclBvaW50cyhfZWRnZSwgcGFzc2VkUGFpckluZm8sIF9pMiwgX2VkZ2VJc1VuYnVuZGxlZCwgZWRnZUlzU3dhcHBlZCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5maW5kRW5kcG9pbnRzKF9lZGdlKTtcbiAgICAgIF90aGlzLnRyeVRvQ29ycmVjdEludmFsaWRQb2ludHMoX2VkZ2UsIHBhc3NlZFBhaXJJbmZvKTtcbiAgICAgIF90aGlzLmNoZWNrRm9ySW52YWxpZEVkZ2VXYXJuaW5nKF9lZGdlKTtcbiAgICAgIF90aGlzLnN0b3JlQWxscHRzKF9lZGdlKTtcbiAgICAgIF90aGlzLnN0b3JlRWRnZVByb2plY3Rpb25zKF9lZGdlKTtcbiAgICAgIF90aGlzLmNhbGN1bGF0ZUFycm93QW5nbGVzKF9lZGdlKTtcbiAgICAgIF90aGlzLnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMoX2VkZ2UpO1xuICAgICAgX3RoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMoX2VkZ2UpO1xuICAgIH0gLy8gZm9yIHBhaXIgZWRnZXNcbiAgfTtcbiAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYWlySWRzLmxlbmd0aDsgcCsrKSB7XG4gICAgX2xvb3AoKTtcbiAgfSAvLyBmb3IgcGFpciBpZHNcblxuICAvLyBoYXlzdGFja3MgYXZvaWQgdGhlIGV4cGVuc2Ugb2YgcGFpckluZm8gc3R1ZmYgKGludGVyc2VjdGlvbnMgZXRjLilcbiAgdGhpcy5maW5kSGF5c3RhY2tQb2ludHMoaGF5c3RhY2tFZGdlcyk7XG59O1xuZnVuY3Rpb24gZ2V0UHRzKHB0cykge1xuICB2YXIgcmV0UHRzID0gW107XG4gIGlmIChwdHMgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB4ID0gcHRzW2ldO1xuICAgIHZhciB5ID0gcHRzW2kgKyAxXTtcbiAgICByZXRQdHMucHVzaCh7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXRQdHM7XG59XG5CUnAkYy5nZXRTZWdtZW50UG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gIHZhciB0eXBlID0gcnMuZWRnZVR5cGU7XG4gIGlmICh0eXBlID09PSAnc2VnbWVudHMnKSB7XG4gICAgcmV0dXJuIGdldFB0cyhycy5zZWdwdHMpO1xuICB9XG59O1xuQlJwJGMuZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBycyA9IGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHRoaXMucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlKGVkZ2UpO1xuICB2YXIgdHlwZSA9IHJzLmVkZ2VUeXBlO1xuICBpZiAodHlwZSA9PT0gJ2JlemllcicgfHwgdHlwZSA9PT0gJ211bHRpYmV6aWVyJyB8fCB0eXBlID09PSAnc2VsZicgfHwgdHlwZSA9PT0gJ2NvbXBvdW5kJykge1xuICAgIHJldHVybiBnZXRQdHMocnMuY3RybHB0cyk7XG4gIH1cbn07XG5CUnAkYy5nZXRFZGdlTWlkcG9pbnQgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcnMgPSBlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoO1xuICB0aGlzLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlZGdlKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBycy5taWRYLFxuICAgIHk6IHJzLm1pZFlcbiAgfTtcbn07XG5cbnZhciBCUnAkYiA9IHt9O1xuQlJwJGIubWFudWFsRW5kcHRUb1B4ID0gZnVuY3Rpb24gKG5vZGUsIHByb3ApIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgbnBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIHcgPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgdmFyIGggPSBub2RlLm91dGVySGVpZ2h0KCk7XG4gIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIGlmIChwcm9wLnZhbHVlLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwID0gW3Byb3AucGZWYWx1ZVswXSwgcHJvcC5wZlZhbHVlWzFdXTtcbiAgICBpZiAocHJvcC51bml0c1swXSA9PT0gJyUnKSB7XG4gICAgICBwWzBdID0gcFswXSAqIHc7XG4gICAgfVxuICAgIGlmIChwcm9wLnVuaXRzWzFdID09PSAnJScpIHtcbiAgICAgIHBbMV0gPSBwWzFdICogaDtcbiAgICB9XG4gICAgcFswXSArPSBucG9zLng7XG4gICAgcFsxXSArPSBucG9zLnk7XG4gICAgcmV0dXJuIHA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFuZ2xlID0gcHJvcC5wZlZhbHVlWzBdO1xuICAgIGFuZ2xlID0gLU1hdGguUEkgLyAyICsgYW5nbGU7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2tcblxuICAgIHZhciBsID0gMiAqIE1hdGgubWF4KHcsIGgpO1xuICAgIHZhciBfcCA9IFtucG9zLnggKyBNYXRoLmNvcyhhbmdsZSkgKiBsLCBucG9zLnkgKyBNYXRoLnNpbihhbmdsZSkgKiBsXTtcbiAgICByZXR1cm4gci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5pbnRlcnNlY3RMaW5lKG5wb3MueCwgbnBvcy55LCB3LCBoLCBfcFswXSwgX3BbMV0sIDAsIG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWUgPT09ICdhdXRvJyA/ICdhdXRvJyA6IG5vZGUucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZSwgcnMpO1xuICB9XG59O1xuQlJwJGIuZmluZEVuZHBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBfcmVmLCBfdGd0TWFuRW5kcHQkcGZWYWx1ZSwgX3JlZjIsIF9zcmNNYW5FbmRwdCRwZlZhbHVlO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBpbnRlcnNlY3Q7XG4gIHZhciBzb3VyY2UgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgdmFyIHNyY1BvcyA9IHNvdXJjZS5wb3NpdGlvbigpO1xuICB2YXIgdGd0UG9zID0gdGFyZ2V0LnBvc2l0aW9uKCk7XG4gIHZhciB0Z3RBclNoYXBlID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICB2YXIgc3JjQXJTaGFwZSA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtYXJyb3ctc2hhcGUnKS52YWx1ZTtcbiAgdmFyIHRndERpc3QgPSBlZGdlLnBzdHlsZSgndGFyZ2V0LWRpc3RhbmNlLWZyb20tbm9kZScpLnBmVmFsdWU7XG4gIHZhciBzcmNEaXN0ID0gZWRnZS5wc3R5bGUoJ3NvdXJjZS1kaXN0YW5jZS1mcm9tLW5vZGUnKS5wZlZhbHVlO1xuICB2YXIgc3JjUnMgPSBzb3VyY2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciB0Z3RScyA9IHRhcmdldC5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGN1cnZlU3R5bGUgPSBlZGdlLnBzdHlsZSgnY3VydmUtc3R5bGUnKS52YWx1ZTtcbiAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdmFyIGV0ID0gcnMuZWRnZVR5cGU7XG4gIHZhciB0YXhpID0gZW5kc1dpdGgoY3VydmVTdHlsZSwgJ3RheGknKTsgLy8gQ292ZXJzIHRheGkgYW5kIHJvdW5kLXRheGlcbiAgdmFyIHNlbGYgPSBldCA9PT0gJ3NlbGYnIHx8IGV0ID09PSAnY29tcG91bmQnO1xuICB2YXIgYmV6aWVyID0gZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnbXVsdGliZXppZXInIHx8IHNlbGY7XG4gIHZhciBtdWx0aSA9IGV0ICE9PSAnYmV6aWVyJztcbiAgdmFyIGxpbmVzID0gZXQgPT09ICdzdHJhaWdodCcgfHwgZXQgPT09ICdzZWdtZW50cyc7XG4gIHZhciBzZWdtZW50cyA9IGV0ID09PSAnc2VnbWVudHMnO1xuICB2YXIgaGFzRW5kcHRzID0gYmV6aWVyIHx8IG11bHRpIHx8IGxpbmVzO1xuICB2YXIgb3ZlcnJpZGVFbmRwdHMgPSBzZWxmIHx8IHRheGk7XG4gIHZhciBzcmNNYW5FbmRwdCA9IGVkZ2UucHN0eWxlKCdzb3VyY2UtZW5kcG9pbnQnKTtcbiAgdmFyIHNyY01hbkVuZHB0VmFsID0gb3ZlcnJpZGVFbmRwdHMgPyAnb3V0c2lkZS10by1ub2RlJyA6IHNyY01hbkVuZHB0LnZhbHVlO1xuICB2YXIgc3JjQ29ybmVyUmFkaXVzID0gc291cmNlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnZhbHVlID09PSAnYXV0bycgPyAnYXV0bycgOiBzb3VyY2UucHN0eWxlKCdjb3JuZXItcmFkaXVzJykucGZWYWx1ZTtcbiAgdmFyIHRndE1hbkVuZHB0ID0gZWRnZS5wc3R5bGUoJ3RhcmdldC1lbmRwb2ludCcpO1xuICB2YXIgdGd0TWFuRW5kcHRWYWwgPSBvdmVycmlkZUVuZHB0cyA/ICdvdXRzaWRlLXRvLW5vZGUnIDogdGd0TWFuRW5kcHQudmFsdWU7XG4gIHZhciB0Z3RDb3JuZXJSYWRpdXMgPSB0YXJnZXQucHN0eWxlKCdjb3JuZXItcmFkaXVzJykudmFsdWUgPT09ICdhdXRvJyA/ICdhdXRvJyA6IHRhcmdldC5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS5wZlZhbHVlO1xuICBycy5zcmNNYW5FbmRwdCA9IHNyY01hbkVuZHB0O1xuICBycy50Z3RNYW5FbmRwdCA9IHRndE1hbkVuZHB0O1xuICB2YXIgcDE7IC8vIGxhc3Qga25vd24gcG9pbnQgb2YgZWRnZSBvbiB0YXJnZXQgc2lkZVxuICB2YXIgcDI7IC8vIGxhc3Qga25vd24gcG9pbnQgb2YgZWRnZSBvbiBzb3VyY2Ugc2lkZVxuXG4gIHZhciBwMV9pOyAvLyBwb2ludCB0byBpbnRlcnNlY3Qgd2l0aCB0YXJnZXQgc2hhcGVcbiAgdmFyIHAyX2k7IC8vIHBvaW50IHRvIGludGVyc2VjdCB3aXRoIHNvdXJjZSBzaGFwZVxuXG4gIHZhciB0Z3RNYW5FbmRwdFB0ID0gKF9yZWYgPSAodGd0TWFuRW5kcHQgPT09IG51bGwgfHwgdGd0TWFuRW5kcHQgPT09IHVuZGVmaW5lZCB8fCAoX3RndE1hbkVuZHB0JHBmVmFsdWUgPSB0Z3RNYW5FbmRwdC5wZlZhbHVlKSA9PT0gbnVsbCB8fCBfdGd0TWFuRW5kcHQkcGZWYWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX3RndE1hbkVuZHB0JHBmVmFsdWUubGVuZ3RoKSA9PT0gMiA/IHRndE1hbkVuZHB0LnBmVmFsdWUgOiBudWxsKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB1bmRlZmluZWQgPyBfcmVmIDogWzAsIDBdO1xuICB2YXIgc3JjTWFuRW5kcHRQdCA9IChfcmVmMiA9IChzcmNNYW5FbmRwdCA9PT0gbnVsbCB8fCBzcmNNYW5FbmRwdCA9PT0gdW5kZWZpbmVkIHx8IChfc3JjTWFuRW5kcHQkcGZWYWx1ZSA9IHNyY01hbkVuZHB0LnBmVmFsdWUpID09PSBudWxsIHx8IF9zcmNNYW5FbmRwdCRwZlZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfc3JjTWFuRW5kcHQkcGZWYWx1ZS5sZW5ndGgpID09PSAyID8gc3JjTWFuRW5kcHQucGZWYWx1ZSA6IG51bGwpICE9PSBudWxsICYmIF9yZWYyICE9PSB1bmRlZmluZWQgPyBfcmVmMiA6IFswLCAwXTtcbiAgaWYgKGJlemllcikge1xuICAgIHZhciBjcFN0YXJ0ID0gW3JzLmN0cmxwdHNbMF0sIHJzLmN0cmxwdHNbMV1dO1xuICAgIHZhciBjcEVuZCA9IG11bHRpID8gW3JzLmN0cmxwdHNbcnMuY3RybHB0cy5sZW5ndGggLSAyXSwgcnMuY3RybHB0c1tycy5jdHJscHRzLmxlbmd0aCAtIDFdXSA6IGNwU3RhcnQ7XG4gICAgcDEgPSBjcEVuZDtcbiAgICBwMiA9IGNwU3RhcnQ7XG4gIH0gZWxzZSBpZiAobGluZXMpIHtcbiAgICB2YXIgc3JjQXJyb3dGcm9tUHQgPSAhc2VnbWVudHMgPyBbdGd0UG9zLnggKyB0Z3RNYW5FbmRwdFB0WzBdLCB0Z3RQb3MueSArIHRndE1hbkVuZHB0UHRbMV1dIDogcnMuc2VncHRzLnNsaWNlKDAsIDIpO1xuICAgIHZhciB0Z3RBcnJvd0Zyb21QdCA9ICFzZWdtZW50cyA/IFtzcmNQb3MueCArIHNyY01hbkVuZHB0UHRbMF0sIHNyY1Bvcy55ICsgc3JjTWFuRW5kcHRQdFsxXV0gOiBycy5zZWdwdHMuc2xpY2UocnMuc2VncHRzLmxlbmd0aCAtIDIpO1xuICAgIHAxID0gdGd0QXJyb3dGcm9tUHQ7XG4gICAgcDIgPSBzcmNBcnJvd0Zyb21QdDtcbiAgfVxuICBpZiAodGd0TWFuRW5kcHRWYWwgPT09ICdpbnNpZGUtdG8tbm9kZScpIHtcbiAgICBpbnRlcnNlY3QgPSBbdGd0UG9zLngsIHRndFBvcy55XTtcbiAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdC51bml0cykge1xuICAgIGludGVyc2VjdCA9IHRoaXMubWFudWFsRW5kcHRUb1B4KHRhcmdldCwgdGd0TWFuRW5kcHQpO1xuICB9IGVsc2UgaWYgKHRndE1hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lJykge1xuICAgIGludGVyc2VjdCA9IHJzLnRndEludG47IC8vIHVzZSBjYWNoZWQgdmFsdWUgZnJvbSBjdHJscHQgY2FsY1xuICB9IGVsc2Uge1xuICAgIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZScgfHwgdGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnKSB7XG4gICAgICBwMV9pID0gcDE7XG4gICAgfSBlbHNlIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScgfHwgdGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICBwMV9pID0gW3NyY1Bvcy54LCBzcmNQb3MueV07XG4gICAgfVxuICAgIGludGVyc2VjdCA9IHIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKHRndFBvcy54LCB0Z3RQb3MueSwgdGFyZ2V0Lm91dGVyV2lkdGgoKSwgdGFyZ2V0Lm91dGVySGVpZ2h0KCksIHAxX2lbMF0sIHAxX2lbMV0sIDAsIHRndENvcm5lclJhZGl1cywgdGd0UnMpO1xuICAgIGlmICh0Z3RNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbm9kZS1vci1sYWJlbCcgfHwgdGd0TWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUtb3ItbGFiZWwnKSB7XG4gICAgICB2YXIgdHJzID0gdGFyZ2V0Ll9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIGx3ID0gdHJzLmxhYmVsV2lkdGg7XG4gICAgICB2YXIgbGggPSB0cnMubGFiZWxIZWlnaHQ7XG4gICAgICB2YXIgbHggPSB0cnMubGFiZWxYO1xuICAgICAgdmFyIGx5ID0gdHJzLmxhYmVsWTtcbiAgICAgIHZhciBsdzIgPSBsdyAvIDI7XG4gICAgICB2YXIgbGgyID0gbGggLyAyO1xuICAgICAgdmFyIHZhID0gdGFyZ2V0LnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZTtcbiAgICAgIGlmICh2YSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgbHkgLT0gbGgyO1xuICAgICAgfSBlbHNlIGlmICh2YSA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgbHkgKz0gbGgyO1xuICAgICAgfVxuICAgICAgdmFyIGhhID0gdGFyZ2V0LnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZTtcbiAgICAgIGlmIChoYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGx4IC09IGx3MjtcbiAgICAgIH0gZWxzZSBpZiAoaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgbHggKz0gbHcyO1xuICAgICAgfVxuICAgICAgdmFyIGxhYmVsSW50ZXJzZWN0ID0gcG9seWdvbkludGVyc2VjdExpbmUocDFfaVswXSwgcDFfaVsxXSwgW2x4IC0gbHcyLCBseSAtIGxoMiwgbHggKyBsdzIsIGx5IC0gbGgyLCBseCArIGx3MiwgbHkgKyBsaDIsIGx4IC0gbHcyLCBseSArIGxoMl0sIHRndFBvcy54LCB0Z3RQb3MueSk7XG4gICAgICBpZiAobGFiZWxJbnRlcnNlY3QubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcmVmUHQgPSBzcmNQb3M7XG4gICAgICAgIHZhciBpbnRTcWRpc3QgPSBzcWRpc3QocmVmUHQsIGFycmF5MnBvaW50KGludGVyc2VjdCkpO1xuICAgICAgICB2YXIgbGFiSW50U3FkaXN0ID0gc3FkaXN0KHJlZlB0LCBhcnJheTJwb2ludChsYWJlbEludGVyc2VjdCkpO1xuICAgICAgICB2YXIgbWluU3FEaXN0ID0gaW50U3FkaXN0O1xuICAgICAgICBpZiAobGFiSW50U3FkaXN0IDwgaW50U3FkaXN0KSB7XG4gICAgICAgICAgaW50ZXJzZWN0ID0gbGFiZWxJbnRlcnNlY3Q7XG4gICAgICAgICAgbWluU3FEaXN0ID0gbGFiSW50U3FkaXN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYWJlbEludGVyc2VjdC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgdmFyIGxhYkludDJTcURpc3QgPSBzcWRpc3QocmVmUHQsIHtcbiAgICAgICAgICAgIHg6IGxhYmVsSW50ZXJzZWN0WzJdLFxuICAgICAgICAgICAgeTogbGFiZWxJbnRlcnNlY3RbM11cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobGFiSW50MlNxRGlzdCA8IG1pblNxRGlzdCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0ID0gW2xhYmVsSW50ZXJzZWN0WzJdLCBsYWJlbEludGVyc2VjdFszXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBhcnJvd0VuZCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMSwgci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgdGd0RGlzdCk7XG4gIHZhciBlZGdlRW5kID0gc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIHAxLCByLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSArIHRndERpc3QpO1xuICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcbiAgaWYgKHNyY01hbkVuZHB0VmFsID09PSAnaW5zaWRlLXRvLW5vZGUnKSB7XG4gICAgaW50ZXJzZWN0ID0gW3NyY1Bvcy54LCBzcmNQb3MueV07XG4gIH0gZWxzZSBpZiAoc3JjTWFuRW5kcHQudW5pdHMpIHtcbiAgICBpbnRlcnNlY3QgPSB0aGlzLm1hbnVhbEVuZHB0VG9QeChzb3VyY2UsIHNyY01hbkVuZHB0KTtcbiAgfSBlbHNlIGlmIChzcmNNYW5FbmRwdFZhbCA9PT0gJ291dHNpZGUtdG8tbGluZScpIHtcbiAgICBpbnRlcnNlY3QgPSBycy5zcmNJbnRuOyAvLyB1c2UgY2FjaGVkIHZhbHVlIGZyb20gY3RybHB0IGNhbGNcbiAgfSBlbHNlIHtcbiAgICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUnIHx8IHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1ub2RlLW9yLWxhYmVsJykge1xuICAgICAgcDJfaSA9IHAyO1xuICAgIH0gZWxzZSBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLWxpbmUnIHx8IHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgcDJfaSA9IFt0Z3RQb3MueCwgdGd0UG9zLnldO1xuICAgIH1cbiAgICBpbnRlcnNlY3QgPSByLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShzcmNQb3MueCwgc3JjUG9zLnksIHNvdXJjZS5vdXRlcldpZHRoKCksIHNvdXJjZS5vdXRlckhlaWdodCgpLCBwMl9pWzBdLCBwMl9pWzFdLCAwLCBzcmNDb3JuZXJSYWRpdXMsIHNyY1JzKTtcbiAgICBpZiAoc3JjTWFuRW5kcHRWYWwgPT09ICdvdXRzaWRlLXRvLW5vZGUtb3ItbGFiZWwnIHx8IHNyY01hbkVuZHB0VmFsID09PSAnb3V0c2lkZS10by1saW5lLW9yLWxhYmVsJykge1xuICAgICAgdmFyIHNycyA9IHNvdXJjZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBfbHcgPSBzcnMubGFiZWxXaWR0aDtcbiAgICAgIHZhciBfbGggPSBzcnMubGFiZWxIZWlnaHQ7XG4gICAgICB2YXIgX2x4ID0gc3JzLmxhYmVsWDtcbiAgICAgIHZhciBfbHkgPSBzcnMubGFiZWxZO1xuICAgICAgdmFyIF9sdzIgPSBfbHcgLyAyO1xuICAgICAgdmFyIF9saDIgPSBfbGggLyAyO1xuICAgICAgdmFyIF92YSA9IHNvdXJjZS5wc3R5bGUoJ3RleHQtdmFsaWduJykudmFsdWU7XG4gICAgICBpZiAoX3ZhID09PSAndG9wJykge1xuICAgICAgICBfbHkgLT0gX2xoMjtcbiAgICAgIH0gZWxzZSBpZiAoX3ZhID09PSAnYm90dG9tJykge1xuICAgICAgICBfbHkgKz0gX2xoMjtcbiAgICAgIH1cbiAgICAgIHZhciBfaGEgPSBzb3VyY2UucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlO1xuICAgICAgaWYgKF9oYSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIF9seCAtPSBfbHcyO1xuICAgICAgfSBlbHNlIGlmIChfaGEgPT09ICdyaWdodCcpIHtcbiAgICAgICAgX2x4ICs9IF9sdzI7XG4gICAgICB9XG4gICAgICB2YXIgX2xhYmVsSW50ZXJzZWN0ID0gcG9seWdvbkludGVyc2VjdExpbmUocDJfaVswXSwgcDJfaVsxXSwgW19seCAtIF9sdzIsIF9seSAtIF9saDIsIF9seCArIF9sdzIsIF9seSAtIF9saDIsIF9seCArIF9sdzIsIF9seSArIF9saDIsIF9seCAtIF9sdzIsIF9seSArIF9saDJdLCBzcmNQb3MueCwgc3JjUG9zLnkpO1xuICAgICAgaWYgKF9sYWJlbEludGVyc2VjdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfcmVmUHQgPSB0Z3RQb3M7XG4gICAgICAgIHZhciBfaW50U3FkaXN0ID0gc3FkaXN0KF9yZWZQdCwgYXJyYXkycG9pbnQoaW50ZXJzZWN0KSk7XG4gICAgICAgIHZhciBfbGFiSW50U3FkaXN0ID0gc3FkaXN0KF9yZWZQdCwgYXJyYXkycG9pbnQoX2xhYmVsSW50ZXJzZWN0KSk7XG4gICAgICAgIHZhciBfbWluU3FEaXN0ID0gX2ludFNxZGlzdDtcbiAgICAgICAgaWYgKF9sYWJJbnRTcWRpc3QgPCBfaW50U3FkaXN0KSB7XG4gICAgICAgICAgaW50ZXJzZWN0ID0gW19sYWJlbEludGVyc2VjdFswXSwgX2xhYmVsSW50ZXJzZWN0WzFdXTtcbiAgICAgICAgICBfbWluU3FEaXN0ID0gX2xhYkludFNxZGlzdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xhYmVsSW50ZXJzZWN0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YXIgX2xhYkludDJTcURpc3QgPSBzcWRpc3QoX3JlZlB0LCB7XG4gICAgICAgICAgICB4OiBfbGFiZWxJbnRlcnNlY3RbMl0sXG4gICAgICAgICAgICB5OiBfbGFiZWxJbnRlcnNlY3RbM11cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoX2xhYkludDJTcURpc3QgPCBfbWluU3FEaXN0KSB7XG4gICAgICAgICAgICBpbnRlcnNlY3QgPSBbX2xhYmVsSW50ZXJzZWN0WzJdLCBfbGFiZWxJbnRlcnNlY3RbM11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgYXJyb3dTdGFydCA9IHNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBwMiwgci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpICsgc3JjRGlzdCk7XG4gIHZhciBlZGdlU3RhcnQgPSBzaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgcDIsIHIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpICsgc3JjRGlzdCk7XG4gIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcbiAgaWYgKGhhc0VuZHB0cykge1xuICAgIGlmICghbnVtYmVyJDEocnMuc3RhcnRYKSB8fCAhbnVtYmVyJDEocnMuc3RhcnRZKSB8fCAhbnVtYmVyJDEocnMuZW5kWCkgfHwgIW51bWJlciQxKHJzLmVuZFkpKSB7XG4gICAgICBycy5iYWRMaW5lID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnMuYmFkTGluZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxufTtcbkJScCRiLmdldFNvdXJjZUVuZHBvaW50ID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5oYXlzdGFja1B0c1swXSxcbiAgICAgICAgeTogcnMuaGF5c3RhY2tQdHNbMV1cbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmFycm93U3RhcnRYLFxuICAgICAgICB5OiBycy5hcnJvd1N0YXJ0WVxuICAgICAgfTtcbiAgfVxufTtcbkJScCRiLmdldFRhcmdldEVuZHBvaW50ID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIHJzID0gZWRnZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgdGhpcy5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoZWRnZSk7XG4gIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBycy5oYXlzdGFja1B0c1syXSxcbiAgICAgICAgeTogcnMuaGF5c3RhY2tQdHNbM11cbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJzLmFycm93RW5kWCxcbiAgICAgICAgeTogcnMuYXJyb3dFbmRZXG4gICAgICB9O1xuICB9XG59O1xuXG52YXIgQlJwJGEgPSB7fTtcbmZ1bmN0aW9uIHB1c2hCZXppZXJQdHMociwgZWRnZSwgcHRzKSB7XG4gIHZhciBxYmV6aWVyQXQkMSA9IGZ1bmN0aW9uIHFiZXppZXJBdCQxKHAxLCBwMiwgcDMsIHQpIHtcbiAgICByZXR1cm4gcWJlemllckF0KHAxLCBwMiwgcDMsIHQpO1xuICB9O1xuICB2YXIgX3AgPSBlZGdlLl9wcml2YXRlO1xuICB2YXIgYnB0cyA9IF9wLnJzdHlsZS5iZXppZXJQdHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgci5iZXppZXJQcm9qUGN0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gci5iZXppZXJQcm9qUGN0c1tpXTtcbiAgICBicHRzLnB1c2goe1xuICAgICAgeDogcWJlemllckF0JDEocHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgcCksXG4gICAgICB5OiBxYmV6aWVyQXQkMShwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCBwKVxuICAgIH0pO1xuICB9XG59XG5CUnAkYS5zdG9yZUVkZ2VQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgZXQgPSBycy5lZGdlVHlwZTtcblxuICAvLyBjbGVhciB0aGUgY2FjaGVkIHBvaW50cyBzdGF0ZVxuICBfcC5yc3R5bGUuYmV6aWVyUHRzID0gbnVsbDtcbiAgX3AucnN0eWxlLmxpbmVQdHMgPSBudWxsO1xuICBfcC5yc3R5bGUuaGF5c3RhY2tQdHMgPSBudWxsO1xuICBpZiAoZXQgPT09ICdtdWx0aWJlemllcicgfHwgZXQgPT09ICdiZXppZXInIHx8IGV0ID09PSAnc2VsZicgfHwgZXQgPT09ICdjb21wb3VuZCcpIHtcbiAgICBfcC5yc3R5bGUuYmV6aWVyUHRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBwdXNoQmV6aWVyUHRzKHRoaXMsIGVkZ2UsIHJzLmFsbHB0cy5zbGljZShpLCBpICsgNikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChldCA9PT0gJ3NlZ21lbnRzJykge1xuICAgIHZhciBscHRzID0gX3AucnN0eWxlLmxpbmVQdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSArIDEgPCBycy5hbGxwdHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGxwdHMucHVzaCh7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpXSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyAxXVxuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV0ID09PSAnaGF5c3RhY2snKSB7XG4gICAgdmFyIGhwdHMgPSBycy5oYXlzdGFja1B0cztcbiAgICBfcC5yc3R5bGUuaGF5c3RhY2tQdHMgPSBbe1xuICAgICAgeDogaHB0c1swXSxcbiAgICAgIHk6IGhwdHNbMV1cbiAgICB9LCB7XG4gICAgICB4OiBocHRzWzJdLFxuICAgICAgeTogaHB0c1szXVxuICAgIH1dO1xuICB9XG4gIF9wLnJzdHlsZS5hcnJvd1dpZHRoID0gdGhpcy5nZXRBcnJvd1dpZHRoKGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWUsIGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlKSAqIHRoaXMuYXJyb3dTaGFwZVdpZHRoO1xufTtcbkJScCRhLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zID0gZnVuY3Rpb24gKGVkZ2VzKSB7XG4gIHRoaXMuZmluZEVkZ2VDb250cm9sUG9pbnRzKGVkZ2VzKTtcbn07XG5cbnZhciBCUnAkOSA9IHt9O1xuQlJwJDkucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGNvbnRlbnQgPSBub2RlLnBzdHlsZSgnbGFiZWwnKS5zdHJWYWx1ZTtcbiAgaWYgKGVtcHR5U3RyaW5nKGNvbnRlbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0ZXh0WCwgdGV4dFk7XG4gIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gIHZhciBub2RlV2lkdGggPSBub2RlLndpZHRoKCk7XG4gIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHBhZGRpbmcgPSBub2RlLnBhZGRpbmcoKTtcbiAgdmFyIG5vZGVQb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciB0ZXh0SGFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtaGFsaWduJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0VmFsaWduID0gbm9kZS5wc3R5bGUoJ3RleHQtdmFsaWduJykuc3RyVmFsdWU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICBzd2l0Y2ggKHRleHRIYWxpZ24pIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHRleHRYID0gbm9kZVBvcy54IC0gbm9kZVdpZHRoIC8gMiAtIHBhZGRpbmc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueCArIG5vZGVXaWR0aCAvIDIgKyBwYWRkaW5nO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGUuZy4gY2VudGVyXG4gICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgfVxuICBzd2l0Y2ggKHRleHRWYWxpZ24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgdGV4dFkgPSBub2RlUG9zLnkgLSBub2RlSGVpZ2h0IC8gMiAtIHBhZGRpbmc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgdGV4dFkgPSBub2RlUG9zLnkgKyBub2RlSGVpZ2h0IC8gMiArIHBhZGRpbmc7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZS5nLiBtaWRkbGVcbiAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICB9XG4gIHJzLmxhYmVsWCA9IHRleHRYO1xuICBycy5sYWJlbFkgPSB0ZXh0WTtcbiAgcnN0eWxlLmxhYmVsWCA9IHRleHRYO1xuICByc3R5bGUubGFiZWxZID0gdGV4dFk7XG4gIHRoaXMuY2FsY3VsYXRlTGFiZWxBbmdsZXMobm9kZSk7XG4gIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMobm9kZSk7XG59O1xudmFyIGxpbmVBbmdsZUZyb21EZWx0YSA9IGZ1bmN0aW9uIGxpbmVBbmdsZUZyb21EZWx0YShkeCwgZHkpIHtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuKGR5IC8gZHgpO1xuICBpZiAoZHggPT09IDAgJiYgYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgPSBhbmdsZSAqIC0xO1xuICB9XG4gIHJldHVybiBhbmdsZTtcbn07XG52YXIgbGluZUFuZ2xlID0gZnVuY3Rpb24gbGluZUFuZ2xlKHAwLCBwMSkge1xuICB2YXIgZHggPSBwMS54IC0gcDAueDtcbiAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG4gIHJldHVybiBsaW5lQW5nbGVGcm9tRGVsdGEoZHgsIGR5KTtcbn07XG52YXIgYmV6aWVyQW5nbGUgPSBmdW5jdGlvbiBiZXppZXJBbmdsZShwMCwgcDEsIHAyLCB0KSB7XG4gIHZhciB0MCA9IGJvdW5kKDAsIHQgLSAwLjAwMSwgMSk7XG4gIHZhciB0MSA9IGJvdW5kKDAsIHQgKyAwLjAwMSwgMSk7XG4gIHZhciBscDAgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MCk7XG4gIHZhciBscDEgPSBxYmV6aWVyUHRBdChwMCwgcDEsIHAyLCB0MSk7XG4gIHJldHVybiBsaW5lQW5nbGUobHAwLCBscDEpO1xufTtcbkJScCQ5LnJlY2FsY3VsYXRlRWRnZUxhYmVsUHJvamVjdGlvbnMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgcDtcbiAgdmFyIF9wID0gZWRnZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNvbnRlbnQgPSB7XG4gICAgbWlkOiBlZGdlLnBzdHlsZSgnbGFiZWwnKS5zdHJWYWx1ZSxcbiAgICBzb3VyY2U6IGVkZ2UucHN0eWxlKCdzb3VyY2UtbGFiZWwnKS5zdHJWYWx1ZSxcbiAgICB0YXJnZXQ6IGVkZ2UucHN0eWxlKCd0YXJnZXQtbGFiZWwnKS5zdHJWYWx1ZVxuICB9O1xuICBpZiAoY29udGVudC5taWQgfHwgY29udGVudC5zb3VyY2UgfHwgY29udGVudC50YXJnZXQpIDsgZWxzZSB7XG4gICAgcmV0dXJuOyAvLyBubyBsYWJlbHMgPT4gbm8gY2FsY3NcbiAgfVxuXG4gIC8vIGFkZCBjZW50ZXIgcG9pbnQgdG8gc3R5bGUgc28gYm91bmRpbmcgYm94IGNhbGN1bGF0aW9ucyBjYW4gdXNlIGl0XG4gIC8vXG4gIHAgPSB7XG4gICAgeDogcnMubWlkWCxcbiAgICB5OiBycy5taWRZXG4gIH07XG4gIHZhciBzZXRScyA9IGZ1bmN0aW9uIHNldFJzKHByb3BOYW1lLCBwcmVmaXgsIHZhbHVlKSB7XG4gICAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgcHJvcE5hbWUsIHByZWZpeCwgdmFsdWUpO1xuICAgIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gIH07XG4gIHNldFJzKCdsYWJlbFgnLCBudWxsLCBwLngpO1xuICBzZXRScygnbGFiZWxZJywgbnVsbCwgcC55KTtcbiAgdmFyIG1pZEFuZ2xlID0gbGluZUFuZ2xlRnJvbURlbHRhKHJzLm1pZERpc3BYLCBycy5taWREaXNwWSk7XG4gIHNldFJzKCdsYWJlbEF1dG9BbmdsZScsIG51bGwsIG1pZEFuZ2xlKTtcbiAgdmFyIF9jcmVhdGVDb250cm9sUG9pbnRJbmZvID0gZnVuY3Rpb24gY3JlYXRlQ29udHJvbFBvaW50SW5mbygpIHtcbiAgICBpZiAoX2NyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGUpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlQ29udHJvbFBvaW50SW5mby5jYWNoZTtcbiAgICB9IC8vIHVzZSBjYWNoZSBzbyBvbmx5IDF4IHBlciBlZGdlXG5cbiAgICB2YXIgY3RybHB0cyA9IFtdO1xuXG4gICAgLy8gc3RvcmUgZWFjaCBjdHJscHQgaW5mbyBpbml0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgKyA1IDwgcnMuYWxscHRzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICB2YXIgcDAgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpXSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyAxXVxuICAgICAgfTtcbiAgICAgIHZhciBwMSA9IHtcbiAgICAgICAgeDogcnMuYWxscHRzW2kgKyAyXSxcbiAgICAgICAgeTogcnMuYWxscHRzW2kgKyAzXVxuICAgICAgfTsgLy8gY3RybHB0XG4gICAgICB2YXIgcDIgPSB7XG4gICAgICAgIHg6IHJzLmFsbHB0c1tpICsgNF0sXG4gICAgICAgIHk6IHJzLmFsbHB0c1tpICsgNV1cbiAgICAgIH07XG4gICAgICBjdHJscHRzLnB1c2goe1xuICAgICAgICBwMDogcDAsXG4gICAgICAgIHAxOiBwMSxcbiAgICAgICAgcDI6IHAyLFxuICAgICAgICBzdGFydERpc3Q6IDAsXG4gICAgICAgIGxlbmd0aDogMCxcbiAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGJwdHMgPSBfcC5yc3R5bGUuYmV6aWVyUHRzO1xuICAgIHZhciBuUHJvanMgPSByLmJlemllclByb2pQY3RzLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBhZGRTZWdtZW50KGNwLCBwMCwgcDEsIHQwLCB0MSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGRpc3QocDAsIHAxKTtcbiAgICAgIHZhciBwcmV2U2VnbWVudCA9IGNwLnNlZ21lbnRzW2NwLnNlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICAgIHAwOiBwMCxcbiAgICAgICAgcDE6IHAxLFxuICAgICAgICB0MDogdDAsXG4gICAgICAgIHQxOiB0MSxcbiAgICAgICAgc3RhcnREaXN0OiBwcmV2U2VnbWVudCA/IHByZXZTZWdtZW50LnN0YXJ0RGlzdCArIHByZXZTZWdtZW50Lmxlbmd0aCA6IDAsXG4gICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICB9O1xuICAgICAgY3Auc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgIGNwLmxlbmd0aCArPSBsZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGVhY2ggY3RybHB0IHdpdGggc2VnbWVudCBpbmZvXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGN0cmxwdHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgY3AgPSBjdHJscHRzW19pXTtcbiAgICAgIHZhciBwcmV2Q3AgPSBjdHJscHRzW19pIC0gMV07XG4gICAgICBpZiAocHJldkNwKSB7XG4gICAgICAgIGNwLnN0YXJ0RGlzdCA9IHByZXZDcC5zdGFydERpc3QgKyBwcmV2Q3AubGVuZ3RoO1xuICAgICAgfVxuICAgICAgYWRkU2VnbWVudChjcCwgY3AucDAsIGJwdHNbX2kgKiBuUHJvanNdLCAwLCByLmJlemllclByb2pQY3RzWzBdKTsgLy8gZmlyc3RcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBuUHJvanMgLSAxOyBqKyspIHtcbiAgICAgICAgYWRkU2VnbWVudChjcCwgYnB0c1tfaSAqIG5Qcm9qcyArIGpdLCBicHRzW19pICogblByb2pzICsgaiArIDFdLCByLmJlemllclByb2pQY3RzW2pdLCByLmJlemllclByb2pQY3RzW2ogKyAxXSk7XG4gICAgICB9XG4gICAgICBhZGRTZWdtZW50KGNwLCBicHRzW19pICogblByb2pzICsgblByb2pzIC0gMV0sIGNwLnAyLCByLmJlemllclByb2pQY3RzW25Qcm9qcyAtIDFdLCAxKTsgLy8gbGFzdFxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNvbnRyb2xQb2ludEluZm8uY2FjaGUgPSBjdHJscHRzO1xuICB9O1xuICB2YXIgY2FsY3VsYXRlRW5kUHJvamVjdGlvbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUVuZFByb2plY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGFuZ2xlO1xuICAgIHZhciBpc1NyYyA9IHByZWZpeCA9PT0gJ3NvdXJjZSc7XG4gICAgaWYgKCFjb250ZW50W3ByZWZpeF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9mZnNldCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctdGV4dC1vZmZzZXQnKS5wZlZhbHVlO1xuICAgIHN3aXRjaCAocnMuZWRnZVR5cGUpIHtcbiAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgIGNhc2UgJ211bHRpYmV6aWVyJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjcHMgPSBfY3JlYXRlQ29udHJvbFBvaW50SW5mbygpO1xuICAgICAgICAgIHZhciBzZWxlY3RlZDtcbiAgICAgICAgICB2YXIgc3RhcnREaXN0ID0gMDtcbiAgICAgICAgICB2YXIgdG90YWxEaXN0ID0gMDtcblxuICAgICAgICAgIC8vIGZpbmQgdGhlIHNlZ21lbnQgd2UncmUgb25cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIF9jcCA9IGNwc1tpc1NyYyA/IGkgOiBjcHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfY3Auc2VnbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9zZWcgPSBfY3Auc2VnbWVudHNbaXNTcmMgPyBqIDogX2NwLnNlZ21lbnRzLmxlbmd0aCAtIDEgLSBqXTtcbiAgICAgICAgICAgICAgdmFyIGxhc3RTZWcgPSBpID09PSBjcHMubGVuZ3RoIC0gMSAmJiBqID09PSBfY3Auc2VnbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgc3RhcnREaXN0ID0gdG90YWxEaXN0O1xuICAgICAgICAgICAgICB0b3RhbERpc3QgKz0gX3NlZy5sZW5ndGg7XG4gICAgICAgICAgICAgIGlmICh0b3RhbERpc3QgPj0gb2Zmc2V0IHx8IGxhc3RTZWcpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHtcbiAgICAgICAgICAgICAgICAgIGNwOiBfY3AsXG4gICAgICAgICAgICAgICAgICBzZWdtZW50OiBfc2VnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY3AgPSBzZWxlY3RlZC5jcDtcbiAgICAgICAgICB2YXIgc2VnID0gc2VsZWN0ZWQuc2VnbWVudDtcbiAgICAgICAgICB2YXIgdFNlZ21lbnQgPSAob2Zmc2V0IC0gc3RhcnREaXN0KSAvIHNlZy5sZW5ndGg7XG4gICAgICAgICAgdmFyIHNlZ0R0ID0gc2VnLnQxIC0gc2VnLnQwO1xuICAgICAgICAgIHZhciB0ID0gaXNTcmMgPyBzZWcudDAgKyBzZWdEdCAqIHRTZWdtZW50IDogc2VnLnQxIC0gc2VnRHQgKiB0U2VnbWVudDtcbiAgICAgICAgICB0ID0gYm91bmQoMCwgdCwgMSk7XG4gICAgICAgICAgcCA9IHFiZXppZXJQdEF0KGNwLnAwLCBjcC5wMSwgY3AucDIsIHQpO1xuICAgICAgICAgIGFuZ2xlID0gYmV6aWVyQW5nbGUoY3AucDAsIGNwLnAxLCBjcC5wMiwgdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgIGNhc2UgJ3NlZ21lbnRzJzpcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBkID0gMCxcbiAgICAgICAgICAgIGRpLFxuICAgICAgICAgICAgZDA7XG4gICAgICAgICAgdmFyIHAwLCBwMTtcbiAgICAgICAgICB2YXIgbCA9IHJzLmFsbHB0cy5sZW5ndGg7XG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyICsgMyA8IGw7IF9pMiArPSAyKSB7XG4gICAgICAgICAgICBpZiAoaXNTcmMpIHtcbiAgICAgICAgICAgICAgcDAgPSB7XG4gICAgICAgICAgICAgICAgeDogcnMuYWxscHRzW19pMl0sXG4gICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW19pMiArIDFdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHAxID0ge1xuICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tfaTIgKyAyXSxcbiAgICAgICAgICAgICAgICB5OiBycy5hbGxwdHNbX2kyICsgM11cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICAgIHg6IHJzLmFsbHB0c1tsIC0gMiAtIF9pMl0sXG4gICAgICAgICAgICAgICAgeTogcnMuYWxscHRzW2wgLSAxIC0gX2kyXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBwMSA9IHtcbiAgICAgICAgICAgICAgICB4OiBycy5hbGxwdHNbbCAtIDQgLSBfaTJdLFxuICAgICAgICAgICAgICAgIHk6IHJzLmFsbHB0c1tsIC0gMyAtIF9pMl1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpID0gZGlzdChwMCwgcDEpO1xuICAgICAgICAgICAgZDAgPSBkO1xuICAgICAgICAgICAgZCArPSBkaTtcbiAgICAgICAgICAgIGlmIChkID49IG9mZnNldCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBEID0gb2Zmc2V0IC0gZDA7XG4gICAgICAgICAgdmFyIF90ID0gcEQgLyBkaTtcbiAgICAgICAgICBfdCA9IGJvdW5kKDAsIF90LCAxKTtcbiAgICAgICAgICBwID0gbGluZUF0KHAwLCBwMSwgX3QpO1xuICAgICAgICAgIGFuZ2xlID0gbGluZUFuZ2xlKHAwLCBwMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UnMoJ2xhYmVsWCcsIHByZWZpeCwgcC54KTtcbiAgICBzZXRScygnbGFiZWxZJywgcHJlZml4LCBwLnkpO1xuICAgIHNldFJzKCdsYWJlbEF1dG9BbmdsZScsIHByZWZpeCwgYW5nbGUpO1xuICB9O1xuICBjYWxjdWxhdGVFbmRQcm9qZWN0aW9uKCdzb3VyY2UnKTtcbiAgY2FsY3VsYXRlRW5kUHJvamVjdGlvbigndGFyZ2V0Jyk7XG4gIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoZWRnZSk7XG59O1xuQlJwJDkuYXBwbHlMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUpO1xuICBpZiAoZWxlLmlzRWRnZSgpKSB7XG4gICAgdGhpcy5hcHBseVByZWZpeGVkTGFiZWxEaW1lbnNpb25zKGVsZSwgJ3NvdXJjZScpO1xuICAgIHRoaXMuYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyhlbGUsICd0YXJnZXQnKTtcbiAgfVxufTtcbkJScCQ5LmFwcGx5UHJlZml4ZWRMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCBwcmVmaXgpIHtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGVsZSwgcHJlZml4KTtcbiAgdmFyIGNhY2hlS2V5ID0gaGFzaFN0cmluZyh0ZXh0LCBlbGUuX3ByaXZhdGUubGFiZWxEaW1zS2V5KTtcblxuICAvLyBzYXZlIHJlY2FsYyBpZiB0aGUgbGFiZWwgaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG4gIGlmIChnZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAncHJlZml4ZWRMYWJlbERpbXNLZXknLCBwcmVmaXgpID09PSBjYWNoZUtleSkge1xuICAgIHJldHVybjsgLy8gdGhlbiB0aGUgbGFiZWwgZGltZW5zaW9ucyArIHRleHQgYXJlIHRoZSBzYW1lXG4gIH1cblxuICAvLyBzYXZlIHRoZSBrZXlcbiAgc2V0UHJlZml4ZWRQcm9wZXJ0eShfcC5yc2NyYXRjaCwgJ3ByZWZpeGVkTGFiZWxEaW1zS2V5JywgcHJlZml4LCBjYWNoZUtleSk7XG4gIHZhciBsYWJlbERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRleHQpO1xuICB2YXIgbGluZUhlaWdodCA9IGVsZS5wc3R5bGUoJ2xpbmUtaGVpZ2h0JykucGZWYWx1ZTtcbiAgdmFyIHRleHRXcmFwID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykuc3RyVmFsdWU7XG4gIHZhciBsaW5lcyA9IGdldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCkgfHwgW107XG4gIHZhciBudW1MaW5lcyA9IHRleHRXcmFwICE9PSAnd3JhcCcgPyAxIDogTWF0aC5tYXgobGluZXMubGVuZ3RoLCAxKTtcbiAgdmFyIG5vcm1QZXJMaW5lSGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodCAvIG51bUxpbmVzO1xuICB2YXIgbGFiZWxMaW5lSGVpZ2h0ID0gbm9ybVBlckxpbmVIZWlnaHQgKiBsaW5lSGVpZ2h0O1xuICB2YXIgd2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0ICsgKG51bUxpbmVzIC0gMSkgKiAobGluZUhlaWdodCAtIDEpICogbm9ybVBlckxpbmVIZWlnaHQ7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnN0eWxlLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxXaWR0aCcsIHByZWZpeCwgd2lkdGgpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzdHlsZSwgJ2xhYmVsSGVpZ2h0JywgcHJlZml4LCBoZWlnaHQpO1xuICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCAnbGFiZWxIZWlnaHQnLCBwcmVmaXgsIGhlaWdodCk7XG4gIHNldFByZWZpeGVkUHJvcGVydHkoX3AucnNjcmF0Y2gsICdsYWJlbExpbmVIZWlnaHQnLCBwcmVmaXgsIGxhYmVsTGluZUhlaWdodCk7XG59O1xuQlJwJDkuZ2V0TGFiZWxUZXh0ID0gZnVuY3Rpb24gKGVsZSwgcHJlZml4KSB7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHBmZCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICB2YXIgdGV4dCA9IGVsZS5wc3R5bGUocGZkICsgJ2xhYmVsJykuc3RyVmFsdWU7XG4gIHZhciB0ZXh0VHJhbnNmb3JtID0gZWxlLnBzdHlsZSgndGV4dC10cmFuc2Zvcm0nKS52YWx1ZTtcbiAgdmFyIHJzY3JhdGNoID0gZnVuY3Rpb24gcnNjcmF0Y2gocHJvcE5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBzZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KF9wLnJzY3JhdGNoLCBwcm9wTmFtZSwgcHJlZml4KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZm9yIGVtcHR5IHRleHQsIHNraXAgYWxsIHByb2Nlc3NpbmdcbiAgaWYgKCF0ZXh0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh0ZXh0VHJhbnNmb3JtID09ICdub25lJykgOyBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnKSB7XG4gICAgdGV4dCA9IHRleHQudG9VcHBlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICdsb3dlcmNhc2UnKSB7XG4gICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgfVxuICB2YXIgd3JhcFN0eWxlID0gZWxlLnBzdHlsZSgndGV4dC13cmFwJykudmFsdWU7XG4gIGlmICh3cmFwU3R5bGUgPT09ICd3cmFwJykge1xuICAgIHZhciBsYWJlbEtleSA9IHJzY3JhdGNoKCdsYWJlbEtleScpO1xuXG4gICAgLy8gc2F2ZSByZWNhbGMgaWYgdGhlIGxhYmVsIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuICAgIGlmIChsYWJlbEtleSAhPSBudWxsICYmIHJzY3JhdGNoKCdsYWJlbFdyYXBLZXknKSA9PT0gbGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiByc2NyYXRjaCgnbGFiZWxXcmFwQ2FjaGVkVGV4dCcpO1xuICAgIH1cbiAgICB2YXIgendzcCA9IFwiXFx1MjAwQlwiO1xuICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBtYXhXID0gZWxlLnBzdHlsZSgndGV4dC1tYXgtd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBvdmVyZmxvdyA9IGVsZS5wc3R5bGUoJ3RleHQtb3ZlcmZsb3ctd3JhcCcpLnZhbHVlO1xuICAgIHZhciBvdmVyZmxvd0FueSA9IG92ZXJmbG93ID09PSAnYW55d2hlcmUnO1xuICAgIHZhciB3cmFwcGVkTGluZXMgPSBbXTtcbiAgICB2YXIgc2VwYXJhdG9yUmVnZXggPSAvW1xcc1xcdTIwMGJdK3wkL2c7IC8vIEluY2x1ZGUgZW5kIG9mIHN0cmluZyB0byBhZGQgbGFzdCB3b3JkXG5cbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IGxpbmVzLmxlbmd0aDsgbCsrKSB7XG4gICAgICB2YXIgbGluZSA9IGxpbmVzW2xdO1xuICAgICAgdmFyIGxpbmVEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCBsaW5lKTtcbiAgICAgIHZhciBsaW5lVyA9IGxpbmVEaW1zLndpZHRoO1xuICAgICAgaWYgKG92ZXJmbG93QW55KSB7XG4gICAgICAgIHZhciBwcm9jZXNzZWRMaW5lID0gbGluZS5zcGxpdCgnJykuam9pbih6d3NwKTtcbiAgICAgICAgbGluZSA9IHByb2Nlc3NlZExpbmU7XG4gICAgICB9XG4gICAgICBpZiAobGluZVcgPiBtYXhXKSB7XG4gICAgICAgIC8vIGxpbmUgaXMgdG9vIGxvbmdcbiAgICAgICAgdmFyIHNlcGFyYXRvck1hdGNoZXMgPSBsaW5lLm1hdGNoQWxsKHNlcGFyYXRvclJlZ2V4KTtcbiAgICAgICAgdmFyIHN1YmxpbmUgPSAnJztcbiAgICAgICAgdmFyIHByZXZpb3VzSW5kZXggPSAwO1xuICAgICAgICAvLyBBZGQgZmFrZSBtYXRjaFxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc2VwYXJhdG9yTWF0Y2hlcyksXG4gICAgICAgICAgX3N0ZXA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBzZXBhcmF0b3JNYXRjaCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHdvcmRTZXBhcmF0b3IgPSBzZXBhcmF0b3JNYXRjaFswXTtcbiAgICAgICAgICAgIHZhciB3b3JkID0gbGluZS5zdWJzdHJpbmcocHJldmlvdXNJbmRleCwgc2VwYXJhdG9yTWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgcHJldmlvdXNJbmRleCA9IHNlcGFyYXRvck1hdGNoLmluZGV4ICsgd29yZFNlcGFyYXRvci5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgdGVzdExpbmUgPSBzdWJsaW5lLmxlbmd0aCA9PT0gMCA/IHdvcmQgOiBzdWJsaW5lICsgd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgICB2YXIgdGVzdERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyhlbGUsIHRlc3RMaW5lKTtcbiAgICAgICAgICAgIHZhciB0ZXN0VyA9IHRlc3REaW1zLndpZHRoO1xuICAgICAgICAgICAgaWYgKHRlc3RXIDw9IG1heFcpIHtcbiAgICAgICAgICAgICAgLy8gd29yZCBmaXRzIG9uIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICBzdWJsaW5lICs9IHdvcmQgKyB3b3JkU2VwYXJhdG9yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gd29yZCBzdGFydHMgbmV3IGxpbmVcbiAgICAgICAgICAgICAgaWYgKHN1YmxpbmUpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaChzdWJsaW5lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdWJsaW5lID0gd29yZCArIHdvcmRTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUncyByZW1haW5pbmcgdGV4dCwgcHV0IGl0IGluIGEgd3JhcHBlZCBsaW5lXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1YmxpbmUubWF0Y2goL15bXFxzXFx1MjAwYl0rJC8pKSB7XG4gICAgICAgICAgd3JhcHBlZExpbmVzLnB1c2goc3VibGluZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxpbmUgaXMgYWxyZWFkeSBzaG9ydCBlbm91Z2hcbiAgICAgICAgd3JhcHBlZExpbmVzLnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfSAvLyBmb3JcblxuICAgIHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHdyYXBwZWRMaW5lcyk7XG4gICAgdGV4dCA9IHJzY3JhdGNoKCdsYWJlbFdyYXBDYWNoZWRUZXh0Jywgd3JhcHBlZExpbmVzLmpvaW4oJ1xcbicpKTtcbiAgICByc2NyYXRjaCgnbGFiZWxXcmFwS2V5JywgbGFiZWxLZXkpO1xuICB9IGVsc2UgaWYgKHdyYXBTdHlsZSA9PT0gJ2VsbGlwc2lzJykge1xuICAgIHZhciBfbWF4VyA9IGVsZS5wc3R5bGUoJ3RleHQtbWF4LXdpZHRoJykucGZWYWx1ZTtcbiAgICB2YXIgZWxsaXBzaXplZCA9ICcnO1xuICAgIHZhciBlbGxpcHNpcyA9IFwiXFx1MjAyNlwiO1xuICAgIHZhciBpbmNMYXN0Q2ggPSBmYWxzZTtcbiAgICBpZiAodGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCB0ZXh0KS53aWR0aCA8IF9tYXhXKSB7XG4gICAgICAvLyB0aGUgbGFiZWwgYWxyZWFkeSBmaXRzXG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd2lkdGhXaXRoTmV4dENoID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoZWxlLCBlbGxpcHNpemVkICsgdGV4dFtpXSArIGVsbGlwc2lzKS53aWR0aDtcbiAgICAgIGlmICh3aWR0aFdpdGhOZXh0Q2ggPiBfbWF4Vykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVsbGlwc2l6ZWQgKz0gdGV4dFtpXTtcbiAgICAgIGlmIChpID09PSB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaW5jTGFzdENoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpbmNMYXN0Q2gpIHtcbiAgICAgIGVsbGlwc2l6ZWQgKz0gZWxsaXBzaXM7XG4gICAgfVxuICAgIHJldHVybiBlbGxpcHNpemVkO1xuICB9IC8vIGlmIGVsbGlwc2l6ZVxuXG4gIHJldHVybiB0ZXh0O1xufTtcbkJScCQ5LmdldExhYmVsSnVzdGlmaWNhdGlvbiA9IGZ1bmN0aW9uIChlbGUpIHtcbiAgdmFyIGp1c3RpZmljYXRpb24gPSBlbGUucHN0eWxlKCd0ZXh0LWp1c3RpZmljYXRpb24nKS5zdHJWYWx1ZTtcbiAgdmFyIHRleHRIYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnN0clZhbHVlO1xuICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2F1dG8nKSB7XG4gICAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgICAgc3dpdGNoICh0ZXh0SGFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGp1c3RpZmljYXRpb247XG4gIH1cbn07XG5CUnAkOS5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZWxlLCB0ZXh0KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHIuY3kud2luZG93KCk7XG4gIHZhciBkb2N1bWVudCA9IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudDtcbiAgdmFyIHBhZGRpbmcgPSAwOyAvLyBhZGQgcGFkZGluZyBhcm91bmQgdGV4dCBkaW1zLCBhcyB0aGUgbWVhc3VyZW1lbnQgaXNuJ3QgdGhhdCBhY2N1cmF0ZVxuICB2YXIgZlN0eWxlID0gZWxlLnBzdHlsZSgnZm9udC1zdHlsZScpLnN0clZhbHVlO1xuICB2YXIgc2l6ZSA9IGVsZS5wc3R5bGUoJ2ZvbnQtc2l6ZScpLnBmVmFsdWU7XG4gIHZhciBmYW1pbHkgPSBlbGUucHN0eWxlKCdmb250LWZhbWlseScpLnN0clZhbHVlO1xuICB2YXIgd2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgdmFyIGNhbnZhcyA9IHRoaXMubGFiZWxDYWxjQ2FudmFzO1xuICB2YXIgYzJkID0gdGhpcy5sYWJlbENhbGNDYW52YXNDb250ZXh0O1xuICBpZiAoIWNhbnZhcykge1xuICAgIGNhbnZhcyA9IHRoaXMubGFiZWxDYWxjQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgYzJkID0gdGhpcy5sYWJlbENhbGNDYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIGRzID0gY2FudmFzLnN0eWxlO1xuICAgIGRzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkcy5sZWZ0ID0gJy05OTk5cHgnO1xuICAgIGRzLnRvcCA9ICctOTk5OXB4JztcbiAgICBkcy56SW5kZXggPSAnLTEnO1xuICAgIGRzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICBkcy5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICB9XG4gIGMyZC5mb250ID0gXCJcIi5jb25jYXQoZlN0eWxlLCBcIiBcIikuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZmFtaWx5KTtcbiAgdmFyIHdpZHRoID0gMDtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICB2YXIgbWV0cmljcyA9IGMyZC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICB2YXIgdyA9IE1hdGguY2VpbChtZXRyaWNzLndpZHRoKTtcbiAgICB2YXIgaCA9IHNpemU7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3LCB3aWR0aCk7XG4gICAgaGVpZ2h0ICs9IGg7XG4gIH1cbiAgd2lkdGggKz0gcGFkZGluZztcbiAgaGVpZ2h0ICs9IHBhZGRpbmc7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG59O1xuQlJwJDkuY2FsY3VsYXRlTGFiZWxBbmdsZSA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICB2YXIgcHJlZml4RGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICB2YXIgcm90ID0gZWxlLnBzdHlsZShwcmVmaXhEYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgdmFyIHJvdFN0ciA9IHJvdC5zdHJWYWx1ZTtcbiAgaWYgKHJvdFN0ciA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoaXNFZGdlICYmIHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgcmV0dXJuIHJzLmxhYmVsQXV0b0FuZ2xlO1xuICB9IGVsc2UgaWYgKHJvdFN0ciA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJvdC5wZlZhbHVlO1xuICB9XG59O1xuQlJwJDkuY2FsY3VsYXRlTGFiZWxBbmdsZXMgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGlzRWRnZSA9IGVsZS5pc0VkZ2UoKTtcbiAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgcnMubGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUpO1xuICBpZiAoaXNFZGdlKSB7XG4gICAgcnMuc291cmNlTGFiZWxBbmdsZSA9IHIuY2FsY3VsYXRlTGFiZWxBbmdsZShlbGUsICdzb3VyY2UnKTtcbiAgICBycy50YXJnZXRMYWJlbEFuZ2xlID0gci5jYWxjdWxhdGVMYWJlbEFuZ2xlKGVsZSwgJ3RhcmdldCcpO1xuICB9XG59O1xuXG52YXIgQlJwJDggPSB7fTtcbnZhciBUT09fU01BTExfQ1VUX1JFQ1QgPSAyODtcbnZhciB3YXJuZWRDdXRSZWN0ID0gZmFsc2U7XG5CUnAkOC5nZXROb2RlU2hhcGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKCdzaGFwZScpLnZhbHVlO1xuICBpZiAoc2hhcGUgPT09ICdjdXRyZWN0YW5nbGUnICYmIChub2RlLndpZHRoKCkgPCBUT09fU01BTExfQ1VUX1JFQ1QgfHwgbm9kZS5oZWlnaHQoKSA8IFRPT19TTUFMTF9DVVRfUkVDVCkpIHtcbiAgICBpZiAoIXdhcm5lZEN1dFJlY3QpIHtcbiAgICAgIHdhcm4oJ1RoZSBgY3V0cmVjdGFuZ2xlYCBub2RlIHNoYXBlIGNhbiBub3QgYmUgdXNlZCBhdCBzbWFsbCBzaXplcyBzbyBgcmVjdGFuZ2xlYCBpcyB1c2VkIGluc3RlYWQnKTtcbiAgICAgIHdhcm5lZEN1dFJlY3QgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gIH1cbiAgaWYgKG5vZGUuaXNQYXJlbnQoKSkge1xuICAgIGlmIChzaGFwZSA9PT0gJ3JlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZC1yZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnY3V0cmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ2N1dC1yZWN0YW5nbGUnIHx8IHNoYXBlID09PSAnYmFycmVsJykge1xuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gICAgfVxuICB9XG4gIGlmIChzaGFwZSA9PT0gJ3BvbHlnb24nKSB7XG4gICAgdmFyIHBvaW50cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnZhbHVlO1xuICAgIHJldHVybiByLm5vZGVTaGFwZXMubWFrZVBvbHlnb24ocG9pbnRzKS5uYW1lO1xuICB9XG4gIHJldHVybiBzaGFwZTtcbn07XG5cbnZhciBCUnAkNyA9IHt9O1xuQlJwJDcucmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGN5ID0gdGhpcy5jeTtcbiAgdmFyIGVsZXNUb1VwZGF0ZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZW5xdWV1ZSA9IGZ1bmN0aW9uIGVucXVldWUoZWxlcykge1xuICAgIHZhciBkaXJ0eVN0eWxlQ2FjaGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgIGVsZXNUb1VwZGF0ZS5tZXJnZShlbGVzKTtcbiAgICBpZiAoZGlydHlTdHlsZUNhY2hlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgICAgIHJzdHlsZS5jbGVhbiA9IGZhbHNlO1xuICAgICAgICByc3R5bGUuY2xlYW5Db25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHIuYmluZGVyKGN5KS5vbignYm91bmRzLiogZGlydHkuKicsIGZ1bmN0aW9uIG9uRGlydHlCb3VuZHMoZSkge1xuICAgIHZhciBlbGUgPSBlLnRhcmdldDtcbiAgICBlbnF1ZXVlKGVsZSk7XG4gIH0pLm9uKCdzdHlsZS4qIGJhY2tncm91bmQuKicsIGZ1bmN0aW9uIG9uRGlydHlTdHlsZShlKSB7XG4gICAgdmFyIGVsZSA9IGUudGFyZ2V0O1xuICAgIGVucXVldWUoZWxlLCBmYWxzZSk7XG4gIH0pO1xuICB2YXIgdXBkYXRlRWxlQ2FsY3MgPSBmdW5jdGlvbiB1cGRhdGVFbGVDYWxjcyh3aWxsRHJhdykge1xuICAgIGlmICh3aWxsRHJhdykge1xuICAgICAgdmFyIGZucyA9IHIub25VcGRhdGVFbGVDYWxjc0ZucztcblxuICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGhhdmUgdXAtdG8tZGF0ZSBzdHlsZSAoZS5nLiBzdHlsZXNoZWV0IG1hcHBlcnMpXG4gICAgICAvLyBiZWZvcmUgY2FsY3VsYXRpbmcgcmVuZGVyZWQgc3R5bGUgKGFuZCBwc3R5bGUgbWlnaHQgbm90IGJlIGNhbGxlZCB5ZXQpXG4gICAgICBlbGVzVG9VcGRhdGUuY2xlYW5TdHlsZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzVG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNUb1VwZGF0ZVtpXTtcbiAgICAgICAgdmFyIHJzdHlsZSA9IGVsZS5fcHJpdmF0ZS5yc3R5bGU7XG4gICAgICAgIGlmIChlbGUuaXNOb2RlKCkgJiYgIXJzdHlsZS5jbGVhbkNvbm5lY3RlZCkge1xuICAgICAgICAgIGVucXVldWUoZWxlLmNvbm5lY3RlZEVkZ2VzKCkpO1xuICAgICAgICAgIHJzdHlsZS5jbGVhbkNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbnMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICB2YXIgZm4gPSBmbnNbX2ldO1xuICAgICAgICAgIGZuKHdpbGxEcmF3LCBlbGVzVG9VcGRhdGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZShlbGVzVG9VcGRhdGUpO1xuICAgICAgZWxlc1RvVXBkYXRlID0gY3kuY29sbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcbiAgci5mbHVzaFJlbmRlcmVkU3R5bGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB1cGRhdGVFbGVDYWxjcyh0cnVlKTtcbiAgfTtcbiAgci5iZWZvcmVSZW5kZXIodXBkYXRlRWxlQ2FsY3MsIHIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5lbGVDYWxjcyk7XG59O1xuQlJwJDcub25VcGRhdGVFbGVDYWxjcyA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgZm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zID0gdGhpcy5vblVwZGF0ZUVsZUNhbGNzRm5zIHx8IFtdO1xuICBmbnMucHVzaChmbik7XG59O1xuQlJwJDcucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24gKGVsZXMsIHVzZUNhY2hlKSB7XG4gIHZhciBpc0NsZWFuQ29ubmVjdGVkID0gZnVuY3Rpb24gaXNDbGVhbkNvbm5lY3RlZChlbGUpIHtcbiAgICByZXR1cm4gZWxlLl9wcml2YXRlLnJzdHlsZS5jbGVhbkNvbm5lY3RlZDtcbiAgfTtcbiAgaWYgKGVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBlZGdlcyA9IFtdO1xuICB2YXIgbm9kZXMgPSBbXTtcblxuICAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYmUgdXNlZCBmb3IgY2FsY3Mgd2hlbiBkZXN0cm95ZWQsIGUuZy4gZWxlLmJvdW5kaW5nQm94KClcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gdXNlIGNhY2hlIGJ5IGRlZmF1bHQgZm9yIHBlcmZcbiAgaWYgKHVzZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICB1c2VDYWNoZSA9IHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG5cbiAgICAvLyBhbiBlZGdlIG1heSBiZSBpbXBsaWNpdGx5IGRpcnR5IGIvYyBvZiBvbmUgb2YgaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgIC8vIChhbmQgYSByZXF1ZXN0IGZvciByZWNhbGMgbWF5IGNvbWUgaW4gYmV0d2VlbiBmcmFtZXMpXG4gICAgaWYgKGVsZS5pc0VkZ2UoKSAmJiAoIWlzQ2xlYW5Db25uZWN0ZWQoZWxlLnNvdXJjZSgpKSB8fCAhaXNDbGVhbkNvbm5lY3RlZChlbGUudGFyZ2V0KCkpKSkge1xuICAgICAgcnN0eWxlLmNsZWFuID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlbGUuaXNFZGdlKCkgJiYgZWxlLmlzQnVuZGxlZEJlemllcigpKSB7XG4gICAgICBpZiAoZWxlLnBhcmFsbGVsRWRnZXMoKS5zb21lKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgcmV0dXJuICFlbGUuX3ByaXZhdGUucnN0eWxlLmNsZWFuICYmIGVsZS5pc0J1bmRsZWRCZXppZXIoKTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHJzdHlsZS5jbGVhbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG9ubHkgdXBkYXRlIGlmIGRpcnR5IGFuZCBpbiBncmFwaFxuICAgIGlmICh1c2VDYWNoZSAmJiByc3R5bGUuY2xlYW4gfHwgZWxlLnJlbW92ZWQoKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gb25seSB1cGRhdGUgaWYgbm90IGRpc3BsYXk6IG5vbmVcbiAgICBpZiAoZWxlLnBzdHlsZSgnZGlzcGxheScpLnZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoX3AuZ3JvdXAgPT09ICdub2RlcycpIHtcbiAgICAgIG5vZGVzLnB1c2goZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWRnZXNcbiAgICAgIGVkZ2VzLnB1c2goZWxlKTtcbiAgICB9XG4gICAgcnN0eWxlLmNsZWFuID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBub2RlIGRhdGEgZnJvbSBwcm9qZWN0aW9uc1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2Rlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9lbGUgPSBub2Rlc1tfaTJdO1xuICAgIHZhciBfcDIgPSBfZWxlLl9wcml2YXRlO1xuICAgIHZhciBfcnN0eWxlID0gX3AyLnJzdHlsZTtcbiAgICB2YXIgcG9zID0gX2VsZS5wb3NpdGlvbigpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKF9lbGUpO1xuICAgIF9yc3R5bGUubm9kZVggPSBwb3MueDtcbiAgICBfcnN0eWxlLm5vZGVZID0gcG9zLnk7XG4gICAgX3JzdHlsZS5ub2RlVyA9IF9lbGUucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgX3JzdHlsZS5ub2RlSCA9IF9lbGUucHN0eWxlKCdoZWlnaHQnKS5wZlZhbHVlO1xuICB9XG4gIHRoaXMucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMoZWRnZXMpO1xuXG4gIC8vIHVwZGF0ZSBlZGdlIGRhdGEgZnJvbSBwcm9qZWN0aW9uc1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlZGdlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIF9lbGUyID0gZWRnZXNbX2kzXTtcbiAgICB2YXIgX3AzID0gX2VsZTIuX3ByaXZhdGU7XG4gICAgdmFyIF9yc3R5bGUyID0gX3AzLnJzdHlsZTtcbiAgICB2YXIgcnMgPSBfcDMucnNjcmF0Y2g7XG5cbiAgICAvLyB1cGRhdGUgcnN0eWxlIHBvc2l0aW9uc1xuICAgIF9yc3R5bGUyLnNyY1ggPSBycy5hcnJvd1N0YXJ0WDtcbiAgICBfcnN0eWxlMi5zcmNZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgX3JzdHlsZTIudGd0WCA9IHJzLmFycm93RW5kWDtcbiAgICBfcnN0eWxlMi50Z3RZID0gcnMuYXJyb3dFbmRZO1xuICAgIF9yc3R5bGUyLm1pZFggPSBycy5taWRYO1xuICAgIF9yc3R5bGUyLm1pZFkgPSBycy5taWRZO1xuICAgIF9yc3R5bGUyLmxhYmVsQW5nbGUgPSBycy5sYWJlbEFuZ2xlO1xuICAgIF9yc3R5bGUyLnNvdXJjZUxhYmVsQW5nbGUgPSBycy5zb3VyY2VMYWJlbEFuZ2xlO1xuICAgIF9yc3R5bGUyLnRhcmdldExhYmVsQW5nbGUgPSBycy50YXJnZXRMYWJlbEFuZ2xlO1xuICB9XG59O1xuXG52YXIgQlJwJDYgPSB7fTtcbkJScCQ2LnVwZGF0ZUNhY2hlZEdyYWJiZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG4gIGlmICghZWxlcykge1xuICAgIC8vIGp1c3QgbGV0IHRoaXMgYmUgcmVjYWxjdWxhdGVkIG9uIHRoZSBuZXh0IHogc29ydCB0aWNrXG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZXMuZHJhZyA9IFtdO1xuICBlbGVzLm5vbmRyYWcgPSBbXTtcbiAgdmFyIGdyYWJUYXJnZXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBpZiAoZWxlLmdyYWJiZWQoKSAmJiAhZWxlLmlzUGFyZW50KCkpIHtcbiAgICAgIGdyYWJUYXJnZXRzLnB1c2goZWxlKTtcbiAgICB9IGVsc2UgaWYgKHJzLmluRHJhZ0xheWVyKSB7XG4gICAgICBlbGVzLmRyYWcucHVzaChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzLm5vbmRyYWcucHVzaChlbGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHB1dCB0aGUgZ3JhYiB0YXJnZXQgbm9kZXMgbGFzdCBzbyBpdCdzIG9uIHRvcCBvZiBpdHMgbmVpZ2hib3VyaG9vZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYWJUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGdyYWJUYXJnZXRzW2ldO1xuICAgIGVsZXMuZHJhZy5wdXNoKGVsZSk7XG4gIH1cbn07XG5CUnAkNi5pbnZhbGlkYXRlQ2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBudWxsO1xufTtcbkJScCQ2LmdldENhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24gKGZvcmNlUmVjYWxjKSB7XG4gIGlmIChmb3JjZVJlY2FsYyB8fCAhdGhpcy5jYWNoZWRaU29ydGVkRWxlcykge1xuICAgIHZhciBlbGVzID0gdGhpcy5jeS5tdXRhYmxlRWxlbWVudHMoKS50b0FycmF5KCk7XG4gICAgZWxlcy5zb3J0KHpJbmRleFNvcnQpO1xuICAgIGVsZXMuaW50ZXJhY3RpdmUgPSBlbGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICByZXR1cm4gZWxlLmludGVyYWN0aXZlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5jYWNoZWRaU29ydGVkRWxlcyA9IGVsZXM7XG4gICAgdGhpcy51cGRhdGVDYWNoZWRHcmFiYmVkRWxlcygpO1xuICB9IGVsc2Uge1xuICAgIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuICB9XG4gIHJldHVybiBlbGVzO1xufTtcblxudmFyIEJScCQ1ID0ge307XG5bQlJwJGUsIEJScCRkLCBCUnAkYywgQlJwJGIsIEJScCRhLCBCUnAkOSwgQlJwJDgsIEJScCQ3LCBCUnAkNl0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKEJScCQ1LCBwcm9wcyk7XG59KTtcblxudmFyIEJScCQ0ID0ge307XG5CUnAkNC5nZXRDYWNoZWRJbWFnZSA9IGZ1bmN0aW9uICh1cmwsIGNyb3NzT3JpZ2luLCBvbkxvYWQpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSB8fCB7fTtcbiAgdmFyIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdO1xuICBpZiAoY2FjaGUpIHtcbiAgICBpZiAoIWNhY2hlLmltYWdlLmNvbXBsZXRlKSB7XG4gICAgICBjYWNoZS5pbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlLmltYWdlO1xuICB9IGVsc2Uge1xuICAgIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdID0gaW1hZ2VDYWNoZVt1cmxdIHx8IHt9O1xuICAgIHZhciBpbWFnZSA9IGNhY2hlLmltYWdlID0gbmV3IEltYWdlKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgaW1hZ2UuZXJyb3IgPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gIzE1ODIgc2FmYXJpIGRvZXNuJ3QgbG9hZCBkYXRhIHVyaXMgd2l0aCBjcm9zc09yaWdpbiBwcm9wZXJseVxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjM5NzhcbiAgICB2YXIgZGF0YVVyaVByZWZpeCA9ICdkYXRhOic7XG4gICAgdmFyIGlzRGF0YVVyaSA9IHVybC5zdWJzdHJpbmcoMCwgZGF0YVVyaVByZWZpeC5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IGRhdGFVcmlQcmVmaXg7XG4gICAgaWYgKCFpc0RhdGFVcmkpIHtcbiAgICAgIC8vIGlmIGNyb3Nzb3JpZ2luIGlzICdudWxsJyhzdHJpbmdpZmllZCksIHRoZW4gbWFudWFsbHkgc2V0IGl0IHRvIG51bGwgXG4gICAgICBjcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luID09PSAnbnVsbCcgPyBudWxsIDogY3Jvc3NPcmlnaW47XG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luOyAvLyBwcmV2ZW50IHRhaW50ZWQgY2FudmFzXG4gICAgfVxuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH1cbn07XG5cbnZhciBCUnAkMyA9IHt9O1xuXG4vKiBnbG9iYWwgZG9jdW1lbnQsIFJlc2l6ZU9ic2VydmVyLCBNdXRhdGlvbk9ic2VydmVyICovXG5cbkJScCQzLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzLCBbMV0pOyAvLyBjb3B5XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHQgPSB0YXJnZXRbaV07XG4gICAgICBpZiAodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBiID0gdGhpcy5iaW5kZXIodCk7XG4gICAgICAgIHJlcy5wdXNoKGIub24uYXBwbHkoYiwgYXJncykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIHZhciBiID0gdGhpcy5iaW5kZXIodGFyZ2V0KTtcbiAgcmV0dXJuIGIub24uYXBwbHkoYiwgYXJncyk7XG59O1xuQlJwJDMuYmluZGVyID0gZnVuY3Rpb24gKHRndCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjb250YWluZXJXaW5kb3cgPSByLmN5LndpbmRvdygpO1xuICB2YXIgdGd0SXNEb20gPSB0Z3QgPT09IGNvbnRhaW5lcldpbmRvdyB8fCB0Z3QgPT09IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudCB8fCB0Z3QgPT09IGNvbnRhaW5lcldpbmRvdy5kb2N1bWVudC5ib2R5IHx8IGRvbUVsZW1lbnQodGd0KTtcbiAgaWYgKHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzID09IG51bGwpIHtcbiAgICAvLyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kI2ZlYXR1cmUtZGV0ZWN0aW9uXG4gICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29udGFpbmVyV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIG5vdCBzdXBwb3J0ZWRcbiAgICB9XG4gICAgci5zdXBwb3J0c1Bhc3NpdmVFdmVudHMgPSBzdXBwb3J0c1Bhc3NpdmU7XG4gIH1cbiAgdmFyIG9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgaWYgKHRndElzRG9tICYmIHIuc3VwcG9ydHNQYXNzaXZlRXZlbnRzKSB7XG4gICAgICAvLyByZXBsYWNlIHVzZUNhcHR1cmUgdy8gb3B0cyBvYmpcbiAgICAgIGFyZ3NbMl0gPSB7XG4gICAgICAgIGNhcHR1cmU6IHVzZUNhcHR1cmUgIT0gbnVsbCA/IHVzZUNhcHR1cmUgOiBmYWxzZSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIG9uY2U6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICByLmJpbmRpbmdzLnB1c2goe1xuICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICBhcmdzOiBhcmdzXG4gICAgfSk7XG4gICAgKHRndC5hZGRFdmVudExpc3RlbmVyIHx8IHRndC5vbikuYXBwbHkodGd0LCBhcmdzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBvbjogb24sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogb24sXG4gICAgYWRkTGlzdGVuZXI6IG9uLFxuICAgIGJpbmQ6IG9uXG4gIH07XG59O1xuQlJwJDMubm9kZUlzRHJhZ2dhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5pc05vZGUoKSAmJiAhbm9kZS5sb2NrZWQoKSAmJiBub2RlLmdyYWJiYWJsZSgpO1xufTtcbkJScCQzLm5vZGVJc0dyYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiB0aGlzLm5vZGVJc0RyYWdnYWJsZShub2RlKSAmJiBub2RlLmludGVyYWN0aXZlKCk7XG59O1xuQlJwJDMubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gci5jeS53aW5kb3coKTtcbiAgdmFyIGlzU2VsZWN0ZWQgPSBmdW5jdGlvbiBpc1NlbGVjdGVkKGVsZSkge1xuICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKTtcbiAgfTtcbiAgdmFyIGdldFNoYWRvd1Jvb3QgPSBmdW5jdGlvbiBnZXRTaGFkb3dSb290KGVsZW1lbnQpIHtcbiAgICB2YXIgcm9vdE5vZGUgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJvb3Qgbm9kZSBpcyBhIHNoYWRvdyByb290XG4gICAgaWYgKHJvb3ROb2RlICYmIHJvb3ROb2RlLm5vZGVUeXBlID09PSAxMSAmJiByb290Tm9kZS5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByb290Tm9kZTtcbiAgICB9XG4gIH07XG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24gdHJpZ2dlckV2ZW50cyh0YXJnZXQsIG5hbWVzLCBlLCBwb3NpdGlvbikge1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgdGFyZ2V0ID0gci5jeTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHRhcmdldC5lbWl0KHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogbmFtZSxcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHZhciBpc011bHRTZWxLZXlEb3duID0gZnVuY3Rpb24gaXNNdWx0U2VsS2V5RG93bihlKSB7XG4gICAgcmV0dXJuIGUuc2hpZnRLZXkgfHwgZS5tZXRhS2V5IHx8IGUuY3RybEtleTsgLy8gbWF5YmUgZS5hbHRLZXlcbiAgfTtcbiAgdmFyIGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoID0gZnVuY3Rpb24gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goZG93biwgZG93bnMpIHtcbiAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IHRydWU7XG4gICAgaWYgKHIuY3kuaGFzQ29tcG91bmROb2RlcygpICYmIGRvd24gJiYgZG93bi5wYW5uYWJsZSgpKSB7XG4gICAgICAvLyBhIGdyYWJiYWJsZSBjb21wb3VuZCBub2RlIGJlbG93IHRoZSBlbGUgPT4gbm8gcGFzc3Rocm91Z2ggcGFubmluZ1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGRvd25zICYmIGkgPCBkb3ducy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZG93biA9IGRvd25zW2ldO1xuXG4gICAgICAgIC8vaWYgYW55IHBhcmVudCBub2RlIGluIGV2ZW50IGhpZXJhcmNoeSBpc24ndCBwYW5uYWJsZSwgcmVqZWN0IHBhc3N0aHJvdWdoXG4gICAgICAgIGlmIChkb3duLmlzTm9kZSgpICYmIGRvd24uaXNQYXJlbnQoKSAmJiAhZG93bi5wYW5uYWJsZSgpKSB7XG4gICAgICAgICAgYWxsb3dQYXNzdGhyb3VnaCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsbG93UGFzc3Rocm91Z2ggPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYWxsb3dQYXNzdGhyb3VnaDtcbiAgfTtcbiAgdmFyIHNldEdyYWJiZWQgPSBmdW5jdGlvbiBzZXRHcmFiYmVkKGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5ncmFiYmVkID0gdHJ1ZTtcbiAgfTtcbiAgdmFyIHNldEZyZWVkID0gZnVuY3Rpb24gc2V0RnJlZWQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgfTtcbiAgdmFyIHNldEluRHJhZ0xheWVyID0gZnVuY3Rpb24gc2V0SW5EcmFnTGF5ZXIoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgfTtcbiAgdmFyIHNldE91dERyYWdMYXllciA9IGZ1bmN0aW9uIHNldE91dERyYWdMYXllcihlbGUpIHtcbiAgICBlbGVbMF0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgfTtcbiAgdmFyIHNldEdyYWJUYXJnZXQgPSBmdW5jdGlvbiBzZXRHcmFiVGFyZ2V0KGVsZSkge1xuICAgIGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaC5pc0dyYWJUYXJnZXQgPSB0cnVlO1xuICB9O1xuICB2YXIgcmVtb3ZlR3JhYlRhcmdldCA9IGZ1bmN0aW9uIHJlbW92ZUdyYWJUYXJnZXQoZWxlKSB7XG4gICAgZWxlWzBdLl9wcml2YXRlLnJzY3JhdGNoLmlzR3JhYlRhcmdldCA9IGZhbHNlO1xuICB9O1xuICB2YXIgYWRkVG9EcmFnTGlzdCA9IGZ1bmN0aW9uIGFkZFRvRHJhZ0xpc3QoZWxlLCBvcHRzKSB7XG4gICAgdmFyIGxpc3QgPSBvcHRzLmFkZFRvTGlzdDtcbiAgICB2YXIgbGlzdEhhc0VsZSA9IGxpc3QuaGFzKGVsZSk7XG4gICAgaWYgKCFsaXN0SGFzRWxlICYmIGVsZS5ncmFiYmFibGUoKSAmJiAhZWxlLmxvY2tlZCgpKSB7XG4gICAgICBsaXN0Lm1lcmdlKGVsZSk7XG4gICAgICBzZXRHcmFiYmVkKGVsZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggY2hpbGQgbm9kZXMgYW5kIGlubmVyIGVkZ2VzXG4gIC8vIG9mIGEgY29tcG91bmQgbm9kZSB0byBiZSBkcmFnZ2VkIGFzIHdlbGwgYXMgdGhlIGdyYWJiZWQgYW5kIHNlbGVjdGVkIG5vZGVzXG4gIHZhciBhZGREZXNjZW5kYW50c1RvRHJhZyA9IGZ1bmN0aW9uIGFkZERlc2NlbmRhbnRzVG9EcmFnKG5vZGUsIG9wdHMpIHtcbiAgICBpZiAoIW5vZGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICB2YXIgaW5uZXJOb2RlcyA9IG5vZGUuZGVzY2VuZGFudHMoKTtcbiAgICBpZiAob3B0cy5pbkRyYWdMYXllcikge1xuICAgICAgaW5uZXJOb2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIGlubmVyTm9kZXMuY29ubmVjdGVkRWRnZXMoKS5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICBhZGRUb0RyYWdMaXN0KGlubmVyTm9kZXMsIG9wdHMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBhZGRzIHRoZSBnaXZlbiBub2RlcyBhbmQgaXRzIG5laWdoYm91cmhvb2QgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgdmFyIGFkZE5vZGVzVG9EcmFnID0gZnVuY3Rpb24gYWRkTm9kZXNUb0RyYWcobm9kZXMsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IG5vZGVzLmN5KCkuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICBub2Rlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIG5vZGVzLm5laWdoYm9yaG9vZCgpLnN0ZEZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgIHJldHVybiAhaGFzQ29tcG91bmROb2RlcyB8fCBlbGUuaXNFZGdlKCk7XG4gICAgICB9KS5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuYWRkVG9MaXN0KSB7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgYWRkVG9EcmFnTGlzdChlbGUsIG9wdHMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGFkZERlc2NlbmRhbnRzVG9EcmFnKG5vZGVzLCBvcHRzKTsgLy8gYWx3YXlzIGFkZCB0byBkcmFnXG5cbiAgICAvLyBhbHNvIGFkZCBub2RlcyBhbmQgZWRnZXMgcmVsYXRlZCB0byB0aGUgdG9wbW9zdCBhbmNlc3RvclxuICAgIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKG5vZGVzLCB7XG4gICAgICBpbkRyYWdMYXllcjogb3B0cy5pbkRyYWdMYXllclxuICAgIH0pO1xuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTtcbiAgdmFyIGFkZE5vZGVUb0RyYWcgPSBhZGROb2Rlc1RvRHJhZztcbiAgdmFyIGZyZWVEcmFnZ2VkRWxlbWVudHMgPSBmdW5jdGlvbiBmcmVlRHJhZ2dlZEVsZW1lbnRzKGdyYWJiZWRFbGVzKSB7XG4gICAgaWYgKCFncmFiYmVkRWxlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGp1c3QgZ28gb3ZlciBhbGwgZWxlbWVudHMgcmF0aGVyIHRoYW4gZG9pbmcgYSBidW5jaCBvZiAocG9zc2libHkgZXhwZW5zaXZlKSB0cmF2ZXJzYWxzXG4gICAgci5nZXRDYWNoZWRaU29ydGVkRWxlcygpLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgc2V0RnJlZWQoZWxlKTtcbiAgICAgIHNldE91dERyYWdMYXllcihlbGUpO1xuICAgICAgcmVtb3ZlR3JhYlRhcmdldChlbGUpO1xuICAgIH0pO1xuICAgIHIudXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMoKTtcbiAgfTtcblxuICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGFuY2VzdG9yIG5vZGVzIGFuZCBlZGdlcyBzaG91bGQgZ29cbiAgLy8gdG8gdGhlIGRyYWcgbGF5ZXIgKG9yIHNob3VsZCBiZSByZW1vdmVkIGZyb20gZHJhZyBsYXllcikuXG4gIHZhciB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciA9IGZ1bmN0aW9uIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKG5vZGUsIG9wdHMpIHtcbiAgICBpZiAob3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgIGlmICghbm9kZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSBub2RlLmFuY2VzdG9ycygpLm9ycGhhbnMoKTtcblxuICAgIC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgICBpZiAocGFyZW50LnNhbWUobm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vZGVzID0gcGFyZW50LmRlc2NlbmRhbnRzKCkuc3Bhd25TZWxmKCkubWVyZ2UocGFyZW50KS51bm1lcmdlKG5vZGUpLnVubWVyZ2Uobm9kZS5kZXNjZW5kYW50cygpKTtcbiAgICB2YXIgZWRnZXMgPSBub2Rlcy5jb25uZWN0ZWRFZGdlcygpO1xuICAgIGlmIChvcHRzLmluRHJhZ0xheWVyKSB7XG4gICAgICBlZGdlcy5mb3JFYWNoKHNldEluRHJhZ0xheWVyKTtcbiAgICAgIG5vZGVzLmZvckVhY2goc2V0SW5EcmFnTGF5ZXIpO1xuICAgIH1cbiAgICBpZiAob3B0cy5hZGRUb0xpc3QpIHtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICBhZGRUb0RyYWdMaXN0KGVsZSwgb3B0cyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHZhciBibHVyQWN0aXZlRG9tRWxlbWVudCA9IGZ1bmN0aW9uIGJsdXJBY3RpdmVEb21FbGVtZW50KCkge1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9IG51bGwgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyICE9IG51bGwpIHtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgfTtcbiAgdmFyIGhhdmVNdXRhdGlvbnNBcGkgPSB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBoYXZlUmVzaXplT2JzZXJ2ZXJBcGkgPSB0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xuXG4gIC8vIHdhdGNoIGZvciB3aGVuIHRoZSBjeSBjb250YWluZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBkb21cbiAgaWYgKGhhdmVNdXRhdGlvbnNBcGkpIHtcbiAgICByLnJlbW92ZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dG5zKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11dG5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtdXRuID0gbXV0bnNbaV07XG4gICAgICAgIHZhciByTm9kZXMgPSBtdXRuLnJlbW92ZWROb2RlcztcbiAgICAgICAgaWYgKHJOb2Rlcykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgck5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgck5vZGUgPSByTm9kZXNbal07XG4gICAgICAgICAgICBpZiAock5vZGUgPT09IHIuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoci5jb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgci5yZW1vdmVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyLnBhcmVudE5vZGUsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICByLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgfVxuICB2YXIgb25SZXNpemUgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgci5jeS5yZXNpemUoKTtcbiAgfSwgMTAwKTtcbiAgaWYgKGhhdmVNdXRhdGlvbnNBcGkpIHtcbiAgICByLnN0eWxlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihvblJlc2l6ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIuc3R5bGVPYnNlcnZlci5vYnNlcnZlKHIuY29udGFpbmVyLCB7XG4gICAgICBhdHRyaWJ1dGVzOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvLyBhdXRvIHJlc2l6ZVxuICByLnJlZ2lzdGVyQmluZGluZyhjb250YWluZXJXaW5kb3csICdyZXNpemUnLCBvblJlc2l6ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICBpZiAoaGF2ZVJlc2l6ZU9ic2VydmVyQXBpKSB7XG4gICAgci5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihvblJlc2l6ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIHIucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyLmNvbnRhaW5lcik7XG4gIH1cbiAgdmFyIGZvckVhY2hVcCA9IGZ1bmN0aW9uIGZvckVhY2hVcChkb21FbGUsIGZuKSB7XG4gICAgd2hpbGUgKGRvbUVsZSAhPSBudWxsKSB7XG4gICAgICBmbihkb21FbGUpO1xuICAgICAgZG9tRWxlID0gZG9tRWxlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9O1xuICB2YXIgaW52YWxpZGF0ZUNvb3JkcyA9IGZ1bmN0aW9uIGludmFsaWRhdGVDb29yZHMoKSB7XG4gICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgfTtcbiAgZm9yRWFjaFVwKHIuY29udGFpbmVyLCBmdW5jdGlvbiAoZG9tRWxlKSB7XG4gICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAndHJhbnNpdGlvbmVuZCcsIGludmFsaWRhdGVDb29yZHMpO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ2FuaW1hdGlvbmVuZCcsIGludmFsaWRhdGVDb29yZHMpO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3Njcm9sbCcsIGludmFsaWRhdGVDb29yZHMpO1xuICB9KTtcblxuICAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdjb250ZXh0bWVudScsIGZ1bmN0aW9uIChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9KTtcbiAgdmFyIGluQm94U2VsZWN0aW9uID0gZnVuY3Rpb24gaW5Cb3hTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHIuc2VsZWN0aW9uWzRdICE9PSAwO1xuICB9O1xuICB2YXIgZXZlbnRJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIGV2ZW50SW5Db250YWluZXIoZSkge1xuICAgIC8vIHNhdmUgY3ljbGVzIGlmIG1vdXNlIGV2ZW50cyBhcmVuJ3QgdG8gYmUgY2FwdHVyZWRcbiAgICB2YXIgY29udGFpbmVyUGFnZUNvb3JkcyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgIHZhciB4ID0gY29udGFpbmVyUGFnZUNvb3Jkc1swXTtcbiAgICB2YXIgeSA9IGNvbnRhaW5lclBhZ2VDb29yZHNbMV07XG4gICAgdmFyIHdpZHRoID0gY29udGFpbmVyUGFnZUNvb3Jkc1syXTtcbiAgICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyUGFnZUNvb3Jkc1szXTtcbiAgICB2YXIgcG9zaXRpb25zID0gZS50b3VjaGVzID8gZS50b3VjaGVzIDogW2VdO1xuICAgIHZhciBhdExlYXN0T25lUG9zSW5zaWRlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcG9zaXRpb25zW2ldO1xuICAgICAgaWYgKHggPD0gcC5jbGllbnRYICYmIHAuY2xpZW50WCA8PSB4ICsgd2lkdGggJiYgeSA8PSBwLmNsaWVudFkgJiYgcC5jbGllbnRZIDw9IHkgKyBoZWlnaHQpIHtcbiAgICAgICAgYXRMZWFzdE9uZVBvc0luc2lkZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWF0TGVhc3RPbmVQb3NJbnNpZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvbnRhaW5lciA9IHIuY29udGFpbmVyO1xuICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICB2YXIgdFBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgIHZhciBjb250YWluZXJJc1RhcmdldCA9IGZhbHNlO1xuICAgIHdoaWxlICh0UGFyZW50KSB7XG4gICAgICBpZiAodFBhcmVudCA9PT0gY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnRhaW5lcklzVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0UGFyZW50ID0gdFBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICBpZiAoIWNvbnRhaW5lcklzVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBpZiB0YXJnZXQgaXMgb3V0aXNkZSBjeSBjb250YWluZXIsIHRoZW4gdGhpcyBldmVudCBpcyBub3QgZm9yIHVzXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQcmltYXJ5IGtleVxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlZG93bicsIGZ1bmN0aW9uIG1vdXNlZG93bkhhbmRsZXIoZSkge1xuICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGR1cmluZyBsZWZ0IG1vdXNlIGJ1dHRvbiBnZXN0dXJlcywgaWdub3JlIG90aGVyIGJ1dHRvbnNcbiAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDEgJiYgZS53aGljaCAhPT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgYmx1ckFjdGl2ZURvbUVsZW1lbnQoKTtcbiAgICByLmhvdmVyRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICByLmhvdmVyRGF0YS53aGljaCA9IGUud2hpY2g7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgZ3BvcyA9IFtlLmNsaWVudFgsIGUuY2xpZW50WV07XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChncG9zWzBdLCBncG9zWzFdKTtcbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIG5lYXJzID0gci5maW5kTmVhcmVzdEVsZW1lbnRzKHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcbiAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IHBvcztcbiAgICByLmhvdmVyRGF0YS5tZG93bkdQb3MgPSBncG9zO1xuICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24gY2hlY2tGb3JUYXBob2xkKCkge1xuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgY2xlYXJUaW1lb3V0KHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuICAgICAgICAgIGlmIChlbGUpIHtcbiAgICAgICAgICAgIGVsZS5lbWl0KG1ha2VFdmVudCgndGFwaG9sZCcpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ3RhcGhvbGQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgfTtcblxuICAgIC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuICAgIGlmIChlLndoaWNoID09IDMpIHtcbiAgICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgdmFyIGN4dEV2dCA9IHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAobmVhcikge1xuICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgIG5lYXIuZW1pdChjeHRFdnQpO1xuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH1cbiAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAgIC8vIFByaW1hcnkgYnV0dG9uXG4gICAgfSBlbHNlIGlmIChlLndoaWNoID09IDEpIHtcbiAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gRWxlbWVudCBkcmFnZ2luZ1xuICAgICAge1xuICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5kZXIgdGhlIGN1cnNvciBhbmQgaXQgaXMgZHJhZ2dhYmxlLCBwcmVwYXJlIHRvIGdyYWIgaXRcbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyLm5vZGVJc0dyYWJiYWJsZShuZWFyKSkge1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJHcmFiID0gZnVuY3Rpb24gdHJpZ2dlckdyYWIoZWxlKSB7XG4gICAgICAgICAgICAgIGVsZS5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRHcmFiVGFyZ2V0KG5lYXIpO1xuICAgICAgICAgICAgaWYgKCFuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyhuZWFyLCB7XG4gICAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlbWVudHNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2dyYWJvbicpKS5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoc2VsZWN0ZWROb2Rlcywge1xuICAgICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFib24nKSk7XG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaCh0cmlnZ2VyR3JhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgci5ob3ZlckRhdGEuZG93bnMgPSBuZWFycztcbiAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgIH1cbiAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZWRvd24nLCAndGFwc3RhcnQnLCAndm1vdXNlZG93biddLCBlLCB7XG4gICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgeTogcG9zWzFdXG4gICAgICB9KTtcbiAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH0gZWxzZSBpZiAobmVhci5wYW5uYWJsZSgpKSB7XG4gICAgICAgIHNlbGVjdFs0XSA9IDE7IC8vIGZvciBmdXR1cmUgcGFuXG4gICAgICB9XG4gICAgICBjaGVja0ZvclRhcGhvbGQoKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHNlbGVjdGlvbiBib3ggY29vcmRpbmF0ZXNcbiAgICBzZWxlY3RbMF0gPSBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgc2VsZWN0WzFdID0gc2VsZWN0WzNdID0gcG9zWzFdO1xuICB9LCBmYWxzZSk7XG4gIHZhciBzaGFkb3dSb290ID0gZ2V0U2hhZG93Um9vdChyLmNvbnRhaW5lcik7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKFtjb250YWluZXJXaW5kb3csIHNoYWRvd1Jvb3RdLCAnbW91c2Vtb3ZlJywgZnVuY3Rpb24gbW91c2Vtb3ZlSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcbiAgICBpZiAoIWNhcHR1cmUgJiYgIWV2ZW50SW5Db250YWluZXIoZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgZ3BvcyA9IFtlLmNsaWVudFgsIGUuY2xpZW50WV07XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChncG9zWzBdLCBncG9zWzFdKTtcbiAgICB2YXIgbWRvd25Qb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcbiAgICB2YXIgbWRvd25HUG9zID0gci5ob3ZlckRhdGEubWRvd25HUG9zO1xuICAgIHZhciBzZWxlY3QgPSByLnNlbGVjdGlvbjtcbiAgICB2YXIgbmVhciA9IG51bGw7XG4gICAgaWYgKCFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IHIuaG92ZXJEYXRhLmxhc3Q7XG4gICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgIHZhciBkaXNwID0gW3Bvc1swXSAtIHNlbGVjdFsyXSwgcG9zWzFdIC0gc2VsZWN0WzNdXTtcbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcbiAgICB2YXIgaXNPdmVyVGhyZXNob2xkRHJhZztcbiAgICBpZiAobWRvd25HUG9zKSB7XG4gICAgICB2YXIgZHggPSBncG9zWzBdIC0gbWRvd25HUG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBncG9zWzFdIC0gbWRvd25HUG9zWzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICByLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnID0gaXNPdmVyVGhyZXNob2xkRHJhZyA9IGRpc3QyID49IHIuZGVza3RvcFRhcFRocmVzaG9sZDI7XG4gICAgfVxuICAgIHZhciBtdWx0U2VsS2V5RG93biA9IGlzTXVsdFNlbEtleURvd24oZSk7XG4gICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgdXBkYXRlRHJhZ0RlbHRhID0gZnVuY3Rpb24gdXBkYXRlRHJhZ0RlbHRhKCkge1xuICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSB8fCBbXTtcbiAgICAgIGlmIChkcmFnRGVsdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMF0pO1xuICAgICAgICBkcmFnRGVsdGEucHVzaChkaXNwWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2Vtb3ZlJywgJ3Ztb3VzZW1vdmUnLCAndGFwZHJhZyddLCBlLCB7XG4gICAgICB4OiBwb3NbMF0sXG4gICAgICB5OiBwb3NbMV1cbiAgICB9KTtcbiAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIGdvSW50b0JveE1vZGUgPSBmdW5jdGlvbiBnb0ludG9Cb3hNb2RlKCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKCFyLmhvdmVyRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ2JveHN0YXJ0JykpO1xuICAgICAgfVxuICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IHRydWU7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9O1xuXG4gICAgLy8gdHJpZ2dlciBjb250ZXh0IGRyYWcgaWYgcm1vdXNlIGRvd25cbiAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDMpIHtcbiAgICAgIC8vIGJ1dCBvbmx5IGlmIG92ZXIgdGhyZXNob2xkXG4gICAgICBpZiAoaXNPdmVyVGhyZXNob2xkRHJhZykge1xuICAgICAgICB2YXIgY3h0RXZ0ID0gbWFrZUV2ZW50KCdjeHRkcmFnJyk7XG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgZG93bi5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgICB9XG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXIuaG92ZXJEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci5ob3ZlckRhdGEuY3h0T3Zlcikge1xuICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS5jeHRPdmVyKSB7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyLmVtaXQobWFrZUV2ZW50KCdjeHRkcmFnb3V0JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyID0gbmVhcjtcbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnY3h0ZHJhZ292ZXInKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBkcmFnIHBhbm5pbmcgdGhlIGVudGlyZSBncmFwaFxuICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIGlmIChjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpKSB7XG4gICAgICAgIHZhciBkZWx0YVA7XG4gICAgICAgIGlmIChyLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbikge1xuICAgICAgICAgIHZhciBtZFBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgIHg6IChwb3NbMF0gLSBtZFBvc1swXSkgKiB6b29tLFxuICAgICAgICAgICAgeTogKHBvc1sxXSAtIG1kUG9zWzFdKSAqIHpvb21cbiAgICAgICAgICB9O1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY3kucGFuQnkoZGVsdGFQKTtcbiAgICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ2RyYWdwYW4nKSk7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBOZWVkcyByZXByb2plY3QgZHVlIHRvIHBhbiBjaGFuZ2luZyB2aWV3cG9ydFxuICAgICAgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgLy8gQ2hlY2tzIHByaW1hcnkgYnV0dG9uIGRvd24gJiBvdXQgb2YgdGltZSAmIG1vdXNlIG5vdCBtb3ZlZCBtdWNoXG4gICAgfSBlbHNlIGlmIChzZWxlY3RbNF0gPT0gMSAmJiAoZG93biA9PSBudWxsIHx8IGRvd24ucGFubmFibGUoKSkpIHtcbiAgICAgIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmcgJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIChtdWx0U2VsS2V5RG93biB8fCAhY3kucGFubmluZ0VuYWJsZWQoKSB8fCAhY3kudXNlclBhbm5pbmdFbmFibGVkKCkpKSB7XG4gICAgICAgICAgZ29JbnRvQm94TW9kZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICAgIHZhciBhbGxvd1Bhc3N0aHJvdWdoID0gYWxsb3dQYW5uaW5nUGFzc3Rocm91Z2goZG93biwgci5ob3ZlckRhdGEuZG93bnMpO1xuICAgICAgICAgIGlmIChhbGxvd1Bhc3N0aHJvdWdoKSB7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IHRydWU7XG4gICAgICAgICAgICBzZWxlY3RbNF0gPSAwO1xuICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gYXJyYXkycG9pbnQobWRvd25Qb3MpO1xuICAgICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkb3duICYmIGRvd24ucGFubmFibGUoKSAmJiBkb3duLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvd24gJiYgZG93bi5wYW5uYWJsZSgpICYmIGRvd24uYWN0aXZlKCkpIHtcbiAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoKCFkb3duIHx8ICFkb3duLmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhsYXN0LCBbJ21vdXNlb3V0JywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lYXIpIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsnbW91c2VvdmVyJywgJ3RhcGRyYWdvdmVyJ10sIGUsIHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgfVxuICAgICAgaWYgKGRvd24pIHtcbiAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAvLyB0aGVuIHdlIGNhbiB0YWtlIGFjdGlvblxuXG4gICAgICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiBtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgLy8gdGhlbiBzZWxlY3Rpb24gb3ZlcnJpZGVzXG4gICAgICAgICAgICBpZiAoZG93biAmJiBkb3duLmdyYWJiZWQoKSkge1xuICAgICAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVtZW50cyk7XG4gICAgICAgICAgICAgIGRvd24uZW1pdChtYWtlRXZlbnQoJ2ZyZWVvbicpKTtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLmVtaXQobWFrZUV2ZW50KCdmcmVlJykpO1xuICAgICAgICAgICAgICBpZiAoci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgICAgICAgZG93bi5lbWl0KG1ha2VFdmVudCgnZHJhZ2ZyZWVvbicpKTtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdChtYWtlRXZlbnQoJ2RyYWdmcmVlJykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnb0ludG9Cb3hNb2RlKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkb3duICYmIGRvd24uZ3JhYmJlZCgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKGRvd24pKSB7XG4gICAgICAgICAgICAvLyBkcmFnIG5vZGVcbiAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuICAgICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IHRydWU7IC8vIGluZGljYXRlIHRoYXQgd2UgYWN0dWFsbHkgZGlkIGRyYWcgdGhlIG5vZGVcblxuICAgICAgICAgICAgLy8gbm93LCBhZGQgdGhlIGVsZW1lbnRzIHRvIHRoZSBkcmFnIGxheWVyIGlmIG5vdCBkb25lIGFscmVhZHlcbiAgICAgICAgICAgIGlmICghci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKSB7XG4gICAgICAgICAgICAgIGFkZE5vZGVzVG9EcmFnKGRyYWdnZWRFbGVtZW50cywge1xuICAgICAgICAgICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRvdGFsU2hpZnQgPSB7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAobnVtYmVyJDEoZGlzcFswXSkgJiYgbnVtYmVyJDEoZGlzcFsxXSkpIHtcbiAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgICBpZiAoanVzdFN0YXJ0ZWREcmFnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YTtcbiAgICAgICAgICAgICAgICBpZiAoZHJhZ0RlbHRhICYmIG51bWJlciQxKGRyYWdEZWx0YVswXSkgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzFdKSkge1xuICAgICAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgIHRvdGFsU2hpZnQueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzLnNpbGVudFNoaWZ0KHRvdGFsU2hpZnQpLmVtaXQobWFrZUV2ZW50KCdwb3NpdGlvbicpKS5lbWl0KG1ha2VFdmVudCgnZHJhZycpKTtcbiAgICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHNhdmUgZHJhZyBkZWx0YSBmb3Igd2hlbiB3ZSBhY3R1YWxseSBzdGFydCBkcmFnZ2luZyBzbyB0aGUgcmVsYXRpdmUgZ3JhYiBwb3MgaXMgY29uc3RhbnRcbiAgICAgICAgICB1cGRhdGVEcmFnRGVsdGEoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwcmV2ZW50IHRoZSBkcmFnZ2luZyBmcm9tIHRyaWdnZXJpbmcgdGV4dCBzZWxlY3Rpb24gb24gdGhlIHBhZ2VcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG4gICAgc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgIHNlbGVjdFszXSA9IHBvc1sxXTtcbiAgICBpZiAocHJldmVudERlZmF1bHQpIHtcbiAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciBjbGlja1RpbWVvdXQsIGRpZERvdWJsZUNsaWNrLCBwcmV2Q2xpY2tUaW1lU3RhbXA7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbiBtb3VzZXVwSGFuZGxlcihlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgIC8vIGR1cmluZyBsZWZ0IG1vdXNlIGJ1dHRvbiBnZXN0dXJlcywgaWdub3JlIG90aGVyIGJ1dHRvbnNcbiAgICBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDEgJiYgZS53aGljaCAhPT0gMSAmJiByLmhvdmVyRGF0YS5jYXB0dXJlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcbiAgICBpZiAoIWNhcHR1cmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgIHZhciBjeSA9IHIuY3k7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgdmFyIHNlbGVjdCA9IHIuc2VsZWN0aW9uO1xuICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUsIGZhbHNlKTtcbiAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcbiAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG4gICAgdmFyIG11bHRTZWxLZXlEb3duID0gaXNNdWx0U2VsS2V5RG93bihlKTtcbiAgICBpZiAoci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uKSB7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9XG4gICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG4gICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkOyAvLyBub3QgYWN0aXZlIGJnIG5vd1xuXG4gICAgaWYgKGRvd24pIHtcbiAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgaWYgKHIuaG92ZXJEYXRhLndoaWNoID09PSAzKSB7XG4gICAgICB2YXIgY3h0RXZ0ID0gbWFrZUV2ZW50KCdjeHR0YXBlbmQnKTtcbiAgICAgIGlmIChkb3duKSB7XG4gICAgICAgIGRvd24uZW1pdChjeHRFdnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3kuZW1pdChjeHRFdnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFyLmhvdmVyRGF0YS5jeHREcmFnZ2VkKSB7XG4gICAgICAgIHZhciBjeHRUYXAgPSBtYWtlRXZlbnQoJ2N4dHRhcCcpO1xuICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgIGRvd24uZW1pdChjeHRUYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3h0VGFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEud2hpY2ggPT09IDEpIHtcbiAgICAgIHRyaWdnZXJFdmVudHMobmVhciwgWydtb3VzZXVwJywgJ3RhcGVuZCcsICd2bW91c2V1cCddLCBlLCB7XG4gICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgeTogcG9zWzFdXG4gICAgICB9KTtcbiAgICAgIGlmICghci5kcmFnRGF0YS5kaWREcmFnICYmXG4gICAgICAvLyBkaWRuJ3QgbW92ZSBhIG5vZGUgYXJvdW5kXG4gICAgICAhci5ob3ZlckRhdGEuZHJhZ2dlZCAmJlxuICAgICAgLy8gZGlkbid0IHBhblxuICAgICAgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAmJlxuICAgICAgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICFyLmhvdmVyRGF0YS5pc092ZXJUaHJlc2hvbGREcmFnIC8vIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXG4gICAgICApIHtcbiAgICAgICAgdHJpZ2dlckV2ZW50cyhkb3duLCBbXCJjbGlja1wiLCBcInRhcFwiLCBcInZjbGlja1wiXSwgZSwge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfSk7XG4gICAgICAgIGRpZERvdWJsZUNsaWNrID0gZmFsc2U7XG4gICAgICAgIGlmIChlLnRpbWVTdGFtcCAtIHByZXZDbGlja1RpbWVTdGFtcCA8PSBjeS5tdWx0aUNsaWNrRGVib3VuY2VUaW1lKCkpIHtcbiAgICAgICAgICBjbGlja1RpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KGNsaWNrVGltZW91dCk7XG4gICAgICAgICAgZGlkRG91YmxlQ2xpY2sgPSB0cnVlO1xuICAgICAgICAgIHByZXZDbGlja1RpbWVTdGFtcCA9IG51bGw7XG4gICAgICAgICAgdHJpZ2dlckV2ZW50cyhkb3duLCBbXCJkYmxjbGlja1wiLCBcImRibHRhcFwiLCBcInZkYmxjbGlja1wiXSwgZSwge1xuICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpY2tUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZGlkRG91YmxlQ2xpY2spIHJldHVybjtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudHMoZG93biwgW1wib25lY2xpY2tcIiwgXCJvbmV0YXBcIiwgXCJ2b25lY2xpY2tcIl0sIGUsIHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGN5Lm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoKSk7XG4gICAgICAgICAgcHJldkNsaWNrVGltZVN0YW1wID0gZS50aW1lU3RhbXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRGVzZWxlY3QgYWxsIGVsZW1lbnRzIGlmIG5vdGhpbmcgaXMgY3VycmVudGx5IHVuZGVyIHRoZSBtb3VzZSBjdXJzb3IgYW5kIHdlIGFyZW4ndCBkcmFnZ2luZyBzb21ldGhpbmdcbiAgICAgIGlmIChkb3duID09IG51bGwgLy8gbm90IG1vdXNlZG93biBvbiBub2RlXG4gICAgICAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIHRoZSBub2RlIGFyb3VuZFxuICAgICAgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgJiYgIWlzTXVsdFNlbEtleURvd24oZSkpIHtcbiAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gZHJhZ2dlZEVsZW1lbnRzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5nbGUgc2VsZWN0aW9uXG4gICAgICBpZiAobmVhciA9PSBkb3duICYmICFyLmRyYWdEYXRhLmRpZERyYWcgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICBpZiAobmVhciAhPSBudWxsICYmIG5lYXIuX3ByaXZhdGUuc2VsZWN0YWJsZSkge1xuICAgICAgICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykgOyBlbHNlIGlmIChjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgfHwgbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgIGlmIChuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgbmVhci51bnNlbGVjdChbJ3RhcHVuc2VsZWN0J10pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmVhci5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbXVsdFNlbEtleURvd24pIHtcbiAgICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKG5lYXIpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgICAgIG5lYXIuc2VsZWN0KFsndGFwc2VsZWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHIuaG92ZXJEYXRhLnNlbGVjdGluZykge1xuICAgICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbihyLmdldEFsbEluQm94KHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSkpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgICBpZiAoYm94Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjeS5lbWl0KG1ha2VFdmVudCgnYm94ZW5kJykpO1xuICAgICAgICB2YXIgZWxlV291bGRCZVNlbGVjdGVkID0gZnVuY3Rpb24gZWxlV291bGRCZVNlbGVjdGVkKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0YWJsZSgpICYmICFlbGUuc2VsZWN0ZWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJykge1xuICAgICAgICAgIGJveC5lbWl0KG1ha2VFdmVudCgnYm94JykpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQobWFrZUV2ZW50KCdib3hzZWxlY3QnKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFtdWx0U2VsS2V5RG93bikge1xuICAgICAgICAgICAgY3kuJChpc1NlbGVjdGVkKS51bm1lcmdlKGJveCkudW5zZWxlY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYm94LmVtaXQobWFrZUV2ZW50KCdib3gnKSkuc3RkRmlsdGVyKGVsZVdvdWxkQmVTZWxlY3RlZCkuc2VsZWN0KCkuZW1pdChtYWtlRXZlbnQoJ2JveHNlbGVjdCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFsd2F5cyBuZWVkIHJlZHJhdyBpbiBjYXNlIGVsZXMgdW5zZWxlY3RhYmxlXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBkcmFnIHBhblxuICAgICAgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuICAgICAgaWYgKCFzZWxlY3RbNF0pIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICB2YXIgZG93bldhc0dyYWJiZWQgPSBkb3duICYmIGRvd24uZ3JhYmJlZCgpO1xuICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVtZW50cyk7XG4gICAgICAgIGlmIChkb3duV2FzR3JhYmJlZCkge1xuICAgICAgICAgIGRvd24uZW1pdChtYWtlRXZlbnQoJ2ZyZWVvbicpKTtcbiAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMuZW1pdChtYWtlRXZlbnQoJ2ZyZWUnKSk7XG4gICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgZG93bi5lbWl0KG1ha2VFdmVudCgnZHJhZ2ZyZWVvbicpKTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cy5lbWl0KG1ha2VFdmVudCgnZHJhZ2ZyZWUnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBlbHNlIG5vdCByaWdodCBtb3VzZVxuXG4gICAgc2VsZWN0WzRdID0gMDtcbiAgICByLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgci5ob3ZlckRhdGEuaXNPdmVyVGhyZXNob2xkRHJhZyA9IGZhbHNlO1xuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlO1xuICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICByLmhvdmVyRGF0YS5tZG93blBvcyA9IG51bGw7XG4gICAgci5ob3ZlckRhdGEubWRvd25HUG9zID0gbnVsbDtcbiAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG4gIH0sIGZhbHNlKTtcbiAgdmFyIHdoZWVsRGVsdGFzID0gW107IC8vIGxvZyBvZiBmaXJzdCBOIHdoZWVsIGRlbHRhc1xuICB2YXIgd2hlZWxEZWx0YU4gPSA0OyAvLyBob3cgbWFueSBldmVudHMgdG8gbG9nXG4gIHZhciBpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlO1xuICB2YXIgaW5hY2N1cmF0ZVNjcm9sbEZhY3RvciA9IDEwMDAwMDsgLy8gYmFzZSBvZiBpbmFjY3VyYXRlIHdoZWVsIGRlbHRhcyAoZS5nLiBiYXNlIDUgY291bGQgeWllbGQgd2hlZWxzIG9mIDEwLCAyNSwgNTAsIGV0Yy4pXG5cbiAgdmFyIGFsbEFyZURpdmlzaWJsZUJ5ID0gZnVuY3Rpb24gYWxsQXJlRGl2aXNpYmxlQnkobGlzdCwgZmFjdG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXSAlIGZhY3RvciAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICB2YXIgYWxsQXJlU2FtZU1hZ25pdHVkZSA9IGZ1bmN0aW9uIGFsbEFyZVNhbWVNYWduaXR1ZGUobGlzdCkge1xuICAgIHZhciBmaXJzdE1hZyA9IE1hdGguYWJzKGxpc3RbMF0pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKE1hdGguYWJzKGxpc3RbaV0pICE9PSBmaXJzdE1hZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICB2YXIgd2hlZWxIYW5kbGVyID0gZnVuY3Rpb24gd2hlZWxIYW5kbGVyKGUpIHtcbiAgICB2YXIgY2xhbXAgPSBmYWxzZTtcbiAgICB2YXIgZGVsdGEgPSBlLmRlbHRhWTtcbiAgICBpZiAoZGVsdGEgPT0gbnVsbCkge1xuICAgICAgLy8gY29tcGF0aWJpbGl0eSB3aXRoIG9sZCBicm93c2Vyc1xuICAgICAgaWYgKGUud2hlZWxEZWx0YVkgIT0gbnVsbCkge1xuICAgICAgICBkZWx0YSA9IGUud2hlZWxEZWx0YVkgLyA0O1xuICAgICAgfSBlbHNlIGlmIChlLndoZWVsRGVsdGEgIT0gbnVsbCkge1xuICAgICAgICBkZWx0YSA9IGUud2hlZWxEZWx0YSAvIDQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWx0YSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBubyBjaGFuZ2UgaW4gem9vbSAoQnVnOiBab29tIGJlY29tZXMgZXJyYXRpYyBvbiByYXBpZCBzY3JvbGwgZHVlIHRvIGRlbHRhWTogMCBldmVudCAjMzM5NClcbiAgICB9XG4gICAgaWYgKGluYWNjdXJhdGVTY3JvbGxEZXZpY2UgPT0gbnVsbCkge1xuICAgICAgaWYgKHdoZWVsRGVsdGFzLmxlbmd0aCA+PSB3aGVlbERlbHRhTikge1xuICAgICAgICAvLyB1c2UgbG9nIHRvIGRldGVybWluZSBpZiBpbmFjY3VyYXRlXG4gICAgICAgIHZhciB3ZHMgPSB3aGVlbERlbHRhcztcbiAgICAgICAgaW5hY2N1cmF0ZVNjcm9sbERldmljZSA9IGFsbEFyZURpdmlzaWJsZUJ5KHdkcywgNSk7XG4gICAgICAgIGlmICghaW5hY2N1cmF0ZVNjcm9sbERldmljZSkge1xuICAgICAgICAgIC8vIGNoZWNrIGZvciBhbGwgbGFyZ2UgdmFsdWVzIG9mIGV4YWN0IHNhbWUgbWFnbml0dWRlXG4gICAgICAgICAgdmFyIGZpcnN0TWFnID0gTWF0aC5hYnMod2RzWzBdKTtcbiAgICAgICAgICBpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlID0gYWxsQXJlU2FtZU1hZ25pdHVkZSh3ZHMpICYmIGZpcnN0TWFnID4gNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5hY2N1cmF0ZVNjcm9sbERldmljZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yID0gTWF0aC5taW4oTWF0aC5hYnMod2RzW2ldKSwgaW5hY2N1cmF0ZVNjcm9sbEZhY3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1NhbXBsZWQgd2hlZWwgZGVsdGFzOicsIHdkcyk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbmFjY3VyYXRlU2Nyb2xsRGV2aWNlOicsIGluYWNjdXJhdGVTY3JvbGxEZXZpY2UpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW5hY2N1cmF0ZVNjcm9sbEZhY3RvcjonLCBpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNsYW1wIGFuZCBsb2cgdW50aWwgd2UgcmVhY2ggTlxuICAgICAgICB3aGVlbERlbHRhcy5wdXNoKGRlbHRhKTtcbiAgICAgICAgY2xhbXAgPSB0cnVlO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2xhbXBpbmcgaW5pdGlhbCB3aGVlbCBldmVudHMgdW50aWwgd2UgZ2V0IGEgZ29vZCBzYW1wbGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluYWNjdXJhdGVTY3JvbGxEZXZpY2UpIHtcbiAgICAgIC8vIGtlZXAgdXBkYXRpbmdcbiAgICAgIGluYWNjdXJhdGVTY3JvbGxGYWN0b3IgPSBNYXRoLm1pbihNYXRoLmFicyhkZWx0YSksIGluYWNjdXJhdGVTY3JvbGxGYWN0b3IpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ0tlZXAgdXBkYXRpbmcgaW5hY2N1cmF0ZVNjcm9sbEZhY3RvciBiZXlvbmQgc2FtcGxlIGluIGNhc2Ugd2UgZGlkIG5vdCBnZXQgdGhlIHNtYWxsZXN0IHBvc3NpYmxlIHZhbDonLCBpbmFjY3VyYXRlU2Nyb2xsRmFjdG9yKTtcbiAgICB9XG4gICAgaWYgKHIuc2Nyb2xsaW5nUGFnZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gd2hpbGUgc2Nyb2xsaW5nLCBpZ25vcmUgd2hlZWwtdG8tem9vbVxuXG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgdmFyIHJwb3MgPSBbcG9zWzBdICogem9vbSArIHBhbi54LCBwb3NbMV0gKiB6b29tICsgcGFuLnldO1xuICAgIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCB8fCBpbkJveFNlbGVjdGlvbigpKSB7XG4gICAgICAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHIuZGF0YS53aGVlbFRpbWVvdXQpO1xuICAgICAgci5kYXRhLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gZmFsc2U7XG4gICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfSwgMTUwKTtcbiAgICAgIHZhciBkaWZmO1xuICAgICAgaWYgKGNsYW1wICYmIE1hdGguYWJzKGRlbHRhKSA+IDUpIHtcbiAgICAgICAgZGVsdGEgPSBzaWdudW0oZGVsdGEpICogNTtcbiAgICAgIH1cbiAgICAgIGRpZmYgPSBkZWx0YSAvIC0yNTA7XG4gICAgICBpZiAoaW5hY2N1cmF0ZVNjcm9sbERldmljZSkge1xuICAgICAgICBkaWZmIC89IGluYWNjdXJhdGVTY3JvbGxGYWN0b3I7XG4gICAgICAgIGRpZmYgKj0gMztcbiAgICAgIH1cbiAgICAgIGRpZmYgPSBkaWZmICogci53aGVlbFNlbnNpdGl2aXR5O1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhgZGVsdGEgPSAke2RlbHRhfSwgZGlmZiA9ICR7ZGlmZn0sIG1vZGUgPSAke2UuZGVsdGFNb2RlfWApXG5cbiAgICAgIHZhciBuZWVkc1doZWVsRml4ID0gZS5kZWx0YU1vZGUgPT09IDE7XG4gICAgICBpZiAobmVlZHNXaGVlbEZpeCkge1xuICAgICAgICAvLyBmaXhlcyBzbG93IHdoZWVsIGV2ZW50cyBvbiBmZi9saW51eCBhbmQgZmYvd2luZG93c1xuICAgICAgICBkaWZmICo9IDMzO1xuICAgICAgfVxuICAgICAgdmFyIG5ld1pvb20gPSBjeS56b29tKCkgKiBNYXRoLnBvdygxMCwgZGlmZik7XG4gICAgICBpZiAoZS50eXBlID09PSAnZ2VzdHVyZWNoYW5nZScpIHtcbiAgICAgICAgbmV3Wm9vbSA9IHIuZ2VzdHVyZVN0YXJ0Wm9vbSAqIGUuc2NhbGU7XG4gICAgICB9XG4gICAgICBjeS56b29tKHtcbiAgICAgICAgbGV2ZWw6IG5ld1pvb20sXG4gICAgICAgIHJlbmRlcmVkUG9zaXRpb246IHtcbiAgICAgICAgICB4OiBycG9zWzBdLFxuICAgICAgICAgIHk6IHJwb3NbMV1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjeS5lbWl0KHtcbiAgICAgICAgdHlwZTogZS50eXBlID09PSAnZ2VzdHVyZWNoYW5nZScgPyAncGluY2h6b29tJyA6ICdzY3JvbGx6b29tJyxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIHdoZXRoZXIgbW91c2Ugd2hlZWwgc2hvdWxkIHRyaWdnZXIgem9vbWluZ1xuICAvLyAtLVxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3doZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcblxuICAvLyBkaXNhYmxlIG5vbnN0YW5kYXJkIHdoZWVsIGV2ZW50c1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ0RPTU1vdXNlU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gb2xkZXIgZmlyZWZveFxuXG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ3Njcm9sbCcsIGZ1bmN0aW9uIHNjcm9sbEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByLnNjcm9sbGluZ1BhZ2UgPSB0cnVlO1xuICAgIGNsZWFyVGltZW91dChyLnNjcm9sbGluZ1BhZ2VUaW1lb3V0KTtcbiAgICByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByLnNjcm9sbGluZ1BhZ2UgPSBmYWxzZTtcbiAgICB9LCAyNTApO1xuICB9LCB0cnVlKTtcblxuICAvLyBkZXNrdG9wIHNhZmFyaSBwaW5jaCB0byB6b29tIHN0YXJ0XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnZ2VzdHVyZXN0YXJ0JywgZnVuY3Rpb24gZ2VzdHVyZVN0YXJ0SGFuZGxlcihlKSB7XG4gICAgci5nZXN0dXJlU3RhcnRab29tID0gci5jeS56b29tKCk7XG4gICAgaWYgKCFyLmhhc1RvdWNoU3RhcnRlZCkge1xuICAgICAgLy8gZG9uJ3QgYWZmZWN0IHRvdWNoIGRldmljZXMgbGlrZSBpcGhvbmVcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0sIHRydWUpO1xuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ2dlc3R1cmVjaGFuZ2UnLCBmdW5jdGlvbiAoZSkge1xuICAgIGlmICghci5oYXNUb3VjaFN0YXJ0ZWQpIHtcbiAgICAgIC8vIGRvbid0IGFmZmVjdCB0b3VjaCBkZXZpY2VzIGxpa2UgaXBob25lXG4gICAgICB3aGVlbEhhbmRsZXIoZSk7XG4gICAgfVxuICB9LCB0cnVlKTtcblxuICAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIGhhbmRsaW5nIG1vdXNlb3V0L21vdXNlb3ZlciBvbiB0aGUgQ3l0b3NjYXBlIGNvbnRhaW5lclxuICAvLyBIYW5kbGUgbW91c2VvdXQgb24gQ3l0b3NjYXBlIGNvbnRhaW5lclxuICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ21vdXNlb3V0JywgZnVuY3Rpb24gbW91c2VPdXRIYW5kbGVyKGUpIHtcbiAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICByLmN5LmVtaXQoe1xuICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgIHk6IHBvc1sxXVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBmYWxzZSk7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAnbW91c2VvdmVyJywgZnVuY3Rpb24gbW91c2VPdmVySGFuZGxlcihlKSB7XG4gICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgci5jeS5lbWl0KHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICB0eXBlOiAnbW91c2VvdmVyJyxcbiAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgeTogcG9zWzFdXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGZhbHNlKTtcbiAgdmFyIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTE7IC8vIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICB2YXIgZGlzdGFuY2UxLCBkaXN0YW5jZTFTcTsgLy8gaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlciAxIGFuZCBmaW5nZXIgMiBmb3IgcGluY2gtdG8tem9vbVxuICB2YXIgY2VudGVyMSwgbW9kZWxDZW50ZXIxOyAvLyBjZW50ZXIgcG9pbnQgb24gc3RhcnQgcGluY2ggdG8gem9vbVxuICB2YXIgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wO1xuICB2YXIgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodDtcbiAgdmFyIHR3b0ZpbmdlcnNTdGFydEluc2lkZTtcbiAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gIH07XG4gIHZhciBkaXN0YW5jZVNxID0gZnVuY3Rpb24gZGlzdGFuY2VTcSh4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiAoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSk7XG4gIH07XG4gIHZhciB0b3VjaHN0YXJ0SGFuZGxlcjtcbiAgci5yZWdpc3RlckJpbmRpbmcoci5jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdG91Y2hzdGFydEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaHN0YXJ0SGFuZGxlcihlKSB7XG4gICAgci5oYXNUb3VjaFN0YXJ0ZWQgPSB0cnVlO1xuICAgIGlmICghZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBibHVyQWN0aXZlRG9tRWxlbWVudCgpO1xuICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgfVxuICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIHJlY29yZCBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgICBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoci5kcmFnRGF0YS50b3VjaERyYWdFbGVzKTtcbiAgICAgIHZhciBvZmZzZXRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICAgIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgICBjb250YWluZXJXaWR0aCA9IG9mZnNldHNbMl07XG4gICAgICBjb250YWluZXJIZWlnaHQgPSBvZmZzZXRzWzNdO1xuICAgICAgZjF4MSA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdDtcbiAgICAgIGYxeTEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIGYyeDEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICBmMnkxID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICB0d29GaW5nZXJzU3RhcnRJbnNpZGUgPSAwIDw9IGYxeDEgJiYgZjF4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYyeDEgJiYgZjJ4MSA8PSBjb250YWluZXJXaWR0aCAmJiAwIDw9IGYxeTEgJiYgZjF5MSA8PSBjb250YWluZXJIZWlnaHQgJiYgMCA8PSBmMnkxICYmIGYyeTEgPD0gY29udGFpbmVySGVpZ2h0O1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZShmMXgxLCBmMXkxLCBmMngxLCBmMnkxKTtcbiAgICAgIGRpc3RhbmNlMVNxID0gZGlzdGFuY2VTcShmMXgxLCBmMXkxLCBmMngxLCBmMnkxKTtcbiAgICAgIGNlbnRlcjEgPSBbKGYxeDEgKyBmMngxKSAvIDIsIChmMXkxICsgZjJ5MSkgLyAyXTtcbiAgICAgIG1vZGVsQ2VudGVyMSA9IFsoY2VudGVyMVswXSAtIHBhbi54KSAvIHpvb20sIChjZW50ZXIxWzFdIC0gcGFuLnkpIC8gem9vbV07XG5cbiAgICAgIC8vIGNvbnNpZGVyIGNvbnRleHQgdGFwXG4gICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZCA9IDIwMDtcbiAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkU3EgPSBjeHREaXN0VGhyZXNob2xkICogY3h0RGlzdFRocmVzaG9sZDtcbiAgICAgIGlmIChkaXN0YW5jZTFTcSA8IGN4dERpc3RUaHJlc2hvbGRTcSAmJiAhZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHZhciBuZWFyMSA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgdmFyIG5lYXIyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzJdLCBub3dbM10sIHRydWUsIHRydWUpO1xuICAgICAgICBpZiAobmVhcjEgJiYgbmVhcjEuaXNOb2RlKCkpIHtcbiAgICAgICAgICBuZWFyMS5hY3RpdmF0ZSgpLmVtaXQobWFrZUV2ZW50KCdjeHR0YXBzdGFydCcpKTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIxO1xuICAgICAgICB9IGVsc2UgaWYgKG5lYXIyICYmIG5lYXIyLmlzTm9kZSgpKSB7XG4gICAgICAgICAgbmVhcjIuYWN0aXZhdGUoKS5lbWl0KG1ha2VFdmVudCgnY3h0dGFwc3RhcnQnKSk7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KG1ha2VFdmVudCgnY3h0dGFwc3RhcnQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IHRydWU7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIC8vIGlnbm9yZVxuXG4gICAgICAvLyBzYWZhcmkgb24gaW9zIHBhbnMgdGhlIHBhZ2Ugb3RoZXJ3aXNlIChub3JtYWxseSB5b3Ugc2hvdWxkIGJlIGFibGUgdG8gcHJldmVudGRlZmF1bHQgb24gdG91Y2htb3ZlLi4uKVxuICAgICAgaWYgKGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIDsgZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgbmVhcnMgPSByLmZpbmROZWFyZXN0RWxlbWVudHMobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgdmFyIG5lYXIgPSBuZWFyc1swXTtcbiAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXI7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0cyA9IG5lYXJzO1xuICAgICAgICBpZiAoci5ub2RlSXNHcmFiYmFibGUobmVhcikpIHtcbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBudWxsO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIGlmIChuZWFyLnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IGRyYWcgZWxlbWVudHMsIHNpbmNlIG5lYXIgd2lsbCBiZSBhZGRlZCBhZ2FpblxuXG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGUuc2VsZWN0ZWQoKSAmJiByLm5vZGVJc0dyYWJiYWJsZShlbGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhZGROb2Rlc1RvRHJhZyhzZWxlY3RlZE5vZGVzLCB7XG4gICAgICAgICAgICAgIGFkZFRvTGlzdDogZHJhZ2dlZEVsZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGROb2RlVG9EcmFnKG5lYXIsIHtcbiAgICAgICAgICAgICAgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldEdyYWJUYXJnZXQobmVhcik7XG4gICAgICAgICAgbmVhci5lbWl0KG1ha2VFdmVudCgnZ3JhYm9uJykpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGVzKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgbi5lbWl0KG1ha2VFdmVudCgnZ3JhYicpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCdncmFiJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJpZ2dlckV2ZW50cyhuZWFyLCBbJ3RvdWNoc3RhcnQnLCAndGFwc3RhcnQnLCAndm1vdXNlZG93biddLCBlLCB7XG4gICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgeTogbm93WzFdXG4gICAgICB9KTtcbiAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgfTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGFwLCB0YXBob2xkXG4gICAgICAvLyAtLS0tLVxuXG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgY2xlYXJUaW1lb3V0KHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0KTtcbiAgICAgIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZSAmJiAhci5waW5jaGluZyAvLyBpZiBwaW5jaGluZywgdGhlbiB0YXBob2xkIHVuc2VsZWN0IHNob3VsZG4ndCB0YWtlIGVmZmVjdFxuICAgICAgICAmJiAhci50b3VjaERhdGEuc2VsZWN0aW5nIC8vIGJveCBzZWxlY3Rpb24gc2hvdWxkbid0IGFsbG93IHRhcGhvbGQgdGhyb3VnaFxuICAgICAgICApIHtcbiAgICAgICAgICB0cmlnZ2VyRXZlbnRzKHIudG91Y2hEYXRhLnN0YXJ0LCBbJ3RhcGhvbGQnXSwgZSwge1xuICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPj0gMSkge1xuICAgICAgdmFyIHNQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc1Bvc1tpXSA9IGVhcmxpZXJbaV0gPSBub3dbaV07XG4gICAgICB9XG4gICAgICB2YXIgdG91Y2gwID0gZS50b3VjaGVzWzBdO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBbdG91Y2gwLmNsaWVudFgsIHRvdWNoMC5jbGllbnRZXTtcbiAgICB9XG4gIH0sIGZhbHNlKTtcbiAgdmFyIHRvdWNobW92ZUhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ3RvdWNobW92ZScsIHRvdWNobW92ZUhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaG1vdmVIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlO1xuICAgIGlmICghY2FwdHVyZSAmJiAhZXZlbnRJbkNvbnRhaW5lcihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgdmFyIGN5ID0gci5jeTtcbiAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICBub3dbMV0gPSBwb3NbMV07XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTtcbiAgICAgIG5vd1syXSA9IHBvc1swXTtcbiAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1syXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgbm93WzRdID0gcG9zWzBdO1xuICAgICAgbm93WzVdID0gcG9zWzFdO1xuICAgIH1cbiAgICB2YXIgbWFrZUV2ZW50ID0gZnVuY3Rpb24gbWFrZUV2ZW50KHR5cGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIHN0YXJ0R1BvcyA9IHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uO1xuICAgIHZhciBpc092ZXJUaHJlc2hvbGREcmFnO1xuICAgIGlmIChjYXB0dXJlICYmIGUudG91Y2hlc1swXSAmJiBzdGFydEdQb3MpIHtcbiAgICAgIHZhciBkaXNwID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKykge1xuICAgICAgICBkaXNwW2pdID0gbm93W2pdIC0gZWFybGllcltqXTtcbiAgICAgIH1cbiAgICAgIHZhciBkeCA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gc3RhcnRHUG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIHN0YXJ0R1Bvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgaXNPdmVyVGhyZXNob2xkRHJhZyA9IGRpc3QyID49IHIudG91Y2hUYXBUaHJlc2hvbGQyO1xuICAgIH1cblxuICAgIC8vIGNvbnRleHQgc3dpcGUgY2FuY2VsbGluZ1xuICAgIGlmIChjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LFxuICAgICAgICBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAvLyB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5Mik7XG4gICAgICB2YXIgZmFjdG9yU3EgPSBkaXN0YW5jZTJTcSAvIGRpc3RhbmNlMVNxO1xuICAgICAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxNTA7XG4gICAgICB2YXIgZGlzdFRocmVzaG9sZFNxID0gZGlzdFRocmVzaG9sZCAqIGRpc3RUaHJlc2hvbGQ7XG4gICAgICB2YXIgZmFjdG9yVGhyZXNob2xkID0gMS41O1xuICAgICAgdmFyIGZhY3RvclRocmVzaG9sZFNxID0gZmFjdG9yVGhyZXNob2xkICogZmFjdG9yVGhyZXNob2xkO1xuXG4gICAgICAvLyBjYW5jZWwgY3R4IGdlc3R1cmVzIGlmIHRoZSBkaXN0YW5jZSBiL3QgdGhlIGZpbmdlcnMgaW5jcmVhc2VzXG4gICAgICBpZiAoZmFjdG9yU3EgPj0gZmFjdG9yVGhyZXNob2xkU3EgfHwgZGlzdGFuY2UyU3EgPj0gZGlzdFRocmVzaG9sZFNxKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICAgIHZhciBjeHRFdnQgPSBtYWtlRXZlbnQoJ2N4dHRhcGVuZCcpO1xuICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC51bmFjdGl2YXRlKCkuZW1pdChjeHRFdnQpO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS5lbWl0KGN4dEV2dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb250ZXh0IHN3aXBlXG4gICAgaWYgKGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0KSB7XG4gICAgICB2YXIgY3h0RXZ0ID0gbWFrZUV2ZW50KCdjeHRkcmFnJyk7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3h0RXZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIudG91Y2hEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgaWYgKHIudG91Y2hEYXRhLmN4dE92ZXIpIHtcbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyLmVtaXQobWFrZUV2ZW50KCdjeHRkcmFnb3V0JykpO1xuICAgICAgICB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIgPSBuZWFyO1xuICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgIG5lYXIuZW1pdChtYWtlRXZlbnQoJ2N4dGRyYWdvdmVyJykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGJveCBzZWxlY3Rpb25cbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5sYXN0VGhyZWVUb3VjaCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgaWYgKCFyLnRvdWNoRGF0YS5zZWxlY3RpbmcpIHtcbiAgICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ2JveHN0YXJ0JykpO1xuICAgICAgfVxuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcbiAgICAgIHIudG91Y2hEYXRhLmRpZFNlbGVjdCA9IHRydWU7XG4gICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgaWYgKCFzZWxlY3QgfHwgc2VsZWN0Lmxlbmd0aCA9PT0gMCB8fCBzZWxlY3RbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxlY3RbMF0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKSAvIDM7XG4gICAgICAgIHNlbGVjdFsxXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pIC8gMztcbiAgICAgICAgc2VsZWN0WzJdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkgLyAzICsgMTtcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pIC8gMztcbiAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkgLyAzO1xuICAgICAgfVxuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgIC8vIHBpbmNoIHRvIHpvb21cbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgJiYgZS50b3VjaGVzWzFdICYmICFyLnRvdWNoRGF0YS5kaWRTZWxlY3QgLy8gZG9uJ3QgYWxsb3cgYm94IHNlbGVjdGlvbiB0byBkZWdyYWRlIHRvIHBpbmNoLXRvLXpvb21cbiAgICAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclpvb21pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkpIHtcbiAgICAgIC8vIHR3byBmaW5nZXJzID0+IHBpbmNoIHRvIHpvb21cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICBpZiAoZHJhZ2dlZEVsZXMpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZGVfcCA9IGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlO1xuICAgICAgICAgIGRlX3AuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgIGRlX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIF9zdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgICAvLyAoeDIsIHkyKSBmb3IgZmluZ2VycyAxIGFuZCAyXG4gICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsXG4gICAgICAgIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZShmMXgyLCBmMXkyLCBmMngyLCBmMnkyKTtcbiAgICAgIC8vIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgIC8vIHZhciBmYWN0b3IgPSBNYXRoLnNxcnQoIGRpc3RhbmNlMlNxICkgLyBNYXRoLnNxcnQoIGRpc3RhbmNlMVNxICk7XG4gICAgICB2YXIgZmFjdG9yID0gZGlzdGFuY2UyIC8gZGlzdGFuY2UxO1xuICAgICAgaWYgKHR3b0ZpbmdlcnNTdGFydEluc2lkZSkge1xuICAgICAgICAvLyBkZWx0YSBmaW5nZXIxXG4gICAgICAgIHZhciBkZjF4ID0gZjF4MiAtIGYxeDE7XG4gICAgICAgIHZhciBkZjF5ID0gZjF5MiAtIGYxeTE7XG5cbiAgICAgICAgLy8gZGVsdGEgZmluZ2VyIDJcbiAgICAgICAgdmFyIGRmMnggPSBmMngyIC0gZjJ4MTtcbiAgICAgICAgdmFyIGRmMnkgPSBmMnkyIC0gZjJ5MTtcblxuICAgICAgICAvLyB0cmFuc2xhdGlvbiBpcyB0aGUgbm9ybWFsaXNlZCB2ZWN0b3Igb2YgdGhlIHR3byBmaW5nZXJzIG1vdmVtZW50XG4gICAgICAgIC8vIGkuZS4gc28gcGluY2hpbmcgY2FuY2VscyBvdXQgYW5kIG1vdmluZyB0b2dldGhlciBwYW5zXG4gICAgICAgIHZhciB0eCA9IChkZjF4ICsgZGYyeCkgLyAyO1xuICAgICAgICB2YXIgdHkgPSAoZGYxeSArIGRmMnkpIC8gMjtcblxuICAgICAgICAvLyBub3cgY2FsY3VsYXRlIHRoZSB6b29tXG4gICAgICAgIHZhciB6b29tMSA9IGN5Lnpvb20oKTtcbiAgICAgICAgdmFyIHpvb20yID0gem9vbTEgKiBmYWN0b3I7XG4gICAgICAgIHZhciBwYW4xID0gY3kucGFuKCk7XG5cbiAgICAgICAgLy8gdGhlIG1vZGVsIGNlbnRlciBwb2ludCBjb252ZXJ0ZWQgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZWQgcG9zXG4gICAgICAgIHZhciBjdHJ4ID0gbW9kZWxDZW50ZXIxWzBdICogem9vbTEgKyBwYW4xLng7XG4gICAgICAgIHZhciBjdHJ5ID0gbW9kZWxDZW50ZXIxWzFdICogem9vbTEgKyBwYW4xLnk7XG4gICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgIHg6IC16b29tMiAvIHpvb20xICogKGN0cnggLSBwYW4xLnggLSB0eCkgKyBjdHJ4LFxuICAgICAgICAgIHk6IC16b29tMiAvIHpvb20xICogKGN0cnkgLSBwYW4xLnkgLSB0eSkgKyBjdHJ5XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcmVtb3ZlIGRyYWdnZWQgZWxlc1xuICAgICAgICBpZiAoX3N0YXJ0ICYmIF9zdGFydC5hY3RpdmUoKSkge1xuICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcbiAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKGRyYWdnZWRFbGVzKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICBfc3RhcnQudW5hY3RpdmF0ZSgpLmVtaXQobWFrZUV2ZW50KCdmcmVlb24nKSk7XG4gICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdChtYWtlRXZlbnQoJ2ZyZWUnKSk7XG4gICAgICAgICAgaWYgKHIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgICAgX3N0YXJ0LmVtaXQobWFrZUV2ZW50KCdkcmFnZnJlZW9uJykpO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdChtYWtlRXZlbnQoJ2RyYWdmcmVlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjeS52aWV3cG9ydCh7XG4gICAgICAgICAgem9vbTogem9vbTIsXG4gICAgICAgICAgcGFuOiBwYW4yLFxuICAgICAgICAgIGNhbmNlbE9uRmFpbGVkWm9vbTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ3BpbmNoem9vbScpKTtcbiAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UyO1xuICAgICAgICBmMXgxID0gZjF4MjtcbiAgICAgICAgZjF5MSA9IGYxeTI7XG4gICAgICAgIGYyeDEgPSBmMngyO1xuICAgICAgICBmMnkxID0gZjJ5MjtcbiAgICAgICAgci5waW5jaGluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlLXByb2plY3RcbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgIH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgICBub3dbMl0gPSBwb3NbMF07XG4gICAgICAgIG5vd1szXSA9IHBvc1sxXTtcbiAgICAgIH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpO1xuICAgICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1s1XSA9IHBvc1sxXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSAmJiAhci50b3VjaERhdGEuZGlkU2VsZWN0IC8vIGRvbid0IGFsbG93IGJveCBzZWxlY3Rpb24gdG8gZGVncmFkZSB0byBzaW5nbGUgZmluZ2VyIGV2ZW50cyBsaWtlIHBhbm5pbmdcbiAgICApIHtcbiAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgICAgdmFyIGxhc3QgPSByLnRvdWNoRGF0YS5sYXN0O1xuICAgICAgdmFyIG5lYXI7XG4gICAgICBpZiAoIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyAmJiAhci5zd2lwZVBhbm5pbmcpIHtcbiAgICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXB0dXJlICYmIHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmFnZ2luZyBub2Rlc1xuICAgICAgaWYgKGNhcHR1cmUgJiYgc3RhcnQgIT0gbnVsbCAmJiByLm5vZGVJc0RyYWdnYWJsZShzdGFydCkpIHtcbiAgICAgICAgaWYgKGlzT3ZlclRocmVzaG9sZERyYWcpIHtcbiAgICAgICAgICAvLyB0aGVuIGRyYWdnaW5nIGNhbiBoYXBwZW5cbiAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmRyYWdEYXRhLmRpZERyYWc7XG4gICAgICAgICAgaWYgKGp1c3RTdGFydGVkRHJhZykge1xuICAgICAgICAgICAgYWRkTm9kZXNUb0RyYWcoZHJhZ2dlZEVsZXMsIHtcbiAgICAgICAgICAgICAgaW5EcmFnTGF5ZXI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlO1xuICAgICAgICAgIHZhciB0b3RhbFNoaWZ0ID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChudW1iZXIkMShkaXNwWzBdKSAmJiBudW1iZXIkMShkaXNwWzFdKSkge1xuICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZGlzcFsxXTtcbiAgICAgICAgICAgIGlmIChqdXN0U3RhcnRlZERyYWcpIHtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGE7XG4gICAgICAgICAgICAgIGlmIChkcmFnRGVsdGEgJiYgbnVtYmVyJDEoZHJhZ0RlbHRhWzBdKSAmJiBudW1iZXIkMShkcmFnRGVsdGFbMV0pKSB7XG4gICAgICAgICAgICAgICAgdG90YWxTaGlmdC54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICB0b3RhbFNoaWZ0LnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG4gICAgICAgICAgZHJhZ2dlZEVsZXMuc2lsZW50U2hpZnQodG90YWxTaGlmdCkuZW1pdChtYWtlRXZlbnQoJ3Bvc2l0aW9uJykpLmVtaXQobWFrZUV2ZW50KCdkcmFnJykpO1xuICAgICAgICAgIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdID09IGVhcmxpZXJbMF0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSA9PSBlYXJsaWVyWzFdKSB7XG4gICAgICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2Uga2VlcCB0cmFjayBvZiBkcmFnIGRlbHRhIGZvciBsYXRlclxuICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgfHwgW107XG4gICAgICAgICAgaWYgKGRyYWdEZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKGRpc3BbMF0pO1xuICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goZGlzcFsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRvdWNobW92ZVxuICAgICAge1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0IHx8IG5lYXIsIFsndG91Y2htb3ZlJywgJ3RhcGRyYWcnLCAndm1vdXNlbW92ZSddLCBlLCB7XG4gICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgIHk6IG5vd1sxXVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCghc3RhcnQgfHwgIXN0YXJ0LmdyYWJiZWQoKSkgJiYgbmVhciAhPSBsYXN0KSB7XG4gICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QuZW1pdChtYWtlRXZlbnQoJ3RhcGRyYWdvdXQnKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgICBuZWFyLmVtaXQobWFrZUV2ZW50KCd0YXBkcmFnb3ZlcicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgci50b3VjaERhdGEubGFzdCA9IG5lYXI7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHRvIGNhbmNlbCB0YXBob2xkXG4gICAgICBpZiAoY2FwdHVyZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChub3dbaV0gJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXSAmJiBpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGFubmluZ1xuICAgICAgaWYgKGNhcHR1cmUgJiYgKHN0YXJ0ID09IG51bGwgfHwgc3RhcnQucGFubmFibGUoKSkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSkge1xuICAgICAgICB2YXIgYWxsb3dQYXNzdGhyb3VnaCA9IGFsbG93UGFubmluZ1Bhc3N0aHJvdWdoKHN0YXJ0LCByLnRvdWNoRGF0YS5zdGFydHMpO1xuICAgICAgICBpZiAoYWxsb3dQYXNzdGhyb3VnaCkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBpZiAoIXIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbikge1xuICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gYXJyYXkycG9pbnQoci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyLnN3aXBlUGFubmluZykge1xuICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3kuZW1pdChtYWtlRXZlbnQoJ2RyYWdwYW4nKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc092ZXJUaHJlc2hvbGREcmFnKSB7XG4gICAgICAgICAgICByLnN3aXBlUGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICAgIHg6IGR4ICogem9vbSxcbiAgICAgICAgICAgICAgeTogZHkgKiB6b29tXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN5LmVtaXQobWFrZUV2ZW50KCdkcmFncGFuJykpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlLXByb2plY3RcbiAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICBub3dbMF0gPSBwb3NbMF07XG4gICAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfVxuXG4gICAgLy8gdGhlIGFjdGl2ZSBiZyBpbmRpY2F0b3Igc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBtYWtpbmcgYSBzd2lwZSB0aGF0IGlzIG5laXRoZXIgZm9yIGRyYWdnaW5nIG5vZGVzIG9yIHBhbm5pbmdcbiAgICBpZiAoY2FwdHVyZSAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMCAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICYmICFyLnN3aXBlUGFubmluZyAmJiByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gIT0gbnVsbCkge1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgci5yZWRyYXdIaW50KCdzZWxlY3QnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuICB9LCBmYWxzZSk7XG4gIHZhciB0b3VjaGNhbmNlbEhhbmRsZXI7XG4gIHIucmVnaXN0ZXJCaW5kaW5nKGNvbnRhaW5lcldpbmRvdywgJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWxIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hjYW5jZWxIYW5kbGVyKGUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgci50b3VjaERhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgfSk7XG4gIHZhciB0b3VjaGVuZEhhbmRsZXIsIGRpZERvdWJsZVRvdWNoLCB0b3VjaFRpbWVvdXQsIHByZXZUb3VjaFRpbWVTdGFtcDtcbiAgci5yZWdpc3RlckJpbmRpbmcoY29udGFpbmVyV2luZG93LCAndG91Y2hlbmQnLCB0b3VjaGVuZEhhbmRsZXIgPSBmdW5jdGlvbiB0b3VjaGVuZEhhbmRsZXIoZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG4gICAgaWYgKGNhcHR1cmUpIHtcbiAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2VsZWN0ID0gci5zZWxlY3Rpb247XG4gICAgci5zd2lwZVBhbm5pbmcgPSBmYWxzZTtcbiAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICB2YXIgY3kgPSByLmN5O1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgIG5vd1swXSA9IHBvc1swXTtcbiAgICAgIG5vd1sxXSA9IHBvc1sxXTtcbiAgICB9XG4gICAgaWYgKGUudG91Y2hlc1sxXSkge1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpO1xuICAgICAgbm93WzJdID0gcG9zWzBdO1xuICAgICAgbm93WzNdID0gcG9zWzFdO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7XG4gICAgICBub3dbNF0gPSBwb3NbMF07XG4gICAgICBub3dbNV0gPSBwb3NbMV07XG4gICAgfVxuICAgIHZhciBtYWtlRXZlbnQgPSBmdW5jdGlvbiBtYWtlRXZlbnQodHlwZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgdmFyIGN0eFRhcGVuZDtcbiAgICBpZiAoci50b3VjaERhdGEuY3h0KSB7XG4gICAgICBjdHhUYXBlbmQgPSBtYWtlRXZlbnQoJ2N4dHRhcGVuZCcpO1xuICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0LmVtaXQoY3R4VGFwZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN5LmVtaXQoY3R4VGFwZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmICghci50b3VjaERhdGEuY3h0RHJhZ2dlZCkge1xuICAgICAgICB2YXIgY3R4VGFwID0gbWFrZUV2ZW50KCdjeHR0YXAnKTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgc3RhcnQuZW1pdChjdHhUYXApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LmVtaXQoY3R4VGFwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBubyBtb3JlIGJveCBzZWxlY3Rpb24gaWYgd2UgZG9uJ3QgaGF2ZSB0aHJlZSBmaW5nZXJzXG4gICAgaWYgKCFlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIHIudG91Y2hEYXRhLnNlbGVjdGluZykge1xuICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICB2YXIgYm94ID0gY3kuY29sbGVjdGlvbihyLmdldEFsbEluQm94KHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSkpO1xuICAgICAgc2VsZWN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzFdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzJdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzNdID0gdW5kZWZpbmVkO1xuICAgICAgc2VsZWN0WzRdID0gMDtcbiAgICAgIHIucmVkcmF3SGludCgnc2VsZWN0JywgdHJ1ZSk7XG4gICAgICBjeS5lbWl0KG1ha2VFdmVudCgnYm94ZW5kJykpO1xuICAgICAgdmFyIGVsZVdvdWxkQmVTZWxlY3RlZCA9IGZ1bmN0aW9uIGVsZVdvdWxkQmVTZWxlY3RlZChlbGUpIHtcbiAgICAgICAgcmV0dXJuIGVsZS5zZWxlY3RhYmxlKCkgJiYgIWVsZS5zZWxlY3RlZCgpO1xuICAgICAgfTtcbiAgICAgIGJveC5lbWl0KG1ha2VFdmVudCgnYm94JykpLnN0ZEZpbHRlcihlbGVXb3VsZEJlU2VsZWN0ZWQpLnNlbGVjdCgpLmVtaXQobWFrZUV2ZW50KCdib3hzZWxlY3QnKSk7XG4gICAgICBpZiAoYm94Lm5vbmVtcHR5KCkpIHtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cbiAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgIH1cbiAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSA7IGVsc2UgaWYgKGUudG91Y2hlc1swXSkgOyBlbHNlIGlmICghZS50b3VjaGVzWzBdKSB7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHN0YXJ0V2FzR3JhYmJlZCA9IHN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQ7XG4gICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoZHJhZ2dlZEVsZXMpO1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICAgIGlmIChzdGFydFdhc0dyYWJiZWQpIHtcbiAgICAgICAgICBzdGFydC5lbWl0KG1ha2VFdmVudCgnZnJlZW9uJykpO1xuICAgICAgICAgIGRyYWdnZWRFbGVzLmVtaXQobWFrZUV2ZW50KCdmcmVlJykpO1xuICAgICAgICAgIGlmIChyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICAgIHN0YXJ0LmVtaXQobWFrZUV2ZW50KCdkcmFnZnJlZW9uJykpO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXMuZW1pdChtYWtlRXZlbnQoJ2RyYWdmcmVlJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyRXZlbnRzKHN0YXJ0LCBbJ3RvdWNoZW5kJywgJ3RhcGVuZCcsICd2bW91c2V1cCcsICd0YXBkcmFnb3V0J10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuICAgICAgICB0cmlnZ2VyRXZlbnRzKG5lYXIsIFsndG91Y2hlbmQnLCAndGFwZW5kJywgJ3Ztb3VzZXVwJywgJ3RhcGRyYWdvdXQnXSwgZSwge1xuICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdIC0gbm93WzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgICAgLy8gVGFwIGV2ZW50LCByb3VnaGx5IHNhbWUgYXMgbW91c2UgY2xpY2sgZXZlbnQgZm9yIHRvdWNoXG4gICAgICBpZiAoIXIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQpIHtcbiAgICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWyd0YXAnLCAndmNsaWNrJ10sIGUsIHtcbiAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgeTogbm93WzFdXG4gICAgICAgIH0pO1xuICAgICAgICBkaWREb3VibGVUb3VjaCA9IGZhbHNlO1xuICAgICAgICBpZiAoZS50aW1lU3RhbXAgLSBwcmV2VG91Y2hUaW1lU3RhbXAgPD0gY3kubXVsdGlDbGlja0RlYm91bmNlVGltZSgpKSB7XG4gICAgICAgICAgdG91Y2hUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0b3VjaFRpbWVvdXQpO1xuICAgICAgICAgIGRpZERvdWJsZVRvdWNoID0gdHJ1ZTtcbiAgICAgICAgICBwcmV2VG91Y2hUaW1lU3RhbXAgPSBudWxsO1xuICAgICAgICAgIHRyaWdnZXJFdmVudHMoc3RhcnQsIFsnZGJsdGFwJywgJ3ZkYmxjbGljayddLCBlLCB7XG4gICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkaWREb3VibGVUb3VjaCkgcmV0dXJuO1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50cyhzdGFydCwgWydvbmV0YXAnLCAndm9uZWNsaWNrJ10sIGUsIHtcbiAgICAgICAgICAgICAgeDogbm93WzBdLFxuICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGN5Lm11bHRpQ2xpY2tEZWJvdW5jZVRpbWUoKSk7XG4gICAgICAgICAgcHJldlRvdWNoVGltZVN0YW1wID0gZS50aW1lU3RhbXA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgaWYgKHN0YXJ0ICE9IG51bGwgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgZHJhZyBub2RlcyBhcm91bmRcbiAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGUgJiYgcmRpc3QyIDwgci50b3VjaFRhcFRocmVzaG9sZDIgJiYgIXIucGluY2hpbmcgLy8gcGluY2ggdG8gem9vbSBzaG91bGQgbm90IGFmZmVjdCBzZWxlY3Rpb25cbiAgICAgICkge1xuICAgICAgICBpZiAoY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnc2luZ2xlJykge1xuICAgICAgICAgIGN5LiQoaXNTZWxlY3RlZCkudW5tZXJnZShzdGFydCkudW5zZWxlY3QoWyd0YXB1bnNlbGVjdCddKTtcbiAgICAgICAgICBzdGFydC5zZWxlY3QoWyd0YXBzZWxlY3QnXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0YXJ0LnNlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KFsndGFwdW5zZWxlY3QnXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LnNlbGVjdChbJ3RhcHNlbGVjdCddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKyspIHtcbiAgICAgIGVhcmxpZXJbal0gPSBub3dbal07XG4gICAgfVxuICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlOyAvLyByZXNldCBmb3IgbmV4dCB0b3VjaHN0YXJ0XG5cbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgci50b3VjaERhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uID0gW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdO1xuICAgICAgci50b3VjaERhdGEuc3RhcnRHUG9zaXRpb24gPSBudWxsO1xuICAgICAgci50b3VjaERhdGEuZGlkU2VsZWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoIDwgMikge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gdGhlIG9sZCBzdGFydCBnbG9iYWwgcG9zJ24gbWF5IG5vdCBiZSB0aGUgc2FtZSBmaW5nZXIgdGhhdCByZW1haW5zXG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0R1Bvc2l0aW9uID0gW2UudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WV07XG4gICAgICB9XG4gICAgICByLnBpbmNoaW5nID0gZmFsc2U7XG4gICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLy9yLnJlZHJhdygpO1xuICB9LCBmYWxzZSk7XG5cbiAgLy8gZmFsbGJhY2sgY29tcGF0aWJpbGl0eSBsYXllciBmb3IgbXMgcG9pbnRlciBldmVudHNcbiAgaWYgKHR5cGVvZiBUb3VjaEV2ZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgIHZhciBtYWtlVG91Y2ggPSBmdW5jdGlvbiBtYWtlVG91Y2goZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2xpZW50WDogZS5jbGllbnRYLFxuICAgICAgICBjbGllbnRZOiBlLmNsaWVudFksXG4gICAgICAgIGZvcmNlOiAxLFxuICAgICAgICBpZGVudGlmaWVyOiBlLnBvaW50ZXJJZCxcbiAgICAgICAgcGFnZVg6IGUucGFnZVgsXG4gICAgICAgIHBhZ2VZOiBlLnBhZ2VZLFxuICAgICAgICByYWRpdXNYOiBlLndpZHRoIC8gMixcbiAgICAgICAgcmFkaXVzWTogZS5oZWlnaHQgLyAyLFxuICAgICAgICBzY3JlZW5YOiBlLnNjcmVlblgsXG4gICAgICAgIHNjcmVlblk6IGUuc2NyZWVuWSxcbiAgICAgICAgdGFyZ2V0OiBlLnRhcmdldFxuICAgICAgfTtcbiAgICB9O1xuICAgIHZhciBtYWtlUG9pbnRlciA9IGZ1bmN0aW9uIG1ha2VQb2ludGVyKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50OiBlLFxuICAgICAgICB0b3VjaDogbWFrZVRvdWNoKGUpXG4gICAgICB9O1xuICAgIH07XG4gICAgdmFyIGFkZFBvaW50ZXIgPSBmdW5jdGlvbiBhZGRQb2ludGVyKGUpIHtcbiAgICAgIHBvaW50ZXJzLnB1c2gobWFrZVBvaW50ZXIoZSkpO1xuICAgIH07XG4gICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmdW5jdGlvbiByZW1vdmVQb2ludGVyKGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHAgPSBwb2ludGVyc1tpXTtcbiAgICAgICAgaWYgKHAuZXZlbnQucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xuICAgICAgICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciB1cGRhdGVQb2ludGVyID0gZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihlKSB7XG4gICAgICB2YXIgcCA9IHBvaW50ZXJzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC5ldmVudC5wb2ludGVySWQgPT09IGUucG9pbnRlcklkO1xuICAgICAgfSlbMF07XG4gICAgICBwLmV2ZW50ID0gZTtcbiAgICAgIHAudG91Y2ggPSBtYWtlVG91Y2goZSk7XG4gICAgfTtcbiAgICB2YXIgYWRkVG91Y2hlc1RvRXZlbnQgPSBmdW5jdGlvbiBhZGRUb3VjaGVzVG9FdmVudChlKSB7XG4gICAgICBlLnRvdWNoZXMgPSBwb2ludGVycy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIHAudG91Y2g7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBwb2ludGVySXNNb3VzZSA9IGZ1bmN0aW9uIHBvaW50ZXJJc01vdXNlKGUpIHtcbiAgICAgIHJldHVybiBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGUucG9pbnRlclR5cGUgPT09IDQ7XG4gICAgfTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChwb2ludGVySXNNb3VzZShlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIG1vdXNlIGFscmVhZHkgaGFuZGxlZFxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBhZGRQb2ludGVyKGUpO1xuICAgICAgYWRkVG91Y2hlc1RvRXZlbnQoZSk7XG4gICAgICB0b3VjaHN0YXJ0SGFuZGxlcihlKTtcbiAgICB9KTtcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmNvbnRhaW5lciwgJ3BvaW50ZXJ1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgcmVtb3ZlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hlbmRIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcmNhbmNlbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAocG9pbnRlcklzTW91c2UoZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBtb3VzZSBhbHJlYWR5IGhhbmRsZWRcblxuICAgICAgcmVtb3ZlUG9pbnRlcihlKTtcbiAgICAgIGFkZFRvdWNoZXNUb0V2ZW50KGUpO1xuICAgICAgdG91Y2hjYW5jZWxIYW5kbGVyKGUpO1xuICAgIH0pO1xuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuY29udGFpbmVyLCAncG9pbnRlcm1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHBvaW50ZXJJc01vdXNlKGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbW91c2UgYWxyZWFkeSBoYW5kbGVkXG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHVwZGF0ZVBvaW50ZXIoZSk7XG4gICAgICBhZGRUb3VjaGVzVG9FdmVudChlKTtcbiAgICAgIHRvdWNobW92ZUhhbmRsZXIoZSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBCUnAkMiA9IHt9O1xuQlJwJDIuZ2VuZXJhdGVQb2x5Z29uID0gZnVuY3Rpb24gKG5hbWUsIHBvaW50cykge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzW25hbWVdID0ge1xuICAgIHJlbmRlcmVyOiB0aGlzLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcG9pbnRzOiBwb2ludHMsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzKTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCB0aGlzLnBvaW50cywgbm9kZVgsIG5vZGVZLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIsIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybiBwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgaGFzTWl0ZXJCb3VuZHM6IG5hbWUgIT09ICdyZWN0YW5nbGUnLFxuICAgIG1pdGVyQm91bmRzOiBmdW5jdGlvbiBtaXRlckJvdW5kcyhjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBzdHJva2VXaWR0aCwgc3Ryb2tlUG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBtaXRlckJveCh0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgc3Ryb2tlV2lkdGgpO1xuICAgIH1cbiAgfTtcbn07XG5CUnAkMi5nZW5lcmF0ZUVsbGlwc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2VsbGlwc2UnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnZWxsaXBzZScsXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIGludGVyc2VjdExpbmVFbGxpcHNlKHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGggLyAyICsgcGFkZGluZywgaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybiBjaGVja0luRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIuZ2VuZXJhdGVSb3VuZFBvbHlnb24gPSBmdW5jdGlvbiAobmFtZSwgcG9pbnRzKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbbmFtZV0gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogbmFtZSxcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBnZXRPckNyZWF0ZUNvcm5lcnM6IGZ1bmN0aW9uIGdldE9yQ3JlYXRlQ29ybmVycyhjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzLCBmaWVsZCkge1xuICAgICAgaWYgKHJzW2ZpZWxkXSAhPT0gdW5kZWZpbmVkICYmIHJzW2ZpZWxkICsgJy1jeCddID09PSBjZW50ZXJYICYmIHJzW2ZpZWxkICsgJy1jeSddID09PSBjZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiByc1tmaWVsZF07XG4gICAgICB9XG4gICAgICByc1tmaWVsZF0gPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgICAgcnNbZmllbGQgKyAnLWN4J10gPSBjZW50ZXJYO1xuICAgICAgcnNbZmllbGQgKyAnLWN5J10gPSBjZW50ZXJZO1xuICAgICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgICAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHdpZHRoLCBoZWlnaHQpIDogY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHAgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHBvaW50cy5sZW5ndGggLyAyOyBfaSsrKSB7XG4gICAgICAgIHBbX2ldID0ge1xuICAgICAgICAgIHg6IGNlbnRlclggKyBoYWxmVyAqIHBvaW50c1tfaSAqIDJdLFxuICAgICAgICAgIHk6IGNlbnRlclkgKyBoYWxmSCAqIHBvaW50c1tfaSAqIDIgKyAxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIGksXG4gICAgICAgIHAxLFxuICAgICAgICBwMixcbiAgICAgICAgcDMsXG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgcDEgPSBwW2xlbiAtIDFdO1xuICAgICAgLy8gZm9yIGVhY2ggcG9pbnRcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwMiA9IHBbaSAlIGxlbl07XG4gICAgICAgIHAzID0gcFsoaSArIDEpICUgbGVuXTtcbiAgICAgICAgcnNbZmllbGRdW2ldID0gZ2V0Um91bmRDb3JuZXIocDEsIHAyLCBwMywgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgcDIgPSBwMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByc1tmaWVsZF07XG4gICAgfSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cywgcnMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCgncm91bmQtcG9seWdvbicsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzLCB0aGlzLmdldE9yQ3JlYXRlQ29ybmVycyhjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzLCAnZHJhd0Nvcm5lcnMnKSk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZywgY29ybmVyUmFkaXVzLCBycykge1xuICAgICAgcmV0dXJuIHJvdW5kUG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgdGhpcy5wb2ludHMsIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZywgdGhpcy5nZXRPckNyZWF0ZUNvcm5lcnMobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzLCAnY29ybmVycycpKTtcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzLCBycykge1xuICAgICAgcmV0dXJuIHBvaW50SW5zaWRlUm91bmRQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLmdldE9yQ3JlYXRlQ29ybmVycyhjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzLCAnY29ybmVycycpKTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIuZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1sncm91bmQtcmVjdGFuZ2xlJ10gPSB0aGlzLm5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgcmVuZGVyZXI6IHRoaXMsXG4gICAgbmFtZTogJ3JvdW5kLXJlY3RhbmdsZScsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzLCBjb3JuZXJSYWRpdXMpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cykge1xuICAgICAgcmV0dXJuIHJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSh4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcsIGNvcm5lclJhZGl1cyk7XG4gICAgfSxcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbiBjaGVja1BvaW50KHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGNvcm5lclJhZGl1cykge1xuICAgICAgdmFyIGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICBjb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihoYWxmV2lkdGgsIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gICAgICB2YXIgZGlhbSA9IGNvcm5lclJhZGl1cyAqIDI7XG5cbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSBkaWFtLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0b3AgbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdG9wIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cywgY2VudGVyWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LCBkaWFtLCBkaWFtLCBjZW50ZXJYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzLCBjZW50ZXJZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cywgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn07XG5CUnAkMi5nZW5lcmF0ZUN1dFJlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZVNoYXBlc1snY3V0LXJlY3RhbmdsZSddID0gdGhpcy5ub2RlU2hhcGVzWydjdXRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnY3V0LXJlY3RhbmdsZScsXG4gICAgY29ybmVyTGVuZ3RoOiBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cykge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgbnVsbCwgY29ybmVyUmFkaXVzKTtcbiAgICB9LFxuICAgIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHM6IGZ1bmN0aW9uIGdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB2YXIgY2wgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IHRoaXMuY29ybmVyTGVuZ3RoIDogY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciB4QmVnaW4gPSBjZW50ZXJYIC0gaHc7XG4gICAgICB2YXIgeEVuZCA9IGNlbnRlclggKyBodztcbiAgICAgIHZhciB5QmVnaW4gPSBjZW50ZXJZIC0gaGg7XG4gICAgICB2YXIgeUVuZCA9IGNlbnRlclkgKyBoaDtcblxuICAgICAgLy8gcG9pbnRzIGFyZSBpbiBjbG9ja3dpc2Ugb3JkZXIsIGlubmVyIChpbWFnaW5hcnkpIHRyaWFuZ2xlIHB0IG9uIFs0LCA1XVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wTGVmdDogW3hCZWdpbiwgeUJlZ2luICsgY2wsIHhCZWdpbiArIGNsLCB5QmVnaW4sIHhCZWdpbiArIGNsLCB5QmVnaW4gKyBjbF0sXG4gICAgICAgIHRvcFJpZ2h0OiBbeEVuZCAtIGNsLCB5QmVnaW4sIHhFbmQsIHlCZWdpbiArIGNsLCB4RW5kIC0gY2wsIHlCZWdpbiArIGNsXSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IFt4RW5kLCB5RW5kIC0gY2wsIHhFbmQgLSBjbCwgeUVuZCwgeEVuZCAtIGNsLCB5RW5kIC0gY2xdLFxuICAgICAgICBib3R0b21MZWZ0OiBbeEJlZ2luICsgY2wsIHlFbmQsIHhCZWdpbiwgeUVuZCAtIGNsLCB4QmVnaW4gKyBjbCwgeUVuZCAtIGNsXVxuICAgICAgfTtcbiAgICB9LFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uIGludGVyc2VjdExpbmUobm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHZhciBjUHRzID0gdGhpcy5nZW5lcmF0ZUN1dFRyaWFuZ2xlUHRzKHdpZHRoICsgMiAqIHBhZGRpbmcsIGhlaWdodCArIDIgKiBwYWRkaW5nLCBub2RlWCwgbm9kZVksIGNvcm5lclJhZGl1cyk7XG4gICAgICB2YXIgcHRzID0gW10uY29uY2F0LmFwcGx5KFtdLCBbY1B0cy50b3BMZWZ0LnNwbGljZSgwLCA0KSwgY1B0cy50b3BSaWdodC5zcGxpY2UoMCwgNCksIGNQdHMuYm90dG9tUmlnaHQuc3BsaWNlKDAsIDQpLCBjUHRzLmJvdHRvbUxlZnQuc3BsaWNlKDAsIDQpXSk7XG4gICAgICByZXR1cm4gcG9seWdvbkludGVyc2VjdExpbmUoeCwgeSwgcHRzLCBub2RlWCwgbm9kZVkpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHZhciBjbCA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gdGhpcy5jb3JuZXJMZW5ndGggOiBjb3JuZXJSYWRpdXM7XG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAocG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRoaXMucG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIGNsLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogY2wsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgY3V0VHJpYW5nbGVQdHMgPSB0aGlzLmdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICByZXR1cm4gcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLnRvcExlZnQpIHx8IHBvaW50SW5zaWRlUG9seWdvblBvaW50cyh4LCB5LCBjdXRUcmlhbmdsZVB0cy50b3BSaWdodCkgfHwgcG9pbnRJbnNpZGVQb2x5Z29uUG9pbnRzKHgsIHksIGN1dFRyaWFuZ2xlUHRzLmJvdHRvbVJpZ2h0KSB8fCBwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgY3V0VHJpYW5nbGVQdHMuYm90dG9tTGVmdCk7XG4gICAgfVxuICB9O1xufTtcbkJScCQyLmdlbmVyYXRlQmFycmVsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2RlU2hhcGVzWydiYXJyZWwnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnYmFycmVsJyxcbiAgICBwb2ludHM6IGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lclJhZGl1cykge1xuICAgICAgdGhpcy5yZW5kZXJlci5ub2RlU2hhcGVJbXBsKHRoaXMubmFtZSwgY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZywgY29ybmVyUmFkaXVzKSB7XG4gICAgICAvLyB1c2UgdHdvIGZpeGVkIHQgdmFsdWVzIGZvciB0aGUgYmV6aWVyIGN1cnZlIGFwcHJveGltYXRpb25cblxuICAgICAgdmFyIHQwID0gMC4xNTtcbiAgICAgIHZhciB0MSA9IDAuNTtcbiAgICAgIHZhciB0MiA9IDAuODU7XG4gICAgICB2YXIgYlB0cyA9IHRoaXMuZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGggKyAyICogcGFkZGluZywgaGVpZ2h0ICsgMiAqIHBhZGRpbmcsIG5vZGVYLCBub2RlWSk7XG4gICAgICB2YXIgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyA9IGZ1bmN0aW9uIGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMocHRzKSB7XG4gICAgICAgIC8vIGFwcHJveGltYXRlIGN1cnZlIHB0cyBiYXNlZCBvbiB0aGUgdHdvIHQgdmFsdWVzXG4gICAgICAgIHZhciBtMCA9IHFiZXppZXJQdEF0KHtcbiAgICAgICAgICB4OiBwdHNbMF0sXG4gICAgICAgICAgeTogcHRzWzFdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbMl0sXG4gICAgICAgICAgeTogcHRzWzNdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBwdHNbNF0sXG4gICAgICAgICAgeTogcHRzWzVdXG4gICAgICAgIH0sIHQwKTtcbiAgICAgICAgdmFyIG0xID0gcWJlemllclB0QXQoe1xuICAgICAgICAgIHg6IHB0c1swXSxcbiAgICAgICAgICB5OiBwdHNbMV1cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1syXSxcbiAgICAgICAgICB5OiBwdHNbM11cbiAgICAgICAgfSwge1xuICAgICAgICAgIHg6IHB0c1s0XSxcbiAgICAgICAgICB5OiBwdHNbNV1cbiAgICAgICAgfSwgdDEpO1xuICAgICAgICB2YXIgbTIgPSBxYmV6aWVyUHRBdCh7XG4gICAgICAgICAgeDogcHRzWzBdLFxuICAgICAgICAgIHk6IHB0c1sxXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzJdLFxuICAgICAgICAgIHk6IHB0c1szXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogcHRzWzRdLFxuICAgICAgICAgIHk6IHB0c1s1XVxuICAgICAgICB9LCB0Mik7XG4gICAgICAgIHJldHVybiBbcHRzWzBdLCBwdHNbMV0sIG0wLngsIG0wLnksIG0xLngsIG0xLnksIG0yLngsIG0yLnksIHB0c1s0XSwgcHRzWzVdXTtcbiAgICAgIH07XG4gICAgICB2YXIgcHRzID0gW10uY29uY2F0KGFwcHJveGltYXRlQmFycmVsQ3VydmVQdHMoYlB0cy50b3BMZWZ0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLnRvcFJpZ2h0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLmJvdHRvbVJpZ2h0KSwgYXBwcm94aW1hdGVCYXJyZWxDdXJ2ZVB0cyhiUHRzLmJvdHRvbUxlZnQpKTtcbiAgICAgIHJldHVybiBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBwdHMsIG5vZGVYLCBub2RlWSk7XG4gICAgfSxcbiAgICBnZW5lcmF0ZUJhcnJlbEJlemllclB0czogZnVuY3Rpb24gZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgdmFyIGhoID0gaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBodyA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciB4QmVnaW4gPSBjZW50ZXJYIC0gaHc7XG4gICAgICB2YXIgeEVuZCA9IGNlbnRlclggKyBodztcbiAgICAgIHZhciB5QmVnaW4gPSBjZW50ZXJZIC0gaGg7XG4gICAgICB2YXIgeUVuZCA9IGNlbnRlclkgKyBoaDtcbiAgICAgIHZhciBjdXJ2ZUNvbnN0YW50cyA9IGdldEJhcnJlbEN1cnZlQ29uc3RhbnRzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5oZWlnaHRPZmZzZXQ7XG4gICAgICB2YXIgd09mZnNldCA9IGN1cnZlQ29uc3RhbnRzLndpZHRoT2Zmc2V0O1xuICAgICAgdmFyIGN0cmxQdFhPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy5jdHJsUHRPZmZzZXRQY3QgKiB3aWR0aDtcblxuICAgICAgLy8gcG9pbnRzIGFyZSBpbiBjbG9ja3dpc2Ugb3JkZXIsIGlubmVyIChpbWFnaW5hcnkpIGNvbnRyb2wgcHQgb24gWzQsIDVdXG4gICAgICB2YXIgcHRzID0ge1xuICAgICAgICB0b3BMZWZ0OiBbeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0LCB4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5QmVnaW4sIHhCZWdpbiArIHdPZmZzZXQsIHlCZWdpbl0sXG4gICAgICAgIHRvcFJpZ2h0OiBbeEVuZCAtIHdPZmZzZXQsIHlCZWdpbiwgeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEVuZCwgeUJlZ2luICsgaE9mZnNldF0sXG4gICAgICAgIGJvdHRvbVJpZ2h0OiBbeEVuZCwgeUVuZCAtIGhPZmZzZXQsIHhFbmQgLSBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4RW5kIC0gd09mZnNldCwgeUVuZF0sXG4gICAgICAgIGJvdHRvbUxlZnQ6IFt4QmVnaW4gKyB3T2Zmc2V0LCB5RW5kLCB4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4QmVnaW4sIHlFbmQgLSBoT2Zmc2V0XVxuICAgICAgfTtcbiAgICAgIHB0cy50b3BMZWZ0LmlzVG9wID0gdHJ1ZTtcbiAgICAgIHB0cy50b3BSaWdodC5pc1RvcCA9IHRydWU7XG4gICAgICBwdHMuYm90dG9tTGVmdC5pc0JvdHRvbSA9IHRydWU7XG4gICAgICBwdHMuYm90dG9tUmlnaHQuaXNCb3R0b20gPSB0cnVlO1xuICAgICAgcmV0dXJuIHB0cztcbiAgICB9LFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uIGNoZWNrUG9pbnQoeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgY29ybmVyUmFkaXVzKSB7XG4gICAgICB2YXIgY3VydmVDb25zdGFudHMgPSBnZXRCYXJyZWxDdXJ2ZUNvbnN0YW50cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBoT2Zmc2V0ID0gY3VydmVDb25zdGFudHMuaGVpZ2h0T2Zmc2V0O1xuICAgICAgdmFyIHdPZmZzZXQgPSBjdXJ2ZUNvbnN0YW50cy53aWR0aE9mZnNldDtcblxuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBoT2Zmc2V0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogd09mZnNldCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBiYXJyZWxDdXJ2ZVB0cyA9IHRoaXMuZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMod2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICB2YXIgZ2V0Q3VydmVUID0gZnVuY3Rpb24gZ2V0Q3VydmVUKHgsIHksIGN1cnZlUHRzKSB7XG4gICAgICAgIHZhciB4MCA9IGN1cnZlUHRzWzRdO1xuICAgICAgICB2YXIgeDEgPSBjdXJ2ZVB0c1syXTtcbiAgICAgICAgdmFyIHgyID0gY3VydmVQdHNbMF07XG4gICAgICAgIHZhciB5MCA9IGN1cnZlUHRzWzVdO1xuICAgICAgICAvLyB2YXIgeTEgPSBjdXJ2ZVB0c1sgMyBdO1xuICAgICAgICB2YXIgeTIgPSBjdXJ2ZVB0c1sxXTtcbiAgICAgICAgdmFyIHhNaW4gPSBNYXRoLm1pbih4MCwgeDIpO1xuICAgICAgICB2YXIgeE1heCA9IE1hdGgubWF4KHgwLCB4Mik7XG4gICAgICAgIHZhciB5TWluID0gTWF0aC5taW4oeTAsIHkyKTtcbiAgICAgICAgdmFyIHlNYXggPSBNYXRoLm1heCh5MCwgeTIpO1xuICAgICAgICBpZiAoeE1pbiA8PSB4ICYmIHggPD0geE1heCAmJiB5TWluIDw9IHkgJiYgeSA8PSB5TWF4KSB7XG4gICAgICAgICAgdmFyIGNvZWZmID0gYmV6aWVyUHRzVG9RdWFkQ29lZmYoeDAsIHgxLCB4Mik7XG4gICAgICAgICAgdmFyIHJvb3RzID0gc29sdmVRdWFkcmF0aWMoY29lZmZbMF0sIGNvZWZmWzFdLCBjb2VmZlsyXSwgeCk7XG4gICAgICAgICAgdmFyIHZhbGlkUm9vdHMgPSByb290cy5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgIHJldHVybiAwIDw9IHIgJiYgciA8PSAxO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh2YWxpZFJvb3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZFJvb3RzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG4gICAgICB2YXIgY3VydmVSZWdpb25zID0gT2JqZWN0LmtleXMoYmFycmVsQ3VydmVQdHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdXJ2ZVJlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvcm5lciA9IGN1cnZlUmVnaW9uc1tpXTtcbiAgICAgICAgdmFyIGNvcm5lclB0cyA9IGJhcnJlbEN1cnZlUHRzW2Nvcm5lcl07XG4gICAgICAgIHZhciB0ID0gZ2V0Q3VydmVUKHgsIHksIGNvcm5lclB0cyk7XG4gICAgICAgIGlmICh0ID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeTAgPSBjb3JuZXJQdHNbNV07XG4gICAgICAgIHZhciB5MSA9IGNvcm5lclB0c1szXTtcbiAgICAgICAgdmFyIHkyID0gY29ybmVyUHRzWzFdO1xuICAgICAgICB2YXIgYmV6WSA9IHFiZXppZXJBdCh5MCwgeTEsIHkyLCB0KTtcbiAgICAgICAgaWYgKGNvcm5lclB0cy5pc1RvcCAmJiBiZXpZIDw9IHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ybmVyUHRzLmlzQm90dG9tICYmIHkgPD0gYmV6WSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufTtcbkJScCQyLmdlbmVyYXRlQm90dG9tUm91bmRyZWN0YW5nbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVTaGFwZXNbJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnXSA9IHRoaXMubm9kZVNoYXBlc1snYm90dG9tcm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICByZW5kZXJlcjogdGhpcyxcbiAgICBuYW1lOiAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZScsXG4gICAgcG9pbnRzOiBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIubm9kZVNoYXBlSW1wbCh0aGlzLm5hbWUsIGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHRoaXMucG9pbnRzLCBjb3JuZXJSYWRpdXMpO1xuICAgIH0sXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24gaW50ZXJzZWN0TGluZShub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcsIGNvcm5lclJhZGl1cykge1xuICAgICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgICAgdmFyIHRvcEVuZFggPSBub2RlWCArICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHZhciB0b3BJbnRlcnNlY3Rpb25zID0gZmluaXRlTGluZXNJbnRlcnNlY3QoeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuICAgICAgaWYgKHRvcEludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdG9wSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiByb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoeCwgeSwgbm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nLCBjb3JuZXJSYWRpdXMpO1xuICAgIH0sXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24gY2hlY2tQb2ludCh4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBjb3JuZXJSYWRpdXMpIHtcbiAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgZGlhbSA9IDIgKiBjb3JuZXJSYWRpdXM7XG5cbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdGhpcy5wb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSBkaWFtLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKHBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0aGlzLnBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSBkaWFtLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBub24tcm91bmRlZCB0b3Agc2lkZVxuICAgICAgdmFyIG91dGVyV2lkdGggPSB3aWR0aCAvIDIgKyAyICogcGFkZGluZztcbiAgICAgIHZhciBvdXRlckhlaWdodCA9IGhlaWdodCAvIDIgKyAyICogcGFkZGluZztcbiAgICAgIHZhciBwb2ludHMgPSBbY2VudGVyWCAtIG91dGVyV2lkdGgsIGNlbnRlclkgLSBvdXRlckhlaWdodCwgY2VudGVyWCAtIG91dGVyV2lkdGgsIGNlbnRlclksIGNlbnRlclggKyBvdXRlcldpZHRoLCBjZW50ZXJZLCBjZW50ZXJYICsgb3V0ZXJXaWR0aCwgY2VudGVyWSAtIG91dGVySGVpZ2h0XTtcbiAgICAgIGlmIChwb2ludEluc2lkZVBvbHlnb25Qb2ludHMoeCwgeSwgcG9pbnRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSwgZGlhbSwgZGlhbSwgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cywgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksIGRpYW0sIGRpYW0sIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59O1xuQlJwJDIucmVnaXN0ZXJOb2RlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZVNoYXBlcyA9IHRoaXMubm9kZVNoYXBlcyA9IHt9O1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICB0aGlzLmdlbmVyYXRlRWxsaXBzZSgpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbigndHJpYW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC10cmlhbmdsZScsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSgzLCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdyZWN0YW5nbGUnLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCkpO1xuICBub2RlU2hhcGVzWydzcXVhcmUnXSA9IG5vZGVTaGFwZXNbJ3JlY3RhbmdsZSddO1xuICB0aGlzLmdlbmVyYXRlUm91bmRSZWN0YW5nbGUoKTtcbiAgdGhpcy5nZW5lcmF0ZUN1dFJlY3RhbmdsZSgpO1xuICB0aGlzLmdlbmVyYXRlQmFycmVsKCk7XG4gIHRoaXMuZ2VuZXJhdGVCb3R0b21Sb3VuZHJlY3RhbmdsZSgpO1xuICB7XG4gICAgdmFyIGRpYW1vbmRQb2ludHMgPSBbMCwgMSwgMSwgMCwgMCwgLTEsIC0xLCAwXTtcbiAgICB0aGlzLmdlbmVyYXRlUG9seWdvbignZGlhbW9uZCcsIGRpYW1vbmRQb2ludHMpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWRpYW1vbmQnLCBkaWFtb25kUG9pbnRzKTtcbiAgfVxuICB0aGlzLmdlbmVyYXRlUG9seWdvbigncGVudGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1wZW50YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg1LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXhhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDYsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVJvdW5kUG9seWdvbigncm91bmQtaGV4YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCdoZXB0YWdvbicsIGdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSk7XG4gIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLWhlcHRhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDcsIDApKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ29jdGFnb24nLCBnZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoOCwgMCkpO1xuICB0aGlzLmdlbmVyYXRlUm91bmRQb2x5Z29uKCdyb3VuZC1vY3RhZ29uJywgZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApKTtcbiAgdmFyIHN0YXI1UG9pbnRzID0gbmV3IEFycmF5KDIwKTtcbiAge1xuICAgIHZhciBvdXRlclBvaW50cyA9IGdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgMCk7XG4gICAgdmFyIGlubmVyUG9pbnRzID0gZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCBNYXRoLlBJIC8gNSk7XG5cbiAgICAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcbiAgICBpbm5lclJhZGl1cyAqPSAxLjU3O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXJQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBpbm5lclBvaW50c1tpICogMl0gKj0gaW5uZXJSYWRpdXM7XG4gICAgICBpbm5lclBvaW50c1tpICogMiArIDFdICo9IGlubmVyUmFkaXVzO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDIwIC8gNDsgaSsrKSB7XG4gICAgICBzdGFyNVBvaW50c1tpICogNF0gPSBvdXRlclBvaW50c1tpICogMl07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDFdID0gb3V0ZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIHN0YXI1UG9pbnRzW2kgKiA0ICsgMl0gPSBpbm5lclBvaW50c1tpICogMl07XG4gICAgICBzdGFyNVBvaW50c1tpICogNCArIDNdID0gaW5uZXJQb2ludHNbaSAqIDIgKyAxXTtcbiAgICB9XG4gIH1cbiAgc3RhcjVQb2ludHMgPSBmaXRQb2x5Z29uVG9TcXVhcmUoc3RhcjVQb2ludHMpO1xuICB0aGlzLmdlbmVyYXRlUG9seWdvbignc3RhcicsIHN0YXI1UG9pbnRzKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3ZlZScsIFstMSwgLTEsIDAsIC0wLjMzMywgMSwgLTEsIDAsIDFdKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3Job21ib2lkJywgWy0xLCAtMSwgMC4zMzMsIC0xLCAxLCAxLCAtMC4zMzMsIDFdKTtcbiAgdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ3JpZ2h0LXJob21ib2lkJywgWy0wLjMzMywgLTEsIDEsIC0xLCAwLjMzMywgMSwgLTEsIDFdKTtcbiAgdGhpcy5ub2RlU2hhcGVzWydjb25jYXZlaGV4YWdvbiddID0gdGhpcy5nZW5lcmF0ZVBvbHlnb24oJ2NvbmNhdmUtaGV4YWdvbicsIFstMSwgLTAuOTUsIC0wLjc1LCAwLCAtMSwgMC45NSwgMSwgMC45NSwgMC43NSwgMCwgMSwgLTAuOTVdKTtcbiAge1xuICAgIHZhciB0YWdQb2ludHMgPSBbLTEsIC0xLCAwLjI1LCAtMSwgMSwgMCwgMC4yNSwgMSwgLTEsIDFdO1xuICAgIHRoaXMuZ2VuZXJhdGVQb2x5Z29uKCd0YWcnLCB0YWdQb2ludHMpO1xuICAgIHRoaXMuZ2VuZXJhdGVSb3VuZFBvbHlnb24oJ3JvdW5kLXRhZycsIHRhZ1BvaW50cyk7XG4gIH1cbiAgbm9kZVNoYXBlcy5tYWtlUG9seWdvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcbiAgICAvLyB1c2UgY2FjaGluZyBvbiB1c2VyLXNwZWNpZmllZCBwb2x5Z29ucyBzbyB0aGV5IGFyZSBhcyBmYXN0IGFzIG5hdGl2ZSBzaGFwZXNcblxuICAgIHZhciBrZXkgPSBwb2ludHMuam9pbignJCcpO1xuICAgIHZhciBuYW1lID0gJ3BvbHlnb24tJyArIGtleTtcbiAgICB2YXIgc2hhcGU7XG4gICAgaWYgKHNoYXBlID0gdGhpc1tuYW1lXSkge1xuICAgICAgLy8gZ290IGNhY2hlZCBzaGFwZVxuICAgICAgcmV0dXJuIHNoYXBlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhbmQgY2FjaGUgbmV3IHNoYXBlXG4gICAgcmV0dXJuIHJlbmRlcmVyLmdlbmVyYXRlUG9seWdvbihuYW1lLCBwb2ludHMpO1xuICB9O1xufTtcblxudmFyIEJScCQxID0ge307XG5CUnAkMS50aW1lVG9SZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlZHJhd1RvdGFsVGltZSAvIHRoaXMucmVkcmF3Q291bnQ7XG59O1xuQlJwJDEucmVkcmF3ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgc3RhdGljRW1wdHlPYmplY3QoKTtcbiAgdmFyIHIgPSB0aGlzO1xuICBpZiAoci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IDA7XG4gIH1cbiAgaWYgKHIubGFzdFJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHIubGFzdFJlZHJhd1RpbWUgPSAwO1xuICB9XG4gIGlmIChyLmxhc3REcmF3VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgci5sYXN0RHJhd1RpbWUgPSAwO1xuICB9XG4gIHIucmVxdWVzdGVkRnJhbWUgPSB0cnVlO1xuICByLnJlbmRlck9wdGlvbnMgPSBvcHRpb25zO1xufTtcbkJScCQxLmJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uIChmbiwgcHJpb3JpdHkpIHtcbiAgLy8gdGhlIHJlbmRlcmVyIGNhbid0IGFkZCB0aWNrIGNhbGxiYWNrcyB3aGVuIGRlc3Ryb3llZFxuICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByaW9yaXR5ID09IG51bGwpIHtcbiAgICBlcnJvcignUHJpb3JpdHkgaXMgbm90IG9wdGlvbmFsIGZvciBiZWZvcmVSZW5kZXInKTtcbiAgfVxuICB2YXIgY2JzID0gdGhpcy5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG4gIGNicy5wdXNoKHtcbiAgICBmbjogZm4sXG4gICAgcHJpb3JpdHk6IHByaW9yaXR5XG4gIH0pO1xuXG4gIC8vIGhpZ2hlciBwcmlvcml0eSBjYWxsYmFja3MgZXhlY3V0ZWQgZmlyc3RcbiAgY2JzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHk7XG4gIH0pO1xufTtcbnZhciBiZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBmdW5jdGlvbiBiZWZvcmVSZW5kZXJDYWxsYmFja3Mociwgd2lsbERyYXcsIHN0YXJ0VGltZSkge1xuICB2YXIgY2JzID0gci5iZWZvcmVSZW5kZXJDYWxsYmFja3M7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2JzW2ldLmZuKHdpbGxEcmF3LCBzdGFydFRpbWUpO1xuICB9XG59O1xuQlJwJDEuc3RhcnRSZW5kZXJMb29wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG4gIGlmIChyLnJlbmRlckxvb3BTdGFydGVkKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHIucmVuZGVyTG9vcFN0YXJ0ZWQgPSB0cnVlO1xuICB9XG4gIHZhciBfcmVuZGVyRm4gPSBmdW5jdGlvbiByZW5kZXJGbihyZXF1ZXN0VGltZSkge1xuICAgIGlmIChyLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3kuYmF0Y2hpbmcoKSkgOyBlbHNlIGlmIChyLnJlcXVlc3RlZEZyYW1lICYmICFyLnNraXBGcmFtZSkge1xuICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIHRydWUsIHJlcXVlc3RUaW1lKTtcbiAgICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgci5yZW5kZXIoci5yZW5kZXJPcHRpb25zKTtcbiAgICAgIHZhciBlbmRUaW1lID0gci5sYXN0RHJhd1RpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgaWYgKHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChyLnJlZHJhd0NvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgci5yZWRyYXdDb3VudCA9IDA7XG4gICAgICB9XG4gICAgICByLnJlZHJhd0NvdW50Kys7XG4gICAgICBpZiAoci5yZWRyYXdUb3RhbFRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByLnJlZHJhd1RvdGFsVGltZSA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgZHVyYXRpb24gPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgci5yZWRyYXdUb3RhbFRpbWUgKz0gZHVyYXRpb247XG4gICAgICByLmxhc3RSZWRyYXdUaW1lID0gZHVyYXRpb247XG5cbiAgICAgIC8vIHVzZSBhIHdlaWdodGVkIGF2ZXJhZ2Ugd2l0aCBhIGJpYXMgZnJvbSB0aGUgcHJldmlvdXMgYXZlcmFnZSBzbyB3ZSBkb24ndCBzcGlrZSBzbyBlYXNpbHlcbiAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lIC8gMiArIGR1cmF0aW9uIC8gMjtcbiAgICAgIHIucmVxdWVzdGVkRnJhbWUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmVmb3JlUmVuZGVyQ2FsbGJhY2tzKHIsIGZhbHNlLCByZXF1ZXN0VGltZSk7XG4gICAgfVxuICAgIHIuc2tpcEZyYW1lID0gZmFsc2U7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9yZW5kZXJGbik7XG4gIH07XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShfcmVuZGVyRm4pO1xufTtcblxudmFyIEJhc2VSZW5kZXJlciA9IGZ1bmN0aW9uIEJhc2VSZW5kZXJlcihvcHRpb25zKSB7XG4gIHRoaXMuaW5pdChvcHRpb25zKTtcbn07XG52YXIgQlIgPSBCYXNlUmVuZGVyZXI7XG52YXIgQlJwID0gQlIucHJvdG90eXBlO1xuQlJwLmNsaWVudEZ1bmN0aW9ucyA9IFsncmVkcmF3SGludCcsICdyZW5kZXInLCAncmVuZGVyVG8nLCAnbWF0Y2hDYW52YXNTaXplJywgJ25vZGVTaGFwZUltcGwnLCAnYXJyb3dTaGFwZUltcGwnXTtcbkJScC5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICByLm9wdGlvbnMgPSBvcHRpb25zO1xuICByLmN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGN0ciA9IHIuY29udGFpbmVyID0gb3B0aW9ucy5jeS5jb250YWluZXIoKTtcbiAgdmFyIGNvbnRhaW5lcldpbmRvdyA9IHIuY3kud2luZG93KCk7XG5cbiAgLy8gcHJlcGVuZCBhIHN0eWxlc2hlZXQgaW4gdGhlIGhlYWQgc3VjaCB0aGF0XG4gIGlmIChjb250YWluZXJXaW5kb3cpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSBjb250YWluZXJXaW5kb3cuZG9jdW1lbnQ7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkO1xuICAgIHZhciBzdHlsZXNoZWV0SWQgPSAnX19fX19fX19fX2N5dG9zY2FwZV9zdHlsZXNoZWV0JztcbiAgICB2YXIgY2xhc3NOYW1lID0gJ19fX19fX19fX19jeXRvc2NhcGVfY29udGFpbmVyJztcbiAgICB2YXIgc3R5bGVzaGVldEFscmVhZHlFeGlzdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHlsZXNoZWV0SWQpICE9IG51bGw7XG4gICAgaWYgKGN0ci5jbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpIDwgMCkge1xuICAgICAgY3RyLmNsYXNzTmFtZSA9IChjdHIuY2xhc3NOYW1lIHx8ICcnKSArICcgJyArIGNsYXNzTmFtZTtcbiAgICB9XG4gICAgaWYgKCFzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cykge1xuICAgICAgdmFyIHN0eWxlc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGVzaGVldC5pZCA9IHN0eWxlc2hlZXRJZDtcbiAgICAgIHN0eWxlc2hlZXQudGV4dENvbnRlbnQgPSAnLicgKyBjbGFzc05hbWUgKyAnIHsgcG9zaXRpb246IHJlbGF0aXZlOyB9JztcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlc2hlZXQsIGhlYWQuY2hpbGRyZW5bMF0pOyAvLyBmaXJzdCBzbyBsb3dlc3QgcHJpb3JpdHlcbiAgICB9XG4gICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBjb250YWluZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjdHIpO1xuICAgIHZhciBwb3NpdGlvbiA9IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcbiAgICBpZiAocG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICB3YXJuKCdBIEN5dG9zY2FwZSBjb250YWluZXIgaGFzIHN0eWxlIHBvc2l0aW9uOnN0YXRpYyBhbmQgc28gY2FuIG5vdCB1c2UgVUkgZXh0ZW5zaW9ucyBwcm9wZXJseScpO1xuICAgIH1cbiAgfVxuICByLnNlbGVjdGlvbiA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDBdOyAvLyBDb29yZGluYXRlcyBmb3Igc2VsZWN0aW9uIGJveCwgcGx1cyBlbmFibGVkIGZsYWdcblxuICByLmJlemllclByb2pQY3RzID0gWzAuMDUsIDAuMjI1LCAwLjQsIDAuNSwgMC42LCAwLjc3NSwgMC45NV07XG5cbiAgLy8tLVBvaW50ZXItcmVsYXRlZCBkYXRhXG4gIHIuaG92ZXJEYXRhID0ge1xuICAgIGRvd246IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBkb3duVGltZTogbnVsbCxcbiAgICB0cmlnZ2VyTW9kZTogbnVsbCxcbiAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgaW5pdGlhbFBhbjogW251bGwsIG51bGxdLFxuICAgIGNhcHR1cmU6IGZhbHNlXG4gIH07XG4gIHIuZHJhZ0RhdGEgPSB7XG4gICAgcG9zc2libGVEcmFnRWxlbWVudHM6IFtdXG4gIH07XG4gIHIudG91Y2hEYXRhID0ge1xuICAgIHN0YXJ0OiBudWxsLFxuICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgIC8vIFRoZXNlIDMgZmllbGRzIHJlbGF0ZWQgdG8gdGFwLCB0YXBob2xkIGV2ZW50c1xuICAgIHN0YXJ0UG9zaXRpb246IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICBzaW5nbGVUb3VjaFN0YXJ0VGltZTogbnVsbCxcbiAgICBzaW5nbGVUb3VjaE1vdmVkOiB0cnVlLFxuICAgIG5vdzogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLFxuICAgIGVhcmxpZXI6IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXVxuICB9O1xuICByLnJlZHJhd3MgPSAwO1xuICByLnNob3dGcHMgPSBvcHRpb25zLnNob3dGcHM7XG4gIHIuZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICByLndlYmdsID0gb3B0aW9ucy53ZWJnbDtcbiAgci5oaWRlRWRnZXNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICByLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgci53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICByLm1vdGlvbkJsdXJFbmFibGVkID0gb3B0aW9ucy5tb3Rpb25CbHVyOyAvLyBvbiBieSBkZWZhdWx0XG4gIHIuZm9yY2VkUGl4ZWxSYXRpbyA9IG51bWJlciQxKG9wdGlvbnMucGl4ZWxSYXRpbykgPyBvcHRpb25zLnBpeGVsUmF0aW8gOiBudWxsO1xuICByLm1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIGZvciBpbml0aWFsIGtpY2sgb2ZmXG4gIHIubW90aW9uQmx1ck9wYWNpdHkgPSBvcHRpb25zLm1vdGlvbkJsdXJPcGFjaXR5O1xuICByLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgPSAxIC0gci5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgci5tb3Rpb25CbHVyUHhSYXRpbyA9IDE7XG4gIHIubWJQeFJCbHVycnkgPSAxOyAvLzAuODtcbiAgci5taW5NYkxvd1F1YWxGcmFtZXMgPSA0O1xuICByLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgci5jbGVhcmVkRm9yTW90aW9uQmx1ciA9IFtdO1xuICByLmRlc2t0b3BUYXBUaHJlc2hvbGQgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gIHIuZGVza3RvcFRhcFRocmVzaG9sZDIgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQgKiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gIHIudG91Y2hUYXBUaHJlc2hvbGQgPSBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICByLnRvdWNoVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQgKiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICByLnRhcGhvbGREdXJhdGlvbiA9IDUwMDtcbiAgci5iaW5kaW5ncyA9IFtdO1xuICByLmJlZm9yZVJlbmRlckNhbGxiYWNrcyA9IFtdO1xuICByLmJlZm9yZVJlbmRlclByaW9yaXRpZXMgPSB7XG4gICAgLy8gaGlnaGVyIHByaW9yaXR5IGV4ZWNzIGJlZm9yZSBsb3dlciBvbmVcbiAgICBhbmltYXRpb25zOiA0MDAsXG4gICAgZWxlQ2FsY3M6IDMwMCxcbiAgICBlbGVUeHJEZXE6IDIwMCxcbiAgICBseXJUeHJEZXE6IDE1MCxcbiAgICBseXJUeHJTa2lwOiAxMDBcbiAgfTtcbiAgci5yZWdpc3Rlck5vZGVTaGFwZXMoKTtcbiAgci5yZWdpc3RlckFycm93U2hhcGVzKCk7XG4gIHIucmVnaXN0ZXJDYWxjdWxhdGlvbkxpc3RlbmVycygpO1xufTtcbkJScC5ub3RpZnkgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBlbGVzKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGN5ID0gci5jeTtcblxuICAvLyB0aGUgcmVuZGVyZXIgY2FuJ3QgYmUgbm90aWZpZWQgYWZ0ZXIgaXQncyBkZXN0cm95ZWRcbiAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChldmVudE5hbWUgPT09ICdpbml0Jykge1xuICAgIHIubG9hZCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZXZlbnROYW1lID09PSAnZGVzdHJveScpIHtcbiAgICByLmRlc3Ryb3koKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2FkZCcgfHwgZXZlbnROYW1lID09PSAncmVtb3ZlJyB8fCBldmVudE5hbWUgPT09ICdtb3ZlJyAmJiBjeS5oYXNDb21wb3VuZE5vZGVzKCkgfHwgZXZlbnROYW1lID09PSAnbG9hZCcgfHwgZXZlbnROYW1lID09PSAnem9yZGVyJyB8fCBldmVudE5hbWUgPT09ICdtb3VudCcpIHtcbiAgICByLmludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcygpO1xuICB9XG4gIGlmIChldmVudE5hbWUgPT09ICd2aWV3cG9ydCcpIHtcbiAgICByLnJlZHJhd0hpbnQoJ3NlbGVjdCcsIHRydWUpO1xuICB9XG4gIGlmIChldmVudE5hbWUgPT09ICdnYycpIHtcbiAgICByLnJlZHJhd0hpbnQoJ2djJywgdHJ1ZSk7XG4gIH1cbiAgaWYgKGV2ZW50TmFtZSA9PT0gJ2xvYWQnIHx8IGV2ZW50TmFtZSA9PT0gJ3Jlc2l6ZScgfHwgZXZlbnROYW1lID09PSAnbW91bnQnKSB7XG4gICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcbiAgICByLm1hdGNoQ2FudmFzU2l6ZShyLmNvbnRhaW5lcik7XG4gIH1cbiAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gIHIucmVkcmF3SGludCgnZHJhZycsIHRydWUpO1xuICB0aGlzLnN0YXJ0UmVuZGVyTG9vcCgpO1xuICB0aGlzLnJlZHJhdygpO1xufTtcbkJScC5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHIuZGVzdHJveWVkID0gdHJ1ZTtcbiAgci5jeS5zdG9wQW5pbWF0aW9uTG9vcCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHIuYmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmluZGluZyA9IHIuYmluZGluZ3NbaV07XG4gICAgdmFyIGIgPSBiaW5kaW5nO1xuICAgIHZhciB0Z3QgPSBiLnRhcmdldDtcbiAgICAodGd0Lm9mZiB8fCB0Z3QucmVtb3ZlRXZlbnRMaXN0ZW5lcikuYXBwbHkodGd0LCBiLmFyZ3MpO1xuICB9XG4gIHIuYmluZGluZ3MgPSBbXTtcbiAgci5iZWZvcmVSZW5kZXJDYWxsYmFja3MgPSBbXTtcbiAgci5vblVwZGF0ZUVsZUNhbGNzRm5zID0gW107XG4gIGlmIChyLnJlbW92ZU9ic2VydmVyKSB7XG4gICAgci5yZW1vdmVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHIuc3R5bGVPYnNlcnZlcikge1xuICAgIHIuc3R5bGVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHIucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICByLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAoci5sYWJlbENhbGNEaXYpIHtcbiAgICB0cnkge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyLmxhYmVsQ2FsY0Rpdik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZTEwIGlzc3VlICMxMDE0XG4gICAgfVxuICB9XG59O1xuQlJwLmlzSGVhZGxlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5bQlJwJGYsIEJScCQ1LCBCUnAkNCwgQlJwJDMsIEJScCQyLCBCUnAkMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKEJScCwgcHJvcHMpO1xufSk7XG5cbnZhciBmdWxsRnBzVGltZSA9IDEwMDAgLyA2MDsgLy8gYXNzdW1lIDYwIGZyYW1lcyBwZXIgc2Vjb25kXG5cbnZhciBkZWZzID0ge1xuICBzZXR1cERlcXVldWVpbmc6IGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZyhvcHRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldHVwRGVxdWV1ZWluZ0ltcGwoKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICBpZiAoc2VsZi5kZXF1ZXVlaW5nU2V0dXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5kZXF1ZXVlaW5nU2V0dXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHF1ZXVlUmVkcmF3ID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByLnJlZHJhd0hpbnQoJ2VsZXMnLCB0cnVlKTtcbiAgICAgICAgci5yZWRyYXdIaW50KCdkcmFnJywgdHJ1ZSk7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9LCBvcHRzLmRlcVJlZHJhd1RocmVzaG9sZCk7XG4gICAgICB2YXIgZGVxdWV1ZSA9IGZ1bmN0aW9uIGRlcXVldWUod2lsbERyYXcsIGZyYW1lU3RhcnRUaW1lKSB7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICB2YXIgYXZnUmVuZGVyVGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWU7XG4gICAgICAgIHZhciByZW5kZXJUaW1lID0gci5sYXN0UmVkcmF3VGltZTtcbiAgICAgICAgdmFyIGRlcWQgPSBbXTtcbiAgICAgICAgdmFyIGV4dGVudCA9IHIuY3kuZXh0ZW50KCk7XG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gci5nZXRQaXhlbFJhdGlvKCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbid0IGluIGEgdGljayB0aGF0IGNhdXNlcyBhIGRyYXcsIHRoZW4gdGhlIHJlbmRlcmVkIHN0eWxlXG4gICAgICAgIC8vIHF1ZXVlIHdvbid0IGF1dG9tYXRpY2FsbHkgYmUgZmx1c2hlZCBiZWZvcmUgZGVxdWV1ZWluZyBzdGFydHNcbiAgICAgICAgaWYgKCF3aWxsRHJhdykge1xuICAgICAgICAgIHIuZmx1c2hSZW5kZXJlZFN0eWxlUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlTm93KCk7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gbm93IC0gc3RhcnRUaW1lO1xuICAgICAgICAgIHZhciBmcmFtZUR1cmF0aW9uID0gbm93IC0gZnJhbWVTdGFydFRpbWU7XG4gICAgICAgICAgaWYgKHJlbmRlclRpbWUgPCBmdWxsRnBzVGltZSkge1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgcmVuZGVyaW5nIGZhc3RlciB0aGFuIHRoZSBpZGVhbCBmcHMsIHRoZW4gZG8gZGVxdWV1ZWluZ1xuICAgICAgICAgICAgLy8gZHVyaW5nIGFsbCBvZiB0aGUgcmVtYWluaW5nIGZyYW1lIHRpbWVcblxuICAgICAgICAgICAgdmFyIHRpbWVBdmFpbGFibGUgPSBmdWxsRnBzVGltZSAtICh3aWxsRHJhdyA/IGF2Z1JlbmRlclRpbWUgOiAwKTtcbiAgICAgICAgICAgIGlmIChmcmFtZUR1cmF0aW9uID49IG9wdHMuZGVxRmFzdENvc3QgKiB0aW1lQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2lsbERyYXcpIHtcbiAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uID49IG9wdHMuZGVxQ29zdCAqIHJlbmRlclRpbWUgfHwgZHVyYXRpb24gPj0gb3B0cy5kZXFBdmdDb3N0ICogYXZnUmVuZGVyVGltZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lRHVyYXRpb24gPj0gb3B0cy5kZXFOb0RyYXdDb3N0ICogZnVsbEZwc1RpbWUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0aGlzRGVxZCA9IG9wdHMuZGVxKHNlbGYsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgICAgICAgaWYgKHRoaXNEZXFkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpc0RlcWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgZGVxZC5wdXNoKHRoaXNEZXFkW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsbGJhY2tzIG9uIGRlcXVldWVcbiAgICAgICAgaWYgKGRlcWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdHMub25EZXFkKHNlbGYsIGRlcWQpO1xuICAgICAgICAgIGlmICghd2lsbERyYXcgJiYgb3B0cy5zaG91bGRSZWRyYXcoc2VsZiwgZGVxZCwgcGl4ZWxSYXRpbywgZXh0ZW50KSkge1xuICAgICAgICAgICAgcXVldWVSZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcHJpb3JpdHkgPSBvcHRzLnByaW9yaXR5IHx8IG5vb3AkMTtcbiAgICAgIHIuYmVmb3JlUmVuZGVyKGRlcXVldWUsIHByaW9yaXR5KHNlbGYpKTtcbiAgICB9O1xuICB9XG59O1xuXG4vLyBBbGxvd3MgbG9va3VwcyBmb3IgKGVsZSwgbHZsKSA9PiBjYWNoZS5cbi8vIFVzZXMga2V5cyBzbyBlbGVtZW50cyBtYXkgc2hhcmUgdGhlIHNhbWUgY2FjaGUuXG52YXIgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVsZW1lbnRUZXh0dXJlQ2FjaGVMb29rdXAoZ2V0S2V5KSB7XG4gICAgdmFyIGRvZXNFbGVJbnZhbGlkYXRlS2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzaWZ5O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwKTtcbiAgICB0aGlzLmlkc0J5S2V5ID0gbmV3IE1hcCQxKCk7XG4gICAgdGhpcy5rZXlGb3JJZCA9IG5ldyBNYXAkMSgpO1xuICAgIHRoaXMuY2FjaGVzQnlMdmwgPSBuZXcgTWFwJDEoKTtcbiAgICB0aGlzLmx2bHMgPSBbXTtcbiAgICB0aGlzLmdldEtleSA9IGdldEtleTtcbiAgICB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5ID0gZG9lc0VsZUludmFsaWRhdGVLZXk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwLCBbe1xuICAgIGtleTogXCJnZXRJZHNGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SWRzRm9yKGtleSkge1xuICAgICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAgIGVycm9yKFwiQ2FuIG5vdCBnZXQgaWQgbGlzdCBmb3IgbnVsbCBrZXlcIik7XG4gICAgICB9XG4gICAgICB2YXIgaWRzQnlLZXkgPSB0aGlzLmlkc0J5S2V5O1xuICAgICAgdmFyIGlkcyA9IHRoaXMuaWRzQnlLZXkuZ2V0KGtleSk7XG4gICAgICBpZiAoIWlkcykge1xuICAgICAgICBpZHMgPSBuZXcgU2V0JDEoKTtcbiAgICAgICAgaWRzQnlLZXkuc2V0KGtleSwgaWRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpZHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZElkRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZElkRm9yS2V5KGtleSwgaWQpIHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmdldElkc0ZvcihrZXkpLmFkZChpZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUlkRm9yS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUlkRm9yS2V5KGtleSwgaWQpIHtcbiAgICAgIGlmIChrZXkgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmdldElkc0ZvcihrZXkpW1wiZGVsZXRlXCJdKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TnVtYmVyT2ZJZHNGb3JLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TnVtYmVyT2ZJZHNGb3JLZXkoa2V5KSB7XG4gICAgICBpZiAoa2V5ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJZHNGb3Ioa2V5KS5zaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVLZXlNYXBwaW5nRm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUtleU1hcHBpbmdGb3IoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBwcmV2S2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoaWQpO1xuICAgICAgdmFyIGN1cnJLZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgdGhpcy5kZWxldGVJZEZvcktleShwcmV2S2V5LCBpZCk7XG4gICAgICB0aGlzLmFkZElkRm9yS2V5KGN1cnJLZXksIGlkKTtcbiAgICAgIHRoaXMua2V5Rm9ySWQuc2V0KGlkLCBjdXJyS2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlS2V5TWFwcGluZ0ZvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVLZXlNYXBwaW5nRm9yKGVsZSkge1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgcHJldktleSA9IHRoaXMua2V5Rm9ySWQuZ2V0KGlkKTtcbiAgICAgIHRoaXMuZGVsZXRlSWRGb3JLZXkocHJldktleSwgaWQpO1xuICAgICAgdGhpcy5rZXlGb3JJZFtcImRlbGV0ZVwiXShpZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImtleUhhc0NoYW5nZWRGb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2V5SGFzQ2hhbmdlZEZvcihlbGUpIHtcbiAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuICAgICAgdmFyIHByZXZLZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7XG4gICAgICB2YXIgbmV3S2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHJldHVybiBwcmV2S2V5ICE9PSBuZXdLZXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW52YWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludmFsaWQoZWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlIYXNDaGFuZ2VkRm9yKGVsZSkgfHwgdGhpcy5kb2VzRWxlSW52YWxpZGF0ZUtleShlbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWNoZXNBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZXNBdChsdmwpIHtcbiAgICAgIHZhciBjYWNoZXNCeUx2bCA9IHRoaXMuY2FjaGVzQnlMdmwsXG4gICAgICAgIGx2bHMgPSB0aGlzLmx2bHM7XG4gICAgICB2YXIgY2FjaGVzID0gY2FjaGVzQnlMdmwuZ2V0KGx2bCk7XG4gICAgICBpZiAoIWNhY2hlcykge1xuICAgICAgICBjYWNoZXMgPSBuZXcgTWFwJDEoKTtcbiAgICAgICAgY2FjaGVzQnlMdmwuc2V0KGx2bCwgY2FjaGVzKTtcbiAgICAgICAgbHZscy5wdXNoKGx2bCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZShrZXksIGx2bCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5nZXQoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChlbGUsIGx2bCkge1xuICAgICAgdmFyIGtleSA9IHRoaXMuZ2V0S2V5KGVsZSk7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLmdldENhY2hlKGtleSwgbHZsKTtcblxuICAgICAgLy8gZ2V0dGluZyBmb3IgYW4gZWxlbWVudCBtYXkgbmVlZCB0byBhZGQgdG8gdGhlIGlkIGxpc3QgYi9jIGVsZXMgY2FuIHNoYXJlIGtleXNcbiAgICAgIGlmIChjYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JDYWNoZWRLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9yQ2FjaGVkS2V5KGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5rZXlGb3JJZC5nZXQoZWxlLmlkKCkpOyAvLyBuLmIuIHVzZSBjYWNoZWQga2V5LCBub3QgbmV3bHkgY29tcHV0ZWQga2V5XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLmdldENhY2hlKGtleSwgbHZsKTtcbiAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQ2FjaGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQ2FjaGUoa2V5LCBsdmwpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENhY2hlc0F0KGx2bCkuaGFzKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMoZWxlLCBsdmwpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldEtleShlbGUpO1xuICAgICAgcmV0dXJuIHRoaXMuaGFzQ2FjaGUoa2V5LCBsdmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYWNoZShrZXksIGx2bCwgY2FjaGUpIHtcbiAgICAgIGNhY2hlLmtleSA9IGtleTtcbiAgICAgIHRoaXMuZ2V0Q2FjaGVzQXQobHZsKS5zZXQoa2V5LCBjYWNoZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQoZWxlLCBsdmwsIGNhY2hlKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHRoaXMuc2V0Q2FjaGUoa2V5LCBsdmwsIGNhY2hlKTtcbiAgICAgIHRoaXMudXBkYXRlS2V5TWFwcGluZ0ZvcihlbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxldGVDYWNoZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxldGVDYWNoZShrZXksIGx2bCkge1xuICAgICAgdGhpcy5nZXRDYWNoZXNBdChsdmwpW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKGVsZSwgbHZsKSB7XG4gICAgICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgICAgIHRoaXMuZGVsZXRlQ2FjaGUoa2V5LCBsdmwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkYXRlS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGVLZXkoa2V5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5sdmxzLmZvckVhY2goZnVuY3Rpb24gKGx2bCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuZGVsZXRlQ2FjaGUoa2V5LCBsdmwpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyB0cnVlIGlmIG5vIG90aGVyIGVsZXMgcmVmZXJlbmNlIHRoZSBpbnZhbGlkYXRlZCBjYWNoZSAobi5iLiBvdGhlciBlbGVzIG1heSBuZWVkIHRoZSBjYWNoZSB3aXRoIHRoZSBzYW1lIGtleSlcbiAgfSwge1xuICAgIGtleTogXCJpbnZhbGlkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlKSB7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmtleUZvcklkLmdldChpZCk7IC8vIG4uYi4gdXNlIHN0b3JlZCBrZXkgcmF0aGVyIHRoYW4gY3VycmVudCAocG90ZW50aWFsIGtleSlcblxuICAgICAgdGhpcy5kZWxldGVLZXlNYXBwaW5nRm9yKGVsZSk7XG4gICAgICB2YXIgZW50aXJlS2V5SW52YWxpZGF0ZWQgPSB0aGlzLmRvZXNFbGVJbnZhbGlkYXRlS2V5KGVsZSk7XG4gICAgICBpZiAoZW50aXJlS2V5SW52YWxpZGF0ZWQpIHtcbiAgICAgICAgLy8gY2xlYXIgbWFwcGluZyBmb3IgY3VycmVudCBrZXlcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlS2V5KGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZW50aXJlS2V5SW52YWxpZGF0ZWQgfHwgdGhpcy5nZXROdW1iZXJPZklkc0ZvcktleShrZXkpID09PSAwO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgbWluVHhySCA9IDI1OyAvLyB0aGUgc2l6ZSBvZiB0aGUgdGV4dHVyZSBjYWNoZSBmb3Igc21hbGwgaGVpZ2h0IGVsZXMgKHNwZWNpYWwgY2FzZSlcbnZhciB0eHJTdGVwSCA9IDUwOyAvLyB0aGUgbWluIHNpemUgb2YgdGhlIHJlZ3VsYXIgY2FjaGUsIGFuZCB0aGUgc2l6ZSBpdCBpbmNyZWFzZXMgd2l0aCBlYWNoIHN0ZXAgdXBcbnZhciBtaW5MdmwkMSA9IC00OyAvLyB3aGVuIHNjYWxpbmcgc21hbGxlciB0aGFuIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byByZS1yZW5kZXJcbnZhciBtYXhMdmwkMSA9IDM7IC8vIHdoZW4gbGFyZ2VyIHRoYW4gdGhpcyBzY2FsZSBqdXN0IHJlbmRlciBkaXJlY3RseSAoY2FjaGluZyBpcyBub3QgaGVscGZ1bClcbnZhciBtYXhab29tJDEgPSA3Ljk5OyAvLyBiZXlvbmQgdGhpcyB6b29tIGxldmVsLCBsYXllcmVkIHRleHR1cmVzIGFyZSBub3QgdXNlZFxudmFyIGVsZVR4clNwYWNpbmcgPSA4OyAvLyBzcGFjaW5nIGJldHdlZW4gZWxlbWVudHMgb24gdGV4dHVyZXMgdG8gYXZvaWQgYmxpdHRpbmcgb3ZlcmxhcHNcbnZhciBkZWZUeHJXaWR0aCA9IDEwMjQ7IC8vIGRlZmF1bHQvbWluaW11bSB0ZXh0dXJlIHdpZHRoXG52YXIgbWF4VHhyVyA9IDEwMjQ7IC8vIHRoZSBtYXhpbXVtIHdpZHRoIG9mIGEgdGV4dHVyZVxudmFyIG1heFR4ckggPSAxMDI0OyAvLyB0aGUgbWF4aW11bSBoZWlnaHQgb2YgYSB0ZXh0dXJlXG52YXIgbWluVXRpbGl0eSA9IDAuMjsgLy8gaWYgdXNhZ2Ugb2YgdGV4dHVyZSBpcyBsZXNzIHRoYW4gdGhpcywgaXQgaXMgcmV0aXJlZFxudmFyIG1heEZ1bGxuZXNzID0gMC44OyAvLyBmdWxsbmVzcyBvZiB0ZXh0dXJlIGFmdGVyIHdoaWNoIHF1ZXVlIHJlbW92YWwgaXMgY2hlY2tlZFxudmFyIG1heEZ1bGxuZXNzQ2hlY2tzID0gMTA7IC8vIGRlcXVldWVkIGFmdGVyIHRoaXMgbWFueSBjaGVja3NcbnZhciBkZXFDb3N0JDEgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcbnZhciBkZXFBdmdDb3N0JDEgPSAwLjE7IC8vICUgb2YgYWRkJ2wgcmVuZGVyaW5nIGNvc3QgY29tcGFyZWQgdG8gYXZlcmFnZSBvdmVyYWxsIHJlZHJhdyB0aW1lXG52YXIgZGVxTm9EcmF3Q29zdCQxID0gMC45OyAvLyAlIG9mIGF2ZyBmcmFtZSB0aW1lIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRlcXVldWVpbmcgd2hlbiBub3QgZHJhd2luZ1xudmFyIGRlcUZhc3RDb3N0JDEgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG52YXIgZGVxUmVkcmF3VGhyZXNob2xkJDEgPSAxMDA7IC8vIHRpbWUgdG8gYmF0Y2ggcmVkcmF3cyB0b2dldGhlciBmcm9tIGRlcXVldWVpbmcgdG8gYWxsb3cgbW9yZSBkZXF1ZXVlaW5nIGNhbGNzIHRvIGhhcHBlbiBpbiB0aGUgbWVhbndoaWxlXG52YXIgbWF4RGVxU2l6ZSQxID0gMTsgLy8gbnVtYmVyIG9mIGVsZXMgdG8gZGVxdWV1ZSBhbmQgcmVuZGVyIGF0IGhpZ2hlciB0ZXh0dXJlIGluIGVhY2ggYmF0Y2hcblxudmFyIGdldFR4clJlYXNvbnMgPSB7XG4gIGRlcXVldWU6ICdkZXF1ZXVlJyxcbiAgZG93bnNjYWxlOiAnZG93bnNjYWxlJyxcbiAgaGlnaFF1YWxpdHk6ICdoaWdoUXVhbGl0eSdcbn07XG52YXIgaW5pdERlZmF1bHRzID0gZGVmYXVsdHMkZyh7XG4gIGdldEtleTogbnVsbCxcbiAgZG9lc0VsZUludmFsaWRhdGVLZXk6IGZhbHNpZnksXG4gIGRyYXdFbGVtZW50OiBudWxsLFxuICBnZXRCb3VuZGluZ0JveDogbnVsbCxcbiAgZ2V0Um90YXRpb25Qb2ludDogbnVsbCxcbiAgZ2V0Um90YXRpb25PZmZzZXQ6IG51bGwsXG4gIGlzVmlzaWJsZTogdHJ1ZWlmeSxcbiAgYWxsb3dFZGdlVHhyQ2FjaGluZzogdHJ1ZSxcbiAgYWxsb3dQYXJlbnRUeHJDYWNoaW5nOiB0cnVlXG59KTtcbnZhciBFbGVtZW50VGV4dHVyZUNhY2hlID0gZnVuY3Rpb24gRWxlbWVudFRleHR1cmVDYWNoZShyZW5kZXJlciwgaW5pdE9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIHNlbGYub25EZXF1ZXVlcyA9IFtdO1xuICB2YXIgb3B0cyA9IGluaXREZWZhdWx0cyhpbml0T3B0aW9ucyk7XG4gIGV4dGVuZChzZWxmLCBvcHRzKTtcbiAgc2VsZi5sb29rdXAgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZUxvb2t1cChvcHRzLmdldEtleSwgb3B0cy5kb2VzRWxlSW52YWxpZGF0ZUtleSk7XG4gIHNlbGYuc2V0dXBEZXF1ZXVlaW5nKCk7XG59O1xudmFyIEVUQ3AgPSBFbGVtZW50VGV4dHVyZUNhY2hlLnByb3RvdHlwZTtcbkVUQ3AucmVhc29ucyA9IGdldFR4clJlYXNvbnM7XG5cbi8vIHRoZSBsaXN0IG9mIHRleHR1cmVzIGluIHdoaWNoIG5ldyBzdWJ0ZXh0dXJlcyBmb3IgZWxlbWVudHMgY2FuIGJlIHBsYWNlZFxuRVRDcC5nZXRUZXh0dXJlUXVldWUgPSBmdW5jdGlvbiAodHhySCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWxlSW1nQ2FjaGVzID0gc2VsZi5lbGVJbWdDYWNoZXMgfHwge307XG4gIHJldHVybiBzZWxmLmVsZUltZ0NhY2hlc1t0eHJIXSA9IHNlbGYuZWxlSW1nQ2FjaGVzW3R4ckhdIHx8IFtdO1xufTtcblxuLy8gdGhlIGxpc3Qgb2YgdXN1c2VkIHRleHR1cmVzIHdoaWNoIGNhbiBiZSByZWN5Y2xlZCAoaW4gdXNlIGluIHRleHR1cmUgcXVldWUpXG5FVENwLmdldFJldGlyZWRUZXh0dXJlUXVldWUgPSBmdW5jdGlvbiAodHhySCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBydHh0clFzID0gc2VsZi5lbGVJbWdDYWNoZXMucmV0aXJlZCA9IHNlbGYuZWxlSW1nQ2FjaGVzLnJldGlyZWQgfHwge307XG4gIHZhciBydHh0clEgPSBydHh0clFzW3R4ckhdID0gcnR4dHJRc1t0eHJIXSB8fCBbXTtcbiAgcmV0dXJuIHJ0eHRyUTtcbn07XG5cbi8vIHF1ZXVlIG9mIGVsZW1lbnQgZHJhdyByZXF1ZXN0cyBhdCBkaWZmZXJlbnQgc2NhbGUgbGV2ZWxzXG5FVENwLmdldEVsZW1lbnRRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSA9IHNlbGYuZWxlQ2FjaGVRdWV1ZSB8fCBuZXcgSGVhcChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLnJlcXMgLSBhLnJlcXM7XG4gIH0pO1xuICByZXR1cm4gcTtcbn07XG5cbi8vIHF1ZXVlIG9mIGVsZW1lbnQgZHJhdyByZXF1ZXN0cyBhdCBkaWZmZXJlbnQgc2NhbGUgbGV2ZWxzIChlbGVtZW50IGlkIGxvb2t1cClcbkVUQ3AuZ2V0RWxlbWVudEtleVRvUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGsycSA9IHNlbGYuZWxlS2V5VG9DYWNoZVF1ZXVlID0gc2VsZi5lbGVLZXlUb0NhY2hlUXVldWUgfHwge307XG4gIHJldHVybiBrMnE7XG59O1xuRVRDcC5nZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSwgYmIsIHB4UmF0aW8sIGx2bCwgcmVhc29uKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSB0aGlzLnJlbmRlcmVyO1xuICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICB2YXIgbG9va3VwID0gdGhpcy5sb29rdXA7XG4gIGlmICghYmIgfHwgYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8IGlzTmFOKGJiLncpIHx8IGlzTmFOKGJiLmgpIHx8ICFlbGUudmlzaWJsZSgpIHx8IGVsZS5yZW1vdmVkKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIXNlbGYuYWxsb3dFZGdlVHhyQ2FjaGluZyAmJiBlbGUuaXNFZGdlKCkgfHwgIXNlbGYuYWxsb3dQYXJlbnRUeHJDYWNoaW5nICYmIGVsZS5pc1BhcmVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGx2bCA9PSBudWxsKSB7XG4gICAgbHZsID0gTWF0aC5jZWlsKGxvZzIoem9vbSAqIHB4UmF0aW8pKTtcbiAgfVxuICBpZiAobHZsIDwgbWluTHZsJDEpIHtcbiAgICBsdmwgPSBtaW5MdmwkMTtcbiAgfSBlbHNlIGlmICh6b29tID49IG1heFpvb20kMSB8fCBsdmwgPiBtYXhMdmwkMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBzY2FsZSA9IE1hdGgucG93KDIsIGx2bCk7XG4gIHZhciBlbGVTY2FsZWRIID0gYmIuaCAqIHNjYWxlO1xuICB2YXIgZWxlU2NhbGVkVyA9IGJiLncgKiBzY2FsZTtcbiAgdmFyIHNjYWxlZExhYmVsU2hvd24gPSByLmVsZVRleHRCaWdnZXJUaGFuTWluKGVsZSwgc2NhbGUpO1xuICBpZiAoIXRoaXMuaXNWaXNpYmxlKGVsZSwgc2NhbGVkTGFiZWxTaG93bikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgZWxlQ2FjaGUgPSBsb29rdXAuZ2V0KGVsZSwgbHZsKTtcblxuICAvLyBpZiB0aGlzIGdldCB3YXMgb24gYW4gdW51c2VkL2ludmFsaWRhdGVkIGNhY2hlLCB0aGVuIHJlc3RvcmUgdGhlIHRleHR1cmUgdXNhZ2UgbWV0cmljXG4gIGlmIChlbGVDYWNoZSAmJiBlbGVDYWNoZS5pbnZhbGlkYXRlZCkge1xuICAgIGVsZUNhY2hlLmludmFsaWRhdGVkID0gZmFsc2U7XG4gICAgZWxlQ2FjaGUudGV4dHVyZS5pbnZhbGlkYXRlZFdpZHRoIC09IGVsZUNhY2hlLndpZHRoO1xuICB9XG4gIGlmIChlbGVDYWNoZSkge1xuICAgIHJldHVybiBlbGVDYWNoZTtcbiAgfVxuICB2YXIgdHhySDsgLy8gd2hpY2ggdGV4dHVyZSBoZWlnaHQgdGhpcyBlbGUgYmVsb25ncyB0b1xuXG4gIGlmIChlbGVTY2FsZWRIIDw9IG1pblR4ckgpIHtcbiAgICB0eHJIID0gbWluVHhySDtcbiAgfSBlbHNlIGlmIChlbGVTY2FsZWRIIDw9IHR4clN0ZXBIKSB7XG4gICAgdHhySCA9IHR4clN0ZXBIO1xuICB9IGVsc2Uge1xuICAgIHR4ckggPSBNYXRoLmNlaWwoZWxlU2NhbGVkSCAvIHR4clN0ZXBIKSAqIHR4clN0ZXBIO1xuICB9XG4gIGlmIChlbGVTY2FsZWRIID4gbWF4VHhySCB8fCBlbGVTY2FsZWRXID4gbWF4VHhyVykge1xuICAgIHJldHVybiBudWxsOyAvLyBjYWNoaW5nIGxhcmdlIGVsZW1lbnRzIGlzIG5vdCBlZmZpY2llbnRcbiAgfVxuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuXG4gIC8vIGZpcnN0IHRyeSB0aGUgc2Vjb25kIGxhc3Qgb25lIGluIGNhc2UgaXQgaGFzIHNwYWNlIGF0IHRoZSBlbmRcbiAgdmFyIHR4ciA9IHR4clFbdHhyUS5sZW5ndGggLSAyXTtcbiAgdmFyIGFkZE5ld1R4ciA9IGZ1bmN0aW9uIGFkZE5ld1R4cigpIHtcbiAgICByZXR1cm4gc2VsZi5yZWN5Y2xlVGV4dHVyZSh0eHJILCBlbGVTY2FsZWRXKSB8fCBzZWxmLmFkZFRleHR1cmUodHhySCwgZWxlU2NhbGVkVyk7XG4gIH07XG5cbiAgLy8gdHJ5IHRoZSBsYXN0IG9uZSBpZiB0aGVyZSBpcyBubyBzZWNvbmQgbGFzdCBvbmVcbiAgaWYgKCF0eHIpIHtcbiAgICB0eHIgPSB0eHJRW3R4clEubGVuZ3RoIC0gMV07XG4gIH1cblxuICAvLyBpZiB0aGUgbGFzdCBvbmUgZG9lc24ndCBleGlzdCwgd2UgbmVlZCBhIGZpcnN0IG9uZVxuICBpZiAoIXR4cikge1xuICAgIHR4ciA9IGFkZE5ld1R4cigpO1xuICB9XG5cbiAgLy8gaWYgdGhlcmUncyBubyByb29tIGluIHRoZSBjdXJyZW50IHRleHR1cmUsIHdlIG5lZWQgYSBuZXcgb25lXG4gIGlmICh0eHIud2lkdGggLSB0eHIudXNlZFdpZHRoIDwgZWxlU2NhbGVkVykge1xuICAgIHR4ciA9IGFkZE5ld1R4cigpO1xuICB9XG4gIHZhciBzY2FsYWJsZUZyb20gPSBmdW5jdGlvbiBzY2FsYWJsZUZyb20ob3RoZXJDYWNoZSkge1xuICAgIHJldHVybiBvdGhlckNhY2hlICYmIG90aGVyQ2FjaGUuc2NhbGVkTGFiZWxTaG93biA9PT0gc2NhbGVkTGFiZWxTaG93bjtcbiAgfTtcbiAgdmFyIGRlcWluZyA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZGVxdWV1ZTtcbiAgdmFyIGhpZ2hRdWFsaXR5UmVxID0gcmVhc29uICYmIHJlYXNvbiA9PT0gZ2V0VHhyUmVhc29ucy5oaWdoUXVhbGl0eTtcbiAgdmFyIGRvd25zY2FsZVJlcSA9IHJlYXNvbiAmJiByZWFzb24gPT09IGdldFR4clJlYXNvbnMuZG93bnNjYWxlO1xuICB2YXIgaGlnaGVyQ2FjaGU7IC8vIHRoZSBuZWFyZXN0IGNhY2hlIHdpdGggYSBoaWdoZXIgbGV2ZWxcbiAgZm9yICh2YXIgbCA9IGx2bCArIDE7IGwgPD0gbWF4THZsJDE7IGwrKykge1xuICAgIHZhciBjID0gbG9va3VwLmdldChlbGUsIGwpO1xuICAgIGlmIChjKSB7XG4gICAgICBoaWdoZXJDYWNoZSA9IGM7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdmFyIG9uZVVwQ2FjaGUgPSBoaWdoZXJDYWNoZSAmJiBoaWdoZXJDYWNoZS5sZXZlbCA9PT0gbHZsICsgMSA/IGhpZ2hlckNhY2hlIDogbnVsbDtcbiAgdmFyIGRvd25zY2FsZSA9IGZ1bmN0aW9uIGRvd25zY2FsZSgpIHtcbiAgICB0eHIuY29udGV4dC5kcmF3SW1hZ2Uob25lVXBDYWNoZS50ZXh0dXJlLmNhbnZhcywgb25lVXBDYWNoZS54LCAwLCBvbmVVcENhY2hlLndpZHRoLCBvbmVVcENhY2hlLmhlaWdodCwgdHhyLnVzZWRXaWR0aCwgMCwgZWxlU2NhbGVkVywgZWxlU2NhbGVkSCk7XG4gIH07XG5cbiAgLy8gcmVzZXQgZWxlIGFyZWEgaW4gdGV4dHVyZVxuICB0eHIuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIHR4ci5jb250ZXh0LmNsZWFyUmVjdCh0eHIudXNlZFdpZHRoLCAwLCBlbGVTY2FsZWRXLCB0eHJIKTtcbiAgaWYgKHNjYWxhYmxlRnJvbShvbmVVcENhY2hlKSkge1xuICAgIC8vIHRoZW4gd2UgY2FuIHJlbGF0aXZlbHkgY2hlYXBseSByZXNjYWxlIHRoZSBleGlzdGluZyBpbWFnZSB3L28gcmVyZW5kZXJpbmdcbiAgICBkb3duc2NhbGUoKTtcbiAgfSBlbHNlIGlmIChzY2FsYWJsZUZyb20oaGlnaGVyQ2FjaGUpKSB7XG4gICAgLy8gdGhlbiB1c2UgdGhlIGhpZ2hlciBjYWNoZSBmb3Igbm93IGFuZCBxdWV1ZSB0aGUgbmV4dCBsZXZlbCBkb3duXG4gICAgLy8gdG8gY2hlYXBseSBzY2FsZSB0b3dhcmRzIHRoZSBzbWFsbGVyIGxldmVsXG5cbiAgICBpZiAoaGlnaFF1YWxpdHlSZXEpIHtcbiAgICAgIGZvciAodmFyIF9sID0gaGlnaGVyQ2FjaGUubGV2ZWw7IF9sID4gbHZsOyBfbC0tKSB7XG4gICAgICAgIG9uZVVwQ2FjaGUgPSBzZWxmLmdldEVsZW1lbnQoZWxlLCBiYiwgcHhSYXRpbywgX2wsIGdldFR4clJlYXNvbnMuZG93bnNjYWxlKTtcbiAgICAgIH1cbiAgICAgIGRvd25zY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGhpZ2hlckNhY2hlLmxldmVsIC0gMSk7XG4gICAgICByZXR1cm4gaGlnaGVyQ2FjaGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dlckNhY2hlOyAvLyB0aGUgbmVhcmVzdCBjYWNoZSB3aXRoIGEgbG93ZXIgbGV2ZWxcbiAgICBpZiAoIWRlcWluZyAmJiAhaGlnaFF1YWxpdHlSZXEgJiYgIWRvd25zY2FsZVJlcSkge1xuICAgICAgZm9yICh2YXIgX2wyID0gbHZsIC0gMTsgX2wyID49IG1pbkx2bCQxOyBfbDItLSkge1xuICAgICAgICB2YXIgX2MgPSBsb29rdXAuZ2V0KGVsZSwgX2wyKTtcbiAgICAgICAgaWYgKF9jKSB7XG4gICAgICAgICAgbG93ZXJDYWNoZSA9IF9jO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzY2FsYWJsZUZyb20obG93ZXJDYWNoZSkpIHtcbiAgICAgIC8vIHRoZW4gdXNlIHRoZSBsb3dlciBxdWFsaXR5IGNhY2hlIGZvciBub3cgYW5kIHF1ZXVlIHRoZSBiZXR0ZXIgb25lIGZvciBsYXRlclxuXG4gICAgICBzZWxmLnF1ZXVlRWxlbWVudChlbGUsIGx2bCk7XG4gICAgICByZXR1cm4gbG93ZXJDYWNoZTtcbiAgICB9XG4gICAgdHhyLmNvbnRleHQudHJhbnNsYXRlKHR4ci51c2VkV2lkdGgsIDApO1xuICAgIHR4ci5jb250ZXh0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgdGhpcy5kcmF3RWxlbWVudCh0eHIuY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgZmFsc2UpO1xuICAgIHR4ci5jb250ZXh0LnNjYWxlKDEgLyBzY2FsZSwgMSAvIHNjYWxlKTtcbiAgICB0eHIuY29udGV4dC50cmFuc2xhdGUoLXR4ci51c2VkV2lkdGgsIDApO1xuICB9XG4gIGVsZUNhY2hlID0ge1xuICAgIHg6IHR4ci51c2VkV2lkdGgsXG4gICAgdGV4dHVyZTogdHhyLFxuICAgIGxldmVsOiBsdmwsXG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIHdpZHRoOiBlbGVTY2FsZWRXLFxuICAgIGhlaWdodDogZWxlU2NhbGVkSCxcbiAgICBzY2FsZWRMYWJlbFNob3duOiBzY2FsZWRMYWJlbFNob3duXG4gIH07XG4gIHR4ci51c2VkV2lkdGggKz0gTWF0aC5jZWlsKGVsZVNjYWxlZFcgKyBlbGVUeHJTcGFjaW5nKTtcbiAgdHhyLmVsZUNhY2hlcy5wdXNoKGVsZUNhY2hlKTtcbiAgbG9va3VwLnNldChlbGUsIGx2bCwgZWxlQ2FjaGUpO1xuICBzZWxmLmNoZWNrVGV4dHVyZUZ1bGxuZXNzKHR4cik7XG4gIHJldHVybiBlbGVDYWNoZTtcbn07XG5FVENwLmludmFsaWRhdGVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuaW52YWxpZGF0ZUVsZW1lbnQoZWxlc1tpXSk7XG4gIH1cbn07XG5FVENwLmludmFsaWRhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsb29rdXAgPSBzZWxmLmxvb2t1cDtcbiAgdmFyIGNhY2hlcyA9IFtdO1xuICB2YXIgaW52YWxpZCA9IGxvb2t1cC5pc0ludmFsaWQoZWxlKTtcbiAgaWYgKCFpbnZhbGlkKSB7XG4gICAgcmV0dXJuOyAvLyBvdmVycmlkZSB0aGUgaW52YWxpZGF0aW9uIHJlcXVlc3QgaWYgdGhlIGVsZW1lbnQga2V5IGhhcyBub3QgY2hhbmdlZFxuICB9XG4gIGZvciAodmFyIGx2bCA9IG1pbkx2bCQxOyBsdmwgPD0gbWF4THZsJDE7IGx2bCsrKSB7XG4gICAgdmFyIGNhY2hlID0gbG9va3VwLmdldEZvckNhY2hlZEtleShlbGUsIGx2bCk7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICBjYWNoZXMucHVzaChjYWNoZSk7XG4gICAgfVxuICB9XG4gIHZhciBub090aGVyRWxlc1VzZUNhY2hlID0gbG9va3VwLmludmFsaWRhdGUoZWxlKTtcbiAgaWYgKG5vT3RoZXJFbGVzVXNlQ2FjaGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9jYWNoZSA9IGNhY2hlc1tpXTtcbiAgICAgIHZhciB0eHIgPSBfY2FjaGUudGV4dHVyZTtcblxuICAgICAgLy8gcmVtb3ZlIHNwYWNlIGZyb20gdGhlIHRleHR1cmUgaXQgYmVsb25ncyB0b1xuICAgICAgdHhyLmludmFsaWRhdGVkV2lkdGggKz0gX2NhY2hlLndpZHRoO1xuXG4gICAgICAvLyBtYXJrIHRoZSBjYWNoZSBhcyBpbnZhbGlkYXRlZFxuICAgICAgX2NhY2hlLmludmFsaWRhdGVkID0gdHJ1ZTtcblxuICAgICAgLy8gcmV0aXJlIHRoZSB0ZXh0dXJlIGlmIGl0cyB1dGlsaXR5IGlzIGxvd1xuICAgICAgc2VsZi5jaGVja1RleHR1cmVVdGlsaXR5KHR4cik7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVtb3ZlIGZyb20gcXVldWUgc2luY2UgdGhlIG9sZCByZXEgd2FzIGZvciB0aGUgb2xkIHN0YXRlXG4gIHNlbGYucmVtb3ZlRnJvbVF1ZXVlKGVsZSk7XG59O1xuRVRDcC5jaGVja1RleHR1cmVVdGlsaXR5ID0gZnVuY3Rpb24gKHR4cikge1xuICAvLyBpbnZhbGlkYXRlIGFsbCBlbnRyaWVzIGluIHRoZSBjYWNoZSBpZiB0aGUgY2FjaGUgc2l6ZSBpcyBzbWFsbFxuICBpZiAodHhyLmludmFsaWRhdGVkV2lkdGggPj0gbWluVXRpbGl0eSAqIHR4ci53aWR0aCkge1xuICAgIHRoaXMucmV0aXJlVGV4dHVyZSh0eHIpO1xuICB9XG59O1xuRVRDcC5jaGVja1RleHR1cmVGdWxsbmVzcyA9IGZ1bmN0aW9uICh0eHIpIHtcbiAgLy8gaWYgdGV4dHVyZSBoYXMgYmVlbiBtb3N0bHkgZmlsbGVkIGFuZCBwYXNzZWQgb3ZlciBzZXZlcmFsIHRpbWVzLCByZW1vdmVcbiAgLy8gaXQgZnJvbSB0aGUgcXVldWUgc28gd2UgZG9uJ3QgbmVlZCB0byB3YXN0ZSB0aW1lIGxvb2tpbmcgYXQgaXQgdG8gcHV0IG5ldyB0aGluZ3NcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhyLmhlaWdodCk7XG4gIGlmICh0eHIudXNlZFdpZHRoIC8gdHhyLndpZHRoID4gbWF4RnVsbG5lc3MgJiYgdHhyLmZ1bGxuZXNzQ2hlY2tzID49IG1heEZ1bGxuZXNzQ2hlY2tzKSB7XG4gICAgcmVtb3ZlRnJvbUFycmF5KHR4clEsIHR4cik7XG4gIH0gZWxzZSB7XG4gICAgdHhyLmZ1bGxuZXNzQ2hlY2tzKys7XG4gIH1cbn07XG5FVENwLnJldGlyZVRleHR1cmUgPSBmdW5jdGlvbiAodHhyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4ckggPSB0eHIuaGVpZ2h0O1xuICB2YXIgdHhyUSA9IHNlbGYuZ2V0VGV4dHVyZVF1ZXVlKHR4ckgpO1xuICB2YXIgbG9va3VwID0gdGhpcy5sb29rdXA7XG5cbiAgLy8gcmV0aXJlIHRoZSB0ZXh0dXJlIGZyb20gdGhlIGFjdGl2ZSAvIHNlYXJjaGFibGUgcXVldWU6XG5cbiAgcmVtb3ZlRnJvbUFycmF5KHR4clEsIHR4cik7XG4gIHR4ci5yZXRpcmVkID0gdHJ1ZTtcblxuICAvLyByZW1vdmUgdGhlIHJlZnMgZnJvbSB0aGUgZWxlcyB0byB0aGUgY2FjaGVzOlxuXG4gIHZhciBlbGVDYWNoZXMgPSB0eHIuZWxlQ2FjaGVzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZUNhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGVDYWNoZSA9IGVsZUNhY2hlc1tpXTtcbiAgICBsb29rdXAuZGVsZXRlQ2FjaGUoZWxlQ2FjaGUua2V5LCBlbGVDYWNoZS5sZXZlbCk7XG4gIH1cbiAgY2xlYXJBcnJheShlbGVDYWNoZXMpO1xuXG4gIC8vIGFkZCB0aGUgdGV4dHVyZSB0byBhIHJldGlyZWQgcXVldWUgc28gaXQgY2FuIGJlIHJlY3ljbGVkIGluIGZ1dHVyZTpcblxuICB2YXIgcnR4dHJRID0gc2VsZi5nZXRSZXRpcmVkVGV4dHVyZVF1ZXVlKHR4ckgpO1xuICBydHh0clEucHVzaCh0eHIpO1xufTtcbkVUQ3AuYWRkVGV4dHVyZSA9IGZ1bmN0aW9uICh0eHJILCBtaW5XKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR4clEgPSBzZWxmLmdldFRleHR1cmVRdWV1ZSh0eHJIKTtcbiAgdmFyIHR4ciA9IHt9O1xuICB0eHJRLnB1c2godHhyKTtcbiAgdHhyLmVsZUNhY2hlcyA9IFtdO1xuICB0eHIuaGVpZ2h0ID0gdHhySDtcbiAgdHhyLndpZHRoID0gTWF0aC5tYXgoZGVmVHhyV2lkdGgsIG1pblcpO1xuICB0eHIudXNlZFdpZHRoID0gMDtcbiAgdHhyLmludmFsaWRhdGVkV2lkdGggPSAwO1xuICB0eHIuZnVsbG5lc3NDaGVja3MgPSAwO1xuICB0eHIuY2FudmFzID0gc2VsZi5yZW5kZXJlci5tYWtlT2Zmc2NyZWVuQ2FudmFzKHR4ci53aWR0aCwgdHhyLmhlaWdodCk7XG4gIHR4ci5jb250ZXh0ID0gdHhyLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICByZXR1cm4gdHhyO1xufTtcbkVUQ3AucmVjeWNsZVRleHR1cmUgPSBmdW5jdGlvbiAodHhySCwgbWluVykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0eHJRID0gc2VsZi5nZXRUZXh0dXJlUXVldWUodHhySCk7XG4gIHZhciBydHh0clEgPSBzZWxmLmdldFJldGlyZWRUZXh0dXJlUXVldWUodHhySCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnR4dHJRLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR4ciA9IHJ0eHRyUVtpXTtcbiAgICBpZiAodHhyLndpZHRoID49IG1pblcpIHtcbiAgICAgIHR4ci5yZXRpcmVkID0gZmFsc2U7XG4gICAgICB0eHIudXNlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5pbnZhbGlkYXRlZFdpZHRoID0gMDtcbiAgICAgIHR4ci5mdWxsbmVzc0NoZWNrcyA9IDA7XG4gICAgICBjbGVhckFycmF5KHR4ci5lbGVDYWNoZXMpO1xuICAgICAgdHhyLmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdHhyLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHR4ci53aWR0aCwgdHhyLmhlaWdodCk7XG4gICAgICByZW1vdmVGcm9tQXJyYXkocnR4dHJRLCB0eHIpO1xuICAgICAgdHhyUS5wdXNoKHR4cik7XG4gICAgICByZXR1cm4gdHhyO1xuICAgIH1cbiAgfVxufTtcbkVUQ3AucXVldWVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZSwgbHZsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgdmFyIGV4aXN0aW5nUmVxID0gazJxW2tleV07XG4gIGlmIChleGlzdGluZ1JlcSkge1xuICAgIC8vIHVzZSB0aGUgbWF4IGx2bCBiL2MgaW4gYmV0d2VlbiBsdmxzIGFyZSBjaGVhcCB0byBtYWtlXG4gICAgZXhpc3RpbmdSZXEubGV2ZWwgPSBNYXRoLm1heChleGlzdGluZ1JlcS5sZXZlbCwgbHZsKTtcbiAgICBleGlzdGluZ1JlcS5lbGVzLm1lcmdlKGVsZSk7XG4gICAgZXhpc3RpbmdSZXEucmVxcysrO1xuICAgIHEudXBkYXRlSXRlbShleGlzdGluZ1JlcSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlcSA9IHtcbiAgICAgIGVsZXM6IGVsZS5zcGF3bigpLm1lcmdlKGVsZSksXG4gICAgICBsZXZlbDogbHZsLFxuICAgICAgcmVxczogMSxcbiAgICAgIGtleToga2V5XG4gICAgfTtcbiAgICBxLnB1c2gocmVxKTtcbiAgICBrMnFba2V5XSA9IHJlcTtcbiAgfVxufTtcbkVUQ3AuZGVxdWV1ZSA9IGZ1bmN0aW9uIChweFJhdGlvIC8qLCBleHRlbnQqLykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5nZXRFbGVtZW50UXVldWUoKTtcbiAgdmFyIGsycSA9IHNlbGYuZ2V0RWxlbWVudEtleVRvUXVldWUoKTtcbiAgdmFyIGRlcXVldWVkID0gW107XG4gIHZhciBsb29rdXAgPSBzZWxmLmxvb2t1cDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhEZXFTaXplJDE7IGkrKykge1xuICAgIGlmIChxLnNpemUoKSA+IDApIHtcbiAgICAgIHZhciByZXEgPSBxLnBvcCgpO1xuICAgICAgdmFyIGtleSA9IHJlcS5rZXk7XG4gICAgICB2YXIgZWxlID0gcmVxLmVsZXNbMF07IC8vIGFsbCBlbGVzIGhhdmUgdGhlIHNhbWUga2V5XG4gICAgICB2YXIgY2FjaGVFeGlzdHMgPSBsb29rdXAuaGFzQ2FjaGUoZWxlLCByZXEubGV2ZWwpO1xuXG4gICAgICAvLyBjbGVhciBvdXQgdGhlIGtleSB0byByZXEgbG9va3VwXG4gICAgICBrMnFba2V5XSA9IG51bGw7XG5cbiAgICAgIC8vIGRlcXVldWVpbmcgaXNuJ3QgbmVjZXNzYXJ5IHdpdGggYW4gZXhpc3RpbmcgY2FjaGVcbiAgICAgIGlmIChjYWNoZUV4aXN0cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRlcXVldWVkLnB1c2gocmVxKTtcbiAgICAgIHZhciBiYiA9IHNlbGYuZ2V0Qm91bmRpbmdCb3goZWxlKTtcbiAgICAgIHNlbGYuZ2V0RWxlbWVudChlbGUsIGJiLCBweFJhdGlvLCByZXEubGV2ZWwsIGdldFR4clJlYXNvbnMuZGVxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVxdWV1ZWQ7XG59O1xuRVRDcC5yZW1vdmVGcm9tUXVldWUgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHEgPSBzZWxmLmdldEVsZW1lbnRRdWV1ZSgpO1xuICB2YXIgazJxID0gc2VsZi5nZXRFbGVtZW50S2V5VG9RdWV1ZSgpO1xuICB2YXIga2V5ID0gdGhpcy5nZXRLZXkoZWxlKTtcbiAgdmFyIHJlcSA9IGsycVtrZXldO1xuICBpZiAocmVxICE9IG51bGwpIHtcbiAgICBpZiAocmVxLmVsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyByZW1vdmUgaWYgbGFzdCBlbGUgaW4gdGhlIHJlcVxuICAgICAgLy8gYnJpbmcgdG8gZnJvbnQgb2YgcXVldWVcbiAgICAgIHJlcS5yZXFzID0gTUFYX0lOVCQxO1xuICAgICAgcS51cGRhdGVJdGVtKHJlcSk7XG4gICAgICBxLnBvcCgpOyAvLyByZW1vdmUgZnJvbSBxdWV1ZVxuXG4gICAgICBrMnFba2V5XSA9IG51bGw7IC8vIHJlbW92ZSBmcm9tIGxvb2t1cCBtYXBcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgcmVtb3ZlIGVsZSBmcm9tIHJlcVxuICAgICAgcmVxLmVsZXMudW5tZXJnZShlbGUpO1xuICAgIH1cbiAgfVxufTtcbkVUQ3Aub25EZXF1ZXVlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHRoaXMub25EZXF1ZXVlcy5wdXNoKGZuKTtcbn07XG5FVENwLm9mZkRlcXVldWUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmVtb3ZlRnJvbUFycmF5KHRoaXMub25EZXF1ZXVlcywgZm4pO1xufTtcbkVUQ3Auc2V0dXBEZXF1ZXVlaW5nID0gZGVmcy5zZXR1cERlcXVldWVpbmcoe1xuICBkZXFSZWRyYXdUaHJlc2hvbGQ6IGRlcVJlZHJhd1RocmVzaG9sZCQxLFxuICBkZXFDb3N0OiBkZXFDb3N0JDEsXG4gIGRlcUF2Z0Nvc3Q6IGRlcUF2Z0Nvc3QkMSxcbiAgZGVxTm9EcmF3Q29zdDogZGVxTm9EcmF3Q29zdCQxLFxuICBkZXFGYXN0Q29zdDogZGVxRmFzdENvc3QkMSxcbiAgZGVxOiBmdW5jdGlvbiBkZXEoc2VsZiwgcHhSYXRpbywgZXh0ZW50KSB7XG4gICAgcmV0dXJuIHNlbGYuZGVxdWV1ZShweFJhdGlvLCBleHRlbnQpO1xuICB9LFxuICBvbkRlcWQ6IGZ1bmN0aW9uIG9uRGVxZChzZWxmLCBkZXFkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLm9uRGVxdWV1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmbiA9IHNlbGYub25EZXF1ZXVlc1tpXTtcbiAgICAgIGZuKGRlcWQpO1xuICAgIH1cbiAgfSxcbiAgc2hvdWxkUmVkcmF3OiBmdW5jdGlvbiBzaG91bGRSZWRyYXcoc2VsZiwgZGVxZCwgcHhSYXRpbywgZXh0ZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXFkLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWxlcyA9IGRlcWRbaV0uZWxlcztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgYmIgPSBlbGVzW2pdLmJvdW5kaW5nQm94KCk7XG4gICAgICAgIGlmIChib3VuZGluZ0JveGVzSW50ZXJzZWN0KGJiLCBleHRlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBwcmlvcml0eTogZnVuY3Rpb24gcHJpb3JpdHkoc2VsZikge1xuICAgIHJldHVybiBzZWxmLnJlbmRlcmVyLmJlZm9yZVJlbmRlclByaW9yaXRpZXMuZWxlVHhyRGVxO1xuICB9XG59KTtcblxudmFyIGRlZk51bUxheWVycyA9IDE7IC8vIGRlZmF1bHQgbnVtYmVyIG9mIGxheWVycyB0byB1c2VcbnZhciBtaW5MdmwgPSAtNDsgLy8gd2hlbiBzY2FsaW5nIHNtYWxsZXIgdGhhbiB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcmUtcmVuZGVyXG52YXIgbWF4THZsID0gMjsgLy8gd2hlbiBsYXJnZXIgdGhhbiB0aGlzIHNjYWxlIGp1c3QgcmVuZGVyIGRpcmVjdGx5IChjYWNoaW5nIGlzIG5vdCBoZWxwZnVsKVxudmFyIG1heFpvb20gPSAzLjk5OyAvLyBiZXlvbmQgdGhpcyB6b29tIGxldmVsLCBsYXllcmVkIHRleHR1cmVzIGFyZSBub3QgdXNlZFxudmFyIGRlcVJlZHJhd1RocmVzaG9sZCA9IDUwOyAvLyB0aW1lIHRvIGJhdGNoIHJlZHJhd3MgdG9nZXRoZXIgZnJvbSBkZXF1ZXVlaW5nIHRvIGFsbG93IG1vcmUgZGVxdWV1ZWluZyBjYWxjcyB0byBoYXBwZW4gaW4gdGhlIG1lYW53aGlsZVxudmFyIHJlZmluZUVsZURlYm91bmNlVGltZSA9IDUwOyAvLyB0aW1lIHRvIGRlYm91bmNlIHNoYXJwZXIgZWxlIHRleHR1cmUgdXBkYXRlc1xudmFyIGRlcUNvc3QgPSAwLjE1OyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGFsbG93ZWQgZm9yIGRlcXVldWluZyBlbGUgY2FjaGVzIGVhY2ggZnJhbWVcbnZhciBkZXFBdmdDb3N0ID0gMC4xOyAvLyAlIG9mIGFkZCdsIHJlbmRlcmluZyBjb3N0IGNvbXBhcmVkIHRvIGF2ZXJhZ2Ugb3ZlcmFsbCByZWRyYXcgdGltZVxudmFyIGRlcU5vRHJhd0Nvc3QgPSAwLjk7IC8vICUgb2YgYXZnIGZyYW1lIHRpbWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZGVxdWV1ZWluZyB3aGVuIG5vdCBkcmF3aW5nXG52YXIgZGVxRmFzdENvc3QgPSAwLjk7IC8vICUgb2YgZnJhbWUgdGltZSB0byBiZSB1c2VkIHdoZW4gPjYwZnBzXG52YXIgbWF4RGVxU2l6ZSA9IDE7IC8vIG51bWJlciBvZiBlbGVzIHRvIGRlcXVldWUgYW5kIHJlbmRlciBhdCBoaWdoZXIgdGV4dHVyZSBpbiBlYWNoIGJhdGNoXG52YXIgaW52YWxpZFRocmVzaG9sZCA9IDI1MDsgLy8gdGltZSB0aHJlc2hvbGQgZm9yIGRpc2FibGluZyBiL2Mgb2YgaW52YWxpZGF0aW9uc1xudmFyIG1heExheWVyQXJlYSA9IDQwMDAgKiA0MDAwOyAvLyBsYXllcnMgY2FuJ3QgYmUgYmlnZ2VyIHRoYW4gdGhpc1xudmFyIG1heExheWVyRGltID0gMzI3Njc7IC8vIG1heGltdW0gc2l6ZSBmb3IgdGhlIHdpZHRoL2hlaWdodCBvZiBsYXllciBjYW52YXNlc1xudmFyIHVzZUhpZ2hRdWFsaXR5RWxlVHhyUmVxcyA9IHRydWU7IC8vIHdoZXRoZXIgdG8gdXNlIGhpZ2ggcXVhbGl0eSBlbGUgdHhyIHJlcXVlc3RzIChnZW5lcmFsbHkgZmFzdGVyIGFuZCBjaGVhcGVyIGluIHRoZSBsb25ndGVybSlcblxuLy8gdmFyIGxvZyA9IGZ1bmN0aW9uKCl7IGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTsgfTtcblxudmFyIExheWVyZWRUZXh0dXJlQ2FjaGUgPSBmdW5jdGlvbiBMYXllcmVkVGV4dHVyZUNhY2hlKHJlbmRlcmVyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHIgPSBzZWxmLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHNlbGYubGF5ZXJzQnlMZXZlbCA9IHt9OyAvLyBlLmcuIDIgPT4gWyBsYXllcjEsIGxheWVyMiwgLi4uLCBsYXllck4gXVxuXG4gIHNlbGYuZmlyc3RHZXQgPSB0cnVlO1xuICBzZWxmLmxhc3RJbnZhbGlkYXRpb25UaW1lID0gcGVyZm9ybWFuY2VOb3coKSAtIDIgKiBpbnZhbGlkVGhyZXNob2xkO1xuICBzZWxmLnNraXBwaW5nID0gZmFsc2U7XG4gIHNlbGYuZWxlVHhyRGVxcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgc2VsZi5zY2hlZHVsZUVsZW1lbnRSZWZpbmVtZW50ID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYucmVmaW5lRWxlbWVudFRleHR1cmVzKHNlbGYuZWxlVHhyRGVxcyk7XG4gICAgc2VsZi5lbGVUeHJEZXFzLnVubWVyZ2Uoc2VsZi5lbGVUeHJEZXFzKTtcbiAgfSwgcmVmaW5lRWxlRGVib3VuY2VUaW1lKTtcbiAgci5iZWZvcmVSZW5kZXIoZnVuY3Rpb24gKHdpbGxEcmF3LCBub3cpIHtcbiAgICBpZiAobm93IC0gc2VsZi5sYXN0SW52YWxpZGF0aW9uVGltZSA8PSBpbnZhbGlkVGhyZXNob2xkKSB7XG4gICAgICBzZWxmLnNraXBwaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5za2lwcGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfSwgci5iZWZvcmVSZW5kZXJQcmlvcml0aWVzLmx5clR4clNraXApO1xuICB2YXIgcVNvcnQgPSBmdW5jdGlvbiBxU29ydChhLCBiKSB7XG4gICAgcmV0dXJuIGIucmVxcyAtIGEucmVxcztcbiAgfTtcbiAgc2VsZi5sYXllcnNRdWV1ZSA9IG5ldyBIZWFwKHFTb3J0KTtcbiAgc2VsZi5zZXR1cERlcXVldWVpbmcoKTtcbn07XG52YXIgTFRDcCA9IExheWVyZWRUZXh0dXJlQ2FjaGUucHJvdG90eXBlO1xudmFyIGxheWVySWRQb29sID0gMDtcbnZhciBNQVhfSU5UID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbkxUQ3AubWFrZUxheWVyID0gZnVuY3Rpb24gKGJiLCBsdmwpIHtcbiAgdmFyIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgdmFyIHcgPSBNYXRoLmNlaWwoYmIudyAqIHNjYWxlKTtcbiAgdmFyIGggPSBNYXRoLmNlaWwoYmIuaCAqIHNjYWxlKTtcbiAgdmFyIGNhbnZhcyA9IHRoaXMucmVuZGVyZXIubWFrZU9mZnNjcmVlbkNhbnZhcyh3LCBoKTtcbiAgdmFyIGxheWVyID0ge1xuICAgIGlkOiBsYXllcklkUG9vbCA9ICsrbGF5ZXJJZFBvb2wgJSBNQVhfSU5ULFxuICAgIGJiOiBiYixcbiAgICBsZXZlbDogbHZsLFxuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaCxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcbiAgICBlbGVzOiBbXSxcbiAgICBlbGVzUXVldWU6IFtdLFxuICAgIHJlcXM6IDBcbiAgfTtcblxuICAvLyBsb2coJ21ha2UgbGF5ZXIgJXMgd2l0aCB3ICVzIGFuZCBoICVzIGFuZCBsdmwgJXMnLCBsYXllci5pZCwgbGF5ZXIud2lkdGgsIGxheWVyLmhlaWdodCwgbGF5ZXIubGV2ZWwpO1xuXG4gIHZhciBjeHQgPSBsYXllci5jb250ZXh0O1xuICB2YXIgZHggPSAtbGF5ZXIuYmIueDE7XG4gIHZhciBkeSA9IC1sYXllci5iYi55MTtcblxuICAvLyBkbyB0aGUgdHJhbnNmb3JtIG9uIGNyZWF0aW9uIHRvIHNhdmUgY3ljbGVzIChpdCdzIHRoZSBzYW1lIGZvciBhbGwgZWxlcylcbiAgY3h0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gIGN4dC50cmFuc2xhdGUoZHgsIGR5KTtcbiAgcmV0dXJuIGxheWVyO1xufTtcbkxUQ3AuZ2V0TGF5ZXJzID0gZnVuY3Rpb24gKGVsZXMsIHB4UmF0aW8sIGx2bCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gc2VsZi5yZW5kZXJlcjtcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBmaXJzdEdldCA9IHNlbGYuZmlyc3RHZXQ7XG4gIHNlbGYuZmlyc3RHZXQgPSBmYWxzZTtcblxuICAvLyBsb2coJy0tXFxuZ2V0IGxheWVycyB3aXRoICVzIGVsZXMnLCBlbGVzLmxlbmd0aCk7XG4gIC8vbG9nIGVsZXMubWFwKGZ1bmN0aW9uKGVsZSl7IHJldHVybiBlbGUuaWQoKSB9KSApO1xuXG4gIGlmIChsdmwgPT0gbnVsbCkge1xuICAgIGx2bCA9IE1hdGguY2VpbChsb2cyKHpvb20gKiBweFJhdGlvKSk7XG4gICAgaWYgKGx2bCA8IG1pbkx2bCkge1xuICAgICAgbHZsID0gbWluTHZsO1xuICAgIH0gZWxzZSBpZiAoem9vbSA+PSBtYXhab29tIHx8IGx2bCA+IG1heEx2bCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHNlbGYudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcobHZsLCBlbGVzKTtcbiAgdmFyIGxheWVyc0J5THZsID0gc2VsZi5sYXllcnNCeUxldmVsO1xuICB2YXIgc2NhbGUgPSBNYXRoLnBvdygyLCBsdmwpO1xuICB2YXIgbGF5ZXJzID0gbGF5ZXJzQnlMdmxbbHZsXSA9IGxheWVyc0J5THZsW2x2bF0gfHwgW107XG4gIHZhciBiYjtcbiAgdmFyIGx2bENvbXBsZXRlID0gc2VsZi5sZXZlbElzQ29tcGxldGUobHZsLCBlbGVzKTtcbiAgdmFyIHRtcExheWVycztcbiAgdmFyIGNoZWNrVGVtcExldmVscyA9IGZ1bmN0aW9uIGNoZWNrVGVtcExldmVscygpIHtcbiAgICB2YXIgY2FuVXNlQXNUbXBMdmwgPSBmdW5jdGlvbiBjYW5Vc2VBc1RtcEx2bChsKSB7XG4gICAgICBzZWxmLnZhbGlkYXRlTGF5ZXJzRWxlc09yZGVyaW5nKGwsIGVsZXMpO1xuICAgICAgaWYgKHNlbGYubGV2ZWxJc0NvbXBsZXRlKGwsIGVsZXMpKSB7XG4gICAgICAgIHRtcExheWVycyA9IGxheWVyc0J5THZsW2xdO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjaGVja0x2bHMgPSBmdW5jdGlvbiBjaGVja0x2bHMoZGlyKSB7XG4gICAgICBpZiAodG1wTGF5ZXJzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGwgPSBsdmwgKyBkaXI7IG1pbkx2bCA8PSBsICYmIGwgPD0gbWF4THZsOyBsICs9IGRpcikge1xuICAgICAgICBpZiAoY2FuVXNlQXNUbXBMdmwobCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tMdmxzKDEpO1xuICAgIGNoZWNrTHZscygtMSk7XG5cbiAgICAvLyByZW1vdmUgdGhlIGludmFsaWQgbGF5ZXJzOyB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYXMgbmVlZGVkIGxhdGVyIGluIHRoaXMgZnVuY3Rpb25cbiAgICBmb3IgKHZhciBpID0gbGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG4gICAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgICByZW1vdmVGcm9tQXJyYXkobGF5ZXJzLCBsYXllcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBpZiAoIWx2bENvbXBsZXRlKSB7XG4gICAgLy8gaWYgdGhlIGN1cnJlbnQgbGV2ZWwgaXMgaW5jb21wbGV0ZSwgdGhlbiB1c2UgdGhlIGNsb3Nlc3QsIGJlc3QgcXVhbGl0eSBsYXllcnNldCB0ZW1wb3JhcmlseVxuICAgIC8vIGFuZCBsYXRlciBxdWV1ZSB0aGUgY3VycmVudCBsYXllcnNldCBzbyB3ZSBjYW4gZ2V0IHRoZSBwcm9wZXIgcXVhbGl0eSBsZXZlbCBzb29uXG5cbiAgICBjaGVja1RlbXBMZXZlbHMoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBsb2coJ2xldmVsIGNvbXBsZXRlLCB1c2luZyBleGlzdGluZyBsYXllcnNcXG4tLScpO1xuICAgIHJldHVybiBsYXllcnM7XG4gIH1cbiAgdmFyIGdldEJiID0gZnVuY3Rpb24gZ2V0QmIoKSB7XG4gICAgaWYgKCFiYikge1xuICAgICAgYmIgPSBtYWtlQm91bmRpbmdCb3goKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVCb3VuZGluZ0JveChiYiwgZWxlc1tpXS5ib3VuZGluZ0JveCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJiO1xuICB9O1xuICB2YXIgbWFrZUxheWVyID0gZnVuY3Rpb24gbWFrZUxheWVyKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgYWZ0ZXIgPSBvcHRzLmFmdGVyO1xuICAgIGdldEJiKCk7XG4gICAgdmFyIHcgPSBNYXRoLmNlaWwoYmIudyAqIHNjYWxlKTtcbiAgICB2YXIgaCA9IE1hdGguY2VpbChiYi5oICogc2NhbGUpO1xuICAgIGlmICh3ID4gbWF4TGF5ZXJEaW0gfHwgaCA+IG1heExheWVyRGltKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGFyZWEgPSB3ICogaDtcbiAgICBpZiAoYXJlYSA+IG1heExheWVyQXJlYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBsYXllciA9IHNlbGYubWFrZUxheWVyKGJiLCBsdmwpO1xuICAgIGlmIChhZnRlciAhPSBudWxsKSB7XG4gICAgICB2YXIgaW5kZXggPSBsYXllcnMuaW5kZXhPZihhZnRlcikgKyAxO1xuICAgICAgbGF5ZXJzLnNwbGljZShpbmRleCwgMCwgbGF5ZXIpO1xuICAgIH0gZWxzZSBpZiAob3B0cy5pbnNlcnQgPT09IHVuZGVmaW5lZCB8fCBvcHRzLmluc2VydCkge1xuICAgICAgLy8gbm8gYWZ0ZXIgc3BlY2lmaWVkID0+IGZpcnN0IGxheWVyIG1hZGUgc28gcHV0IGF0IHN0YXJ0XG4gICAgICBsYXllcnMudW5zaGlmdChsYXllcik7XG4gICAgfVxuXG4gICAgLy8gaWYoIHRtcExheWVycyApe1xuICAgIC8vc2VsZi5xdWV1ZUxheWVyKCBsYXllciApO1xuICAgIC8vIH1cblxuICAgIHJldHVybiBsYXllcjtcbiAgfTtcbiAgaWYgKHNlbGYuc2tpcHBpbmcgJiYgIWZpcnN0R2V0KSB7XG4gICAgLy8gbG9nKCdza2lwIGxheWVycycpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbG9nKCdkbyBsYXllcnMnKTtcblxuICB2YXIgbGF5ZXIgPSBudWxsO1xuICB2YXIgbWF4RWxlc1BlckxheWVyID0gZWxlcy5sZW5ndGggLyBkZWZOdW1MYXllcnM7XG4gIHZhciBhbGxvd0xhenlRdWV1ZWluZyA9ICFmaXJzdEdldDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBjYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyA9IHJzLmltZ0xheWVyQ2FjaGVzIHx8IHt9O1xuXG4gICAgLy8gbG9nKCdsb29rIGF0IGVsZScsIGVsZS5pZCgpKTtcblxuICAgIHZhciBleGlzdGluZ0xheWVyID0gY2FjaGVzW2x2bF07XG4gICAgaWYgKGV4aXN0aW5nTGF5ZXIpIHtcbiAgICAgIC8vIHJldXNlIGxheWVyIGZvciBsYXRlciBlbGVzXG4gICAgICAvLyBsb2coJ3JldXNlIGxheWVyIGZvcicsIGVsZS5pZCgpKTtcbiAgICAgIGxheWVyID0gZXhpc3RpbmdMYXllcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWxheWVyIHx8IGxheWVyLmVsZXMubGVuZ3RoID49IG1heEVsZXNQZXJMYXllciB8fCAhYm91bmRpbmdCb3hJbkJvdW5kaW5nQm94KGxheWVyLmJiLCBlbGUuYm91bmRpbmdCb3goKSkpIHtcbiAgICAgIC8vIGxvZygnbWFrZSBuZXcgbGF5ZXIgZm9yIGVsZSAlcycsIGVsZS5pZCgpKTtcblxuICAgICAgbGF5ZXIgPSBtYWtlTGF5ZXIoe1xuICAgICAgICBpbnNlcnQ6IHRydWUsXG4gICAgICAgIGFmdGVyOiBsYXllclxuICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIG5vdyBsYXllciBjYW4gYmUgYnVpbHQgdGhlbiB3ZSBjYW4ndCB1c2UgbGF5ZXJzIGF0IHRoaXMgbGV2ZWxcbiAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZygnbmV3IGxheWVyIHdpdGggaWQgJXMnLCBsYXllci5pZCk7XG4gICAgfVxuICAgIGlmICh0bXBMYXllcnMgfHwgYWxsb3dMYXp5UXVldWVpbmcpIHtcbiAgICAgIC8vIGxvZygncXVldWUgZWxlICVzIGluIGxheWVyICVzJywgZWxlLmlkKCksIGxheWVyLmlkKTtcbiAgICAgIHNlbGYucXVldWVMYXllcihsYXllciwgZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbG9nKCdkcmF3IGVsZSAlcyBpbiBsYXllciAlcycsIGVsZS5pZCgpLCBsYXllci5pZCk7XG4gICAgICBzZWxmLmRyYXdFbGVJbkxheWVyKGxheWVyLCBlbGUsIGx2bCwgcHhSYXRpbyk7XG4gICAgfVxuICAgIGxheWVyLmVsZXMucHVzaChlbGUpO1xuICAgIGNhY2hlc1tsdmxdID0gbGF5ZXI7XG4gIH1cblxuICAvLyBsb2coJy0tJyk7XG5cbiAgaWYgKHRtcExheWVycykge1xuICAgIC8vIHRoZW4gd2Ugb25seSBxdWV1ZWQgdGhlIGN1cnJlbnQgbGF5ZXJzZXQgYW5kIGNhbid0IGRyYXcgaXQgeWV0XG4gICAgcmV0dXJuIHRtcExheWVycztcbiAgfVxuICBpZiAoYWxsb3dMYXp5UXVldWVpbmcpIHtcbiAgICAvLyBsb2coJ2xhenkgcXVldWUgbGV2ZWwnLCBsdmwpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBsYXllcnM7XG59O1xuXG4vLyBhIGxheWVyIG1heSB3YW50IHRvIHVzZSBhbiBlbGUgY2FjaGUgb2YgYSBoaWdoZXIgbGV2ZWwgdG8gYXZvaWQgYmx1cnJpbmVzc1xuLy8gc28gdGhlIGxheWVyIGxldmVsIG1pZ2h0IG5vdCBlcXVhbCB0aGUgZWxlIGxldmVsXG5MVENwLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbCA9IGZ1bmN0aW9uIChsdmwsIHB4UmF0aW8pIHtcbiAgcmV0dXJuIGx2bDtcbn07XG5MVENwLmRyYXdFbGVJbkxheWVyID0gZnVuY3Rpb24gKGxheWVyLCBlbGUsIGx2bCwgcHhSYXRpbykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciByID0gdGhpcy5yZW5kZXJlcjtcbiAgdmFyIGNvbnRleHQgPSBsYXllci5jb250ZXh0O1xuICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcbiAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCB8fCAhZWxlLnZpc2libGUoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsdmwgPSBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbChsdmwsIHB4UmF0aW8pO1xuICB7XG4gICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgZmFsc2UpO1xuICB9XG4gIHtcbiAgICByLmRyYXdDYWNoZWRFbGVtZW50KGNvbnRleHQsIGVsZSwgbnVsbCwgbnVsbCwgbHZsLCB1c2VIaWdoUXVhbGl0eUVsZVR4clJlcXMpO1xuICB9XG4gIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgfVxufTtcbkxUQ3AubGV2ZWxJc0NvbXBsZXRlID0gZnVuY3Rpb24gKGx2bCwgZWxlcykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXllcnMgPSBzZWxmLmxheWVyc0J5TGV2ZWxbbHZsXTtcbiAgaWYgKCFsYXllcnMgfHwgbGF5ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbnVtRWxlc0luTGF5ZXJzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbaV07XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgYW55IGVsZXMgbmVlZGVkIHRvIGJlIGRyYXduIHlldCwgdGhlIGxldmVsIGlzIG5vdCBjb21wbGV0ZVxuICAgIGlmIChsYXllci5yZXFzID4gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBsYXllciBpcyBpbnZhbGlkLCB0aGUgbGV2ZWwgaXMgbm90IGNvbXBsZXRlXG4gICAgaWYgKGxheWVyLmludmFsaWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbnVtRWxlc0luTGF5ZXJzICs9IGxheWVyLmVsZXMubGVuZ3RoO1xuICB9XG5cbiAgLy8gd2Ugc2hvdWxkIGhhdmUgZXhhY3RseSB0aGUgbnVtYmVyIG9mIGVsZXMgcGFzc2VkIGluIHRvIGJlIGNvbXBsZXRlXG4gIGlmIChudW1FbGVzSW5MYXllcnMgIT09IGVsZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbkxUQ3AudmFsaWRhdGVMYXllcnNFbGVzT3JkZXJpbmcgPSBmdW5jdGlvbiAobHZsLCBlbGVzKSB7XG4gIHZhciBsYXllcnMgPSB0aGlzLmxheWVyc0J5TGV2ZWxbbHZsXTtcbiAgaWYgKCFsYXllcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBpbiBhIGxheWVyIHRoZSBlbGVzIGFyZSBub3QgaW4gdGhlIHNhbWUgb3JkZXIsIHRoZW4gdGhlIGxheWVyIGlzIGludmFsaWRcbiAgLy8gKGkuZS4gdGhlcmUgaXMgYW4gZWxlIGluIGJldHdlZW4gdGhlIGVsZXMgaW4gdGhlIGxheWVyKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgIHZhciBvZmZzZXQgPSAtMTtcblxuICAgIC8vIGZpbmQgdGhlIG9mZnNldFxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGxheWVyLmVsZXNbMF0gPT09IGVsZXNbal0pIHtcbiAgICAgICAgb2Zmc2V0ID0gajtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAvLyB0aGVuIHRoZSBsYXllciBoYXMgbm9uZXhpc3RlbnQgZWxlbWVudHMgYW5kIGlzIGludmFsaWRcbiAgICAgIHRoaXMuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRoZSBlbGVzIGluIHRoZSBsYXllciBtdXN0IGJlIGluIHRoZSBzYW1lIGNvbnRpbnVvdXMgb3JkZXIsIGVsc2UgdGhlIGxheWVyIGlzIGludmFsaWRcblxuICAgIHZhciBvID0gb2Zmc2V0O1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGxheWVyLmVsZXNbal0gIT09IGVsZXNbbyArIGpdKSB7XG4gICAgICAgIC8vIGxvZygnaW52YWxpZGF0ZSBiYXNlZCBvbiBvcmRlcmluZycsIGxheWVyLmlkKTtcblxuICAgICAgICB0aGlzLmludmFsaWRhdGVMYXllcihsYXllcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkxUQ3AudXBkYXRlRWxlbWVudHNJbkxheWVycyA9IGZ1bmN0aW9uIChlbGVzLCB1cGRhdGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaXNFbGVzID0gZWxlbWVudChlbGVzWzBdKTtcblxuICAvLyBjb2xsZWN0IHVkcGF0ZWQgZWxlbWVudHMgKGNhc2NhZGVkIGZyb20gdGhlIGxheWVycykgYW5kIHVwZGF0ZSBlYWNoXG4gIC8vIGxheWVyIGl0c2VsZiBhbG9uZyB0aGUgd2F5XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZXEgPSBpc0VsZXMgPyBudWxsIDogZWxlc1tpXTtcbiAgICB2YXIgZWxlID0gaXNFbGVzID8gZWxlc1tpXSA6IGVsZXNbaV0uZWxlO1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FjaGVzID0gcnMuaW1nTGF5ZXJDYWNoZXMgPSBycy5pbWdMYXllckNhY2hlcyB8fCB7fTtcbiAgICBmb3IgKHZhciBsID0gbWluTHZsOyBsIDw9IG1heEx2bDsgbCsrKSB7XG4gICAgICB2YXIgbGF5ZXIgPSBjYWNoZXNbbF07XG4gICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB1cGRhdGUgaXMgYSByZXF1ZXN0IGZyb20gdGhlIGVsZSBjYWNoZSwgdGhlbiBpdCBhZmZlY3RzIG9ubHlcbiAgICAgIC8vIHRoZSBtYXRjaGluZyBsZXZlbFxuICAgICAgaWYgKHJlcSAmJiBzZWxmLmdldEVsZUxldmVsRm9yTGF5ZXJMZXZlbChsYXllci5sZXZlbCkgIT09IHJlcS5sZXZlbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZShsYXllciwgZWxlLCByZXEpO1xuICAgIH1cbiAgfVxufTtcbkxUQ3AuaGF2ZUxheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgaGF2ZUxheWVycyA9IGZhbHNlO1xuICBmb3IgKHZhciBsID0gbWluTHZsOyBsIDw9IG1heEx2bDsgbCsrKSB7XG4gICAgdmFyIGxheWVycyA9IHNlbGYubGF5ZXJzQnlMZXZlbFtsXTtcbiAgICBpZiAobGF5ZXJzICYmIGxheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICBoYXZlTGF5ZXJzID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGF2ZUxheWVycztcbn07XG5MVENwLmludmFsaWRhdGVFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKGVsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbGYubGFzdEludmFsaWRhdGlvblRpbWUgPSBwZXJmb3JtYW5jZU5vdygpO1xuXG4gIC8vIGxvZygndXBkYXRlIGludmFsaWRhdGUgbGF5ZXIgdGltZSBmcm9tIGVsZXMnKTtcblxuICBpZiAoZWxlcy5sZW5ndGggPT09IDAgfHwgIXNlbGYuaGF2ZUxheWVycygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyhlbGVzLCBmdW5jdGlvbiBpbnZhbEFzc29jTGF5ZXJzKGxheWVyLCBlbGUsIHJlcSkge1xuICAgIHNlbGYuaW52YWxpZGF0ZUxheWVyKGxheWVyKTtcbiAgfSk7XG59O1xuTFRDcC5pbnZhbGlkYXRlTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgLy8gbG9nKCd1cGRhdGUgaW52YWxpZGF0ZSBsYXllciB0aW1lJyk7XG5cbiAgdGhpcy5sYXN0SW52YWxpZGF0aW9uVGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGlmIChsYXllci5pbnZhbGlkKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIHNhdmUgY3ljbGVzXG5cbiAgdmFyIGx2bCA9IGxheWVyLmxldmVsO1xuICB2YXIgZWxlcyA9IGxheWVyLmVsZXM7XG4gIHZhciBsYXllcnMgPSB0aGlzLmxheWVyc0J5TGV2ZWxbbHZsXTtcblxuICAvLyBsb2coJ2ludmFsaWRhdGUgbGF5ZXInLCBsYXllci5pZCApO1xuXG4gIHJlbW92ZUZyb21BcnJheShsYXllcnMsIGxheWVyKTtcbiAgLy8gbGF5ZXIuZWxlcyA9IFtdO1xuXG4gIGxheWVyLmVsZXNRdWV1ZSA9IFtdO1xuICBsYXllci5pbnZhbGlkID0gdHJ1ZTtcbiAgaWYgKGxheWVyLnJlcGxhY2VtZW50KSB7XG4gICAgbGF5ZXIucmVwbGFjZW1lbnQuaW52YWxpZCA9IHRydWU7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNhY2hlcyA9IGVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW1nTGF5ZXJDYWNoZXM7XG4gICAgaWYgKGNhY2hlcykge1xuICAgICAgY2FjaGVzW2x2bF0gPSBudWxsO1xuICAgIH1cbiAgfVxufTtcbkxUQ3AucmVmaW5lRWxlbWVudFRleHR1cmVzID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGxvZygncmVmaW5lJywgZWxlcy5sZW5ndGgpO1xuXG4gIHNlbGYudXBkYXRlRWxlbWVudHNJbkxheWVycyhlbGVzLCBmdW5jdGlvbiByZWZpbmVFYWNoRWxlKGxheWVyLCBlbGUsIHJlcSkge1xuICAgIHZhciByTHlyID0gbGF5ZXIucmVwbGFjZW1lbnQ7XG4gICAgaWYgKCFyTHlyKSB7XG4gICAgICByTHlyID0gbGF5ZXIucmVwbGFjZW1lbnQgPSBzZWxmLm1ha2VMYXllcihsYXllci5iYiwgbGF5ZXIubGV2ZWwpO1xuICAgICAgckx5ci5yZXBsYWNlcyA9IGxheWVyO1xuICAgICAgckx5ci5lbGVzID0gbGF5ZXIuZWxlcztcblxuICAgICAgLy8gbG9nKCdtYWtlIHJlcGxhY2VtZW50IGxheWVyICVzIGZvciAlcyB3aXRoIGxldmVsICVzJywgckx5ci5pZCwgbGF5ZXIuaWQsIHJMeXIubGV2ZWwpO1xuICAgIH1cbiAgICBpZiAoIXJMeXIucmVxcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByTHlyLmVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5xdWV1ZUxheWVyKHJMeXIsIHJMeXIuZWxlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZygncXVldWUgcmVwbGFjZW1lbnQgbGF5ZXIgcmVmaW5lbWVudCcsIHJMeXIuaWQpO1xuICAgIH1cbiAgfSk7XG59O1xuTFRDcC5lbnF1ZXVlRWxlbWVudFJlZmluZW1lbnQgPSBmdW5jdGlvbiAoZWxlKSB7XG4gIHRoaXMuZWxlVHhyRGVxcy5tZXJnZShlbGUpO1xuICB0aGlzLnNjaGVkdWxlRWxlbWVudFJlZmluZW1lbnQoKTtcbn07XG5MVENwLnF1ZXVlTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXIsIGVsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5sYXllcnNRdWV1ZTtcbiAgdmFyIGVsZXNRID0gbGF5ZXIuZWxlc1F1ZXVlO1xuICB2YXIgaGFzSWQgPSBlbGVzUS5oYXNJZCA9IGVsZXNRLmhhc0lkIHx8IHt9O1xuXG4gIC8vIGlmIGEgbGF5ZXIgaXMgZ29pbmcgdG8gYmUgcmVwbGFjZWQsIHF1ZXVpbmcgaXMgYSB3YXN0ZSBvZiB0aW1lXG4gIGlmIChsYXllci5yZXBsYWNlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlKSB7XG4gICAgaWYgKGhhc0lkW2VsZS5pZCgpXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVzUS5wdXNoKGVsZSk7XG4gICAgaGFzSWRbZWxlLmlkKCldID0gdHJ1ZTtcbiAgfVxuICBpZiAobGF5ZXIucmVxcykge1xuICAgIGxheWVyLnJlcXMrKztcbiAgICBxLnVwZGF0ZUl0ZW0obGF5ZXIpO1xuICB9IGVsc2Uge1xuICAgIGxheWVyLnJlcXMgPSAxO1xuICAgIHEucHVzaChsYXllcik7XG4gIH1cbn07XG5MVENwLmRlcXVldWUgPSBmdW5jdGlvbiAocHhSYXRpbykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBxID0gc2VsZi5sYXllcnNRdWV1ZTtcbiAgdmFyIGRlcWQgPSBbXTtcbiAgdmFyIGVsZURlcXMgPSAwO1xuICB3aGlsZSAoZWxlRGVxcyA8IG1heERlcVNpemUpIHtcbiAgICBpZiAocS5zaXplKCkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgbGF5ZXIgPSBxLnBlZWsoKTtcblxuICAgIC8vIGlmIGEgbGF5ZXIgaGFzIGJlZW4gb3Igd2lsbCBiZSByZXBsYWNlZCwgdGhlbiBkb24ndCB3YXN0ZSB0aW1lIHdpdGggaXRcbiAgICBpZiAobGF5ZXIucmVwbGFjZW1lbnQpIHtcbiAgICAgIC8vIGxvZygnbGF5ZXIgJXMgaW4gcXVldWUgc2tpcHBlZCBiL2MgaXQgYWxyZWFkeSBoYXMgYSByZXBsYWNlbWVudCcsIGxheWVyLmlkKTtcbiAgICAgIHEucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGlzIGlzIGEgcmVwbGFjZW1lbnQgbGF5ZXIgdGhhdCBoYXMgYmVlbiBzdXBlcmNlZGVkLCB0aGVuIGZvcmdldCBpdFxuICAgIGlmIChsYXllci5yZXBsYWNlcyAmJiBsYXllciAhPT0gbGF5ZXIucmVwbGFjZXMucmVwbGFjZW1lbnQpIHtcbiAgICAgIC8vIGxvZygnbGF5ZXIgaXMgbm8gbG9uZ2VyIHRoZSBtb3N0IHVwdG9kYXRlIHJlcGxhY2VtZW50OyBkZXF1ZXVlZCcsIGxheWVyLmlkKVxuICAgICAgcS5wb3AoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobGF5ZXIuaW52YWxpZCkge1xuICAgICAgLy8gbG9nKCdyZXBsYWNlbWVudCBsYXllciAlcyBpcyBpbnZhbGlkOyBkZXF1ZXVlZCcsIGxheWVyLmlkKTtcbiAgICAgIHEucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGVsZSA9IGxheWVyLmVsZXNRdWV1ZS5zaGlmdCgpO1xuICAgIGlmIChlbGUpIHtcbiAgICAgIC8vIGxvZygnZGVxdWV1ZSBsYXllciAlcycsIGxheWVyLmlkKTtcblxuICAgICAgc2VsZi5kcmF3RWxlSW5MYXllcihsYXllciwgZWxlLCBsYXllci5sZXZlbCwgcHhSYXRpbyk7XG4gICAgICBlbGVEZXFzKys7XG4gICAgfVxuICAgIGlmIChkZXFkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gd2UgbmVlZCBvbmx5IG9uZSBlbnRyeSBpbiBkZXFkIHRvIHF1ZXVlIHJlZHJhd2luZyBldGNcbiAgICAgIGRlcWQucHVzaCh0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbGF5ZXIgaGFzIGFsbCBpdHMgZWxlcyBkb25lLCB0aGVuIHJlbW92ZSBmcm9tIHRoZSBxdWV1ZVxuICAgIGlmIChsYXllci5lbGVzUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBxLnBvcCgpO1xuICAgICAgbGF5ZXIucmVxcyA9IDA7XG5cbiAgICAgIC8vIGxvZygnZGVxdWV1ZSBvZiBsYXllciAlcyBjb21wbGV0ZScsIGxheWVyLmlkKTtcblxuICAgICAgLy8gd2hlbiBhIHJlcGxhY2VtZW50IGxheWVyIGlzIGRlcXVldWVkLCBpdCByZXBsYWNlcyB0aGUgb2xkIGxheWVyIGluIHRoZSBsZXZlbFxuICAgICAgaWYgKGxheWVyLnJlcGxhY2VzKSB7XG4gICAgICAgIHNlbGYuYXBwbHlMYXllclJlcGxhY2VtZW50KGxheWVyKTtcbiAgICAgIH1cbiAgICAgIHNlbGYucmVxdWVzdFJlZHJhdygpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVxZDtcbn07XG5MVENwLmFwcGx5TGF5ZXJSZXBsYWNlbWVudCA9IGZ1bmN0aW9uIChsYXllcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsYXllcnNJbkxldmVsID0gc2VsZi5sYXllcnNCeUxldmVsW2xheWVyLmxldmVsXTtcbiAgdmFyIHJlcGxhY2VkID0gbGF5ZXIucmVwbGFjZXM7XG4gIHZhciBpbmRleCA9IGxheWVyc0luTGV2ZWwuaW5kZXhPZihyZXBsYWNlZCk7XG5cbiAgLy8gaWYgdGhlIHJlcGxhY2VkIGxheWVyIGlzIG5vdCBpbiB0aGUgYWN0aXZlIGxpc3QgZm9yIHRoZSBsZXZlbCwgdGhlbiByZXBsYWNpbmdcbiAgLy8gcmVmcyB3b3VsZCBiZSBhIG1pc3Rha2UgKGkuZS4gb3ZlcndyaXRpbmcgdGhlIHRydWUgYWN0aXZlIGxheWVyKVxuICBpZiAoaW5kZXggPCAwIHx8IHJlcGxhY2VkLmludmFsaWQpIHtcbiAgICAvLyBsb2coJ3JlcGxhY2VtZW50IGxheWVyIHdvdWxkIGhhdmUgbm8gZWZmZWN0JywgbGF5ZXIuaWQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsYXllcnNJbkxldmVsW2luZGV4XSA9IGxheWVyOyAvLyByZXBsYWNlIGxldmVsIHJlZlxuXG4gIC8vIHJlcGxhY2UgcmVmcyBpbiBlbGVzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIuZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfcCA9IGxheWVyLmVsZXNbaV0uX3ByaXZhdGU7XG4gICAgdmFyIGNhY2hlID0gX3AuaW1nTGF5ZXJDYWNoZXMgPSBfcC5pbWdMYXllckNhY2hlcyB8fCB7fTtcbiAgICBpZiAoY2FjaGUpIHtcbiAgICAgIGNhY2hlW2xheWVyLmxldmVsXSA9IGxheWVyO1xuICAgIH1cbiAgfVxuXG4gIC8vIGxvZygnYXBwbHkgcmVwbGFjZW1lbnQgbGF5ZXIgJXMgb3ZlciAlcycsIGxheWVyLmlkLCByZXBsYWNlZC5pZCk7XG5cbiAgc2VsZi5yZXF1ZXN0UmVkcmF3KCk7XG59O1xuTFRDcC5yZXF1ZXN0UmVkcmF3ID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICB2YXIgciA9IHRoaXMucmVuZGVyZXI7XG4gIHIucmVkcmF3SGludCgnZWxlcycsIHRydWUpO1xuICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgci5yZWRyYXcoKTtcbn0sIDEwMCk7XG5MVENwLnNldHVwRGVxdWV1ZWluZyA9IGRlZnMuc2V0dXBEZXF1ZXVlaW5nKHtcbiAgZGVxUmVkcmF3VGhyZXNob2xkOiBkZXFSZWRyYXdUaHJlc2hvbGQsXG4gIGRlcUNvc3Q6IGRlcUNvc3QsXG4gIGRlcUF2Z0Nvc3Q6IGRlcUF2Z0Nvc3QsXG4gIGRlcU5vRHJhd0Nvc3Q6IGRlcU5vRHJhd0Nvc3QsXG4gIGRlcUZhc3RDb3N0OiBkZXFGYXN0Q29zdCxcbiAgZGVxOiBmdW5jdGlvbiBkZXEoc2VsZiwgcHhSYXRpbykge1xuICAgIHJldHVybiBzZWxmLmRlcXVldWUocHhSYXRpbyk7XG4gIH0sXG4gIG9uRGVxZDogbm9vcCQxLFxuICBzaG91bGRSZWRyYXc6IHRydWVpZnksXG4gIHByaW9yaXR5OiBmdW5jdGlvbiBwcmlvcml0eShzZWxmKSB7XG4gICAgcmV0dXJuIHNlbGYucmVuZGVyZXIuYmVmb3JlUmVuZGVyUHJpb3JpdGllcy5seXJUeHJEZXE7XG4gIH1cbn0pO1xuXG52YXIgQ1JwJGIgPSB7fTtcbnZhciBpbXBsO1xuZnVuY3Rpb24gcG9seWdvbihjb250ZXh0LCBwb2ludHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWFuZ2xlQmFja2N1cnZlKGNvbnRleHQsIHBvaW50cywgY29udHJvbFBvaW50KSB7XG4gIHZhciBmaXJzdFB0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgZmlyc3RQdCA9IHB0O1xuICAgIH1cbiAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgfVxuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBmaXJzdFB0LngsIGZpcnN0UHQueSk7XG59XG5mdW5jdGlvbiB0cmlhbmdsZVRlZShjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgdGVlUG9pbnRzKSB7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cbiAgdmFyIHRyaVB0cyA9IHRyaWFuZ2xlUG9pbnRzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHRyaVB0c1tpXTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgfVxuICB2YXIgdGVlUHRzID0gdGVlUG9pbnRzO1xuICB2YXIgZmlyc3RUZWVQdCA9IHRlZVBvaW50c1swXTtcbiAgY29udGV4dC5tb3ZlVG8oZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHRlZVB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwdCA9IHRlZVB0c1tpXTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgfVxuICBpZiAoY29udGV4dC5jbG9zZVBhdGgpIHtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59XG5mdW5jdGlvbiBjaXJjbGVUcmlhbmdsZShjb250ZXh0LCB0cmlhbmdsZVBvaW50cywgcngsIHJ5LCByKSB7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cbiAgY29udGV4dC5hcmMocngsIHJ5LCByLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICB2YXIgdHJpUHRzID0gdHJpYW5nbGVQb2ludHM7XG4gIHZhciBmaXJzdFRyUHQgPSB0cmlQdHNbMF07XG4gIGNvbnRleHQubW92ZVRvKGZpcnN0VHJQdC54LCBmaXJzdFRyUHQueSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJpUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHB0ID0gdHJpUHRzW2ldO1xuICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICB9XG4gIGlmIChjb250ZXh0LmNsb3NlUGF0aCkge1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNpcmNsZSQxKGNvbnRleHQsIHJ4LCByeSwgcikge1xuICBjb250ZXh0LmFyYyhyeCwgcnksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG59XG5DUnAkYi5hcnJvd1NoYXBlSW1wbCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAoaW1wbCB8fCAoaW1wbCA9IHtcbiAgICAncG9seWdvbic6IHBvbHlnb24sXG4gICAgJ3RyaWFuZ2xlLWJhY2tjdXJ2ZSc6IHRyaWFuZ2xlQmFja2N1cnZlLFxuICAgICd0cmlhbmdsZS10ZWUnOiB0cmlhbmdsZVRlZSxcbiAgICAnY2lyY2xlLXRyaWFuZ2xlJzogY2lyY2xlVHJpYW5nbGUsXG4gICAgJ3RyaWFuZ2xlLWNyb3NzJzogdHJpYW5nbGVUZWUsXG4gICAgJ2NpcmNsZSc6IGNpcmNsZSQxXG4gIH0pKVtuYW1lXTtcbn07XG5cbnZhciBDUnAkYSA9IHt9O1xuQ1JwJGEuZHJhd0VsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgc2hvd0xhYmVsLCBzaG93T3ZlcmxheSwgc2hvd09wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2UoY29udGV4dCwgZWxlLCBzaGlmdFRvT3JpZ2luV2l0aEJiLCBzaG93TGFiZWwsIHNob3dPdmVybGF5LCBzaG93T3BhY2l0eSk7XG4gIH1cbn07XG5DUnAkYS5kcmF3RWxlbWVudE92ZXJsYXkgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gIHZhciByID0gdGhpcztcbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHIuZHJhd05vZGVPdmVybGF5KGNvbnRleHQsIGVsZSk7XG4gIH0gZWxzZSB7XG4gICAgci5kcmF3RWRnZU92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgfVxufTtcbkNScCRhLmRyYXdFbGVtZW50VW5kZXJsYXkgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlKSB7XG4gIHZhciByID0gdGhpcztcbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIHIuZHJhd05vZGVVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICB9IGVsc2Uge1xuICAgIHIuZHJhd0VkZ2VVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuQ1JwJGEuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgZWxlVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRSb3RhdGlvbiwgZ2V0T3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBiYiA9IGVsZVR4ckNhY2hlLmdldEJvdW5kaW5nQm94KGVsZSk7XG4gIGlmIChiYi53ID09PSAwIHx8IGJiLmggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH0gLy8gaWdub3JlIHplcm8gc2l6ZSBjYXNlXG5cbiAgdmFyIGVsZUNhY2hlID0gZWxlVHhyQ2FjaGUuZ2V0RWxlbWVudChlbGUsIGJiLCBweFJhdGlvLCBsdmwsIHJlYXNvbik7XG4gIGlmIChlbGVDYWNoZSAhPSBudWxsKSB7XG4gICAgdmFyIG9wYWNpdHkgPSBnZXRPcGFjaXR5KHIsIGVsZSk7XG4gICAgaWYgKG9wYWNpdHkgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRoZXRhID0gZ2V0Um90YXRpb24ociwgZWxlKTtcbiAgICB2YXIgeDEgPSBiYi54MSxcbiAgICAgIHkxID0gYmIueTEsXG4gICAgICB3ID0gYmIudyxcbiAgICAgIGggPSBiYi5oO1xuICAgIHZhciB4LCB5LCBzeCwgc3ksIHNtb290aDtcbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIHZhciByb3RQdCA9IGVsZVR4ckNhY2hlLmdldFJvdGF0aW9uUG9pbnQoZWxlKTtcbiAgICAgIHN4ID0gcm90UHQueDtcbiAgICAgIHN5ID0gcm90UHQueTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHN4LCBzeSk7XG4gICAgICBjb250ZXh0LnJvdGF0ZSh0aGV0YSk7XG4gICAgICBzbW9vdGggPSByLmdldEltZ1Ntb290aGluZyhjb250ZXh0KTtcbiAgICAgIGlmICghc21vb3RoKSB7XG4gICAgICAgIHIuc2V0SW1nU21vb3RoaW5nKGNvbnRleHQsIHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIG9mZiA9IGVsZVR4ckNhY2hlLmdldFJvdGF0aW9uT2Zmc2V0KGVsZSk7XG4gICAgICB4ID0gb2ZmLng7XG4gICAgICB5ID0gb2ZmLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4MTtcbiAgICAgIHkgPSB5MTtcbiAgICB9XG4gICAgdmFyIG9sZEdsb2JhbEFscGhhO1xuICAgIGlmIChvcGFjaXR5ICE9PSAxKSB7XG4gICAgICBvbGRHbG9iYWxBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb2xkR2xvYmFsQWxwaGEgKiBvcGFjaXR5O1xuICAgIH1cbiAgICBjb250ZXh0LmRyYXdJbWFnZShlbGVDYWNoZS50ZXh0dXJlLmNhbnZhcywgZWxlQ2FjaGUueCwgMCwgZWxlQ2FjaGUud2lkdGgsIGVsZUNhY2hlLmhlaWdodCwgeCwgeSwgdywgaCk7XG4gICAgaWYgKG9wYWNpdHkgIT09IDEpIHtcbiAgICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvbGRHbG9iYWxBbHBoYTtcbiAgICB9XG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLXN4LCAtc3kpO1xuICAgICAgaWYgKCFzbW9vdGgpIHtcbiAgICAgICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBlbGVUeHJDYWNoZS5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUpOyAvLyBkaXJlY3QgZHJhdyBmYWxsYmFja1xuICB9XG59O1xudmFyIGdldFplcm9Sb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFplcm9Sb3RhdGlvbigpIHtcbiAgcmV0dXJuIDA7XG59O1xudmFyIGdldExhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uKHIsIGVsZSkge1xuICByZXR1cm4gci5nZXRUZXh0QW5nbGUoZWxlLCBudWxsKTtcbn07XG52YXIgZ2V0U291cmNlTGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsICdzb3VyY2UnKTtcbn07XG52YXIgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbiA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb24ociwgZWxlKSB7XG4gIHJldHVybiByLmdldFRleHRBbmdsZShlbGUsICd0YXJnZXQnKTtcbn07XG52YXIgZ2V0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldE9wYWNpdHkociwgZWxlKSB7XG4gIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xufTtcbnZhciBnZXRUZXh0T3BhY2l0eSA9IGZ1bmN0aW9uIGdldFRleHRPcGFjaXR5KGUsIGVsZSkge1xuICByZXR1cm4gZWxlLnBzdHlsZSgndGV4dC1vcGFjaXR5JykucGZWYWx1ZSAqIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG59O1xuQ1JwJGEuZHJhd0NhY2hlZEVsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQsIGx2bCwgcmVxdWVzdEhpZ2hRdWFsaXR5KSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIF9yJGRhdGEgPSByLmRhdGEsXG4gICAgZWxlVHhyQ2FjaGUgPSBfciRkYXRhLmVsZVR4ckNhY2hlLFxuICAgIGxibFR4ckNhY2hlID0gX3IkZGF0YS5sYmxUeHJDYWNoZSxcbiAgICBzbGJUeHJDYWNoZSA9IF9yJGRhdGEuc2xiVHhyQ2FjaGUsXG4gICAgdGxiVHhyQ2FjaGUgPSBfciRkYXRhLnRsYlR4ckNhY2hlO1xuICB2YXIgYmIgPSBlbGUuYm91bmRpbmdCb3goKTtcbiAgdmFyIHJlYXNvbiA9IHJlcXVlc3RIaWdoUXVhbGl0eSA9PT0gdHJ1ZSA/IGVsZVR4ckNhY2hlLnJlYXNvbnMuaGlnaFF1YWxpdHkgOiBudWxsO1xuICBpZiAoYmIudyA9PT0gMCB8fCBiYi5oID09PSAwIHx8ICFlbGUudmlzaWJsZSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZXh0ZW50IHx8IGJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoYmIsIGV4dGVudCkpIHtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBiYWRMaW5lID0gZWxlLmVsZW1lbnQoKS5fcHJpdmF0ZS5yc2NyYXRjaC5iYWRMaW5lO1xuICAgIHIuZHJhd0VsZW1lbnRVbmRlcmxheShjb250ZXh0LCBlbGUpO1xuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uKGNvbnRleHQsIGVsZSwgZWxlVHhyQ2FjaGUsIHB4UmF0aW8sIGx2bCwgcmVhc29uLCBnZXRaZXJvUm90YXRpb24sIGdldE9wYWNpdHkpO1xuICAgIGlmICghaXNFZGdlIHx8ICFiYWRMaW5lKSB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIGxibFR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0TGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgIH1cbiAgICBpZiAoaXNFZGdlICYmICFiYWRMaW5lKSB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbihjb250ZXh0LCBlbGUsIHNsYlR4ckNhY2hlLCBweFJhdGlvLCBsdmwsIHJlYXNvbiwgZ2V0U291cmNlTGFiZWxSb3RhdGlvbiwgZ2V0VGV4dE9wYWNpdHkpO1xuICAgICAgci5kcmF3Q2FjaGVkRWxlbWVudFBvcnRpb24oY29udGV4dCwgZWxlLCB0bGJUeHJDYWNoZSwgcHhSYXRpbywgbHZsLCByZWFzb24sIGdldFRhcmdldExhYmVsUm90YXRpb24sIGdldFRleHRPcGFjaXR5KTtcbiAgICB9XG4gICAgci5kcmF3RWxlbWVudE92ZXJsYXkoY29udGV4dCwgZWxlKTtcbiAgfVxufTtcbkNScCRhLmRyYXdFbGVtZW50cyA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGVzKSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgci5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUpO1xuICB9XG59O1xuQ1JwJGEuZHJhd0NhY2hlZEVsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIHIuZHJhd0NhY2hlZEVsZW1lbnQoY29udGV4dCwgZWxlLCBweFJhdGlvLCBleHRlbnQpO1xuICB9XG59O1xuQ1JwJGEuZHJhd0NhY2hlZE5vZGVzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICB2YXIgciA9IHRoaXM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgIGlmICghZWxlLmlzTm9kZSgpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudChjb250ZXh0LCBlbGUsIHB4UmF0aW8sIGV4dGVudCk7XG4gIH1cbn07XG5DUnAkYS5kcmF3TGF5ZXJlZEVsZW1lbnRzID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZXMsIHB4UmF0aW8sIGV4dGVudCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBsYXllcnMgPSByLmRhdGEubHlyVHhyQ2FjaGUuZ2V0TGF5ZXJzKGVsZXMsIHB4UmF0aW8pO1xuICBpZiAobGF5ZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyc1tpXTtcbiAgICAgIHZhciBiYiA9IGxheWVyLmJiO1xuICAgICAgaWYgKGJiLncgPT09IDAgfHwgYmIuaCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGxheWVyLmNhbnZhcywgYmIueDEsIGJiLnkxLCBiYi53LCBiYi5oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbCBiYWNrIG9uIHBsYWluIGNhY2hpbmcgaWYgbm8gbGF5ZXJzXG4gICAgci5kcmF3Q2FjaGVkRWxlbWVudHMoY29udGV4dCwgZWxlcywgcHhSYXRpbywgZXh0ZW50KTtcbiAgfVxufTtcblxudmFyIENScCQ5ID0ge307XG5DUnAkOS5kcmF3RWRnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlLCBzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gIHZhciBkcmF3TGFiZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIHZhciBzaG91bGREcmF3T3ZlcmxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiB0cnVlO1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIGlmIChzaG91bGREcmF3T3BhY2l0eSAmJiAhZWRnZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBiZXppZXIgY3RybCBwdHMgY2FuIG5vdCBiZSBjYWxjdWxhdGVkLCB0aGVuIGRpZVxuICBpZiAocnMuYmFkTGluZSB8fCBycy5hbGxwdHMgPT0gbnVsbCB8fCBpc05hTihycy5hbGxwdHNbMF0pKSB7XG4gICAgLy8gaXNOYU4gaW4gY2FzZSBlZGdlIGlzIGltcG9zc2libGUgYW5kIGJyb3dzZXIgYnVncyAoZS5nLiBzYWZhcmkpXG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBiYjtcbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWJiLngxLCAtYmIueTEpO1xuICB9XG4gIHZhciBvcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBlZGdlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlIDogMTtcbiAgdmFyIGxpbmVPcGFjaXR5ID0gc2hvdWxkRHJhd09wYWNpdHkgPyBlZGdlLnBzdHlsZSgnbGluZS1vcGFjaXR5JykudmFsdWUgOiAxO1xuICB2YXIgY3VydmVTdHlsZSA9IGVkZ2UucHN0eWxlKCdjdXJ2ZS1zdHlsZScpLnZhbHVlO1xuICB2YXIgbGluZVN0eWxlID0gZWRnZS5wc3R5bGUoJ2xpbmUtc3R5bGUnKS52YWx1ZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIHZhciBsaW5lQ2FwID0gZWRnZS5wc3R5bGUoJ2xpbmUtY2FwJykudmFsdWU7XG4gIHZhciBsaW5lT3V0bGluZVdpZHRoID0gZWRnZS5wc3R5bGUoJ2xpbmUtb3V0bGluZS13aWR0aCcpLnZhbHVlO1xuICB2YXIgbGluZU91dGxpbmVDb2xvciA9IGVkZ2UucHN0eWxlKCdsaW5lLW91dGxpbmUtY29sb3InKS52YWx1ZTtcbiAgdmFyIGVmZmVjdGl2ZUxpbmVPcGFjaXR5ID0gb3BhY2l0eSAqIGxpbmVPcGFjaXR5O1xuICAvLyBzZXBhcmF0ZSBhcnJvdyBvcGFjaXR5IHdvdWxkIHJlcXVpcmUgYXJyb3ctb3BhY2l0eSBwcm9wZXJ0eVxuICB2YXIgZWZmZWN0aXZlQXJyb3dPcGFjaXR5ID0gb3BhY2l0eSAqIGxpbmVPcGFjaXR5O1xuICB2YXIgZHJhd0xpbmUgPSBmdW5jdGlvbiBkcmF3TGluZSgpIHtcbiAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWZmZWN0aXZlTGluZU9wYWNpdHk7XG4gICAgaWYgKGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodC10cmlhbmdsZScpIHtcbiAgICAgIHIuZWxlU3Ryb2tlU3R5bGUoY29udGV4dCwgZWRnZSwgc3Ryb2tlT3BhY2l0eSk7XG4gICAgICByLmRyYXdFZGdlVHJpYW5nbGVQYXRoKGVkZ2UsIGNvbnRleHQsIHJzLmFsbHB0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZWRnZVdpZHRoO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgIHIuZWxlU3Ryb2tlU3R5bGUoY29udGV4dCwgZWRnZSwgc3Ryb2tlT3BhY2l0eSk7XG4gICAgICByLmRyYXdFZGdlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMsIGxpbmVTdHlsZSk7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7IC8vIHJlc2V0IGZvciBvdGhlciBkcmF3aW5nIGZ1bmN0aW9uc1xuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdMaW5lT3V0bGluZSA9IGZ1bmN0aW9uIGRyYXdMaW5lT3V0bGluZSgpIHtcbiAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWZmZWN0aXZlTGluZU9wYWNpdHk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGggKyBsaW5lT3V0bGluZVdpZHRoO1xuICAgIGNvbnRleHQubGluZUNhcCA9IGxpbmVDYXA7XG4gICAgaWYgKGxpbmVPdXRsaW5lV2lkdGggPiAwKSB7XG4gICAgICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgbGluZU91dGxpbmVDb2xvclswXSwgbGluZU91dGxpbmVDb2xvclsxXSwgbGluZU91dGxpbmVDb2xvclsyXSwgc3Ryb2tlT3BhY2l0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvIG5vdCBkcmF3IGFueSBsaW5lT3V0bGluZVxuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnOyAvLyByZXNldCBmb3Igb3RoZXIgZHJhd2luZyBmdW5jdGlvbnNcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnZlU3R5bGUgPT09ICdzdHJhaWdodC10cmlhbmdsZScpIHtcbiAgICAgIHIuZHJhd0VkZ2VUcmlhbmdsZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5kcmF3RWRnZVBhdGgoZWRnZSwgY29udGV4dCwgcnMuYWxscHRzLCBsaW5lU3R5bGUpO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnOyAvLyByZXNldCBmb3Igb3RoZXIgZHJhd2luZyBmdW5jdGlvbnNcbiAgICB9XG4gIH07XG4gIHZhciBkcmF3T3ZlcmxheSA9IGZ1bmN0aW9uIGRyYXdPdmVybGF5KCkge1xuICAgIGlmICghc2hvdWxkRHJhd092ZXJsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgci5kcmF3RWRnZU92ZXJsYXkoY29udGV4dCwgZWRnZSk7XG4gIH07XG4gIHZhciBkcmF3VW5kZXJsYXkgPSBmdW5jdGlvbiBkcmF3VW5kZXJsYXkoKSB7XG4gICAgaWYgKCFzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByLmRyYXdFZGdlVW5kZXJsYXkoY29udGV4dCwgZWRnZSk7XG4gIH07XG4gIHZhciBkcmF3QXJyb3dzID0gZnVuY3Rpb24gZHJhd0Fycm93cygpIHtcbiAgICB2YXIgYXJyb3dPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBlZmZlY3RpdmVBcnJvd09wYWNpdHk7XG4gICAgci5kcmF3QXJyb3doZWFkcyhjb250ZXh0LCBlZGdlLCBhcnJvd09wYWNpdHkpO1xuICB9O1xuICB2YXIgZHJhd1RleHQgPSBmdW5jdGlvbiBkcmF3VGV4dCgpIHtcbiAgICByLmRyYXdFbGVtZW50VGV4dChjb250ZXh0LCBlZGdlLCBudWxsLCBkcmF3TGFiZWwpO1xuICB9O1xuICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgdmFyIGdob3N0ID0gZWRnZS5wc3R5bGUoJ2dob3N0JykudmFsdWUgPT09ICd5ZXMnO1xuICBpZiAoZ2hvc3QpIHtcbiAgICB2YXIgZ3ggPSBlZGdlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXgnKS5wZlZhbHVlO1xuICAgIHZhciBneSA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vZmZzZXQteScpLnBmVmFsdWU7XG4gICAgdmFyIGdob3N0T3BhY2l0eSA9IGVkZ2UucHN0eWxlKCdnaG9zdC1vcGFjaXR5JykudmFsdWU7XG4gICAgdmFyIGVmZmVjdGl2ZUdob3N0T3BhY2l0eSA9IGVmZmVjdGl2ZUxpbmVPcGFjaXR5ICogZ2hvc3RPcGFjaXR5O1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgZHJhd0xpbmUoZWZmZWN0aXZlR2hvc3RPcGFjaXR5KTtcbiAgICBkcmF3QXJyb3dzKGVmZmVjdGl2ZUdob3N0T3BhY2l0eSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuICB9IGVsc2Uge1xuICAgIGRyYXdMaW5lT3V0bGluZSgpO1xuICB9XG4gIGRyYXdVbmRlcmxheSgpO1xuICBkcmF3TGluZSgpO1xuICBkcmF3QXJyb3dzKCk7XG4gIGRyYXdPdmVybGF5KCk7XG4gIGRyYXdUZXh0KCk7XG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgfVxufTtcbnZhciBkcmF3RWRnZU92ZXJsYXlVbmRlcmxheSA9IGZ1bmN0aW9uIGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5KG92ZXJsYXlPclVuZGVybGF5KSB7XG4gIGlmICghWydvdmVybGF5JywgJ3VuZGVybGF5J10uaW5jbHVkZXMob3ZlcmxheU9yVW5kZXJsYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBlZGdlKSB7XG4gICAgaWYgKCFlZGdlLnZpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb3BhY2l0eSA9IGVkZ2UucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1vcGFjaXR5XCIpKS52YWx1ZTtcbiAgICBpZiAob3BhY2l0eSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHVzZVBhdGhzID0gci51c2VQYXRocygpO1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHBhZGRpbmcgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItcGFkZGluZ1wiKSkucGZWYWx1ZTtcbiAgICB2YXIgd2lkdGggPSAyICogcGFkZGluZztcbiAgICB2YXIgY29sb3IgPSBlZGdlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItY29sb3JcIikpLnZhbHVlO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VsZicgJiYgIXVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG4gICAgfVxuICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICByLmRyYXdFZGdlUGF0aChlZGdlLCBjb250ZXh0LCBycy5hbGxwdHMsICdzb2xpZCcpO1xuICB9O1xufTtcbkNScCQ5LmRyYXdFZGdlT3ZlcmxheSA9IGRyYXdFZGdlT3ZlcmxheVVuZGVybGF5KCdvdmVybGF5Jyk7XG5DUnAkOS5kcmF3RWRnZVVuZGVybGF5ID0gZHJhd0VkZ2VPdmVybGF5VW5kZXJsYXkoJ3VuZGVybGF5Jyk7XG5DUnAkOS5kcmF3RWRnZVBhdGggPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgcHRzLCB0eXBlKSB7XG4gIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjYW52YXNDeHQgPSBjb250ZXh0O1xuICB2YXIgcGF0aDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIHZhciBsaW5lRGFzaFBhdHRlcm4gPSBlZGdlLnBzdHlsZSgnbGluZS1kYXNoLXBhdHRlcm4nKS5wZlZhbHVlO1xuICB2YXIgbGluZURhc2hPZmZzZXQgPSBlZGdlLnBzdHlsZSgnbGluZS1kYXNoLW9mZnNldCcpLnBmVmFsdWU7XG4gIGlmICh1c2VQYXRocykge1xuICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBwdHMuam9pbignJCcpO1xuICAgIHZhciBrZXlNYXRjaGVzID0gcnMucGF0aENhY2hlS2V5ICYmIHJzLnBhdGhDYWNoZUtleSA9PT0gcGF0aENhY2hlS2V5O1xuICAgIGlmIChrZXlNYXRjaGVzKSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgcnMucGF0aENhY2hlID0gcGF0aDtcbiAgICB9XG4gIH1cbiAgaWYgKGNhbnZhc0N4dC5zZXRMaW5lRGFzaCkge1xuICAgIC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsxLCAxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKGxpbmVEYXNoUGF0dGVybik7XG4gICAgICAgIGNhbnZhc0N4dC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICghcGF0aENhY2hlSGl0ICYmICFycy5iYWRMaW5lKSB7XG4gICAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH1cbiAgICBjb250ZXh0Lm1vdmVUbyhwdHNbMF0sIHB0c1sxXSk7XG4gICAgc3dpdGNoIChycy5lZGdlVHlwZSkge1xuICAgICAgY2FzZSAnYmV6aWVyJzpcbiAgICAgIGNhc2UgJ3NlbGYnOlxuICAgICAgY2FzZSAnY29tcG91bmQnOlxuICAgICAgY2FzZSAnbXVsdGliZXppZXInOlxuICAgICAgICBmb3IgKHZhciBpID0gMjsgaSArIDMgPCBwdHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzW2ldLCBwdHNbaSArIDFdLCBwdHNbaSArIDJdLCBwdHNbaSArIDNdKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmFpZ2h0JzpcbiAgICAgIGNhc2UgJ2hheXN0YWNrJzpcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSArIDEgPCBwdHMubGVuZ3RoOyBfaSArPSAyKSB7XG4gICAgICAgICAgY29udGV4dC5saW5lVG8ocHRzW19pXSwgcHRzW19pICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VnbWVudHMnOlxuICAgICAgICBpZiAocnMuaXNSb3VuZCkge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihycy5yb3VuZENvcm5lcnMpLFxuICAgICAgICAgICAgX3N0ZXA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBjb3JuZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgZHJhd1ByZXBhcmVkUm91bmRDb3JuZXIoY29udGV4dCwgY29ybmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQubGluZVRvKHB0c1twdHMubGVuZ3RoIC0gMl0sIHB0c1twdHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDI7IF9pMiArIDEgPCBwdHMubGVuZ3RoOyBfaTIgKz0gMikge1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8ocHRzW19pMl0sIHB0c1tfaTIgKyAxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb250ZXh0ID0gY2FudmFzQ3h0O1xuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9XG5cbiAgLy8gcmVzZXQgYW55IGxpbmUgZGFzaGVzXG4gIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gIH1cbn07XG5DUnAkOS5kcmF3RWRnZVRyaWFuZ2xlUGF0aCA9IGZ1bmN0aW9uIChlZGdlLCBjb250ZXh0LCBwdHMpIHtcbiAgLy8gdXNlIGxpbmUgc3Ryb2tlIHN0eWxlIGZvciB0cmlhbmdsZSBmaWxsIHN0eWxlXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgdmFyIGVkZ2VXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gIGZvciAodmFyIGkgPSAwOyBpICsgMSA8IHB0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB2ZWN0b3IgPSBbcHRzW2kgKyAyXSAtIHB0c1tpXSwgcHRzW2kgKyAzXSAtIHB0c1tpICsgMV1dO1xuICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQodmVjdG9yWzBdICogdmVjdG9yWzBdICsgdmVjdG9yWzFdICogdmVjdG9yWzFdKTtcbiAgICB2YXIgbm9ybWFsID0gW3ZlY3RvclsxXSAvIGxlbmd0aCwgLXZlY3RvclswXSAvIGxlbmd0aF07XG4gICAgdmFyIHRyaWFuZ2xlSGVhZCA9IFtub3JtYWxbMF0gKiBlZGdlV2lkdGggLyAyLCBub3JtYWxbMV0gKiBlZGdlV2lkdGggLyAyXTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKHB0c1tpXSAtIHRyaWFuZ2xlSGVhZFswXSwgcHRzW2kgKyAxXSAtIHRyaWFuZ2xlSGVhZFsxXSk7XG4gICAgY29udGV4dC5saW5lVG8ocHRzW2ldICsgdHJpYW5nbGVIZWFkWzBdLCBwdHNbaSArIDFdICsgdHJpYW5nbGVIZWFkWzFdKTtcbiAgICBjb250ZXh0LmxpbmVUbyhwdHNbaSArIDJdLCBwdHNbaSArIDNdKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG59O1xuQ1JwJDkuZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgb3BhY2l0eSkge1xuICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuICBpZiAoIWlzSGF5c3RhY2spIHtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ3NvdXJjZScsIHJzLmFycm93U3RhcnRYLCBycy5hcnJvd1N0YXJ0WSwgcnMuc3JjQXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gIH1cbiAgdGhpcy5kcmF3QXJyb3doZWFkKGNvbnRleHQsIGVkZ2UsICdtaWQtdGFyZ2V0JywgcnMubWlkWCwgcnMubWlkWSwgcnMubWlkdGd0QXJyb3dBbmdsZSwgb3BhY2l0eSk7XG4gIHRoaXMuZHJhd0Fycm93aGVhZChjb250ZXh0LCBlZGdlLCAnbWlkLXNvdXJjZScsIHJzLm1pZFgsIHJzLm1pZFksIHJzLm1pZHNyY0Fycm93QW5nbGUsIG9wYWNpdHkpO1xuICBpZiAoIWlzSGF5c3RhY2spIHtcbiAgICB0aGlzLmRyYXdBcnJvd2hlYWQoY29udGV4dCwgZWRnZSwgJ3RhcmdldCcsIHJzLmFycm93RW5kWCwgcnMuYXJyb3dFbmRZLCBycy50Z3RBcnJvd0FuZ2xlLCBvcGFjaXR5KTtcbiAgfVxufTtcbkNScCQ5LmRyYXdBcnJvd2hlYWQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWRnZSwgcHJlZml4LCB4LCB5LCBhbmdsZSwgb3BhY2l0eSkge1xuICBpZiAoaXNOYU4oeCkgfHwgeCA9PSBudWxsIHx8IGlzTmFOKHkpIHx8IHkgPT0gbnVsbCB8fCBpc05hTihhbmdsZSkgfHwgYW5nbGUgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcnJvd1NoYXBlID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICBpZiAoYXJyb3dTaGFwZSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhcnJvd0NsZWFyRmlsbCA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctZmlsbCcpLnZhbHVlID09PSAnaG9sbG93JyA/ICdib3RoJyA6ICdmaWxsZWQnO1xuICB2YXIgYXJyb3dGaWxsID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1maWxsJykudmFsdWU7XG4gIHZhciBlZGdlV2lkdGggPSBlZGdlLnBzdHlsZSgnd2lkdGgnKS5wZlZhbHVlO1xuICB2YXIgcEFycm93V2lkdGggPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LXdpZHRoJyk7XG4gIHZhciBhcnJvd1dpZHRoID0gcEFycm93V2lkdGgudmFsdWUgPT09ICdtYXRjaC1saW5lJyA/IGVkZ2VXaWR0aCA6IHBBcnJvd1dpZHRoLnBmVmFsdWU7XG4gIGlmIChwQXJyb3dXaWR0aC51bml0cyA9PT0gJyUnKSBhcnJvd1dpZHRoICo9IGVkZ2VXaWR0aDtcbiAgdmFyIGVkZ2VPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ29wYWNpdHknKS52YWx1ZTtcbiAgaWYgKG9wYWNpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgIG9wYWNpdHkgPSBlZGdlT3BhY2l0eTtcbiAgfVxuICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gIGlmIChvcGFjaXR5ICE9PSAxIHx8IGFycm93RmlsbCA9PT0gJ2hvbGxvdycpIHtcbiAgICAvLyB0aGVuIGV4dHJhIGNsZWFyIGlzIG5lZWRlZFxuICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcbiAgICBzZWxmLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgc2VsZi5kcmF3QXJyb3dTaGFwZShlZGdlLCBjb250ZXh0LCBhcnJvd0NsZWFyRmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCBhcnJvd1dpZHRoLCB4LCB5LCBhbmdsZSk7XG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gIH0gLy8gb3RoZXJ3aXNlLCB0aGUgb3BhcXVlIGFycm93IGNsZWFycyBpdCBmb3IgZnJlZSA6KVxuXG4gIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKHByZWZpeCArICctYXJyb3ctY29sb3InKS52YWx1ZTtcbiAgc2VsZi5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgc2VsZi5jb2xvclN0cm9rZVN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICBzZWxmLmRyYXdBcnJvd1NoYXBlKGVkZ2UsIGNvbnRleHQsIGFycm93RmlsbCwgZWRnZVdpZHRoLCBhcnJvd1NoYXBlLCBhcnJvd1dpZHRoLCB4LCB5LCBhbmdsZSk7XG59O1xuQ1JwJDkuZHJhd0Fycm93U2hhcGUgPSBmdW5jdGlvbiAoZWRnZSwgY29udGV4dCwgZmlsbCwgZWRnZVdpZHRoLCBzaGFwZSwgc2hhcGVXaWR0aCwgeCwgeSwgYW5nbGUpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCkgJiYgc2hhcGUgIT09ICd0cmlhbmdsZS1jcm9zcyc7XG4gIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgdmFyIHBhdGg7XG4gIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgdmFyIHRyYW5zbGF0aW9uID0ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuICB2YXIgc2NhbGUgPSBlZGdlLnBzdHlsZSgnYXJyb3ctc2NhbGUnKS52YWx1ZTtcbiAgdmFyIHNpemUgPSB0aGlzLmdldEFycm93V2lkdGgoZWRnZVdpZHRoLCBzY2FsZSk7XG4gIHZhciBzaGFwZUltcGwgPSByLmFycm93U2hhcGVzW3NoYXBlXTtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgdmFyIGNhY2hlID0gci5hcnJvd1BhdGhDYWNoZSA9IHIuYXJyb3dQYXRoQ2FjaGUgfHwgW107XG4gICAgdmFyIGtleSA9IGhhc2hTdHJpbmcoc2hhcGUpO1xuICAgIHZhciBjYWNoZWRQYXRoID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkUGF0aCAhPSBudWxsKSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IGNhY2hlZFBhdGg7XG4gICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGNhY2hlW2tleV0gPSBwYXRoO1xuICAgIH1cbiAgfVxuICBpZiAoIXBhdGhDYWNoZUhpdCkge1xuICAgIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB9XG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAvLyBzdG9yZSBpbiB0aGUgcGF0aCBjYWNoZSB3aXRoIHZhbHVlcyBlYXNpbHkgbWFuaXB1bGF0ZWQgbGF0ZXJcbiAgICAgIHNoYXBlSW1wbC5kcmF3KGNvbnRleHQsIDEsIDAsIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlSW1wbC5kcmF3KGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiwgZWRnZVdpZHRoKTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQuY2xvc2VQYXRoKSB7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBjb250ZXh0ID0gY2FudmFzQ29udGV4dDtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgLy8gc2V0IHRyYW5zZm9ybSB0byBhcnJvdyBwb3NpdGlvbi9vcmllbnRhdGlvblxuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQucm90YXRlKGFuZ2xlKTtcbiAgICBjb250ZXh0LnNjYWxlKHNpemUsIHNpemUpO1xuICB9XG4gIGlmIChmaWxsID09PSAnZmlsbGVkJyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgIGNvbnRleHQuZmlsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9XG4gIGlmIChmaWxsID09PSAnaG9sbG93JyB8fCBmaWxsID09PSAnYm90aCcpIHtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHNoYXBlV2lkdGggLyAodXNlUGF0aHMgPyBzaXplIDogMSk7XG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICBjb250ZXh0LnN0cm9rZShwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgLy8gcmVzZXQgdHJhbnNmb3JtIGJ5IGFwcGx5aW5nIGludmVyc2VcbiAgICBjb250ZXh0LnNjYWxlKDEgLyBzaXplLCAxIC8gc2l6ZSk7XG4gICAgY29udGV4dC5yb3RhdGUoLWFuZ2xlKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9XG59O1xuXG52YXIgQ1JwJDggPSB7fTtcbkNScCQ4LnNhZmVEcmF3SW1hZ2UgPSBmdW5jdGlvbiAoY29udGV4dCwgaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCkge1xuICAvLyBkZXRlY3QgcHJvYmxlbWF0aWMgY2FzZXMgZm9yIG9sZCBicm93c2VycyB3aXRoIGJhZCBpbWFnZXMgKGNoZWFwZXIgdGhhbiB0cnktY2F0Y2gpXG4gIGlmIChpdyA8PSAwIHx8IGloIDw9IDAgfHwgdyA8PSAwIHx8IGggPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgaXgsIGl5LCBpdywgaWgsIHgsIHksIHcsIGgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgd2FybihlKTtcbiAgfVxufTtcbkNScCQ4LmRyYXdJbnNjcmliZWRJbWFnZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBpbWcsIG5vZGUsIGluZGV4LCBub2RlT3BhY2l0eSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIHZhciBub2RlWCA9IHBvcy54O1xuICB2YXIgbm9kZVkgPSBwb3MueTtcbiAgdmFyIHN0eWxlT2JqID0gbm9kZS5jeSgpLnN0eWxlKCk7XG4gIHZhciBnZXRJbmRleGVkU3R5bGUgPSBzdHlsZU9iai5nZXRJbmRleGVkU3R5bGUuYmluZChzdHlsZU9iaik7XG4gIHZhciBmaXQgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtZml0JywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgcmVwZWF0ID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXJlcGVhdCcsICd2YWx1ZScsIGluZGV4KTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgcGFkZGluZ1gyID0gbm9kZS5wYWRkaW5nKCkgKiAyO1xuICB2YXIgbm9kZVRXID0gbm9kZVcgKyAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoLXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gIHZhciBub2RlVEggPSBub2RlSCArIChnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaGVpZ2h0LXJlbGF0aXZlLXRvJywgJ3ZhbHVlJywgaW5kZXgpID09PSAnaW5uZXInID8gMCA6IHBhZGRpbmdYMik7XG4gIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHZhciBjbGlwID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWNsaXAnLCAndmFsdWUnLCBpbmRleCk7XG4gIHZhciBzaG91bGRDbGlwID0gY2xpcCA9PT0gJ25vZGUnO1xuICB2YXIgaW1nT3BhY2l0eSA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgJ3ZhbHVlJywgaW5kZXgpICogbm9kZU9wYWNpdHk7XG4gIHZhciBzbW9vdGggPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtaW1hZ2Utc21vb3RoaW5nJywgJ3ZhbHVlJywgaW5kZXgpO1xuICB2YXIgY29ybmVyUmFkaXVzID0gbm9kZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZTtcbiAgaWYgKGNvcm5lclJhZGl1cyAhPT0gJ2F1dG8nKSBjb3JuZXJSYWRpdXMgPSBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gIHZhciBpbWdXID0gaW1nLndpZHRoIHx8IGltZy5jYWNoZWRXO1xuICB2YXIgaW1nSCA9IGltZy5oZWlnaHQgfHwgaW1nLmNhY2hlZEg7XG5cbiAgLy8gd29ya2Fyb3VuZCBmb3IgYnJva2VuIGJyb3dzZXJzIGxpa2UgaWVcbiAgaWYgKG51bGwgPT0gaW1nVyB8fCBudWxsID09IGltZ0gpIHtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGltZyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxuICAgIGltZ1cgPSBpbWcuY2FjaGVkVyA9IGltZy53aWR0aCB8fCBpbWcub2Zmc2V0V2lkdGg7XG4gICAgaW1nSCA9IGltZy5jYWNoZWRIID0gaW1nLmhlaWdodCB8fCBpbWcub2Zmc2V0SGVpZ2h0O1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW1nKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICB9XG4gIHZhciB3ID0gaW1nVztcbiAgdmFyIGggPSBpbWdIO1xuICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3ZhbHVlJywgaW5kZXgpICE9PSAnYXV0bycpIHtcbiAgICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXdpZHRoJywgJ3VuaXRzJywgaW5kZXgpID09PSAnJScpIHtcbiAgICAgIHcgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtd2lkdGgnLCAncGZWYWx1ZScsIGluZGV4KSAqIG5vZGVUVztcbiAgICB9IGVsc2Uge1xuICAgICAgdyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC13aWR0aCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICAgIH1cbiAgfVxuICBpZiAoZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWhlaWdodCcsICd2YWx1ZScsIGluZGV4KSAhPT0gJ2F1dG8nKSB7XG4gICAgaWYgKGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAndW5pdHMnLCBpbmRleCkgPT09ICclJykge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KSAqIG5vZGVUSDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1oZWlnaHQnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgICB9XG4gIH1cbiAgaWYgKHcgPT09IDAgfHwgaCA9PT0gMCkge1xuICAgIHJldHVybjsgLy8gbm8gcG9pbnQgaW4gZHJhd2luZyBlbXB0eSBpbWFnZSAoYW5kIGNocm9tZSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlKVxuICB9XG4gIGlmIChmaXQgPT09ICdjb250YWluJykge1xuICAgIHZhciBzY2FsZSA9IE1hdGgubWluKG5vZGVUVyAvIHcsIG5vZGVUSCAvIGgpO1xuICAgIHcgKj0gc2NhbGU7XG4gICAgaCAqPSBzY2FsZTtcbiAgfSBlbHNlIGlmIChmaXQgPT09ICdjb3ZlcicpIHtcbiAgICB2YXIgc2NhbGUgPSBNYXRoLm1heChub2RlVFcgLyB3LCBub2RlVEggLyBoKTtcbiAgICB3ICo9IHNjYWxlO1xuICAgIGggKj0gc2NhbGU7XG4gIH1cbiAgdmFyIHggPSBub2RlWCAtIG5vZGVUVyAvIDI7IC8vIGxlZnRcbiAgdmFyIHBvc1hVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgJ3VuaXRzJywgaW5kZXgpO1xuICB2YXIgcG9zWFBmVmFsID0gZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgaWYgKHBvc1hVbml0cyA9PT0gJyUnKSB7XG4gICAgeCArPSAobm9kZVRXIC0gdykgKiBwb3NYUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeCArPSBwb3NYUGZWYWw7XG4gIH1cbiAgdmFyIG9mZlhVbml0cyA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIG9mZlhQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1vZmZzZXQteCcsICdwZlZhbHVlJywgaW5kZXgpO1xuICBpZiAob2ZmWFVuaXRzID09PSAnJScpIHtcbiAgICB4ICs9IChub2RlVFcgLSB3KSAqIG9mZlhQZlZhbDtcbiAgfSBlbHNlIHtcbiAgICB4ICs9IG9mZlhQZlZhbDtcbiAgfVxuICB2YXIgeSA9IG5vZGVZIC0gbm9kZVRIIC8gMjsgLy8gdG9wXG4gIHZhciBwb3NZVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtcG9zaXRpb24teScsICd1bml0cycsIGluZGV4KTtcbiAgdmFyIHBvc1lQZlZhbCA9IGdldEluZGV4ZWRTdHlsZShub2RlLCAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgJ3BmVmFsdWUnLCBpbmRleCk7XG4gIGlmIChwb3NZVW5pdHMgPT09ICclJykge1xuICAgIHkgKz0gKG5vZGVUSCAtIGgpICogcG9zWVBmVmFsO1xuICB9IGVsc2Uge1xuICAgIHkgKz0gcG9zWVBmVmFsO1xuICB9XG4gIHZhciBvZmZZVW5pdHMgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXknLCAndW5pdHMnLCBpbmRleCk7XG4gIHZhciBvZmZZUGZWYWwgPSBnZXRJbmRleGVkU3R5bGUobm9kZSwgJ2JhY2tncm91bmQtb2Zmc2V0LXknLCAncGZWYWx1ZScsIGluZGV4KTtcbiAgaWYgKG9mZllVbml0cyA9PT0gJyUnKSB7XG4gICAgeSArPSAobm9kZVRIIC0gaCkgKiBvZmZZUGZWYWw7XG4gIH0gZWxzZSB7XG4gICAgeSArPSBvZmZZUGZWYWw7XG4gIH1cbiAgaWYgKHJzLnBhdGhDYWNoZSkge1xuICAgIHggLT0gbm9kZVg7XG4gICAgeSAtPSBub2RlWTtcbiAgICBub2RlWCA9IDA7XG4gICAgbm9kZVkgPSAwO1xuICB9XG4gIHZhciBnQWxwaGEgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuICBjb250ZXh0Lmdsb2JhbEFscGhhID0gaW1nT3BhY2l0eTtcbiAgdmFyIHNtb290aGluZ0VuYWJsZWQgPSByLmdldEltZ1Ntb290aGluZyhjb250ZXh0KTtcbiAgdmFyIGlzU21vb3RoaW5nU3dpdGNoZWQgPSBmYWxzZTtcbiAgaWYgKHNtb290aCA9PT0gJ25vJyAmJiBzbW9vdGhpbmdFbmFibGVkKSB7XG4gICAgci5zZXRJbWdTbW9vdGhpbmcoY29udGV4dCwgZmFsc2UpO1xuICAgIGlzU21vb3RoaW5nU3dpdGNoZWQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHNtb290aCA9PT0gJ3llcycgJiYgIXNtb290aGluZ0VuYWJsZWQpIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCB0cnVlKTtcbiAgICBpc1Ntb290aGluZ1N3aXRjaGVkID0gdHJ1ZTtcbiAgfVxuICBpZiAocmVwZWF0ID09PSAnbm8tcmVwZWF0Jykge1xuICAgIGlmIChzaG91bGRDbGlwKSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGlmIChycy5wYXRoQ2FjaGUpIHtcbiAgICAgICAgY29udGV4dC5jbGlwKHJzLnBhdGhDYWNoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgbm9kZVgsIG5vZGVZLCBub2RlVFcsIG5vZGVUSCwgY29ybmVyUmFkaXVzLCBycyk7XG4gICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByLnNhZmVEcmF3SW1hZ2UoY29udGV4dCwgaW1nLCAwLCAwLCBpbWdXLCBpbWdILCB4LCB5LCB3LCBoKTtcbiAgICBpZiAoc2hvdWxkQ2xpcCkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKGltZywgcmVwZWF0KTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIG5vZGVYLCBub2RlWSwgbm9kZVRXLCBub2RlVEgsIGNvcm5lclJhZGl1cywgcnMpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cbiAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGdBbHBoYTtcbiAgaWYgKGlzU21vb3RoaW5nU3dpdGNoZWQpIHtcbiAgICByLnNldEltZ1Ntb290aGluZyhjb250ZXh0LCBzbW9vdGhpbmdFbmFibGVkKTtcbiAgfVxufTtcblxudmFyIENScCQ3ID0ge307XG5DUnAkNy5lbGVUZXh0QmlnZ2VyVGhhbk1pbiA9IGZ1bmN0aW9uIChlbGUsIHNjYWxlKSB7XG4gIGlmICghc2NhbGUpIHtcbiAgICB2YXIgem9vbSA9IGVsZS5jeSgpLnpvb20oKTtcbiAgICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHZhciBsdmwgPSBNYXRoLmNlaWwobG9nMih6b29tICogcHhSYXRpbykpOyAvLyB0aGUgZWZmZWN0aXZlIHRleHR1cmUgbGV2ZWxcblxuICAgIHNjYWxlID0gTWF0aC5wb3coMiwgbHZsKTtcbiAgfVxuICB2YXIgY29tcHV0ZWRTaXplID0gZWxlLnBzdHlsZSgnZm9udC1zaXplJykucGZWYWx1ZSAqIHNjYWxlO1xuICB2YXIgbWluU2l6ZSA9IGVsZS5wc3R5bGUoJ21pbi16b29tZWQtZm9udC1zaXplJykucGZWYWx1ZTtcbiAgaWYgKGNvbXB1dGVkU2l6ZSA8IG1pblNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuQ1JwJDcuZHJhd0VsZW1lbnRUZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgc2hpZnRUb09yaWdpbldpdGhCYiwgZm9yY2UsIHByZWZpeCkge1xuICB2YXIgdXNlRWxlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogdHJ1ZTtcbiAgdmFyIHIgPSB0aGlzO1xuICBpZiAoZm9yY2UgPT0gbnVsbCkge1xuICAgIGlmICh1c2VFbGVPcGFjaXR5ICYmICFyLmVsZVRleHRCaWdnZXJUaGFuTWluKGVsZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9yY2UgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKCdsYWJlbCcpO1xuICAgIGlmICghbGFiZWwgfHwgIWxhYmVsLnZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBqdXN0aWZpY2F0aW9uID0gci5nZXRMYWJlbEp1c3RpZmljYXRpb24oZWxlKTtcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9IGp1c3RpZmljYXRpb247XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmFkTGluZSA9IGVsZS5lbGVtZW50KCkuX3ByaXZhdGUucnNjcmF0Y2guYmFkTGluZTtcbiAgICB2YXIgX2xhYmVsID0gZWxlLnBzdHlsZSgnbGFiZWwnKTtcbiAgICB2YXIgc3JjTGFiZWwgPSBlbGUucHN0eWxlKCdzb3VyY2UtbGFiZWwnKTtcbiAgICB2YXIgdGd0TGFiZWwgPSBlbGUucHN0eWxlKCd0YXJnZXQtbGFiZWwnKTtcbiAgICBpZiAoYmFkTGluZSB8fCAoIV9sYWJlbCB8fCAhX2xhYmVsLnZhbHVlKSAmJiAoIXNyY0xhYmVsIHx8ICFzcmNMYWJlbC52YWx1ZSkgJiYgKCF0Z3RMYWJlbCB8fCAhdGd0TGFiZWwudmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgfVxuICB2YXIgYXBwbHlSb3RhdGlvbiA9ICFzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICB2YXIgYmI7XG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgYmIgPSBzaGlmdFRvT3JpZ2luV2l0aEJiO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1iYi54MSwgLWJiLnkxKTtcbiAgfVxuICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICByLmRyYXdUZXh0KGNvbnRleHQsIGVsZSwgbnVsbCwgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgci5kcmF3VGV4dChjb250ZXh0LCBlbGUsICdzb3VyY2UnLCBhcHBseVJvdGF0aW9uLCB1c2VFbGVPcGFjaXR5KTtcbiAgICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCAndGFyZ2V0JywgYXBwbHlSb3RhdGlvbiwgdXNlRWxlT3BhY2l0eSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHIuZHJhd1RleHQoY29udGV4dCwgZWxlLCBwcmVmaXgsIGFwcGx5Um90YXRpb24sIHVzZUVsZU9wYWNpdHkpO1xuICB9XG4gIGlmIChzaGlmdFRvT3JpZ2luV2l0aEJiKSB7XG4gICAgY29udGV4dC50cmFuc2xhdGUoYmIueDEsIGJiLnkxKTtcbiAgfVxufTtcbkNScCQ3LmdldEZvbnRDYWNoZSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIHZhciBjYWNoZTtcbiAgdGhpcy5mb250Q2FjaGVzID0gdGhpcy5mb250Q2FjaGVzIHx8IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZm9udENhY2hlcy5sZW5ndGg7IGkrKykge1xuICAgIGNhY2hlID0gdGhpcy5mb250Q2FjaGVzW2ldO1xuICAgIGlmIChjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICB9XG4gIGNhY2hlID0ge1xuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfTtcbiAgdGhpcy5mb250Q2FjaGVzLnB1c2goY2FjaGUpO1xuICByZXR1cm4gY2FjaGU7XG59O1xuXG4vLyBzZXQgdXAgY2FudmFzIGNvbnRleHQgd2l0aCBmb250XG4vLyByZXR1cm5zIHRyYW5zZm9ybWVkIHRleHQgc3RyaW5nXG5DUnAkNy5zZXR1cFRleHRTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUpIHtcbiAgdmFyIHVzZUVsZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gIC8vIEZvbnQgc3R5bGVcbiAgdmFyIGxhYmVsU3R5bGUgPSBlbGUucHN0eWxlKCdmb250LXN0eWxlJykuc3RyVmFsdWU7XG4gIHZhciBsYWJlbFNpemUgPSBlbGUucHN0eWxlKCdmb250LXNpemUnKS5wZlZhbHVlICsgJ3B4JztcbiAgdmFyIGxhYmVsRmFtaWx5ID0gZWxlLnBzdHlsZSgnZm9udC1mYW1pbHknKS5zdHJWYWx1ZTtcbiAgdmFyIGxhYmVsV2VpZ2h0ID0gZWxlLnBzdHlsZSgnZm9udC13ZWlnaHQnKS5zdHJWYWx1ZTtcbiAgdmFyIG9wYWNpdHkgPSB1c2VFbGVPcGFjaXR5ID8gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSAqIGVsZS5wc3R5bGUoJ3RleHQtb3BhY2l0eScpLnZhbHVlIDogMTtcbiAgdmFyIG91dGxpbmVPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1vdXRsaW5lLW9wYWNpdHknKS52YWx1ZSAqIG9wYWNpdHk7XG4gIHZhciBjb2xvciA9IGVsZS5wc3R5bGUoJ2NvbG9yJykudmFsdWU7XG4gIHZhciBvdXRsaW5lQ29sb3IgPSBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtY29sb3InKS52YWx1ZTtcbiAgY29udGV4dC5mb250ID0gbGFiZWxTdHlsZSArICcgJyArIGxhYmVsV2VpZ2h0ICsgJyAnICsgbGFiZWxTaXplICsgJyAnICsgbGFiZWxGYW1pbHk7XG4gIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnOyAvLyBzbyB0ZXh0IG91dGxpbmVzIGFyZW4ndCBqYWdnZWRcblxuICB0aGlzLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuICB0aGlzLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgb3V0bGluZUNvbG9yWzBdLCBvdXRsaW5lQ29sb3JbMV0sIG91dGxpbmVDb2xvclsyXSwgb3V0bGluZU9wYWNpdHkpO1xufTtcbmZ1bmN0aW9uIGNpcmNsZShjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGRpYW1ldGVyID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gIHZhciByYWRpdXMgPSBkaWFtZXRlciAvIDI7XG4gIHZhciBjZW50ZXJYID0geCArIHdpZHRoIC8gMjtcbiAgdmFyIGNlbnRlclkgPSB5ICsgaGVpZ2h0IC8gMjtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG5mdW5jdGlvbiByb3VuZFJlY3QoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciByYWRpdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDU7XG4gIHZhciByID0gTWF0aC5taW4ocmFkaXVzLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpOyAvLyBwcmV2ZW50IG92ZXJmbG93XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4ICsgciwgeSk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gciwgeSk7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcik7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcik7XG4gIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gciwgeSArIGhlaWdodCk7XG4gIGN0eC5saW5lVG8oeCArIHIsIHkgKyBoZWlnaHQpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcik7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIpO1xuICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgciwgeSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbkNScCQ3LmdldFRleHRBbmdsZSA9IGZ1bmN0aW9uIChlbGUsIHByZWZpeCkge1xuICB2YXIgdGhldGE7XG4gIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgdmFyIHJzY3JhdGNoID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwZGFzaCA9IHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnO1xuICB2YXIgcm90YXRpb24gPSBlbGUucHN0eWxlKHBkYXNoICsgJ3RleHQtcm90YXRpb24nKTtcbiAgaWYgKHJvdGF0aW9uLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZScpIHtcbiAgICB2YXIgdGV4dEFuZ2xlID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsQW5nbGUnLCBwcmVmaXgpO1xuICAgIHRoZXRhID0gZWxlLmlzRWRnZSgpID8gdGV4dEFuZ2xlIDogMDtcbiAgfSBlbHNlIGlmIChyb3RhdGlvbi5zdHJWYWx1ZSA9PT0gJ25vbmUnKSB7XG4gICAgdGhldGEgPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoZXRhID0gcm90YXRpb24ucGZWYWx1ZTtcbiAgfVxuICByZXR1cm4gdGhldGE7XG59O1xuQ1JwJDcuZHJhd1RleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBwcmVmaXgpIHtcbiAgdmFyIGFwcGx5Um90YXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHRydWU7XG4gIHZhciB1c2VFbGVPcGFjaXR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gIHZhciByc2NyYXRjaCA9IF9wLnJzY3JhdGNoO1xuICB2YXIgcGFyZW50T3BhY2l0eSA9IHVzZUVsZU9wYWNpdHkgPyBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpIDogMTtcbiAgaWYgKHVzZUVsZU9wYWNpdHkgJiYgKHBhcmVudE9wYWNpdHkgPT09IDAgfHwgZWxlLnBzdHlsZSgndGV4dC1vcGFjaXR5JykudmFsdWUgPT09IDApKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gdXNlICdtYWluJyBhcyBhbiBhbGlhcyBmb3IgdGhlIG1haW4gbGFiZWwgKGkuZS4gbnVsbCBwcmVmaXgpXG4gIGlmIChwcmVmaXggPT09ICdtYWluJykge1xuICAgIHByZWZpeCA9IG51bGw7XG4gIH1cbiAgdmFyIHRleHRYID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsWCcsIHByZWZpeCk7XG4gIHZhciB0ZXh0WSA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFknLCBwcmVmaXgpO1xuICB2YXIgb3JnVGV4dFgsIG9yZ1RleHRZOyAvLyB1c2VkIGZvciByb3RhdGlvblxuICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KGVsZSwgcHJlZml4KTtcbiAgaWYgKHRleHQgIT0gbnVsbCAmJiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dFgpICYmICFpc05hTih0ZXh0WSkpIHtcbiAgICB0aGlzLnNldHVwVGV4dFN0eWxlKGNvbnRleHQsIGVsZSwgdXNlRWxlT3BhY2l0eSk7XG4gICAgdmFyIHBkYXNoID0gcHJlZml4ID8gcHJlZml4ICsgJy0nIDogJyc7XG4gICAgdmFyIHRleHRXID0gZ2V0UHJlZml4ZWRQcm9wZXJ0eShyc2NyYXRjaCwgJ2xhYmVsV2lkdGgnLCBwcmVmaXgpO1xuICAgIHZhciB0ZXh0SCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbEhlaWdodCcsIHByZWZpeCk7XG4gICAgdmFyIG1hcmdpblggPSBlbGUucHN0eWxlKHBkYXNoICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlO1xuICAgIHZhciBtYXJnaW5ZID0gZWxlLnBzdHlsZShwZGFzaCArICd0ZXh0LW1hcmdpbi15JykucGZWYWx1ZTtcbiAgICB2YXIgaXNFZGdlID0gZWxlLmlzRWRnZSgpO1xuICAgIHZhciBoYWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LWhhbGlnbicpLnZhbHVlO1xuICAgIHZhciB2YWxpZ24gPSBlbGUucHN0eWxlKCd0ZXh0LXZhbGlnbicpLnZhbHVlO1xuICAgIGlmIChpc0VkZ2UpIHtcbiAgICAgIGhhbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdmFsaWduID0gJ2NlbnRlcic7XG4gICAgfVxuICAgIHRleHRYICs9IG1hcmdpblg7XG4gICAgdGV4dFkgKz0gbWFyZ2luWTtcbiAgICB2YXIgdGhldGE7XG4gICAgaWYgKCFhcHBseVJvdGF0aW9uKSB7XG4gICAgICB0aGV0YSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZXRhID0gdGhpcy5nZXRUZXh0QW5nbGUoZWxlLCBwcmVmaXgpO1xuICAgIH1cbiAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgIG9yZ1RleHRYID0gdGV4dFg7XG4gICAgICBvcmdUZXh0WSA9IHRleHRZO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUob3JnVGV4dFgsIG9yZ1RleHRZKTtcbiAgICAgIGNvbnRleHQucm90YXRlKHRoZXRhKTtcbiAgICAgIHRleHRYID0gMDtcbiAgICAgIHRleHRZID0gMDtcbiAgICB9XG4gICAgc3dpdGNoICh2YWxpZ24pIHtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgdGV4dFkgKz0gdGV4dEggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIHRleHRZICs9IHRleHRIO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGJhY2tncm91bmRPcGFjaXR5ID0gZWxlLnBzdHlsZSgndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgYm9yZGVyT3BhY2l0eSA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLW9wYWNpdHknKS52YWx1ZTtcbiAgICB2YXIgdGV4dEJvcmRlcldpZHRoID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItd2lkdGgnKS5wZlZhbHVlO1xuICAgIHZhciBiYWNrZ3JvdW5kUGFkZGluZyA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1wYWRkaW5nJykucGZWYWx1ZTtcbiAgICB2YXIgc3R5bGVTaGFwZSA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1zaGFwZScpLnN0clZhbHVlO1xuICAgIHZhciByb3VuZGVkID0gc3R5bGVTaGFwZSA9PT0gJ3JvdW5kLXJlY3RhbmdsZScgfHwgc3R5bGVTaGFwZSA9PT0gJ3JvdW5kcmVjdGFuZ2xlJztcbiAgICB2YXIgY2lyY2xlZCA9IHN0eWxlU2hhcGUgPT09ICdjaXJjbGUnO1xuICAgIHZhciByb3VuZFJhZGl1cyA9IDI7XG4gICAgaWYgKGJhY2tncm91bmRPcGFjaXR5ID4gMCB8fCB0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwKSB7XG4gICAgICB2YXIgdGV4dEZpbGwgPSBjb250ZXh0LmZpbGxTdHlsZTtcbiAgICAgIHZhciB0ZXh0U3Ryb2tlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICAgIHZhciB0ZXh0TGluZVdpZHRoID0gY29udGV4dC5saW5lV2lkdGg7XG4gICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgICAgdmFyIHRleHRCb3JkZXJDb2xvciA9IGVsZS5wc3R5bGUoJ3RleHQtYm9yZGVyLWNvbG9yJykudmFsdWU7XG4gICAgICB2YXIgdGV4dEJvcmRlclN0eWxlID0gZWxlLnBzdHlsZSgndGV4dC1ib3JkZXItc3R5bGUnKS52YWx1ZTtcbiAgICAgIHZhciBkb0ZpbGwgPSBiYWNrZ3JvdW5kT3BhY2l0eSA+IDA7XG4gICAgICB2YXIgZG9TdHJva2UgPSB0ZXh0Qm9yZGVyV2lkdGggPiAwICYmIGJvcmRlck9wYWNpdHkgPiAwO1xuICAgICAgdmFyIGJnWCA9IHRleHRYIC0gYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBiZ1ggLT0gdGV4dFc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgYmdYIC09IHRleHRXIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhciBiZ1kgPSB0ZXh0WSAtIHRleHRIIC0gYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdXID0gdGV4dFcgKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICB2YXIgYmdIID0gdGV4dEggKyAyICogYmFja2dyb3VuZFBhZGRpbmc7XG4gICAgICBpZiAoZG9GaWxsKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKFwiLmNvbmNhdCh0ZXh0QmFja2dyb3VuZENvbG9yWzBdLCBcIixcIikuY29uY2F0KHRleHRCYWNrZ3JvdW5kQ29sb3JbMV0sIFwiLFwiKS5jb25jYXQodGV4dEJhY2tncm91bmRDb2xvclsyXSwgXCIsXCIpLmNvbmNhdChiYWNrZ3JvdW5kT3BhY2l0eSAqIHBhcmVudE9wYWNpdHksIFwiKVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb1N0cm9rZSkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZ2JhKFwiLmNvbmNhdCh0ZXh0Qm9yZGVyQ29sb3JbMF0sIFwiLFwiKS5jb25jYXQodGV4dEJvcmRlckNvbG9yWzFdLCBcIixcIikuY29uY2F0KHRleHRCb3JkZXJDb2xvclsyXSwgXCIsXCIpLmNvbmNhdChib3JkZXJPcGFjaXR5ICogcGFyZW50T3BhY2l0eSwgXCIpXCIpO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aDtcbiAgICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgICBzd2l0Y2ggKHRleHRCb3JkZXJTdHlsZSkge1xuICAgICAgICAgICAgY2FzZSAnZG90dGVkJzpcbiAgICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzQsIDJdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRleHRCb3JkZXJXaWR0aCAvIDQ7XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyb3VuZGVkKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIHJvdW5kUmVjdChjb250ZXh0LCBiZ1gsIGJnWSwgYmdXLCBiZ0gsIHJvdW5kUmFkaXVzKTtcbiAgICAgIH0gZWxzZSBpZiAoY2lyY2xlZCkge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjaXJjbGUoY29udGV4dCwgYmdYLCBiZ1ksIGJnVywgYmdIKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQucmVjdChiZ1gsIGJnWSwgYmdXLCBiZ0gpO1xuICAgICAgfVxuICAgICAgaWYgKGRvRmlsbCkgY29udGV4dC5maWxsKCk7XG4gICAgICBpZiAoZG9TdHJva2UpIGNvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgIC8vIERvdWJsZSBib3JkZXIgcGFzcyBmb3IgJ2RvdWJsZScgc3R5bGVcbiAgICAgIGlmIChkb1N0cm9rZSAmJiB0ZXh0Qm9yZGVyU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgIHZhciB3aGl0ZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoIC8gMjtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgaWYgKHJvdW5kZWQpIHtcbiAgICAgICAgICByb3VuZFJlY3QoY29udGV4dCwgYmdYICsgd2hpdGVXaWR0aCwgYmdZICsgd2hpdGVXaWR0aCwgYmdXIC0gMiAqIHdoaXRlV2lkdGgsIGJnSCAtIDIgKiB3aGl0ZVdpZHRoLCByb3VuZFJhZGl1cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5yZWN0KGJnWCArIHdoaXRlV2lkdGgsIGJnWSArIHdoaXRlV2lkdGgsIGJnVyAtIDIgKiB3aGl0ZVdpZHRoLCBiZ0ggLSAyICogd2hpdGVXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGV4dEZpbGw7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dExpbmVXaWR0aDtcbiAgICAgIGlmIChjb250ZXh0LnNldExpbmVEYXNoKSBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICB9XG4gICAgdmFyIGxpbmVXaWR0aCA9IDIgKiBlbGUucHN0eWxlKCd0ZXh0LW91dGxpbmUtd2lkdGgnKS5wZlZhbHVlOyAvLyAqMiBiL2MgdGhlIHN0cm9rZSBpcyBkcmF3biBjZW50cmVkIG9uIHRoZSBtaWRkbGVcblxuICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICB9XG4gICAgaWYgKGVsZS5wc3R5bGUoJ3RleHQtd3JhcCcpLnZhbHVlID09PSAnd3JhcCcpIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbFdyYXBDYWNoZWRMaW5lcycsIHByZWZpeCk7XG4gICAgICB2YXIgbGluZUhlaWdodCA9IGdldFByZWZpeGVkUHJvcGVydHkocnNjcmF0Y2gsICdsYWJlbExpbmVIZWlnaHQnLCBwcmVmaXgpO1xuICAgICAgdmFyIGhhbGZUZXh0VyA9IHRleHRXIC8gMjtcbiAgICAgIHZhciBqdXN0aWZpY2F0aW9uID0gdGhpcy5nZXRMYWJlbEp1c3RpZmljYXRpb24oZWxlKTtcbiAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnYXV0bycpIDsgZWxzZSBpZiAoaGFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgLy8gYXV0byBqdXN0aWZpY2F0aW9uIDogcmlnaHRcbiAgICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgIHRleHRYICs9IC10ZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRYICs9IC1oYWxmVGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cbiAgICAgIH0gZWxzZSBpZiAoaGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAvLyBhdXRvIGp1c3RmaWNhdGlvbiA6IGNlbnRlclxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gLWhhbGZUZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gaGFsZlRleHRXO1xuICAgICAgICB9IC8vIGVsc2Ugc2FtZSBhcyBhdXRvXG4gICAgICB9IGVsc2UgaWYgKGhhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAvLyBhdXRvIGp1c3RpZmljYXRpb24gOiBsZWZ0XG4gICAgICAgIGlmIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRYICs9IGhhbGZUZXh0VztcbiAgICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgdGV4dFggKz0gdGV4dFc7XG4gICAgICAgIH0gLy8gZWxzZSBzYW1lIGFzIGF1dG9cbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodmFsaWduKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgdGV4dFkgLT0gKGxpbmVzLmxlbmd0aCAtIDEpICogbGluZUhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0ZXh0WSAtPSAobGluZXMubGVuZ3RoIC0gMSkgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKykge1xuICAgICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChsaW5lc1tsXSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGV4dCwgdGV4dFgsIHRleHRZKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgdGV4dFgsIHRleHRZKTtcbiAgICB9XG4gICAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtdGhldGEpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoLW9yZ1RleHRYLCAtb3JnVGV4dFkpO1xuICAgIH1cbiAgfVxufTtcblxuLyogZ2xvYmFsIFBhdGgyRCAqL1xuXG52YXIgQ1JwJDYgPSB7fTtcbkNScCQ2LmRyYXdOb2RlID0gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgdmFyIGRyYXdMYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgdmFyIHNob3VsZERyYXdPdmVybGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB0cnVlO1xuICB2YXIgc2hvdWxkRHJhd09wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHRydWU7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIG5vZGVXaWR0aCwgbm9kZUhlaWdodDtcbiAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG4gIGlmICghbnVtYmVyJDEocG9zLngpIHx8ICFudW1iZXIkMShwb3MueSkpIHtcbiAgICByZXR1cm47IC8vIGNhbid0IGRyYXcgbm9kZSB3aXRoIHVuZGVmaW5lZCBwb3NpdGlvblxuICB9XG4gIGlmIChzaG91bGREcmF3T3BhY2l0eSAmJiAhbm9kZS52aXNpYmxlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGVsZU9wYWNpdHkgPSBzaG91bGREcmF3T3BhY2l0eSA/IG5vZGUuZWZmZWN0aXZlT3BhY2l0eSgpIDogMTtcbiAgdmFyIHVzZVBhdGhzID0gci51c2VQYXRocygpO1xuICB2YXIgcGF0aDtcbiAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICB2YXIgcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICBub2RlV2lkdGggPSBub2RlLndpZHRoKCkgKyAyICogcGFkZGluZztcbiAgbm9kZUhlaWdodCA9IG5vZGUuaGVpZ2h0KCkgKyAyICogcGFkZGluZztcblxuICAvL1xuICAvLyBzZXR1cCBzaGlmdFxuXG4gIHZhciBiYjtcbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBiYiA9IHNoaWZ0VG9PcmlnaW5XaXRoQmI7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLWJiLngxLCAtYmIueTEpO1xuICB9XG5cbiAgLy9cbiAgLy8gbG9hZCBiZyBpbWFnZVxuXG4gIHZhciBiZ0ltZ1Byb3AgPSBub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1pbWFnZScpO1xuICB2YXIgdXJscyA9IGJnSW1nUHJvcC52YWx1ZTtcbiAgdmFyIHVybERlZmluZWQgPSBuZXcgQXJyYXkodXJscy5sZW5ndGgpO1xuICB2YXIgaW1hZ2UgPSBuZXcgQXJyYXkodXJscy5sZW5ndGgpO1xuICB2YXIgbnVtSW1hZ2VzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHVybCA9IHVybHNbaV07XG4gICAgdmFyIGRlZmQgPSB1cmxEZWZpbmVkW2ldID0gdXJsICE9IG51bGwgJiYgdXJsICE9PSAnbm9uZSc7XG4gICAgaWYgKGRlZmQpIHtcbiAgICAgIHZhciBiZ0ltZ0Nyb3NzT3JpZ2luID0gbm9kZS5jeSgpLnN0eWxlKCkuZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLWNyb3Nzb3JpZ2luJywgJ3ZhbHVlJywgaSk7XG4gICAgICBudW1JbWFnZXMrKztcblxuICAgICAgLy8gZ2V0IGltYWdlLCBhbmQgaWYgbm90IGxvYWRlZCB0aGVuIGFzayB0byByZWRyYXcgd2hlbiBsYXRlciBsb2FkZWRcbiAgICAgIGltYWdlW2ldID0gci5nZXRDYWNoZWRJbWFnZSh1cmwsIGJnSW1nQ3Jvc3NPcmlnaW4sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3AuYmFja2dyb3VuZFRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICAgIG5vZGUuZW1pdEFuZE5vdGlmeSgnYmFja2dyb3VuZCcpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gc2V0dXAgc3R5bGVzXG5cbiAgdmFyIGRhcmtuZXNzID0gbm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtYmxhY2tlbicpLnZhbHVlO1xuICB2YXIgYm9yZGVyV2lkdGggPSBub2RlLnBzdHlsZSgnYm9yZGVyLXdpZHRoJykucGZWYWx1ZTtcbiAgdmFyIGJnT3BhY2l0eSA9IG5vZGUucHN0eWxlKCdiYWNrZ3JvdW5kLW9wYWNpdHknKS52YWx1ZSAqIGVsZU9wYWNpdHk7XG4gIHZhciBib3JkZXJDb2xvciA9IG5vZGUucHN0eWxlKCdib3JkZXItY29sb3InKS52YWx1ZTtcbiAgdmFyIGJvcmRlclN0eWxlID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1zdHlsZScpLnZhbHVlO1xuICB2YXIgYm9yZGVySm9pbiA9IG5vZGUucHN0eWxlKCdib3JkZXItam9pbicpLnZhbHVlO1xuICB2YXIgYm9yZGVyQ2FwID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1jYXAnKS52YWx1ZTtcbiAgdmFyIGJvcmRlclBvc2l0aW9uID0gbm9kZS5wc3R5bGUoJ2JvcmRlci1wb3NpdGlvbicpLnZhbHVlO1xuICB2YXIgYm9yZGVyUGF0dGVybiA9IG5vZGUucHN0eWxlKCdib3JkZXItZGFzaC1wYXR0ZXJuJykucGZWYWx1ZTtcbiAgdmFyIGJvcmRlck9mZnNldCA9IG5vZGUucHN0eWxlKCdib3JkZXItZGFzaC1vZmZzZXQnKS5wZlZhbHVlO1xuICB2YXIgYm9yZGVyT3BhY2l0eSA9IG5vZGUucHN0eWxlKCdib3JkZXItb3BhY2l0eScpLnZhbHVlICogZWxlT3BhY2l0eTtcbiAgdmFyIG91dGxpbmVXaWR0aCA9IG5vZGUucHN0eWxlKCdvdXRsaW5lLXdpZHRoJykucGZWYWx1ZTtcbiAgdmFyIG91dGxpbmVDb2xvciA9IG5vZGUucHN0eWxlKCdvdXRsaW5lLWNvbG9yJykudmFsdWU7XG4gIHZhciBvdXRsaW5lU3R5bGUgPSBub2RlLnBzdHlsZSgnb3V0bGluZS1zdHlsZScpLnZhbHVlO1xuICB2YXIgb3V0bGluZU9wYWNpdHkgPSBub2RlLnBzdHlsZSgnb3V0bGluZS1vcGFjaXR5JykudmFsdWUgKiBlbGVPcGFjaXR5O1xuICB2YXIgb3V0bGluZU9mZnNldCA9IG5vZGUucHN0eWxlKCdvdXRsaW5lLW9mZnNldCcpLnZhbHVlO1xuICB2YXIgY29ybmVyUmFkaXVzID0gbm9kZS5wc3R5bGUoJ2Nvcm5lci1yYWRpdXMnKS52YWx1ZTtcbiAgaWYgKGNvcm5lclJhZGl1cyAhPT0gJ2F1dG8nKSBjb3JuZXJSYWRpdXMgPSBub2RlLnBzdHlsZSgnY29ybmVyLXJhZGl1cycpLnBmVmFsdWU7XG4gIHZhciBzZXR1cFNoYXBlQ29sb3IgPSBmdW5jdGlvbiBzZXR1cFNoYXBlQ29sb3IoKSB7XG4gICAgdmFyIGJnT3B5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBiZ09wYWNpdHk7XG4gICAgci5lbGVGaWxsU3R5bGUoY29udGV4dCwgbm9kZSwgYmdPcHkpO1xuICB9O1xuICB2YXIgc2V0dXBCb3JkZXJDb2xvciA9IGZ1bmN0aW9uIHNldHVwQm9yZGVyQ29sb3IoKSB7XG4gICAgdmFyIGJkck9weSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogYm9yZGVyT3BhY2l0eTtcbiAgICByLmNvbG9yU3Ryb2tlU3R5bGUoY29udGV4dCwgYm9yZGVyQ29sb3JbMF0sIGJvcmRlckNvbG9yWzFdLCBib3JkZXJDb2xvclsyXSwgYmRyT3B5KTtcbiAgfTtcbiAgdmFyIHNldHVwT3V0bGluZUNvbG9yID0gZnVuY3Rpb24gc2V0dXBPdXRsaW5lQ29sb3IoKSB7XG4gICAgdmFyIG90bG5PcHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG91dGxpbmVPcGFjaXR5O1xuICAgIHIuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBvdXRsaW5lQ29sb3JbMF0sIG91dGxpbmVDb2xvclsxXSwgb3V0bGluZUNvbG9yWzJdLCBvdGxuT3B5KTtcbiAgfTtcblxuICAvL1xuICAvLyBzZXR1cCBzaGFwZVxuXG4gIHZhciBnZXRQYXRoID0gZnVuY3Rpb24gZ2V0UGF0aCh3aWR0aCwgaGVpZ2h0LCBzaGFwZSwgcG9pbnRzKSB7XG4gICAgdmFyIHBhdGhDYWNoZSA9IHIubm9kZVBhdGhDYWNoZSA9IHIubm9kZVBhdGhDYWNoZSB8fCBbXTtcbiAgICB2YXIga2V5ID0gaGFzaFN0cmluZ3Moc2hhcGUgPT09ICdwb2x5Z29uJyA/IHNoYXBlICsgJywnICsgcG9pbnRzLmpvaW4oJywnKSA6IHNoYXBlLCAnJyArIGhlaWdodCwgJycgKyB3aWR0aCwgJycgKyBjb3JuZXJSYWRpdXMpO1xuICAgIHZhciBjYWNoZWRQYXRoID0gcGF0aENhY2hlW2tleV07XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIGNhY2hlSGl0ID0gZmFsc2U7XG4gICAgaWYgKGNhY2hlZFBhdGggIT0gbnVsbCkge1xuICAgICAgcGF0aCA9IGNhY2hlZFBhdGg7XG4gICAgICBjYWNoZUhpdCA9IHRydWU7XG4gICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgICAgcGF0aENhY2hlW2tleV0gPSBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogcGF0aCxcbiAgICAgIGNhY2hlSGl0OiBjYWNoZUhpdFxuICAgIH07XG4gIH07XG4gIHZhciBzdHlsZVNoYXBlID0gbm9kZS5wc3R5bGUoJ3NoYXBlJykuc3RyVmFsdWU7XG4gIHZhciBzaGFwZVB0cyA9IG5vZGUucHN0eWxlKCdzaGFwZS1wb2x5Z29uLXBvaW50cycpLnBmVmFsdWU7XG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gICAgdmFyIHNoYXBlUGF0aCA9IGdldFBhdGgobm9kZVdpZHRoLCBub2RlSGVpZ2h0LCBzdHlsZVNoYXBlLCBzaGFwZVB0cyk7XG4gICAgcGF0aCA9IHNoYXBlUGF0aC5wYXRoO1xuICAgIHBhdGhDYWNoZUhpdCA9IHNoYXBlUGF0aC5jYWNoZUhpdDtcbiAgfVxuICB2YXIgZHJhd1NoYXBlID0gZnVuY3Rpb24gZHJhd1NoYXBlKCkge1xuICAgIGlmICghcGF0aENhY2hlSGl0KSB7XG4gICAgICB2YXIgbnBvcyA9IHBvcztcbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBucG9zID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KHBhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCwgY29ybmVyUmFkaXVzLCBycyk7XG4gICAgfVxuICAgIGlmICh1c2VQYXRocykge1xuICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH07XG4gIHZhciBkcmF3SW1hZ2VzID0gZnVuY3Rpb24gZHJhd0ltYWdlcygpIHtcbiAgICB2YXIgbm9kZU9wYWNpdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGVsZU9wYWNpdHk7XG4gICAgdmFyIGluc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICB2YXIgcHJldkJnaW5nID0gX3AuYmFja2dyb3VuZGluZztcbiAgICB2YXIgdG90YWxDb21wbGV0ZWQgPSAwO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbWFnZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBiZ0NvbnRhaW5tZW50ID0gbm9kZS5jeSgpLnN0eWxlKCkuZ2V0SW5kZXhlZFN0eWxlKG5vZGUsICdiYWNrZ3JvdW5kLWltYWdlLWNvbnRhaW5tZW50JywgJ3ZhbHVlJywgX2kpO1xuICAgICAgaWYgKGluc2lkZSAmJiBiZ0NvbnRhaW5tZW50ID09PSAnb3ZlcicgfHwgIWluc2lkZSAmJiBiZ0NvbnRhaW5tZW50ID09PSAnaW5zaWRlJykge1xuICAgICAgICB0b3RhbENvbXBsZXRlZCsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh1cmxEZWZpbmVkW19pXSAmJiBpbWFnZVtfaV0uY29tcGxldGUgJiYgIWltYWdlW19pXS5lcnJvcikge1xuICAgICAgICB0b3RhbENvbXBsZXRlZCsrO1xuICAgICAgICByLmRyYXdJbnNjcmliZWRJbWFnZShjb250ZXh0LCBpbWFnZVtfaV0sIG5vZGUsIF9pLCBub2RlT3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9wLmJhY2tncm91bmRpbmcgPSAhKHRvdGFsQ29tcGxldGVkID09PSBudW1JbWFnZXMpO1xuICAgIGlmIChwcmV2QmdpbmcgIT09IF9wLmJhY2tncm91bmRpbmcpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBiL2MgOmJhY2tncm91bmRpbmcgc3RhdGUgY2hhbmdlZFxuICAgICAgbm9kZS51cGRhdGVTdHlsZShmYWxzZSk7XG4gICAgfVxuICB9O1xuICB2YXIgZHJhd1BpZSA9IGZ1bmN0aW9uIGRyYXdQaWUoKSB7XG4gICAgdmFyIHJlZHJhd1NoYXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgcGllT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZWxlT3BhY2l0eTtcbiAgICBpZiAoci5oYXNQaWUobm9kZSkpIHtcbiAgICAgIHIuZHJhd1BpZShjb250ZXh0LCBub2RlLCBwaWVPcGFjaXR5KTtcblxuICAgICAgLy8gcmVkcmF3L3Jlc3RvcmUgcGF0aCBpZiBzdGVwcyBhZnRlciBwaWUgbmVlZCBpdFxuICAgICAgaWYgKHJlZHJhd1NoYXBlKSB7XG4gICAgICAgIGlmICghdXNlUGF0aHMpIHtcbiAgICAgICAgICByLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXcoY29udGV4dCwgcG9zLngsIHBvcy55LCBub2RlV2lkdGgsIG5vZGVIZWlnaHQsIGNvcm5lclJhZGl1cywgcnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZHJhd1N0cmlwZSA9IGZ1bmN0aW9uIGRyYXdTdHJpcGUoKSB7XG4gICAgdmFyIHJlZHJhd1NoYXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgc3RyaXBlT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZWxlT3BhY2l0eTtcbiAgICBpZiAoci5oYXNTdHJpcGUobm9kZSkpIHtcbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgaWYgKHVzZVBhdGhzKSB7XG4gICAgICAgIGNvbnRleHQuY2xpcChycy5wYXRoQ2FjaGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzKTtcbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICB9XG4gICAgICByLmRyYXdTdHJpcGUoY29udGV4dCwgbm9kZSwgc3RyaXBlT3BhY2l0eSk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgLy8gcmVkcmF3L3Jlc3RvcmUgcGF0aCBpZiBzdGVwcyBhZnRlciBzdHJpcGVzIG5lZWQgaXRcbiAgICAgIGlmIChyZWRyYXdTaGFwZSkge1xuICAgICAgICBpZiAoIXVzZVBhdGhzKSB7XG4gICAgICAgICAgci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3KGNvbnRleHQsIHBvcy54LCBwb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0LCBjb3JuZXJSYWRpdXMsIHJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGRhcmtlbiA9IGZ1bmN0aW9uIGRhcmtlbigpIHtcbiAgICB2YXIgZGFya2VuT3BhY2l0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZWxlT3BhY2l0eTtcbiAgICB2YXIgb3BhY2l0eSA9IChkYXJrbmVzcyA+IDAgPyBkYXJrbmVzcyA6IC1kYXJrbmVzcykgKiBkYXJrZW5PcGFjaXR5O1xuICAgIHZhciBjID0gZGFya25lc3MgPiAwID8gMCA6IDI1NTtcbiAgICBpZiAoZGFya25lc3MgIT09IDApIHtcbiAgICAgIHIuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgYywgYywgYywgb3BhY2l0eSk7XG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgY29udGV4dC5maWxsKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZHJhd0JvcmRlciA9IGZ1bmN0aW9uIGRyYXdCb3JkZXIoKSB7XG4gICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9IGJvcmRlckNhcDtcbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSBib3JkZXJKb2luO1xuICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIHN3aXRjaCAoYm9yZGVyU3R5bGUpIHtcbiAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goYm9yZGVyUGF0dGVybik7XG4gICAgICAgICAgICBjb250ZXh0LmxpbmVEYXNoT2Zmc2V0ID0gYm9yZGVyT2Zmc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFtdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYm9yZGVyUG9zaXRpb24gIT09ICdjZW50ZXInKSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCAqPSAyO1xuICAgICAgICBpZiAoYm9yZGVyUG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XG4gICAgICAgICAgdXNlUGF0aHMgPyBjb250ZXh0LmNsaXAocGF0aCkgOiBjb250ZXh0LmNsaXAoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVnaW9uID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgIHJlZ2lvbi5yZWN0KC1ub2RlV2lkdGggLyAyIC0gYm9yZGVyV2lkdGgsIC1ub2RlSGVpZ2h0IC8gMiAtIGJvcmRlcldpZHRoLCBub2RlV2lkdGggKyAyICogYm9yZGVyV2lkdGgsIG5vZGVIZWlnaHQgKyAyICogYm9yZGVyV2lkdGgpO1xuICAgICAgICAgIHJlZ2lvbi5hZGRQYXRoKHBhdGgpO1xuICAgICAgICAgIGNvbnRleHQuY2xpcChyZWdpb24sICdldmVub2RkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdXNlUGF0aHMgPyBjb250ZXh0LnN0cm9rZShwYXRoKSA6IGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXNlUGF0aHMgPyBjb250ZXh0LnN0cm9rZShwYXRoKSA6IGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBpZiAoYm9yZGVyU3R5bGUgPT09ICdkb3VibGUnKSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGggLyAzO1xuICAgICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc2V0IGluIGNhc2Ugd2UgY2hhbmdlZCB0aGUgYm9yZGVyIHN0eWxlXG4gICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgZHJhd091dGxpbmUgPSBmdW5jdGlvbiBkcmF3T3V0bGluZSgpIHtcbiAgICBpZiAob3V0bGluZVdpZHRoID4gMCkge1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSBvdXRsaW5lV2lkdGg7XG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgICAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgc3dpdGNoIChvdXRsaW5lU3R5bGUpIHtcbiAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbMSwgMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWzQsIDJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG5wb3MgPSBwb3M7XG4gICAgICBpZiAodXNlUGF0aHMpIHtcbiAgICAgICAgbnBvcyA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBzaGFwZSA9IHIuZ2V0Tm9kZVNoYXBlKG5vZGUpO1xuICAgICAgdmFyIGJXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgaWYgKGJvcmRlclBvc2l0aW9uID09PSAnaW5zaWRlJykgYldpZHRoID0gMDtcbiAgICAgIGlmIChib3JkZXJQb3NpdGlvbiA9PT0gJ291dHNpZGUnKSBiV2lkdGggKj0gMjtcbiAgICAgIHZhciBzY2FsZVggPSAobm9kZVdpZHRoICsgYldpZHRoICsgKG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpKSAvIG5vZGVXaWR0aDtcbiAgICAgIHZhciBzY2FsZVkgPSAobm9kZUhlaWdodCArIGJXaWR0aCArIChvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSkgLyBub2RlSGVpZ2h0O1xuICAgICAgdmFyIHNXaWR0aCA9IG5vZGVXaWR0aCAqIHNjYWxlWDtcbiAgICAgIHZhciBzSGVpZ2h0ID0gbm9kZUhlaWdodCAqIHNjYWxlWTtcbiAgICAgIHZhciBwb2ludHMgPSByLm5vZGVTaGFwZXNbc2hhcGVdLnBvaW50cztcbiAgICAgIHZhciBfcGF0aDtcbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICB2YXIgb3V0bGluZVBhdGggPSBnZXRQYXRoKHNXaWR0aCwgc0hlaWdodCwgc2hhcGUsIHBvaW50cyk7XG4gICAgICAgIF9wYXRoID0gb3V0bGluZVBhdGgucGF0aDtcbiAgICAgIH1cblxuICAgICAgLy8gZHJhdyB0aGUgb3V0bGluZSBwYXRoLCBlaXRoZXIgYnkgdXNpbmcgZXhwYW5kZWQgcG9pbnRzIG9yIGJ5IHNjYWxpbmcgXG4gICAgICAvLyB0aGUgZGltZW5zaW9ucywgZGVwZW5kaW5nIG9uIHNoYXBlXG4gICAgICBpZiAoc2hhcGUgPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgICAgIHIuZHJhd0VsbGlwc2VQYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBzV2lkdGgsIHNIZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChbJ3JvdW5kLWRpYW1vbmQnLCAncm91bmQtaGVwdGFnb24nLCAncm91bmQtaGV4YWdvbicsICdyb3VuZC1vY3RhZ29uJywgJ3JvdW5kLXBlbnRhZ29uJywgJ3JvdW5kLXBvbHlnb24nLCAncm91bmQtdHJpYW5nbGUnLCAncm91bmQtdGFnJ10uaW5jbHVkZXMoc2hhcGUpKSB7XG4gICAgICAgIHZhciBzTXVsdCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXRYID0gMDtcbiAgICAgICAgdmFyIG9mZnNldFkgPSAwO1xuICAgICAgICBpZiAoc2hhcGUgPT09ICdyb3VuZC1kaWFtb25kJykge1xuICAgICAgICAgIHNNdWx0ID0gKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpICogMS40O1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAncm91bmQtaGVwdGFnb24nKSB7XG4gICAgICAgICAgc011bHQgPSAoYldpZHRoICsgb3V0bGluZU9mZnNldCArIG91dGxpbmVXaWR0aCkgKiAxLjA3NTtcbiAgICAgICAgICBvZmZzZXRZID0gLShiV2lkdGggLyAyICsgb3V0bGluZU9mZnNldCArIG91dGxpbmVXaWR0aCkgLyAzNTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3JvdW5kLWhleGFnb24nKSB7XG4gICAgICAgICAgc011bHQgPSAoYldpZHRoICsgb3V0bGluZU9mZnNldCArIG91dGxpbmVXaWR0aCkgKiAxLjEyO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAncm91bmQtcGVudGFnb24nKSB7XG4gICAgICAgICAgc011bHQgPSAoYldpZHRoICsgb3V0bGluZU9mZnNldCArIG91dGxpbmVXaWR0aCkgKiAxLjEzO1xuICAgICAgICAgIG9mZnNldFkgPSAtKGJXaWR0aCAvIDIgKyBvdXRsaW5lT2Zmc2V0ICsgb3V0bGluZVdpZHRoKSAvIDE1O1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlID09PSAncm91bmQtdGFnJykge1xuICAgICAgICAgIHNNdWx0ID0gKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpICogMS4xMjtcbiAgICAgICAgICBvZmZzZXRYID0gKGJXaWR0aCAvIDIgKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAqIC4wNztcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZSA9PT0gJ3JvdW5kLXRyaWFuZ2xlJykge1xuICAgICAgICAgIHNNdWx0ID0gKGJXaWR0aCArIG91dGxpbmVPZmZzZXQgKyBvdXRsaW5lV2lkdGgpICogKE1hdGguUEkgLyAyKTtcbiAgICAgICAgICBvZmZzZXRZID0gLShiV2lkdGggKyBvdXRsaW5lT2Zmc2V0IC8gMiArIG91dGxpbmVXaWR0aCkgLyBNYXRoLlBJO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzTXVsdCAhPT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IChub2RlV2lkdGggKyBzTXVsdCkgLyBub2RlV2lkdGg7XG4gICAgICAgICAgc1dpZHRoID0gbm9kZVdpZHRoICogc2NhbGVYO1xuICAgICAgICAgIGlmICghWydyb3VuZC1oZXhhZ29uJywgJ3JvdW5kLXRhZyddLmluY2x1ZGVzKHNoYXBlKSkge1xuICAgICAgICAgICAgc2NhbGVZID0gKG5vZGVIZWlnaHQgKyBzTXVsdCkgLyBub2RlSGVpZ2h0O1xuICAgICAgICAgICAgc0hlaWdodCA9IG5vZGVIZWlnaHQgKiBzY2FsZVk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRQb2x5Z29uUmFkaXVzKHNXaWR0aCwgc0hlaWdodCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICAgIHZhciBoYWxmVyA9IHNXaWR0aCAvIDI7XG4gICAgICAgIHZhciBoYWxmSCA9IHNIZWlnaHQgLyAyO1xuICAgICAgICB2YXIgcmFkaXVzID0gY29ybmVyUmFkaXVzICsgKGJXaWR0aCArIG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpIC8gMjtcbiAgICAgICAgdmFyIHAgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAvIDIpO1xuICAgICAgICB2YXIgY29ybmVycyA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoIC8gMik7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBvaW50cy5sZW5ndGggLyAyOyBfaTIrKykge1xuICAgICAgICAgIHBbX2kyXSA9IHtcbiAgICAgICAgICAgIHg6IG5wb3MueCArIG9mZnNldFggKyBoYWxmVyAqIHBvaW50c1tfaTIgKiAyXSxcbiAgICAgICAgICAgIHk6IG5wb3MueSArIG9mZnNldFkgKyBoYWxmSCAqIHBvaW50c1tfaTIgKiAyICsgMV1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBfaTMsXG4gICAgICAgICAgcDEsXG4gICAgICAgICAgcDIsXG4gICAgICAgICAgcDMsXG4gICAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICAgIHAxID0gcFtsZW4gLSAxXTtcbiAgICAgICAgLy8gZm9yIGVhY2ggcG9pbnRcbiAgICAgICAgZm9yIChfaTMgPSAwOyBfaTMgPCBsZW47IF9pMysrKSB7XG4gICAgICAgICAgcDIgPSBwW19pMyAlIGxlbl07XG4gICAgICAgICAgcDMgPSBwWyhfaTMgKyAxKSAlIGxlbl07XG4gICAgICAgICAgY29ybmVyc1tfaTNdID0gZ2V0Um91bmRDb3JuZXIocDEsIHAyLCBwMywgcmFkaXVzKTtcbiAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgIHAyID0gcDM7XG4gICAgICAgIH1cbiAgICAgICAgci5kcmF3Um91bmRQb2x5Z29uUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLnggKyBvZmZzZXRYLCBucG9zLnkgKyBvZmZzZXRZLCBub2RlV2lkdGggKiBzY2FsZVgsIG5vZGVIZWlnaHQgKiBzY2FsZVksIHBvaW50cywgY29ybmVycyk7XG4gICAgICB9IGVsc2UgaWYgKFsncm91bmRyZWN0YW5nbGUnLCAncm91bmQtcmVjdGFuZ2xlJ10uaW5jbHVkZXMoc2hhcGUpKSB7XG4gICAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMoc1dpZHRoLCBzSGVpZ2h0KSA6IGNvcm5lclJhZGl1cztcbiAgICAgICAgci5kcmF3Um91bmRSZWN0YW5nbGVQYXRoKF9wYXRoIHx8IGNvbnRleHQsIG5wb3MueCwgbnBvcy55LCBzV2lkdGgsIHNIZWlnaHQsIGNvcm5lclJhZGl1cyArIChiV2lkdGggKyBvdXRsaW5lV2lkdGggKyBvdXRsaW5lT2Zmc2V0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChbJ2N1dHJlY3RhbmdsZScsICdjdXQtcmVjdGFuZ2xlJ10uaW5jbHVkZXMoc2hhcGUpKSB7XG4gICAgICAgIGNvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Q3V0UmVjdGFuZ2xlQ29ybmVyTGVuZ3RoKCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICAgIHIuZHJhd0N1dFJlY3RhbmdsZVBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIHNXaWR0aCwgc0hlaWdodCwgbnVsbCwgY29ybmVyUmFkaXVzICsgKGJXaWR0aCArIG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpIC8gNCk7XG4gICAgICB9IGVsc2UgaWYgKFsnYm90dG9tcm91bmRyZWN0YW5nbGUnLCAnYm90dG9tLXJvdW5kLXJlY3RhbmdsZSddLmluY2x1ZGVzKHNoYXBlKSkge1xuICAgICAgICBjb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHNXaWR0aCwgc0hlaWdodCkgOiBjb3JuZXJSYWRpdXM7XG4gICAgICAgIHIuZHJhd0JvdHRvbVJvdW5kUmVjdGFuZ2xlUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgc1dpZHRoLCBzSGVpZ2h0LCBjb3JuZXJSYWRpdXMgKyAoYldpZHRoICsgb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkgLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGUgPT09IFwiYmFycmVsXCIpIHtcbiAgICAgICAgci5kcmF3QmFycmVsUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgc1dpZHRoLCBzSGVpZ2h0KTtcbiAgICAgIH0gZWxzZSBpZiAoc2hhcGUuc3RhcnRzV2l0aChcInBvbHlnb25cIikgfHwgWydyaG9tYm9pZCcsICdyaWdodC1yaG9tYm9pZCcsICdyb3VuZC10YWcnLCAndGFnJywgJ3ZlZSddLmluY2x1ZGVzKHNoYXBlKSkge1xuICAgICAgICB2YXIgcGFkID0gKGJXaWR0aCArIG91dGxpbmVXaWR0aCArIG91dGxpbmVPZmZzZXQpIC8gbm9kZVdpZHRoO1xuICAgICAgICBwb2ludHMgPSBqb2luTGluZXMoZXhwYW5kUG9seWdvbihwb2ludHMsIHBhZCkpO1xuICAgICAgICByLmRyYXdQb2x5Z29uUGF0aChfcGF0aCB8fCBjb250ZXh0LCBucG9zLngsIG5wb3MueSwgbm9kZVdpZHRoLCBub2RlSGVpZ2h0LCBwb2ludHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9wYWQgPSAoYldpZHRoICsgb3V0bGluZVdpZHRoICsgb3V0bGluZU9mZnNldCkgLyBub2RlV2lkdGg7XG4gICAgICAgIHBvaW50cyA9IGpvaW5MaW5lcyhleHBhbmRQb2x5Z29uKHBvaW50cywgLV9wYWQpKTtcbiAgICAgICAgci5kcmF3UG9seWdvblBhdGgoX3BhdGggfHwgY29udGV4dCwgbnBvcy54LCBucG9zLnksIG5vZGVXaWR0aCwgbm9kZUhlaWdodCwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZShfcGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgaWYgKG91dGxpbmVTdHlsZSA9PT0gJ2RvdWJsZScpIHtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBiV2lkdGggLyAzO1xuICAgICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICAgIGlmICh1c2VQYXRocykge1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKF9wYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgfVxuXG4gICAgICAvLyByZXNldCBpbiBjYXNlIHdlIGNoYW5nZWQgdGhlIGJvcmRlciBzdHlsZVxuICAgICAgaWYgKGNvbnRleHQuc2V0TGluZURhc2gpIHtcbiAgICAgICAgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGRyYXdPdmVybGF5ID0gZnVuY3Rpb24gZHJhd092ZXJsYXkoKSB7XG4gICAgaWYgKHNob3VsZERyYXdPdmVybGF5KSB7XG4gICAgICByLmRyYXdOb2RlT3ZlcmxheShjb250ZXh0LCBub2RlLCBwb3MsIG5vZGVXaWR0aCwgbm9kZUhlaWdodCk7XG4gICAgfVxuICB9O1xuICB2YXIgZHJhd1VuZGVybGF5ID0gZnVuY3Rpb24gZHJhd1VuZGVybGF5KCkge1xuICAgIGlmIChzaG91bGREcmF3T3ZlcmxheSkge1xuICAgICAgci5kcmF3Tm9kZVVuZGVybGF5KGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KTtcbiAgICB9XG4gIH07XG4gIHZhciBkcmF3VGV4dCA9IGZ1bmN0aW9uIGRyYXdUZXh0KCkge1xuICAgIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIG5vZGUsIG51bGwsIGRyYXdMYWJlbCk7XG4gIH07XG4gIHZhciBnaG9zdCA9IG5vZGUucHN0eWxlKCdnaG9zdCcpLnZhbHVlID09PSAneWVzJztcbiAgaWYgKGdob3N0KSB7XG4gICAgdmFyIGd4ID0gbm9kZS5wc3R5bGUoJ2dob3N0LW9mZnNldC14JykucGZWYWx1ZTtcbiAgICB2YXIgZ3kgPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb2Zmc2V0LXknKS5wZlZhbHVlO1xuICAgIHZhciBnaG9zdE9wYWNpdHkgPSBub2RlLnBzdHlsZSgnZ2hvc3Qtb3BhY2l0eScpLnZhbHVlO1xuICAgIHZhciBlZmZHaG9zdE9wYWNpdHkgPSBnaG9zdE9wYWNpdHkgKiBlbGVPcGFjaXR5O1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgc2V0dXBPdXRsaW5lQ29sb3IoKTtcbiAgICBkcmF3T3V0bGluZSgpO1xuICAgIHNldHVwU2hhcGVDb2xvcihnaG9zdE9wYWNpdHkgKiBiZ09wYWNpdHkpO1xuICAgIGRyYXdTaGFwZSgpO1xuICAgIGRyYXdJbWFnZXMoZWZmR2hvc3RPcGFjaXR5LCB0cnVlKTtcbiAgICBzZXR1cEJvcmRlckNvbG9yKGdob3N0T3BhY2l0eSAqIGJvcmRlck9wYWNpdHkpO1xuICAgIGRyYXdCb3JkZXIoKTtcbiAgICBkcmF3UGllKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgICBkcmF3U3RyaXBlKGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwKTtcbiAgICBkcmF3SW1hZ2VzKGVmZkdob3N0T3BhY2l0eSwgZmFsc2UpO1xuICAgIGRhcmtlbihlZmZHaG9zdE9wYWNpdHkpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgfVxuICBpZiAodXNlUGF0aHMpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgtcG9zLngsIC1wb3MueSk7XG4gIH1cbiAgZHJhd1VuZGVybGF5KCk7XG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHBvcy54LCBwb3MueSk7XG4gIH1cbiAgc2V0dXBPdXRsaW5lQ29sb3IoKTtcbiAgZHJhd091dGxpbmUoKTtcbiAgc2V0dXBTaGFwZUNvbG9yKCk7XG4gIGRyYXdTaGFwZSgpO1xuICBkcmF3SW1hZ2VzKGVsZU9wYWNpdHksIHRydWUpO1xuICBzZXR1cEJvcmRlckNvbG9yKCk7XG4gIGRyYXdCb3JkZXIoKTtcbiAgZHJhd1BpZShkYXJrbmVzcyAhPT0gMCB8fCBib3JkZXJXaWR0aCAhPT0gMCk7XG4gIGRyYXdTdHJpcGUoZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDApO1xuICBkcmF3SW1hZ2VzKGVsZU9wYWNpdHksIGZhbHNlKTtcbiAgZGFya2VuKCk7XG4gIGlmICh1c2VQYXRocykge1xuICAgIGNvbnRleHQudHJhbnNsYXRlKC1wb3MueCwgLXBvcy55KTtcbiAgfVxuICBkcmF3VGV4dCgpO1xuICBkcmF3T3ZlcmxheSgpO1xuXG4gIC8vXG4gIC8vIGNsZWFuIHVwIHNoaWZ0XG5cbiAgaWYgKHNoaWZ0VG9PcmlnaW5XaXRoQmIpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZShiYi54MSwgYmIueTEpO1xuICB9XG59O1xudmFyIGRyYXdOb2RlT3ZlcmxheVVuZGVybGF5ID0gZnVuY3Rpb24gZHJhd05vZGVPdmVybGF5VW5kZXJsYXkob3ZlcmxheU9yVW5kZXJsYXkpIHtcbiAgaWYgKCFbJ292ZXJsYXknLCAndW5kZXJsYXknXS5pbmNsdWRlcyhvdmVybGF5T3JVbmRlcmxheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUnKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIG5vZGUsIHBvcywgbm9kZVdpZHRoLCBub2RlSGVpZ2h0KSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIGlmICghbm9kZS52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhZGRpbmcgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItcGFkZGluZ1wiKSkucGZWYWx1ZTtcbiAgICB2YXIgb3BhY2l0eSA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1vcGFjaXR5XCIpKS52YWx1ZTtcbiAgICB2YXIgY29sb3IgPSBub2RlLnBzdHlsZShcIlwiLmNvbmNhdChvdmVybGF5T3JVbmRlcmxheSwgXCItY29sb3JcIikpLnZhbHVlO1xuICAgIHZhciBzaGFwZSA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1zaGFwZVwiKSkudmFsdWU7XG4gICAgdmFyIHJhZGl1cyA9IG5vZGUucHN0eWxlKFwiXCIuY29uY2F0KG92ZXJsYXlPclVuZGVybGF5LCBcIi1jb3JuZXItcmFkaXVzXCIpKS52YWx1ZTtcbiAgICBpZiAob3BhY2l0eSA+IDApIHtcbiAgICAgIHBvcyA9IHBvcyB8fCBub2RlLnBvc2l0aW9uKCk7XG4gICAgICBpZiAobm9kZVdpZHRoID09IG51bGwgfHwgbm9kZUhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIHZhciBfcGFkZGluZyA9IG5vZGUucGFkZGluZygpO1xuICAgICAgICBub2RlV2lkdGggPSBub2RlLndpZHRoKCkgKyAyICogX3BhZGRpbmc7XG4gICAgICAgIG5vZGVIZWlnaHQgPSBub2RlLmhlaWdodCgpICsgMiAqIF9wYWRkaW5nO1xuICAgICAgfVxuICAgICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICAgIHIubm9kZVNoYXBlc1tzaGFwZV0uZHJhdyhjb250ZXh0LCBwb3MueCwgcG9zLnksIG5vZGVXaWR0aCArIHBhZGRpbmcgKiAyLCBub2RlSGVpZ2h0ICsgcGFkZGluZyAqIDIsIHJhZGl1cyk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICB9XG4gIH07XG59O1xuQ1JwJDYuZHJhd05vZGVPdmVybGF5ID0gZHJhd05vZGVPdmVybGF5VW5kZXJsYXkoJ292ZXJsYXknKTtcbkNScCQ2LmRyYXdOb2RlVW5kZXJsYXkgPSBkcmF3Tm9kZU92ZXJsYXlVbmRlcmxheSgndW5kZXJsYXknKTtcblxuLy8gZG9lcyB0aGUgbm9kZSBoYXZlIGF0IGxlYXN0IG9uZSBwaWUgcGllY2U/XG5DUnAkNi5oYXNQaWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcblxuICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5oYXNQaWU7XG59O1xuQ1JwJDYuaGFzU3RyaXBlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzU3RyaXBlO1xufTtcbkNScCQ2LmRyYXdQaWUgPSBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgbm9kZU9wYWNpdHksIHBvcykge1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcbiAgcG9zID0gcG9zIHx8IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIGN5U3R5bGUgPSBub2RlLmN5KCkuc3R5bGUoKTtcbiAgdmFyIHBpZVNpemUgPSBub2RlLnBzdHlsZSgncGllLXNpemUnKTtcbiAgdmFyIGhvbGUgPSBub2RlLnBzdHlsZSgncGllLWhvbGUnKTtcbiAgdmFyIG92ZXJhbGxTdGFydEFuZ2xlID0gbm9kZS5wc3R5bGUoJ3BpZS1zdGFydC1hbmdsZScpLnBmVmFsdWU7XG4gIHZhciB4ID0gcG9zLng7XG4gIHZhciB5ID0gcG9zLnk7XG4gIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgdmFyIG5vZGVIID0gbm9kZS5oZWlnaHQoKTtcbiAgdmFyIHJhZGl1cyA9IE1hdGgubWluKG5vZGVXLCBub2RlSCkgLyAyOyAvLyBtdXN0IGZpdCBpbiBub2RlXG4gIHZhciBob2xlUmFkaXVzO1xuICB2YXIgbGFzdFBlcmNlbnQgPSAwOyAvLyB3aGF0ICUgdG8gY29udGludWUgZHJhd2luZyBwaWUgc2xpY2VzIGZyb20gb24gWzAsIDFdXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgaWYgKHVzZVBhdGhzKSB7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG4gIH1cbiAgaWYgKHBpZVNpemUudW5pdHMgPT09ICclJykge1xuICAgIHJhZGl1cyA9IHJhZGl1cyAqIHBpZVNpemUucGZWYWx1ZTtcbiAgfSBlbHNlIGlmIChwaWVTaXplLnBmVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJhZGl1cyA9IHBpZVNpemUucGZWYWx1ZSAvIDI7IC8vIGRpYW1ldGVyIGluIHBpeGVscyA9PiByYWRpdXNcbiAgfVxuICBpZiAoaG9sZS51bml0cyA9PT0gJyUnKSB7XG4gICAgaG9sZVJhZGl1cyA9IHJhZGl1cyAqIGhvbGUucGZWYWx1ZTtcbiAgfSBlbHNlIGlmIChob2xlLnBmVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGhvbGVSYWRpdXMgPSBob2xlLnBmVmFsdWUgLyAyOyAvLyBkaWFtZXRlciBpbiBwaXhlbHMgPT4gcmFkaXVzXG4gIH1cbiAgaWYgKGhvbGVSYWRpdXMgPj0gcmFkaXVzKSB7XG4gICAgcmV0dXJuOyAvLyB0aGUgcGllIHdvdWxkIGJlIGludmlzaWJsZSBhbnl3YXlcbiAgfVxuICBmb3IgKHZhciBpID0gMTsgaSA8PSBjeVN0eWxlLnBpZUJhY2tncm91bmROOyBpKyspIHtcbiAgICAvLyAxLi5OXG4gICAgdmFyIHNpemUgPSBub2RlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnKS52YWx1ZTtcbiAgICB2YXIgY29sb3IgPSBub2RlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLWNvbG9yJykudmFsdWU7XG4gICAgdmFyIG9wYWNpdHkgPSBub2RlLnBzdHlsZSgncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknKS52YWx1ZSAqIG5vZGVPcGFjaXR5O1xuICAgIHZhciBwZXJjZW50ID0gc2l6ZSAvIDEwMDsgLy8gbWFwIGludGVnZXIgcmFuZ2UgWzAsIDEwMF0gdG8gWzAsIDFdXG5cbiAgICAvLyBwZXJjZW50IGNhbid0IHB1c2ggYmV5b25kIDFcbiAgICBpZiAocGVyY2VudCArIGxhc3RQZXJjZW50ID4gMSkge1xuICAgICAgcGVyY2VudCA9IDEgLSBsYXN0UGVyY2VudDtcbiAgICB9XG4gICAgdmFyIGFuZ2xlU3RhcnQgPSAxLjUgKiBNYXRoLlBJICsgMiAqIE1hdGguUEkgKiBsYXN0UGVyY2VudDsgLy8gc3RhcnQgYXQgMTIgbydjbG9jayBhbmQgZ28gY2xvY2t3aXNlXG4gICAgYW5nbGVTdGFydCArPSBvdmVyYWxsU3RhcnRBbmdsZTsgLy8gc2hpZnQgYnkgdGhlIG92ZXJhbGwgcGllIHN0YXJ0IGFuZ2xlXG4gICAgdmFyIGFuZ2xlRGVsdGEgPSAyICogTWF0aC5QSSAqIHBlcmNlbnQ7XG4gICAgdmFyIGFuZ2xlRW5kID0gYW5nbGVTdGFydCArIGFuZ2xlRGVsdGE7XG5cbiAgICAvLyBpZ25vcmUgaWZcbiAgICAvLyAtIHplcm8gc2l6ZVxuICAgIC8vIC0gd2UncmUgYWxyZWFkeSBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgLy8gLSBhZGRpbmcgdGhlIGN1cnJlbnQgc2xpY2Ugd291bGQgZ28gYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgIGlmIChzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChob2xlUmFkaXVzID09PSAwKSB7XG4gICAgICAvLyBtYWtlIGEgcGllIHNsaWNlXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCByYWRpdXMsIGFuZ2xlU3RhcnQsIGFuZ2xlRW5kKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1ha2UgYSBwaWUgc2xpY2UgdGhhdCdzIGxpa2UgdGhlIGFib3ZlIGJ1dCB3aXRoIGEgaG9sZSBpbiB0aGUgbWlkZGxlXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCBhbmdsZVN0YXJ0LCBhbmdsZUVuZCk7XG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCBob2xlUmFkaXVzLCBhbmdsZUVuZCwgYW5nbGVTdGFydCwgdHJ1ZSk7IC8vIHRydWUgZm9yIGFudGljbG9ja3dpc2VcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgfVxufTtcbkNScCQ2LmRyYXdTdHJpcGUgPSBmdW5jdGlvbiAoY29udGV4dCwgbm9kZSwgbm9kZU9wYWNpdHksIHBvcykge1xuICBub2RlID0gbm9kZVswXTsgLy8gZW5zdXJlIGVsZSByZWZcbiAgcG9zID0gcG9zIHx8IG5vZGUucG9zaXRpb24oKTtcbiAgdmFyIGN5U3R5bGUgPSBub2RlLmN5KCkuc3R5bGUoKTtcbiAgdmFyIHggPSBwb3MueDtcbiAgdmFyIHkgPSBwb3MueTtcbiAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICB2YXIgbGFzdFBlcmNlbnQgPSAwOyAvLyB3aGF0ICUgdG8gY29udGludWUgZHJhd2luZyBwaWUgc2xpY2VzIGZyb20gb24gWzAsIDFdXG4gIHZhciB1c2VQYXRocyA9IHRoaXMudXNlUGF0aHMoKTtcbiAgY29udGV4dC5zYXZlKCk7XG4gIHZhciBkaXJlY3Rpb24gPSBub2RlLnBzdHlsZSgnc3RyaXBlLWRpcmVjdGlvbicpLnZhbHVlO1xuICB2YXIgc3RyaXBlU2l6ZSA9IG5vZGUucHN0eWxlKCdzdHJpcGUtc2l6ZScpO1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlZmF1bHRcbiAgICBjYXNlICdyaWdod2FyZCc6XG4gICAgICBjb250ZXh0LnJvdGF0ZSgtTWF0aC5QSSAvIDIpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgdmFyIHN0cmlwZVcgPSBub2RlVztcbiAgdmFyIHN0cmlwZUggPSBub2RlSDtcbiAgaWYgKHN0cmlwZVNpemUudW5pdHMgPT09ICclJykge1xuICAgIHN0cmlwZVcgPSBzdHJpcGVXICogc3RyaXBlU2l6ZS5wZlZhbHVlO1xuICAgIHN0cmlwZUggPSBzdHJpcGVIICogc3RyaXBlU2l6ZS5wZlZhbHVlO1xuICB9IGVsc2UgaWYgKHN0cmlwZVNpemUucGZWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaXBlVyA9IHN0cmlwZVNpemUucGZWYWx1ZTtcbiAgICBzdHJpcGVIID0gc3RyaXBlU2l6ZS5wZlZhbHVlO1xuICB9XG4gIGlmICh1c2VQYXRocykge1xuICAgIHggPSAwO1xuICAgIHkgPSAwO1xuICB9XG5cbiAgLy8gc2hpZnQgdXAgZnJvbSB0aGUgY2VudHJlIG9mIHRoZSBub2RlIHRvIHRoZSB0b3AtbGVmdCBjb3JuZXJcbiAgeSAtPSBzdHJpcGVXIC8gMjtcbiAgeCAtPSBzdHJpcGVIIC8gMjtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gY3lTdHlsZS5zdHJpcGVCYWNrZ3JvdW5kTjsgaSsrKSB7XG4gICAgLy8gMS4uTlxuICAgIHZhciBzaXplID0gbm9kZS5wc3R5bGUoJ3N0cmlwZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJykudmFsdWU7XG4gICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUoJ3N0cmlwZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gbm9kZS5wc3R5bGUoJ3N0cmlwZS0nICsgaSArICctYmFja2dyb3VuZC1vcGFjaXR5JykudmFsdWUgKiBub2RlT3BhY2l0eTtcbiAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuXG4gICAgLy8gcGVyY2VudCBjYW4ndCBwdXNoIGJleW9uZCAxXG4gICAgaWYgKHBlcmNlbnQgKyBsYXN0UGVyY2VudCA+IDEpIHtcbiAgICAgIHBlcmNlbnQgPSAxIC0gbGFzdFBlcmNlbnQ7XG4gICAgfVxuXG4gICAgLy8gaWdub3JlIGlmXG4gICAgLy8gLSB6ZXJvIHNpemVcbiAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNoYXJ0XG4gICAgLy8gLSBhZGRpbmcgdGhlIGN1cnJlbnQgc2xpY2Ugd291bGQgZ28gYmV5b25kIHRoZSBmdWxsIGNoYXJ0XG4gICAgaWYgKHNpemUgPT09IDAgfHwgbGFzdFBlcmNlbnQgPj0gMSB8fCBsYXN0UGVyY2VudCArIHBlcmNlbnQgPiAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkcmF3IHJlY3QgZm9yIHRoZSBjdXJyZW50IHN0cmlwZVxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5yZWN0KHgsIHkgKyBzdHJpcGVIICogbGFzdFBlcmNlbnQsIHN0cmlwZVcsIHN0cmlwZUggKiBwZXJjZW50KTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgfVxuICBjb250ZXh0LnJlc3RvcmUoKTtcbn07XG5cbnZhciBDUnAkNSA9IHt9O1xudmFyIG1vdGlvbkJsdXJEZWxheSA9IDEwMDtcblxuLy8gdmFyIGlzRmlyZWZveCA9IHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbkNScCQ1LmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcy5kYXRhLmNvbnRleHRzWzBdO1xuICBpZiAodGhpcy5mb3JjZWRQaXhlbFJhdGlvICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5mb3JjZWRQaXhlbFJhdGlvO1xuICB9XG4gIHZhciBjb250YWluZXJXaW5kb3cgPSB0aGlzLmN5LndpbmRvdygpO1xuICB2YXIgYmFja2luZ1N0b3JlID0gY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIChjb250YWluZXJXaW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIGJhY2tpbmdTdG9yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxufTtcbkNScCQ1LnBhaW50Q2FjaGUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgY2FjaGVzID0gdGhpcy5wYWludENhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgfHwgW107XG4gIHZhciBuZWVkVG9DcmVhdGVDYWNoZSA9IHRydWU7XG4gIHZhciBjYWNoZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZSA9IGNhY2hlc1tpXTtcbiAgICBpZiAoY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgbmVlZFRvQ3JlYXRlQ2FjaGUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAobmVlZFRvQ3JlYXRlQ2FjaGUpIHtcbiAgICBjYWNoZSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9O1xuICAgIGNhY2hlcy5wdXNoKGNhY2hlKTtcbiAgfVxuICByZXR1cm4gY2FjaGU7XG59O1xuQ1JwJDUuY3JlYXRlR3JhZGllbnRTdHlsZUZvciA9IGZ1bmN0aW9uIChjb250ZXh0LCBzaGFwZVN0eWxlTmFtZSwgZWxlLCBmaWxsLCBvcGFjaXR5KSB7XG4gIHZhciBncmFkaWVudFN0eWxlO1xuICB2YXIgdXNlUGF0aHMgPSB0aGlzLnVzZVBhdGhzKCk7XG4gIHZhciBjb2xvcnMgPSBlbGUucHN0eWxlKHNoYXBlU3R5bGVOYW1lICsgJy1ncmFkaWVudC1zdG9wLWNvbG9ycycpLnZhbHVlLFxuICAgIHBvc2l0aW9ucyA9IGVsZS5wc3R5bGUoc2hhcGVTdHlsZU5hbWUgKyAnLWdyYWRpZW50LXN0b3AtcG9zaXRpb25zJykucGZWYWx1ZTtcbiAgaWYgKGZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgaWYgKGVsZS5pc0VkZ2UoKSkge1xuICAgICAgdmFyIHN0YXJ0ID0gZWxlLnNvdXJjZUVuZHBvaW50KCksXG4gICAgICAgIGVuZCA9IGVsZS50YXJnZXRFbmRwb2ludCgpLFxuICAgICAgICBtaWQgPSBlbGUubWlkcG9pbnQoKTtcbiAgICAgIHZhciBkMSA9IGRpc3Qoc3RhcnQsIG1pZCk7XG4gICAgICB2YXIgZDIgPSBkaXN0KGVuZCwgbWlkKTtcbiAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KG1pZC54LCBtaWQueSwgMCwgbWlkLngsIG1pZC55LCBNYXRoLm1heChkMSwgZDIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvcyA9IHVzZVBhdGhzID8ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9IDogZWxlLnBvc2l0aW9uKCksXG4gICAgICAgIHdpZHRoID0gZWxlLnBhZGRlZFdpZHRoKCksXG4gICAgICAgIGhlaWdodCA9IGVsZS5wYWRkZWRIZWlnaHQoKTtcbiAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHBvcy54LCBwb3MueSwgMCwgcG9zLngsIHBvcy55LCBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbGUuaXNFZGdlKCkpIHtcbiAgICAgIHZhciBfc3RhcnQgPSBlbGUuc291cmNlRW5kcG9pbnQoKSxcbiAgICAgICAgX2VuZCA9IGVsZS50YXJnZXRFbmRwb2ludCgpO1xuICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3N0YXJ0LngsIF9zdGFydC55LCBfZW5kLngsIF9lbmQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcG9zID0gdXNlUGF0aHMgPyB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0gOiBlbGUucG9zaXRpb24oKSxcbiAgICAgICAgX3dpZHRoID0gZWxlLnBhZGRlZFdpZHRoKCksXG4gICAgICAgIF9oZWlnaHQgPSBlbGUucGFkZGVkSGVpZ2h0KCksXG4gICAgICAgIGhhbGZXaWR0aCA9IF93aWR0aCAvIDIsXG4gICAgICAgIGhhbGZIZWlnaHQgPSBfaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGUucHN0eWxlKCdiYWNrZ3JvdW5kLWdyYWRpZW50LWRpcmVjdGlvbicpLnZhbHVlO1xuICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgY2FzZSAndG8tYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLngsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLXRvcCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54LCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLngsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by1sZWZ0JzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by1yaWdodCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnksIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG8tYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgY2FzZSAndG8tcmlnaHQtYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggLSBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLXRvcC1yaWdodCc6XG4gICAgICAgIGNhc2UgJ3RvLXJpZ2h0LXRvcCc6XG4gICAgICAgICAgZ3JhZGllbnRTdHlsZSA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgKyBoYWxmSGVpZ2h0LCBfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0by1ib3R0b20tbGVmdCc6XG4gICAgICAgIGNhc2UgJ3RvLWxlZnQtYm90dG9tJzpcbiAgICAgICAgICBncmFkaWVudFN0eWxlID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChfcG9zLnggKyBoYWxmV2lkdGgsIF9wb3MueSAtIGhhbGZIZWlnaHQsIF9wb3MueCAtIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3RvLXRvcC1sZWZ0JzpcbiAgICAgICAgY2FzZSAndG8tbGVmdC10b3AnOlxuICAgICAgICAgIGdyYWRpZW50U3R5bGUgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KF9wb3MueCArIGhhbGZXaWR0aCwgX3Bvcy55ICsgaGFsZkhlaWdodCwgX3Bvcy54IC0gaGFsZldpZHRoLCBfcG9zLnkgLSBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFncmFkaWVudFN0eWxlKSByZXR1cm4gbnVsbDsgLy8gaW52YWxpZCBncmFkaWVudCBzdHlsZVxuXG4gIHZhciBoYXNQb3NpdGlvbnMgPSBwb3NpdGlvbnMubGVuZ3RoID09PSBjb2xvcnMubGVuZ3RoO1xuICB2YXIgbGVuZ3RoID0gY29sb3JzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGdyYWRpZW50U3R5bGUuYWRkQ29sb3JTdG9wKGhhc1Bvc2l0aW9ucyA/IHBvc2l0aW9uc1tpXSA6IGkgLyAobGVuZ3RoIC0gMSksICdyZ2JhKCcgKyBjb2xvcnNbaV1bMF0gKyAnLCcgKyBjb2xvcnNbaV1bMV0gKyAnLCcgKyBjb2xvcnNbaV1bMl0gKyAnLCcgKyBvcGFjaXR5ICsgJyknKTtcbiAgfVxuICByZXR1cm4gZ3JhZGllbnRTdHlsZTtcbn07XG5DUnAkNS5ncmFkaWVudEZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIGZpbGwsIG9wYWNpdHkpIHtcbiAgdmFyIGdyYWRpZW50U3R5bGUgPSB0aGlzLmNyZWF0ZUdyYWRpZW50U3R5bGVGb3IoY29udGV4dCwgJ2JhY2tncm91bmQnLCBlbGUsIGZpbGwsIG9wYWNpdHkpO1xuICBpZiAoIWdyYWRpZW50U3R5bGUpIHJldHVybiBudWxsOyAvLyBlcnJvclxuICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50U3R5bGU7XG59O1xuQ1JwJDUuY29sb3JGaWxsU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgciwgZywgYiwgYSkge1xuICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAvLyBpZiggY2FjaGUuZmlsbFN0eWxlICE9PSBmaWxsU3R5bGUgKXtcbiAgLy8gICBjb250ZXh0LmZpbGxTdHlsZSA9IGNhY2hlLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgLy8gfVxufTtcbkNScCQ1LmVsZUZpbGxTdHlsZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBlbGUsIG9wYWNpdHkpIHtcbiAgdmFyIGJhY2tncm91bmRGaWxsID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1maWxsJykudmFsdWU7XG4gIGlmIChiYWNrZ3JvdW5kRmlsbCA9PT0gJ2xpbmVhci1ncmFkaWVudCcgfHwgYmFja2dyb3VuZEZpbGwgPT09ICdyYWRpYWwtZ3JhZGllbnQnKSB7XG4gICAgdGhpcy5ncmFkaWVudEZpbGxTdHlsZShjb250ZXh0LCBlbGUsIGJhY2tncm91bmRGaWxsLCBvcGFjaXR5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmFja2dyb3VuZENvbG9yID0gZWxlLnBzdHlsZSgnYmFja2dyb3VuZC1jb2xvcicpLnZhbHVlO1xuICAgIHRoaXMuY29sb3JGaWxsU3R5bGUoY29udGV4dCwgYmFja2dyb3VuZENvbG9yWzBdLCBiYWNrZ3JvdW5kQ29sb3JbMV0sIGJhY2tncm91bmRDb2xvclsyXSwgb3BhY2l0eSk7XG4gIH1cbn07XG5DUnAkNS5ncmFkaWVudFN0cm9rZVN0eWxlID0gZnVuY3Rpb24gKGNvbnRleHQsIGVsZSwgZmlsbCwgb3BhY2l0eSkge1xuICB2YXIgZ3JhZGllbnRTdHlsZSA9IHRoaXMuY3JlYXRlR3JhZGllbnRTdHlsZUZvcihjb250ZXh0LCAnbGluZScsIGVsZSwgZmlsbCwgb3BhY2l0eSk7XG4gIGlmICghZ3JhZGllbnRTdHlsZSkgcmV0dXJuIG51bGw7IC8vIGVycm9yXG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBncmFkaWVudFN0eWxlO1xufTtcbkNScCQ1LmNvbG9yU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgciwgZywgYiwgYSkge1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgLy8gdmFyIHN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cbiAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAvLyB9XG59O1xuQ1JwJDUuZWxlU3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAoY29udGV4dCwgZWxlLCBvcGFjaXR5KSB7XG4gIHZhciBsaW5lRmlsbCA9IGVsZS5wc3R5bGUoJ2xpbmUtZmlsbCcpLnZhbHVlO1xuICBpZiAobGluZUZpbGwgPT09ICdsaW5lYXItZ3JhZGllbnQnIHx8IGxpbmVGaWxsID09PSAncmFkaWFsLWdyYWRpZW50Jykge1xuICAgIHRoaXMuZ3JhZGllbnRTdHJva2VTdHlsZShjb250ZXh0LCBlbGUsIGxpbmVGaWxsLCBvcGFjaXR5KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGluZUNvbG9yID0gZWxlLnBzdHlsZSgnbGluZS1jb2xvcicpLnZhbHVlO1xuICAgIHRoaXMuY29sb3JTdHJva2VTdHlsZShjb250ZXh0LCBsaW5lQ29sb3JbMF0sIGxpbmVDb2xvclsxXSwgbGluZUNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgfVxufTtcblxuLy8gUmVzaXplIGNhbnZhc1xuQ1JwJDUubWF0Y2hDYW52YXNTaXplID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBkYXRhID0gci5kYXRhO1xuICB2YXIgYmIgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgdmFyIHdpZHRoID0gYmJbMl07XG4gIHZhciBoZWlnaHQgPSBiYlszXTtcbiAgdmFyIHBpeGVsUmF0aW8gPSByLmdldFBpeGVsUmF0aW8oKTtcbiAgdmFyIG1iUHhSYXRpbyA9IHIubW90aW9uQmx1clB4UmF0aW87XG4gIGlmIChjb250YWluZXIgPT09IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8IGNvbnRhaW5lciA9PT0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pIHtcbiAgICBwaXhlbFJhdGlvID0gbWJQeFJhdGlvO1xuICB9XG4gIHZhciBjYW52YXNXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgdmFyIGNhbnZhc0hlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gIHZhciBjYW52YXM7XG4gIGlmIChjYW52YXNXaWR0aCA9PT0gci5jYW52YXNXaWR0aCAmJiBjYW52YXNIZWlnaHQgPT09IHIuY2FudmFzSGVpZ2h0KSB7XG4gICAgcmV0dXJuOyAvLyBzYXZlIGN5Y2xlcyBpZiBzYW1lXG4gIH1cbiAgci5mb250Q2FjaGVzID0gbnVsbDsgLy8gcmVzaXppbmcgcmVzZXRzIHRoZSBzdHlsZVxuXG4gIHZhciBjYW52YXNDb250YWluZXIgPSBkYXRhLmNhbnZhc0NvbnRhaW5lcjtcbiAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICBjYW52YXNDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgIGNhbnZhcyA9IGRhdGEuY2FudmFzZXNbaV07XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1tpXTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgfVxuICByLnRleHR1cmVNdWx0ID0gMTtcbiAgaWYgKHBpeGVsUmF0aW8gPD0gMSkge1xuICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgci50ZXh0dXJlTXVsdCA9IDI7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiByLnRleHR1cmVNdWx0O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0O1xuICB9XG4gIHIuY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcbiAgci5jYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gIHIucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG59O1xuQ1JwJDUucmVuZGVyVG8gPSBmdW5jdGlvbiAoY3h0LCB6b29tLCBwYW4sIHB4UmF0aW8pIHtcbiAgdGhpcy5yZW5kZXIoe1xuICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICBmb3JjZWRab29tOiB6b29tLFxuICAgIGZvcmNlZFBhbjogcGFuLFxuICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgZm9yY2VkUHhSYXRpbzogcHhSYXRpb1xuICB9KTtcbn07XG5DUnAkNS5jbGVhckNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgZGF0YSA9IHIuZGF0YTtcbiAgZnVuY3Rpb24gY2xlYXIoY29udGV4dCkge1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0KTtcbiAgfVxuICBjbGVhcihkYXRhLmNvbnRleHRzW3IuTk9ERV0pO1xuICBjbGVhcihkYXRhLmNvbnRleHRzW3IuRFJBR10pO1xufTtcbkNScCQ1LnJlbmRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciByID0gdGhpcztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgc3RhdGljRW1wdHlPYmplY3QoKTtcbiAgdmFyIGN5ID0gci5jeTtcbiAgdmFyIGZvcmNlZENvbnRleHQgPSBvcHRpb25zLmZvcmNlZENvbnRleHQ7XG4gIHZhciBkcmF3QWxsTGF5ZXJzID0gb3B0aW9ucy5kcmF3QWxsTGF5ZXJzO1xuICB2YXIgZHJhd09ubHlOb2RlTGF5ZXIgPSBvcHRpb25zLmRyYXdPbmx5Tm9kZUxheWVyO1xuICB2YXIgZm9yY2VkWm9vbSA9IG9wdGlvbnMuZm9yY2VkWm9vbTtcbiAgdmFyIGZvcmNlZFBhbiA9IG9wdGlvbnMuZm9yY2VkUGFuO1xuICB2YXIgcGl4ZWxSYXRpbyA9IG9wdGlvbnMuZm9yY2VkUHhSYXRpbyA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRQaXhlbFJhdGlvKCkgOiBvcHRpb25zLmZvcmNlZFB4UmF0aW87XG4gIHZhciBkYXRhID0gci5kYXRhO1xuICB2YXIgbmVlZERyYXcgPSBkYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuICB2YXIgdGV4dHVyZURyYXcgPSByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICYmIChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcpO1xuICB2YXIgbW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1ciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3Rpb25CbHVyIDogci5tb3Rpb25CbHVyO1xuICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcbiAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gIHZhciBpbk5vZGVEcmFnR2VzdHVyZSA9IHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcztcbiAgdmFyIGluQm94U2VsZWN0aW9uID0gci5ob3ZlckRhdGEuc2VsZWN0aW5nIHx8IHIudG91Y2hEYXRhLnNlbGVjdGluZyA/IHRydWUgOiBmYWxzZTtcbiAgbW90aW9uQmx1ciA9IG1vdGlvbkJsdXIgJiYgIWZvcmNlZENvbnRleHQgJiYgci5tb3Rpb25CbHVyRW5hYmxlZCAmJiAhaW5Cb3hTZWxlY3Rpb247XG4gIHZhciBtb3Rpb25CbHVyRmFkZUVmZmVjdCA9IG1vdGlvbkJsdXI7XG4gIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgIGlmIChyLnByZXZQeFJhdGlvICE9PSBwaXhlbFJhdGlvKSB7XG4gICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgci5tYXRjaENhbnZhc1NpemUoci5jb250YWluZXIpO1xuICAgICAgci5yZWRyYXdIaW50KCdlbGVzJywgdHJ1ZSk7XG4gICAgICByLnJlZHJhd0hpbnQoJ2RyYWcnLCB0cnVlKTtcbiAgICB9XG4gICAgci5wcmV2UHhSYXRpbyA9IHBpeGVsUmF0aW87XG4gIH1cbiAgaWYgKCFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1clRpbWVvdXQpIHtcbiAgICBjbGVhclRpbWVvdXQoci5tb3Rpb25CbHVyVGltZW91dCk7XG4gIH1cbiAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICBpZiAoci5tYkZyYW1lcyA9PSBudWxsKSB7XG4gICAgICByLm1iRnJhbWVzID0gMDtcbiAgICB9XG4gICAgci5tYkZyYW1lcysrO1xuICAgIGlmIChyLm1iRnJhbWVzIDwgMykge1xuICAgICAgLy8gbmVlZCBzZXZlcmFsIGZyYW1lcyBiZWZvcmUgZXZlbiBoaWdoIHF1YWxpdHkgbW90aW9uYmx1clxuICAgICAgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBnbyB0byBsb3dlciBxdWFsaXR5IGJsdXJyeSBmcmFtZXMgd2hlbiBzZXZlcmFsIG0vYiBmcmFtZXMgaGF2ZSBiZWVuIHJlbmRlcmVkIChhdm9pZHMgZmxhc2hpbmcpXG4gICAgaWYgKHIubWJGcmFtZXMgPiByLm1pbk1iTG93UXVhbEZyYW1lcykge1xuICAgICAgLy9yLmZ1bGxRdWFsaXR5TWIgPSBmYWxzZTtcbiAgICAgIHIubW90aW9uQmx1clB4UmF0aW8gPSByLm1iUHhSQmx1cnJ5O1xuICAgIH1cbiAgfVxuICBpZiAoci5jbGVhcmluZ01vdGlvbkJsdXIpIHtcbiAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgfVxuXG4gIC8vIGIvYyBkcmF3VG9Db250ZXh0KCkgbWF5IGJlIGFzeW5jIHcuci50LiByZWRyYXcoKSwga2VlcCB0cmFjayBvZiBsYXN0IHRleHR1cmUgZnJhbWVcbiAgLy8gYmVjYXVzZSBhIHJvZ3VlIGFzeW5jIHRleHR1cmUgZnJhbWUgd291bGQgY2xlYXIgbmVlZERyYXdcbiAgaWYgKHIudGV4dHVyZURyYXdMYXN0RnJhbWUgJiYgIXRleHR1cmVEcmF3KSB7XG4gICAgbmVlZERyYXdbci5OT0RFXSA9IHRydWU7XG4gICAgbmVlZERyYXdbci5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gIHZhciBlZmZlY3RpdmVab29tID0gZm9yY2VkWm9vbSAhPT0gdW5kZWZpbmVkID8gZm9yY2VkWm9vbSA6IHpvb207XG4gIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgdmFyIGVmZmVjdGl2ZVBhbiA9IHtcbiAgICB4OiBwYW4ueCxcbiAgICB5OiBwYW4ueVxuICB9O1xuICB2YXIgdnAgPSB7XG4gICAgem9vbTogem9vbSxcbiAgICBwYW46IHtcbiAgICAgIHg6IHBhbi54LFxuICAgICAgeTogcGFuLnlcbiAgICB9XG4gIH07XG4gIHZhciBwcmV2VnAgPSByLnByZXZWaWV3cG9ydDtcbiAgdmFyIHZpZXdwb3J0SXNEaWZmID0gcHJldlZwID09PSB1bmRlZmluZWQgfHwgdnAuem9vbSAhPT0gcHJldlZwLnpvb20gfHwgdnAucGFuLnggIT09IHByZXZWcC5wYW4ueCB8fCB2cC5wYW4ueSAhPT0gcHJldlZwLnBhbi55O1xuXG4gIC8vIHdlIHdhbnQgdGhlIGxvdyBxdWFsaXR5IG1vdGlvbmJsdXIgb25seSB3aGVuIHRoZSB2aWV3cG9ydCBpcyBiZWluZyBtYW5pcHVsYXRlZCBldGMgKHdoZXJlIGl0J3Mgbm90IG5vdGljZWQpXG4gIGlmICghdmlld3BvcnRJc0RpZmYgJiYgIShpbk5vZGVEcmFnR2VzdHVyZSAmJiAhaGFzQ29tcG91bmROb2RlcykpIHtcbiAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgfVxuICBpZiAoZm9yY2VkUGFuKSB7XG4gICAgZWZmZWN0aXZlUGFuID0gZm9yY2VkUGFuO1xuICB9XG5cbiAgLy8gYXBwbHkgcGl4ZWwgcmF0aW9cblxuICBlZmZlY3RpdmVab29tICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi54ICo9IHBpeGVsUmF0aW87XG4gIGVmZmVjdGl2ZVBhbi55ICo9IHBpeGVsUmF0aW87XG4gIHZhciBlbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICBmdW5jdGlvbiBtYmNsZWFyKGNvbnRleHQsIHgsIHksIHcsIGgpIHtcbiAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICByLmNvbG9yRmlsbFN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSk7XG4gICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgfVxuICBmdW5jdGlvbiBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKSB7XG4gICAgdmFyIGVQYW4sIGVab29tLCB3LCBoO1xuICAgIGlmICghci5jbGVhcmluZ01vdGlvbkJsdXIgJiYgKGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbci5NT1RJT05CTFVSX0JVRkZFUl9OT0RFXSB8fCBjb250ZXh0ID09PSBkYXRhLmJ1ZmZlckNvbnRleHRzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR10pKSB7XG4gICAgICBlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCAqIG1iUHhSYXRpbyxcbiAgICAgICAgeTogcGFuLnkgKiBtYlB4UmF0aW9cbiAgICAgIH07XG4gICAgICBlWm9vbSA9IHpvb20gKiBtYlB4UmF0aW87XG4gICAgICB3ID0gci5jYW52YXNXaWR0aCAqIG1iUHhSYXRpbztcbiAgICAgIGggPSByLmNhbnZhc0hlaWdodCAqIG1iUHhSYXRpbztcbiAgICB9IGVsc2Uge1xuICAgICAgZVBhbiA9IGVmZmVjdGl2ZVBhbjtcbiAgICAgIGVab29tID0gZWZmZWN0aXZlWm9vbTtcbiAgICAgIHcgPSByLmNhbnZhc1dpZHRoO1xuICAgICAgaCA9IHIuY2FudmFzSGVpZ2h0O1xuICAgIH1cbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBpZiAoY2xlYXIgPT09ICdtb3Rpb25CbHVyJykge1xuICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB3LCBoKTtcbiAgICB9IGVsc2UgaWYgKCFmb3JjZWRDb250ZXh0ICYmIChjbGVhciA9PT0gdW5kZWZpbmVkIHx8IGNsZWFyKSkge1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgfVxuICAgIGlmICghZHJhd0FsbExheWVycykge1xuICAgICAgY29udGV4dC50cmFuc2xhdGUoZVBhbi54LCBlUGFuLnkpO1xuICAgICAgY29udGV4dC5zY2FsZShlWm9vbSwgZVpvb20pO1xuICAgIH1cbiAgICBpZiAoZm9yY2VkUGFuKSB7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShmb3JjZWRQYW4ueCwgZm9yY2VkUGFuLnkpO1xuICAgIH1cbiAgICBpZiAoZm9yY2VkWm9vbSkge1xuICAgICAgY29udGV4dC5zY2FsZShmb3JjZWRab29tLCBmb3JjZWRab29tKTtcbiAgICB9XG4gIH1cbiAgaWYgKCF0ZXh0dXJlRHJhdykge1xuICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSBmYWxzZTtcbiAgfVxuICBpZiAodGV4dHVyZURyYXcpIHtcbiAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gdHJ1ZTtcbiAgICBpZiAoIXIudGV4dHVyZUNhY2hlKSB7XG4gICAgICByLnRleHR1cmVDYWNoZSA9IHt9O1xuICAgICAgci50ZXh0dXJlQ2FjaGUuYmIgPSBjeS5tdXRhYmxlRWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuICAgICAgci50ZXh0dXJlQ2FjaGUudGV4dHVyZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLlRFWFRVUkVfQlVGRkVSXTtcbiAgICAgIHZhciBjeHQgPSByLmRhdGEuYnVmZmVyQ29udGV4dHNbci5URVhUVVJFX0JVRkZFUl07XG4gICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdCwgci5jYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0KTtcbiAgICAgIHIucmVuZGVyKHtcbiAgICAgICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgICAgICBkcmF3T25seU5vZGVMYXllcjogdHJ1ZSxcbiAgICAgICAgZm9yY2VkUHhSYXRpbzogcGl4ZWxSYXRpbyAqIHIudGV4dHVyZU11bHRcbiAgICAgIH0pO1xuICAgICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQgPSB7XG4gICAgICAgIHpvb206IGN5Lnpvb20oKSxcbiAgICAgICAgcGFuOiBjeS5wYW4oKSxcbiAgICAgICAgd2lkdGg6IHIuY2FudmFzV2lkdGgsXG4gICAgICAgIGhlaWdodDogci5jYW52YXNIZWlnaHRcbiAgICAgIH07XG4gICAgICB2cC5tcGFuID0ge1xuICAgICAgICB4OiAoMCAtIHZwLnBhbi54KSAvIHZwLnpvb20sXG4gICAgICAgIHk6ICgwIC0gdnAucGFuLnkpIC8gdnAuem9vbVxuICAgICAgfTtcbiAgICB9XG4gICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIG5lZWREcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICB2YXIgdGV4dHVyZSA9IHIudGV4dHVyZUNhY2hlLnRleHR1cmU7XG4gICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQ7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICAgIG1iY2xlYXIoY29udGV4dCwgMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgIH1cbiAgICB2YXIgb3V0c2lkZUJnQ29sb3IgPSBzdHlsZS5jb3JlKCdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InKS52YWx1ZTtcbiAgICB2YXIgb3V0c2lkZUJnT3BhY2l0eSA9IHN0eWxlLmNvcmUoJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JykudmFsdWU7XG4gICAgci5jb2xvckZpbGxTdHlsZShjb250ZXh0LCBvdXRzaWRlQmdDb2xvclswXSwgb3V0c2lkZUJnQ29sb3JbMV0sIG91dHNpZGVCZ0NvbG9yWzJdLCBvdXRzaWRlQmdPcGFjaXR5KTtcbiAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgZmFsc2UpO1xuICAgIGNvbnRleHQuY2xlYXJSZWN0KHZwLm1wYW4ueCwgdnAubXBhbi55LCB2cC53aWR0aCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvLCB2cC5oZWlnaHQgLyB2cC56b29tIC8gcGl4ZWxSYXRpbyk7XG4gICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dHVyZSwgdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoIC8gdnAuem9vbSAvIHBpeGVsUmF0aW8sIHZwLmhlaWdodCAvIHZwLnpvb20gLyBwaXhlbFJhdGlvKTtcbiAgfSBlbHNlIGlmIChyLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0KSB7XG4gICAgLy8gY2xlYXIgdGhlIGNhY2hlIHNpbmNlIHdlIGRvbid0IG5lZWQgaXRcbiAgICByLnRleHR1cmVDYWNoZSA9IG51bGw7XG4gIH1cbiAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuICB2YXIgdnBNYW5pcCA9IHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgfHwgci5jeS5hbmltYXRlZCgpO1xuICB2YXIgaGlkZUVkZ2VzID0gci5oaWRlRWRnZXNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG4gIHZhciBuZWVkTWJDbGVhciA9IFtdO1xuICBuZWVkTWJDbGVhcltyLk5PREVdID0gIW5lZWREcmF3W3IuTk9ERV0gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLk5PREVdIHx8IHIuY2xlYXJpbmdNb3Rpb25CbHVyO1xuICBpZiAobmVlZE1iQ2xlYXJbci5OT0RFXSkge1xuICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSA9IHRydWU7XG4gIH1cbiAgbmVlZE1iQ2xlYXJbci5EUkFHXSA9ICFuZWVkRHJhd1tyLkRSQUddICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5EUkFHXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgaWYgKG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW3IuRFJBR10gPSB0cnVlO1xuICB9XG4gIGlmIChuZWVkRHJhd1tyLk5PREVdIHx8IGRyYXdBbGxMYXllcnMgfHwgZHJhd09ubHlOb2RlTGF5ZXIgfHwgbmVlZE1iQ2xlYXJbci5OT0RFXSkge1xuICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhcltyLk5PREVdICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIDogZGF0YS5jb250ZXh0c1tyLk5PREVdKTtcbiAgICB2YXIgY2xlYXIgPSBtb3Rpb25CbHVyICYmICF1c2VCdWZmZXIgPyAnbW90aW9uQmx1cicgOiB1bmRlZmluZWQ7XG4gICAgc2V0Q29udGV4dFRyYW5zZm9ybShjb250ZXh0LCBjbGVhcik7XG4gICAgaWYgKGhpZGVFZGdlcykge1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoY29udGV4dCwgZWxlcy5ub25kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdMYXllcmVkRWxlbWVudHMoY29udGV4dCwgZWxlcy5ub25kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH1cbiAgICBpZiAoci5kZWJ1Zykge1xuICAgICAgci5kcmF3RGVidWdQb2ludHMoY29udGV4dCwgZWxlcy5ub25kcmFnKTtcbiAgICB9XG4gICAgaWYgKCFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyKSB7XG4gICAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICghZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W3IuRFJBR10gfHwgZHJhd0FsbExheWVycyB8fCBuZWVkTWJDbGVhcltyLkRSQUddKSkge1xuICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhcltyLkRSQUddICYmIG1iUHhSYXRpbyAhPT0gMTtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1tyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUddIDogZGF0YS5jb250ZXh0c1tyLkRSQUddKTtcbiAgICBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIG1vdGlvbkJsdXIgJiYgIXVzZUJ1ZmZlciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKGhpZGVFZGdlcykge1xuICAgICAgci5kcmF3Q2FjaGVkTm9kZXMoY29udGV4dCwgZWxlcy5kcmFnLCBwaXhlbFJhdGlvLCBleHRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByLmRyYXdDYWNoZWRFbGVtZW50cyhjb250ZXh0LCBlbGVzLmRyYWcsIHBpeGVsUmF0aW8sIGV4dGVudCk7XG4gICAgfVxuICAgIGlmIChyLmRlYnVnKSB7XG4gICAgICByLmRyYXdEZWJ1Z1BvaW50cyhjb250ZXh0LCBlbGVzLmRyYWcpO1xuICAgIH1cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMgJiYgIW1vdGlvbkJsdXIpIHtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdGhpcy5kcmF3U2VsZWN0aW9uUmVjdGFuZ2xlKG9wdGlvbnMsIHNldENvbnRleHRUcmFuc2Zvcm0pO1xuXG4gIC8vIG1vdGlvbmJsdXI6IGJsaXQgcmVuZGVyZWQgYmx1cnJ5IGZyYW1lc1xuICBpZiAobW90aW9uQmx1ciAmJiBtYlB4UmF0aW8gIT09IDEpIHtcbiAgICB2YXIgY3h0Tm9kZSA9IGRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgICB2YXIgdHh0Tm9kZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1tyLk1PVElPTkJMVVJfQlVGRkVSX05PREVdO1xuICAgIHZhciBjeHREcmFnID0gZGF0YS5jb250ZXh0c1tyLkRSQUddO1xuICAgIHZhciB0eHREcmFnID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW3IuTU9USU9OQkxVUl9CVUZGRVJfRFJBR107XG4gICAgdmFyIGRyYXdNb3Rpb25CbHVyID0gZnVuY3Rpb24gZHJhd01vdGlvbkJsdXIoY3h0LCB0eHQsIG5lZWRDbGVhcikge1xuICAgICAgY3h0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGlmIChuZWVkQ2xlYXIgfHwgIW1vdGlvbkJsdXJGYWRlRWZmZWN0KSB7XG4gICAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWJjbGVhcihjeHQsIDAsIDAsIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHZhciBweHIgPSBtYlB4UmF0aW87XG4gICAgICBjeHQuZHJhd0ltYWdlKHR4dCxcbiAgICAgIC8vIGltZ1xuICAgICAgMCwgMCxcbiAgICAgIC8vIHN4LCBzeVxuICAgICAgci5jYW52YXNXaWR0aCAqIHB4ciwgci5jYW52YXNIZWlnaHQgKiBweHIsXG4gICAgICAvLyBzdywgc2hcbiAgICAgIDAsIDAsXG4gICAgICAvLyB4LCB5XG4gICAgICByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCAvLyB3LCBoXG4gICAgICApO1xuICAgIH07XG4gICAgaWYgKG5lZWREcmF3W3IuTk9ERV0gfHwgbmVlZE1iQ2xlYXJbci5OT0RFXSkge1xuICAgICAgZHJhd01vdGlvbkJsdXIoY3h0Tm9kZSwgdHh0Tm9kZSwgbmVlZE1iQ2xlYXJbci5OT0RFXSk7XG4gICAgICBuZWVkRHJhd1tyLk5PREVdID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChuZWVkRHJhd1tyLkRSQUddIHx8IG5lZWRNYkNsZWFyW3IuRFJBR10pIHtcbiAgICAgIGRyYXdNb3Rpb25CbHVyKGN4dERyYWcsIHR4dERyYWcsIG5lZWRNYkNsZWFyW3IuRFJBR10pO1xuICAgICAgbmVlZERyYXdbci5EUkFHXSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByLnByZXZWaWV3cG9ydCA9IHZwO1xuICBpZiAoci5jbGVhcmluZ01vdGlvbkJsdXIpIHtcbiAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9IGZhbHNlO1xuICAgIHIubW90aW9uQmx1ckNsZWFyZWQgPSB0cnVlO1xuICAgIHIubW90aW9uQmx1ciA9IHRydWU7XG4gIH1cbiAgaWYgKG1vdGlvbkJsdXIpIHtcbiAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbci5OT0RFXSA9IGZhbHNlO1xuICAgICAgci5jbGVhcmVkRm9yTW90aW9uQmx1cltyLkRSQUddID0gZmFsc2U7XG4gICAgICByLm1vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gIXRleHR1cmVEcmF3O1xuICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgICBuZWVkRHJhd1tyLk5PREVdID0gdHJ1ZTtcbiAgICAgIG5lZWREcmF3W3IuRFJBR10gPSB0cnVlO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9LCBtb3Rpb25CbHVyRGVsYXkpO1xuICB9XG4gIGlmICghZm9yY2VkQ29udGV4dCkge1xuICAgIGN5LmVtaXQoJ3JlbmRlcicpO1xuICB9XG59O1xudmFyIGZwc0hlaWdodDtcbkNScCQ1LmRyYXdTZWxlY3Rpb25SZWN0YW5nbGUgPSBmdW5jdGlvbiAob3B0aW9ucywgc2V0Q29udGV4dFRyYW5zZm9ybSkge1xuICB2YXIgciA9IHRoaXM7XG4gIHZhciBjeSA9IHIuY3k7XG4gIHZhciBkYXRhID0gci5kYXRhO1xuICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICB2YXIgZHJhd09ubHlOb2RlTGF5ZXIgPSBvcHRpb25zLmRyYXdPbmx5Tm9kZUxheWVyO1xuICB2YXIgZHJhd0FsbExheWVycyA9IG9wdGlvbnMuZHJhd0FsbExheWVycztcbiAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgdmFyIGZvcmNlZENvbnRleHQgPSBvcHRpb25zLmZvcmNlZENvbnRleHQ7XG4gIGlmIChyLnNob3dGcHMgfHwgIWRyYXdPbmx5Tm9kZUxheWVyICYmIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gJiYgIWRyYXdBbGxMYXllcnMpIHtcbiAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgZGF0YS5jb250ZXh0c1tyLlNFTEVDVF9CT1hdO1xuICAgIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCk7XG4gICAgaWYgKHIuc2VsZWN0aW9uWzRdID09IDEgJiYgKHIuaG92ZXJEYXRhLnNlbGVjdGluZyB8fCByLnRvdWNoRGF0YS5zZWxlY3RpbmcpKSB7XG4gICAgICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnKS52YWx1ZSAvIHpvb207XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzBdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzFdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICBjb250ZXh0LmZpbGxSZWN0KHIuc2VsZWN0aW9uWzBdLCByLnNlbGVjdGlvblsxXSwgci5zZWxlY3Rpb25bMl0gLSByLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bM10gLSByLnNlbGVjdGlvblsxXSk7XG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJykudmFsdWVbMV0gKyAnLCcgKyBzdHlsZS5jb3JlKCdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicpLnZhbHVlWzJdICsgJywnICsgc3R5bGUuY29yZSgnc2VsZWN0aW9uLWJveC1vcGFjaXR5JykudmFsdWUgKyAnKSc7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChyLnNlbGVjdGlvblswXSwgci5zZWxlY3Rpb25bMV0sIHIuc2VsZWN0aW9uWzJdIC0gci5zZWxlY3Rpb25bMF0sIHIuc2VsZWN0aW9uWzNdIC0gci5zZWxlY3Rpb25bMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nKSB7XG4gICAgICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICAgICAgdmFyIHBvcyA9IGRhdGEuYmdBY3RpdmVQb3Npc3Rpb247XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctY29sb3InKS52YWx1ZVswXSArICcsJyArIHN0eWxlLmNvcmUoJ2FjdGl2ZS1iZy1jb2xvcicpLnZhbHVlWzFdICsgJywnICsgc3R5bGUuY29yZSgnYWN0aXZlLWJnLWNvbG9yJykudmFsdWVbMl0gKyAnLCcgKyBzdHlsZS5jb3JlKCdhY3RpdmUtYmctb3BhY2l0eScpLnZhbHVlICsgJyknO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKHBvcy54LCBwb3MueSwgc3R5bGUuY29yZSgnYWN0aXZlLWJnLXNpemUnKS5wZlZhbHVlIC8gem9vbSwgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmxhc3RSZWRyYXdUaW1lO1xuICAgIGlmIChyLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyKSB7XG4gICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKHRpbWVUb1JlbmRlcik7XG4gICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwIC8gdGltZVRvUmVuZGVyKTtcbiAgICAgIHZhciB0ZXh0ID0gJzEgZnJhbWUgPSAnICsgdGltZVRvUmVuZGVyICsgJyBtcyA9ICcgKyBmcHMgKyAnIGZwcyc7XG4gICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICAvLyBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICBjb250ZXh0LmZvbnQgPSAnMzBweCBBcmlhbCc7XG4gICAgICBpZiAoIWZwc0hlaWdodCkge1xuICAgICAgICB2YXIgZGltcyA9IGNvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG4gICAgICAgIGZwc0hlaWdodCA9IGRpbXMuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIDAsIGZwc0hlaWdodCk7XG4gICAgICB2YXIgbWF4RnBzID0gNjA7XG4gICAgICBjb250ZXh0LnN0cm9rZVJlY3QoMCwgZnBzSGVpZ2h0ICsgMTAsIDI1MCwgMjApO1xuICAgICAgY29udGV4dC5maWxsUmVjdCgwLCBmcHNIZWlnaHQgKyAxMCwgMjUwICogTWF0aC5taW4oZnBzIC8gbWF4RnBzLCAxKSwgMjApO1xuICAgIH1cbiAgICBpZiAoIWRyYXdBbGxMYXllcnMpIHtcbiAgICAgIG5lZWREcmF3W3IuU0VMRUNUX0JPWF0gPSBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTm90ZXM6XG4gKiAtIEFsbCBjb2xvcnMgaGF2ZSBwcmVtdWx0aXBsaWVkIGFscGhhLiBWZXJ5IGltcG9ydGFudCBmb3IgdGV4dHVlcyBhbmQgXG4gKiAgIGJsZW5kaW5nIHRvIHdvcmsgY29ycmVjdGx5LlxuICovXG5cbmZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoZ2wsIHR5cGUsIHNvdXJjZSkge1xuICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XG4gIH1cbiAgLy8gY29uc29sZS5sb2coZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgcmV0dXJuIHNoYWRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNvdXJjZSwgZnJhZ2VtZW50U291cmNlKSB7XG4gIHZhciB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTb3VyY2UpO1xuICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdlbWVudFNvdXJjZSk7XG4gIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBpbml0aWFsaXplIHNoYWRlcnMnKTtcbiAgfVxuICByZXR1cm4gcHJvZ3JhbTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9mZnNjcmVuIGNhbnZhcyB3aXRoIGEgMkQgY29udGV4dCwgZm9yIHRoZVxuICogY2FudmFzIHJlbmRlcmVyIHRvIHVzZSBmb3IgZHJhd2luZyB0ZXh0dXJlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZUNhbnZhcyhyLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmIChoZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgIGhlaWdodCA9IHdpZHRoO1xuICB9XG4gIHZhciBjYW52YXMgPSByLm1ha2VPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIHZhciBjdHggPSBjYW52YXMuY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjYW52YXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgfTtcbiAgY2FudmFzLmNsZWFyKCk7XG4gIHJldHVybiBjYW52YXM7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBwYW4gJiB6b29tIHZhbHVlcywgc2NhbGVkIGJ5IHRoZSBwaXhlbCByYXRpby5cbiAqL1xuZnVuY3Rpb24gZ2V0RWZmZWN0aXZlUGFuWm9vbShyKSB7XG4gIHZhciBwaXhlbFJhdGlvID0gci5waXhlbFJhdGlvO1xuICB2YXIgem9vbSA9IHIuY3kuem9vbSgpO1xuICB2YXIgcGFuID0gci5jeS5wYW4oKTtcbiAgcmV0dXJuIHtcbiAgICB6b29tOiB6b29tICogcGl4ZWxSYXRpbyxcbiAgICBwYW46IHtcbiAgICAgIHg6IHBhbi54ICogcGl4ZWxSYXRpbyxcbiAgICAgIHk6IHBhbi55ICogcGl4ZWxSYXRpb1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB6b29tIHZhbHVlLCBzY2FsZWQgYnkgdGhlIHBpeGVsIHJhdGlvLlxuICovXG5mdW5jdGlvbiBnZXRFZmZlY3RpdmVab29tKHIpIHtcbiAgdmFyIHBpeGVsUmF0aW8gPSByLnBpeGVsUmF0aW87XG4gIHZhciB6b29tID0gci5jeS56b29tKCk7XG4gIHJldHVybiB6b29tICogcGl4ZWxSYXRpbztcbn1cbmZ1bmN0aW9uIG1vZGVsVG9SZW5kZXJlZFBvc2l0aW9uKHIsIHBhbiwgem9vbSwgeCwgeSkge1xuICB2YXIgcnggPSB4ICogem9vbSArIHBhbi54O1xuICB2YXIgcnkgPSB5ICogem9vbSArIHBhbi55O1xuICByeSA9IE1hdGgucm91bmQoci5jYW52YXNIZWlnaHQgLSByeSk7IC8vIGFkanVzdCBmb3Igd2ViZ2xcbiAgcmV0dXJuIFtyeCwgcnldO1xufVxuZnVuY3Rpb24gaXNTaW1wbGVTaGFwZShub2RlKSB7XG4gIC8vIHRoZSBhY3R1YWwgc2hhcGUgaXMgY2hlY2tlZCBpbiBFbGVtZW50RHJhd2luZ1dlYkdMLl9nZXRWZXJ0VHlwZUZvclNoYXBlKClcbiAgLy8gbm8gbmVlZCB0byBjaGVjayBpdCB0d2ljZSwgdGhpcyBqdXN0IGNoZWNrcyBvdGhlciB2aXN1YWwgcHJvcGVydGllc1xuICBpZiAobm9kZS5wc3R5bGUoJ2JhY2tncm91bmQtZmlsbCcpLnZhbHVlICE9PSAnc29saWQnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnBzdHlsZSgnYmFja2dyb3VuZC1pbWFnZScpLnN0clZhbHVlICE9PSAnbm9uZScpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS52YWx1ZSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIGlmIChub2RlLnBzdHlsZSgnYm9yZGVyLW9wYWNpdHknKS52YWx1ZSA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIC8vIHdlIGhhdmUgYSBib3JkZXIgYnV0IGl0IG11c3QgYmUgc2ltcGxlXG4gIGlmIChub2RlLnBzdHlsZSgnYm9yZGVyLXN0eWxlJykudmFsdWUgIT09ICdzb2xpZCcpIHJldHVybiBmYWxzZTtcbiAgLy8gVE9ETyBpZ25vcmluZyAnYm9yZGVyLWNhcCcsICdib3JkZXItam9pbicgYW5kICdib3JkZXItcG9zaXRpb24nIGZvciBub3dcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhcnJheUVxdWFsKGExLCBhMikge1xuICBpZiAoYTEubGVuZ3RoICE9PSBhMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhMVtpXSAhPT0gYTJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGFrZXMgY29sb3IgJiBvcGFjaXR5IHN0eWxlIHZhbHVlcyBhbmQgY29udmVydHMgdGhlbSB0byBXZWJHTCBmb3JtYXQuIFxuICogQWxwaGEgaXMgcHJlbXVsdGlwbGllZC5cbiAqL1xuZnVuY3Rpb24gdG9XZWJHTENvbG9yKGNvbG9yLCBvcGFjaXR5LCBvdXRBcnJheSkge1xuICB2YXIgciA9IGNvbG9yWzBdIC8gMjU1O1xuICB2YXIgZyA9IGNvbG9yWzFdIC8gMjU1O1xuICB2YXIgYiA9IGNvbG9yWzJdIC8gMjU1O1xuICB2YXIgYSA9IG9wYWNpdHk7XG4gIHZhciBhcnIgPSBvdXRBcnJheSB8fCBuZXcgQXJyYXkoNCk7XG4gIGFyclswXSA9IHIgKiBhO1xuICBhcnJbMV0gPSBnICogYTtcbiAgYXJyWzJdID0gYiAqIGE7XG4gIGFyclszXSA9IGE7XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBpbmRleFRvVmVjNChpbmRleCwgb3V0QXJyYXkpIHtcbiAgdmFyIGFyciA9IG91dEFycmF5IHx8IG5ldyBBcnJheSg0KTtcbiAgYXJyWzBdID0gKGluZGV4ID4+IDAgJiAweEZGKSAvIDB4RkY7XG4gIGFyclsxXSA9IChpbmRleCA+PiA4ICYgMHhGRikgLyAweEZGO1xuICBhcnJbMl0gPSAoaW5kZXggPj4gMTYgJiAweEZGKSAvIDB4RkY7XG4gIGFyclszXSA9IChpbmRleCA+PiAyNCAmIDB4RkYpIC8gMHhGRjtcbiAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIHZlYzRUb0luZGV4KHZlYzQpIHtcbiAgcmV0dXJuIHZlYzRbMF0gKyAodmVjNFsxXSA8PCA4KSArICh2ZWM0WzJdIDw8IDE2KSArICh2ZWM0WzNdIDw8IDI0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUoZ2wsIGRlYnVnSUQpIHtcbiAgdmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIHRleHR1cmUuYnVmZmVyID0gZnVuY3Rpb24gKG9mZnNjcmVlbkNhbnZhcykge1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QpO1xuXG4gICAgLy8gdmVyeSBpbXBvcnRhbnQsIHRoaXMgdGVsbHMgd2ViZ2wgdG8gcHJlbXVsdGlwbHkgY29sb3JzIGJ5IHRoZSBhbHBoYSBjaGFubmVsXG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG9mZnNjcmVlbkNhbnZhcyk7XG4gICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gIH07XG4gIHRleHR1cmUuZGVsZXRlVGV4dHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBnbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpO1xuICB9O1xuICByZXR1cm4gdGV4dHVyZTtcbn1cbmZ1bmN0aW9uIGdldFR5cGVJbmZvKGdsLCBnbHNsVHlwZSkge1xuICBzd2l0Y2ggKGdsc2xUeXBlKSB7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgcmV0dXJuIFsxLCBnbC5GTE9BVCwgNF07XG4gICAgY2FzZSAndmVjMic6XG4gICAgICByZXR1cm4gWzIsIGdsLkZMT0FULCA0XTtcbiAgICBjYXNlICd2ZWMzJzpcbiAgICAgIHJldHVybiBbMywgZ2wuRkxPQVQsIDRdO1xuICAgIGNhc2UgJ3ZlYzQnOlxuICAgICAgcmV0dXJuIFs0LCBnbC5GTE9BVCwgNF07XG4gICAgY2FzZSAnaW50JzpcbiAgICAgIHJldHVybiBbMSwgZ2wuSU5ULCA0XTtcbiAgICBjYXNlICdpdmVjMic6XG4gICAgICByZXR1cm4gWzIsIGdsLklOVCwgNF07XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVkQXJyYXkoZ2wsIGdsVHlwZSwgZGF0YU9yU2l6ZSkge1xuICBzd2l0Y2ggKGdsVHlwZSkge1xuICAgIGNhc2UgZ2wuRkxPQVQ6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShkYXRhT3JTaXplKTtcbiAgICBjYXNlIGdsLklOVDpcbiAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShkYXRhT3JTaXplKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVHlwZWRBcnJheVZpZXcoZ2wsIGdsVHlwZSwgYXJyYXksIHN0cmlkZSwgc2l6ZSwgaSkge1xuICBzd2l0Y2ggKGdsVHlwZSkge1xuICAgIGNhc2UgZ2wuRkxPQVQ6XG4gICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShhcnJheS5idWZmZXIsIGkgKiBzdHJpZGUsIHNpemUpO1xuICAgIGNhc2UgZ2wuSU5UOlxuICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KGFycmF5LmJ1ZmZlciwgaSAqIHN0cmlkZSwgc2l6ZSk7XG4gIH1cbn1cblxuLyoqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAqL1xuZnVuY3Rpb24gY3JlYXRlQnVmZmVyU3RhdGljRHJhdyhnbCwgdHlwZSwgYXR0cmlidXRlTG9jLCBkYXRhQXJyYXkpIHtcbiAgdmFyIF9nZXRUeXBlSW5mbyA9IGdldFR5cGVJbmZvKGdsLCB0eXBlKSxcbiAgICBfZ2V0VHlwZUluZm8yID0gX3NsaWNlZFRvQXJyYXkoX2dldFR5cGVJbmZvLCAyKSxcbiAgICBzaXplID0gX2dldFR5cGVJbmZvMlswXSxcbiAgICBnbFR5cGUgPSBfZ2V0VHlwZUluZm8yWzFdO1xuICB2YXIgZGF0YSA9IGNyZWF0ZVR5cGVkQXJyYXkoZ2wsIGdsVHlwZSwgZGF0YUFycmF5KTtcbiAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcbiAgaWYgKGdsVHlwZSA9PT0gZ2wuRkxPQVQpIHtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGF0dHJpYnV0ZUxvYywgc2l6ZSwgZ2xUeXBlLCBmYWxzZSwgMCwgMCk7XG4gIH0gZWxzZSBpZiAoZ2xUeXBlID09PSBnbC5JTlQpIHtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJJUG9pbnRlcihhdHRyaWJ1dGVMb2MsIHNpemUsIGdsVHlwZSwgMCwgMCk7XG4gIH1cbiAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlidXRlTG9jKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKiogXG4gKiBDcmVhdGVzIGEgZmxvYXQgYnVmZmVyIHdpdGggZ2wuRFlOQU1JQ19EUkFXLlxuICogVGhlIHJldHVybmVkIGJ1ZmZlciBvYmplY3QgY29udGFpbnMgZnVuY3Rpb25zIHRvIGVhc2lseSBzZXQgaW5zdGFuY2UgZGF0YSBhbmQgYnVmZmVyIHRoZSBkYXRhIGJlZm9yZSBhIGRyYXcgY2FsbC5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIGluc3RhbmNlcywgdHlwZSwgYXR0cmlidXRlTG9jKSB7XG4gIHZhciBfZ2V0VHlwZUluZm8zID0gZ2V0VHlwZUluZm8oZ2wsIHR5cGUpLFxuICAgIF9nZXRUeXBlSW5mbzQgPSBfc2xpY2VkVG9BcnJheShfZ2V0VHlwZUluZm8zLCAzKSxcbiAgICBzaXplID0gX2dldFR5cGVJbmZvNFswXSxcbiAgICBnbFR5cGUgPSBfZ2V0VHlwZUluZm80WzFdLFxuICAgIGJ5dGVzID0gX2dldFR5cGVJbmZvNFsyXTtcbiAgdmFyIGRhdGFBcnJheSA9IGNyZWF0ZVR5cGVkQXJyYXkoZ2wsIGdsVHlwZSwgaW5zdGFuY2VzICogc2l6ZSk7XG4gIHZhciBzdHJpZGUgPSBzaXplICogYnl0ZXM7XG4gIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBpbnN0YW5jZXMgKiBzdHJpZGUsIGdsLkRZTkFNSUNfRFJBVyk7XG4gIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJpYnV0ZUxvYyk7XG4gIGlmIChnbFR5cGUgPT09IGdsLkZMT0FUKSB7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihhdHRyaWJ1dGVMb2MsIHNpemUsIGdsVHlwZSwgZmFsc2UsIHN0cmlkZSwgMCk7XG4gIH0gZWxzZSBpZiAoZ2xUeXBlID09PSBnbC5JTlQpIHtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJJUG9pbnRlcihhdHRyaWJ1dGVMb2MsIHNpemUsIGdsVHlwZSwgc3RyaWRlLCAwKTtcbiAgfVxuICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGF0dHJpYnV0ZUxvYywgMSk7XG4gIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcblxuICAvLyB1c2UgYXJyYXkgdmlld3MgdG8gc2V0IHZhbHVlcyBkaXJlY3RseSBpbnRvIHRoZSBidWZmZXIgYXJyYXlcbiAgdmFyIHZpZXdzID0gbmV3IEFycmF5KGluc3RhbmNlcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdGFuY2VzOyBpKyspIHtcbiAgICB2aWV3c1tpXSA9IGNyZWF0ZVR5cGVkQXJyYXlWaWV3KGdsLCBnbFR5cGUsIGRhdGFBcnJheSwgc3RyaWRlLCBzaXplLCBpKTtcbiAgfVxuICBidWZmZXIuZGF0YUFycmF5ID0gZGF0YUFycmF5O1xuICBidWZmZXIuc3RyaWRlID0gc3RyaWRlO1xuICBidWZmZXIuc2l6ZSA9IHNpemU7XG4gIGJ1ZmZlci5nZXRWaWV3ID0gZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gdmlld3NbaV07XG4gIH07XG4gIGJ1ZmZlci5zZXRQb2ludCA9IGZ1bmN0aW9uIChpLCB4LCB5KSB7XG4gICAgdmFyIHZpZXcgPSB2aWV3c1tpXTtcbiAgICB2aWV3WzBdID0geDtcbiAgICB2aWV3WzFdID0geTtcbiAgfTtcbiAgYnVmZmVyLmJ1ZmZlclN1YkRhdGEgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCBkYXRhQXJyYXksIDAsIGNvdW50ICogc2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCBkYXRhQXJyYXkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqIFxuICogQ3JlYXRlcyBhIGJ1ZmZlciBvZiAzeDMgbWF0cml4IGRhdGEgZm9yIHVzZSBhcyBhdHRyaWJ1dGUgZGF0YS5cbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlM3gzTWF0cml4QnVmZmVyRHluYW1pY0RyYXcoZ2wsIGluc3RhbmNlcywgYXR0cmlidXRlTG9jKSB7XG4gIHZhciBtYXRyaXhTaXplID0gOTsgLy8gM3gzIG1hdHJpeFxuICB2YXIgbWF0cml4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoaW5zdGFuY2VzICogbWF0cml4U2l6ZSk7XG5cbiAgLy8gdXNlIG1hdHJpeCB2aWV3cyB0byBzZXQgdmFsdWVzIGRpcmVjdGx5IGludG8gdGhlIG1hdHJpeERhdGEgYXJyYXlcbiAgdmFyIG1hdHJpeFZpZXdzID0gbmV3IEFycmF5KGluc3RhbmNlcyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdGFuY2VzOyBpKyspIHtcbiAgICB2YXIgYnl0ZU9mZnNldCA9IGkgKiBtYXRyaXhTaXplICogNDsgLy8gNCBieXRlcyBwZXIgZmxvYXRcbiAgICBtYXRyaXhWaWV3c1tpXSA9IG5ldyBGbG9hdDMyQXJyYXkobWF0cml4RGF0YS5idWZmZXIsIGJ5dGVPZmZzZXQsIG1hdHJpeFNpemUpOyAvLyBhcnJheSB2aWV3XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG1hdHJpeERhdGEuYnl0ZUxlbmd0aCwgZ2wuRFlOQU1JQ19EUkFXKTtcblxuICAvLyBlYWNoIHJvdyBvZiB0aGUgbWF0cml4IG5lZWRzIHRvIGJlIGEgc2VwYXJhdGUgYXR0cmlidXRlXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCAzOyBfaSsrKSB7XG4gICAgdmFyIGxvYyA9IGF0dHJpYnV0ZUxvYyArIF9pO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvYyk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2MsIDMsIGdsLkZMT0FULCBmYWxzZSwgMyAqIDEyLCBfaSAqIDEyKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGxvYywgMSk7XG4gIH1cbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICBidWZmZXIuZ2V0TWF0cml4VmlldyA9IGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIG1hdHJpeFZpZXdzW2ldO1xuICB9O1xuXG4gIC8vIFRPRE8gdGhpcyBpcyB0b28gc2xvdywgdXNlIGdldE1hdHJpeFZpZXcgYW5kIHBhc3MgdGhlIHZpZXcgZGlyZWN0bHkgdG8gdGhlIGdsbWF0cml4IGxpYnJhcnlcbiAgYnVmZmVyLnNldERhdGEgPSBmdW5jdGlvbiAobWF0cml4LCBpKSB7XG4gICAgbWF0cml4Vmlld3NbaV0uc2V0KG1hdHJpeCwgMCk7XG4gIH07XG4gIGJ1ZmZlci5idWZmZXJTdWJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCBtYXRyaXhEYXRhKTtcbiAgfTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqIFxuICogQ3JlYXRlcyBhIEZyYW1lIEJ1ZmZlciB0byB1c2UgZm9yIG9mZnNjcmVlbiByZW5kZXJpbmcuXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBpY2tpbmdGcmFtZUJ1ZmZlcihnbCkge1xuICAvLyBDcmVhdGUgYW5kIGJpbmQgdGhlIGZyYW1lYnVmZmVyXG4gIHZhciBmYiA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmIpO1xuXG4gIC8vIENyZWF0ZSBhIHRleHR1cmUgdG8gcmVuZGVyIHRvXG4gIHZhciB0YXJnZXRUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0YXJnZXRUZXh0dXJlKTtcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblxuICAvLyBhdHRhY2ggdGhlIHRleHR1cmUgYXMgdGhlIGZpcnN0IGNvbG9yIGF0dGFjaG1lbnRcbiAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0YXJnZXRUZXh0dXJlLCAwKTtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgZmIuc2V0RnJhbWVidWZmZXJBdHRhY2htZW50U2l6ZXMgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRhcmdldFRleHR1cmUpO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gIH07XG4gIHJldHVybiBmYjtcbn1cblxuLyoqXG4gKiBDb21tb24gdXRpbGl0aWVzXG4gKiBAbW9kdWxlIGdsTWF0cml4XG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG52YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59O1xuXG4vKipcbiAqIDN4MyBNYXRyaXhcbiAqIEBtb2R1bGUgbWF0M1xuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQzXG4gKlxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgQVJSQVlfVFlQRSg5KTtcblxuICBpZiAoQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cblxuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDAgPSBiWzBdLFxuICAgICAgYjAxID0gYlsxXSxcbiAgICAgIGIwMiA9IGJbMl07XG4gIHZhciBiMTAgPSBiWzNdLFxuICAgICAgYjExID0gYls0XSxcbiAgICAgIGIxMiA9IGJbNV07XG4gIHZhciBiMjAgPSBiWzZdLFxuICAgICAgYjIxID0gYls3XSxcbiAgICAgIGIyMiA9IGJbOF07XG4gIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgb3V0WzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG4gIG91dFszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG4gIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XSxcbiAgICAgIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XSxcbiAgICAgIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IGEwMDtcbiAgb3V0WzFdID0gYTAxO1xuICBvdXRbMl0gPSBhMDI7XG4gIG91dFszXSA9IGExMDtcbiAgb3V0WzRdID0gYTExO1xuICBvdXRbNV0gPSBhMTI7XG4gIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XSxcbiAgICAgIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XSxcbiAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGMgKiBhMDAgKyBzICogYTEwO1xuICBvdXRbMV0gPSBjICogYTAxICsgcyAqIGExMTtcbiAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG4gIG91dFszXSA9IGMgKiBhMTAgLSBzICogYTAwO1xuICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgb3V0WzVdID0gYyAqIGExMiAtIHMgKiBhMDI7XG4gIG91dFs2XSA9IGEyMDtcbiAgb3V0WzddID0gYTIxO1xuICBvdXRbOF0gPSBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xuXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IHggKiBhWzBdO1xuICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgb3V0WzJdID0geCAqIGFbMl07XG4gIG91dFszXSA9IHkgKiBhWzNdO1xuICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgb3V0WzVdID0geSAqIGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIDJEIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB5b3VyIGdsIGNvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGdsIGNvbnRleHRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xuXG5mdW5jdGlvbiBwcm9qZWN0aW9uKG91dCwgd2lkdGgsIGhlaWdodCkge1xuICBvdXRbMF0gPSAyIC8gd2lkdGg7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IC0yIC8gaGVpZ2h0O1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSAtMTtcbiAgb3V0WzddID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cblxuLy8gQSBcInRleHR1cmUgYXRsYXNcIiBpcyBhIGJpZyBjYW52YXMsIGFuZCBzZWN0aW9ucyBvZiBpdCBhcmUgdXNlZCBhcyB0ZXh0dXJlcyBmb3Igbm9kZXMvbGFiZWxzLlxuXG4vKipcbiAqIEEgc2luZ2xlIHNxdWFyZSB0ZXh0dXJlIGF0bGFzIChhbHNvIGtub3duIGFzIGEgXCJzcHJpdGUgc2hlZXRcIikuXG4gKi9cbnZhciBBdGxhcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0bGFzKHIsIHRleFNpemUsIHRleFJvd3MsIGNyZWF0ZVRleHR1cmVDYW52YXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXRsYXMpO1xuICAgIHRoaXMuZGVidWdJRCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMudGV4U2l6ZSA9IHRleFNpemU7XG4gICAgdGhpcy50ZXhSb3dzID0gdGV4Um93cztcbiAgICB0aGlzLnRleEhlaWdodCA9IE1hdGguZmxvb3IodGV4U2l6ZSAvIHRleFJvd3MpO1xuICAgIHRoaXMuZW5hYmxlV3JhcHBpbmcgPSB0cnVlOyAvLyBoYXJkY29kZWQgZm9yIG5vdywgY2FuIGJlIG1hZGUgYW4gb3B0aW9uXG5cbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlOyAvLyBvbmNlIGFuIGF0bGFzIGlzIGxvY2tlZCBpdCBjYW4gbm8gbG9uZ2VyIGJlIGRyYXduIHRvXG4gICAgdGhpcy50ZXh0dXJlID0gbnVsbDsgLy8gV2ViR0xUZXh0dXJlIG9iamVjdFxuICAgIHRoaXMubmVlZHNCdWZmZXIgPSB0cnVlO1xuXG4gICAgLy8gYSBcImxvY2F0aW9uXCIgaXMgYW4gcG9pbnRlciBpbnRvIHRoZSBhdGxhcyB3aXRoIGEgJ3JvdycgYW5kICd4JyBmaWVsZHNcbiAgICB0aGlzLmZyZWVQb2ludGVyID0ge1xuICAgICAgeDogMCxcbiAgICAgIHJvdzogMFxuICAgIH07XG5cbiAgICAvLyBtYXAgZnJvbSB0aGUgc3R5bGUga2V5IHRvIHRoZSByb3cveCB3aGVyZSB0aGUgdGV4dHVyZSBzdGFydHNcbiAgICAvLyBpZiB0aGUgdGV4dHVyZSB3cmFwcyB0aGVuIHRoZXJlJ3MgYSBzZWNvbmQgbG9jYXRpb25cbiAgICB0aGlzLmtleVRvTG9jYXRpb24gPSBuZXcgTWFwKCk7IC8vIHN0eWxlS2V5IC0+IFsgbG9jYXRpb24sIGxvY2F0aW9uIF1cblxuICAgIHRoaXMuY2FudmFzID0gY3JlYXRlVGV4dHVyZUNhbnZhcyhyLCB0ZXhTaXplLCB0ZXhTaXplKTtcbiAgICB0aGlzLnNjcmF0Y2ggPSBjcmVhdGVUZXh0dXJlQ2FudmFzKHIsIHRleFNpemUsIHRoaXMudGV4SGVpZ2h0LCAnc2NyYXRjaCcpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXRsYXMsIFt7XG4gICAga2V5OiBcImxvY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9jaygpIHtcbiAgICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0S2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRLZXlzKCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5rZXlUb0xvY2F0aW9uLmtleXMoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjYWxlKF9yZWYpIHtcbiAgICAgIHZhciB3ID0gX3JlZi53LFxuICAgICAgICBoID0gX3JlZi5oO1xuICAgICAgdmFyIHRleEhlaWdodCA9IHRoaXMudGV4SGVpZ2h0LFxuICAgICAgICBtYXhUZXhXaWR0aCA9IHRoaXMudGV4U2l6ZTtcbiAgICAgIC8vIHRyeSB0byBmaXQgdG8gdGhlIGhlaWdodCBvZiBhIHJvd1xuICAgICAgdmFyIHNjYWxlID0gdGV4SGVpZ2h0IC8gaDsgLy8gVE9ETyB3aGF0IGFib3V0IHBpeGVsUmF0aW8/XG4gICAgICB2YXIgdGV4VyA9IHcgKiBzY2FsZTtcbiAgICAgIHZhciB0ZXhIID0gaCAqIHNjYWxlO1xuICAgICAgLy8gaWYgdGhlIHNjYWxlZCB3aWR0aCBpcyB0b28gd2lkZSB0aGVuIHNjYWxlIHRvIGZpdCBtYXggd2lkdGggaW5zdGVhZFxuICAgICAgaWYgKHRleFcgPiBtYXhUZXhXaWR0aCkge1xuICAgICAgICBzY2FsZSA9IG1heFRleFdpZHRoIC8gdztcbiAgICAgICAgdGV4VyA9IHcgKiBzY2FsZTtcbiAgICAgICAgdGV4SCA9IGggKiBzY2FsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgdGV4VzogdGV4VyxcbiAgICAgICAgdGV4SDogdGV4SFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGtleSwgYmIsIGRvRHJhd2luZykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmxvY2tlZCkgdGhyb3cgbmV3IEVycm9yKCdjYW5cXCd0IGRyYXcsIGF0bGFzIGlzIGxvY2tlZCcpO1xuICAgICAgdmFyIHRleFNpemUgPSB0aGlzLnRleFNpemUsXG4gICAgICAgIHRleFJvd3MgPSB0aGlzLnRleFJvd3MsXG4gICAgICAgIHRleEhlaWdodCA9IHRoaXMudGV4SGVpZ2h0O1xuICAgICAgdmFyIF90aGlzJGdldFNjYWxlID0gdGhpcy5nZXRTY2FsZShiYiksXG4gICAgICAgIHNjYWxlID0gX3RoaXMkZ2V0U2NhbGUuc2NhbGUsXG4gICAgICAgIHRleFcgPSBfdGhpcyRnZXRTY2FsZS50ZXhXLFxuICAgICAgICB0ZXhIID0gX3RoaXMkZ2V0U2NhbGUudGV4SDtcbiAgICAgIHZhciBkcmF3QXQgPSBmdW5jdGlvbiBkcmF3QXQobG9jYXRpb24sIGNhbnZhcykge1xuICAgICAgICBpZiAoZG9EcmF3aW5nICYmIGNhbnZhcykge1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmNvbnRleHQ7XG4gICAgICAgICAgdmFyIHggPSBsb2NhdGlvbi54LFxuICAgICAgICAgICAgcm93ID0gbG9jYXRpb24ucm93O1xuICAgICAgICAgIHZhciB4T2Zmc2V0ID0geDtcbiAgICAgICAgICB2YXIgeU9mZnNldCA9IHRleEhlaWdodCAqIHJvdztcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgICBjb250ZXh0LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICAgICAgZG9EcmF3aW5nKGNvbnRleHQsIGJiKTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBsb2NhdGlvbnMgPSBbbnVsbCwgbnVsbF07XG4gICAgICB2YXIgZHJhd05vcm1hbCA9IGZ1bmN0aW9uIGRyYXdOb3JtYWwoKSB7XG4gICAgICAgIC8vIGRvbid0IG5lZWQgdG8gd3JhcCwgZHJhdyBkaXJlY3RseSBvbiB0aGUgY2FudmFzXG4gICAgICAgIGRyYXdBdChfdGhpcy5mcmVlUG9pbnRlciwgX3RoaXMuY2FudmFzKTtcbiAgICAgICAgbG9jYXRpb25zWzBdID0ge1xuICAgICAgICAgIHg6IF90aGlzLmZyZWVQb2ludGVyLngsXG4gICAgICAgICAgeTogX3RoaXMuZnJlZVBvaW50ZXIucm93ICogdGV4SGVpZ2h0LFxuICAgICAgICAgIHc6IHRleFcsXG4gICAgICAgICAgaDogdGV4SFxuICAgICAgICB9O1xuICAgICAgICBsb2NhdGlvbnNbMV0gPSB7XG4gICAgICAgICAgLy8gY3JlYXRlIGEgc2Vjb25kIGxvY2F0aW9uIHdpdGggYSB3aWR0aCBvZiAwLCBmb3IgY29udmVuaWVuY2VcbiAgICAgICAgICB4OiBfdGhpcy5mcmVlUG9pbnRlci54ICsgdGV4VyxcbiAgICAgICAgICB5OiBfdGhpcy5mcmVlUG9pbnRlci5yb3cgKiB0ZXhIZWlnaHQsXG4gICAgICAgICAgdzogMCxcbiAgICAgICAgICBoOiB0ZXhIXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbW92ZSB0aGUgcG9pbnRlciB0byB0aGUgZW5kIG9mIHRoZSB0ZXh0dXJlXG4gICAgICAgIF90aGlzLmZyZWVQb2ludGVyLnggKz0gdGV4VztcbiAgICAgICAgaWYgKF90aGlzLmZyZWVQb2ludGVyLnggPT0gdGV4U2l6ZSkge1xuICAgICAgICAgIF90aGlzLmZyZWVQb2ludGVyLnggPSAwO1xuICAgICAgICAgIF90aGlzLmZyZWVQb2ludGVyLnJvdysrO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGRyYXdXcmFwcGVkID0gZnVuY3Rpb24gZHJhd1dyYXBwZWQoKSB7XG4gICAgICAgIHZhciBzY3JhdGNoID0gX3RoaXMuc2NyYXRjaCxcbiAgICAgICAgICBjYW52YXMgPSBfdGhpcy5jYW52YXM7XG5cbiAgICAgICAgLy8gRHJhdyB0byB0aGUgc2NyYXRjaCBjYW52YXNcbiAgICAgICAgc2NyYXRjaC5jbGVhcigpO1xuICAgICAgICBkcmF3QXQoe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgcm93OiAwXG4gICAgICAgIH0sIHNjcmF0Y2gpO1xuICAgICAgICB2YXIgZmlyc3RUZXhXID0gdGV4U2l6ZSAtIF90aGlzLmZyZWVQb2ludGVyLng7XG4gICAgICAgIHZhciBzZWNvbmRUZXhXID0gdGV4VyAtIGZpcnN0VGV4VztcbiAgICAgICAgdmFyIGggPSB0ZXhIZWlnaHQ7XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBjb3B5IGZpcnN0IHBhcnQgb2Ygc2NyYXRjaCB0byB0aGUgZmlyc3QgdGV4dHVyZVxuICAgICAgICAgIHZhciBkeCA9IF90aGlzLmZyZWVQb2ludGVyLng7XG4gICAgICAgICAgdmFyIGR5ID0gX3RoaXMuZnJlZVBvaW50ZXIucm93ICogdGV4SGVpZ2h0O1xuICAgICAgICAgIHZhciB3ID0gZmlyc3RUZXhXO1xuICAgICAgICAgIGNhbnZhcy5jb250ZXh0LmRyYXdJbWFnZShzY3JhdGNoLCAwLCAwLCB3LCBoLCBkeCwgZHksIHcsIGgpO1xuICAgICAgICAgIGxvY2F0aW9uc1swXSA9IHtcbiAgICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgICAgeTogZHksXG4gICAgICAgICAgICB3OiB3LFxuICAgICAgICAgICAgaDogdGV4SFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIC8vIGNvcHkgc2Vjb25kIHBhcnQgb2Ygc2NyYXRjaCB0byB0aGUgc2Vjb25kIHRleHR1cmVcbiAgICAgICAgICB2YXIgc3ggPSBmaXJzdFRleFc7XG4gICAgICAgICAgdmFyIF9keSA9IChfdGhpcy5mcmVlUG9pbnRlci5yb3cgKyAxKSAqIHRleEhlaWdodDtcbiAgICAgICAgICB2YXIgX3cgPSBzZWNvbmRUZXhXO1xuICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIGNhbnZhcy5jb250ZXh0LmRyYXdJbWFnZShzY3JhdGNoLCBzeCwgMCwgX3csIGgsIDAsIF9keSwgX3csIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhdGlvbnNbMV0gPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogX2R5LFxuICAgICAgICAgICAgdzogX3csXG4gICAgICAgICAgICBoOiB0ZXhIXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5mcmVlUG9pbnRlci54ID0gc2Vjb25kVGV4VztcbiAgICAgICAgX3RoaXMuZnJlZVBvaW50ZXIucm93Kys7XG4gICAgICB9O1xuICAgICAgdmFyIG1vdmVUb1N0YXJ0T2ZOZXh0Um93ID0gZnVuY3Rpb24gbW92ZVRvU3RhcnRPZk5leHRSb3coKSB7XG4gICAgICAgIF90aGlzLmZyZWVQb2ludGVyLnggPSAwO1xuICAgICAgICBfdGhpcy5mcmVlUG9pbnRlci5yb3crKztcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5mcmVlUG9pbnRlci54ICsgdGV4VyA8PSB0ZXhTaXplKSB7XG4gICAgICAgIC8vIFRoZXJlJ3MgZW5vdWdoIHNwYWNlIGluIHRoZSBjdXJyZW50IHJvd1xuICAgICAgICBkcmF3Tm9ybWFsKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZnJlZVBvaW50ZXIucm93ID49IHRleFJvd3MgLSAxKSB7XG4gICAgICAgIC8vIE5lZWQgdG8gbW92ZSB0byB0aGUgbmV4dCByb3csIGJ1dCB0aGVyZSBhcmUgbm8gbW9yZSByb3dzLCBhdGxhcyBpcyBmdWxsLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZnJlZVBvaW50ZXIueCA9PT0gdGV4U2l6ZSkge1xuICAgICAgICAvLyBoYXBwZW4gdG8gYmUgcmlnaHQgYXQgZW5kIG9mIGN1cnJlbnQgcm93XG4gICAgICAgIG1vdmVUb1N0YXJ0T2ZOZXh0Um93KCk7XG4gICAgICAgIGRyYXdOb3JtYWwoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lbmFibGVXcmFwcGluZykge1xuICAgICAgICAvLyBkcmF3IHBhcnQgb2YgdGhlIHRleHR1cmUgdG8gdGhlIGVuZCBvZiB0aGUgY3VyZW50IHJvdywgdGhlbiB3cmFwIHRvIHRoZSBuZXh0IHJvd1xuICAgICAgICBkcmF3V3JhcHBlZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbW92ZSB0byB0aGUgc3RhcnQgb2YgdGhlIG5leHQgcm93LCB0aGVuIGRyYXcgbm9ybWFsbHlcbiAgICAgICAgbW92ZVRvU3RhcnRPZk5leHRSb3coKTtcbiAgICAgICAgZHJhd05vcm1hbCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXlUb0xvY2F0aW9uLnNldChrZXksIGxvY2F0aW9ucyk7XG4gICAgICB0aGlzLm5lZWRzQnVmZmVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiBsb2NhdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9mZnNldHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T2Zmc2V0cyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleVRvTG9jYXRpb24uZ2V0KGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyZWVQb2ludGVyLnggPT09IDAgJiYgdGhpcy5mcmVlUG9pbnRlci5yb3cgPT09IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbkZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5GaXQoYmIpIHtcbiAgICAgIGlmICh0aGlzLmxvY2tlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIHRleFNpemUgPSB0aGlzLnRleFNpemUsXG4gICAgICAgIHRleFJvd3MgPSB0aGlzLnRleFJvd3M7XG4gICAgICB2YXIgX3RoaXMkZ2V0U2NhbGUyID0gdGhpcy5nZXRTY2FsZShiYiksXG4gICAgICAgIHRleFcgPSBfdGhpcyRnZXRTY2FsZTIudGV4VztcbiAgICAgIGlmICh0aGlzLmZyZWVQb2ludGVyLnggKyB0ZXhXID4gdGV4U2l6ZSkge1xuICAgICAgICAvLyBuZWVkIHRvIHdyYXBcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJlZVBvaW50ZXIucm93IDwgdGV4Um93cyAtIDE7IC8vIHJldHVybiB0cnVlIGlmIHRoZXJlJ3MgYSByb3cgdG8gd3JhcCB0b1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIG9uIGV2ZXJ5IGZyYW1lXG4gIH0sIHtcbiAgICBrZXk6IFwiYnVmZmVySWZOZWVkZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYnVmZmVySWZOZWVkZWQoZ2wpIHtcbiAgICAgIGlmICghdGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIHRoaXMuZGVidWdJRCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWVkc0J1ZmZlcikge1xuICAgICAgICB0aGlzLnRleHR1cmUuYnVmZmVyKHRoaXMuY2FudmFzKTtcbiAgICAgICAgdGhpcy5uZWVkc0J1ZmZlciA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICAgICAgdGhpcy5zY3JhdGNoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICBpZiAodGhpcy50ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZS5kZWxldGVUZXh0dXJlKCk7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLnNjcmF0Y2ggPSBudWxsO1xuICAgICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB0ZXh0dXJlIGF0bGFzZXMsIGFsbCBvZiB0aGUgc2FtZSBcInJlbmRlciB0eXBlXCIuIFxuICogKCdub2RlLWJvZHknIGlzIGFuIGV4YW1wbGUgb2YgYSByZW5kZXIgdHlwZS4pXG4gKiBBbiBBdGxhc0NvbGxlY3Rpb24gY2FuIGFsc28gYmUgbm90aWZpZWQgd2hlbiBhIHRleHR1cmUgaXMgbm8gbG9uZ2VyIG5lZWRlZCwgXG4gKiBhbmQgaXQgY2FuIGdhcmJhZ2UgY29sbGVjdCB0aGUgdW51c2VkIHRleHR1cmVzLlxuICovXG52YXIgQXRsYXNDb2xsZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXRsYXNDb2xsZWN0aW9uKHIsIHRleFNpemUsIHRleFJvd3MsIGNyZWF0ZVRleHR1cmVDYW52YXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXRsYXNDb2xsZWN0aW9uKTtcbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMudGV4U2l6ZSA9IHRleFNpemU7XG4gICAgdGhpcy50ZXhSb3dzID0gdGV4Um93cztcbiAgICB0aGlzLmNyZWF0ZVRleHR1cmVDYW52YXMgPSBjcmVhdGVUZXh0dXJlQ2FudmFzO1xuICAgIHRoaXMuYXRsYXNlcyA9IFtdO1xuICAgIHRoaXMuc3R5bGVLZXlUb0F0bGFzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMubWFya2VkS2V5cyA9IG5ldyBTZXQoKTsgLy8gbWFya2VkIGZvciBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEF0bGFzQ29sbGVjdGlvbiwgW3tcbiAgICBrZXk6IFwiZ2V0S2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRLZXlzKCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5zdHlsZUtleVRvQXRsYXMua2V5cygpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUF0bGFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBdGxhcygpIHtcbiAgICAgIHZhciByID0gdGhpcy5yLFxuICAgICAgICB0ZXhTaXplID0gdGhpcy50ZXhTaXplLFxuICAgICAgICB0ZXhSb3dzID0gdGhpcy50ZXhSb3dzLFxuICAgICAgICBjcmVhdGVUZXh0dXJlQ2FudmFzID0gdGhpcy5jcmVhdGVUZXh0dXJlQ2FudmFzO1xuICAgICAgcmV0dXJuIG5ldyBBdGxhcyhyLCB0ZXhTaXplLCB0ZXhSb3dzLCBjcmVhdGVUZXh0dXJlQ2FudmFzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFNjcmF0Y2hDYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNjcmF0Y2hDYW52YXMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2NyYXRjaCkge1xuICAgICAgICB2YXIgciA9IHRoaXMucixcbiAgICAgICAgICB0ZXhTaXplID0gdGhpcy50ZXhTaXplLFxuICAgICAgICAgIHRleFJvd3MgPSB0aGlzLnRleFJvd3MsXG4gICAgICAgICAgY3JlYXRlVGV4dHVyZUNhbnZhcyA9IHRoaXMuY3JlYXRlVGV4dHVyZUNhbnZhcztcbiAgICAgICAgdmFyIHRleEhlaWdodCA9IE1hdGguZmxvb3IodGV4U2l6ZSAvIHRleFJvd3MpO1xuICAgICAgICB0aGlzLnNjcmF0Y2ggPSBjcmVhdGVUZXh0dXJlQ2FudmFzKHIsIHRleFNpemUsIHRleEhlaWdodCwgJ3NjcmF0Y2gnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNjcmF0Y2g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhrZXksIGJiLCBkb0RyYXdpbmcpIHtcbiAgICAgIHZhciBhdGxhcyA9IHRoaXMuc3R5bGVLZXlUb0F0bGFzLmdldChrZXkpO1xuICAgICAgaWYgKCFhdGxhcykge1xuICAgICAgICAvLyBjaGVjayBmb3Igc3BhY2UgYXQgdGhlIGVuZCBvZiB0aGUgbGFzdCBhdGxhc1xuICAgICAgICBhdGxhcyA9IHRoaXMuYXRsYXNlc1t0aGlzLmF0bGFzZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICghYXRsYXMgfHwgIWF0bGFzLmNhbkZpdChiYikpIHtcbiAgICAgICAgICBpZiAoYXRsYXMpIGF0bGFzLmxvY2soKTtcbiAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgYXRsYXNcbiAgICAgICAgICBhdGxhcyA9IHRoaXMuX2NyZWF0ZUF0bGFzKCk7XG4gICAgICAgICAgdGhpcy5hdGxhc2VzLnB1c2goYXRsYXMpO1xuICAgICAgICB9XG4gICAgICAgIGF0bGFzLmRyYXcoa2V5LCBiYiwgZG9EcmF3aW5nKTtcbiAgICAgICAgdGhpcy5zdHlsZUtleVRvQXRsYXMuc2V0KGtleSwgYXRsYXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0bGFzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdGxhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdGxhcyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0eWxlS2V5VG9BdGxhcy5nZXQoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzQXRsYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzQXRsYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHlsZUtleVRvQXRsYXMuaGFzKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtLZXlGb3JHQ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrS2V5Rm9yR0Moa2V5KSB7XG4gICAgICB0aGlzLm1hcmtlZEtleXMuYWRkKGtleSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdjXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdjKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgbWFya2VkS2V5cyA9IHRoaXMubWFya2VkS2V5cztcbiAgICAgIGlmIChtYXJrZWRLZXlzLnNpemUgPT09IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ25vdGhpbmcgdG8gZ2FyYmFnZSBjb2xsZWN0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdBdGxhc2VzID0gW107XG4gICAgICB2YXIgbmV3U3R5bGVLZXlUb0F0bGFzID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIG5ld0F0bGFzID0gbnVsbDtcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmF0bGFzZXMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgIHZhciBhdGxhcyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBrZXlzID0gYXRsYXMuZ2V0S2V5cygpO1xuICAgICAgICAgIHZhciBrZXlzVG9Db2xsZWN0ID0gaW50ZXJzZWN0aW9uKG1hcmtlZEtleXMsIGtleXMpO1xuICAgICAgICAgIGlmIChrZXlzVG9Db2xsZWN0LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRoaXMgYXRsYXMgY2FuIHN0aWxsIGJlIHVzZWRcbiAgICAgICAgICAgIG5ld0F0bGFzZXMucHVzaChhdGxhcyk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ld1N0eWxlS2V5VG9BdGxhcy5zZXQoaywgYXRsYXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gMTsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFuZXdBdGxhcykge1xuICAgICAgICAgICAgbmV3QXRsYXMgPSBfdGhpczIuX2NyZWF0ZUF0bGFzKCk7XG4gICAgICAgICAgICBuZXdBdGxhc2VzLnB1c2gobmV3QXRsYXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGtleXMpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIWtleXNUb0NvbGxlY3QuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2F0bGFzJGdldE9mZnNldHMgPSBhdGxhcy5nZXRPZmZzZXRzKGtleSksXG4gICAgICAgICAgICAgICAgICBfYXRsYXMkZ2V0T2Zmc2V0czIgPSBfc2xpY2VkVG9BcnJheShfYXRsYXMkZ2V0T2Zmc2V0cywgMiksXG4gICAgICAgICAgICAgICAgICBzMSA9IF9hdGxhcyRnZXRPZmZzZXRzMlswXSxcbiAgICAgICAgICAgICAgICAgIHMyID0gX2F0bGFzJGdldE9mZnNldHMyWzFdO1xuICAgICAgICAgICAgICAgIGlmICghbmV3QXRsYXMuY2FuRml0KHtcbiAgICAgICAgICAgICAgICAgIHc6IHMxLncgKyBzMi53LFxuICAgICAgICAgICAgICAgICAgaDogczEuaFxuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICBuZXdBdGxhcy5sb2NrKCk7XG4gICAgICAgICAgICAgICAgICBuZXdBdGxhcyA9IF90aGlzMi5fY3JlYXRlQXRsYXMoKTtcbiAgICAgICAgICAgICAgICAgIG5ld0F0bGFzZXMucHVzaChuZXdBdGxhcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdGxhcy5jYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0ZXh0dXJlIGNhbid0IGJlIGNvcGllZCB0aGVuIGl0IHdpbGwgaGF2ZSB0byBiZSByZWRyYXduIG9uIHRoZSBuZXh0IGZyYW1lXG4gICAgICAgICAgICAgICAgICBfdGhpczIuX2NvcHlUZXh0dXJlVG9OZXdBdGxhcyhrZXksIGF0bGFzLCBuZXdBdGxhcyk7XG4gICAgICAgICAgICAgICAgICBuZXdTdHlsZUtleVRvQXRsYXMuc2V0KGtleSwgbmV3QXRsYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdGxhcy5kaXNwb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgaWYgKF9sb29wKCkpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmF0bGFzZXMgPSBuZXdBdGxhc2VzO1xuICAgICAgdGhpcy5zdHlsZUtleVRvQXRsYXMgPSBuZXdTdHlsZUtleVRvQXRsYXM7XG4gICAgICB0aGlzLm1hcmtlZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jb3B5VGV4dHVyZVRvTmV3QXRsYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvcHlUZXh0dXJlVG9OZXdBdGxhcyhrZXksIG9sZEF0bGFzLCBuZXdBdGxhcykge1xuICAgICAgdmFyIF9vbGRBdGxhcyRnZXRPZmZzZXRzID0gb2xkQXRsYXMuZ2V0T2Zmc2V0cyhrZXkpLFxuICAgICAgICBfb2xkQXRsYXMkZ2V0T2Zmc2V0czIgPSBfc2xpY2VkVG9BcnJheShfb2xkQXRsYXMkZ2V0T2Zmc2V0cywgMiksXG4gICAgICAgIHMxID0gX29sZEF0bGFzJGdldE9mZnNldHMyWzBdLFxuICAgICAgICBzMiA9IF9vbGRBdGxhcyRnZXRPZmZzZXRzMlsxXTtcbiAgICAgIGlmIChzMi53ID09PSAwKSB7XG4gICAgICAgIC8vIHRoZSB0ZXh0dXJlIGRvZXMgbm90IHdyYXAsIGRyYXcgZGlyZWN0bHkgdG8gbmV3IGF0bGFzXG4gICAgICAgIG5ld0F0bGFzLmRyYXcoa2V5LCBzMSwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShvbGRBdGxhcy5jYW52YXMsIHMxLngsIHMxLnksIHMxLncsIHMxLmgsIDAsIDAsIHMxLncsIHMxLmgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZSB0ZXh0dXJlIHdyYXBzLCBmaXJzdCBkcmF3IGJvdGggcGFydHMgdG8gYSBzY3JhdGNoIGNhbnZhc1xuICAgICAgICB2YXIgc2NyYXRjaCA9IHRoaXMuX2dldFNjcmF0Y2hDYW52YXMoKTtcbiAgICAgICAgc2NyYXRjaC5jbGVhcigpO1xuICAgICAgICBzY3JhdGNoLmNvbnRleHQuZHJhd0ltYWdlKG9sZEF0bGFzLmNhbnZhcywgczEueCwgczEueSwgczEudywgczEuaCwgMCwgMCwgczEudywgczEuaCk7XG4gICAgICAgIHNjcmF0Y2guY29udGV4dC5kcmF3SW1hZ2Uob2xkQXRsYXMuY2FudmFzLCBzMi54LCBzMi55LCBzMi53LCBzMi5oLCBzMS53LCAwLCBzMi53LCBzMi5oKTtcblxuICAgICAgICAvLyBub3cgZHJhdyB0aGUgc2NyYXRjaCB0byB0aGUgbmV3IGF0bGFzXG4gICAgICAgIHZhciB3ID0gczEudyArIHMyLnc7XG4gICAgICAgIHZhciBoID0gczEuaDtcbiAgICAgICAgbmV3QXRsYXMuZHJhdyhrZXksIHtcbiAgICAgICAgICB3OiB3LFxuICAgICAgICAgIGg6IGhcbiAgICAgICAgfSwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShzY3JhdGNoLCAwLCAwLCB3LCBoLCAwLCAwLCB3LCBoIC8vIHRoZSBkZXN0aW5hdGlvbiBjb250ZXh0IGhhcyBhbHJlYWR5IGJlZW4gdHJhbnNsYXRlZCB0byB0aGUgY29ycmVjdCBwb3NpdGlvblxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb3VudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q291bnRzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5Q291bnQ6IHRoaXMuc3R5bGVLZXlUb0F0bGFzLnNpemUsXG4gICAgICAgIGF0bGFzQ291bnQ6IG5ldyBTZXQodGhpcy5zdHlsZUtleVRvQXRsYXMudmFsdWVzKCkpLnNpemVcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG59KCk7XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oc2V0MSwgc2V0Mikge1xuICAvLyBUT0RPIHdoeSBubyBTZXQuaW50ZXJzZWN0aW9uIGluIG5vZGUgMTY/Pz9cbiAgaWYgKHNldDEuaW50ZXJzZWN0aW9uKSByZXR1cm4gc2V0MS5pbnRlcnNlY3Rpb24oc2V0Mik7ZWxzZSByZXR1cm4gbmV3IFNldChfdG9Db25zdW1hYmxlQXJyYXkoc2V0MSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHNldDIuaGFzKHgpO1xuICB9KSk7XG59XG5cbi8qKlxuICogVXNlZCB0byBtYW5hZ2UgYmF0Y2hlcyBvZiBBdGxhc2VzIGZvciBkcmF3aW5nIG5vZGVzIGFuZCBsYWJlbHMuXG4gKiBTdXBwb3J0cyBkaWZmZXJlbnQgdHlwZXMgb2YgQXRsYXNDb2xsZWN0aW9ucyBmb3IgZGlmZmVyZW50IHJlbmRlciB0eXBlcyxcbiAqIGZvciBleGFtcGxlICdub2RlLWJvZHknIGFuZCAnbm9kZS1sYWJlbCcgd291bGQgYmUgZGlmZmVyZW50IHJlbmRlciB0eXBlcy5cbiAqIFJlbmRlciB0eXBlcyBhcmUga2VwdCBzZXBhcmF0ZSBiZWNhdXNlIHRoZXkgd2lsbCBsaWtlbHkgbmVlZCB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuICogc2VwYXJhdGVseSBhbmQgaXRzIG5vdCBlbnRpZXJseSBndWFyYW50ZWVkIHRoYXQgdGhlaXIgc3R5bGUga2V5cyB3b24ndCBjb2xsaWRlLlxuICovXG52YXIgQXRsYXNNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXRsYXNNYW5hZ2VyKHIsIGdsb2JhbE9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXRsYXNNYW5hZ2VyKTtcbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgdGhpcy5hdGxhc1NpemUgPSBnbG9iYWxPcHRpb25zLndlYmdsVGV4U2l6ZTtcbiAgICB0aGlzLm1heEF0bGFzZXNQZXJCYXRjaCA9IGdsb2JhbE9wdGlvbnMud2ViZ2xUZXhQZXJCYXRjaDtcbiAgICB0aGlzLnJlbmRlclR5cGVzID0gbmV3IE1hcCgpOyAvLyByZW5kZXJUeXBlOnN0cmluZyAtPiByZW5kZXJUeXBlT3B0aW9uc1xuICAgIHRoaXMuY29sbGVjdGlvbnMgPSBuZXcgTWFwKCk7IC8vIGNvbGxlY3Rpb25OYW1lOnN0cmluZyAtPiBBdGxhc0NvbGxlY3Rpb25cblxuICAgIHRoaXMudHlwZUFuZElkVG9LZXkgPSBuZXcgTWFwKCk7IC8vIFtyZW5kZXJUeXBlLGlkXSA9PiBBcnJheTxzdHlsZSBrZXk+XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBdGxhc01hbmFnZXIsIFt7XG4gICAga2V5OiBcImdldEF0bGFzU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdGxhc1NpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdGxhc1NpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZEF0bGFzQ29sbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRBdGxhc0NvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUsIGF0bGFzQ29sbGVjdGlvbk9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyRnbG9iYWxPcHRpb25zID0gdGhpcy5nbG9iYWxPcHRpb25zLFxuICAgICAgICB3ZWJnbFRleFNpemUgPSBfdGhpcyRnbG9iYWxPcHRpb25zLndlYmdsVGV4U2l6ZSxcbiAgICAgICAgY3JlYXRlVGV4dHVyZUNhbnZhcyA9IF90aGlzJGdsb2JhbE9wdGlvbnMuY3JlYXRlVGV4dHVyZUNhbnZhcztcbiAgICAgIHZhciB0ZXhSb3dzID0gYXRsYXNDb2xsZWN0aW9uT3B0aW9ucy50ZXhSb3dzO1xuICAgICAgdmFyIGNhY2hlZENyZWF0ZVRleHR1cmVDYW52YXMgPSB0aGlzLl9jYWNoZVNjcmF0Y2hDYW52YXMoY3JlYXRlVGV4dHVyZUNhbnZhcyk7XG4gICAgICB2YXIgYXRsYXNDb2xsZWN0aW9uID0gbmV3IEF0bGFzQ29sbGVjdGlvbih0aGlzLnIsIHdlYmdsVGV4U2l6ZSwgdGV4Um93cywgY2FjaGVkQ3JlYXRlVGV4dHVyZUNhbnZhcyk7XG4gICAgICB0aGlzLmNvbGxlY3Rpb25zLnNldChjb2xsZWN0aW9uTmFtZSwgYXRsYXNDb2xsZWN0aW9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUmVuZGVyVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZW5kZXJUeXBlKHR5cGUsIHJlbmRlclR5cGVPcHRpb25zKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHJlbmRlclR5cGVPcHRpb25zLmNvbGxlY3Rpb247XG4gICAgICBpZiAoIXRoaXMuY29sbGVjdGlvbnMuaGFzKGNvbGxlY3Rpb24pKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGF0bGFzIGNvbGxlY3Rpb24gbmFtZSAnXCIuY29uY2F0KGNvbGxlY3Rpb24sIFwiJ1wiKSk7XG4gICAgICB2YXIgYXRsYXNDb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9ucy5nZXQoY29sbGVjdGlvbik7XG4gICAgICB2YXIgb3B0cyA9IGV4dGVuZCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIGF0bGFzQ29sbGVjdGlvbjogYXRsYXNDb2xsZWN0aW9uXG4gICAgICB9LCByZW5kZXJUeXBlT3B0aW9ucyk7XG4gICAgICB0aGlzLnJlbmRlclR5cGVzLnNldCh0eXBlLCBvcHRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVuZGVyVHlwZU9wdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVuZGVyVHlwZU9wdHModHlwZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVHlwZXMuZ2V0KHR5cGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdGxhc0NvbGxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXRsYXNDb2xsZWN0aW9uKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbGxlY3Rpb25zLmdldChuYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhY2hlU2NyYXRjaENhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FjaGVTY3JhdGNoQ2FudmFzKGNyZWF0ZVRleHR1cmVDYW52YXMpIHtcbiAgICAgIC8vIGFsbCBzY3JhdGNoIGNhbnZhc2VzIGZvciB0aGUgc2FtZSByZW5kZXIgdHlwZSB3aWxsIGhhdmUgdGhlIHNhbWUgd2lkdGggYW5kIGhlaWdodCAoaWUgd2ViZ2xUZXhSb3dzIG9wdGlvbilcbiAgICAgIC8vIGJ1dCB3ZSdsbCBrZWVwIHRyYWNrIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGp1c3QgdG8gYmUgc2FmZVxuICAgICAgdmFyIHByZXZXID0gLTE7XG4gICAgICB2YXIgcHJldkggPSAtMTtcbiAgICAgIHZhciBzY3JhdGNoQ2FudmFzID0gbnVsbDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAociwgdywgaCwgc2NyYXRjaCkge1xuICAgICAgICBpZiAoc2NyYXRjaCkge1xuICAgICAgICAgIGlmICghc2NyYXRjaENhbnZhcyB8fCB3ICE9IHByZXZXIHx8IGggIT0gcHJldkgpIHtcbiAgICAgICAgICAgIHByZXZXID0gdztcbiAgICAgICAgICAgIHByZXZIID0gaDtcbiAgICAgICAgICAgIHNjcmF0Y2hDYW52YXMgPSBjcmVhdGVUZXh0dXJlQ2FudmFzKHIsIHcsIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NyYXRjaENhbnZhcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlVGV4dHVyZUNhbnZhcyhyLCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2tleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfa2V5KHJlbmRlclR5cGUsIGlkKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQocmVuZGVyVHlwZSwgXCItXCIpLmNvbmNhdChpZCk7IC8vIFRPRE8gbm90IHZlcnkgZWZmaWNpZW50XG4gICAgfVxuXG4gICAgLyoqIE1hcmtzIHRleHR1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50IGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlKGVsZXMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgX3JlZjIkZm9yY2VSZWRyYXcgPSBfcmVmMi5mb3JjZVJlZHJhdyxcbiAgICAgICAgZm9yY2VSZWRyYXcgPSBfcmVmMiRmb3JjZVJlZHJhdyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcmVmMiRmb3JjZVJlZHJhdyxcbiAgICAgICAgX3JlZjIkZmlsdGVyRWxlID0gX3JlZjIuZmlsdGVyRWxlLFxuICAgICAgICBmaWx0ZXJFbGUgPSBfcmVmMiRmaWx0ZXJFbGUgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSA6IF9yZWYyJGZpbHRlckVsZSxcbiAgICAgICAgX3JlZjIkZmlsdGVyVHlwZSA9IF9yZWYyLmZpbHRlclR5cGUsXG4gICAgICAgIGZpbHRlclR5cGUgPSBfcmVmMiRmaWx0ZXJUeXBlID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gOiBfcmVmMiRmaWx0ZXJUeXBlO1xuICAgICAgdmFyIG5lZWRHQyA9IGZhbHNlO1xuICAgICAgdmFyIHJ1bkdDTm93ID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGVsZXMpLFxuICAgICAgICBfc3RlcDM7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBlbGUgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgaWYgKGZpbHRlckVsZShlbGUpKSB7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMucmVuZGVyVHlwZXMudmFsdWVzKCkpLFxuICAgICAgICAgICAgICBfc3RlcDQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciByZW5kZXJUeXBlID0gb3B0cy50eXBlO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJUeXBlKHJlbmRlclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYXRsYXNDb2xsZWN0aW9uID0gX3RoaXMzLmNvbGxlY3Rpb25zLmdldChvcHRzLmNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IG9wdHMuZ2V0S2V5KGVsZSk7XG4gICAgICAgICAgICAgICAgICB2YXIga2V5QXJyYXkgPSBBcnJheS5pc0FycmF5KGtleSkgPyBrZXkgOiBba2V5XTtcblxuICAgICAgICAgICAgICAgICAgLy8gd2hlbiBhIG5vZGUncyBiYWNrZ3JvdW5kIGltYWdlIGZpbmlzaGVzIGxvYWRpbmcsIHRoZSBzdHlsZSBrZXkgZG9lc24ndCBjaGFuZ2UgYnV0IHN0aWxsIG5lZWRzIHRvIGJlIHJlZHJhd25cbiAgICAgICAgICAgICAgICAgIGlmIChmb3JjZVJlZHJhdykge1xuICAgICAgICAgICAgICAgICAgICBrZXlBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXRsYXNDb2xsZWN0aW9uLm1hcmtLZXlGb3JHQyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcnVuR0NOb3cgPSB0cnVlOyAvLyBydW4gR0MgdG8gcmVtb3ZlIHRoZSBvbGQgdGV4dHVyZSByaWdodCBub3csIHRoYXQgd2F5IHdlIGRvbid0IG5lZWQgdG8gcmVtZW1iZXIgZm9yIHRoZSBuZXh0IGdjIFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gb3B0cy5nZXRJRCA/IG9wdHMuZ2V0SUQoZWxlKSA6IGVsZS5pZCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwS2V5ID0gX3RoaXMzLl9rZXkocmVuZGVyVHlwZSwgaWQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2xkS2V5QXJyYXkgPSBfdGhpczMudHlwZUFuZElkVG9LZXkuZ2V0KG1hcEtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRLZXlBcnJheSAhPT0gdW5kZWZpbmVkICYmICFhcnJheUVxdWFsKGtleUFycmF5LCBvbGRLZXlBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zZXJ2YXRpdmUgYXBwcm9hY2gsIGlmIGFueSBvZiB0aGUga2V5cyBkb24ndCBtYXRjaCB0aGVuIHRocm93IHRoZW0gYWxsIGF3YXlcbiAgICAgICAgICAgICAgICAgICAgICBuZWVkR0MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzMy50eXBlQW5kSWRUb0tleVtcImRlbGV0ZVwiXShtYXBLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgIG9sZEtleUFycmF5LmZvckVhY2goZnVuY3Rpb24gKG9sZEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0bGFzQ29sbGVjdGlvbi5tYXJrS2V5Rm9yR0Mob2xkS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgICBfbG9vcDIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgIH1cbiAgICAgIGlmIChydW5HQ05vdykge1xuICAgICAgICB0aGlzLmdjKCk7XG4gICAgICAgIG5lZWRHQyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5lZWRHQztcbiAgICB9XG5cbiAgICAvKiogR2FyYmFnZSBjb2xsZWN0ICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2MoKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuY29sbGVjdGlvbnMudmFsdWVzKCkpLFxuICAgICAgICBfc3RlcDU7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gX3N0ZXA1LnZhbHVlO1xuICAgICAgICAgIGNvbGxlY3Rpb24uZ2MoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9yQ3JlYXRlQXRsYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JDcmVhdGVBdGxhcyhlbGUsIHR5cGUsIGJiLCBzdHlsZUtleSkge1xuICAgICAgLy8gc3R5bGVLZXkgaXMgbm90IGFuIGFycmF5IGhlcmVcbiAgICAgIHZhciBvcHRzID0gdGhpcy5yZW5kZXJUeXBlcy5nZXQodHlwZSk7XG4gICAgICB2YXIgYXRsYXNDb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9ucy5nZXQob3B0cy5jb2xsZWN0aW9uKTtcblxuICAgICAgLy8gZHJhd3MgdGhlIHRleHR1cmUgb25seSBpZiBuZWVkZWRcbiAgICAgIHZhciBkcmF3biA9IGZhbHNlO1xuICAgICAgdmFyIGF0bGFzID0gYXRsYXNDb2xsZWN0aW9uLmRyYXcoc3R5bGVLZXksIGJiLCBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBpZiAob3B0cy5kcmF3Q2xpcHBlZCkge1xuICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIGJiLncsIGJiLmgpO1xuICAgICAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgICAgICAgIG9wdHMuZHJhd0VsZW1lbnQoY29udGV4dCwgZWxlLCBiYiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0cy5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUsIGJiLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBkcmF3biA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIGlmIChkcmF3bikge1xuICAgICAgICB2YXIgaWQgPSBvcHRzLmdldElEID8gb3B0cy5nZXRJRChlbGUpIDogZWxlLmlkKCk7IC8vIGZvciB0ZXN0aW5nXG4gICAgICAgIHZhciBtYXBLZXkgPSB0aGlzLl9rZXkodHlwZSwgaWQpO1xuICAgICAgICBpZiAodGhpcy50eXBlQW5kSWRUb0tleS5oYXMobWFwS2V5KSkge1xuICAgICAgICAgIHRoaXMudHlwZUFuZElkVG9LZXkuZ2V0KG1hcEtleSkucHVzaChzdHlsZUtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50eXBlQW5kSWRUb0tleS5zZXQobWFwS2V5LCBbc3R5bGVLZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGF0bGFzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdGxhc0luZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXRsYXNJbmZvKGVsZSwgdHlwZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMucmVuZGVyVHlwZXMuZ2V0KHR5cGUpO1xuICAgICAgdmFyIGtleSA9IG9wdHMuZ2V0S2V5KGVsZSk7XG4gICAgICB2YXIga2V5QXJyYXkgPSBBcnJheS5pc0FycmF5KGtleSkgPyBrZXkgOiBba2V5XTtcbiAgICAgIHJldHVybiBrZXlBcnJheS5tYXAoZnVuY3Rpb24gKHN0eWxlS2V5KSB7XG4gICAgICAgIHZhciBiYiA9IG9wdHMuZ2V0Qm91bmRpbmdCb3goZWxlLCBzdHlsZUtleSk7IC8vIHBhc3MgdGhlIGtleSBiYWNrIHRvIHRoZSBnZXRCb3VuZGluZ0JveCBtZXRob2RcbiAgICAgICAgdmFyIGF0bGFzID0gX3RoaXM0LmdldE9yQ3JlYXRlQXRsYXMoZWxlLCB0eXBlLCBiYiwgc3R5bGVLZXkpO1xuICAgICAgICB2YXIgX2F0bGFzJGdldE9mZnNldHMzID0gYXRsYXMuZ2V0T2Zmc2V0cyhzdHlsZUtleSksXG4gICAgICAgICAgX2F0bGFzJGdldE9mZnNldHM0ID0gX3NsaWNlZFRvQXJyYXkoX2F0bGFzJGdldE9mZnNldHMzLCAyKSxcbiAgICAgICAgICB0ZXgxID0gX2F0bGFzJGdldE9mZnNldHM0WzBdLFxuICAgICAgICAgIHRleDIgPSBfYXRsYXMkZ2V0T2Zmc2V0czRbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXRsYXM6IGF0bGFzLFxuICAgICAgICAgIHRleDogdGV4MSxcbiAgICAgICAgICB0ZXgxOiB0ZXgxLFxuICAgICAgICAgIHRleDI6IHRleDIsXG4gICAgICAgICAgYmI6IGJiXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVidWdJbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlYnVnSW5mbygpIHtcbiAgICAgIHZhciBkZWJ1Z0luZm8gPSBbXTtcbiAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5jb2xsZWN0aW9ucyksXG4gICAgICAgIF9zdGVwNjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwNiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNi52YWx1ZSwgMiksXG4gICAgICAgICAgICBuYW1lID0gX3N0ZXA2JHZhbHVlWzBdLFxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IF9zdGVwNiR2YWx1ZVsxXTtcbiAgICAgICAgICB2YXIgX2NvbGxlY3Rpb24kZ2V0Q291bnRzID0gY29sbGVjdGlvbi5nZXRDb3VudHMoKSxcbiAgICAgICAgICAgIGtleUNvdW50ID0gX2NvbGxlY3Rpb24kZ2V0Q291bnRzLmtleUNvdW50LFxuICAgICAgICAgICAgYXRsYXNDb3VudCA9IF9jb2xsZWN0aW9uJGdldENvdW50cy5hdGxhc0NvdW50O1xuICAgICAgICAgIGRlYnVnSW5mby5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IG5hbWUsXG4gICAgICAgICAgICBrZXlDb3VudDoga2V5Q291bnQsXG4gICAgICAgICAgICBhdGxhc0NvdW50OiBhdGxhc0NvdW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYnVnSW5mbztcbiAgICB9XG4gIH1dKTtcbn0oKTtcbnZhciBBdGxhc0JhdGNoTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0bGFzQmF0Y2hNYW5hZ2VyKGdsb2JhbE9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXRsYXNCYXRjaE1hbmFnZXIpO1xuICAgIHRoaXMuZ2xvYmFsT3B0aW9ucyA9IGdsb2JhbE9wdGlvbnM7XG4gICAgdGhpcy5hdGxhc1NpemUgPSBnbG9iYWxPcHRpb25zLndlYmdsVGV4U2l6ZTtcbiAgICB0aGlzLm1heEF0bGFzZXNQZXJCYXRjaCA9IGdsb2JhbE9wdGlvbnMud2ViZ2xUZXhQZXJCYXRjaDtcbiAgICB0aGlzLmJhdGNoQXRsYXNlcyA9IFtdO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQXRsYXNCYXRjaE1hbmFnZXIsIFt7XG4gICAga2V5OiBcImdldE1heEF0bGFzZXNQZXJCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNYXhBdGxhc2VzUGVyQmF0Y2goKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXhBdGxhc2VzUGVyQmF0Y2g7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF0bGFzU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdGxhc1NpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdGxhc1NpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEluZGV4QXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXhBcnJheSgpIHtcbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiB0aGlzLm1heEF0bGFzZXNQZXJCYXRjaFxuICAgICAgfSwgZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydEJhdGNoKCkge1xuICAgICAgdGhpcy5iYXRjaEF0bGFzZXMgPSBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXRsYXNDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdGxhc0NvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hBdGxhc2VzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXRsYXNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdGxhc2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hBdGxhc2VzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5BZGRUb0N1cnJlbnRCYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5BZGRUb0N1cnJlbnRCYXRjaChhdGxhcykge1xuICAgICAgaWYgKHRoaXMuYmF0Y2hBdGxhc2VzLmxlbmd0aCA9PT0gdGhpcy5tYXhBdGxhc2VzUGVyQmF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hBdGxhc2VzLmluY2x1ZGVzKGF0bGFzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlOyAvLyBub3QgZnVsbFxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdGxhc0luZGV4Rm9yQmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXRsYXNJbmRleEZvckJhdGNoKGF0bGFzKSB7XG4gICAgICB2YXIgYXRsYXNJRCA9IHRoaXMuYmF0Y2hBdGxhc2VzLmluZGV4T2YoYXRsYXMpO1xuICAgICAgaWYgKGF0bGFzSUQgPCAwKSB7XG4gICAgICAgIGlmICh0aGlzLmJhdGNoQXRsYXNlcy5sZW5ndGggPT09IHRoaXMubWF4QXRsYXNlc1BlckJhdGNoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYWRkIG1vcmUgYXRsYXNlcyB0byBiYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmF0Y2hBdGxhc2VzLnB1c2goYXRsYXMpO1xuICAgICAgICBhdGxhc0lEID0gdGhpcy5iYXRjaEF0bGFzZXMubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdGxhc0lEO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG4vLyBGcmFnbWVudCBzaGFkZXIgZnVuY3Rpb25zIHRvIGNhbGN1bGF0ZSBzaWduZWQgZGlzdGFuY2Vcbi8vIGh0dHBzOi8vaXF1aWxlemxlcy5vcmcvYXJ0aWNsZXMvZGlzdGZ1bmN0aW9uczJkL1xuLy8gZWxsaXBzZTogaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzRsc1hETiBcblxuLyoqXG4gKiBwYXJhbSBwIC0gcG9pbnRcbiAqIGZsb2F0IHIgLSBjaXJjbGUgcmFkaXVzLCBlZyAwLjUgZm9yIHVuaXQgY2lyY2xlXG4gKi9cbnZhciBjaXJjbGVTRCA9IFwiXFxuICBmbG9hdCBjaXJjbGVTRCh2ZWMyIHAsIGZsb2F0IHIpIHtcXG4gICAgcmV0dXJuIGRpc3RhbmNlKHZlYzIoMCksIHApIC0gcjsgLy8gc2lnbmVkIGRpc3RhbmNlXFxuICB9XFxuXCI7XG5cbi8qKlxuICogcGFyYW0gcCAtIHBvaW50XG4gKiBwYXJhbSBiIC0gYi54ID0gaGFsZiB3aWR0aCwgYi55ID0gaGFsZiBoZWlnaHRcbiAqL1xudmFyIHJlY3RhbmdsZVNEID0gXCJcXG4gIGZsb2F0IHJlY3RhbmdsZVNEKHZlYzIgcCwgdmVjMiBiKSB7XFxuICAgIHZlYzIgZCA9IGFicyhwKS1iO1xcbiAgICByZXR1cm4gZGlzdGFuY2UodmVjMigwKSxtYXgoZCwwLjApKSArIG1pbihtYXgoZC54LGQueSksMC4wKTtcXG4gIH1cXG5cIjtcblxuLyoqXG4gKiBwYXJhbSBwIC0gcG9pbnRcbiAqIHBhcmFtIGIgLSBiLnggPSBoYWxmIHdpZHRoLCBiLnkgPSBoYWxmIGhlaWdodFxuICogcGFyYW0gY3IgLSB2ZWN0b3Igb2YgY29ybmVyIHJhZGl1c2VzXG4gKi9cbnZhciByb3VuZFJlY3RhbmdsZVNEID0gXCJcXG4gIGZsb2F0IHJvdW5kUmVjdGFuZ2xlU0QodmVjMiBwLCB2ZWMyIGIsIHZlYzQgY3IpIHtcXG4gICAgY3IueHkgPSAocC54ID4gMC4wKSA/IGNyLnh5IDogY3Iuenc7XFxuICAgIGNyLnggID0gKHAueSA+IDAuMCkgPyBjci54ICA6IGNyLnk7XFxuICAgIHZlYzIgcSA9IGFicyhwKSAtIGIgKyBjci54O1xcbiAgICByZXR1cm4gbWluKG1heChxLngsIHEueSksIDAuMCkgKyBkaXN0YW5jZSh2ZWMyKDApLCBtYXgocSwgMC4wKSkgLSBjci54O1xcbiAgfVxcblwiO1xuXG4vKipcbiAqIHBhcmFtIHAgLSBwb2ludFxuICogcGFyYW0gYWIgLSBhLnggPSBob3Jpem9udGFsIHJhZGl1cywgYS55ID0gdmVydGljYWwgcmFkaXVzXG4gKi9cbnZhciBlbGxpcHNlU0QgPSBcIlxcbiAgZmxvYXQgZWxsaXBzZVNEKHZlYzIgcCwgdmVjMiBhYikge1xcbiAgICBwID0gYWJzKCBwICk7IC8vIHN5bW1ldHJ5XFxuXFxuICAgIC8vIGZpbmQgcm9vdCB3aXRoIE5ld3RvbiBzb2x2ZXJcXG4gICAgdmVjMiBxID0gYWIqKHAtYWIpO1xcbiAgICBmbG9hdCB3ID0gKHEueDxxLnkpPyAxLjU3MDc5NjMyNyA6IDAuMDtcXG4gICAgZm9yKCBpbnQgaT0wOyBpPDU7IGkrKyApIHtcXG4gICAgICB2ZWMyIGNzID0gdmVjMihjb3Modyksc2luKHcpKTtcXG4gICAgICB2ZWMyIHUgPSBhYip2ZWMyKCBjcy54LGNzLnkpO1xcbiAgICAgIHZlYzIgdiA9IGFiKnZlYzIoLWNzLnksY3MueCk7XFxuICAgICAgdyA9IHcgKyBkb3QocC11LHYpLyhkb3QocC11LHUpK2RvdCh2LHYpKTtcXG4gICAgfVxcbiAgICBcXG4gICAgLy8gY29tcHV0ZSBmaW5hbCBwb2ludCBhbmQgZGlzdGFuY2VcXG4gICAgZmxvYXQgZCA9IGxlbmd0aChwLWFiKnZlYzIoY29zKHcpLHNpbih3KSkpO1xcbiAgICBcXG4gICAgLy8gcmV0dXJuIHNpZ25lZCBkaXN0YW5jZVxcbiAgICByZXR1cm4gKGRvdChwL2FiLHAvYWIpPjEuMCkgPyBkIDogLWQ7XFxuICB9XFxuXCI7XG5cbi8qKlxuICogVHdvIHJlbmRlciBtb2Rlcy4gRWFjaCBtb2RlIGhhcyBpdHMgb3duIHNoYWRlciBwcm9ncmFtLiBUaGV5IGFyZSBhbG1vc3QgaWRlbnRpY2FsLCB0aGUgbWFpbiBkaWZmZXJlbmNlIGlzIHRoZSBvdXRwdXQuXG4gKiBTQ1JFRU46ICBvdXRwdXQgcGl4ZWwgY29sb3JzIHRvIHRoZSBzY3JlZW5cbiAqIFBJQ0tJTkc6IG91dHB1dCB6LW9yZGVyIGluZGV4IHRvIGFuIG9mZnNjcmVlbiBmcmFtZWJ1ZmZlciwgdXNlZCB0byBkZXRlY3Qgd2hhdCdzIHVuZGVyIHRoZSBtb3VzZSBjdXJzb3JcbiAqL1xudmFyIFJFTkRFUl9UQVJHRVQgPSB7XG4gIFNDUkVFTjoge1xuICAgIG5hbWU6ICdzY3JlZW4nLFxuICAgIHNjcmVlbjogdHJ1ZVxuICB9LFxuICBQSUNLSU5HOiB7XG4gICAgbmFtZTogJ3BpY2tpbmcnLFxuICAgIHBpY2tpbmc6IHRydWVcbiAgfVxufTtcblxuLyoqXG4gKiBTcGVjaWFsIGhhbmRpbmcgZm9yIGxhYmVsIHRleHR1cmVzIGluIFBJQ0tJTkcgbW9kZS4gU2VlIGlzc3VlICMzMzM3LlxuICovXG52YXIgVEVYX1BJQ0tJTkdfTU9ERSA9IHtcbiAgLy8gcmVuZGVyIHRoZSB0ZXh0dXJlIGp1c3QgbGlrZSBpbiBSRU5ERVJfVEFSR0VULlNDUkVFTiBtb2RlXG4gIElHTk9SRTogMSxcbiAgLy8gZG9uJ3QgcmVuZGVyIHRoZSB0ZXh0dXJlIGF0IGFsbFxuICBVU0VfQkI6IDIgLy8gcmVuZGVyIHRoZSBib3VuZGluZyBib3ggYXMgYW4gb3BhcXVlIHJlY3RhbmdsZVxufTtcblxuLy8gVmVydGV4IHR5cGVzLlxuLy8gVXNlZCBkaXJlY3RseSBpbiB0aGUgc2hhZGVycyBzbyBtdXN0IGJlIG51bWVyaWMuXG4vLyBUaGVyZSBpcyBvbmx5IG9uZSBzaGFkZXIgcHJvZ3JhbSB1c2VkIGZvciBhbiBlbnRpcmUgZnJhbWUgdGhhdCByZW5kZXJzIGFsbCB0eXBlcyBvZiBlbGVtZW50cy5cbi8vIFRoZXJlIGFyZSBpZi1lbHNlIGJsb2NrcyBpbiB0aGUgc2hhZGVycyB0aGF0IGRvIGRpZmZlcmVudCB0aGluZ3MgZGVwZW5kaW5nIG9uIHRoZSB2ZXJ0ZXggdHlwZS5cbi8vIFRoaXMgYWxsb3dzIGFsbCBlbGVtZW50cyB0byBiZSByZW5kZXJlcmQgaW4gbGFyZ2UgYmF0Y2hlcyB3aXRob3V0IHN3aXRjaGluZyBzaGFkZXIgcHJvZ3JhbXMuXG52YXIgVEVYVFVSRSA9IDA7XG52YXIgRURHRV9TVFJBSUdIVCA9IDE7XG52YXIgRURHRV9DVVJWRV9TRUdNRU5UID0gMjtcbnZhciBFREdFX0FSUk9XID0gMztcbnZhciBSRUNUQU5HTEUgPSA0O1xudmFyIFJPVU5EX1JFQ1RBTkdMRSA9IDU7XG52YXIgQk9UVE9NX1JPVU5EX1JFQ1RBTkdMRSA9IDY7XG52YXIgRUxMSVBTRSA9IDc7XG52YXIgRWxlbWVudERyYXdpbmdXZWJHTCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAgICovXG4gIGZ1bmN0aW9uIEVsZW1lbnREcmF3aW5nV2ViR0wociwgZ2wsIG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWxlbWVudERyYXdpbmdXZWJHTCk7XG4gICAgdGhpcy5yID0gcjsgLy8gcmVmZXJlbmNlIHRvIHRoZSBjYW52YXMgcmVuZGVyZXJcbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5tYXhJbnN0YW5jZXMgPSBvcHRzLndlYmdsQmF0Y2hTaXplO1xuICAgIHRoaXMuYXRsYXNTaXplID0gb3B0cy53ZWJnbFRleFNpemU7XG4gICAgdGhpcy5iZ0NvbG9yID0gb3B0cy5iZ0NvbG9yO1xuICAgIHRoaXMuZGVidWcgPSBvcHRzLndlYmdsRGVidWc7XG4gICAgdGhpcy5iYXRjaERlYnVnSW5mbyA9IFtdO1xuICAgIG9wdHMuZW5hYmxlV3JhcHBpbmcgPSB0cnVlO1xuICAgIG9wdHMuY3JlYXRlVGV4dHVyZUNhbnZhcyA9IGNyZWF0ZVRleHR1cmVDYW52YXM7IC8vIFVuaXQgdGVzdHMgbW9jayB0aGlzXG5cbiAgICB0aGlzLmF0bGFzTWFuYWdlciA9IG5ldyBBdGxhc01hbmFnZXIociwgb3B0cyk7XG4gICAgdGhpcy5iYXRjaE1hbmFnZXIgPSBuZXcgQXRsYXNCYXRjaE1hbmFnZXIob3B0cyk7XG4gICAgdGhpcy5zaW1wbGVTaGFwZU9wdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wcm9ncmFtID0gdGhpcy5fY3JlYXRlU2hhZGVyUHJvZ3JhbShSRU5ERVJfVEFSR0VULlNDUkVFTik7XG4gICAgdGhpcy5waWNraW5nUHJvZ3JhbSA9IHRoaXMuX2NyZWF0ZVNoYWRlclByb2dyYW0oUkVOREVSX1RBUkdFVC5QSUNLSU5HKTtcbiAgICB0aGlzLnZhbyA9IHRoaXMuX2NyZWF0ZVZBTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IHN0cmluZyB9IGNvbGxlY3Rpb25OYW1lXG4gICAqIEBwYXJhbSB7eyB0ZXhSb3dzOiBudW1iZXIgfX0gb3B0c1xuICAgKi9cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFbGVtZW50RHJhd2luZ1dlYkdMLCBbe1xuICAgIGtleTogXCJhZGRBdGxhc0NvbGxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQXRsYXNDb2xsZWN0aW9uKGNvbGxlY3Rpb25OYW1lLCBvcHRzKSB7XG4gICAgICB0aGlzLmF0bGFzTWFuYWdlci5hZGRBdGxhc0NvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHsgT2JqZWN0IH0gVGV4dHVyZVJlbmRlclR5cGVPcHRzXG4gICAgICogQHByb3BlcnR5IHsgc3RyaW5nIH0gY29sbGVjdGlvbiAtIG5hbWUgb2YgYXRsYXMgY29sbGVjdGlvbiB0byByZW5kZXIgdGV4dHVyZXMgdG9cbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGdldEtleSAtIHJldHVybnMgdGhlIFwic3R5bGUga2V5XCIgZm9yIGFuIGVsZW1lbnQsIG1heSBiZSBhIHNpbmdsZSB2YWx1ZSBvciBhbiBhcnJheSBmb3IgbXVsdGktbGluZSBsYWJsZXNcbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGRyYXdFbGVtZW50IC0gdXNlcyBhIGNhbnZhcyByZW5kZXJlciB0byBkcmF3IHRoZSBlbGVtZW50IHRvIHRoZSB0ZXh0dXJlIGF0bGFzXG4gICAgICogQHByb3BlcnR5IHsgYm9vbGVhbiAgfSBkcmF3Q2xpcHBlZCAtIGlmIHRydWUgdGhlIGNvbnRleHQgd2lsbCBiZSBjbGlwcGVkIHRvIHRoZSBib3VuZGluZyBib3ggYmVmb3JlIGRyYXdFbGVtZW50KCkgaXMgY2FsbGVkLCBtYXkgYWZmZWN0IHBlcmZvcm1hbmNlXG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBnZXRCb3VuZGluZ0JveCAtIHJldHVybnMgdGhlIGJvdW5kaW5nIGJveCBmb3IgYW4gZWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gZ2V0Um90YXRpb25cbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGdldFJvdGF0aW9uUG9pbnRcbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGdldFJvdGF0aW9uT2Zmc2V0XG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBpc1Zpc2libGUgLSBhbiBleHRyYSBjaGVjayBmb3IgdmlzaWJpbGl0eSBpbiBhZGRpdGlvbiB0byBlbGUudmlzaWJsZSgpXG4gICAgICogQHByb3BlcnR5IHsgZnVuY3Rpb24gfSBnZXRUZXhQaWNraW5nTW9kZSAtIHJldHVybnMgYSB2YWx1ZSBmcm9tIHRoZSBURVhfUElDS0lOR19NT0RFIGVudW1cbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSB0eXBlTmFtZVxuICAgICAqIEBwYXJhbSB7IFRleHR1cmVSZW5kZXJUeXBlT3B0cyB9IG9wdHNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRUZXh0dXJlQXRsYXNSZW5kZXJUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRleHR1cmVBdGxhc1JlbmRlclR5cGUodHlwZU5hbWUsIG9wdHMpIHtcbiAgICAgIHRoaXMuYXRsYXNNYW5hZ2VyLmFkZFJlbmRlclR5cGUodHlwZU5hbWUsIG9wdHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlZGVmIHsgT2JqZWN0IH0gU2ltcGxlU2hhcGVSZW5kZXJUeXBlT3B0c1xuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gZ2V0Qm91bmRpbmdCb3ggLSByZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZm9yIGFuIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkgeyBmdW5jdGlvbiB9IGlzVmlzaWJsZSAtIHRoaXMgaXMgYW4gZXh0cmEgY2hlY2sgZm9yIHZpc2liaWxpdHkgaW4gYWRkaXRpb24gdG8gZWxlLnZpc2libGUoKVxuICAgICAqIEBwcm9wZXJ0eSB7IGZ1bmN0aW9uIH0gaXNTaW1wbGUgLSBjaGVjayBpZiBlbGVtZW50IGlzIGEgc2ltcGxlIHNoYXBlLCBvciBpZiBpdCBuZWVkcyB0byBmYWxsIGJhY2sgdG8gdGV4dHVyZSByZW5kZXJpbmdcbiAgICAgKiBAcHJvcGVydHkgeyBTaGFwZVZpc3VhbFByb3BlcnRpZXMgfSBzaGFwZVByb3BzXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYgeyBPYmplY3QgfSBTaGFwZVZpc3VhbFByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSBzaGFwZVxuICAgICAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IGNvbG9yXG4gICAgICogQHByb3BlcnR5IHsgc3RyaW5nIH0gb3BhY2l0eVxuICAgICAqIEBwcm9wZXJ0eSB7IHN0cmluZyB9IHBhZGRpbmdcbiAgICAgKiBAcHJvcGVydHkgeyBzdHJpbmcgfSByYWRpdXNcbiAgICAgKiBAcHJvcGVydHkgeyBib29sZWFuIH0gYm9yZGVyXG4gICAgKi9cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyBzdHJpbmcgfSB0eXBlTmFtZVxuICAgICAqIEBwYXJhbSB7IFNpbXBsZVNoYXBlUmVuZGVyVHlwZU9wdHMgfSBvcHRzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU2ltcGxlU2hhcGVSZW5kZXJUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNpbXBsZVNoYXBlUmVuZGVyVHlwZSh0eXBlTmFtZSwgb3B0cykge1xuICAgICAgdGhpcy5zaW1wbGVTaGFwZU9wdGlvbnMuc2V0KHR5cGVOYW1lLCBvcHRzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmZvcm0gdGhlIGF0bGFzTWFuYWdlciB3aGVuIGVsZW1lbnQgc3R5bGUga2V5cyBtYXkgaGF2ZSBjaGFuZ2VkLlxuICAgICAqIFRoZSBhdGxhc01hbmFnZXIgY2FuIHRoZW4gbWFyayB1bnVzZWQgdGV4dHVyZXMgZm9yIFwiZ2FyYmFnZSBjb2xsZWN0aW9uXCIuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW52YWxpZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnZhbGlkYXRlKGVsZXMpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgICAgdHlwZSA9IF9yZWYudHlwZTtcbiAgICAgIHZhciBhdGxhc01hbmFnZXIgPSB0aGlzLmF0bGFzTWFuYWdlcjtcbiAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBhdGxhc01hbmFnZXIuaW52YWxpZGF0ZShlbGVzLCB7XG4gICAgICAgICAgZmlsdGVyVHlwZTogZnVuY3Rpb24gZmlsdGVyVHlwZSh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdCA9PT0gdHlwZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvcmNlUmVkcmF3OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF0bGFzTWFuYWdlci5pbnZhbGlkYXRlKGVsZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1biB0ZXh0dXJlIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnYygpIHtcbiAgICAgIHRoaXMuYXRsYXNNYW5hZ2VyLmdjKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVTaGFkZXJQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVTaGFkZXJQcm9ncmFtKHJlbmRlclRhcmdldCkge1xuICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBcIiN2ZXJzaW9uIDMwMCBlc1xcbiAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG4gICAgICB1bmlmb3JtIG1hdDMgdVBhblpvb21NYXRyaXg7XFxuICAgICAgdW5pZm9ybSBpbnQgIHVBdGxhc1NpemU7XFxuICAgICAgXFxuICAgICAgLy8gaW5zdGFuY2VkXFxuICAgICAgaW4gdmVjMiBhUG9zaXRpb247IC8vIGEgdmVydGV4IGZyb20gdGhlIHVuaXQgc3F1YXJlXFxuICAgICAgXFxuICAgICAgaW4gbWF0MyBhVHJhbnNmb3JtOyAvLyB1c2VkIHRvIHRyYW5zZm9ybSB2ZXJ0aWNpZXMsIGVnIGludG8gYSBib3VuZGluZyBib3hcXG4gICAgICBpbiBpbnQgYVZlcnRUeXBlOyAvLyB0aGUgdHlwZSBvZiB0aGluZyB3ZSBhcmUgcmVuZGVyaW5nXFxuXFxuICAgICAgLy8gdGhlIHotaW5kZXggdGhhdCBpcyBvdXRwdXQgd2hlbiB1c2luZyBwaWNraW5nIG1vZGVcXG4gICAgICBpbiB2ZWM0IGFJbmRleDtcXG4gICAgICBcXG4gICAgICAvLyBGb3IgdGV4dHVyZXNcXG4gICAgICBpbiBpbnQgYUF0bGFzSWQ7IC8vIHdoaWNoIHNoYWRlciB1bml0L2F0bGFzIHRvIHVzZVxcbiAgICAgIGluIHZlYzQgYVRleDsgLy8geC95L3cvaCBvZiB0ZXh0dXJlIGluIGF0bGFzXFxuXFxuICAgICAgLy8gZm9yIGVkZ2VzXFxuICAgICAgaW4gdmVjNCBhUG9pbnRBUG9pbnRCO1xcbiAgICAgIGluIHZlYzQgYVBvaW50Q1BvaW50RDtcXG4gICAgICBpbiB2ZWMyIGFMaW5lV2lkdGg7IC8vIGFsc28gdXNlZCBmb3Igbm9kZSBib3JkZXIgd2lkdGhcXG5cXG4gICAgICAvLyBzaW1wbGUgc2hhcGVzXFxuICAgICAgaW4gdmVjNCBhQ29ybmVyUmFkaXVzOyAvLyBmb3Igcm91bmQtcmVjdGFuZ2xlIFt0b3AtcmlnaHQsIGJvdHRvbS1yaWdodCwgdG9wLWxlZnQsIGJvdHRvbS1sZWZ0XVxcbiAgICAgIGluIHZlYzQgYUNvbG9yOyAvLyBhbHNvIHVzZWQgZm9yIGVkZ2VzXFxuICAgICAgaW4gdmVjNCBhQm9yZGVyQ29sb3I7IC8vIGFMaW5lV2lkdGggaXMgdXNlZCBmb3IgYm9yZGVyIHdpZHRoXFxuXFxuICAgICAgLy8gb3V0cHV0IHZhbHVlcyBwYXNzZWQgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxcbiAgICAgIG91dCB2ZWMyIHZUZXhDb29yZDtcXG4gICAgICBvdXQgdmVjNCB2Q29sb3I7XFxuICAgICAgb3V0IHZlYzIgdlBvc2l0aW9uO1xcbiAgICAgIC8vIGZsYXQgdmFsdWVzIGFyZSBub3QgaW50ZXJwb2xhdGVkXFxuICAgICAgZmxhdCBvdXQgaW50IHZBdGxhc0lkOyBcXG4gICAgICBmbGF0IG91dCBpbnQgdlZlcnRUeXBlO1xcbiAgICAgIGZsYXQgb3V0IHZlYzIgdlRvcFJpZ2h0O1xcbiAgICAgIGZsYXQgb3V0IHZlYzIgdkJvdExlZnQ7XFxuICAgICAgZmxhdCBvdXQgdmVjNCB2Q29ybmVyUmFkaXVzO1xcbiAgICAgIGZsYXQgb3V0IHZlYzQgdkJvcmRlckNvbG9yO1xcbiAgICAgIGZsYXQgb3V0IHZlYzIgdkJvcmRlcldpZHRoO1xcbiAgICAgIGZsYXQgb3V0IHZlYzQgdkluZGV4O1xcbiAgICAgIFxcbiAgICAgIHZvaWQgbWFpbih2b2lkKSB7XFxuICAgICAgICBpbnQgdmlkID0gZ2xfVmVydGV4SUQ7XFxuICAgICAgICB2ZWMyIHBvc2l0aW9uID0gYVBvc2l0aW9uOyAvLyBUT0RPIG1ha2UgdGhpcyBhIHZlYzMsIHNpbXBsaWZpZXMgc29tZSBjb2RlIGJlbG93XFxuXFxuICAgICAgICBpZihhVmVydFR5cGUgPT0gXCIuY29uY2F0KFRFWFRVUkUsIFwiKSB7XFxuICAgICAgICAgIGZsb2F0IHRleFggPSBhVGV4Lng7IC8vIHRleHR1cmUgY29vcmRpbmF0ZXNcXG4gICAgICAgICAgZmxvYXQgdGV4WSA9IGFUZXgueTtcXG4gICAgICAgICAgZmxvYXQgdGV4VyA9IGFUZXguejtcXG4gICAgICAgICAgZmxvYXQgdGV4SCA9IGFUZXgudztcXG5cXG4gICAgICAgICAgaWYodmlkID09IDEgfHwgdmlkID09IDIgfHwgdmlkID09IDQpIHtcXG4gICAgICAgICAgICB0ZXhYICs9IHRleFc7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYodmlkID09IDIgfHwgdmlkID09IDQgfHwgdmlkID09IDUpIHtcXG4gICAgICAgICAgICB0ZXhZICs9IHRleEg7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmxvYXQgZCA9IGZsb2F0KHVBdGxhc1NpemUpO1xcbiAgICAgICAgICB2VGV4Q29vcmQgPSB2ZWMyKHRleFggLyBkLCB0ZXhZIC8gZCk7IC8vIHRleCBjb29yZHMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFcXG5cXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHVQYW5ab29tTWF0cml4ICogYVRyYW5zZm9ybSAqIHZlYzMocG9zaXRpb24sIDEuMCksIDEuMCk7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIGlmKGFWZXJ0VHlwZSA9PSBcIikuY29uY2F0KFJFQ1RBTkdMRSwgXCIgfHwgYVZlcnRUeXBlID09IFwiKS5jb25jYXQoRUxMSVBTRSwgXCIgXFxuICAgICAgICAgICAgIHx8IGFWZXJ0VHlwZSA9PSBcIikuY29uY2F0KFJPVU5EX1JFQ1RBTkdMRSwgXCIgfHwgYVZlcnRUeXBlID09IFwiKS5jb25jYXQoQk9UVE9NX1JPVU5EX1JFQ1RBTkdMRSwgXCIpIHsgLy8gc2ltcGxlIHNoYXBlc1xcblxcbiAgICAgICAgICAvLyB0aGUgYm91bmRpbmcgYm94IGlzIG5lZWRlZCBieSB0aGUgZnJhZ21lbnQgc2hhZGVyXFxuICAgICAgICAgIHZCb3RMZWZ0ICA9IChhVHJhbnNmb3JtICogdmVjMygwLCAwLCAxKSkueHk7IC8vIGZsYXRcXG4gICAgICAgICAgdlRvcFJpZ2h0ID0gKGFUcmFuc2Zvcm0gKiB2ZWMzKDEsIDEsIDEpKS54eTsgLy8gZmxhdFxcbiAgICAgICAgICB2UG9zaXRpb24gPSAoYVRyYW5zZm9ybSAqIHZlYzMocG9zaXRpb24sIDEpKS54eTsgLy8gd2lsbCBiZSBpbnRlcnBvbGF0ZWRcXG5cXG4gICAgICAgICAgLy8gY2FsY3VsYXRpb25zIGFyZSBkb25lIGluIHRoZSBmcmFnbWVudCBzaGFkZXIsIGp1c3QgcGFzcyB0aGVzZSBhbG9uZ1xcbiAgICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XFxuICAgICAgICAgIHZDb3JuZXJSYWRpdXMgPSBhQ29ybmVyUmFkaXVzO1xcbiAgICAgICAgICB2Qm9yZGVyQ29sb3IgPSBhQm9yZGVyQ29sb3I7XFxuICAgICAgICAgIHZCb3JkZXJXaWR0aCA9IGFMaW5lV2lkdGg7XFxuXFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh1UGFuWm9vbU1hdHJpeCAqIGFUcmFuc2Zvcm0gKiB2ZWMzKHBvc2l0aW9uLCAxLjApLCAxLjApO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSBpZihhVmVydFR5cGUgPT0gXCIpLmNvbmNhdChFREdFX1NUUkFJR0hULCBcIikge1xcbiAgICAgICAgICB2ZWMyIHNvdXJjZSA9IGFQb2ludEFQb2ludEIueHk7XFxuICAgICAgICAgIHZlYzIgdGFyZ2V0ID0gYVBvaW50QVBvaW50Qi56dztcXG5cXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBnZW9tZXRyeSBzbyB0aGF0IHRoZSBsaW5lIGlzIGNlbnRlcmVkIG9uIHRoZSBlZGdlXFxuICAgICAgICAgIHBvc2l0aW9uLnkgPSBwb3NpdGlvbi55IC0gMC41O1xcblxcbiAgICAgICAgICAvLyBzdHJldGNoIHRoZSB1bml0IHNxdWFyZSBpbnRvIGEgbG9uZyBza2lubnkgcmVjdGFuZ2xlXFxuICAgICAgICAgIHZlYzIgeEJhc2lzID0gdGFyZ2V0IC0gc291cmNlO1xcbiAgICAgICAgICB2ZWMyIHlCYXNpcyA9IG5vcm1hbGl6ZSh2ZWMyKC14QmFzaXMueSwgeEJhc2lzLngpKTtcXG4gICAgICAgICAgdmVjMiBwb2ludCA9IHNvdXJjZSArIHhCYXNpcyAqIHBvc2l0aW9uLnggKyB5QmFzaXMgKiBhTGluZVdpZHRoWzBdICogcG9zaXRpb24ueTtcXG5cXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHVQYW5ab29tTWF0cml4ICogdmVjMyhwb2ludCwgMS4wKSwgMS4wKTtcXG4gICAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xcbiAgICAgICAgfSBcXG4gICAgICAgIGVsc2UgaWYoYVZlcnRUeXBlID09IFwiKS5jb25jYXQoRURHRV9DVVJWRV9TRUdNRU5ULCBcIikge1xcbiAgICAgICAgICB2ZWMyIHBvaW50QSA9IGFQb2ludEFQb2ludEIueHk7XFxuICAgICAgICAgIHZlYzIgcG9pbnRCID0gYVBvaW50QVBvaW50Qi56dztcXG4gICAgICAgICAgdmVjMiBwb2ludEMgPSBhUG9pbnRDUG9pbnRELnh5O1xcbiAgICAgICAgICB2ZWMyIHBvaW50RCA9IGFQb2ludENQb2ludEQuenc7XFxuXFxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZ2VvbWV0cnkgc28gdGhhdCB0aGUgbGluZSBpcyBjZW50ZXJlZCBvbiB0aGUgZWRnZVxcbiAgICAgICAgICBwb3NpdGlvbi55ID0gcG9zaXRpb24ueSAtIDAuNTtcXG5cXG4gICAgICAgICAgdmVjMiBwMCwgcDEsIHAyLCBwb3M7XFxuICAgICAgICAgIGlmKHBvc2l0aW9uLnggPT0gMC4wKSB7IC8vIFRoZSBsZWZ0IHNpZGUgb2YgdGhlIHVuaXQgc3F1YXJlXFxuICAgICAgICAgICAgcDAgPSBwb2ludEE7XFxuICAgICAgICAgICAgcDEgPSBwb2ludEI7XFxuICAgICAgICAgICAgcDIgPSBwb2ludEM7XFxuICAgICAgICAgICAgcG9zID0gcG9zaXRpb247XFxuICAgICAgICAgIH0gZWxzZSB7IC8vIFRoZSByaWdodCBzaWRlIG9mIHRoZSB1bml0IHNxdWFyZSwgdXNlIHNhbWUgYXBwcm9hY2ggYnV0IGZsaXAgdGhlIGdlb21ldHJ5IHVwc2lkZSBkb3duXFxuICAgICAgICAgICAgcDAgPSBwb2ludEQ7XFxuICAgICAgICAgICAgcDEgPSBwb2ludEM7XFxuICAgICAgICAgICAgcDIgPSBwb2ludEI7XFxuICAgICAgICAgICAgcG9zID0gdmVjMigwLjAsIC1wb3NpdGlvbi55KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2ZWMyIHAwMSA9IHAxIC0gcDA7XFxuICAgICAgICAgIHZlYzIgcDEyID0gcDIgLSBwMTtcXG4gICAgICAgICAgdmVjMiBwMjEgPSBwMSAtIHAyO1xcblxcbiAgICAgICAgICAvLyBGaW5kIHRoZSBub3JtYWwgdmVjdG9yLlxcbiAgICAgICAgICB2ZWMyIHRhbmdlbnQgPSBub3JtYWxpemUobm9ybWFsaXplKHAxMikgKyBub3JtYWxpemUocDAxKSk7XFxuICAgICAgICAgIHZlYzIgbm9ybWFsID0gdmVjMigtdGFuZ2VudC55LCB0YW5nZW50LngpO1xcblxcbiAgICAgICAgICAvLyBGaW5kIHRoZSB2ZWN0b3IgcGVycGVuZGljdWxhciB0byBwMCAtPiBwMS5cXG4gICAgICAgICAgdmVjMiBwMDFOb3JtID0gbm9ybWFsaXplKHZlYzIoLXAwMS55LCBwMDEueCkpO1xcblxcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGJlbmQgZGlyZWN0aW9uLlxcbiAgICAgICAgICBmbG9hdCBzaWdtYSA9IHNpZ24oZG90KHAwMSArIHAyMSwgbm9ybWFsKSk7XFxuICAgICAgICAgIGZsb2F0IHdpZHRoID0gYUxpbmVXaWR0aFswXTtcXG5cXG4gICAgICAgICAgaWYoc2lnbihwb3MueSkgPT0gLXNpZ21hKSB7XFxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcnNlY3RpbmcgdmVydGV4LiBBZGp1c3QgdGhlIHBvc2l0aW9uIHNvIHRoYXQgdGhlcmUncyBubyBvdmVybGFwLlxcbiAgICAgICAgICAgIHZlYzIgcG9pbnQgPSAwLjUgKiB3aWR0aCAqIG5vcm1hbCAqIC1zaWdtYSAvIGRvdChub3JtYWwsIHAwMU5vcm0pO1xcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh1UGFuWm9vbU1hdHJpeCAqIHZlYzMocDEgKyBwb2ludCwgMS4wKSwgMS4wKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbm9uLWludGVyc2VjdGluZyB2ZXJ0ZXguIFRyZWF0IGl0IGxpa2UgYSBtaXRyZSBqb2luLlxcbiAgICAgICAgICAgIHZlYzIgcG9pbnQgPSAwLjUgKiB3aWR0aCAqIG5vcm1hbCAqIHNpZ21hICogZG90KG5vcm1hbCwgcDAxTm9ybSk7XFxuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHVQYW5ab29tTWF0cml4ICogdmVjMyhwMSArIHBvaW50LCAxLjApLCAxLjApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZDb2xvciA9IGFDb2xvcjtcXG4gICAgICAgIH0gXFxuICAgICAgICBlbHNlIGlmKGFWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEVER0VfQVJST1csIFwiICYmIHZpZCA8IDMpIHtcXG4gICAgICAgICAgLy8gbWFzc2FnZSB0aGUgZmlyc3QgdHJpYW5nbGUgaW50byBhbiBlZGdlIGFycm93XFxuICAgICAgICAgIGlmKHZpZCA9PSAwKVxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdmVjMigtMC4xNSwgLTAuMyk7XFxuICAgICAgICAgIGlmKHZpZCA9PSAxKVxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdmVjMiggIDAuMCwgIDAuMCk7XFxuICAgICAgICAgIGlmKHZpZCA9PSAyKVxcbiAgICAgICAgICAgIHBvc2l0aW9uID0gdmVjMiggMC4xNSwgLTAuMyk7XFxuXFxuICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh1UGFuWm9vbU1hdHJpeCAqIGFUcmFuc2Zvcm0gKiB2ZWMzKHBvc2l0aW9uLCAxLjApLCAxLjApO1xcbiAgICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XFxuICAgICAgICB9XFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KDIuMCwgMC4wLCAwLjAsIDEuMCk7IC8vIGRpc2NhcmQgdmVydGV4IGJ5IHB1dHRpbmcgaXQgb3V0c2lkZSB3ZWJnbCBjbGlwIHNwYWNlXFxuICAgICAgICB9XFxuXFxuICAgICAgICB2QXRsYXNJZCA9IGFBdGxhc0lkO1xcbiAgICAgICAgdlZlcnRUeXBlID0gYVZlcnRUeXBlO1xcbiAgICAgICAgdkluZGV4ID0gYUluZGV4O1xcbiAgICAgIH1cXG4gICAgXCIpO1xuICAgICAgdmFyIGlkeHMgPSB0aGlzLmJhdGNoTWFuYWdlci5nZXRJbmRleEFycmF5KCk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBcIiN2ZXJzaW9uIDMwMCBlc1xcbiAgICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG4gICAgICAvLyBkZWNsYXJlIHRleHR1cmUgdW5pdCBmb3IgZWFjaCB0ZXh0dXJlIGF0bGFzIGluIHRoZSBiYXRjaFxcbiAgICAgIFwiLmNvbmNhdChpZHhzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gXCJ1bmlmb3JtIHNhbXBsZXIyRCB1VGV4dHVyZVwiLmNvbmNhdChpLCBcIjtcIik7XG4gICAgICB9KS5qb2luKCdcXG5cXHQnKSwgXCJcXG5cXG4gICAgICB1bmlmb3JtIHZlYzQgdUJHQ29sb3I7XFxuICAgICAgdW5pZm9ybSBmbG9hdCB1Wm9vbTtcXG5cXG4gICAgICBpbiB2ZWMyIHZUZXhDb29yZDtcXG4gICAgICBpbiB2ZWM0IHZDb2xvcjtcXG4gICAgICBpbiB2ZWMyIHZQb3NpdGlvbjsgLy8gbW9kZWwgY29vcmRpbmF0ZXNcXG5cXG4gICAgICBmbGF0IGluIGludCB2QXRsYXNJZDtcXG4gICAgICBmbGF0IGluIHZlYzQgdkluZGV4O1xcbiAgICAgIGZsYXQgaW4gaW50IHZWZXJ0VHlwZTtcXG4gICAgICBmbGF0IGluIHZlYzIgdlRvcFJpZ2h0O1xcbiAgICAgIGZsYXQgaW4gdmVjMiB2Qm90TGVmdDtcXG4gICAgICBmbGF0IGluIHZlYzQgdkNvcm5lclJhZGl1cztcXG4gICAgICBmbGF0IGluIHZlYzQgdkJvcmRlckNvbG9yO1xcbiAgICAgIGZsYXQgaW4gdmVjMiB2Qm9yZGVyV2lkdGg7XFxuXFxuICAgICAgb3V0IHZlYzQgb3V0Q29sb3I7XFxuXFxuICAgICAgXCIpLmNvbmNhdChjaXJjbGVTRCwgXCJcXG4gICAgICBcIikuY29uY2F0KHJlY3RhbmdsZVNELCBcIlxcbiAgICAgIFwiKS5jb25jYXQocm91bmRSZWN0YW5nbGVTRCwgXCJcXG4gICAgICBcIikuY29uY2F0KGVsbGlwc2VTRCwgXCJcXG5cXG4gICAgICB2ZWM0IGJsZW5kKHZlYzQgdG9wLCB2ZWM0IGJvdCkgeyAvLyBibGVuZCBjb2xvcnMgd2l0aCBwcmVtdWx0aXBsaWVkIGFscGhhXFxuICAgICAgICByZXR1cm4gdmVjNCggXFxuICAgICAgICAgIHRvcC5yZ2IgKyAoYm90LnJnYiAqICgxLjAgLSB0b3AuYSkpLFxcbiAgICAgICAgICB0b3AuYSAgICsgKGJvdC5hICAgKiAoMS4wIC0gdG9wLmEpKSBcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIHZlYzQgZGlzdEludGVycCh2ZWM0IGNBLCB2ZWM0IGNCLCBmbG9hdCBkKSB7IC8vIGludGVycG9sYXRlIGNvbG9yIHVzaW5nIFNpZ25lZCBEaXN0YW5jZVxcbiAgICAgICAgLy8gc2NhbGUgdG8gdGhlIHpvb20gbGV2ZWwgc28gdGhhdCBib3JkZXJzIGRvbid0IGxvb2sgYmx1cnJ5IHdoZW4gem9vbWVkIGluXFxuICAgICAgICAvLyBub3RlIDEuNSBpcyBhbiBhcmliaXRyYXJ5IHZhbHVlIGNob3NlbiBiZWNhdXNlIGl0IGxvb2tzIGdvb2RcXG4gICAgICAgIHJldHVybiBtaXgoY0EsIGNCLCAxLjAgLSBzbW9vdGhzdGVwKDAuMCwgMS41IC8gdVpvb20sIGFicyhkKSkpOyBcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKHZvaWQpIHtcXG4gICAgICAgIGlmKHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KFRFWFRVUkUsIFwiKSB7XFxuICAgICAgICAgIC8vIGxvb2sgdXAgdGhlIHRleGVsIGZyb20gdGhlIHRleHR1cmUgdW5pdFxcbiAgICAgICAgICBcIikuY29uY2F0KGlkeHMubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBcImlmKHZBdGxhc0lkID09IFwiLmNvbmNhdChpLCBcIikgb3V0Q29sb3IgPSB0ZXh0dXJlKHVUZXh0dXJlXCIpLmNvbmNhdChpLCBcIiwgdlRleENvb3JkKTtcIik7XG4gICAgICB9KS5qb2luKCdcXG5cXHRlbHNlICcpLCBcIlxcbiAgICAgICAgfSBcXG4gICAgICAgIGVsc2UgaWYodlZlcnRUeXBlID09IFwiKS5jb25jYXQoRURHRV9BUlJPVywgXCIpIHtcXG4gICAgICAgICAgLy8gbWltaWNzIGhvdyBjYW52YXMgcmVuZGVyZXIgdXNlcyBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xcbiAgICAgICAgICBvdXRDb2xvciA9IGJsZW5kKHZDb2xvciwgdUJHQ29sb3IpO1xcbiAgICAgICAgICBvdXRDb2xvci5hID0gMS4wOyAvLyBtYWtlIG9wYXF1ZSwgbWFza3Mgb3V0IGxpbmUgdW5kZXIgYXJyb3dcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYodlZlcnRUeXBlID09IFwiKS5jb25jYXQoUkVDVEFOR0xFLCBcIiAmJiB2Qm9yZGVyV2lkdGggPT0gdmVjMigwLjApKSB7IC8vIHNpbXBsZSByZWN0YW5nbGUgd2l0aCBubyBib3JkZXJcXG4gICAgICAgICAgb3V0Q29sb3IgPSB2Q29sb3I7IC8vIHVuaXQgc3F1YXJlIGlzIGFscmVhZHkgdHJhbnNmb3JtZWQgdG8gdGhlIHJlY3RhbmdsZSwgbm90aGluZyBlbHNlIG5lZWRzIHRvIGJlIGRvbmVcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2UgaWYodlZlcnRUeXBlID09IFwiKS5jb25jYXQoUkVDVEFOR0xFLCBcIiB8fCB2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChFTExJUFNFLCBcIiBcXG4gICAgICAgICAgfHwgdlZlcnRUeXBlID09IFwiKS5jb25jYXQoUk9VTkRfUkVDVEFOR0xFLCBcIiB8fCB2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChCT1RUT01fUk9VTkRfUkVDVEFOR0xFLCBcIikgeyAvLyB1c2UgU0RGXFxuXFxuICAgICAgICAgIGZsb2F0IG91dGVyQm9yZGVyID0gdkJvcmRlcldpZHRoWzBdO1xcbiAgICAgICAgICBmbG9hdCBpbm5lckJvcmRlciA9IHZCb3JkZXJXaWR0aFsxXTtcXG4gICAgICAgICAgZmxvYXQgYm9yZGVyUGFkZGluZyA9IG91dGVyQm9yZGVyICogMi4wO1xcbiAgICAgICAgICBmbG9hdCB3ID0gdlRvcFJpZ2h0LnggLSB2Qm90TGVmdC54IC0gYm9yZGVyUGFkZGluZztcXG4gICAgICAgICAgZmxvYXQgaCA9IHZUb3BSaWdodC55IC0gdkJvdExlZnQueSAtIGJvcmRlclBhZGRpbmc7XFxuICAgICAgICAgIHZlYzIgYiA9IHZlYzIody8yLjAsIGgvMi4wKTsgLy8gaGFsZiB3aWR0aCwgaGFsZiBoZWlnaHRcXG4gICAgICAgICAgdmVjMiBwID0gdlBvc2l0aW9uIC0gdmVjMih2VG9wUmlnaHQueCAtIGJbMF0gLSBvdXRlckJvcmRlciwgdlRvcFJpZ2h0LnkgLSBiWzFdIC0gb3V0ZXJCb3JkZXIpOyAvLyB0cmFuc2xhdGUgdG8gY2VudGVyXFxuXFxuICAgICAgICAgIGZsb2F0IGQ7IC8vIHNpZ25lZCBkaXN0YW5jZVxcbiAgICAgICAgICBpZih2VmVydFR5cGUgPT0gXCIpLmNvbmNhdChSRUNUQU5HTEUsIFwiKSB7XFxuICAgICAgICAgICAgZCA9IHJlY3RhbmdsZVNEKHAsIGIpO1xcbiAgICAgICAgICB9IGVsc2UgaWYodlZlcnRUeXBlID09IFwiKS5jb25jYXQoRUxMSVBTRSwgXCIgJiYgdyA9PSBoKSB7XFxuICAgICAgICAgICAgZCA9IGNpcmNsZVNEKHAsIGIueCk7IC8vIGZhc3RlciB0aGFuIGVsbGlwc2VcXG4gICAgICAgICAgfSBlbHNlIGlmKHZWZXJ0VHlwZSA9PSBcIikuY29uY2F0KEVMTElQU0UsIFwiKSB7XFxuICAgICAgICAgICAgZCA9IGVsbGlwc2VTRChwLCBiKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBkID0gcm91bmRSZWN0YW5nbGVTRChwLCBiLCB2Q29ybmVyUmFkaXVzLnd6eXgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8vIHVzZSB0aGUgZGlzdGFuY2UgdG8gaW50ZXJwb2xhdGUgYSBjb2xvciB0byBzbW9vdGggdGhlIGVkZ2VzIG9mIHRoZSBzaGFwZSwgZG9lc24ndCBuZWVkIG11bHRpc2FtcGxpbmdcXG4gICAgICAgICAgLy8gd2UgbXVzdCBzbW9vdGggY29sb3JzIGlud2FyZHMsIGJlY2F1c2Ugd2UgY2FuJ3QgY2hhbmdlIHBpeGVscyBvdXRzaWRlIHRoZSBzaGFwZSdzIGJvdW5kaW5nIGJveFxcbiAgICAgICAgICBpZihkID4gMC4wKSB7XFxuICAgICAgICAgICAgaWYoZCA+IG91dGVyQm9yZGVyKSB7XFxuICAgICAgICAgICAgICBkaXNjYXJkO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBvdXRDb2xvciA9IGRpc3RJbnRlcnAodkJvcmRlckNvbG9yLCB2ZWM0KDApLCBkIC0gb3V0ZXJCb3JkZXIpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpZihkID4gaW5uZXJCb3JkZXIpIHtcXG4gICAgICAgICAgICAgIHZlYzQgb3V0ZXJDb2xvciA9IG91dGVyQm9yZGVyID09IDAuMCA/IHZlYzQoMCkgOiB2Qm9yZGVyQ29sb3I7XFxuICAgICAgICAgICAgICB2ZWM0IGlubmVyQm9yZGVyQ29sb3IgPSBibGVuZCh2Qm9yZGVyQ29sb3IsIHZDb2xvcik7XFxuICAgICAgICAgICAgICBvdXRDb2xvciA9IGRpc3RJbnRlcnAoaW5uZXJCb3JkZXJDb2xvciwgb3V0ZXJDb2xvciwgZCk7XFxuICAgICAgICAgICAgfSBcXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgIHZlYzQgb3V0ZXJDb2xvcjtcXG4gICAgICAgICAgICAgIGlmKGlubmVyQm9yZGVyID09IDAuMCAmJiBvdXRlckJvcmRlciA9PSAwLjApIHtcXG4gICAgICAgICAgICAgICAgb3V0ZXJDb2xvciA9IHZlYzQoMCk7XFxuICAgICAgICAgICAgICB9IGVsc2UgaWYoaW5uZXJCb3JkZXIgPT0gMC4wKSB7XFxuICAgICAgICAgICAgICAgIG91dGVyQ29sb3IgPSB2Qm9yZGVyQ29sb3I7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBvdXRlckNvbG9yID0gYmxlbmQodkJvcmRlckNvbG9yLCB2Q29sb3IpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgb3V0Q29sb3IgPSBkaXN0SW50ZXJwKHZDb2xvciwgb3V0ZXJDb2xvciwgZCAtIGlubmVyQm9yZGVyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICBvdXRDb2xvciA9IHZDb2xvcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIFwiKS5jb25jYXQocmVuZGVyVGFyZ2V0LnBpY2tpbmcgPyBcImlmKG91dENvbG9yLmEgPT0gMC4wKSBkaXNjYXJkO1xcbiAgICAgICAgICAgICBlbHNlIG91dENvbG9yID0gdkluZGV4O1wiIDogJycsIFwiXFxuICAgICAgfVxcbiAgICBcIik7XG4gICAgICB2YXIgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlclNvdXJjZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuXG4gICAgICAvLyBpbnN0YW5jZSBnZW9tZXRyeVxuICAgICAgcHJvZ3JhbS5hUG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVBvc2l0aW9uJyk7XG5cbiAgICAgIC8vIGF0dHJpYnV0ZXNcbiAgICAgIHByb2dyYW0uYUluZGV4ID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FJbmRleCcpO1xuICAgICAgcHJvZ3JhbS5hVmVydFR5cGUgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVZlcnRUeXBlJyk7XG4gICAgICBwcm9ncmFtLmFUcmFuc2Zvcm0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVRyYW5zZm9ybScpO1xuICAgICAgcHJvZ3JhbS5hQXRsYXNJZCA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhQXRsYXNJZCcpO1xuICAgICAgcHJvZ3JhbS5hVGV4ID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FUZXgnKTtcbiAgICAgIHByb2dyYW0uYVBvaW50QVBvaW50QiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhUG9pbnRBUG9pbnRCJyk7XG4gICAgICBwcm9ncmFtLmFQb2ludENQb2ludEQgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCAnYVBvaW50Q1BvaW50RCcpO1xuICAgICAgcHJvZ3JhbS5hTGluZVdpZHRoID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FMaW5lV2lkdGgnKTtcbiAgICAgIHByb2dyYW0uYUNvbG9yID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FDb2xvcicpO1xuICAgICAgcHJvZ3JhbS5hQ29ybmVyUmFkaXVzID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FDb3JuZXJSYWRpdXMnKTtcbiAgICAgIHByb2dyYW0uYUJvcmRlckNvbG9yID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgJ2FCb3JkZXJDb2xvcicpO1xuXG4gICAgICAvLyB1bmlmb3Jtc1xuICAgICAgcHJvZ3JhbS51UGFuWm9vbU1hdHJpeCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndVBhblpvb21NYXRyaXgnKTtcbiAgICAgIHByb2dyYW0udUF0bGFzU2l6ZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUF0bGFzU2l6ZScpO1xuICAgICAgcHJvZ3JhbS51QkdDb2xvciA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCAndUJHQ29sb3InKTtcbiAgICAgIHByb2dyYW0udVpvb20gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgJ3Vab29tJyk7XG4gICAgICBwcm9ncmFtLnVUZXh0dXJlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJhdGNoTWFuYWdlci5nZXRNYXhBdGxhc2VzUGVyQmF0Y2goKTsgaSsrKSB7XG4gICAgICAgIHByb2dyYW0udVRleHR1cmVzLnB1c2goZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidVRleHR1cmVcIi5jb25jYXQoaSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlVkFPXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVWQU8oKSB7XG4gICAgICB2YXIgdW5pdFNxdWFyZSA9IFswLCAwLCAxLCAwLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxXTtcbiAgICAgIHRoaXMudmVydGV4Q291bnQgPSB1bml0U3F1YXJlLmxlbmd0aCAvIDI7XG4gICAgICB2YXIgbiA9IHRoaXMubWF4SW5zdGFuY2VzO1xuICAgICAgdmFyIGdsID0gdGhpcy5nbCxcbiAgICAgICAgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbTtcbiAgICAgIHZhciB2YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgICAgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG4gICAgICBjcmVhdGVCdWZmZXJTdGF0aWNEcmF3KGdsLCAndmVjMicsIHByb2dyYW0uYVBvc2l0aW9uLCB1bml0U3F1YXJlKTtcblxuICAgICAgLy8gQ3JlYXRlIGJ1ZmZlcnMgZm9yIGFsbCB0aGUgYXR0cmlidXRlc1xuICAgICAgdGhpcy50cmFuc2Zvcm1CdWZmZXIgPSBjcmVhdGUzeDNNYXRyaXhCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgcHJvZ3JhbS5hVHJhbnNmb3JtKTtcbiAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ3ZlYzQnLCBwcm9ncmFtLmFJbmRleCk7XG4gICAgICB0aGlzLnZlcnRUeXBlQnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICdpbnQnLCBwcm9ncmFtLmFWZXJ0VHlwZSk7XG4gICAgICB0aGlzLmF0bGFzSWRCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ2ludCcsIHByb2dyYW0uYUF0bGFzSWQpO1xuICAgICAgdGhpcy50ZXhCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ3ZlYzQnLCBwcm9ncmFtLmFUZXgpO1xuICAgICAgdGhpcy5wb2ludEFQb2ludEJCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ3ZlYzQnLCBwcm9ncmFtLmFQb2ludEFQb2ludEIpO1xuICAgICAgdGhpcy5wb2ludENQb2ludERCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ3ZlYzQnLCBwcm9ncmFtLmFQb2ludENQb2ludEQpO1xuICAgICAgdGhpcy5saW5lV2lkdGhCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ3ZlYzInLCBwcm9ncmFtLmFMaW5lV2lkdGgpO1xuICAgICAgdGhpcy5jb2xvckJ1ZmZlciA9IGNyZWF0ZUJ1ZmZlckR5bmFtaWNEcmF3KGdsLCBuLCAndmVjNCcsIHByb2dyYW0uYUNvbG9yKTtcbiAgICAgIHRoaXMuY29ybmVyUmFkaXVzQnVmZmVyID0gY3JlYXRlQnVmZmVyRHluYW1pY0RyYXcoZ2wsIG4sICd2ZWM0JywgcHJvZ3JhbS5hQ29ybmVyUmFkaXVzKTtcbiAgICAgIHRoaXMuYm9yZGVyQ29sb3JCdWZmZXIgPSBjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyhnbCwgbiwgJ3ZlYzQnLCBwcm9ncmFtLmFCb3JkZXJDb2xvcik7XG4gICAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICByZXR1cm4gdmFvO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJidWZmZXJzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLl9idWZmZXJzKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnMgPSBPYmplY3Qua2V5cyh0aGlzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gZW5kc1dpdGgoaywgJ0J1ZmZlcicpO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXNba107XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0RnJhbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRGcmFtZShwYW5ab29tTWF0cml4KSB7XG4gICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBSRU5ERVJfVEFSR0VULlNDUkVFTjtcbiAgICAgIHRoaXMucGFuWm9vbU1hdHJpeCA9IHBhblpvb21NYXRyaXg7XG4gICAgICB0aGlzLnJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcbiAgICAgIHRoaXMuYmF0Y2hEZWJ1Z0luZm8gPSBbXTtcbiAgICAgIHRoaXMud3JhcHBlZENvdW50ID0gMDtcbiAgICAgIHRoaXMuc2ltcGxlQ291bnQgPSAwO1xuICAgICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0QmF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRCYXRjaCgpIHtcbiAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IDA7XG4gICAgICB0aGlzLmJhdGNoTWFuYWdlci5zdGFydEJhdGNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZEZyYW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZEZyYW1lKCkge1xuICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNWaXNpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1Zpc2libGUoZWxlLCBvcHRzKSB7XG4gICAgICBpZiAoZWxlLnZpc2libGUoKSkge1xuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLmlzVmlzaWJsZSkge1xuICAgICAgICAgIHJldHVybiBvcHRzLmlzVmlzaWJsZShlbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIGEgdGV4dHVyZSB1c2luZyB0aGUgdGV4dHVyZSBhdGxhcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3VGV4dHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3VGV4dHVyZShlbGUsIGVsZUluZGV4LCB0eXBlKSB7XG4gICAgICB2YXIgYXRsYXNNYW5hZ2VyID0gdGhpcy5hdGxhc01hbmFnZXIsXG4gICAgICAgIGJhdGNoTWFuYWdlciA9IHRoaXMuYmF0Y2hNYW5hZ2VyO1xuICAgICAgdmFyIG9wdHMgPSBhdGxhc01hbmFnZXIuZ2V0UmVuZGVyVHlwZU9wdHModHlwZSk7XG4gICAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZShlbGUsIG9wdHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRWRnZXMgd2l0aCBpbnZhbGlkIHBvaW50cyBjb3VsZCBiZSBwYXNzZWQgaGVyZSAobGFiZWxzKSwgY2F1c2luZyBlcnJvcnNcbiAgICAgIC8vIFJlZjogUmFuZG9tIFwiU2NyaXB0IEVycm9yXCIgdGhyb3duIHdoZW4gZ2VuZXJhdGluZyBub2RlcyBhbmQgZWRnZXMgaW4gbmV3ZXN0IHdlYmdsIHZlcnNpb24gIzMzNjVcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jeXRvc2NhcGUvY3l0b3NjYXBlLmpzL2lzc3Vlcy8zMzY1XG4gICAgICBpZiAoZWxlLmlzRWRnZSgpICYmICF0aGlzLl9pc1ZhbGlkRWRnZShlbGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlbmRlclRhcmdldC5waWNraW5nICYmIG9wdHMuZ2V0VGV4UGlja2luZ01vZGUpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBvcHRzLmdldFRleFBpY2tpbmdNb2RlKGVsZSk7XG4gICAgICAgIGlmIChtb2RlID09PSBURVhfUElDS0lOR19NT0RFLklHTk9SRSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RlID09IFRFWF9QSUNLSU5HX01PREUuVVNFX0JCKSB7XG4gICAgICAgICAgdGhpcy5kcmF3UGlja2luZ1JlY3RhbmdsZShlbGUsIGVsZUluZGV4LCB0eXBlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBhdGxhcyBhbmQgdGhlIHRleHR1cmUgY29vcmRpbmF0ZXMsIHdpbGwgZHJhdyB0aGUgdGV4dHVyZSBpZiBpdCBoYXNuJ3QgYmVlbiBkcmF3biB5ZXRcbiAgICAgIC8vIE1heSBiZSBtb3JlIHRoYW4gb25lIHRleHR1cmUgaWYgZm9yIGV4YW1wbGUgdGhlIGxhYmVsIGhhcyBtdWx0aXBsZSBsaW5lc1xuICAgICAgdmFyIGF0bGFzSW5mb0FycmF5ID0gYXRsYXNNYW5hZ2VyLmdldEF0bGFzSW5mbyhlbGUsIHR5cGUpO1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGF0bGFzSW5mb0FycmF5KSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBhdGxhc0luZm8gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgYXRsYXMgPSBhdGxhc0luZm8uYXRsYXMsXG4gICAgICAgICAgICB0ZXgxID0gYXRsYXNJbmZvLnRleDEsXG4gICAgICAgICAgICB0ZXgyID0gYXRsYXNJbmZvLnRleDI7IC8vIHRleDIgaXMgdXNlZCBpZiB0aGUgbGFiZWwgd3JhcHMgYW5kIHRoZXJlIGFyZSB0d28gdGV4dHVyZXNcblxuICAgICAgICAgIGlmICghYmF0Y2hNYW5hZ2VyLmNhbkFkZFRvQ3VycmVudEJhdGNoKGF0bGFzKSkge1xuICAgICAgICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXRsYXNJbmRleCA9IGJhdGNoTWFuYWdlci5nZXRBdGxhc0luZGV4Rm9yQmF0Y2goYXRsYXMpO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2FyciA9IFtbdGV4MSwgdHJ1ZV0sIFt0ZXgyLCBmYWxzZV1dOyBfaSA8IF9hcnIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgX2FyciRfaSA9IF9zbGljZWRUb0FycmF5KF9hcnJbX2ldLCAyKSxcbiAgICAgICAgICAgICAgdGV4ID0gX2FyciRfaVswXSxcbiAgICAgICAgICAgICAgZmlyc3QgPSBfYXJyJF9pWzFdO1xuICAgICAgICAgICAgaWYgKHRleC53ICE9IDApIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZUNvdW50O1xuICAgICAgICAgICAgICB0aGlzLnZlcnRUeXBlQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpWzBdID0gVEVYVFVSRTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4VmlldyA9IHRoaXMuaW5kZXhCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIGluZGV4VG9WZWM0KGVsZUluZGV4LCBpbmRleFZpZXcpO1xuXG4gICAgICAgICAgICAgIC8vIFNldCB2YWx1ZXMgaW4gdGhlIGJ1ZmZlcnMgdXNpbmcgVHlwZWQgQXJyYXkgVmlld3MgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgICB2YXIgYXRsYXNJZFZpZXcgPSB0aGlzLmF0bGFzSWRCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIGF0bGFzSWRWaWV3WzBdID0gYXRsYXNJbmRleDtcblxuICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHR3byBzZXRzIG9mIHRleHR1cmUgY29vcmRpbmF0ZXMgYW5kIHRyYW5zZm9ybXMgYmVjYXVzZSB0ZXh0dXJlcyBjYW4gd3JhcCBpbiB0aGUgYXRsYXNcbiAgICAgICAgICAgICAgdmFyIHRleFZpZXcgPSB0aGlzLnRleEJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgdGV4Vmlld1swXSA9IHRleC54O1xuICAgICAgICAgICAgICB0ZXhWaWV3WzFdID0gdGV4Lnk7XG4gICAgICAgICAgICAgIHRleFZpZXdbMl0gPSB0ZXgudztcbiAgICAgICAgICAgICAgdGV4Vmlld1szXSA9IHRleC5oO1xuICAgICAgICAgICAgICB2YXIgbWF0cml4VmlldyA9IHRoaXMudHJhbnNmb3JtQnVmZmVyLmdldE1hdHJpeFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybU1hdHJpeChlbGUsIG1hdHJpeFZpZXcsIG9wdHMsIGF0bGFzSW5mbywgZmlyc3QpO1xuICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlQ291bnQrKztcbiAgICAgICAgICAgICAgaWYgKCFmaXJzdCkgdGhpcy53cmFwcGVkQ291bnQrKztcbiAgICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2VDb3VudCA+PSB0aGlzLm1heEluc3RhbmNlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1hdHJpeCBpcyBleHBlY3RlZCB0byBiZSBhIDkgZWxlbWVudCBhcnJheVxuICAgICAqIHRoaXMgZnVuY3Rpb24gZm9sbG93cyBzYW1lIHBhdHRlcm4gYXMgQ1JwLmRyYXdDYWNoZWRFbGVtZW50UG9ydGlvbiguLi4pXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VHJhbnNmb3JtTWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRyYW5zZm9ybU1hdHJpeChlbGUsIG1hdHJpeCwgb3B0cywgYXRsYXNJbmZvKSB7XG4gICAgICB2YXIgZmlyc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gICAgICB2YXIgcGFkZGluZyA9IDA7XG4gICAgICBpZiAob3B0cy5zaGFwZVByb3BzICYmIG9wdHMuc2hhcGVQcm9wcy5wYWRkaW5nKSB7XG4gICAgICAgIHBhZGRpbmcgPSBlbGUucHN0eWxlKG9wdHMuc2hhcGVQcm9wcy5wYWRkaW5nKS5wZlZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGF0bGFzSW5mbykge1xuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGNvbXB1dGVkIHRoZSBiYiBhbmQgdGV4IGJvdW5kcyBmb3IgYSB0ZXh0dXJlXG4gICAgICAgIHZhciBiYiA9IGF0bGFzSW5mby5iYixcbiAgICAgICAgICB0ZXgxID0gYXRsYXNJbmZvLnRleDEsXG4gICAgICAgICAgdGV4MiA9IGF0bGFzSW5mby50ZXgyO1xuICAgICAgICAvLyB3cmFwcGVkIHRleHR1cmVzIG5lZWQgc2VwYXJhdGUgbWF0cml4IGZvciBlYWNoIHBhcnRcbiAgICAgICAgdmFyIHJhdGlvID0gdGV4MS53IC8gKHRleDEudyArIHRleDIudyk7XG4gICAgICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgICAvLyBmaXJzdCA9IHRydWUgbWVhbnMgaXRzIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSB3cmFwcGVkIHRleHR1cmVcbiAgICAgICAgICByYXRpbyA9IDEgLSByYXRpbztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWRqQkIgPSB0aGlzLl9nZXRBZGp1c3RlZEJCKGJiLCBwYWRkaW5nLCBmaXJzdCwgcmF0aW8pO1xuICAgICAgICB0aGlzLl9hcHBseVRyYW5zZm9ybU1hdHJpeChtYXRyaXgsIGFkakJCLCBvcHRzLCBlbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSBhIHRleHR1cmUsIG9yIHdlIHdhbnQgdG8gYXZvaWQgY3JlYXRpbmcgYSB0ZXh0dXJlIGZvciBzaW1wbGUgc2hhcGVzXG4gICAgICAgIHZhciBfYmIgPSBvcHRzLmdldEJvdW5kaW5nQm94KGVsZSk7XG4gICAgICAgIHZhciBfYWRqQkIgPSB0aGlzLl9nZXRBZGp1c3RlZEJCKF9iYiwgcGFkZGluZywgdHJ1ZSwgMSk7XG4gICAgICAgIHRoaXMuX2FwcGx5VHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgX2FkakJCLCBvcHRzLCBlbGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYXBwbHlUcmFuc2Zvcm1NYXRyaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5VHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgYWRqQkIsIG9wdHMsIGVsZSkge1xuICAgICAgdmFyIHgsIHk7XG4gICAgICBpZGVudGl0eShtYXRyaXgpO1xuICAgICAgdmFyIHRoZXRhID0gb3B0cy5nZXRSb3RhdGlvbiA/IG9wdHMuZ2V0Um90YXRpb24oZWxlKSA6IDA7XG4gICAgICBpZiAodGhldGEgIT09IDApIHtcbiAgICAgICAgdmFyIF9vcHRzJGdldFJvdGF0aW9uUG9pbiA9IG9wdHMuZ2V0Um90YXRpb25Qb2ludChlbGUpLFxuICAgICAgICAgIHN4ID0gX29wdHMkZ2V0Um90YXRpb25Qb2luLngsXG4gICAgICAgICAgc3kgPSBfb3B0cyRnZXRSb3RhdGlvblBvaW4ueTtcbiAgICAgICAgdHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCBbc3gsIHN5XSk7XG4gICAgICAgIHJvdGF0ZShtYXRyaXgsIG1hdHJpeCwgdGhldGEpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gb3B0cy5nZXRSb3RhdGlvbk9mZnNldChlbGUpO1xuICAgICAgICB4ID0gb2Zmc2V0LnggKyAoYWRqQkIueE9mZnNldCB8fCAwKTtcbiAgICAgICAgeSA9IG9mZnNldC55ICsgKGFkakJCLnlPZmZzZXQgfHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gYWRqQkIueDE7XG4gICAgICAgIHkgPSBhZGpCQi55MTtcbiAgICAgIH1cbiAgICAgIHRyYW5zbGF0ZShtYXRyaXgsIG1hdHJpeCwgW3gsIHldKTtcbiAgICAgIHNjYWxlKG1hdHJpeCwgbWF0cml4LCBbYWRqQkIudywgYWRqQkIuaF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdHMgYSBub2RlIG9yIGxhYmVsIEJCIHRvIGFjY29tb2RhdGUgcGFkZGluZyBhbmQgc3BsaXQgZm9yIHdyYXBwZWQgdGV4dHVyZXMuXG4gICAgICogQHBhcmFtIGJiIC0gdGhlIG9yaWdpbmFsIGJvdW5kaW5nIGJveFxuICAgICAqIEBwYXJhbSBwYWRkaW5nIC0gdGhlIHBhZGRpbmcgdG8gYWRkIHRvIHRoZSBib3VuZGluZyBib3hcbiAgICAgKiBAcGFyYW0gZmlyc3QgLSB3aGV0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IHBhcnQgb2YgYSB3cmFwcGVkIHRleHR1cmVcbiAgICAgKiBAcGFyYW0gcmF0aW8gLSB0aGUgcmF0aW8gb2YgdGhlIHRleHR1cmUgd2lkdGggb2YgcGFydCBvZiB0aGUgdGV4dCB0byB0aGUgZW50aXJlIHRleHR1cmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWRqdXN0ZWRCQlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWRqdXN0ZWRCQihiYiwgcGFkZGluZywgZmlyc3QsIHJhdGlvKSB7XG4gICAgICB2YXIgeDEgPSBiYi54MSxcbiAgICAgICAgeTEgPSBiYi55MSxcbiAgICAgICAgdyA9IGJiLncsXG4gICAgICAgIGggPSBiYi5oLFxuICAgICAgICB5T2Zmc2V0ID0gYmIueU9mZnNldDtcbiAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgIHgxIC09IHBhZGRpbmc7XG4gICAgICAgIHkxIC09IHBhZGRpbmc7XG4gICAgICAgIHcgKz0gMiAqIHBhZGRpbmc7XG4gICAgICAgIGggKz0gMiAqIHBhZGRpbmc7XG4gICAgICB9XG4gICAgICB2YXIgeE9mZnNldCA9IDA7XG4gICAgICB2YXIgYWRqVyA9IHcgKiByYXRpbztcbiAgICAgIGlmIChmaXJzdCAmJiByYXRpbyA8IDEpIHtcbiAgICAgICAgdyA9IGFkalc7XG4gICAgICB9IGVsc2UgaWYgKCFmaXJzdCAmJiByYXRpbyA8IDEpIHtcbiAgICAgICAgeE9mZnNldCA9IHcgLSBhZGpXO1xuICAgICAgICB4MSArPSB4T2Zmc2V0O1xuICAgICAgICB3ID0gYWRqVztcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB3OiB3LFxuICAgICAgICBoOiBoLFxuICAgICAgICB4T2Zmc2V0OiB4T2Zmc2V0LFxuICAgICAgICB5T2Zmc2V0OiB5T2Zmc2V0XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBzb2xpZCBvcGFxdWUgcmVjdGFuZ2xlIG1hdGNoaW5nIHRoZSBlbGVtZW50J3MgQm91bmRpbmcgQm94LlxuICAgICAqIFVzZWQgYnkgdGhlIFBJQ0tJTkcgbW9kZSB0byBtYWtlIHRoZSBlbnRpcmUgQkIgb2YgYSBsYWJlbCBjbGlja2FibGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1BpY2tpbmdSZWN0YW5nbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BpY2tpbmdSZWN0YW5nbGUoZWxlLCBlbGVJbmRleCwgdHlwZSkge1xuICAgICAgdmFyIG9wdHMgPSB0aGlzLmF0bGFzTWFuYWdlci5nZXRSZW5kZXJUeXBlT3B0cyh0eXBlKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2VDb3VudDtcbiAgICAgIHRoaXMudmVydFR5cGVCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSlbMF0gPSBSRUNUQU5HTEU7XG4gICAgICB2YXIgaW5kZXhWaWV3ID0gdGhpcy5pbmRleEJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgIGluZGV4VG9WZWM0KGVsZUluZGV4LCBpbmRleFZpZXcpO1xuICAgICAgdmFyIGNvbG9yVmlldyA9IHRoaXMuY29sb3JCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICB0b1dlYkdMQ29sb3IoWzAsIDAsIDBdLCAxLCBjb2xvclZpZXcpOyAvLyBvcGFxdWUsIHNvIGVudGlyZSBsYWJlbCBCQiBpcyBjbGlja2FibGVcblxuICAgICAgdmFyIG1hdHJpeFZpZXcgPSB0aGlzLnRyYW5zZm9ybUJ1ZmZlci5nZXRNYXRyaXhWaWV3KGluc3RhbmNlKTtcbiAgICAgIHRoaXMuc2V0VHJhbnNmb3JtTWF0cml4KGVsZSwgbWF0cml4Vmlldywgb3B0cyk7XG4gICAgICB0aGlzLnNpbXBsZUNvdW50Kys7XG4gICAgICB0aGlzLmluc3RhbmNlQ291bnQrKztcbiAgICAgIGlmICh0aGlzLmluc3RhbmNlQ291bnQgPj0gdGhpcy5tYXhJbnN0YW5jZXMpIHtcbiAgICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXcgYSBub2RlIHVzaW5nIGVpdGhlciBhIHRleHR1cmUgb3IgYSBcInNpbXBsZSBzaGFwZVwiLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdOb2RlKG5vZGUsIGVsZUluZGV4LCB0eXBlKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMuc2ltcGxlU2hhcGVPcHRpb25zLmdldCh0eXBlKTtcbiAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKG5vZGUsIG9wdHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wcyA9IG9wdHMuc2hhcGVQcm9wcztcblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0byB1c2UgYSB0ZXh0dXJlXG4gICAgICB2YXIgdmVydFR5cGUgPSB0aGlzLl9nZXRWZXJ0VHlwZUZvclNoYXBlKG5vZGUsIHByb3BzLnNoYXBlKTtcbiAgICAgIGlmICh2ZXJ0VHlwZSA9PT0gdW5kZWZpbmVkIHx8IG9wdHMuaXNTaW1wbGUgJiYgIW9wdHMuaXNTaW1wbGUobm9kZSkpIHtcbiAgICAgICAgdGhpcy5kcmF3VGV4dHVyZShub2RlLCBlbGVJbmRleCwgdHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIGEgXCJzaW1wbGUgc2hhcGVcIiB1c2luZyBTREYgKHNpZ25lZCBkaXN0YW5jZSBmaWVsZHMpXG4gICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG4gICAgICB0aGlzLnZlcnRUeXBlQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpWzBdID0gdmVydFR5cGU7XG4gICAgICBpZiAodmVydFR5cGUgPT09IFJPVU5EX1JFQ1RBTkdMRSB8fCB2ZXJ0VHlwZSA9PT0gQk9UVE9NX1JPVU5EX1JFQ1RBTkdMRSkge1xuICAgICAgICAvLyBnZXQgY29ybmVyIHJhZGl1c1xuICAgICAgICB2YXIgYmIgPSBvcHRzLmdldEJvdW5kaW5nQm94KG5vZGUpO1xuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5fZ2V0Q29ybmVyUmFkaXVzKG5vZGUsIHByb3BzLnJhZGl1cywgYmIpO1xuICAgICAgICB2YXIgcmFkaXVzVmlldyA9IHRoaXMuY29ybmVyUmFkaXVzQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICByYWRpdXNWaWV3WzBdID0gcmFkaXVzOyAvLyB0b3AtcmlnaHRcbiAgICAgICAgcmFkaXVzVmlld1sxXSA9IHJhZGl1czsgLy8gYm90dG9tLXJpZ2h0XG4gICAgICAgIHJhZGl1c1ZpZXdbMl0gPSByYWRpdXM7IC8vIHRvcC1sZWZ0XG4gICAgICAgIHJhZGl1c1ZpZXdbM10gPSByYWRpdXM7IC8vIGJvdHRvbS1sZWZ0XG4gICAgICAgIGlmICh2ZXJ0VHlwZSA9PT0gQk9UVE9NX1JPVU5EX1JFQ1RBTkdMRSkge1xuICAgICAgICAgIHJhZGl1c1ZpZXdbMF0gPSAwO1xuICAgICAgICAgIHJhZGl1c1ZpZXdbMl0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXhWaWV3ID0gdGhpcy5pbmRleEJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgIGluZGV4VG9WZWM0KGVsZUluZGV4LCBpbmRleFZpZXcpO1xuICAgICAgdmFyIGNvbG9yID0gbm9kZS5wc3R5bGUocHJvcHMuY29sb3IpLnZhbHVlO1xuICAgICAgdmFyIG9wYWNpdHkgPSBub2RlLnBzdHlsZShwcm9wcy5vcGFjaXR5KS52YWx1ZTtcbiAgICAgIHZhciBjb2xvclZpZXcgPSB0aGlzLmNvbG9yQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgdG9XZWJHTENvbG9yKGNvbG9yLCBvcGFjaXR5LCBjb2xvclZpZXcpO1xuICAgICAgdmFyIGxpbmVXaWR0aFZpZXcgPSB0aGlzLmxpbmVXaWR0aEJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTsgLy8gcmV1c2UgZWRnZSBsaW5lIHdpZHRoIGF0dHJpYnV0ZSBmb3Igbm9kZSBib3JkZXJcbiAgICAgIGxpbmVXaWR0aFZpZXdbMF0gPSAwO1xuICAgICAgbGluZVdpZHRoVmlld1sxXSA9IDA7XG4gICAgICBpZiAocHJvcHMuYm9yZGVyKSB7XG4gICAgICAgIHZhciBib3JkZXJXaWR0aCA9IG5vZGUucHN0eWxlKCdib3JkZXItd2lkdGgnKS52YWx1ZTtcbiAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgIHZhciBib3JkZXJDb2xvciA9IG5vZGUucHN0eWxlKCdib3JkZXItY29sb3InKS52YWx1ZTtcbiAgICAgICAgICB2YXIgYm9yZGVyT3BhY2l0eSA9IG5vZGUucHN0eWxlKCdib3JkZXItb3BhY2l0eScpLnZhbHVlO1xuICAgICAgICAgIHZhciBib3JkZXJDb2xvclZpZXcgPSB0aGlzLmJvcmRlckNvbG9yQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICAgIHRvV2ViR0xDb2xvcihib3JkZXJDb2xvciwgYm9yZGVyT3BhY2l0eSwgYm9yZGVyQ29sb3JWaWV3KTtcblxuICAgICAgICAgIC8vIFNERiBkaXN0YW5jZSBpcyBuZWdhdGl2ZSBpbnNpZGUgdGhlIHNoYXBlIGFuZCBwb3NpdGl2ZSBvdXRzaWRlXG4gICAgICAgICAgdmFyIGJvcmRlclBvcyA9IG5vZGUucHN0eWxlKCdib3JkZXItcG9zaXRpb24nKS52YWx1ZTtcbiAgICAgICAgICBpZiAoYm9yZGVyUG9zID09PSAnaW5zaWRlJykge1xuICAgICAgICAgICAgbGluZVdpZHRoVmlld1swXSA9IDA7XG4gICAgICAgICAgICBsaW5lV2lkdGhWaWV3WzFdID0gLWJvcmRlcldpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYm9yZGVyUG9zID09PSAnb3V0c2lkZScpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aFZpZXdbMF0gPSBib3JkZXJXaWR0aDtcbiAgICAgICAgICAgIGxpbmVXaWR0aFZpZXdbMV0gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAnY2VudGVyJ1xuICAgICAgICAgICAgdmFyIGhhbGZXaWR0aCA9IGJvcmRlcldpZHRoIC8gMjtcbiAgICAgICAgICAgIGxpbmVXaWR0aFZpZXdbMF0gPSBoYWxmV2lkdGg7XG4gICAgICAgICAgICBsaW5lV2lkdGhWaWV3WzFdID0gLWhhbGZXaWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtYXRyaXhWaWV3ID0gdGhpcy50cmFuc2Zvcm1CdWZmZXIuZ2V0TWF0cml4VmlldyhpbnN0YW5jZSk7XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybU1hdHJpeChub2RlLCBtYXRyaXhWaWV3LCBvcHRzKTtcbiAgICAgIHRoaXMuc2ltcGxlQ291bnQrKztcbiAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCsrO1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2VDb3VudCA+PSB0aGlzLm1heEluc3RhbmNlcykge1xuICAgICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWZXJ0VHlwZUZvclNoYXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWZXJ0VHlwZUZvclNoYXBlKG5vZGUsIHNoYXBlUHJvcCkge1xuICAgICAgdmFyIHNoYXBlID0gbm9kZS5wc3R5bGUoc2hhcGVQcm9wKS52YWx1ZTtcbiAgICAgIHN3aXRjaCAoc2hhcGUpIHtcbiAgICAgICAgY2FzZSAncmVjdGFuZ2xlJzpcbiAgICAgICAgICByZXR1cm4gUkVDVEFOR0xFO1xuICAgICAgICBjYXNlICdlbGxpcHNlJzpcbiAgICAgICAgICByZXR1cm4gRUxMSVBTRTtcbiAgICAgICAgY2FzZSAncm91bmRyZWN0YW5nbGUnOlxuICAgICAgICBjYXNlICdyb3VuZC1yZWN0YW5nbGUnOlxuICAgICAgICAgIHJldHVybiBST1VORF9SRUNUQU5HTEU7XG4gICAgICAgIGNhc2UgJ2JvdHRvbS1yb3VuZC1yZWN0YW5nbGUnOlxuICAgICAgICAgIHJldHVybiBCT1RUT01fUk9VTkRfUkVDVEFOR0xFO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDb3JuZXJSYWRpdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvcm5lclJhZGl1cyhub2RlLCByYWRpdXNQcm9wLCBfcmVmMikge1xuICAgICAgdmFyIHcgPSBfcmVmMi53LFxuICAgICAgICBoID0gX3JlZjIuaDtcbiAgICAgIC8vIHNlZSBDUnAuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aFxuICAgICAgaWYgKG5vZGUucHN0eWxlKHJhZGl1c1Byb3ApLnZhbHVlID09PSAnYXV0bycpIHtcbiAgICAgICAgcmV0dXJuIGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHcsIGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IG5vZGUucHN0eWxlKHJhZGl1c1Byb3ApLnBmVmFsdWU7XG4gICAgICAgIHZhciBoYWxmV2lkdGggPSB3IC8gMjtcbiAgICAgICAgdmFyIGhhbGZIZWlnaHQgPSBoIC8gMjtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHJhZGl1cywgaGFsZkhlaWdodCwgaGFsZldpZHRoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPbmx5IHN1cHBvcnRzIGRyYXdpbmcgdHJpYW5nbGVzIGF0IHRoZSBtb21lbnQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0VkZ2VBcnJvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3RWRnZUFycm93KGVkZ2UsIGVsZUluZGV4LCBwcmVmaXgpIHtcbiAgICAgIGlmICghZWRnZS52aXNpYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gRWRnZSBwb2ludHMgYW5kIGFycm93IGFuZ2xlcyBldGMgYXJlIGNhbGN1bGF0ZWQgYnkgdGhlIGJhc2UgcmVuZGVyZXIgYW5kIGNhY2hlZCBpbiB0aGUgcnNjcmF0Y2ggb2JqZWN0LlxuICAgICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciB4LCB5LCBhbmdsZTtcbiAgICAgIGlmIChwcmVmaXggPT09ICdzb3VyY2UnKSB7XG4gICAgICAgIHggPSBycy5hcnJvd1N0YXJ0WDtcbiAgICAgICAgeSA9IHJzLmFycm93U3RhcnRZO1xuICAgICAgICBhbmdsZSA9IHJzLnNyY0Fycm93QW5nbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gcnMuYXJyb3dFbmRYO1xuICAgICAgICB5ID0gcnMuYXJyb3dFbmRZO1xuICAgICAgICBhbmdsZSA9IHJzLnRndEFycm93QW5nbGU7XG4gICAgICB9XG5cbiAgICAgIC8vIHRha2VuIGZyb20gQ1JwLmRyYXdBcnJvd2hlYWRcbiAgICAgIGlmIChpc05hTih4KSB8fCB4ID09IG51bGwgfHwgaXNOYU4oeSkgfHwgeSA9PSBudWxsIHx8IGlzTmFOKGFuZ2xlKSB8fCBhbmdsZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgc2hhcGUgYWZ0ZXIgdGhlIHgveSBjaGVjayBiZWNhdXNlIHBzdHlsZSgpIGlzIGEgYml0IHNsb3dcbiAgICAgIHZhciBhcnJvd1NoYXBlID0gZWRnZS5wc3R5bGUocHJlZml4ICsgJy1hcnJvdy1zaGFwZScpLnZhbHVlO1xuICAgICAgaWYgKGFycm93U2hhcGUgPT09ICdub25lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY29sb3IgPSBlZGdlLnBzdHlsZShwcmVmaXggKyAnLWFycm93LWNvbG9yJykudmFsdWU7XG4gICAgICB2YXIgYmFzZU9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuICAgICAgdmFyIGxpbmVPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ2xpbmUtb3BhY2l0eScpLnZhbHVlO1xuICAgICAgdmFyIG9wYWNpdHkgPSBiYXNlT3BhY2l0eSAqIGxpbmVPcGFjaXR5O1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IGVkZ2UucHN0eWxlKCd3aWR0aCcpLnBmVmFsdWU7XG4gICAgICB2YXIgc2NhbGUkMSA9IGVkZ2UucHN0eWxlKCdhcnJvdy1zY2FsZScpLnZhbHVlO1xuICAgICAgdmFyIHNpemUgPSB0aGlzLnIuZ2V0QXJyb3dXaWR0aChsaW5lV2lkdGgsIHNjYWxlJDEpO1xuICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZUNvdW50O1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtQnVmZmVyLmdldE1hdHJpeFZpZXcoaW5zdGFuY2UpO1xuICAgICAgaWRlbnRpdHkodHJhbnNmb3JtKTtcbiAgICAgIHRyYW5zbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybSwgW3gsIHldKTtcbiAgICAgIHNjYWxlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBbc2l6ZSwgc2l6ZV0pO1xuICAgICAgcm90YXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBhbmdsZSk7XG4gICAgICB0aGlzLnZlcnRUeXBlQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpWzBdID0gRURHRV9BUlJPVztcbiAgICAgIHZhciBpbmRleFZpZXcgPSB0aGlzLmluZGV4QnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgaW5kZXhUb1ZlYzQoZWxlSW5kZXgsIGluZGV4Vmlldyk7XG4gICAgICB2YXIgY29sb3JWaWV3ID0gdGhpcy5jb2xvckJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgIHRvV2ViR0xDb2xvcihjb2xvciwgb3BhY2l0eSwgY29sb3JWaWV3KTtcbiAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCsrO1xuICAgICAgaWYgKHRoaXMuaW5zdGFuY2VDb3VudCA+PSB0aGlzLm1heEluc3RhbmNlcykge1xuICAgICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhdyBzdHJhaWdodC1saW5lIG9yIGJlemllciBjdXJ2ZSBlZGdlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3RWRnZUxpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0VkZ2VMaW5lKGVkZ2UsIGVsZUluZGV4KSB7XG4gICAgICBpZiAoIWVkZ2UudmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLl9nZXRFZGdlUG9pbnRzKGVkZ2UpO1xuICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBsaW5lIHN0eWxlXG4gICAgICB2YXIgYmFzZU9wYWNpdHkgPSBlZGdlLnBzdHlsZSgnb3BhY2l0eScpLnZhbHVlO1xuICAgICAgdmFyIGxpbmVPcGFjaXR5ID0gZWRnZS5wc3R5bGUoJ2xpbmUtb3BhY2l0eScpLnZhbHVlO1xuICAgICAgdmFyIHdpZHRoID0gZWRnZS5wc3R5bGUoJ3dpZHRoJykucGZWYWx1ZTtcbiAgICAgIHZhciBjb2xvciA9IGVkZ2UucHN0eWxlKCdsaW5lLWNvbG9yJykudmFsdWU7XG4gICAgICB2YXIgb3BhY2l0eSA9IGJhc2VPcGFjaXR5ICogbGluZU9wYWNpdHk7XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCAvIDIgKyB0aGlzLmluc3RhbmNlQ291bnQgPiB0aGlzLm1heEluc3RhbmNlcykge1xuICAgICAgICB0aGlzLmVuZEJhdGNoKCk7XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgIC8vIHN0cmFpZ2h0IGxpbmVcbiAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZUNvdW50O1xuICAgICAgICB0aGlzLnZlcnRUeXBlQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpWzBdID0gRURHRV9TVFJBSUdIVDtcbiAgICAgICAgdmFyIGluZGV4VmlldyA9IHRoaXMuaW5kZXhCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICAgIGluZGV4VG9WZWM0KGVsZUluZGV4LCBpbmRleFZpZXcpO1xuICAgICAgICB2YXIgY29sb3JWaWV3ID0gdGhpcy5jb2xvckJ1ZmZlci5nZXRWaWV3KGluc3RhbmNlKTtcbiAgICAgICAgdG9XZWJHTENvbG9yKGNvbG9yLCBvcGFjaXR5LCBjb2xvclZpZXcpO1xuICAgICAgICB2YXIgbGluZVdpZHRoQnVmZmVyID0gdGhpcy5saW5lV2lkdGhCdWZmZXIuZ2V0VmlldyhpbnN0YW5jZSk7XG4gICAgICAgIGxpbmVXaWR0aEJ1ZmZlclswXSA9IHdpZHRoO1xuICAgICAgICB2YXIgc291cmNlVGFyZ2V0VmlldyA9IHRoaXMucG9pbnRBUG9pbnRCQnVmZmVyLmdldFZpZXcoaW5zdGFuY2UpO1xuICAgICAgICBzb3VyY2VUYXJnZXRWaWV3WzBdID0gcG9pbnRzWzBdOyAvLyBzb3VyY2UgeFxuICAgICAgICBzb3VyY2VUYXJnZXRWaWV3WzFdID0gcG9pbnRzWzFdOyAvLyBzb3VyY2UgeVxuICAgICAgICBzb3VyY2VUYXJnZXRWaWV3WzJdID0gcG9pbnRzWzJdOyAvLyB0YXJnZXQgeFxuICAgICAgICBzb3VyY2VUYXJnZXRWaWV3WzNdID0gcG9pbnRzWzNdOyAvLyB0YXJnZXQgeVxuXG4gICAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZUNvdW50ID49IHRoaXMubWF4SW5zdGFuY2VzKSB7XG4gICAgICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjdXJ2ZWQgbGluZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAyOyBpICs9IDIpIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlID0gdGhpcy5pbnN0YW5jZUNvdW50O1xuICAgICAgICAgIHRoaXMudmVydFR5cGVCdWZmZXIuZ2V0VmlldyhfaW5zdGFuY2UpWzBdID0gRURHRV9DVVJWRV9TRUdNRU5UO1xuICAgICAgICAgIHZhciBfaW5kZXhWaWV3ID0gdGhpcy5pbmRleEJ1ZmZlci5nZXRWaWV3KF9pbnN0YW5jZSk7XG4gICAgICAgICAgaW5kZXhUb1ZlYzQoZWxlSW5kZXgsIF9pbmRleFZpZXcpO1xuICAgICAgICAgIHZhciBfY29sb3JWaWV3ID0gdGhpcy5jb2xvckJ1ZmZlci5nZXRWaWV3KF9pbnN0YW5jZSk7XG4gICAgICAgICAgdG9XZWJHTENvbG9yKGNvbG9yLCBvcGFjaXR5LCBfY29sb3JWaWV3KTtcbiAgICAgICAgICB2YXIgX2xpbmVXaWR0aEJ1ZmZlciA9IHRoaXMubGluZVdpZHRoQnVmZmVyLmdldFZpZXcoX2luc3RhbmNlKTtcbiAgICAgICAgICBfbGluZVdpZHRoQnVmZmVyWzBdID0gd2lkdGg7XG4gICAgICAgICAgdmFyIHBBeCA9IHBvaW50c1tpIC0gMl0sXG4gICAgICAgICAgICBwQXkgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgICAgIHZhciBwQnggPSBwb2ludHNbaV0sXG4gICAgICAgICAgICBwQnkgPSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgIHZhciBwQ3ggPSBwb2ludHNbaSArIDJdLFxuICAgICAgICAgICAgcEN5ID0gcG9pbnRzW2kgKyAzXTtcbiAgICAgICAgICB2YXIgcER4ID0gcG9pbnRzW2kgKyA0XSxcbiAgICAgICAgICAgIHBEeSA9IHBvaW50c1tpICsgNV07XG5cbiAgICAgICAgICAvLyBtYWtlIHBoYW50b20gcG9pbnRzIGZvciB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgICAgICAgICAvLyBUT0RPIGFkZGluZyAwLjAwMSB0byBhdm9pZCBkaXZpc2lvbiBieSB6ZXJvIGluIHRoZSBzaGFkZXIgKEkgdGhpbmspLCBuZWVkIGEgYmV0dGVyIHNvbHV0aW9uXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgICAgcEF4ID0gMiAqIHBCeCAtIHBDeCArIDAuMDAxO1xuICAgICAgICAgICAgcEF5ID0gMiAqIHBCeSAtIHBDeSArIDAuMDAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PSBwb2ludHMubGVuZ3RoIC0gNCkge1xuICAgICAgICAgICAgcER4ID0gMiAqIHBDeCAtIHBCeCArIDAuMDAxO1xuICAgICAgICAgICAgcER5ID0gMiAqIHBDeSAtIHBCeSArIDAuMDAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcG9pbnRBQlZpZXcgPSB0aGlzLnBvaW50QVBvaW50QkJ1ZmZlci5nZXRWaWV3KF9pbnN0YW5jZSk7XG4gICAgICAgICAgcG9pbnRBQlZpZXdbMF0gPSBwQXg7XG4gICAgICAgICAgcG9pbnRBQlZpZXdbMV0gPSBwQXk7XG4gICAgICAgICAgcG9pbnRBQlZpZXdbMl0gPSBwQng7XG4gICAgICAgICAgcG9pbnRBQlZpZXdbM10gPSBwQnk7XG4gICAgICAgICAgdmFyIHBvaW50Q0RWaWV3ID0gdGhpcy5wb2ludENQb2ludERCdWZmZXIuZ2V0VmlldyhfaW5zdGFuY2UpO1xuICAgICAgICAgIHBvaW50Q0RWaWV3WzBdID0gcEN4O1xuICAgICAgICAgIHBvaW50Q0RWaWV3WzFdID0gcEN5O1xuICAgICAgICAgIHBvaW50Q0RWaWV3WzJdID0gcER4O1xuICAgICAgICAgIHBvaW50Q0RWaWV3WzNdID0gcER5O1xuICAgICAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCsrO1xuICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlQ291bnQgPj0gdGhpcy5tYXhJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kQmF0Y2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVmFsaWRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1ZhbGlkRWRnZShlZGdlKSB7XG4gICAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgaWYgKHJzLmJhZExpbmUgfHwgcnMuYWxscHRzID09IG51bGwgfHwgaXNOYU4ocnMuYWxscHRzWzBdKSkge1xuICAgICAgICAvLyBpc05hTiBpbiBjYXNlIGVkZ2UgaXMgaW1wb3NzaWJsZSBhbmQgYnJvd3NlciBidWdzIChlLmcuIHNhZmFyaSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRFZGdlUG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFZGdlUG9pbnRzKGVkZ2UpIHtcbiAgICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICAgIC8vIGlmIGJlemllciBjdHJsIHB0cyBjYW4gbm90IGJlIGNhbGN1bGF0ZWQsIHRoZW4gZGllXG4gICAgICBpZiAoIXRoaXMuX2lzVmFsaWRFZGdlKGVkZ2UpKSB7XG4gICAgICAgIC8vIGlzTmFOIGluIGNhc2UgZWRnZSBpcyBpbXBvc3NpYmxlIGFuZCBicm93c2VyIGJ1Z3MgKGUuZy4gc2FmYXJpKVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY29udHJvbFBvaW50cyA9IHJzLmFsbHB0cztcbiAgICAgIGlmIChjb250cm9sUG9pbnRzLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgIHJldHVybiBjb250cm9sUG9pbnRzO1xuICAgICAgfVxuICAgICAgdmFyIG51bVNlZ21lbnRzID0gdGhpcy5fZ2V0TnVtU2VnbWVudHMoZWRnZSk7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q3VydmVTZWdtZW50UG9pbnRzKGNvbnRyb2xQb2ludHMsIG51bVNlZ21lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE51bVNlZ21lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXROdW1TZWdtZW50cyhlZGdlKSB7XG4gICAgICAvLyBUT0RPIE5lZWQgYSBoZXVyaXN0aWMgdGhhdCBkZWNpZGVzIGhvdyBtYW55IHNlZ21lbnRzIHRvIHVzZS4gRmFjdG9ycyB0byBjb25zaWRlcjpcbiAgICAgIC8vIC0gZWRnZSB3aWR0aC9sZW5ndGhcbiAgICAgIC8vIC0gZWRnZSBjdXJ2YXR1cmUgKHRoZSBtb3JlIHRoZSBjdXJ2YXR1cmUsIHRoZSBtb3JlIHNlZ21lbnRzKVxuICAgICAgLy8gLSB6b29tIGxldmVsIChtb3JlIHNlZ21lbnRzIHdoZW4gem9vbWVkIGluKVxuICAgICAgLy8gLSBudW1iZXIgb2YgdmlzaWJsZSBlZGdlcyAobW9yZSBzZWdtZW50cyB3aGVuIHRoZXJlIGFyZSBmZXdlciBlZGdlcylcbiAgICAgIC8vIC0gcGVyZm9ybWFuY2UgKGZld2VyIHNlZ21lbnRzIHdoZW4gcGVyZm9ybWFuY2UgaXMgYSBjb25jZXJuKVxuICAgICAgLy8gLSB1c2VyIGNvbmZpZ3VyYWJsZSBvcHRpb24ocylcbiAgICAgIC8vIG5vdGU6IG51bWJlciBvZiBzZWdtZW50cyBtdXN0IGJlIGxlc3MgdGhhbiB0aGUgbWF4IG51bWJlciBvZiBpbnN0YW5jZXNcbiAgICAgIC8vIG5vdGU6IHNlZ21lbnRzIGRvbid0IG5lZWQgdG8gYmUgZXZlbmx5IHNwYWNlZCBvdXQsIGl0IG1pZ2h0IG1ha2Ugc2Vuc2UgdG8gaGF2ZSBzaG9ydGVyIHNlZ21lbnRzIG5lYXJlciB0byB0aGUgY29udHJvbCBwb2ludHNcbiAgICAgIHZhciBudW1TZWdtZW50cyA9IDE1O1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG51bVNlZ21lbnRzLCA1KSwgdGhpcy5tYXhJbnN0YW5jZXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q3VydmVTZWdtZW50UG9pbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDdXJ2ZVNlZ21lbnRQb2ludHMoY29udHJvbFBvaW50cywgc2VnbWVudHMpIHtcbiAgICAgIGlmIChjb250cm9sUG9pbnRzLmxlbmd0aCA9PSA0KSB7XG4gICAgICAgIHJldHVybiBjb250cm9sUG9pbnRzOyAvLyBzdHJhaWdodCBsaW5lXG4gICAgICB9XG4gICAgICB2YXIgY3VydmVQb2ludHMgPSBBcnJheSgoc2VnbWVudHMgKyAxKSAqIDIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkrKykge1xuICAgICAgICAvLyB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgYW5kIGxhc3QgY29udHJvbCBwb2ludHNcbiAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgIGN1cnZlUG9pbnRzWzBdID0gY29udHJvbFBvaW50c1swXTtcbiAgICAgICAgICBjdXJ2ZVBvaW50c1sxXSA9IGNvbnRyb2xQb2ludHNbMV07XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PSBzZWdtZW50cykge1xuICAgICAgICAgIGN1cnZlUG9pbnRzW2kgKiAyXSA9IGNvbnRyb2xQb2ludHNbY29udHJvbFBvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgICBjdXJ2ZVBvaW50c1tpICogMiArIDFdID0gY29udHJvbFBvaW50c1tjb250cm9sUG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0ID0gaSAvIHNlZ21lbnRzOyAvLyBzZWdtZW50cyBoYXZlIGVxdWFsIGxlbmd0aCwgaXRzIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgdG8gZG8gaXQgdGhpcyB3YXlcbiAgICAgICAgICAvLyBwYXNzIGluIGN1cnZlUG9pbnRzIHRvIHNldCB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSBkaXJlY3RseVxuICAgICAgICAgIHRoaXMuX3NldEN1cnZlUG9pbnQoY29udHJvbFBvaW50cywgdCwgY3VydmVQb2ludHMsIGkgKiAyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnZlUG9pbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0Q3VydmVQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q3VydmVQb2ludChwb2ludHMsIHQsIGN1cnZlUG9pbnRzLCBjcGkpIHtcbiAgICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgY3VydmVQb2ludHNbY3BpXSA9IHBvaW50c1swXTtcbiAgICAgICAgY3VydmVQb2ludHNbY3BpICsgMV0gPSBwb2ludHNbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3cG9pbnRzID0gQXJyYXkocG9pbnRzLmxlbmd0aCAtIDIpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld3BvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIHZhciB4ID0gKDEgLSB0KSAqIHBvaW50c1tpXSArIHQgKiBwb2ludHNbaSArIDJdO1xuICAgICAgICAgIHZhciB5ID0gKDEgLSB0KSAqIHBvaW50c1tpICsgMV0gKyB0ICogcG9pbnRzW2kgKyAzXTtcbiAgICAgICAgICBuZXdwb2ludHNbaV0gPSB4O1xuICAgICAgICAgIG5ld3BvaW50c1tpICsgMV0gPSB5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXRDdXJ2ZVBvaW50KG5ld3BvaW50cywgdCwgY3VydmVQb2ludHMsIGNwaSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZEJhdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuZEJhdGNoKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy5nbCxcbiAgICAgICAgdmFvID0gdGhpcy52YW8sXG4gICAgICAgIHZlcnRleENvdW50ID0gdGhpcy52ZXJ0ZXhDb3VudCxcbiAgICAgICAgY291bnQgPSB0aGlzLmluc3RhbmNlQ291bnQ7XG4gICAgICBpZiAoY291bnQgPT09IDApIHJldHVybjtcbiAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5yZW5kZXJUYXJnZXQucGlja2luZyA/IHRoaXMucGlja2luZ1Byb2dyYW0gOiB0aGlzLnByb2dyYW07XG4gICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XG5cbiAgICAgIC8vIGJ1ZmZlciB0aGUgYXR0cmlidXRlIGRhdGFcbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5idWZmZXJzKSxcbiAgICAgICAgX3N0ZXAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYnVmZmVyID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIGJ1ZmZlci5idWZmZXJTdWJEYXRhKGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgICB2YXIgYXRsYXNlcyA9IHRoaXMuYmF0Y2hNYW5hZ2VyLmdldEF0bGFzZXMoKTtcbiAgICAgIC8vIG11c3QgYnVmZmVyIGJlZm9yZSBhY3RpdmF0aW5nIHRleHR1cmUgdW5pdHNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXRsYXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhdGxhc2VzW2ldLmJ1ZmZlcklmTmVlZGVkKGdsKTtcbiAgICAgIH1cbiAgICAgIC8vIEFjdGl2YXRlIGFsbCB0aGUgdGV4dHVyZSB1bml0cyB0aGF0IHdlIG5lZWRcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGF0bGFzZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgX2kyKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgYXRsYXNlc1tfaTJdLnRleHR1cmUpO1xuICAgICAgICBnbC51bmlmb3JtMWkocHJvZ3JhbS51VGV4dHVyZXNbX2kyXSwgX2kyKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSB1bmlmb3Jtc1xuICAgICAgZ2wudW5pZm9ybTFmKHByb2dyYW0udVpvb20sIGdldEVmZmVjdGl2ZVpvb20odGhpcy5yKSk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHByb2dyYW0udVBhblpvb21NYXRyaXgsIGZhbHNlLCB0aGlzLnBhblpvb21NYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybTFpKHByb2dyYW0udUF0bGFzU2l6ZSwgdGhpcy5iYXRjaE1hbmFnZXIuZ2V0QXRsYXNTaXplKCkpO1xuICAgICAgLy8gc2V0IGJhY2tncm91bmQgY29sb3IsIG5lZWRlZCBmb3IgZWRnZSBhcnJvdyBjb2xvciBibGVuZGluZ1xuICAgICAgdmFyIHdlYmdsQmdDb2xvciA9IHRvV2ViR0xDb2xvcih0aGlzLmJnQ29sb3IsIDEpO1xuICAgICAgZ2wudW5pZm9ybTRmdihwcm9ncmFtLnVCR0NvbG9yLCB3ZWJnbEJnQ29sb3IpO1xuXG4gICAgICAvLyBkcmF3IVxuICAgICAgZ2wuZHJhd0FycmF5c0luc3RhbmNlZChnbC5UUklBTkdMRVMsIDAsIHZlcnRleENvdW50LCBjb3VudCk7XG4gICAgICBnbC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgLy8gVE9ETyBpcyB0aGlzIHJpZ2h0IHdoZW4gaGF2aW5nIG11bHRpcGxlIHRleHR1cmUgdW5pdHM/XG5cbiAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgIHRoaXMuYmF0Y2hEZWJ1Z0luZm8ucHVzaCh7XG4gICAgICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgICAgIC8vIGluc3RhbmNlIGNvdW50XG4gICAgICAgICAgYXRsYXNDb3VudDogYXRsYXNlcy5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0YXJ0IHRoZSBuZXh0IGJhdGNoLCBldmVuIGlmIG5vdCBuZWVkZWRcbiAgICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZWJ1Z0luZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVidWdJbmZvKCkge1xuICAgICAgdmFyIGF0bGFzSW5mbyA9IHRoaXMuYXRsYXNNYW5hZ2VyLmdldERlYnVnSW5mbygpO1xuICAgICAgdmFyIHRvdGFsQXRsYXNlcyA9IGF0bGFzSW5mby5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBpbmZvKSB7XG4gICAgICAgIHJldHVybiBjb3VudCArIGluZm8uYXRsYXNDb3VudDtcbiAgICAgIH0sIDApO1xuICAgICAgdmFyIGJhdGNoSW5mbyA9IHRoaXMuYmF0Y2hEZWJ1Z0luZm87XG4gICAgICB2YXIgdG90YWxJbnN0YW5jZXMgPSBiYXRjaEluZm8ucmVkdWNlKGZ1bmN0aW9uIChjb3VudCwgaW5mbykge1xuICAgICAgICByZXR1cm4gY291bnQgKyBpbmZvLmNvdW50O1xuICAgICAgfSwgMCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhdGxhc0luZm86IGF0bGFzSW5mbyxcbiAgICAgICAgdG90YWxBdGxhc2VzOiB0b3RhbEF0bGFzZXMsXG4gICAgICAgIHdyYXBwZWRDb3VudDogdGhpcy53cmFwcGVkQ291bnQsXG4gICAgICAgIHNpbXBsZUNvdW50OiB0aGlzLnNpbXBsZUNvdW50LFxuICAgICAgICBiYXRjaENvdW50OiBiYXRjaEluZm8ubGVuZ3RoLFxuICAgICAgICBiYXRjaEluZm86IGJhdGNoSW5mbyxcbiAgICAgICAgdG90YWxJbnN0YW5jZXM6IHRvdGFsSW5zdGFuY2VzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgQ1JwJDQgPSB7fTtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBXZWJHTCByZW5kZXJpbmcgbW9kZSBhZnRlciB0aGUgQ2FudmFzIHJlbmRlcmVyIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICovXG5DUnAkNC5pbml0V2ViZ2wgPSBmdW5jdGlvbiAob3B0cywgZm5zKSB7XG4gIHZhciByID0gdGhpcztcbiAgdmFyIGdsID0gci5kYXRhLmNvbnRleHRzW3IuV0VCR0xdO1xuXG4gIC8vIFNldCBkZWZhdWx0cyBhbmQgbGltaXRzIGZvciBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gIG9wdHMuYmdDb2xvciA9IGdldEJHQ29sb3Iocik7XG4gIG9wdHMud2ViZ2xUZXhTaXplID0gTWF0aC5taW4ob3B0cy53ZWJnbFRleFNpemUsIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKSk7XG4gIG9wdHMud2ViZ2xUZXhSb3dzID0gTWF0aC5taW4ob3B0cy53ZWJnbFRleFJvd3MsIDU0KTtcbiAgb3B0cy53ZWJnbFRleFJvd3NOb2RlcyA9IE1hdGgubWluKG9wdHMud2ViZ2xUZXhSb3dzTm9kZXMsIDU0KTtcbiAgb3B0cy53ZWJnbEJhdGNoU2l6ZSA9IE1hdGgubWluKG9wdHMud2ViZ2xCYXRjaFNpemUsIDE2Mzg0KTtcbiAgb3B0cy53ZWJnbFRleFBlckJhdGNoID0gTWF0aC5taW4ob3B0cy53ZWJnbFRleFBlckJhdGNoLCBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpKTtcblxuICAvLyBUdXJuIGRlYnVnIG1vZGUgb24gb3Igb2ZmLlxuICByLndlYmdsRGVidWcgPSBvcHRzLndlYmdsRGVidWc7XG4gIHIud2ViZ2xEZWJ1Z1Nob3dBdGxhc2VzID0gb3B0cy53ZWJnbERlYnVnU2hvd0F0bGFzZXM7XG5cbiAgLy8gQ3JlYXRlIG9mZnNjcmVlbiBmcmFtZWJ1ZmZlciB0aGF0IHN0b3JlcyB0aGUgcmVzdWx0cyB3aGVuIFJFTkRFUl9UQVJHRVQuUElDS0lORyBpcyBlbmFibGVkLlxuICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIHRvcG1vc3QgZWxlbWVudCB6LWluZGV4IGZvciBlYWNoIHBpeGVsLCB3aGljaCBpcyB1c2VkIHRvIHRlbGwgd2hhdHMgdW5kZXIgdGhlIG1vdXNlIGN1cnNvciBwb2ludC5cbiAgci5waWNraW5nRnJhbWVCdWZmZXIgPSBjcmVhdGVQaWNraW5nRnJhbWVCdWZmZXIoZ2wpO1xuICByLnBpY2tpbmdGcmFtZUJ1ZmZlci5uZWVkc0RyYXcgPSB0cnVlO1xuXG4gIC8vIENyZWF0ZSBhbiBFbGVtZW50RHJhd2luZ1dlYkdMIGluc3RhbmNlIHdpY2ggaXMgdXNlZCB0byBkbyB0aGUgYWN0dWFsIFdlYkdMIHJlbmRlcmluZy5cbiAgLy8gVGhpcyBpbnN0YW5jZSBuZWVkcyB0byBiZSBjb25maWd1cmVkIHRvIGRyYXcgdmFyaW91cyB0eXBlcyBvZiBlbGVtZW50cy5cbiAgci5kcmF3aW5nID0gbmV3IEVsZW1lbnREcmF3aW5nV2ViR0wociwgZ2wsIG9wdHMpO1xuXG4gIC8vIFNvbWUgZnVuY3Rpb25zIHRoYXQgYXJlIHVzZWQgdG8gY29uZmlndXJlIEVsZW1lbnREcmF3aW5nV2ViR0xcbiAgdmFyIGdldExhYmVsUm90YXRpb24gPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZSkge1xuICAgICAgcmV0dXJuIHIuZ2V0VGV4dEFuZ2xlKGVsZSwgcHJvcCk7XG4gICAgfTtcbiAgfTtcbiAgdmFyIGlzTGFiZWxWaXNpYmxlID0gZnVuY3Rpb24gaXNMYWJlbFZpc2libGUocHJvcCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlKSB7XG4gICAgICB2YXIgbGFiZWwgPSBlbGUucHN0eWxlKHByb3ApO1xuICAgICAgcmV0dXJuIGxhYmVsICYmIGxhYmVsLnZhbHVlO1xuICAgIH07XG4gIH07XG4gIHZhciBpc0xheWVyVmlzaWJsZSA9IGZ1bmN0aW9uIGlzTGF5ZXJWaXNpYmxlKHByZWZpeCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgLy8gcHJlZml4IGlzICdvdmVybGF5JyBvciAndW5kZXJsYXknXG4gICAgICByZXR1cm4gbm9kZS5wc3R5bGUoXCJcIi5jb25jYXQocHJlZml4LCBcIi1vcGFjaXR5XCIpKS52YWx1ZSA+IDA7XG4gICAgfTtcbiAgfTtcbiAgdmFyIGdldFRleFBpY2tpbmdNb2RlID0gZnVuY3Rpb24gZ2V0VGV4UGlja2luZ01vZGUoZWxlKSB7XG4gICAgLy8gdGVsbHMgd2hlbiBhIGxhYmVsIHNob3VsZCBiZSBjbGlja2FibGVcbiAgICB2YXIgZW5hYmxlZCA9IGVsZS5wc3R5bGUoJ3RleHQtZXZlbnRzJykuc3RyVmFsdWUgPT09ICd5ZXMnO1xuICAgIHJldHVybiBlbmFibGVkID8gVEVYX1BJQ0tJTkdfTU9ERS5VU0VfQkIgOiBURVhfUElDS0lOR19NT0RFLklHTk9SRTtcbiAgfTtcbiAgdmFyIGdldEJCRm9yU2ltcGxlU2hhcGUgPSBmdW5jdGlvbiBnZXRCQkZvclNpbXBsZVNoYXBlKG5vZGUpIHtcbiAgICAvLyBcInNpbXBsZVwiIHNoYXBlcyBuZWVkIHRoZWlyIEJCIHRvIGluY2x1ZGUgYm9yZGVyIGFuZCBwYWRkaW5nXG4gICAgdmFyIF9ub2RlJHBvc2l0aW9uID0gbm9kZS5wb3NpdGlvbigpLFxuICAgICAgeCA9IF9ub2RlJHBvc2l0aW9uLngsXG4gICAgICB5ID0gX25vZGUkcG9zaXRpb24ueTtcbiAgICB2YXIgdyA9IG5vZGUub3V0ZXJXaWR0aCgpOyAvLyBpbmNsdWRlcyBib3JkZXIgYW5kIHBhZGRpbmdcbiAgICB2YXIgaCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdzogdyxcbiAgICAgIGg6IGgsXG4gICAgICB4MTogeCAtIHcgLyAyLFxuICAgICAgeTE6IHkgLSBoIC8gMlxuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gQXRsYXNDb2xsZWN0aW9uIGlzIGEgY29sbGVjdGlvbiBvZiBBdGxhc2VzIHRoYXQgaGF2ZSB0aGUgc2FtZSBjb25maWd1cmFpdG9uIG9wdGlvbnMuXG4gIC8vIENyZWF0ZSBvbmUgZm9yIG5vZGUgYm9kaWVzIGFuZCBvbmUgZm9yIGFsbCB0eXBlcyBvZiBsYWJlbHMuXG4gIHIuZHJhd2luZy5hZGRBdGxhc0NvbGxlY3Rpb24oJ25vZGUnLCB7XG4gICAgdGV4Um93czogb3B0cy53ZWJnbFRleFJvd3NOb2Rlc1xuICB9KTtcbiAgci5kcmF3aW5nLmFkZEF0bGFzQ29sbGVjdGlvbignbGFiZWwnLCB7XG4gICAgdGV4Um93czogb3B0cy53ZWJnbFRleFJvd3NcbiAgfSk7XG5cbiAgLy8gQ29uZmlndXJlIHRoZSBkaWZmZXJlbnQgdHlwZXMgb2YgZWxlbWVudHMgdGhhdCBjYW4gYmUgcmVuZGVyZWQuXG5cbiAgLy8gTm9kZSBib2RpZXMgY2FuIGJlIHJlbmRlcmVkIGFzIHRleHR1cmVzIG9yIGFzIFwic2ltcGxlIHNoYXBlc1wiLiBcbiAgLy8gU2ltcGxlIHNoYXBlcyBhcmUgcHJlZmVycmVkIGJlY2F1c2UgdGhleSBkbyBub3QgdXNlIHRleHR1cmUgbWVtb3J5LlxuICAvLyBUZXh0dXJlcyBhcmUgcmVxdWlyZWQgaWYgdGhlIG5vZGUgYm9keSB1c2VzIGNvbXBsZXggc3R5bGVzLiBcbiAgci5kcmF3aW5nLmFkZFRleHR1cmVBdGxhc1JlbmRlclR5cGUoJ25vZGUtYm9keScsIHtcbiAgICBjb2xsZWN0aW9uOiAnbm9kZScsXG4gICAgZ2V0S2V5OiBmbnMuZ2V0U3R5bGVLZXksXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZucy5nZXRFbGVtZW50Qm94LFxuICAgIGRyYXdFbGVtZW50OiBmbnMuZHJhd0VsZW1lbnRcbiAgfSk7XG4gIHIuZHJhd2luZy5hZGRTaW1wbGVTaGFwZVJlbmRlclR5cGUoJ25vZGUtYm9keScsIHtcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0QkJGb3JTaW1wbGVTaGFwZSxcbiAgICBpc1NpbXBsZTogaXNTaW1wbGVTaGFwZSxcbiAgICBzaGFwZVByb3BzOiB7XG4gICAgICBzaGFwZTogJ3NoYXBlJyxcbiAgICAgIGNvbG9yOiAnYmFja2dyb3VuZC1jb2xvcicsXG4gICAgICBvcGFjaXR5OiAnYmFja2dyb3VuZC1vcGFjaXR5JyxcbiAgICAgIHJhZGl1czogJ2Nvcm5lci1yYWRpdXMnLFxuICAgICAgYm9yZGVyOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgci5kcmF3aW5nLmFkZFNpbXBsZVNoYXBlUmVuZGVyVHlwZSgnbm9kZS1vdmVybGF5Jywge1xuICAgIGdldEJvdW5kaW5nQm94OiBnZXRCQkZvclNpbXBsZVNoYXBlLFxuICAgIGlzVmlzaWJsZTogaXNMYXllclZpc2libGUoJ292ZXJsYXknKSxcbiAgICBzaGFwZVByb3BzOiB7XG4gICAgICBzaGFwZTogJ292ZXJsYXktc2hhcGUnLFxuICAgICAgY29sb3I6ICdvdmVybGF5LWNvbG9yJyxcbiAgICAgIG9wYWNpdHk6ICdvdmVybGF5LW9wYWNpdHknLFxuICAgICAgcGFkZGluZzogJ292ZXJsYXktcGFkZGluZycsXG4gICAgICByYWRpdXM6ICdvdmVybGF5LWNvcm5lci1yYWRpdXMnXG4gICAgfVxuICB9KTtcbiAgci5kcmF3aW5nLmFkZFNpbXBsZVNoYXBlUmVuZGVyVHlwZSgnbm9kZS11bmRlcmxheScsIHtcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0QkJGb3JTaW1wbGVTaGFwZSxcbiAgICBpc1Zpc2libGU6IGlzTGF5ZXJWaXNpYmxlKCd1bmRlcmxheScpLFxuICAgIHNoYXBlUHJvcHM6IHtcbiAgICAgIHNoYXBlOiAndW5kZXJsYXktc2hhcGUnLFxuICAgICAgY29sb3I6ICd1bmRlcmxheS1jb2xvcicsXG4gICAgICBvcGFjaXR5OiAndW5kZXJsYXktb3BhY2l0eScsXG4gICAgICBwYWRkaW5nOiAndW5kZXJsYXktcGFkZGluZycsXG4gICAgICByYWRpdXM6ICd1bmRlcmxheS1jb3JuZXItcmFkaXVzJ1xuICAgIH1cbiAgfSk7XG4gIHIuZHJhd2luZy5hZGRUZXh0dXJlQXRsYXNSZW5kZXJUeXBlKCdsYWJlbCcsIHtcbiAgICAvLyBub2RlIGxhYmVsIG9yIGVkZ2UgbWlkIGxhYmVsXG4gICAgY29sbGVjdGlvbjogJ2xhYmVsJyxcbiAgICBnZXRUZXhQaWNraW5nTW9kZTogZ2V0VGV4UGlja2luZ01vZGUsXG4gICAgZ2V0S2V5OiBnZXRTdHlsZUtleXNGb3JMYWJlbChmbnMuZ2V0TGFiZWxLZXksIG51bGwpLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRCb3VuZGluZ0JveEZvckxhYmVsKGZucy5nZXRMYWJlbEJveCwgbnVsbCksXG4gICAgZHJhd0NsaXBwZWQ6IHRydWUsXG4gICAgZHJhd0VsZW1lbnQ6IGZucy5kcmF3TGFiZWwsXG4gICAgZ2V0Um90YXRpb246IGdldExhYmVsUm90YXRpb24obnVsbCksXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZm5zLmdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZm5zLmdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZSgnbGFiZWwnKVxuICB9KTtcbiAgci5kcmF3aW5nLmFkZFRleHR1cmVBdGxhc1JlbmRlclR5cGUoJ2VkZ2Utc291cmNlLWxhYmVsJywge1xuICAgIGNvbGxlY3Rpb246ICdsYWJlbCcsXG4gICAgZ2V0VGV4UGlja2luZ01vZGU6IGdldFRleFBpY2tpbmdNb2RlLFxuICAgIGdldEtleTogZ2V0U3R5bGVLZXlzRm9yTGFiZWwoZm5zLmdldFNvdXJjZUxhYmVsS2V5LCAnc291cmNlJyksXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldEJvdW5kaW5nQm94Rm9yTGFiZWwoZm5zLmdldFNvdXJjZUxhYmVsQm94LCAnc291cmNlJyksXG4gICAgZHJhd0NsaXBwZWQ6IHRydWUsXG4gICAgZHJhd0VsZW1lbnQ6IGZucy5kcmF3U291cmNlTGFiZWwsXG4gICAgZ2V0Um90YXRpb246IGdldExhYmVsUm90YXRpb24oJ3NvdXJjZScpLFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGZucy5nZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGZucy5nZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGUoJ3NvdXJjZS1sYWJlbCcpXG4gIH0pO1xuICByLmRyYXdpbmcuYWRkVGV4dHVyZUF0bGFzUmVuZGVyVHlwZSgnZWRnZS10YXJnZXQtbGFiZWwnLCB7XG4gICAgY29sbGVjdGlvbjogJ2xhYmVsJyxcbiAgICBnZXRUZXhQaWNraW5nTW9kZTogZ2V0VGV4UGlja2luZ01vZGUsXG4gICAgZ2V0S2V5OiBnZXRTdHlsZUtleXNGb3JMYWJlbChmbnMuZ2V0VGFyZ2V0TGFiZWxLZXksICd0YXJnZXQnKSxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0Qm91bmRpbmdCb3hGb3JMYWJlbChmbnMuZ2V0VGFyZ2V0TGFiZWxCb3gsICd0YXJnZXQnKSxcbiAgICBkcmF3Q2xpcHBlZDogdHJ1ZSxcbiAgICBkcmF3RWxlbWVudDogZm5zLmRyYXdUYXJnZXRMYWJlbCxcbiAgICBnZXRSb3RhdGlvbjogZ2V0TGFiZWxSb3RhdGlvbigndGFyZ2V0JyksXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZm5zLmdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZm5zLmdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZSgndGFyZ2V0LWxhYmVsJylcbiAgfSk7XG5cbiAgLy8gVmVyeSBzaW1wbGlzdGljIHdheSBvZiB0cmlnZ2VyaW5nIGdhcmJhZ2UgY29sbGVjdGlvbiwganVzdCB1c2UgYSB0aW1lci5cbiAgdmFyIHNldEdDRmxhZyA9IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZygnZ2FyYmFnZSBjb2xsZWN0IGZsYWcgc2V0Jyk7XG4gICAgci5kYXRhLmdjID0gdHJ1ZTtcbiAgfSwgMTAwMDApO1xuXG4gIC8vIEV2ZW50IGxpc3RlbmVyIGNoZWNrcyBpZiBzdHlsZSBrZXlzIGFyZSBubyBsb25nZXIgaW4gdXNlLlxuICByLm9uVXBkYXRlRWxlQ2FsY3MoZnVuY3Rpb24gKHdpbGxEcmF3LCBlbGVzKSB7XG4gICAgdmFyIGdjTmVlZGVkID0gZmFsc2U7XG4gICAgaWYgKGVsZXMgJiYgZWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICBnY05lZWRlZCB8PSByLmRyYXdpbmcuaW52YWxpZGF0ZShlbGVzKTtcbiAgICB9XG4gICAgaWYgKGdjTmVlZGVkKSB7XG4gICAgICBzZXRHQ0ZsYWcoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFwiT3ZlcnJpZGVcIiBjZXJ0YWluIGZ1bmN0aW9ucyBpbiBjYW52YXMgYW5kIGJhc2UgcmVuZGVyZXJcbiAgb3ZlcnJpZGVDYW52YXNSZW5kZXJlckZ1bmN0aW9ucyhyKTtcbn07XG5mdW5jdGlvbiBnZXRCR0NvbG9yKHIpIHtcbiAgdmFyIGNvbnRhaW5lciA9IHIuY3kuY29udGFpbmVyKCk7XG4gIHZhciBjc3NDb2xvciA9IGNvbnRhaW5lciAmJiBjb250YWluZXIuc3R5bGUgJiYgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmRDb2xvciB8fCAnd2hpdGUnO1xuICByZXR1cm4gY29sb3IydHVwbGUoY3NzQ29sb3IpO1xufVxuZnVuY3Rpb24gZ2V0TGFiZWxMaW5lcyhlbGUsIHByZWZpeCkge1xuICB2YXIgcnMgPSBlbGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gIHJldHVybiBnZXRQcmVmaXhlZFByb3BlcnR5KHJzLCAnbGFiZWxXcmFwQ2FjaGVkTGluZXMnLCBwcmVmaXgpIHx8IFtdO1xufVxuXG4vKiogXG4gKiBIYW5kbGUgbXVsdGktbGluZSBsYWJlbHMgYnkgcmVuZGVyaW5nIGVhY2ggbGluZSBhcyBhIHNlcGVyYXRlIHRleHR1cmUuXG4gKiBUaGF0IG1lYW5zIGVhY2ggbGluZSBuZWVkcyBpdHMgb3duIHN0eWxlIGtleS5cbiAqL1xudmFyIGdldFN0eWxlS2V5c0ZvckxhYmVsID0gZnVuY3Rpb24gZ2V0U3R5bGVLZXlzRm9yTGFiZWwoZ2V0S2V5LCBwcmVmaXgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5KGVsZSk7XG4gICAgdmFyIGxpbmVzID0gZ2V0TGFiZWxMaW5lcyhlbGUsIHByZWZpeCk7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiBsaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChrZXksIFwiX1wiKS5jb25jYXQoaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH07XG59O1xuXG4vKipcbiAqIE5lZWQgdG8gY3JlYXRlIGEgc2VwYXJhdGUgYm91bmRpbmcgYm94IGZvciBlYWNoIGxpbmUgb2YgYSBtdWx0aS1saW5lIGxhYmVsLlxuICogTm90ZSB0aGF0ICdkcmF3Q2xpcHBlZDogdHJ1ZScgc2hvdWxkIGJlIHVzZWQgd2l0aCB0aGlzLlxuICovXG52YXIgZ2V0Qm91bmRpbmdCb3hGb3JMYWJlbCA9IGZ1bmN0aW9uIGdldEJvdW5kaW5nQm94Rm9yTGFiZWwoZ2V0Qm91bmRpbmdCb3gsIHByZWZpeCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGVsZSwgc3R5bGVLZXkpIHtcbiAgICB2YXIgYmIgPSBnZXRCb3VuZGluZ0JveChlbGUpO1xuICAgIGlmICh0eXBlb2Ygc3R5bGVLZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgdWkgPSBzdHlsZUtleS5pbmRleE9mKCdfJyk7XG4gICAgICBpZiAodWkgPiAwKSB7XG4gICAgICAgIHZhciBsaW5lSW5kZXggPSBOdW1iZXIoc3R5bGVLZXkuc3Vic3RyaW5nKHVpICsgMSkpO1xuICAgICAgICB2YXIgbGluZXMgPSBnZXRMYWJlbExpbmVzKGVsZSwgcHJlZml4KTtcbiAgICAgICAgLy8gQWRqdXN0IHRoZSBoZWlnaHQgYW5kIFkgY29vcmRpbmF0ZSBmb3Igb25lIGxpbmUgb2YgdGhlIGxhYmVsLlxuICAgICAgICB2YXIgaCA9IGJiLmggLyBsaW5lcy5sZW5ndGg7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gaCAqIGxpbmVJbmRleDtcbiAgICAgICAgdmFyIHkxID0gYmIueTEgKyB5T2Zmc2V0O1xuICAgICAgICAvLyB0aGUgeU9mZnNldCBpcyBuZWVkZWQgd2hlbiByb3RhdGluZyB0aGUgbGFiZWxcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4MTogYmIueDEsXG4gICAgICAgICAgdzogYmIudyxcbiAgICAgICAgICB5MTogeTEsXG4gICAgICAgICAgaDogaCxcbiAgICAgICAgICB5T2Zmc2V0OiB5T2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYjtcbiAgfTtcbn07XG5cbi8qKlxuICogUGx1ZyBpbnRvIHRoZSBjYW52YXMgcmVuZGVyZXIgYnkgZHluYW1pY2FsbHkgb3ZlcnJpZGluZyBzb21lIG9mIGl0cyBmdW5jdGlvbnMuXG4gKiBUaGlzIHJlcXVpcmVzIG1pbmltYWwgY2hhbmdlcyB0byB0aGUgY2FudmFzIHJlbmRyZXJlci5cbiAqL1xuZnVuY3Rpb24gb3ZlcnJpZGVDYW52YXNSZW5kZXJlckZ1bmN0aW9ucyhyKSB7XG4gIHtcbiAgICAvLyBPdmVycmlkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIHRvIGNhbGwgdGhlIHdlYmdsIHJlbmRlciBmdW5jdGlvbiBpZiB0aGUgem9vbSBsZXZlbCBpcyBhcHByb3ByaWF0ZVxuICAgIHZhciByZW5kZXJDYW52YXMgPSByLnJlbmRlcjtcbiAgICByLnJlbmRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBjeSA9IHIuY3k7XG4gICAgICBpZiAoci53ZWJnbCkge1xuICAgICAgICAvLyBJZiB0aGUgem9vbSBsZXZlbCBpcyBncmVhdGVyIHRoYW4gdGhlIG1heCB6b29tIGxldmVsLCB0aGVuIGRpc2FibGUgd2ViZ2wgYW5kIHN3aXRjaCBiYWNrIHRvIFxuICAgICAgICAvLyB0aGUgY2FudmFzIHJlbmRlcmVyLlxuICAgICAgICBpZiAoY3kuem9vbSgpID4gbWF4Wm9vbSQxKSB7XG4gICAgICAgICAgY2xlYXJXZWJnbChyKTtcbiAgICAgICAgICByZW5kZXJDYW52YXMuY2FsbChyLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhckNhbnZhcyhyKTtcbiAgICAgICAgICByZW5kZXJXZWJnbChyLCBvcHRpb25zLCBSRU5ERVJfVEFSR0VULlNDUkVFTik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHtcbiAgICAvLyBPdmVycmlkZSB0aGUgbWF0Y2hDYW52YXNTaXplIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgcGlja2luZyBmcmFtZSBidWZmZXIgc2l6ZVxuICAgIHZhciBiYXNlRnVuYyA9IHIubWF0Y2hDYW52YXNTaXplO1xuICAgIHIubWF0Y2hDYW52YXNTaXplID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgYmFzZUZ1bmMuY2FsbChyLCBjb250YWluZXIpO1xuICAgICAgci5waWNraW5nRnJhbWVCdWZmZXIuc2V0RnJhbWVidWZmZXJBdHRhY2htZW50U2l6ZXMoci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgci5waWNraW5nRnJhbWVCdWZmZXIubmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICB9O1xuICB9XG4gIHtcbiAgICAvLyBPdmVycmlkZSBmdW5jdGlvbiB0byBjYWxsIHRoZSB3ZWJnbCB2ZXJzaW9uIGZvciBwaWNraW5nLlxuICAgIC8vIERvbid0IG92ZXJyaWRlIHIuZ2V0QWxsSW5Cb3goKSBzZWxjdGlvbiBib3ggcGlja2luZywgaXRzIG5vdCBhY2N1cmF0ZSBlbm91Z2ggd2l0aCB3ZWJnbFxuICAgIHIuZmluZE5lYXJlc3RFbGVtZW50cyA9IGZ1bmN0aW9uICh4LCB5LCBpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSwgaXNUb3VjaCkge1xuICAgICAgLy8gdGhlIGNhbnZhcyB2ZXJzaW9uIG9mIHRoaXMgZnVuY3Rpb24gaXMgdmVyeSBzbG93IG9uIGxhcmdlIGdyYXBoc1xuICAgICAgcmV0dXJuIGZpbmROZWFyZXN0RWxlbWVudHNXZWJnbChyLCB4LCB5KTtcbiAgICB9O1xuICB9XG4gIHtcbiAgICAvLyBuZWVkIHRvIGtub3cgd2hlbiB0aGUgY2FjaGVkIGVsZW1lbnRzIGhhdmUgY2hhbmdlZCBzbyB3ZSBjYW4gaW52YWxpZGF0ZSBvdXIgY2FjaGVzXG4gICAgdmFyIF9iYXNlRnVuYyA9IHIuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzO1xuICAgIHIuaW52YWxpZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgX2Jhc2VGdW5jLmNhbGwocik7XG4gICAgICByLnBpY2tpbmdGcmFtZUJ1ZmZlci5uZWVkc0RyYXcgPSB0cnVlO1xuICAgIH07XG4gIH1cbiAge1xuICAgIC8vIG5lZWQgdG8ga25vdyB3aGVuIHRoZSBjYWNoZWQgZWxlbWVudHMgaGF2ZSBjaGFuZ2VkIHNvIHdlIGNhbiBpbnZhbGlkYXRlIG91ciBjYWNoZXNcbiAgICB2YXIgX2Jhc2VGdW5jMiA9IHIubm90aWZ5O1xuICAgIHIubm90aWZ5ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgZWxlcykge1xuICAgICAgX2Jhc2VGdW5jMi5jYWxsKHIsIGV2ZW50TmFtZSwgZWxlcyk7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSAndmlld3BvcnQnIHx8IGV2ZW50TmFtZSA9PT0gJ2JvdW5kcycpIHtcbiAgICAgICAgci5waWNraW5nRnJhbWVCdWZmZXIubmVlZHNEcmF3ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnYmFja2dyb3VuZCcpIHtcbiAgICAgICAgLy8gYmFja2dyb3VuZCBpbWFnZSBmaW5pc2hlZCBsb2FkaW5nLCBuZWVkIHRvIHJlZHJhd1xuICAgICAgICByLmRyYXdpbmcuaW52YWxpZGF0ZShlbGVzLCB7XG4gICAgICAgICAgdHlwZTogJ25vZGUtYm9keSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJXZWJnbChyKSB7XG4gIHZhciBnbCA9IHIuZGF0YS5jb250ZXh0c1tyLldFQkdMXTtcbiAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xufVxuZnVuY3Rpb24gY2xlYXJDYW52YXMocikge1xuICAvLyB0aGUgQ1JwLmNsZWFyQ2FudmFzKCkgZnVuY3Rpb24gZG9lc24ndCB0YWtlIHRoZSB0cmFuc2Zvcm0gaW50byBhY2NvdW50XG4gIHZhciBjbGVhciA9IGZ1bmN0aW9uIGNsZWFyKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnNhdmUoKTtcbiAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gIH07XG4gIGNsZWFyKHIuZGF0YS5jb250ZXh0c1tyLk5PREVdKTtcbiAgY2xlYXIoci5kYXRhLmNvbnRleHRzW3IuRFJBR10pO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbU1hdHJpeChyKSB7XG4gIHZhciB3aWR0aCA9IHIuY2FudmFzV2lkdGg7XG4gIHZhciBoZWlnaHQgPSByLmNhbnZhc0hlaWdodDtcbiAgdmFyIF91dGlsJGdldEVmZmVjdGl2ZVBhbiA9IGdldEVmZmVjdGl2ZVBhblpvb20ociksXG4gICAgcGFuID0gX3V0aWwkZ2V0RWZmZWN0aXZlUGFuLnBhbixcbiAgICB6b29tID0gX3V0aWwkZ2V0RWZmZWN0aXZlUGFuLnpvb207XG4gIHZhciB0cmFuc2Zvcm0gPSBjcmVhdGUoKTtcbiAgdHJhbnNsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBbcGFuLngsIHBhbi55XSk7XG4gIHNjYWxlKHRyYW5zZm9ybSwgdHJhbnNmb3JtLCBbem9vbSwgem9vbV0pO1xuICB2YXIgcHJvamVjdGlvbiQxID0gY3JlYXRlKCk7XG4gIHByb2plY3Rpb24ocHJvamVjdGlvbiQxLCB3aWR0aCwgaGVpZ2h0KTtcbiAgdmFyIHByb2R1Y3QgPSBjcmVhdGUoKTtcbiAgbXVsdGlwbHkocHJvZHVjdCwgcHJvamVjdGlvbiQxLCB0cmFuc2Zvcm0pO1xuICByZXR1cm4gcHJvZHVjdDtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHRUcmFuc2Zvcm0ociwgY29udGV4dCkge1xuICB2YXIgd2lkdGggPSByLmNhbnZhc1dpZHRoO1xuICB2YXIgaGVpZ2h0ID0gci5jYW52YXNIZWlnaHQ7XG4gIHZhciBfdXRpbCRnZXRFZmZlY3RpdmVQYW4yID0gZ2V0RWZmZWN0aXZlUGFuWm9vbShyKSxcbiAgICBwYW4gPSBfdXRpbCRnZXRFZmZlY3RpdmVQYW4yLnBhbixcbiAgICB6b29tID0gX3V0aWwkZ2V0RWZmZWN0aXZlUGFuMi56b29tO1xuICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gIGNvbnRleHQudHJhbnNsYXRlKHBhbi54LCBwYW4ueSk7XG4gIGNvbnRleHQuc2NhbGUoem9vbSwgem9vbSk7XG59XG5mdW5jdGlvbiBkcmF3U2VsZWN0aW9uUmVjdGFuZ2xlKHIsIG9wdGlvbnMpIHtcbiAgci5kcmF3U2VsZWN0aW9uUmVjdGFuZ2xlKG9wdGlvbnMsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNldENvbnRleHRUcmFuc2Zvcm0ociwgY29udGV4dCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZHJhd0F4ZXMocikge1xuICAvLyBmb3IgZGViZ2dpbmdcbiAgdmFyIGNvbnRleHQgPSByLmRhdGEuY29udGV4dHNbci5OT0RFXTtcbiAgY29udGV4dC5zYXZlKCk7XG4gIHNldENvbnRleHRUcmFuc2Zvcm0ociwgY29udGV4dCk7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgwLCAwLCAwLCAwLjMpJztcbiAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgY29udGV4dC5tb3ZlVG8oLTFlMywgMCk7XG4gIGNvbnRleHQubGluZVRvKDEwMDAsIDApO1xuICBjb250ZXh0LnN0cm9rZSgpO1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICBjb250ZXh0Lm1vdmVUbygwLCAtMWUzKTtcbiAgY29udGV4dC5saW5lVG8oMCwgMTAwMCk7XG4gIGNvbnRleHQuc3Ryb2tlKCk7XG4gIGNvbnRleHQucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZHJhd0F0bGFzZXMocikge1xuICAvLyBGb3IgZGVidWdnaW5nIHRoZSBhdGxhc2VzLCB0aGlzIGRvZXNuJ3Qgd29yayBmb3IgQXRsYXNlcyB0aGF0IGFyZSBsb2NrZWRcbiAgdmFyIGRyYXcgPSBmdW5jdGlvbiBkcmF3KGRyYXdpbmcsIG5hbWUsIHJvdykge1xuICAgIHZhciBjb2xsZWN0aW9uID0gZHJhd2luZy5hdGxhc01hbmFnZXIuZ2V0QXRsYXNDb2xsZWN0aW9uKG5hbWUpO1xuICAgIHZhciBjb250ZXh0ID0gci5kYXRhLmNvbnRleHRzW3IuTk9ERV07XG4gICAgdmFyIGF0bGFzZXMgPSBjb2xsZWN0aW9uLmF0bGFzZXM7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGF0bGFzZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgYXRsYXMgPSBhdGxhc2VzW19pXTtcbiAgICAgIHZhciBjYW52YXMgPSBhdGxhcy5jYW52YXM7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIHZhciB3ID0gY2FudmFzLndpZHRoO1xuICAgICAgICB2YXIgaCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIHZhciB4ID0gdyAqIF9pO1xuICAgICAgICB2YXIgeSA9IGNhbnZhcy5oZWlnaHQgKiByb3c7XG4gICAgICAgIHZhciBzY2FsZSA9IDAuNDtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLCB4LCB5KTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgICAgIGNvbnRleHQucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgaSA9IDA7XG4gIGRyYXcoci5kcmF3aW5nLCAnbm9kZScsIGkrKyk7XG4gIGRyYXcoci5kcmF3aW5nLCAnbGFiZWwnLCBpKyspO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHotb3JkZXIgaW5kZXggb2YgZWxtZW50cyB1bmRlciBvciB2ZXJ5IGNsb3NlIHRvIHRoZSBtb3VzZSBjdXJzb3IgcG9pbnQuXG4gKiBBcmd1bWVudHMgYXJlIGluIG1vZGVsIGNvb3JkaW5hdGVzLlxuICogKHgxLCB5MSkgaXMgdG9wIGxlZnQgY29ybmVyXG4gKiAoeDIsIHkyKSBpcyBib3R0b20gcmlnaHQgY29ybmVyIChvcHRpb25hbClcbiAqIFJldHVybnMgYSBTZXQgb2YgaW5kZXhlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0UGlja2luZ0luZGV4ZXMociwgbVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIHZhciB4LCB5LCB3LCBoO1xuICB2YXIgX3V0aWwkZ2V0RWZmZWN0aXZlUGFuMyA9IGdldEVmZmVjdGl2ZVBhblpvb20ociksXG4gICAgcGFuID0gX3V0aWwkZ2V0RWZmZWN0aXZlUGFuMy5wYW4sXG4gICAgem9vbSA9IF91dGlsJGdldEVmZmVjdGl2ZVBhbjMuem9vbTtcbiAge1xuICAgIHZhciBfdXRpbCRtb2RlbFRvUmVuZGVyZWQgPSBtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbihyLCBwYW4sIHpvb20sIG1YMSwgbVkxKSxcbiAgICAgIF91dGlsJG1vZGVsVG9SZW5kZXJlZDIgPSBfc2xpY2VkVG9BcnJheShfdXRpbCRtb2RlbFRvUmVuZGVyZWQsIDIpLFxuICAgICAgY1gxID0gX3V0aWwkbW9kZWxUb1JlbmRlcmVkMlswXSxcbiAgICAgIGNZMSA9IF91dGlsJG1vZGVsVG9SZW5kZXJlZDJbMV07XG4gICAgdmFyIHQgPSA2OyAvLyBzaG91bGQgYmUgZXZlblxuICAgIHggPSBjWDEgLSB0IC8gMjtcbiAgICB5ID0gY1kxIC0gdCAvIDI7XG4gICAgdyA9IHQ7XG4gICAgaCA9IHQ7XG4gIH1cbiAgaWYgKHcgPT09IDAgfHwgaCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgZ2wgPSByLmRhdGEuY29udGV4dHNbci5XRUJHTF07XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgci5waWNraW5nRnJhbWVCdWZmZXIpO1xuICBpZiAoci5waWNraW5nRnJhbWVCdWZmZXIubmVlZHNEcmF3KSB7XG4gICAgLy8gRHJhdyBlbGVtZW50IHotaW5kZXhlcyB0byB0aGUgcGlja2luZyBmcmFtZWJ1ZmZlclxuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgcmVuZGVyV2ViZ2wociwgbnVsbCwgUkVOREVSX1RBUkdFVC5QSUNLSU5HKTtcbiAgICByLnBpY2tpbmdGcmFtZUJ1ZmZlci5uZWVkc0RyYXcgPSBmYWxzZTtcbiAgfVxuICB2YXIgbiA9IHcgKiBoOyAvLyBudW1iZXIgb2YgcGl4ZWxzIHRvIHJlYWRcbiAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShuICogNCk7IC8vIDQgYnl0ZXMgcGVyIHBpeGVsXG4gIGdsLnJlYWRQaXhlbHMoeCwgeSwgdywgaCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gIHZhciBpbmRleGVzID0gbmV3IFNldCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIHZhciBwaXhlbCA9IGRhdGEuc2xpY2UoaSAqIDQsIGkgKiA0ICsgNCk7XG4gICAgdmFyIGluZGV4ID0gdmVjNFRvSW5kZXgocGl4ZWwpIC0gMTsgLy8gVGhlIGZyYW1lYnVmZmVyIGlzIGNsZWFyZWQgd2l0aCAwcywgc28gei1pbmRleGVzIGFyZSBvZmZzZXQgYnkgMVxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBpbmRleGVzLmFkZChpbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleGVzO1xufVxuXG4vKipcbiAqIEN5LmpzOiBtb2RlbCBjb29yZGluYXRlIHkgYXhpcyBnb2VzIGRvd25cbiAqL1xuZnVuY3Rpb24gZmluZE5lYXJlc3RFbGVtZW50c1dlYmdsKHIsIHgsIHkpIHtcbiAgLy8gbW9kZWwgY29vcmRpbmF0ZXNcbiAgdmFyIGluZGV4ZXMgPSBnZXRQaWNraW5nSW5kZXhlcyhyLCB4LCB5KTtcbiAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gIHZhciBub2RlLCBlZGdlO1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaW5kZXhlcyksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBpbmRleCA9IF9zdGVwLnZhbHVlO1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaW5kZXhdO1xuICAgICAgaWYgKCFub2RlICYmIGVsZS5pc05vZGUoKSkge1xuICAgICAgICBub2RlID0gZWxlO1xuICAgICAgfVxuICAgICAgaWYgKCFlZGdlICYmIGVsZS5pc0VkZ2UoKSkge1xuICAgICAgICBlZGdlID0gZWxlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgJiYgZWRnZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxuICByZXR1cm4gW25vZGUsIGVkZ2VdLmZpbHRlcihCb29sZWFuKTtcbn1cblxuLyoqXG4gKiBEcmF3IG9uZSBub2RlIG9yIGVkZ2UuIFxuICovXG5mdW5jdGlvbiBkcmF3RWxlKHIsIGluZGV4LCBlbGUpIHtcbiAgdmFyIGRyYXdpbmcgPSByLmRyYXdpbmc7XG4gIGluZGV4ICs9IDE7IC8vIDAgaXMgdXNlZCB0byBjbGVhciB0aGUgYmFja2dyb3VuZCwgbmVlZCB0byBvZmZzZXQgYWxsIHotaW5kZXhlcyBieSBvbmVcbiAgaWYgKGVsZS5pc05vZGUoKSkge1xuICAgIGRyYXdpbmcuZHJhd05vZGUoZWxlLCBpbmRleCwgJ25vZGUtdW5kZXJsYXknKTtcbiAgICBkcmF3aW5nLmRyYXdOb2RlKGVsZSwgaW5kZXgsICdub2RlLWJvZHknKTtcbiAgICBkcmF3aW5nLmRyYXdUZXh0dXJlKGVsZSwgaW5kZXgsICdsYWJlbCcpO1xuICAgIGRyYXdpbmcuZHJhd05vZGUoZWxlLCBpbmRleCwgJ25vZGUtb3ZlcmxheScpO1xuICB9IGVsc2Uge1xuICAgIGRyYXdpbmcuZHJhd0VkZ2VMaW5lKGVsZSwgaW5kZXgpO1xuICAgIGRyYXdpbmcuZHJhd0VkZ2VBcnJvdyhlbGUsIGluZGV4LCAnc291cmNlJyk7XG4gICAgZHJhd2luZy5kcmF3RWRnZUFycm93KGVsZSwgaW5kZXgsICd0YXJnZXQnKTtcbiAgICBkcmF3aW5nLmRyYXdUZXh0dXJlKGVsZSwgaW5kZXgsICdsYWJlbCcpO1xuICAgIGRyYXdpbmcuZHJhd1RleHR1cmUoZWxlLCBpbmRleCwgJ2VkZ2Utc291cmNlLWxhYmVsJyk7XG4gICAgZHJhd2luZy5kcmF3VGV4dHVyZShlbGUsIGluZGV4LCAnZWRnZS10YXJnZXQtbGFiZWwnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbmRlciBvbmUgZnJhbWUuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlcldlYmdsKHIsIG9wdGlvbnMsIHJlbmRlclRhcmdldCkge1xuICB2YXIgc3RhcnQ7XG4gIGlmIChyLndlYmdsRGVidWcpIHtcbiAgICBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gIH1cbiAgdmFyIGRyYXdpbmcgPSByLmRyYXdpbmc7XG4gIHZhciBlbGVDb3VudCA9IDA7XG4gIGlmIChyZW5kZXJUYXJnZXQuc2NyZWVuKSB7XG4gICAgaWYgKHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tyLlNFTEVDVF9CT1hdKSB7XG4gICAgICBkcmF3U2VsZWN0aW9uUmVjdGFuZ2xlKHIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNlZSBkcmF3aW5nLWVsZW1lbnRzLmpzIGRyYXdDYWNoZWRFbGVtZW50KClcbiAgaWYgKHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tyLk5PREVdIHx8IHJlbmRlclRhcmdldC5waWNraW5nKSB7XG4gICAgdmFyIGdsID0gci5kYXRhLmNvbnRleHRzW3IuV0VCR0xdO1xuICAgIGlmIChyZW5kZXJUYXJnZXQuc2NyZWVuKSB7XG4gICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApOyAvLyBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpOyAvLyBlbmFibGUgYWxwaGEgYmxlbmRpbmcgb2YgY29sb3JzXG4gICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTsgLy8gd2ViZ2wgY29sb3JzIHVzZSBwcmVtdWx0aXBsaWVkIGFscGhhXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpOyAvLyBkb24ndCBibGVuZCB6LW9yZGVyIGluZGV4IHZhbHVlcyEgdGhleSBhcmUgbm90IGNvbG9yc1xuICAgIH1cbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcbiAgICB2YXIgcGFuWm9vbU1hdHJpeCA9IGNyZWF0ZVBhblpvb21NYXRyaXgocik7XG4gICAgdmFyIGVsZXMgPSByLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gICAgZWxlQ291bnQgPSBlbGVzLmxlbmd0aDtcbiAgICBkcmF3aW5nLnN0YXJ0RnJhbWUocGFuWm9vbU1hdHJpeCwgcmVuZGVyVGFyZ2V0KTtcbiAgICBpZiAocmVuZGVyVGFyZ2V0LnNjcmVlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVzLm5vbmRyYWcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZHJhd0VsZShyLCBpLCBlbGVzLm5vbmRyYWdbaV0pO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZWxlcy5kcmFnLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgZHJhd0VsZShyLCBfaTIsIGVsZXMuZHJhZ1tfaTJdKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlbmRlclRhcmdldC5waWNraW5nKSB7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlbGVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgZHJhd0VsZShyLCBfaTMsIGVsZXNbX2kzXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRyYXdpbmcuZW5kRnJhbWUoKTtcbiAgICBpZiAocmVuZGVyVGFyZ2V0LnNjcmVlbiAmJiByLndlYmdsRGVidWdTaG93QXRsYXNlcykge1xuICAgICAgZHJhd0F4ZXMocik7XG4gICAgICBkcmF3QXRsYXNlcyhyKTtcbiAgICB9XG4gICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W3IuTk9ERV0gPSBmYWxzZTtcbiAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbci5EUkFHXSA9IGZhbHNlO1xuICB9XG4gIGlmIChyLndlYmdsRGVidWcpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgdmFyIGNvbXBhY3QgPSBmYWxzZTtcbiAgICB2YXIgdGltZSA9IE1hdGguY2VpbChlbmQgLSBzdGFydCk7XG4gICAgdmFyIGRlYnVnSW5mbyA9IGRyYXdpbmcuZ2V0RGVidWdJbmZvKCk7XG4gICAgdmFyIHJlcG9ydCA9IFtcIlwiLmNvbmNhdChlbGVDb3VudCwgXCIgZWxlbWVudHNcIiksIFwiXCIuY29uY2F0KGRlYnVnSW5mby50b3RhbEluc3RhbmNlcywgXCIgaW5zdGFuY2VzXCIpLCBcIlwiLmNvbmNhdChkZWJ1Z0luZm8uYmF0Y2hDb3VudCwgXCIgYmF0Y2hlc1wiKSwgXCJcIi5jb25jYXQoZGVidWdJbmZvLnRvdGFsQXRsYXNlcywgXCIgYXRsYXNlc1wiKSwgXCJcIi5jb25jYXQoZGVidWdJbmZvLndyYXBwZWRDb3VudCwgXCIgd3JhcHBlZCB0ZXh0dXJlc1wiKSwgXCJcIi5jb25jYXQoZGVidWdJbmZvLnNpbXBsZUNvdW50LCBcIiBzaW1wbGUgc2hhcGVzXCIpXS5qb2luKCcsICcpO1xuICAgIGlmIChjb21wYWN0KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldlYkdMIChcIi5jb25jYXQocmVuZGVyVGFyZ2V0Lm5hbWUsIFwiKSAtIHRpbWUgXCIpLmNvbmNhdCh0aW1lLCBcIm1zLCBcIikuY29uY2F0KHJlcG9ydCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldlYkdMIChcIi5jb25jYXQocmVuZGVyVGFyZ2V0Lm5hbWUsIFwiKSAtIGZyYW1lIHRpbWUgXCIpLmNvbmNhdCh0aW1lLCBcIm1zXCIpKTtcbiAgICAgIGNvbnNvbGUubG9nKCdUb3RhbHM6Jyk7XG4gICAgICBjb25zb2xlLmxvZyhcIiAgXCIuY29uY2F0KHJlcG9ydCkpO1xuICAgICAgY29uc29sZS5sb2coJ1RleHR1cmUgQXRsYXNlcyBVc2VkOicpO1xuICAgICAgdmFyIGF0bGFzSW5mbyA9IGRlYnVnSW5mby5hdGxhc0luZm87XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGF0bGFzSW5mbyksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGluZm8gPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgY29uc29sZS5sb2coXCIgIFwiLmNvbmNhdChpbmZvLnR5cGUsIFwiOiBcIikuY29uY2F0KGluZm8ua2V5Q291bnQsIFwiIGtleXMsIFwiKS5jb25jYXQoaW5mby5hdGxhc0NvdW50LCBcIiBhdGxhc2VzXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgICBjb25zb2xlLmxvZygnJyk7XG4gICAgfVxuICB9XG4gIGlmIChyLmRhdGEuZ2MpIHtcbiAgICBjb25zb2xlLmxvZygnR2FyYmFnZSBDb2xsZWN0IScpO1xuICAgIHIuZGF0YS5nYyA9IGZhbHNlO1xuICAgIGRyYXdpbmcuZ2MoKTtcbiAgfVxufVxuXG52YXIgQ1JwJDMgPSB7fTtcblxuLy8gQE8gUG9seWdvbiBkcmF3aW5nXG5DUnAkMy5kcmF3UG9seWdvblBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG4gIHZhciBoYWxmVyA9IHdpZHRoIC8gMjtcbiAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuICBjb250ZXh0Lm1vdmVUbyh4ICsgaGFsZlcgKiBwb2ludHNbMF0sIHkgKyBoYWxmSCAqIHBvaW50c1sxXSk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIGNvbnRleHQubGluZVRvKHggKyBoYWxmVyAqIHBvaW50c1tpICogMl0sIHkgKyBoYWxmSCAqIHBvaW50c1tpICogMiArIDFdKTtcbiAgfVxuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcbkNScCQzLmRyYXdSb3VuZFBvbHlnb25QYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cywgY29ybmVycykge1xuICBjb3JuZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvcm5lcikge1xuICAgIHJldHVybiBkcmF3UHJlcGFyZWRSb3VuZENvcm5lcihjb250ZXh0LCBjb3JuZXIpO1xuICB9KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG5cbi8vIFJvdW5kIHJlY3RhbmdsZSBkcmF3aW5nXG5DUnAkMy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJSYWRpdXMgPSByYWRpdXMgPT09ICdhdXRvJyA/IGdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpIDogTWF0aC5taW4ocmFkaXVzLCBoYWxmSGVpZ2h0LCBoYWxmV2lkdGgpO1xuICBpZiAoY29udGV4dC5iZWdpblBhdGgpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICB9XG5cbiAgLy8gU3RhcnQgYXQgdG9wIG1pZGRsZVxuICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gIC8vIEFyYyBmcm9tIG1pZGRsZSB0b3AgdG8gcmlnaHQgc2lkZVxuICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4ICsgaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICAvLyBBcmMgZnJvbSByaWdodCBzaWRlIHRvIGJvdHRvbVxuICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4LCB5ICsgaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgLy8gQXJjIGZyb20gYm90dG9tIHRvIGxlZnQgc2lkZVxuICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICAvLyBBcmMgZnJvbSBsZWZ0IHNpZGUgdG8gdG9wQm9yZGVyXG4gIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHgsIHkgLSBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAvLyBKb2luIGxpbmVcbiAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcbkNScCQzLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIGNvcm5lclJhZGl1cyA9IHJhZGl1cyA9PT0gJ2F1dG8nID8gZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCkgOiByYWRpdXM7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cblxuICAvLyBTdGFydCBhdCB0b3AgbWlkZGxlXG4gIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoLCB5KTtcbiAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmNsb3NlUGF0aCgpO1xufTtcbkNScCQzLmRyYXdDdXRSZWN0YW5nbGVQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cywgY29ybmVycykge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciBjb3JuZXJMZW5ndGggPSBjb3JuZXJzID09PSAnYXV0bycgPyBnZXRDdXRSZWN0YW5nbGVDb3JuZXJMZW5ndGgoKSA6IGNvcm5lcnM7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cbiAgY29udGV4dC5tb3ZlVG8oeCAtIGhhbGZXaWR0aCArIGNvcm5lckxlbmd0aCwgeSAtIGhhbGZIZWlnaHQpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5IC0gaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyTGVuZ3RoKTtcbiAgY29udGV4dC5saW5lVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4ICsgaGFsZldpZHRoIC0gY29ybmVyTGVuZ3RoLCB5ICsgaGFsZkhlaWdodCk7XG4gIGNvbnRleHQubGluZVRvKHggLSBoYWxmV2lkdGggKyBjb3JuZXJMZW5ndGgsIHkgKyBoYWxmSGVpZ2h0KTtcbiAgY29udGV4dC5saW5lVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQgLSBjb3JuZXJMZW5ndGgpO1xuICBjb250ZXh0LmxpbmVUbyh4IC0gaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCArIGNvcm5lckxlbmd0aCk7XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuQ1JwJDMuZHJhd0JhcnJlbFBhdGggPSBmdW5jdGlvbiAoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICB2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gIHZhciB4QmVnaW4gPSB4IC0gaGFsZldpZHRoO1xuICB2YXIgeEVuZCA9IHggKyBoYWxmV2lkdGg7XG4gIHZhciB5QmVnaW4gPSB5IC0gaGFsZkhlaWdodDtcbiAgdmFyIHlFbmQgPSB5ICsgaGFsZkhlaWdodDtcbiAgdmFyIGJhcnJlbEN1cnZlQ29uc3RhbnRzID0gZ2V0QmFycmVsQ3VydmVDb25zdGFudHMod2lkdGgsIGhlaWdodCk7XG4gIHZhciB3T2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMud2lkdGhPZmZzZXQ7XG4gIHZhciBoT2Zmc2V0ID0gYmFycmVsQ3VydmVDb25zdGFudHMuaGVpZ2h0T2Zmc2V0O1xuICB2YXIgY3RybFB0WE9mZnNldCA9IGJhcnJlbEN1cnZlQ29uc3RhbnRzLmN0cmxQdE9mZnNldFBjdCAqIHdPZmZzZXQ7XG4gIGlmIChjb250ZXh0LmJlZ2luUGF0aCkge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIH1cbiAgY29udGV4dC5tb3ZlVG8oeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5saW5lVG8oeEJlZ2luLCB5RW5kIC0gaE9mZnNldCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4QmVnaW4gKyBjdHJsUHRYT2Zmc2V0LCB5RW5kLCB4QmVnaW4gKyB3T2Zmc2V0LCB5RW5kKTtcbiAgY29udGV4dC5saW5lVG8oeEVuZCAtIHdPZmZzZXQsIHlFbmQpO1xuICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oeEVuZCAtIGN0cmxQdFhPZmZzZXQsIHlFbmQsIHhFbmQsIHlFbmQgLSBoT2Zmc2V0KTtcbiAgY29udGV4dC5saW5lVG8oeEVuZCwgeUJlZ2luICsgaE9mZnNldCk7XG4gIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh4RW5kIC0gY3RybFB0WE9mZnNldCwgeUJlZ2luLCB4RW5kIC0gd09mZnNldCwgeUJlZ2luKTtcbiAgY29udGV4dC5saW5lVG8oeEJlZ2luICsgd09mZnNldCwgeUJlZ2luKTtcbiAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHhCZWdpbiArIGN0cmxQdFhPZmZzZXQsIHlCZWdpbiwgeEJlZ2luLCB5QmVnaW4gKyBoT2Zmc2V0KTtcbiAgY29udGV4dC5jbG9zZVBhdGgoKTtcbn07XG52YXIgc2luMCA9IE1hdGguc2luKDApO1xudmFyIGNvczAgPSBNYXRoLmNvcygwKTtcbnZhciBzaW4gPSB7fTtcbnZhciBjb3MgPSB7fTtcbnZhciBlbGxpcHNlU3RlcFNpemUgPSBNYXRoLlBJIC8gNDA7XG5mb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUpIHtcbiAgc2luW2ldID0gTWF0aC5zaW4oaSk7XG4gIGNvc1tpXSA9IE1hdGguY29zKGkpO1xufVxuQ1JwJDMuZHJhd0VsbGlwc2VQYXRoID0gZnVuY3Rpb24gKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgfVxuICBpZiAoY29udGV4dC5lbGxpcHNlKSB7XG4gICAgY29udGV4dC5lbGxpcHNlKGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMiwgMCwgMCwgMiAqIE1hdGguUEkpO1xuICB9IGVsc2Uge1xuICAgIHZhciB4UG9zLCB5UG9zO1xuICAgIHZhciBydyA9IHdpZHRoIC8gMjtcbiAgICB2YXIgcmggPSBoZWlnaHQgLyAyO1xuICAgIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSkge1xuICAgICAgeFBvcyA9IGNlbnRlclggLSBydyAqIHNpbltpXSAqIHNpbjAgKyBydyAqIGNvc1tpXSAqIGNvczA7XG4gICAgICB5UG9zID0gY2VudGVyWSArIHJoICogY29zW2ldICogc2luMCArIHJoICogc2luW2ldICogY29zMDtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnRleHQuY2xvc2VQYXRoKCk7XG59O1xuXG4vKiBnbG9iYWwgYXRvYiwgQXJyYXlCdWZmZXIsIFVpbnQ4QXJyYXksIEJsb2IgKi9cblxudmFyIENScCQyID0ge307XG5DUnAkMi5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbiAodywgaCkge1xuICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgYnVmZmVyLndpZHRoID0gdztcbiAgYnVmZmVyLmhlaWdodCA9IGg7XG4gIHJldHVybiBbYnVmZmVyLCBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKV07XG59O1xuQ1JwJDIuYnVmZmVyQ2FudmFzSW1hZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgY3kgPSB0aGlzLmN5O1xuICB2YXIgZWxlcyA9IGN5Lm11dGFibGVFbGVtZW50cygpO1xuICB2YXIgYmIgPSBlbGVzLmJvdW5kaW5nQm94KCk7XG4gIHZhciBjdHJSZWN0ID0gdGhpcy5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG4gIHZhciB3aWR0aCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi53KSA6IGN0clJlY3RbMl07XG4gIHZhciBoZWlnaHQgPSBvcHRpb25zLmZ1bGwgPyBNYXRoLmNlaWwoYmIuaCkgOiBjdHJSZWN0WzNdO1xuICB2YXIgc3BlY2RNYXhEaW1zID0gbnVtYmVyJDEob3B0aW9ucy5tYXhXaWR0aCkgfHwgbnVtYmVyJDEob3B0aW9ucy5tYXhIZWlnaHQpO1xuICB2YXIgcHhSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICB2YXIgc2NhbGUgPSAxO1xuICBpZiAob3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2lkdGggKj0gb3B0aW9ucy5zY2FsZTtcbiAgICBoZWlnaHQgKj0gb3B0aW9ucy5zY2FsZTtcbiAgICBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gIH0gZWxzZSBpZiAoc3BlY2RNYXhEaW1zKSB7XG4gICAgdmFyIG1heFNjYWxlVyA9IEluZmluaXR5O1xuICAgIHZhciBtYXhTY2FsZUggPSBJbmZpbml0eTtcbiAgICBpZiAobnVtYmVyJDEob3B0aW9ucy5tYXhXaWR0aCkpIHtcbiAgICAgIG1heFNjYWxlVyA9IHNjYWxlICogb3B0aW9ucy5tYXhXaWR0aCAvIHdpZHRoO1xuICAgIH1cbiAgICBpZiAobnVtYmVyJDEob3B0aW9ucy5tYXhIZWlnaHQpKSB7XG4gICAgICBtYXhTY2FsZUggPSBzY2FsZSAqIG9wdGlvbnMubWF4SGVpZ2h0IC8gaGVpZ2h0O1xuICAgIH1cbiAgICBzY2FsZSA9IE1hdGgubWluKG1heFNjYWxlVywgbWF4U2NhbGVIKTtcbiAgICB3aWR0aCAqPSBzY2FsZTtcbiAgICBoZWlnaHQgKj0gc2NhbGU7XG4gIH1cbiAgaWYgKCFzcGVjZE1heERpbXMpIHtcbiAgICB3aWR0aCAqPSBweFJhdGlvO1xuICAgIGhlaWdodCAqPSBweFJhdGlvO1xuICAgIHNjYWxlICo9IHB4UmF0aW87XG4gIH1cbiAgdmFyIGJ1ZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIGJ1ZmZDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgYnVmZkNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGJ1ZmZDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgdmFyIGJ1ZmZDeHQgPSBidWZmQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgLy8gUmFzdGVyaXplIHRoZSBsYXllcnMsIGJ1dCBvbmx5IGlmIGNvbnRhaW5lciBoYXMgbm9uemVybyBzaXplXG4gIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgIGJ1ZmZDeHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICB2YXIgenNvcnRlZEVsZXMgPSB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCk7XG4gICAgaWYgKG9wdGlvbnMuZnVsbCkge1xuICAgICAgLy8gZHJhdyB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdyYXBoXG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSgtYmIueDEgKiBzY2FsZSwgLWJiLnkxICogc2NhbGUpO1xuICAgICAgYnVmZkN4dC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgdGhpcy5kcmF3RWxlbWVudHMoYnVmZkN4dCwgenNvcnRlZEVsZXMpO1xuICAgICAgYnVmZkN4dC5zY2FsZSgxIC8gc2NhbGUsIDEgLyBzY2FsZSk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZShiYi54MSAqIHNjYWxlLCBiYi55MSAqIHNjYWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZHJhdyB0aGUgY3VycmVudCB2aWV3XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHBhbi54ICogc2NhbGUsXG4gICAgICAgIHk6IHBhbi55ICogc2NhbGVcbiAgICAgIH07XG4gICAgICBzY2FsZSAqPSBjeS56b29tKCk7XG4gICAgICBidWZmQ3h0LnRyYW5zbGF0ZSh0cmFuc2xhdGlvbi54LCB0cmFuc2xhdGlvbi55KTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIHRoaXMuZHJhd0VsZW1lbnRzKGJ1ZmZDeHQsIHpzb3J0ZWRFbGVzKTtcbiAgICAgIGJ1ZmZDeHQuc2NhbGUoMSAvIHNjYWxlLCAxIC8gc2NhbGUpO1xuICAgICAgYnVmZkN4dC50cmFuc2xhdGUoLXRyYW5zbGF0aW9uLngsIC10cmFuc2xhdGlvbi55KTtcbiAgICB9XG5cbiAgICAvLyBuZWVkIHRvIGZpbGwgYmcgYXQgZW5kIGxpa2UgdGhpcyBpbiBvcmRlciB0byBmaWxsIGNsZWFyZWQgdHJhbnNwYXJlbnQgcGl4ZWxzIGluIGpwZ3NcbiAgICBpZiAob3B0aW9ucy5iZykge1xuICAgICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3Zlcic7XG4gICAgICBidWZmQ3h0LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmc7XG4gICAgICBidWZmQ3h0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBidWZmQ3h0LmZpbGwoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ1ZmZDYW52YXM7XG59O1xuZnVuY3Rpb24gYjY0VG9CbG9iKGI2NCwgbWltZVR5cGUpIHtcbiAgdmFyIGJ5dGVzID0gYXRvYihiNjQpO1xuICB2YXIgYnVmZiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlcy5sZW5ndGgpO1xuICB2YXIgYnVmZlVpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmVWludDhbaV0gPSBieXRlcy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBuZXcgQmxvYihbYnVmZl0sIHtcbiAgICB0eXBlOiBtaW1lVHlwZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGI2NFVyaVRvQjY0KGI2NHVyaSkge1xuICB2YXIgaSA9IGI2NHVyaS5pbmRleE9mKCcsJyk7XG4gIHJldHVybiBiNjR1cmkuc3Vic3RyKGkgKyAxKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvcHRpb25zLCBjYW52YXMsIG1pbWVUeXBlKSB7XG4gIHZhciBnZXRCNjRVcmkgPSBmdW5jdGlvbiBnZXRCNjRVcmkoKSB7XG4gICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIG9wdGlvbnMucXVhbGl0eSk7XG4gIH07XG4gIHN3aXRjaCAob3B0aW9ucy5vdXRwdXQpIHtcbiAgICBjYXNlICdibG9iLXByb21pc2UnOlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNhbnZhcy50b0Jsb2IoZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgICAgIGlmIChibG9iICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShibG9iKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2BjYW52YXMudG9CbG9iKClgIHNlbnQgYSBudWxsIHZhbHVlIGluIGl0cyBjYWxsYmFjaycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBtaW1lVHlwZSwgb3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIGNhc2UgJ2Jsb2InOlxuICAgICAgcmV0dXJuIGI2NFRvQmxvYihiNjRVcmlUb0I2NChnZXRCNjRVcmkoKSksIG1pbWVUeXBlKTtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIGI2NFVyaVRvQjY0KGdldEI2NFVyaSgpKTtcbiAgICBjYXNlICdiYXNlNjR1cmknOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZ2V0QjY0VXJpKCk7XG4gIH1cbn1cbkNScCQyLnBuZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL3BuZycpO1xufTtcbkNScCQyLmpwZyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBvdXRwdXQob3B0aW9ucywgdGhpcy5idWZmZXJDYW52YXNJbWFnZShvcHRpb25zKSwgJ2ltYWdlL2pwZWcnKTtcbn07XG5cbnZhciBDUnAkMSA9IHt9O1xuQ1JwJDEubm9kZVNoYXBlSW1wbCA9IGZ1bmN0aW9uIChuYW1lLCBjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMsIGNvcm5lcnMpIHtcbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSAnZWxsaXBzZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3RWxsaXBzZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgY2FzZSAncG9seWdvbic6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3UG9seWdvblBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKTtcbiAgICBjYXNlICdyb3VuZC1wb2x5Z29uJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdSb3VuZFBvbHlnb25QYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBvaW50cywgY29ybmVycyk7XG4gICAgY2FzZSAncm91bmRyZWN0YW5nbGUnOlxuICAgIGNhc2UgJ3JvdW5kLXJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Um91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGNvcm5lcnMpO1xuICAgIGNhc2UgJ2N1dHJlY3RhbmdsZSc6XG4gICAgY2FzZSAnY3V0LXJlY3RhbmdsZSc6XG4gICAgICByZXR1cm4gdGhpcy5kcmF3Q3V0UmVjdGFuZ2xlUGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMsIGNvcm5lcnMpO1xuICAgIGNhc2UgJ2JvdHRvbXJvdW5kcmVjdGFuZ2xlJzpcbiAgICBjYXNlICdib3R0b20tcm91bmQtcmVjdGFuZ2xlJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdCb3R0b21Sb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgY29ybmVycyk7XG4gICAgY2FzZSAnYmFycmVsJzpcbiAgICAgIHJldHVybiB0aGlzLmRyYXdCYXJyZWxQYXRoKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG59O1xuXG52YXIgQ1IgPSBDYW52YXNSZW5kZXJlcjtcbnZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5DUnAuQ0FOVkFTX0xBWUVSUyA9IDM7XG4vL1xuQ1JwLlNFTEVDVF9CT1ggPSAwO1xuQ1JwLkRSQUcgPSAxO1xuQ1JwLk5PREUgPSAyO1xuQ1JwLldFQkdMID0gMztcbkNScC5DQU5WQVNfVFlQRVMgPSBbJzJkJywgJzJkJywgJzJkJywgJ3dlYmdsMiddO1xuQ1JwLkJVRkZFUl9DT1VOVCA9IDM7XG4vL1xuQ1JwLlRFWFRVUkVfQlVGRkVSID0gMDtcbkNScC5NT1RJT05CTFVSX0JVRkZFUl9OT0RFID0gMTtcbkNScC5NT1RJT05CTFVSX0JVRkZFUl9EUkFHID0gMjtcbmZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdmFyIHIgPSB0aGlzO1xuICB2YXIgY29udGFpbmVyV2luZG93ID0gci5jeS53aW5kb3coKTtcbiAgdmFyIGRvY3VtZW50ID0gY29udGFpbmVyV2luZG93LmRvY3VtZW50O1xuICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgIENScC5DQU5WQVNfTEFZRVJTID0gci5DQU5WQVNfTEFZRVJTID0gNDtcbiAgICBjb25zb2xlLmxvZygnd2ViZ2wgcmVuZGVyaW5nIGVuYWJsZWQnKTtcbiAgfVxuICByLmRhdGEgPSB7XG4gICAgY2FudmFzZXM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY29udGV4dHM6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgY2FudmFzTmVlZHNSZWRyYXc6IG5ldyBBcnJheShDUnAuQ0FOVkFTX0xBWUVSUyksXG4gICAgYnVmZmVyQ2FudmFzZXM6IG5ldyBBcnJheShDUnAuQlVGRkVSX0NPVU5UKSxcbiAgICBidWZmZXJDb250ZXh0czogbmV3IEFycmF5KENScC5DQU5WQVNfTEFZRVJTKVxuICB9O1xuICB2YXIgdGFwSGxPZmZBdHRyID0gJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcic7XG4gIHZhciB0YXBIbE9mZlN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICByLmRhdGEuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgdmFyIGNvbnRhaW5lclN0eWxlID0gci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZTtcbiAgci5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZVt0YXBIbE9mZkF0dHJdID0gdGFwSGxPZmZTdHlsZTtcbiAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICBjb250YWluZXJTdHlsZS56SW5kZXggPSAnMCc7XG4gIGNvbnRhaW5lclN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIHZhciBjb250YWluZXIgPSBvcHRpb25zLmN5LmNvbnRhaW5lcigpO1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmNhbnZhc0NvbnRhaW5lcik7XG4gIGNvbnRhaW5lci5zdHlsZVt0YXBIbE9mZkF0dHJdID0gdGFwSGxPZmZTdHlsZTtcbiAgdmFyIHN0eWxlTWFwID0ge1xuICAgICctd2Via2l0LXVzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICctbW96LXVzZXItc2VsZWN0JzogJy1tb3otbm9uZScsXG4gICAgJ3VzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InOiAncmdiYSgwLDAsMCwwKScsXG4gICAgJ291dGxpbmUtc3R5bGUnOiAnbm9uZSdcbiAgfTtcbiAgaWYgKG1zKCkpIHtcbiAgICBzdHlsZU1hcFsnLW1zLXRvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICAgIHN0eWxlTWFwWyd0b3VjaC1hY3Rpb24nXSA9ICdub25lJztcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IENScC5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICB2YXIgY2FudmFzID0gci5kYXRhLmNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgdHlwZSA9IENScC5DQU5WQVNfVFlQRVNbaV07XG4gICAgci5kYXRhLmNvbnRleHRzW2ldID0gY2FudmFzLmdldENvbnRleHQodHlwZSk7XG4gICAgaWYgKCFyLmRhdGEuY29udGV4dHNbaV0pIHtcbiAgICAgIGVycm9yKCdDb3VsZCBub3QgY3JlYXRlIGNhbnZhcyBvZiB0eXBlICcgKyB0eXBlKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMoc3R5bGVNYXApLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrXSA9IHN0eWxlTWFwW2tdO1xuICAgIH0pO1xuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBpKTtcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gU3RyaW5nKENScC5DQU5WQVNfTEFZRVJTIC0gaSk7XG4gICAgci5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tpXSA9IGZhbHNlO1xuICB9XG4gIHIuZGF0YS50b3BDYW52YXMgPSByLmRhdGEuY2FudmFzZXNbMF07XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAuTk9ERV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5OT0RFICsgJy1ub2RlJyk7XG4gIHIuZGF0YS5jYW52YXNlc1tDUnAuU0VMRUNUX0JPWF0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5TRUxFQ1RfQk9YICsgJy1zZWxlY3Rib3gnKTtcbiAgci5kYXRhLmNhbnZhc2VzW0NScC5EUkFHXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ1JwLkRSQUcgKyAnLWRyYWcnKTtcbiAgaWYgKHIuZGF0YS5jYW52YXNlc1tDUnAuV0VCR0xdKSB7XG4gICAgci5kYXRhLmNhbnZhc2VzW0NScC5XRUJHTF0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENScC5XRUJHTCArICctd2ViZ2wnKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IENScC5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgIHIuZGF0YS5idWZmZXJDYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4gICAgci5kYXRhLmJ1ZmZlckNvbnRleHRzW2ldID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLmdldENvbnRleHQoJzJkJyk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2J1ZmZlcicgKyBpKTtcbiAgICByLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc3R5bGUuekluZGV4ID0gU3RyaW5nKC1pIC0gMSk7XG4gICAgci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAvL3IuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoci5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgfVxuICByLnBhdGhzRW5hYmxlZCA9IHRydWU7XG4gIHZhciBlbXB0eUJiID0gbWFrZUJvdW5kaW5nQm94KCk7XG4gIHZhciBnZXRCb3hDZW50ZXIgPSBmdW5jdGlvbiBnZXRCb3hDZW50ZXIoYmIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKGJiLngxICsgYmIueDIpIC8gMixcbiAgICAgIHk6IChiYi55MSArIGJiLnkyKSAvIDJcbiAgICB9O1xuICB9O1xuICB2YXIgZ2V0Q2VudGVyT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0Q2VudGVyT2Zmc2V0KGJiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IC1iYi53IC8gMixcbiAgICAgIHk6IC1iYi5oIC8gMlxuICAgIH07XG4gIH07XG4gIHZhciBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZCA9IGZ1bmN0aW9uIGJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkKGVsZSkge1xuICAgIHZhciBfcCA9IGVsZVswXS5fcHJpdmF0ZTtcbiAgICB2YXIgc2FtZSA9IF9wLm9sZEJhY2tncm91bmRUaW1lc3RhbXAgPT09IF9wLmJhY2tncm91bmRUaW1lc3RhbXA7XG4gICAgcmV0dXJuICFzYW1lO1xuICB9O1xuICB2YXIgZ2V0U3R5bGVLZXkgPSBmdW5jdGlvbiBnZXRTdHlsZUtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLm5vZGVLZXk7XG4gIH07XG4gIHZhciBnZXRMYWJlbEtleSA9IGZ1bmN0aW9uIGdldExhYmVsS2V5KGVsZSkge1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxTdHlsZUtleTtcbiAgfTtcbiAgdmFyIGdldFNvdXJjZUxhYmVsS2V5ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxLZXkoZWxlKSB7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5zb3VyY2VMYWJlbFN0eWxlS2V5O1xuICB9O1xuICB2YXIgZ2V0VGFyZ2V0TGFiZWxLZXkgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbEtleShlbGUpIHtcbiAgICByZXR1cm4gZWxlWzBdLl9wcml2YXRlLnRhcmdldExhYmVsU3R5bGVLZXk7XG4gIH07XG4gIHZhciBkcmF3RWxlbWVudCA9IGZ1bmN0aW9uIGRyYXdFbGVtZW50KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudChjb250ZXh0LCBlbGUsIGJiLCBmYWxzZSwgZmFsc2UsIHVzZUVsZU9wYWNpdHkpO1xuICB9O1xuICB2YXIgZHJhd0xhYmVsID0gZnVuY3Rpb24gZHJhd0xhYmVsKGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sIHVzZUVsZU9wYWNpdHkpIHtcbiAgICByZXR1cm4gci5kcmF3RWxlbWVudFRleHQoY29udGV4dCwgZWxlLCBiYiwgc2NhbGVkTGFiZWxTaG93biwgJ21haW4nLCB1c2VFbGVPcGFjaXR5KTtcbiAgfTtcbiAgdmFyIGRyYXdTb3VyY2VMYWJlbCA9IGZ1bmN0aW9uIGRyYXdTb3VyY2VMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICdzb3VyY2UnLCB1c2VFbGVPcGFjaXR5KTtcbiAgfTtcbiAgdmFyIGRyYXdUYXJnZXRMYWJlbCA9IGZ1bmN0aW9uIGRyYXdUYXJnZXRMYWJlbChjb250ZXh0LCBlbGUsIGJiLCBzY2FsZWRMYWJlbFNob3duLCB1c2VFbGVPcGFjaXR5KSB7XG4gICAgcmV0dXJuIHIuZHJhd0VsZW1lbnRUZXh0KGNvbnRleHQsIGVsZSwgYmIsIHNjYWxlZExhYmVsU2hvd24sICd0YXJnZXQnLCB1c2VFbGVPcGFjaXR5KTtcbiAgfTtcbiAgdmFyIGdldEVsZW1lbnRCb3ggPSBmdW5jdGlvbiBnZXRFbGVtZW50Qm94KGVsZSkge1xuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUuYm9keUJvdW5kcztcbiAgfTtcbiAgdmFyIGdldExhYmVsQm94ID0gZnVuY3Rpb24gZ2V0TGFiZWxCb3goZWxlKSB7XG4gICAgZWxlLmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIGVsZVswXS5fcHJpdmF0ZS5sYWJlbEJvdW5kcy5tYWluIHx8IGVtcHR5QmI7XG4gIH07XG4gIHZhciBnZXRTb3VyY2VMYWJlbEJveCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsQm94KGVsZSkge1xuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxCb3VuZHMuc291cmNlIHx8IGVtcHR5QmI7XG4gIH07XG4gIHZhciBnZXRUYXJnZXRMYWJlbEJveCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsQm94KGVsZSkge1xuICAgIGVsZS5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiBlbGVbMF0uX3ByaXZhdGUubGFiZWxCb3VuZHMudGFyZ2V0IHx8IGVtcHR5QmI7XG4gIH07XG4gIHZhciBpc0xhYmVsVmlzaWJsZUF0U2NhbGUgPSBmdW5jdGlvbiBpc0xhYmVsVmlzaWJsZUF0U2NhbGUoZWxlLCBzY2FsZWRMYWJlbFNob3duKSB7XG4gICAgcmV0dXJuIHNjYWxlZExhYmVsU2hvd247XG4gIH07XG4gIHZhciBnZXRFbGVtZW50Um90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldEVsZW1lbnRSb3RhdGlvblBvaW50KGVsZSkge1xuICAgIHJldHVybiBnZXRCb3hDZW50ZXIoZ2V0RWxlbWVudEJveChlbGUpKTtcbiAgfTtcbiAgdmFyIGFkZFRleHRNYXJnaW4gPSBmdW5jdGlvbiBhZGRUZXh0TWFyZ2luKHByZWZpeCwgcHQsIGVsZSkge1xuICAgIHZhciBwcmUgPSBwcmVmaXggPyBwcmVmaXggKyAnLScgOiAnJztcbiAgICByZXR1cm4ge1xuICAgICAgeDogcHQueCArIGVsZS5wc3R5bGUocHJlICsgJ3RleHQtbWFyZ2luLXgnKS5wZlZhbHVlLFxuICAgICAgeTogcHQueSArIGVsZS5wc3R5bGUocHJlICsgJ3RleHQtbWFyZ2luLXknKS5wZlZhbHVlXG4gICAgfTtcbiAgfTtcbiAgdmFyIGdldFJzUHQgPSBmdW5jdGlvbiBnZXRSc1B0KGVsZSwgeCwgeSkge1xuICAgIHZhciBycyA9IGVsZVswXS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcnNbeF0sXG4gICAgICB5OiByc1t5XVxuICAgIH07XG4gIH07XG4gIHZhciBnZXRMYWJlbFJvdGF0aW9uUG9pbnQgPSBmdW5jdGlvbiBnZXRMYWJlbFJvdGF0aW9uUG9pbnQoZWxlKSB7XG4gICAgcmV0dXJuIGFkZFRleHRNYXJnaW4oJycsIGdldFJzUHQoZWxlLCAnbGFiZWxYJywgJ2xhYmVsWScpLCBlbGUpO1xuICB9O1xuICB2YXIgZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50KGVsZSkge1xuICAgIHJldHVybiBhZGRUZXh0TWFyZ2luKCdzb3VyY2UnLCBnZXRSc1B0KGVsZSwgJ3NvdXJjZUxhYmVsWCcsICdzb3VyY2VMYWJlbFknKSwgZWxlKTtcbiAgfTtcbiAgdmFyIGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludChlbGUpIHtcbiAgICByZXR1cm4gYWRkVGV4dE1hcmdpbigndGFyZ2V0JywgZ2V0UnNQdChlbGUsICd0YXJnZXRMYWJlbFgnLCAndGFyZ2V0TGFiZWxZJyksIGVsZSk7XG4gIH07XG4gIHZhciBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRFbGVtZW50Qm94KGVsZSkpO1xuICB9O1xuICB2YXIgZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldCA9IGZ1bmN0aW9uIGdldFNvdXJjZUxhYmVsUm90YXRpb25PZmZzZXQoZWxlKSB7XG4gICAgcmV0dXJuIGdldENlbnRlck9mZnNldChnZXRTb3VyY2VMYWJlbEJveChlbGUpKTtcbiAgfTtcbiAgdmFyIGdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0KGVsZSkge1xuICAgIHJldHVybiBnZXRDZW50ZXJPZmZzZXQoZ2V0VGFyZ2V0TGFiZWxCb3goZWxlKSk7XG4gIH07XG4gIHZhciBnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0TGFiZWxSb3RhdGlvbk9mZnNldChlbGUpIHtcbiAgICB2YXIgYmIgPSBnZXRMYWJlbEJveChlbGUpO1xuICAgIHZhciBwID0gZ2V0Q2VudGVyT2Zmc2V0KGdldExhYmVsQm94KGVsZSkpO1xuICAgIGlmIChlbGUuaXNOb2RlKCkpIHtcbiAgICAgIHN3aXRjaCAoZWxlLnBzdHlsZSgndGV4dC1oYWxpZ24nKS52YWx1ZSkge1xuICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICBwLnggPSAtYmIudyAtIChiYi5sZWZ0UGFkIHx8IDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcC54ID0gLShiYi5yaWdodFBhZCB8fCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZWxlLnBzdHlsZSgndGV4dC12YWxpZ24nKS52YWx1ZSkge1xuICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgIHAueSA9IC1iYi5oIC0gKGJiLnRvcFBhZCB8fCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICBwLnkgPSAtKGJiLmJvdFBhZCB8fCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG4gIHZhciBlbGVUeHJDYWNoZSA9IHIuZGF0YS5lbGVUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldFN0eWxlS2V5LFxuICAgIGRvZXNFbGVJbnZhbGlkYXRlS2V5OiBiYWNrZ3JvdW5kVGltZXN0YW1wSGFzQ2hhbmdlZCxcbiAgICBkcmF3RWxlbWVudDogZHJhd0VsZW1lbnQsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldEVsZW1lbnRCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCxcbiAgICBhbGxvd0VkZ2VUeHJDYWNoaW5nOiBmYWxzZSxcbiAgICBhbGxvd1BhcmVudFR4ckNhY2hpbmc6IGZhbHNlXG4gIH0pO1xuICB2YXIgbGJsVHhyQ2FjaGUgPSByLmRhdGEubGJsVHhyQ2FjaGUgPSBuZXcgRWxlbWVudFRleHR1cmVDYWNoZShyLCB7XG4gICAgZ2V0S2V5OiBnZXRMYWJlbEtleSxcbiAgICBkcmF3RWxlbWVudDogZHJhd0xhYmVsLFxuICAgIGdldEJvdW5kaW5nQm94OiBnZXRMYWJlbEJveCxcbiAgICBnZXRSb3RhdGlvblBvaW50OiBnZXRMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgZ2V0Um90YXRpb25PZmZzZXQ6IGdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgaXNWaXNpYmxlOiBpc0xhYmVsVmlzaWJsZUF0U2NhbGVcbiAgfSk7XG4gIHZhciBzbGJUeHJDYWNoZSA9IHIuZGF0YS5zbGJUeHJDYWNoZSA9IG5ldyBFbGVtZW50VGV4dHVyZUNhY2hlKHIsIHtcbiAgICBnZXRLZXk6IGdldFNvdXJjZUxhYmVsS2V5LFxuICAgIGRyYXdFbGVtZW50OiBkcmF3U291cmNlTGFiZWwsXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGdldFNvdXJjZUxhYmVsQm94LFxuICAgIGdldFJvdGF0aW9uUG9pbnQ6IGdldFNvdXJjZUxhYmVsUm90YXRpb25Qb2ludCxcbiAgICBnZXRSb3RhdGlvbk9mZnNldDogZ2V0U291cmNlTGFiZWxSb3RhdGlvbk9mZnNldCxcbiAgICBpc1Zpc2libGU6IGlzTGFiZWxWaXNpYmxlQXRTY2FsZVxuICB9KTtcbiAgdmFyIHRsYlR4ckNhY2hlID0gci5kYXRhLnRsYlR4ckNhY2hlID0gbmV3IEVsZW1lbnRUZXh0dXJlQ2FjaGUociwge1xuICAgIGdldEtleTogZ2V0VGFyZ2V0TGFiZWxLZXksXG4gICAgZHJhd0VsZW1lbnQ6IGRyYXdUYXJnZXRMYWJlbCxcbiAgICBnZXRCb3VuZGluZ0JveDogZ2V0VGFyZ2V0TGFiZWxCb3gsXG4gICAgZ2V0Um90YXRpb25Qb2ludDogZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgIGdldFJvdGF0aW9uT2Zmc2V0OiBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgIGlzVmlzaWJsZTogaXNMYWJlbFZpc2libGVBdFNjYWxlXG4gIH0pO1xuICB2YXIgbHlyVHhyQ2FjaGUgPSByLmRhdGEubHlyVHhyQ2FjaGUgPSBuZXcgTGF5ZXJlZFRleHR1cmVDYWNoZShyKTtcbiAgci5vblVwZGF0ZUVsZUNhbGNzKGZ1bmN0aW9uIGludmFsaWRhdGVUZXh0dXJlQ2FjaGVzKHdpbGxEcmF3LCBlbGVzKSB7XG4gICAgLy8gZWFjaCBjYWNoZSBzaG91bGQgY2hlY2sgZm9yIHN1Yi1rZXkgZGlmZiB0byBzZWUgdGhhdCB0aGUgdXBkYXRlIGFmZmVjdHMgdGhhdCBjYWNoZSBwYXJ0aWN1bGFybHlcbiAgICBlbGVUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG4gICAgbGJsVHhyQ2FjaGUuaW52YWxpZGF0ZUVsZW1lbnRzKGVsZXMpO1xuICAgIHNsYlR4ckNhY2hlLmludmFsaWRhdGVFbGVtZW50cyhlbGVzKTtcbiAgICB0bGJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG5cbiAgICAvLyBhbnkgY2hhbmdlIGludmFsaWRhdGVzIHRoZSBsYXllcnNcbiAgICBseXJUeHJDYWNoZS5pbnZhbGlkYXRlRWxlbWVudHMoZWxlcyk7XG5cbiAgICAvLyB1cGRhdGUgdGhlIG9sZCBiZyB0aW1lc3RhbXAgc28gZGlmZnMgY2FuIGJlIGRvbmUgaW4gdGhlIGVsZSB0eHIgY2FjaGVzXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3AgPSBlbGVzW19pXS5fcHJpdmF0ZTtcbiAgICAgIF9wLm9sZEJhY2tncm91bmRUaW1lc3RhbXAgPSBfcC5iYWNrZ3JvdW5kVGltZXN0YW1wO1xuICAgIH1cbiAgfSk7XG4gIHZhciByZWZpbmVJbkxheWVycyA9IGZ1bmN0aW9uIHJlZmluZUluTGF5ZXJzKHJlcXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGx5clR4ckNhY2hlLmVucXVldWVFbGVtZW50UmVmaW5lbWVudChyZXFzW2ldLmVsZSk7XG4gICAgfVxuICB9O1xuICBlbGVUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICBsYmxUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICBzbGJUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICB0bGJUeHJDYWNoZS5vbkRlcXVldWUocmVmaW5lSW5MYXllcnMpO1xuICBpZiAob3B0aW9ucy53ZWJnbCkge1xuICAgIHIuaW5pdFdlYmdsKG9wdGlvbnMsIHtcbiAgICAgIGdldFN0eWxlS2V5OiBnZXRTdHlsZUtleSxcbiAgICAgIGdldExhYmVsS2V5OiBnZXRMYWJlbEtleSxcbiAgICAgIGdldFNvdXJjZUxhYmVsS2V5OiBnZXRTb3VyY2VMYWJlbEtleSxcbiAgICAgIGdldFRhcmdldExhYmVsS2V5OiBnZXRUYXJnZXRMYWJlbEtleSxcbiAgICAgIGRyYXdFbGVtZW50OiBkcmF3RWxlbWVudCxcbiAgICAgIGRyYXdMYWJlbDogZHJhd0xhYmVsLFxuICAgICAgZHJhd1NvdXJjZUxhYmVsOiBkcmF3U291cmNlTGFiZWwsXG4gICAgICBkcmF3VGFyZ2V0TGFiZWw6IGRyYXdUYXJnZXRMYWJlbCxcbiAgICAgIGdldEVsZW1lbnRCb3g6IGdldEVsZW1lbnRCb3gsXG4gICAgICBnZXRMYWJlbEJveDogZ2V0TGFiZWxCb3gsXG4gICAgICBnZXRTb3VyY2VMYWJlbEJveDogZ2V0U291cmNlTGFiZWxCb3gsXG4gICAgICBnZXRUYXJnZXRMYWJlbEJveDogZ2V0VGFyZ2V0TGFiZWxCb3gsXG4gICAgICBnZXRFbGVtZW50Um90YXRpb25Qb2ludDogZ2V0RWxlbWVudFJvdGF0aW9uUG9pbnQsXG4gICAgICBnZXRFbGVtZW50Um90YXRpb25PZmZzZXQ6IGdldEVsZW1lbnRSb3RhdGlvbk9mZnNldCxcbiAgICAgIGdldExhYmVsUm90YXRpb25Qb2ludDogZ2V0TGFiZWxSb3RhdGlvblBvaW50LFxuICAgICAgZ2V0U291cmNlTGFiZWxSb3RhdGlvblBvaW50OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQsXG4gICAgICBnZXRUYXJnZXRMYWJlbFJvdGF0aW9uUG9pbnQ6IGdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCxcbiAgICAgIGdldExhYmVsUm90YXRpb25PZmZzZXQ6IGdldExhYmVsUm90YXRpb25PZmZzZXQsXG4gICAgICBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0OiBnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0LFxuICAgICAgZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldDogZ2V0VGFyZ2V0TGFiZWxSb3RhdGlvbk9mZnNldFxuICAgIH0pO1xuICB9XG59XG5DUnAucmVkcmF3SGludCA9IGZ1bmN0aW9uIChncm91cCwgYm9vbCkge1xuICB2YXIgciA9IHRoaXM7XG4gIHN3aXRjaCAoZ3JvdXApIHtcbiAgICBjYXNlICdlbGVzJzpcbiAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDUnAuTk9ERV0gPSBib29sO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZHJhZyc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLkRSQUddID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1JwLlNFTEVDVF9CT1hdID0gYm9vbDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2djJzpcbiAgICAgIHIuZGF0YS5nYyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gd2hldGhlciB0byB1c2UgUGF0aDJEIGNhY2hpbmcgZm9yIGRyYXdpbmdcbnZhciBwYXRoc0ltcGxkID0gdHlwZW9mIFBhdGgyRCAhPT0gJ3VuZGVmaW5lZCc7XG5DUnAucGF0aDJkRW5hYmxlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhzRW5hYmxlZDtcbiAgfVxuICB0aGlzLnBhdGhzRW5hYmxlZCA9IG9uID8gdHJ1ZSA6IGZhbHNlO1xufTtcbkNScC51c2VQYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHBhdGhzSW1wbGQgJiYgdGhpcy5wYXRoc0VuYWJsZWQ7XG59O1xuQ1JwLnNldEltZ1Ntb290aGluZyA9IGZ1bmN0aW9uIChjb250ZXh0LCBib29sKSB7XG4gIGlmIChjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCAhPSBudWxsKSB7XG4gICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBib29sO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gYm9vbDtcbiAgICBjb250ZXh0Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gICAgY29udGV4dC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGJvb2w7XG4gIH1cbn07XG5DUnAuZ2V0SW1nU21vb3RoaW5nID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9IG51bGwpIHtcbiAgICByZXR1cm4gY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkIHx8IGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQ7XG4gIH1cbn07XG5DUnAubWFrZU9mZnNjcmVlbkNhbnZhcyA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gIHZhciBjYW52YXM7XG4gIGlmICgodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKE9mZnNjcmVlbkNhbnZhcykpICE9PSAoXCJ1bmRlZmluZWRcIiApKSB7XG4gICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyV2luZG93ID0gdGhpcy5jeS53aW5kb3coKTtcbiAgICB2YXIgZG9jdW1lbnQgPSBjb250YWluZXJXaW5kb3cuZG9jdW1lbnQ7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIHJldHVybiBjYW52YXM7XG59O1xuW0NScCRiLCBDUnAkYSwgQ1JwJDksIENScCQ4LCBDUnAkNywgQ1JwJDYsIENScCQ1LCBDUnAkNCwgQ1JwJDMsIENScCQyLCBDUnAkMV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgZXh0ZW5kKENScCwgcHJvcHMpO1xufSk7XG5cbnZhciByZW5kZXJlciA9IFt7XG4gIG5hbWU6ICdudWxsJyxcbiAgaW1wbDogTnVsbFJlbmRlcmVyXG59LCB7XG4gIG5hbWU6ICdiYXNlJyxcbiAgaW1wbDogQlJcbn0sIHtcbiAgbmFtZTogJ2NhbnZhcycsXG4gIGltcGw6IENSXG59XTtcblxudmFyIGluY0V4dHMgPSBbe1xuICB0eXBlOiAnbGF5b3V0JyxcbiAgZXh0ZW5zaW9uczogbGF5b3V0XG59LCB7XG4gIHR5cGU6ICdyZW5kZXJlcicsXG4gIGV4dGVuc2lvbnM6IHJlbmRlcmVyXG59XTtcblxuLy8gcmVnaXN0ZXJlZCBleHRlbnNpb25zIHRvIGN5dG9zY2FwZSwgaW5kZXhlZCBieSBuYW1lXG52YXIgZXh0ZW5zaW9ucyA9IHt9O1xuXG4vLyByZWdpc3RlcmVkIG1vZHVsZXMgZm9yIGV4dGVuc2lvbnMsIGluZGV4ZWQgYnkgbmFtZVxudmFyIG1vZHVsZXMgPSB7fTtcbmZ1bmN0aW9uIHNldEV4dGVuc2lvbih0eXBlLCBuYW1lLCByZWdpc3RyYW50KSB7XG4gIHZhciBleHQgPSByZWdpc3RyYW50O1xuICB2YXIgb3ZlcnJpZGVFcnIgPSBmdW5jdGlvbiBvdmVycmlkZUVycihmaWVsZCkge1xuICAgIHdhcm4oJ0NhbiBub3QgcmVnaXN0ZXIgYCcgKyBuYW1lICsgJ2AgZm9yIGAnICsgdHlwZSArICdgIHNpbmNlIGAnICsgZmllbGQgKyAnYCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgcHJvdG90eXBlIGFuZCBjYW4gbm90IGJlIG92ZXJyaWRkZW4nKTtcbiAgfTtcbiAgaWYgKHR5cGUgPT09ICdjb3JlJykge1xuICAgIGlmIChDb3JlLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb3JlLnByb3RvdHlwZVtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb2xsZWN0aW9uJykge1xuICAgIGlmIChDb2xsZWN0aW9uLnByb3RvdHlwZVtuYW1lXSkge1xuICAgICAgcmV0dXJuIG92ZXJyaWRlRXJyKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsYXlvdXQnKSB7XG4gICAgLy8gZmlsbCBpbiBtaXNzaW5nIGxheW91dCBmdW5jdGlvbnMgaW4gdGhlIHByb3RvdHlwZVxuXG4gICAgdmFyIExheW91dCA9IGZ1bmN0aW9uIExheW91dChvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgcmVnaXN0cmFudC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgbGF5b3V0IGhhcyBfcHJpdmF0ZSBmb3IgdXNlIHcvIHN0ZCBhcGlzIGxpa2UgLm9uKClcbiAgICAgIGlmICghcGxhaW5PYmplY3QodGhpcy5fcHJpdmF0ZSkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZSA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5fcHJpdmF0ZS5jeSA9IG9wdGlvbnMuY3k7XG4gICAgICB0aGlzLl9wcml2YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgdGhpcy5jcmVhdGVFbWl0dGVyKCk7XG4gICAgfTtcbiAgICB2YXIgbGF5b3V0UHJvdG8gPSBMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShyZWdpc3RyYW50LnByb3RvdHlwZSk7XG4gICAgdmFyIG9wdExheW91dEZucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0TGF5b3V0Rm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZm5OYW1lID0gb3B0TGF5b3V0Rm5zW2ldO1xuICAgICAgbGF5b3V0UHJvdG9bZm5OYW1lXSA9IGxheW91dFByb3RvW2ZuTmFtZV0gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuICAgIGlmIChsYXlvdXRQcm90by5zdGFydCAmJiAhbGF5b3V0UHJvdG8ucnVuKSB7XG4gICAgICBsYXlvdXRQcm90by5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIWxheW91dFByb3RvLnN0YXJ0ICYmIGxheW91dFByb3RvLnJ1bikge1xuICAgICAgbGF5b3V0UHJvdG8uc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIHJlZ1N0b3AgPSByZWdpc3RyYW50LnByb3RvdHlwZS5zdG9wO1xuICAgIGxheW91dFByb3RvLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRzICYmIG9wdHMuYW5pbWF0ZSkge1xuICAgICAgICB2YXIgYW5pcyA9IHRoaXMuYW5pbWF0aW9ucztcbiAgICAgICAgaWYgKGFuaXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYW5pcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFuaXNbX2ldLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWdTdG9wKSB7XG4gICAgICAgIHJlZ1N0b3AuY2FsbCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RvcCcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBpZiAoIWxheW91dFByb3RvLmRlc3Ryb3kpIHtcbiAgICAgIGxheW91dFByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9XG4gICAgbGF5b3V0UHJvdG8uY3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB9O1xuICAgIHZhciBnZXRDeSA9IGZ1bmN0aW9uIGdldEN5KGxheW91dCkge1xuICAgICAgcmV0dXJuIGxheW91dC5fcHJpdmF0ZS5jeTtcbiAgICB9O1xuICAgIHZhciBlbWl0dGVyT3B0cyA9IHtcbiAgICAgIGFkZEV2ZW50RmllbGRzOiBmdW5jdGlvbiBhZGRFdmVudEZpZWxkcyhsYXlvdXQsIGV2dCkge1xuICAgICAgICBldnQubGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICBldnQuY3kgPSBnZXRDeShsYXlvdXQpO1xuICAgICAgICBldnQudGFyZ2V0ID0gbGF5b3V0O1xuICAgICAgfSxcbiAgICAgIGJ1YmJsZTogZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChsYXlvdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldEN5KGxheW91dCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBleHRlbmQobGF5b3V0UHJvdG8sIHtcbiAgICAgIGNyZWF0ZUVtaXR0ZXI6IGZ1bmN0aW9uIGNyZWF0ZUVtaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuZW1pdHRlciA9IG5ldyBFbWl0dGVyKGVtaXR0ZXJPcHRzLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgZW1pdHRlcjogZnVuY3Rpb24gZW1pdHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZW1pdHRlcjtcbiAgICAgIH0sXG4gICAgICBvbjogZnVuY3Rpb24gb24oZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbihldnQsIGNiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgb25lOiBmdW5jdGlvbiBvbmUoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG9uY2U6IGZ1bmN0aW9uIG9uY2UoZXZ0LCBjYikge1xuICAgICAgICB0aGlzLmVtaXR0ZXIoKS5vbmUoZXZ0LCBjYik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldnQsIGNiKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlcigpLnJlbW92ZUxpc3RlbmVyKGV2dCwgY2IpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICByZW1vdmVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZ0LCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyKCkuZW1pdChldnQsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlZmluZS5ldmVudEFsaWFzZXNPbihsYXlvdXRQcm90byk7XG4gICAgZXh0ID0gTGF5b3V0OyAvLyByZXBsYWNlIHdpdGggb3VyIHdyYXBwZWQgbGF5b3V0XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlbmRlcmVyJyAmJiBuYW1lICE9PSAnbnVsbCcgJiYgbmFtZSAhPT0gJ2Jhc2UnKSB7XG4gICAgLy8gdXNlciByZWdpc3RlcmVkIHJlbmRlcmVycyBpbmhlcml0IGZyb20gYmFzZVxuXG4gICAgdmFyIEJhc2VSZW5kZXJlciA9IGdldEV4dGVuc2lvbigncmVuZGVyZXInLCAnYmFzZScpO1xuICAgIHZhciBiUHJvdG8gPSBCYXNlUmVuZGVyZXIucHJvdG90eXBlO1xuICAgIHZhciBSZWdpc3RyYW50UmVuZGVyZXIgPSByZWdpc3RyYW50O1xuICAgIHZhciByUHJvdG8gPSByZWdpc3RyYW50LnByb3RvdHlwZTtcbiAgICB2YXIgUmVuZGVyZXIgPSBmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgICAgIEJhc2VSZW5kZXJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgUmVnaXN0cmFudFJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB2YXIgcHJvdG8gPSBSZW5kZXJlci5wcm90b3R5cGU7XG4gICAgZm9yICh2YXIgcE5hbWUgaW4gYlByb3RvKSB7XG4gICAgICB2YXIgcFZhbCA9IGJQcm90b1twTmFtZV07XG4gICAgICB2YXIgZXhpc3RzSW5SID0gclByb3RvW3BOYW1lXSAhPSBudWxsO1xuICAgICAgaWYgKGV4aXN0c0luUikge1xuICAgICAgICByZXR1cm4gb3ZlcnJpZGVFcnIocE5hbWUpO1xuICAgICAgfVxuICAgICAgcHJvdG9bcE5hbWVdID0gcFZhbDsgLy8gdGFrZSBpbXBsIGZyb20gYmFzZVxuICAgIH1cbiAgICBmb3IgKHZhciBfcE5hbWUgaW4gclByb3RvKSB7XG4gICAgICBwcm90b1tfcE5hbWVdID0gclByb3RvW19wTmFtZV07IC8vIHRha2UgaW1wbCBmcm9tIHJlZ2lzdHJhbnRcbiAgICB9XG4gICAgYlByb3RvLmNsaWVudEZ1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IHByb3RvW25hbWVdIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXJyb3IoJ1JlbmRlcmVyIGRvZXMgbm90IGltcGxlbWVudCBgcmVuZGVyZXIuJyArIG5hbWUgKyAnKClgIG9uIGl0cyBwcm90b3R5cGUnKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgZXh0ID0gUmVuZGVyZXI7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ19fcHJvdG9fXycgfHwgdHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCB0eXBlID09PSAncHJvdG90eXBlJykge1xuICAgIC8vIHRvIGF2b2lkIHBvdGVudGlhbCBwcm90b3R5cGUgcG9sbHV0aW9uXG4gICAgcmV0dXJuIGVycm9yKHR5cGUgKyAnIGlzIGFuIGlsbGVnYWwgdHlwZSB0byBiZSByZWdpc3RlcmVkLCBwb3NzaWJseSBsZWFkIHRvIHByb3RvdHlwZSBwb2xsdXRpb25zJyk7XG4gIH1cbiAgcmV0dXJuIHNldE1hcCh7XG4gICAgbWFwOiBleHRlbnNpb25zLFxuICAgIGtleXM6IFt0eXBlLCBuYW1lXSxcbiAgICB2YWx1ZTogZXh0XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUpIHtcbiAgcmV0dXJuIGdldE1hcCh7XG4gICAgbWFwOiBleHRlbnNpb25zLFxuICAgIGtleXM6IFt0eXBlLCBuYW1lXVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lLCByZWdpc3RyYW50KSB7XG4gIHJldHVybiBzZXRNYXAoe1xuICAgIG1hcDogbW9kdWxlcyxcbiAgICBrZXlzOiBbdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZV0sXG4gICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRNb2R1bGUodHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSkge1xuICByZXR1cm4gZ2V0TWFwKHtcbiAgICBtYXA6IG1vZHVsZXMsXG4gICAga2V5czogW3R5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWVdXG4gIH0pO1xufVxudmFyIGV4dGVuc2lvbiA9IGZ1bmN0aW9uIGV4dGVuc2lvbigpIHtcbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycpXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIGdldEV4dGVuc2lvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLy8gZS5nLiBleHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsIHsgLi4uIH0pXG4gIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gc2V0RXh0ZW5zaW9uLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvLyBlLmcuIGV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8vIGUuZy4gZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnLCB7IC4uLiB9KVxuICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XG4gICAgcmV0dXJuIHNldE1vZHVsZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9IGVsc2Uge1xuICAgIGVycm9yKCdJbnZhbGlkIGV4dGVuc2lvbiBhY2Nlc3Mgc3ludGF4Jyk7XG4gIH1cbn07XG5cbi8vIGFsbG93cyBhIGNvcmUgaW5zdGFuY2UgdG8gYWNjZXNzIGV4dGVuc2lvbnMgaW50ZXJuYWxseVxuQ29yZS5wcm90b3R5cGUuZXh0ZW5zaW9uID0gZXh0ZW5zaW9uO1xuXG4vLyBpbmNsdWRlZCBleHRlbnNpb25zXG5pbmNFeHRzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gIGdyb3VwLmV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZXh0KSB7XG4gICAgc2V0RXh0ZW5zaW9uKGdyb3VwLnR5cGUsIGV4dC5uYW1lLCBleHQuaW1wbCk7XG4gIH0pO1xufSk7XG5cbi8vIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3QgdGhhdCBkb2Vzbid0IG5lZWQgYSByZWZlcmVuY2UgdG8gdGhlIGNvcmVcbi8vICh1c2VmdWwgZm9yIGluaXQpXG52YXIgX1N0eWxlc2hlZXQgPSBmdW5jdGlvbiBTdHlsZXNoZWV0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgX1N0eWxlc2hlZXQpKSB7XG4gICAgcmV0dXJuIG5ldyBfU3R5bGVzaGVldCgpO1xuICB9XG4gIHRoaXMubGVuZ3RoID0gMDtcbn07XG52YXIgc2hlZXRmbiA9IF9TdHlsZXNoZWV0LnByb3RvdHlwZTtcbnNoZWV0Zm4uaW5zdGFuY2VTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnc3R5bGVzaGVldCc7XG59O1xuXG4vLyBqdXN0IHN0b3JlIHRoZSBzZWxlY3RvciB0byBiZSBwYXJzZWQgbGF0ZXJcbnNoZWV0Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuICB0aGlzW2ldID0ge1xuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBwcm9wZXJ0aWVzOiBbXVxuICB9O1xuICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbn07XG5cbi8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuc2hlZXRmbi5jc3MgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgdmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gIGlmIChzdHJpbmcobmFtZSkpIHtcbiAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocGxhaW5PYmplY3QobmFtZSkpIHtcbiAgICB2YXIgbWFwID0gbmFtZTtcbiAgICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHByb3BOYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGtleSA9IHByb3BOYW1lc1tqXTtcbiAgICAgIHZhciBtYXBWYWwgPSBtYXBba2V5XTtcbiAgICAgIGlmIChtYXBWYWwgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wID0gX1N0eWxlLnByb3BlcnRpZXNba2V5XSB8fCBfU3R5bGUucHJvcGVydGllc1tkYXNoMmNhbWVsKGtleSldO1xuICAgICAgaWYgKHByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBfbmFtZSA9IHByb3AubmFtZTtcbiAgICAgIHZhciBfdmFsdWUgPSBtYXBWYWw7XG4gICAgICB0aGlzW2ldLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IF9uYW1lLFxuICAgICAgICB2YWx1ZTogX3ZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG59O1xuc2hlZXRmbi5zdHlsZSA9IHNoZWV0Zm4uY3NzO1xuXG4vLyBnZW5lcmF0ZSBhIHJlYWwgc3R5bGUgb2JqZWN0IGZyb20gdGhlIGR1bW15IHN0eWxlc2hlZXRcbnNoZWV0Zm4uZ2VuZXJhdGVTdHlsZSA9IGZ1bmN0aW9uIChjeSkge1xuICB2YXIgc3R5bGUgPSBuZXcgX1N0eWxlKGN5KTtcbiAgcmV0dXJuIHRoaXMuYXBwZW5kVG9TdHlsZShzdHlsZSk7XG59O1xuXG4vLyBhcHBlbmQgYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCBvbiBhIHJlYWwgc3R5bGUgb2JqZWN0XG5zaGVldGZuLmFwcGVuZFRvU3R5bGUgPSBmdW5jdGlvbiAoc3R5bGUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzW2ldO1xuICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgdmFyIHByb3BzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuICAgIHN0eWxlLnNlbGVjdG9yKHNlbGVjdG9yKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICBzdHlsZS5jc3MocHJvcC5uYW1lLCBwcm9wLnZhbHVlKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlO1xufTtcblxudmFyIHZlcnNpb24gPSBcIjMuMzMuMVwiO1xuXG52YXIgY3l0b3NjYXBlID0gZnVuY3Rpb24gY3l0b3NjYXBlKG9wdGlvbnMpIHtcbiAgLy8gaWYgbm8gb3B0aW9ucyBzcGVjaWZpZWQsIHVzZSBkZWZhdWx0XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICAvLyBjcmVhdGUgaW5zdGFuY2VcbiAgaWYgKHBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb3JlKG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gYWxsb3cgZm9yIHJlZ2lzdHJhdGlvbiBvZiBleHRlbnNpb25zXG4gIGVsc2UgaWYgKHN0cmluZyhvcHRpb25zKSkge1xuICAgIHJldHVybiBleHRlbnNpb24uYXBwbHkoZXh0ZW5zaW9uLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG4vLyBlLmcuIGN5dG9zY2FwZS51c2UoIHJlcXVpcmUoJ2N5dG9zY2FwZS1mb28nKSwgYmFyIClcbmN5dG9zY2FwZS51c2UgPSBmdW5jdGlvbiAoZXh0KSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gYXJncyB0byBwYXNzIHRvIGV4dFxuXG4gIGFyZ3MudW5zaGlmdChjeXRvc2NhcGUpOyAvLyBjeXRvc2NhcGUgaXMgZmlyc3QgYXJnIHRvIGV4dFxuXG4gIGV4dC5hcHBseShudWxsLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuY3l0b3NjYXBlLndhcm5pbmdzID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgcmV0dXJuIHdhcm5pbmdzKGJvb2wpO1xufTtcblxuLy8gcmVwbGFjZWQgYnkgYnVpbGQgc3lzdGVtXG5jeXRvc2NhcGUudmVyc2lvbiA9IHZlcnNpb247XG5cbi8vIGV4cG9zZSBwdWJsaWMgYXBpcyAobW9zdGx5IGZvciBleHRlbnNpb25zKVxuY3l0b3NjYXBlLnN0eWxlc2hlZXQgPSBjeXRvc2NhcGUuU3R5bGVzaGVldCA9IF9TdHlsZXNoZWV0O1xuXG5leHBvcnQgeyBjeXRvc2NhcGUgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIl9hcnJheUxpa2VUb0FycmF5IiwiciIsImEiLCJsZW5ndGgiLCJlIiwibiIsIkFycmF5IiwiX2FycmF5V2l0aEhvbGVzIiwiaXNBcnJheSIsIl9hcnJheVdpdGhvdXRIb2xlcyIsIl9jbGFzc0NhbGxDaGVjayIsIlR5cGVFcnJvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidCIsIm8iLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl90b1Byb3BlcnR5S2V5Iiwia2V5IiwiX2NyZWF0ZUNsYXNzIiwicHJvdG90eXBlIiwiX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIkYiLCJzIiwiZG9uZSIsInZhbHVlIiwiZiIsInUiLCJjYWxsIiwibmV4dCIsInJldHVybiIsIl9kZWZpbmVQcm9wZXJ0eSQxIiwiX2l0ZXJhYmxlVG9BcnJheSIsImZyb20iLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJsIiwiaSIsInB1c2giLCJfbm9uSXRlcmFibGVSZXN0IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiX3NsaWNlZFRvQXJyYXkiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsInVuZGVmaW5lZCIsIlN0cmluZyIsIl90eXBlb2YiLCJ0b1N0cmluZyIsInNsaWNlIiwibmFtZSIsInRlc3QiLCJfd2luZG93Iiwid2luZG93IiwibmF2aWdhdG9yIiwiZG9jdW1lbnQiLCJ0eXBlb2ZzdHIiLCJ0eXBlb2ZvYmoiLCJ0eXBlb2ZmbiIsInR5cGVvZmh0bWxlbGUiLCJIVE1MRWxlbWVudCIsImluc3RhbmNlU3RyIiwib2JqIiwiaW5zdGFuY2VTdHJpbmciLCJmbiQ2Iiwic3RyaW5nIiwiZm4iLCJhcnJheSIsImVsZW1lbnRPckNvbGxlY3Rpb24iLCJwbGFpbk9iamVjdCIsIm9iamVjdCIsIm51bWJlciQxIiwibnVtYmVyIiwiaXNOYU4iLCJpbnRlZ2VyIiwiTWF0aCIsImZsb29yIiwiaHRtbEVsZW1lbnQiLCJlbGVtZW50IiwiY29sbGVjdGlvbiIsIl9wcml2YXRlIiwic2luZ2xlIiwiY29yZSIsInN0eWxlc2hlZXQiLCJldmVudCIsImVtcHR5U3RyaW5nIiwibWF0Y2giLCJkb21FbGVtZW50IiwiYm91bmRpbmdCb3giLCJ4MSIsIngyIiwieTEiLCJ5MiIsInByb21pc2UiLCJ0aGVuIiwibXMiLCJ1c2VyQWdlbnQiLCJtZW1vaXplIiwia2V5Rm4iLCJhcmd1bWVudHMiLCJhcmdzIiwiam9pbiIsIl9tZW1vaXplZEZuIiwibWVtb2l6ZWRGbiIsInNlbGYiLCJyZXQiLCJrIiwiYXBwbHkiLCJjYWNoZSIsImNhbWVsMmRhc2giLCJzdHIiLCJyZXBsYWNlIiwidiIsInRvTG93ZXJDYXNlIiwiZGFzaDJjYW1lbCIsInRvVXBwZXJDYXNlIiwicHJlcGVuZENhbWVsIiwicHJlZml4Iiwic3Vic3RyaW5nIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImVuZHNXaXRoIiwic3VmZml4IiwicmdiYSIsInJnYmFOb0JhY2tSZWZzIiwiaHNsYSIsImhzbGFOb0JhY2tSZWZzIiwiaGV4MyIsImhleDYiLCJhc2NlbmRpbmciLCJiIiwiZGVzY2VuZGluZyIsImV4dGVuZCIsImFzc2lnbiIsImJpbmQiLCJ0Z3QiLCJrZXlzIiwiaiIsImhleDJ0dXBsZSIsImhleCIsInNob3J0SGV4IiwiZyIsImJhc2UiLCJwYXJzZUludCIsImhzbDJ0dXBsZSIsImhzbCIsImgiLCJodWUycmdiIiwicCIsInEiLCJtIiwiUmVnRXhwIiwiZXhlYyIsInBhcnNlRmxvYXQiLCJyb3VuZCIsInJnYjJ0dXBsZSIsInJnYiIsImlzUGN0IiwiY2hhbm5lbCIsImF0TGVhc3RPbmVJc1BjdCIsImFsbEFyZVBjdCIsImFscGhhIiwiY29sb3JuYW1lMnR1cGxlIiwiY29sb3IiLCJjb2xvcnMiLCJjb2xvcjJ0dXBsZSIsInRyYW5zcGFyZW50IiwiYWxpY2VibHVlIiwiYW50aXF1ZXdoaXRlIiwiYXF1YSIsImFxdWFtYXJpbmUiLCJhenVyZSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuY2hlZGFsbW9uZCIsImJsdWUiLCJibHVldmlvbGV0IiwiYnJvd24iLCJidXJseXdvb2QiLCJjYWRldGJsdWUiLCJjaGFydHJldXNlIiwiY2hvY29sYXRlIiwiY29yYWwiLCJjb3JuZmxvd2VyYmx1ZSIsImNvcm5zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJkYXJrYmx1ZSIsImRhcmtjeWFuIiwiZGFya2dvbGRlbnJvZCIsImRhcmtncmF5IiwiZGFya2dyZWVuIiwiZGFya2dyZXkiLCJkYXJra2hha2kiLCJkYXJrbWFnZW50YSIsImRhcmtvbGl2ZWdyZWVuIiwiZGFya29yYW5nZSIsImRhcmtvcmNoaWQiLCJkYXJrcmVkIiwiZGFya3NhbG1vbiIsImRhcmtzZWFncmVlbiIsImRhcmtzbGF0ZWJsdWUiLCJkYXJrc2xhdGVncmF5IiwiZGFya3NsYXRlZ3JleSIsImRhcmt0dXJxdW9pc2UiLCJkYXJrdmlvbGV0IiwiZGVlcHBpbmsiLCJkZWVwc2t5Ymx1ZSIsImRpbWdyYXkiLCJkaW1ncmV5IiwiZG9kZ2VyYmx1ZSIsImZpcmVicmljayIsImZsb3JhbHdoaXRlIiwiZm9yZXN0Z3JlZW4iLCJmdWNoc2lhIiwiZ2FpbnNib3JvIiwiZ2hvc3R3aGl0ZSIsImdvbGQiLCJnb2xkZW5yb2QiLCJncmF5IiwiZ3JleSIsImdyZWVuIiwiZ3JlZW55ZWxsb3ciLCJob25leWRldyIsImhvdHBpbmsiLCJpbmRpYW5yZWQiLCJpbmRpZ28iLCJpdm9yeSIsImtoYWtpIiwibGF2ZW5kZXIiLCJsYXZlbmRlcmJsdXNoIiwibGF3bmdyZWVuIiwibGVtb25jaGlmZm9uIiwibGlnaHRibHVlIiwibGlnaHRjb3JhbCIsImxpZ2h0Y3lhbiIsImxpZ2h0Z29sZGVucm9keWVsbG93IiwibGlnaHRncmF5IiwibGlnaHRncmVlbiIsImxpZ2h0Z3JleSIsImxpZ2h0cGluayIsImxpZ2h0c2FsbW9uIiwibGlnaHRzZWFncmVlbiIsImxpZ2h0c2t5Ymx1ZSIsImxpZ2h0c2xhdGVncmF5IiwibGlnaHRzbGF0ZWdyZXkiLCJsaWdodHN0ZWVsYmx1ZSIsImxpZ2h0eWVsbG93IiwibGltZSIsImxpbWVncmVlbiIsImxpbmVuIiwibWFnZW50YSIsIm1hcm9vbiIsIm1lZGl1bWFxdWFtYXJpbmUiLCJtZWRpdW1ibHVlIiwibWVkaXVtb3JjaGlkIiwibWVkaXVtcHVycGxlIiwibWVkaXVtc2VhZ3JlZW4iLCJtZWRpdW1zbGF0ZWJsdWUiLCJtZWRpdW1zcHJpbmdncmVlbiIsIm1lZGl1bXR1cnF1b2lzZSIsIm1lZGl1bXZpb2xldHJlZCIsIm1pZG5pZ2h0Ymx1ZSIsIm1pbnRjcmVhbSIsIm1pc3R5cm9zZSIsIm1vY2Nhc2luIiwibmF2YWpvd2hpdGUiLCJuYXZ5Iiwib2xkbGFjZSIsIm9saXZlIiwib2xpdmVkcmFiIiwib3JhbmdlIiwib3JhbmdlcmVkIiwib3JjaGlkIiwicGFsZWdvbGRlbnJvZCIsInBhbGVncmVlbiIsInBhbGV0dXJxdW9pc2UiLCJwYWxldmlvbGV0cmVkIiwicGFwYXlhd2hpcCIsInBlYWNocHVmZiIsInBlcnUiLCJwaW5rIiwicGx1bSIsInBvd2RlcmJsdWUiLCJwdXJwbGUiLCJyZWQiLCJyb3N5YnJvd24iLCJyb3lhbGJsdWUiLCJzYWRkbGVicm93biIsInNhbG1vbiIsInNhbmR5YnJvd24iLCJzZWFncmVlbiIsInNlYXNoZWxsIiwic2llbm5hIiwic2lsdmVyIiwic2t5Ymx1ZSIsInNsYXRlYmx1ZSIsInNsYXRlZ3JheSIsInNsYXRlZ3JleSIsInNub3ciLCJzcHJpbmdncmVlbiIsInN0ZWVsYmx1ZSIsInRhbiIsInRlYWwiLCJ0aGlzdGxlIiwidG9tYXRvIiwidHVycXVvaXNlIiwidmlvbGV0Iiwid2hlYXQiLCJ3aGl0ZSIsIndoaXRlc21va2UiLCJ5ZWxsb3ciLCJ5ZWxsb3dncmVlbiIsInNldE1hcCIsIm9wdGlvbnMiLCJtYXAiLCJFcnJvciIsImdldE1hcCIsImNvbW1vbmpzR2xvYmFsIiwiZ2xvYmFsVGhpcyIsImdsb2JhbCIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwieCIsIl9fZXNNb2R1bGUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzT2JqZWN0XzEiLCJoYXNSZXF1aXJlZElzT2JqZWN0IiwicmVxdWlyZUlzT2JqZWN0IiwiaXNPYmplY3QiLCJ0eXBlIiwiX2ZyZWVHbG9iYWwiLCJoYXNSZXF1aXJlZF9mcmVlR2xvYmFsIiwicmVxdWlyZV9mcmVlR2xvYmFsIiwiZnJlZUdsb2JhbCIsIl9yb290IiwiaGFzUmVxdWlyZWRfcm9vdCIsInJlcXVpcmVfcm9vdCIsImZyZWVTZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwibm93XzEiLCJoYXNSZXF1aXJlZE5vdyIsInJlcXVpcmVOb3ciLCJub3ciLCJEYXRlIiwiX3RyaW1tZWRFbmRJbmRleCIsImhhc1JlcXVpcmVkX3RyaW1tZWRFbmRJbmRleCIsInJlcXVpcmVfdHJpbW1lZEVuZEluZGV4IiwicmVXaGl0ZXNwYWNlIiwidHJpbW1lZEVuZEluZGV4IiwiaW5kZXgiLCJfYmFzZVRyaW0iLCJoYXNSZXF1aXJlZF9iYXNlVHJpbSIsInJlcXVpcmVfYmFzZVRyaW0iLCJyZVRyaW1TdGFydCIsImJhc2VUcmltIiwiX1N5bWJvbCIsImhhc1JlcXVpcmVkX1N5bWJvbCIsInJlcXVpcmVfU3ltYm9sIiwiX2dldFJhd1RhZyIsImhhc1JlcXVpcmVkX2dldFJhd1RhZyIsInJlcXVpcmVfZ2V0UmF3VGFnIiwib2JqZWN0UHJvdG8iLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwidG9TdHJpbmdUYWciLCJnZXRSYXdUYWciLCJpc093biIsInRhZyIsInVubWFza2VkIiwicmVzdWx0IiwiX29iamVjdFRvU3RyaW5nIiwiaGFzUmVxdWlyZWRfb2JqZWN0VG9TdHJpbmciLCJyZXF1aXJlX29iamVjdFRvU3RyaW5nIiwib2JqZWN0VG9TdHJpbmciLCJfYmFzZUdldFRhZyIsImhhc1JlcXVpcmVkX2Jhc2VHZXRUYWciLCJyZXF1aXJlX2Jhc2VHZXRUYWciLCJudWxsVGFnIiwidW5kZWZpbmVkVGFnIiwiYmFzZUdldFRhZyIsImlzT2JqZWN0TGlrZV8xIiwiaGFzUmVxdWlyZWRJc09iamVjdExpa2UiLCJyZXF1aXJlSXNPYmplY3RMaWtlIiwiaXNPYmplY3RMaWtlIiwiaXNTeW1ib2xfMSIsImhhc1JlcXVpcmVkSXNTeW1ib2wiLCJyZXF1aXJlSXNTeW1ib2wiLCJzeW1ib2xUYWciLCJpc1N5bWJvbCIsInRvTnVtYmVyXzEiLCJoYXNSZXF1aXJlZFRvTnVtYmVyIiwicmVxdWlyZVRvTnVtYmVyIiwiTkFOIiwicmVJc0JhZEhleCIsInJlSXNCaW5hcnkiLCJyZUlzT2N0YWwiLCJmcmVlUGFyc2VJbnQiLCJ0b051bWJlciIsIm90aGVyIiwidmFsdWVPZiIsImlzQmluYXJ5IiwiZGVib3VuY2VfMSIsImhhc1JlcXVpcmVkRGVib3VuY2UiLCJyZXF1aXJlRGVib3VuY2UiLCJGVU5DX0VSUk9SX1RFWFQiLCJuYXRpdmVNYXgiLCJtYXgiLCJuYXRpdmVNaW4iLCJtaW4iLCJkZWJvdW5jZSIsImZ1bmMiLCJ3YWl0IiwibGFzdEFyZ3MiLCJsYXN0VGhpcyIsIm1heFdhaXQiLCJ0aW1lcklkIiwibGFzdENhbGxUaW1lIiwibGFzdEludm9rZVRpbWUiLCJsZWFkaW5nIiwibWF4aW5nIiwidHJhaWxpbmciLCJpbnZva2VGdW5jIiwidGltZSIsInRoaXNBcmciLCJsZWFkaW5nRWRnZSIsInNldFRpbWVvdXQiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwidGltZVdhaXRpbmciLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJjbGVhclRpbWVvdXQiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWJvdW5jZUV4cG9ydHMiLCJwZXJmb3JtYW5jZSQxIiwicGVyZm9ybWFuY2UiLCJwbm93IiwicmFmIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwid2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJwZXJmb3JtYW5jZU5vdyIsIkRFRkFVTFRfSEFTSF9TRUVEIiwiSyIsIkRFRkFVTFRfSEFTSF9TRUVEX0FMVCIsImhhc2hJdGVyYWJsZUludHMiLCJzZWVkIiwiaGFzaCIsImVudHJ5IiwiaGFzaEludCIsIm51bSIsImhhc2hJbnRBbHQiLCJjb21iaW5lSGFzaGVzIiwiaGFzaDEiLCJoYXNoMiIsImNvbWJpbmVIYXNoZXNBcnJheSIsImhhc2hlcyIsImhhc2hBcnJheXMiLCJoYXNoZXMxIiwiaGFzaGVzMiIsImhhc2hJbnRzQXJyYXkiLCJpbnRzIiwiaGFzaFN0cmluZyIsImNoYXJDb2RlQXQiLCJoYXNoU3RyaW5ncyIsImhhc2hTdHJpbmdzQXJyYXkiLCJzdHJzIiwicm90YXRlUG9pbnQiLCJ5IiwiY2VudGVyWCIsImNlbnRlclkiLCJhbmdsZURlZ3JlZXMiLCJhbmdsZVJhZGlhbnMiLCJQSSIsInJvdGF0ZWRYIiwiY29zIiwic2luIiwicm90YXRlZFkiLCJtb3ZlUG9pbnRCeUJveEFzcGVjdCIsImJveFgiLCJib3hZIiwic2tld1giLCJza2V3WSIsInJvdGF0ZVBvc0FuZFNrZXdCeUJveCIsInBvcyIsImJveCIsInciLCJyb3RhdGVkIiwic2tld2VkIiwid2FybmluZ3NFbmFibGVkIiwid2FyblN1cHBvcnRlZCIsImNvbnNvbGUiLCJ3YXJuIiwidHJhY2VTdXBwb3J0ZWQiLCJ0cmFjZSIsIk1BWF9JTlQkMSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJ0cnVlaWZ5IiwiZmFsc2lmeSIsInplcm9pZnkiLCJub29wJDEiLCJub29wIiwiZXJyb3IiLCJtc2ciLCJ3YXJuaW5ncyIsImVuYWJsZWQiLCJsb2ciLCJjbG9uZSIsImNvcHkiLCJjb3B5QXJyYXkiLCJhcnIiLCJ1dWlkIiwicmFuZG9tIiwiX3N0YXRpY0VtcHR5T2JqZWN0Iiwic3RhdGljRW1wdHlPYmplY3QiLCJkZWZhdWx0cyRnIiwiZGVmYXVsdHMiLCJfZGVmYXVsdHMiLCJvcHRzIiwiZmlsbGVkT3B0cyIsIm9wdFZhbCIsInJlbW92ZUZyb21BcnJheSIsImVsZSIsIm9uZUNvcHkiLCJzcGxpY2UiLCJjbGVhckFycmF5Iiwib3RoZXJBcnIiLCJlbCIsImdldFByZWZpeGVkUHJvcGVydHkiLCJwcm9wTmFtZSIsInNldFByZWZpeGVkUHJvcGVydHkiLCJPYmplY3RNYXAiLCJfb2JqIiwic2V0IiwidmFsIiwiX2RlbGV0ZSIsImNsZWFyIiwiaGFzIiwiZ2V0IiwiTWFwJDEiLCJNYXAiLCJ1bmRlZiIsIk9iamVjdFNldCIsImFycmF5T3JPYmplY3RTZXQiLCJjcmVhdGUiLCJzaXplIiwidG9BcnJheSIsImFkZCIsIl90aGlzIiwiZmlsdGVyIiwiZm9yRWFjaCIsImNhbGxiYWNrIiwiU2V0JDEiLCJTZXQiLCJFbGVtZW50IiwiY3kiLCJwYXJhbXMiLCJyZXN0b3JlIiwiZ3JvdXAiLCJkYXRhIiwic291cmNlIiwidGFyZ2V0IiwiX3AiLCJwb3NpdGlvbiIsImF1dG9XaWR0aCIsImF1dG9IZWlnaHQiLCJhdXRvUGFkZGluZyIsImNvbXBvdW5kQm91bmRzQ2xlYW4iLCJsaXN0ZW5lcnMiLCJzdHlsZSIsInJzdHlsZSIsInN0eWxlQ3h0cyIsInN0eWxlS2V5cyIsInJlbW92ZWQiLCJzZWxlY3RlZCIsInNlbGVjdGFibGUiLCJsb2NrZWQiLCJncmFiYmVkIiwiZ3JhYmJhYmxlIiwicGFubmFibGUiLCJhY3RpdmUiLCJjbGFzc2VzIiwiYW5pbWF0aW9uIiwiY3VycmVudCIsInF1ZXVlIiwicnNjcmF0Y2giLCJzY3JhdGNoIiwiZWRnZXMiLCJjaGlsZHJlbiIsInBhcmVudCIsImlzTm9kZSIsInRyYXZlcnNhbENhY2hlIiwiYmFja2dyb3VuZGluZyIsImJiQ2FjaGUiLCJiYkNhY2hlU2hpZnQiLCJib2R5Qm91bmRzIiwib3ZlcmxheUJvdW5kcyIsImxhYmVsQm91bmRzIiwiYWxsIiwibWFpbiIsImFycm93Qm91bmRzIiwicmVuZGVyZWRQb3NpdGlvbiIsInJwb3MiLCJwYW4iLCJ6b29tIiwic3BsaXQiLCJjbHMiLCJjcmVhdGVFbWl0dGVyIiwiYnlwYXNzIiwiY3NzIiwiZGVmaW5lU2VhcmNoIiwiYmZzIiwiZGZzIiwic2VhcmNoRm4iLCJyb290cyIsImRpcmVjdGVkIiwidmlzaXQiLCJRIiwiY29ubmVjdGVkTm9kZXMiLCJjb25uZWN0ZWRCeSIsImlkMmRlcHRoIiwiViIsImZvdW5kIiwiX3RoaXMkYnlHcm91cCIsImJ5R3JvdXAiLCJub2RlcyIsInZpIiwidmlJZCIsImlkIiwidW5zaGlmdCIsIl9sb29wIiwic2hpZnQiLCJwb3AiLCJ2SWQiLCJkZXB0aCIsInByZXZFZGdlIiwic3JjIiwicHJldk5vZGUiLCJzYW1lIiwidndFZGdlcyIsImNvbm5lY3RlZEVkZ2VzIiwiX2kyIiwid0lkIiwiX3JldCIsImNvbm5lY3RlZEVsZXMiLCJfaSIsIm5vZGUiLCJlZGdlIiwicGF0aCIsImVsZXNmbiR2IiwiYnJlYWR0aEZpcnN0U2VhcmNoIiwiZGVwdGhGaXJzdFNlYXJjaCIsImhlYXAkMiIsImV4cG9ydHMiLCJoZWFwJDEiLCJoYXNSZXF1aXJlZEhlYXAkMSIsInJlcXVpcmVIZWFwJDEiLCJtb2R1bGUiLCJIZWFwIiwiZGVmYXVsdENtcCIsImhlYXBpZnkiLCJoZWFwcG9wIiwiaGVhcHB1c2giLCJoZWFwcHVzaHBvcCIsImhlYXByZXBsYWNlIiwiaW5zb3J0Iiwibmxhcmdlc3QiLCJuc21hbGxlc3QiLCJ1cGRhdGVJdGVtIiwiX3NpZnRkb3duIiwiX3NpZnR1cCIsImxvIiwiaGkiLCJjbXAiLCJtaWQiLCJjb25jYXQiLCJpdGVtIiwibGFzdGVsdCIsInJldHVybml0ZW0iLCJfcmVmIiwiX2xlbiIsIl9yZWYxIiwiX3Jlc3VsdHMiLCJfcmVzdWx0czEiLCJfaiIsInJldmVyc2UiLCJpbmRleE9mIiwiZWxlbSIsInNvcnQiLCJsb3MiLCJzdGFydHBvcyIsIm5ld2l0ZW0iLCJwYXJlbnRwb3MiLCJjaGlsZHBvcyIsImVuZHBvcyIsInJpZ2h0cG9zIiwicHVzaHBvcCIsInBlZWsiLCJjb250YWlucyIsImVtcHR5IiwiaGVhcCIsImluc2VydCIsInRvcCIsImZyb250IiwiZmFjdG9yeSIsImhhc1JlcXVpcmVkSGVhcCIsInJlcXVpcmVIZWFwIiwiaGVhcEV4cG9ydHMiLCJkaWprc3RyYURlZmF1bHRzIiwid2VpZ2h0IiwiZWxlc2ZuJHUiLCJkaWprc3RyYSIsIl9kaWprc3RyYURlZmF1bHRzIiwiZWxlcyIsIndlaWdodEZuIiwiZGlzdCIsInByZXYiLCJrbm93bkRpc3QiLCJ1bm1lcmdlQnkiLCJpc0xvb3AiLCJnZXREaXN0Iiwic2V0RGlzdCIsImQiLCJJbmZpbml0eSIsImRpc3RCZXR3ZWVuIiwidXZzIiwiZWRnZXNUbyIsImVkZ2VzV2l0aCIsImludGVyc2VjdCIsInNtYWxsZXN0RGlzdGFuY2UiLCJzbWFsbGVzdEVkZ2UiLCJfd2VpZ2h0Iiwic21hbGxldHNEaXN0IiwidWlkIiwibmVpZ2hib3JzIiwibmVpZ2hib3Job29kIiwidmlkIiwidkRpc3QiLCJhbHQiLCJkaXN0YW5jZVRvIiwicGF0aFRvIiwiUyIsInNwYXduIiwiZWxlc2ZuJHQiLCJrcnVza2FsIiwibnVtTm9kZXMiLCJmb3Jlc3QiLCJBIiwiZmluZFNldEluZGV4Iiwic2V0VUluZGV4Iiwic2V0VkluZGV4Iiwic2V0VSIsInNldFYiLCJtZXJnZSIsImFTdGFyRGVmYXVsdHMiLCJnb2FsIiwiaGV1cmlzdGljIiwiZWxlc2ZuJHMiLCJhU3RhciIsIl9hU3RhckRlZmF1bHRzIiwic2lkIiwidGlkIiwiZ1Njb3JlIiwiZlNjb3JlIiwiY2xvc2VkU2V0SWRzIiwib3BlblNldCIsIm9wZW5TZXRJZHMiLCJjYW1lRnJvbSIsImNhbWVGcm9tRWRnZSIsImFkZFRvT3BlblNldCIsImNNaW4iLCJjTWluSWQiLCJwb3BGcm9tT3BlblNldCIsImlzSW5PcGVuU2V0Iiwic3RlcHMiLCJwYXRoTm9kZSIsInBhdGhOb2RlSWQiLCJwYXRoRWRnZSIsImRpc3RhbmNlIiwiaGFzRWxlbWVudFdpdGhJZCIsIndTcmMiLCJ3VGd0Iiwid2lkIiwidGVtcFNjb3JlIiwiZmxveWRXYXJzaGFsbERlZmF1bHRzIiwiZWxlc2ZuJHIiLCJmbG95ZFdhcnNoYWxsIiwiX2Zsb3lkV2Fyc2hhbGxEZWZhdWx0IiwiTiIsIk5zcSIsImF0SW5kZXgiLCJlZGdlTmV4dCIsInN0IiwidHMiLCJpayIsImlqIiwia2oiLCJnZXRBcmdFbGUiLCJpbmRleE9mQXJnRWxlIiwicmVzIiwidG8iLCJmcm9tTm9kZSIsImJlbGxtYW5Gb3JkRGVmYXVsdHMiLCJlbGVzZm4kcSIsImJlbGxtYW5Gb3JkIiwiX2JlbGxtYW5Gb3JkRGVmYXVsdHMiLCJpbmZvTWFwIiwiaGFzTmVnYXRpdmVXZWlnaHRDeWNsZSIsIm5lZ2F0aXZlV2VpZ2h0Q3ljbGVzIiwibnVtRWRnZXMiLCJnZXRJbmZvIiwiZ2V0Tm9kZUZyb21UbyIsIiQiLCJ0aGlzU3RhcnQiLCJlbmQiLCJfZ2V0SW5mbyIsInByZWQiLCJpbmZvIiwicmVwbGFjZWRFZGdlIiwiY2hlY2tGb3JFZGdlUmVwbGFjZW1lbnQiLCJub2RlMSIsIm5vZGUyIiwiaW5mbzEiLCJpbmZvMiIsInNyY0luZm8iLCJ0Z3RJbmZvIiwibmVnYXRpdmVXZWlnaHRDeWNsZUlkcyIsIl9lIiwiX2VkZ2UiLCJfc3JjIiwiX3RndCIsIl93ZWlnaHQyIiwic3JjRGlzdCIsInRndERpc3QiLCJmaW5kTmVnYXRpdmVXZWlnaHRDeWNsZXMiLCJuZWdhdGl2ZU5vZGVzIiwibnVtTmVnYXRpdmVOb2RlcyIsInN0YXJ0IiwiY3ljbGUiLCJfbm9kZSIsInNtYWxsZXN0SWQiLCJzbWFsbGVzdEluZGV4IiwiYyIsImN5Y2xlSWQiLCJzcXJ0MiIsInNxcnQiLCJjb2xsYXBzZSIsImVkZ2VJbmRleCIsIm5vZGVNYXAiLCJyZW1haW5pbmdFZGdlcyIsImVkZ2VJbmZvIiwic291cmNlSW4iLCJ0YXJnZXRJbiIsInBhcnRpdGlvbjEiLCJwYXJ0aXRpb24yIiwibmV3RWRnZXMiLCJjb250cmFjdFVudGlsIiwibWV0YU5vZGVNYXAiLCJzaXplTGltaXQiLCJlbGVzZm4kcCIsImthcmdlclN0ZWluIiwibnVtSXRlciIsImNlaWwiLCJwb3ciLCJMTjIiLCJzdG9wU2l6ZSIsImVkZ2VJbmRleGVzIiwibWluQ3V0U2l6ZSIsIm1pbkN1dEVkZ2VJbmRleGVzIiwibWluQ3V0Tm9kZU1hcCIsIm1ldGFOb2RlTWFwMiIsImNvcHlOb2Rlc01hcCIsIl9pMyIsIml0ZXIiLCJfaTQiLCJlZGdlc1N0YXRlIiwiZWRnZXNTdGF0ZTIiLCJyZXMxIiwicmVzMiIsImN1dCIsIndpdG5lc3NOb2RlUGFydGl0aW9uIiwiX2k1IiwicGFydGl0aW9uSWQiLCJjb25zdHJ1Y3RDb21wb25lbnQiLCJzdWJzZXQiLCJjb21wb25lbnQiLCJjb21wb25lbnRzIiwiX01hdGgkaHlwb3QiLCJjb3B5UG9zaXRpb24iLCJtb2RlbFRvUmVuZGVyZWRQb3NpdGlvbiQxIiwibW9kZWxUb1JlbmRlcmVkUG9zaXRpb24iLCJyZW5kZXJlZFRvTW9kZWxQb3NpdGlvbiIsImFycmF5MnBvaW50IiwiYmVnaW4iLCJpc0Zpbml0ZSIsIm1lYW4iLCJ0b3RhbCIsIm1lZGlhbiIsImluY2x1ZGVIb2xlcyIsIm9mZiIsImxlbiIsImRlZzJyYWQiLCJkZWciLCJnZXRBbmdsZUZyb21EaXNwIiwiZGlzcFgiLCJkaXNwWSIsImF0YW4yIiwibG9nMiIsInNpZ251bSIsInAxIiwicDIiLCJzcWRpc3QiLCJkeCIsImR5IiwiaW5QbGFjZVN1bU5vcm1hbGl6ZSIsInFiZXppZXJBdCIsInAwIiwicWJlemllclB0QXQiLCJsaW5lQXQiLCJ2ZWMiLCJ2ZWNEaXN0Iiwibm9ybVZlYyIsImJvdW5kIiwibWFrZUJvdW5kaW5nQm94IiwiYmIiLCJjb3B5Qm91bmRpbmdCb3giLCJjbGVhckJvdW5kaW5nQm94IiwidXBkYXRlQm91bmRpbmdCb3giLCJiYjEiLCJiYjIiLCJleHBhbmRCb3VuZGluZ0JveEJ5UG9pbnQiLCJleHBhbmRCb3VuZGluZ0JveCIsInBhZGRpbmciLCJleHBhbmRCb3VuZGluZ0JveFNpZGVzIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwiX3BhZGRpbmciLCJhc3NpZ25Cb3VuZGluZ0JveCIsImJvdW5kaW5nQm94ZXNJbnRlcnNlY3QiLCJpbkJvdW5kaW5nQm94IiwicG9pbnRJbkJvdW5kaW5nQm94IiwicHQiLCJib3VuZGluZ0JveEluQm91bmRpbmdCb3giLCJoeXBvdCIsImluZmxhdGVQb2x5Z29uIiwicG9seWdvbiIsInN1YiIsInNjYWxlIiwiY3Jvc3MiLCJub3JtYWxpemUiLCJzaWduZWRBcmVhIiwicHRzIiwiaW50ZXJzZWN0TGluZXMiLCJwMyIsInA0IiwiZGVub20iLCJhYnMiLCJub3JtYWxzIiwib3V0Iiwib2Zmc2V0RWRnZXMiLCJucm0iLCJpbmZsYXRlZCIsImN1cnJFZGdlIiwiaXAiLCJtaXRlckJveCIsIndpZHRoIiwiaGVpZ2h0Iiwic3Ryb2tlV2lkdGgiLCJ0cHRzIiwidHJhbnNmb3JtUG9pbnRzIiwib2Zmc2V0UG9pbnRzIiwicm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lIiwibm9kZVgiLCJub2RlWSIsInJhZGl1cyIsImNvcm5lclJhZGl1cyIsImdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzIiwiaGFsZldpZHRoIiwiaGFsZkhlaWdodCIsImRvV2lkdGgiLCJkb0hlaWdodCIsInN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMiLCJ0b3BTdGFydFgiLCJ0b3BTdGFydFkiLCJ0b3BFbmRYIiwidG9wRW5kWSIsImZpbml0ZUxpbmVzSW50ZXJzZWN0IiwicmlnaHRTdGFydFgiLCJyaWdodFN0YXJ0WSIsInJpZ2h0RW5kWCIsInJpZ2h0RW5kWSIsImJvdHRvbVN0YXJ0WCIsImJvdHRvbVN0YXJ0WSIsImJvdHRvbUVuZFgiLCJib3R0b21FbmRZIiwibGVmdFN0YXJ0WCIsImxlZnRTdGFydFkiLCJsZWZ0RW5kWCIsImxlZnRFbmRZIiwiYXJjSW50ZXJzZWN0aW9ucyIsInRvcExlZnRDZW50ZXJYIiwidG9wTGVmdENlbnRlclkiLCJpbnRlcnNlY3RMaW5lQ2lyY2xlIiwidG9wUmlnaHRDZW50ZXJYIiwidG9wUmlnaHRDZW50ZXJZIiwiYm90dG9tUmlnaHRDZW50ZXJYIiwiYm90dG9tUmlnaHRDZW50ZXJZIiwiYm90dG9tTGVmdENlbnRlclgiLCJib3R0b21MZWZ0Q2VudGVyWSIsImluTGluZVZpY2luaXR5IiwibHgxIiwibHkxIiwibHgyIiwibHkyIiwidG9sZXJhbmNlIiwiaW5CZXppZXJWaWNpbml0eSIsIngzIiwieTMiLCJzb2x2ZVF1YWRyYXRpYyIsInNxcnRSIiwicm9vdDEiLCJyb290MiIsInNvbHZlQ3ViaWMiLCJlcHNpbG9uIiwiZGlzY3JpbWluYW50IiwiZHVtMSIsInRlcm0xIiwicjEzIiwiYWNvcyIsInNxZGlzdFRvUXVhZHJhdGljQmV6aWVyIiwiemVyb1RocmVzaG9sZCIsIm1pbkRpc3RhbmNlU3F1YXJlZCIsImN1clgiLCJjdXJZIiwiZGlzdFNxdWFyZWQiLCJzcWRpc3RUb0Zpbml0ZUxpbmUiLCJvZmZzZXQiLCJsaW5lIiwibGluZVNxIiwiaHlwU3EiLCJkb3RQcm9kdWN0IiwiYWRqU3EiLCJwb2ludEluc2lkZVBvbHlnb25Qb2ludHMiLCJwb2ludHMiLCJ1cCIsInBvaW50SW5zaWRlUG9seWdvbiIsImJhc2VQb2ludHMiLCJkaXJlY3Rpb24iLCJ0cmFuc2Zvcm1lZFBvaW50cyIsImFuZ2xlIiwiYXRhbiIsImV4cGFuZGVkTGluZVNldCIsImV4cGFuZFBvbHlnb24iLCJqb2luTGluZXMiLCJwb2ludEluc2lkZVJvdW5kUG9seWdvbiIsImNvcm5lcnMiLCJjdXRQb2x5Z29uUG9pbnRzIiwiY29ybmVyIiwic3RhcnRYIiwic3RhcnRZIiwic3RvcFgiLCJzdG9wWSIsInNxdWFyZWREaXN0YW5jZSIsImN4IiwibGluZVNldCIsInZlcnRpY2VzIiwiY3VycmVudExpbmVTdGFydFgiLCJjdXJyZW50TGluZVN0YXJ0WSIsImN1cnJlbnRMaW5lRW5kWCIsImN1cnJlbnRMaW5lRW5kWSIsIm5leHRMaW5lU3RhcnRYIiwibmV4dExpbmVTdGFydFkiLCJuZXh0TGluZUVuZFgiLCJuZXh0TGluZUVuZFkiLCJpbnRlcnNlY3Rpb24iLCJwYWQiLCJjdXJyZW50UG9pbnRYIiwiY3VycmVudFBvaW50WSIsIm5leHRQb2ludFgiLCJuZXh0UG9pbnRZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJvZmZzZXRMZW5ndGgiLCJub3JtYWxpemVkT2Zmc2V0WCIsIm5vcm1hbGl6ZWRPZmZzZXRZIiwiaW50ZXJzZWN0TGluZUVsbGlwc2UiLCJlbGxpcHNlV3JhZGl1cyIsImVsbGlwc2VIcmFkaXVzIiwibmV3TGVuZ3RoIiwibGVuUHJvcG9ydGlvbiIsImNoZWNrSW5FbGxpcHNlIiwidDEiLCJ0MiIsInRNaW4iLCJ0TWF4IiwiaW5SYW5nZVBhcmFtcyIsIm5lYXJJbnRlcnNlY3Rpb25YIiwibmVhckludGVyc2VjdGlvblkiLCJmYXJJbnRlcnNlY3Rpb25YIiwiZmFySW50ZXJzZWN0aW9uWSIsIm1pZE9mVGhyZWUiLCJ4NCIsInk0IiwiaW5maW5pdGVMaW5lcyIsImR4MTMiLCJkeDIxIiwiZHg0MyIsImR5MTMiLCJkeTIxIiwiZHk0MyIsInVhX3QiLCJ1Yl90IiwidV9iIiwidWEiLCJ1YiIsImZscHRUaHJlc2hvbGQiLCJfbWluIiwiX21heCIsImhhbGZXIiwiaGFsZkgiLCJwb2x5Z29uSW50ZXJzZWN0TGluZSIsImludGVyc2VjdGlvbnMiLCJkb1RyYW5zZm9ybSIsImN1cnJlbnRYIiwiY3VycmVudFkiLCJuZXh0WCIsIm5leHRZIiwicm91bmRQb2x5Z29uSW50ZXJzZWN0TGluZSIsImxpbmVzIiwibG93ZXN0SW50ZXJzZWN0aW9uIiwibG93ZXN0U3F1YXJlZERpc3RhbmNlIiwic2hvcnRlbkludGVyc2VjdGlvbiIsImFtb3VudCIsImRpc3AiLCJsZW5SYXRpbyIsImdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSIsInNpZGVzIiwicm90YXRpb25SYWRpYW5zIiwiZ2VuZXJhdGVVbml0TmdvblBvaW50cyIsImZpdFBvbHlnb25Ub1NxdWFyZSIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJzeCIsInN5IiwiX2k2IiwiaW5jcmVtZW50Iiwic3RhcnRBbmdsZSIsImN1cnJlbnRBbmdsZSIsImdldFJvdW5kUG9seWdvblJhZGl1cyIsImdldEN1dFJlY3RhbmdsZUNvcm5lckxlbmd0aCIsImJlemllclB0c1RvUXVhZENvZWZmIiwiZ2V0QmFycmVsQ3VydmVDb25zdGFudHMiLCJoZWlnaHRPZmZzZXQiLCJ3aWR0aE9mZnNldCIsImN0cmxQdE9mZnNldFBjdCIsInNhdFBvbHlnb25JbnRlcnNlY3Rpb24iLCJwb2x5MSIsInBvbHkyIiwiZ2V0QXhlcyIsImF4ZXMiLCJub3JtYWwiLCJwcm9qZWN0IiwiYXhpcyIsIl9pdGVyYXRvciIsIl9zdGVwIiwicG9pbnQiLCJwcm9qZWN0aW9uIiwiZXJyIiwib3ZlcmxhcHMiLCJwcm9qMSIsInByb2oyIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsInBhZ2VSYW5rRGVmYXVsdHMiLCJkYW1waW5nRmFjdG9yIiwicHJlY2lzaW9uIiwiaXRlcmF0aW9ucyIsImVsZXNmbiRvIiwicGFnZVJhbmsiLCJfcGFnZVJhbmtEZWZhdWx0cyIsIm51bU5vZGVzU3FkIiwibWF0cml4IiwiY29sdW1uU3VtIiwiYWRkaXRpb25hbFByb2IiLCJzcmNJZCIsInRndElkIiwiaW5kZXhPZklkIiwiX24iLCJfbjIiLCJfbjMiLCJlaWdlbnZlY3RvciIsInRlbXAiLCJwcmV2aW91cyIsIl9qMiIsIl9uNCIsImRpZmYiLCJfaTciLCJkZWx0YSIsInJhbmsiLCJkZWZhdWx0cyRmIiwiZWxlc2ZuJG4iLCJkZWdyZWVDZW50cmFsaXR5Tm9ybWFsaXplZCIsImRlZ3JlZXMiLCJtYXhEZWdyZWUiLCJjdXJyRGVncmVlIiwiZGVncmVlQ2VudHJhbGl0eSIsImRlZ3JlZSIsImluZGVncmVlcyIsIm91dGRlZ3JlZXMiLCJtYXhJbmRlZ3JlZSIsIm1heE91dGRlZ3JlZSIsIl9jdXJyRGVncmVlIiwiaW5kZWdyZWUiLCJvdXRkZWdyZWUiLCJjYWxsaW5nRWxlcyIsIl9vcHRpb25zIiwiY29ubkVkZ2VzIiwiaW5jb21pbmciLCJvdXRnb2luZyIsImtfaW4iLCJrX291dCIsInNfaW4iLCJzX291dCIsImRjIiwiZGNuIiwiZGVncmVlQ2VudHJhbGl0eU5vcm1hbGlzZWQiLCJkZWZhdWx0cyRlIiwiaGFybW9uaWMiLCJlbGVzZm4kbSIsImNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpemVkIiwiY2xvc2VuZXNzZXMiLCJtYXhDbG9zZW5lc3MiLCJmdyIsImN1cnJDbG9zZW5lc3MiLCJub2RlX2kiLCJjbG9zZW5lc3MiLCJjbG9zZW5lc3NDZW50cmFsaXR5IiwiX2RlZmF1bHRzMiIsInRvdGFsRGlzdGFuY2UiLCJjYyIsImNjbiIsImNsb3NlbmVzc0NlbnRyYWxpdHlOb3JtYWxpc2VkIiwiZGVmYXVsdHMkZCIsImVsZXNmbiRsIiwiYmV0d2Vlbm5lc3NDZW50cmFsaXR5Iiwid2VpZ2h0ZWQiLCJfQyIsIkMiLCJvdXRnb2VycyIsIm9wZW5OZWlnaGJvcmhvb2QiLCJQIiwiX3ZpZCIsIl92IiwidkVsZSIsImdldEVsZW1lbnRCeUlkIiwiZWRnZVdlaWdodCIsIl93IiwiX3cyIiwiX3YyIiwiYmV0d2Vlbm5lc3MiLCJiZXR3ZWVubmVzc05vcm1hbGl6ZWQiLCJiZXR3ZWVubmVzc05vcm1hbGlzZWQiLCJiYyIsImRlZmF1bHRzJGMiLCJleHBhbmRGYWN0b3IiLCJpbmZsYXRlRmFjdG9yIiwibXVsdEZhY3RvciIsIm1heEl0ZXJhdGlvbnMiLCJhdHRyaWJ1dGVzIiwic2V0T3B0aW9ucyQzIiwic2V0T3B0aW9ucyIsImdldFNpbWlsYXJpdHkkMSIsImdldFNpbWlsYXJpdHkiLCJhZGRMb29wcyIsIk0iLCJzdW0iLCJjb2wiLCJyb3ciLCJfcm93IiwibW11bHQiLCJCIiwiZXhwYW5kIiwiX00iLCJpbmZsYXRlIiwiaGFzQ29udmVyZ2VkIiwibjIiLCJyb3VuZEZhY3RvciIsInYxIiwidjIiLCJhc3NpZ24kMiIsImNsdXN0ZXJzIiwiY2x1c3RlciIsImlzRHVwbGljYXRlIiwiYzEiLCJjMiIsInJlbW92ZUR1cGxpY2F0ZXMiLCJtYXJrb3ZDbHVzdGVyaW5nIiwiaWQycG9zaXRpb24iLCJzaW0iLCJpc1N0aWxsTW92aW5nIiwibWFya292Q2x1c3RlcmluZyQxIiwibWNsIiwiaWRlbnRpdHkkMSIsImlkZW50aXR5IiwiYWJzRGlmZiIsImFkZEFic0RpZmYiLCJhZGRTcXVhcmVkRGlmZiIsIm1heEFic0RpZmYiLCJjdXJyZW50TWF4IiwiZ2V0RGlzdGFuY2UiLCJnZXRQIiwiZ2V0USIsImluaXQiLCJwb3N0IiwiZGltIiwiZGlzdGFuY2VzIiwiZXVjbGlkZWFuIiwic3F1YXJlZEV1Y2xpZGVhbiIsIm1hbmhhdHRhbiIsImNsdXN0ZXJpbmdEaXN0YW5jZSIsIm1ldGhvZCIsIm5vZGVQIiwibm9kZVEiLCJpbXBsIiwiZGVmYXVsdHMkYiIsInNlbnNpdGl2aXR5VGhyZXNob2xkIiwidGVzdE1vZGUiLCJ0ZXN0Q2VudHJvaWRzIiwic2V0T3B0aW9ucyQyIiwiY2VudHJvaWQiLCJtb2RlIiwibm9Ob2RlUCIsInJhbmRvbUNlbnRyb2lkcyIsIm5kaW0iLCJjZW50cm9pZHMiLCJjbGFzc2lmeSIsImJ1aWxkQ2x1c3RlciIsImFzc2lnbm1lbnQiLCJoYXZlVmFsdWVzQ29udmVyZ2VkIiwiaGF2ZU1hdHJpY2VzQ29udmVyZ2VkIiwic2VlbkJlZm9yZSIsIm1lZG9pZHMiLCJyYW5kb21NZWRvaWRzIiwiZmluZENvc3QiLCJwb3RlbnRpYWxOZXdNZWRvaWQiLCJjb3N0Iiwia01lYW5zIiwibmV3Q2VudHJvaWQiLCJrTWVkb2lkcyIsImN1ckNvc3QiLCJtaW5Db3N0cyIsInVwZGF0ZUNlbnRyb2lkcyIsIlUiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsIl9jIiwidXBkYXRlTWVtYmVyc2hpcCIsIl9VIiwiYXNzaWduJDEiLCJfYzIiLCJfYzMiLCJmdXp6eUNNZWFucyIsImRlZ3JlZU9mTWVtYmVyc2hpcCIsImtDbHVzdGVyaW5nIiwiZmNtIiwiZGVmYXVsdHMkYSIsImxpbmthZ2UiLCJ0aHJlc2hvbGQiLCJhZGREZW5kcm9ncmFtIiwiZGVuZHJvZ3JhbURlcHRoIiwibGlua2FnZUFsaWFzZXMiLCJzZXRPcHRpb25zJDEiLCJwcmVmZXJyZWRBbGlhcyIsIm1lcmdlQ2xvc2VzdCIsImRpc3RzIiwibWlucyIsIm1pbktleSIsImF0dHJzIiwibjEiLCJfZGlzdCIsIm1lcmdlZCIsImN1ciIsImtleTEiLCJrZXkyIiwiX2dldEFsbENoaWxkcmVuIiwiZ2V0QWxsQ2hpbGRyZW4iLCJfYnVpbGREZW5kcm9ncmFtIiwiYnVpbGREZW5kcm9ncmFtIiwibGVmdFN0ciIsInJpZ2h0U3RyIiwiX2J1aWxkQ2x1c3RlcnNGcm9tVHJlZSIsImJ1aWxkQ2x1c3RlcnNGcm9tVHJlZSIsImxlYXZlcyIsImhpZXJhcmNoaWNhbENsdXN0ZXJpbmciLCJyZXRDbHVzdGVycyIsImhpZXJhcmNoaWNhbENsdXN0ZXJpbmckMSIsImhjYSIsImRlZmF1bHRzJDkiLCJwcmVmZXJlbmNlIiwiZGFtcGluZyIsIm1pbkl0ZXJhdGlvbnMiLCJkbXAiLCJwcmVmIiwidmFsaWRQcmVmcyIsInNvbWUiLCJhdHRyIiwiZ2V0UHJlZmVyZW5jZSIsImZpbmRFeGVtcGxhcnMiLCJSIiwiaW5kaWNlcyIsImFzc2lnbkNsdXN0ZXJzIiwiZXhlbXBsYXJzIiwiZWkiLCJfZWkiLCJpaSIsIm1heEkiLCJtYXhTdW0iLCJhZmZpbml0eVByb3BhZ2F0aW9uIiwib2xkIiwiUnAiLCJzZSIsIl9pOCIsIm1heDIiLCJBUyIsIl9pOSIsIl9qMyIsIl9qNCIsIl9pMTAiLCJFIiwiX3N1bSIsIl9pMTEiLCJfajUiLCJleGVtcGxhcnNJbmRpY2VzIiwiY2x1c3RlckluZGljZXMiLCJfaTEyIiwiY2x1c3RlckluZGV4IiwiYWZmaW5pdHlQcm9wYWdhdGlvbiQxIiwiYXAiLCJoaWVyaG9semVyRGVmYXVsdHMiLCJlbGVzZm4kayIsImhpZXJob2x6ZXIiLCJfaGllcmhvbHplckRlZmF1bHRzIiwiZGZsYWciLCJvZGRJbiIsIm9kZE91dCIsInN0YXJ0VmVydGV4IiwiaW5kIiwib3V0ZCIsImQxIiwiZDIiLCJpc0VkZ2UiLCJ0cmFpbCIsIndhbGsiLCJjdXJyZW50Tm9kZSIsInN1YnRvdXIiLCJhZGoiLCJhZGpUYWlsIiwiYWRqSGVhZCIsImhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQiLCJlZGdlQ291bnQiLCJzdGFjayIsInZpc2l0ZWRFZGdlcyIsImJ1aWxkQ29tcG9uZW50IiwiY3V0c2V0Iiwibm9kZUlkIiwiY3V0VmVydGV4IiwiX2JpY29ubmVjdGVkU2VhcmNoIiwiYmljb25uZWN0ZWRTZWFyY2giLCJsb3ciLCJzb3VyY2VJZCIsInRhcmdldElkIiwib3RoZXJOb2RlSWQiLCJlZGdlSWQiLCJjdXRWZXJ0aWNlcyIsImhvcGNyb2Z0VGFyamFuQmljb25uZWN0ZWQkMSIsImh0YmMiLCJodGIiLCJob3Bjcm9mdFRhcmphbkJpY29ubmVjdGVkQ29tcG9uZW50cyIsInRhcmphblN0cm9uZ2x5Q29ubmVjdGVkIiwiX3N0cm9uZ2x5Q29ubmVjdGVkU2VhcmNoIiwic3Ryb25nbHlDb25uZWN0ZWRTZWFyY2giLCJzb3VyY2VOb2RlSWQiLCJleHBsb3JlZCIsInRhcmdldE5vZGVJZCIsImNvbXBvbmVudE5vZGVzIiwiY29tcG9uZW50RWRnZXMiLCJkaWZmZXJlbmNlIiwidGFyamFuU3Ryb25nbHlDb25uZWN0ZWQkMSIsInRzYyIsInRzY2MiLCJ0YXJqYW5TdHJvbmdseUNvbm5lY3RlZENvbXBvbmVudHMiLCJlbGVzZm4kaiIsInByb3BzIiwiU1RBVEVfUEVORElORyIsIlNUQVRFX0ZVTEZJTExFRCIsIlNUQVRFX1JFSkVDVEVEIiwiX2FwaSIsImFwaSIsImV4ZWN1dG9yIiwic3RhdGUiLCJmdWxmaWxsVmFsdWUiLCJyZWplY3RSZWFzb24iLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJwcm94eSIsImZ1bGZpbGwiLCJyZWplY3QiLCJkZWxpdmVyIiwiY3VyciIsInJlc29sdmVyIiwiZXhlY3V0ZSIsImV4ZWN1dGVfaGFuZGxlcnMiLCJoYW5kbGVycyIsInNldEltbWVkaWF0ZSIsImNiIiwiX3Jlc29sdmUiLCJyZXNvbHZlIiwicmVzb2x2ZWQiLCJwcyIsInJlc29sdmVBbGwiLCJyZWplY3RBbGwiLCJ2YWxzIiwiZG9uZUNvdW50IiwiaXNQcm9taXNlIiwiUHJvbWlzZSQxIiwiUHJvbWlzZSIsIkFuaW1hdGlvbiIsIm9wdHMyIiwiaXNDb3JlIiwiaXNFbGUiLCJkdXJhdGlvbiIsInN0YXJ0ZWQiLCJwbGF5aW5nIiwiaG9va2VkIiwiYXBwbHlpbmciLCJwcm9ncmVzcyIsImNvbXBsZXRlcyIsImZyYW1lcyIsImNvbXBsZXRlIiwic3RhcnRQb3NpdGlvbiIsInN0YXJ0U3R5bGUiLCJnZXRBbmltYXRpb25TdGFydFN0eWxlIiwic3RhcnRQYW4iLCJzdGFydFpvb20iLCJhbmlmbiIsImhvb2siLCJ0QW5pIiwiYWRkVG9BbmltYXRpb25Qb29sIiwicGxheSIsInN0b3BwZWQiLCJwYXVzZSIsInN0b3AiLCJyZXdpbmQiLCJmYXN0Zm9yd2FyZCIsIndhc1BsYXlpbmciLCJjb21wbGV0ZWQiLCJzd2FwIiwiX3BhIiwicHJvcCIsInN0YXJ0U3R5bGVQcm9wIiwicnVuIiwicnVubmluZyIsImRlZmluZSQzIiwiYW5pbWF0ZWQiLCJhbmltYXRlZEltcGwiLCJzZWxmSXNBcnJheUxpa2UiLCJzdHlsZUVuYWJsZWQiLCJjbGVhclF1ZXVlIiwiY2xlYXJRdWV1ZUltcGwiLCJkZWxheSIsImRlbGF5SW1wbCIsImFuaW1hdGUiLCJkZWxheUFuaW1hdGlvbiIsImRlbGF5QW5pbWF0aW9uSW1wbCIsImFuaW1hdGlvbkltcGwiLCJwcm9wZXJ0aWVzIiwiaXNFbGVzIiwicHJvcGVydGllc0VtcHR5IiwiZ2V0UHJvcHNMaXN0IiwicGFuQnkiLCJjeVBhbiIsImNlbnRlciIsImNlbnRyZSIsImNlbnRlclBhbiIsImdldENlbnRlclBhbiIsImZpdCIsImZpdFZwIiwiZ2V0Rml0Vmlld3BvcnQiLCJ2cCIsImdldFpvb21lZFZpZXdwb3J0Iiwiem9vbWVkIiwicGFubmVkIiwiYW5pbWF0ZUltcGwiLCJhbmkiLCJzdG9wSW1wbCIsImp1bXBUb0VuZCIsImFuaXMiLCJhbmlfcCIsIm5vdGlmeSIsImlzQXJyYXlfMSIsImhhc1JlcXVpcmVkSXNBcnJheSIsInJlcXVpcmVJc0FycmF5IiwiX2lzS2V5IiwiaGFzUmVxdWlyZWRfaXNLZXkiLCJyZXF1aXJlX2lzS2V5IiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsImlzS2V5IiwiaXNGdW5jdGlvbl8xIiwiaGFzUmVxdWlyZWRJc0Z1bmN0aW9uIiwicmVxdWlyZUlzRnVuY3Rpb24iLCJhc3luY1RhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJwcm94eVRhZyIsImlzRnVuY3Rpb24iLCJfY29yZUpzRGF0YSIsImhhc1JlcXVpcmVkX2NvcmVKc0RhdGEiLCJyZXF1aXJlX2NvcmVKc0RhdGEiLCJjb3JlSnNEYXRhIiwiX2lzTWFza2VkIiwiaGFzUmVxdWlyZWRfaXNNYXNrZWQiLCJyZXF1aXJlX2lzTWFza2VkIiwibWFza1NyY0tleSIsIklFX1BST1RPIiwiaXNNYXNrZWQiLCJfdG9Tb3VyY2UiLCJoYXNSZXF1aXJlZF90b1NvdXJjZSIsInJlcXVpcmVfdG9Tb3VyY2UiLCJmdW5jUHJvdG8iLCJmdW5jVG9TdHJpbmciLCJ0b1NvdXJjZSIsIl9iYXNlSXNOYXRpdmUiLCJoYXNSZXF1aXJlZF9iYXNlSXNOYXRpdmUiLCJyZXF1aXJlX2Jhc2VJc05hdGl2ZSIsInJlUmVnRXhwQ2hhciIsInJlSXNIb3N0Q3RvciIsInJlSXNOYXRpdmUiLCJiYXNlSXNOYXRpdmUiLCJwYXR0ZXJuIiwiX2dldFZhbHVlIiwiaGFzUmVxdWlyZWRfZ2V0VmFsdWUiLCJyZXF1aXJlX2dldFZhbHVlIiwiZ2V0VmFsdWUiLCJfZ2V0TmF0aXZlIiwiaGFzUmVxdWlyZWRfZ2V0TmF0aXZlIiwicmVxdWlyZV9nZXROYXRpdmUiLCJnZXROYXRpdmUiLCJfbmF0aXZlQ3JlYXRlIiwiaGFzUmVxdWlyZWRfbmF0aXZlQ3JlYXRlIiwicmVxdWlyZV9uYXRpdmVDcmVhdGUiLCJuYXRpdmVDcmVhdGUiLCJfaGFzaENsZWFyIiwiaGFzUmVxdWlyZWRfaGFzaENsZWFyIiwicmVxdWlyZV9oYXNoQ2xlYXIiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsIl9oYXNoRGVsZXRlIiwiaGFzUmVxdWlyZWRfaGFzaERlbGV0ZSIsInJlcXVpcmVfaGFzaERlbGV0ZSIsImhhc2hEZWxldGUiLCJfaGFzaEdldCIsImhhc1JlcXVpcmVkX2hhc2hHZXQiLCJyZXF1aXJlX2hhc2hHZXQiLCJIQVNIX1VOREVGSU5FRCIsImhhc2hHZXQiLCJfaGFzaEhhcyIsImhhc1JlcXVpcmVkX2hhc2hIYXMiLCJyZXF1aXJlX2hhc2hIYXMiLCJoYXNoSGFzIiwiX2hhc2hTZXQiLCJoYXNSZXF1aXJlZF9oYXNoU2V0IiwicmVxdWlyZV9oYXNoU2V0IiwiaGFzaFNldCIsIl9IYXNoIiwiaGFzUmVxdWlyZWRfSGFzaCIsInJlcXVpcmVfSGFzaCIsIkhhc2giLCJlbnRyaWVzIiwiX2xpc3RDYWNoZUNsZWFyIiwiaGFzUmVxdWlyZWRfbGlzdENhY2hlQ2xlYXIiLCJyZXF1aXJlX2xpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlQ2xlYXIiLCJlcV8xIiwiaGFzUmVxdWlyZWRFcSIsInJlcXVpcmVFcSIsImVxIiwiX2Fzc29jSW5kZXhPZiIsImhhc1JlcXVpcmVkX2Fzc29jSW5kZXhPZiIsInJlcXVpcmVfYXNzb2NJbmRleE9mIiwiYXNzb2NJbmRleE9mIiwiX2xpc3RDYWNoZURlbGV0ZSIsImhhc1JlcXVpcmVkX2xpc3RDYWNoZURlbGV0ZSIsInJlcXVpcmVfbGlzdENhY2hlRGVsZXRlIiwiYXJyYXlQcm90byIsImxpc3RDYWNoZURlbGV0ZSIsImxhc3RJbmRleCIsIl9saXN0Q2FjaGVHZXQiLCJoYXNSZXF1aXJlZF9saXN0Q2FjaGVHZXQiLCJyZXF1aXJlX2xpc3RDYWNoZUdldCIsImxpc3RDYWNoZUdldCIsIl9saXN0Q2FjaGVIYXMiLCJoYXNSZXF1aXJlZF9saXN0Q2FjaGVIYXMiLCJyZXF1aXJlX2xpc3RDYWNoZUhhcyIsImxpc3RDYWNoZUhhcyIsIl9saXN0Q2FjaGVTZXQiLCJoYXNSZXF1aXJlZF9saXN0Q2FjaGVTZXQiLCJyZXF1aXJlX2xpc3RDYWNoZVNldCIsImxpc3RDYWNoZVNldCIsIl9MaXN0Q2FjaGUiLCJoYXNSZXF1aXJlZF9MaXN0Q2FjaGUiLCJyZXF1aXJlX0xpc3RDYWNoZSIsIkxpc3RDYWNoZSIsIl9NYXAiLCJoYXNSZXF1aXJlZF9NYXAiLCJyZXF1aXJlX01hcCIsIl9tYXBDYWNoZUNsZWFyIiwiaGFzUmVxdWlyZWRfbWFwQ2FjaGVDbGVhciIsInJlcXVpcmVfbWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlQ2xlYXIiLCJfaXNLZXlhYmxlIiwiaGFzUmVxdWlyZWRfaXNLZXlhYmxlIiwicmVxdWlyZV9pc0tleWFibGUiLCJpc0tleWFibGUiLCJfZ2V0TWFwRGF0YSIsImhhc1JlcXVpcmVkX2dldE1hcERhdGEiLCJyZXF1aXJlX2dldE1hcERhdGEiLCJnZXRNYXBEYXRhIiwiX21hcENhY2hlRGVsZXRlIiwiaGFzUmVxdWlyZWRfbWFwQ2FjaGVEZWxldGUiLCJyZXF1aXJlX21hcENhY2hlRGVsZXRlIiwibWFwQ2FjaGVEZWxldGUiLCJfbWFwQ2FjaGVHZXQiLCJoYXNSZXF1aXJlZF9tYXBDYWNoZUdldCIsInJlcXVpcmVfbWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUdldCIsIl9tYXBDYWNoZUhhcyIsImhhc1JlcXVpcmVkX21hcENhY2hlSGFzIiwicmVxdWlyZV9tYXBDYWNoZUhhcyIsIm1hcENhY2hlSGFzIiwiX21hcENhY2hlU2V0IiwiaGFzUmVxdWlyZWRfbWFwQ2FjaGVTZXQiLCJyZXF1aXJlX21hcENhY2hlU2V0IiwibWFwQ2FjaGVTZXQiLCJfTWFwQ2FjaGUiLCJoYXNSZXF1aXJlZF9NYXBDYWNoZSIsInJlcXVpcmVfTWFwQ2FjaGUiLCJNYXBDYWNoZSIsIm1lbW9pemVfMSIsImhhc1JlcXVpcmVkTWVtb2l6ZSIsInJlcXVpcmVNZW1vaXplIiwibWVtb2l6ZWQiLCJDYWNoZSIsIl9tZW1vaXplQ2FwcGVkIiwiaGFzUmVxdWlyZWRfbWVtb2l6ZUNhcHBlZCIsInJlcXVpcmVfbWVtb2l6ZUNhcHBlZCIsIk1BWF9NRU1PSVpFX1NJWkUiLCJtZW1vaXplQ2FwcGVkIiwiX3N0cmluZ1RvUGF0aCIsImhhc1JlcXVpcmVkX3N0cmluZ1RvUGF0aCIsInJlcXVpcmVfc3RyaW5nVG9QYXRoIiwicmVQcm9wTmFtZSIsInJlRXNjYXBlQ2hhciIsInN0cmluZ1RvUGF0aCIsInF1b3RlIiwic3ViU3RyaW5nIiwiX2FycmF5TWFwIiwiaGFzUmVxdWlyZWRfYXJyYXlNYXAiLCJyZXF1aXJlX2FycmF5TWFwIiwiYXJyYXlNYXAiLCJpdGVyYXRlZSIsIl9iYXNlVG9TdHJpbmciLCJoYXNSZXF1aXJlZF9iYXNlVG9TdHJpbmciLCJyZXF1aXJlX2Jhc2VUb1N0cmluZyIsInN5bWJvbFByb3RvIiwic3ltYm9sVG9TdHJpbmciLCJiYXNlVG9TdHJpbmciLCJ0b1N0cmluZ18xIiwiaGFzUmVxdWlyZWRUb1N0cmluZyIsInJlcXVpcmVUb1N0cmluZyIsIl9jYXN0UGF0aCIsImhhc1JlcXVpcmVkX2Nhc3RQYXRoIiwicmVxdWlyZV9jYXN0UGF0aCIsImNhc3RQYXRoIiwiX3RvS2V5IiwiaGFzUmVxdWlyZWRfdG9LZXkiLCJyZXF1aXJlX3RvS2V5IiwidG9LZXkiLCJfYmFzZUdldCIsImhhc1JlcXVpcmVkX2Jhc2VHZXQiLCJyZXF1aXJlX2Jhc2VHZXQiLCJiYXNlR2V0IiwiZ2V0XzEiLCJoYXNSZXF1aXJlZEdldCIsInJlcXVpcmVHZXQiLCJkZWZhdWx0VmFsdWUiLCJnZXRFeHBvcnRzIiwiX2RlZmluZVByb3BlcnR5IiwiaGFzUmVxdWlyZWRfZGVmaW5lUHJvcGVydHkiLCJyZXF1aXJlX2RlZmluZVByb3BlcnR5IiwiX2Jhc2VBc3NpZ25WYWx1ZSIsImhhc1JlcXVpcmVkX2Jhc2VBc3NpZ25WYWx1ZSIsInJlcXVpcmVfYmFzZUFzc2lnblZhbHVlIiwiYmFzZUFzc2lnblZhbHVlIiwiX2Fzc2lnblZhbHVlIiwiaGFzUmVxdWlyZWRfYXNzaWduVmFsdWUiLCJyZXF1aXJlX2Fzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsIl9pc0luZGV4IiwiaGFzUmVxdWlyZWRfaXNJbmRleCIsInJlcXVpcmVfaXNJbmRleCIsInJlSXNVaW50IiwiaXNJbmRleCIsIl9iYXNlU2V0IiwiaGFzUmVxdWlyZWRfYmFzZVNldCIsInJlcXVpcmVfYmFzZVNldCIsImJhc2VTZXQiLCJjdXN0b21pemVyIiwibmVzdGVkIiwibmV3VmFsdWUiLCJzZXRfMSIsImhhc1JlcXVpcmVkU2V0IiwicmVxdWlyZVNldCIsInNldEV4cG9ydHMiLCJfY29weUFycmF5IiwiaGFzUmVxdWlyZWRfY29weUFycmF5IiwicmVxdWlyZV9jb3B5QXJyYXkiLCJ0b1BhdGhfMSIsImhhc1JlcXVpcmVkVG9QYXRoIiwicmVxdWlyZVRvUGF0aCIsInRvUGF0aCIsInRvUGF0aEV4cG9ydHMiLCJkZWZpbmUkMiIsImZpZWxkIiwiYmluZGluZ0V2ZW50IiwiYWxsb3dCaW5kaW5nIiwiYWxsb3dTZXR0aW5nIiwiYWxsb3dHZXR0aW5nIiwic2V0dGluZ0V2ZW50Iiwic2V0dGluZ1RyaWdnZXJzRXZlbnQiLCJ0cmlnZ2VyRm5OYW1lIiwiaW1tdXRhYmxlS2V5cyIsInVwZGF0ZVN0eWxlIiwiYmVmb3JlR2V0IiwiYmVmb3JlU2V0Iiwib25TZXQiLCJjYW5TZXQiLCJkYXRhSW1wbCIsImlzUGF0aExpa2UiLCJ2YWxpZCIsImNoYW5nZSIsIl92YWxpZCIsIl9lbGUiLCJvbiIsInJlbW92ZURhdGEiLCJ0cmlnZ2VyRXZlbnQiLCJyZW1vdmVEYXRhSW1wbCIsIm5hbWVzIiwiaV9hIiwibF9hIiwiX2lfYSIsIl9sX2EiLCJfcHJpdmF0ZUZpZWxkcyIsIl9rZXlzIiwiX2tleSIsInZhbGlkS2V5VG9EZWxldGUiLCJkZWZpbmUkMSIsImV2ZW50QWxpYXNlc09uIiwicHJvdG8iLCJhZGRMaXN0ZW5lciIsImxpc3RlbiIsInVubGlzdGVuIiwidW5iaW5kIiwicmVtb3ZlTGlzdGVuZXIiLCJ0cmlnZ2VyIiwiZW1pdCIsInBvbiIsInByb21pc2VPbiIsImV2ZW50cyIsInNlbGVjdG9yIiwib2ZmQXJncyIsIm9uQXJncyIsImRlZmluZSIsImVsZXNmbiRpIiwiZWxlc2ZuJGgiLCJfY2xhc3NlcyIsImNoYW5nZWQiLCJjbGFzc2VzU2V0IiwiZWxlQ2xhc3NlcyIsImNoYW5nZWRFbGUiLCJlbGVIYXNDbGFzcyIsImFkZENsYXNzIiwidG9nZ2xlQ2xhc3MiLCJoYXNDbGFzcyIsImNsYXNzTmFtZSIsInRvZ2dsZSIsInRvZ2dsZVVuZGVmZCIsImlsIiwiY2hhbmdlZE5vdyIsInJlbW92ZUNsYXNzIiwiZmxhc2hDbGFzcyIsImNsYXNzTmFtZXMiLCJ0b2tlbnMiLCJtZXRhQ2hhciIsImNvbXBhcmF0b3JPcCIsImJvb2xPcCIsIm1ldGEiLCJzZXBhcmF0b3IiLCJkZXNjZW5kYW50IiwiY2hpbGQiLCJzdWJqZWN0IiwiZGlyZWN0ZWRFZGdlIiwidW5kaXJlY3RlZEVkZ2UiLCJ2YXJpYWJsZSIsIm9wcyIsIm9wIiwibmV3UXVlcnkiLCJjaGVja3MiLCJUeXBlIiwiR1JPVVAiLCJDT0xMRUNUSU9OIiwiRklMVEVSIiwiREFUQV9DT01QQVJFIiwiREFUQV9FWElTVCIsIkRBVEFfQk9PTCIsIk1FVEFfQ09NUEFSRSIsIlNUQVRFIiwiSUQiLCJDTEFTUyIsIlVORElSRUNURURfRURHRSIsIkRJUkVDVEVEX0VER0UiLCJOT0RFX1NPVVJDRSIsIk5PREVfVEFSR0VUIiwiTk9ERV9ORUlHSEJPUiIsIkNISUxEIiwiREVTQ0VOREFOVCIsIlBBUkVOVCIsIkFOQ0VTVE9SIiwiQ09NUE9VTkRfU1BMSVQiLCJUUlVFIiwic3RhdGVTZWxlY3RvcnMiLCJtYXRjaGVzIiwidmlzaWJsZSIsImlzUGFyZW50IiwiaXNDaGlsZGxlc3MiLCJpc0NoaWxkIiwiaXNPcnBoYW4iLCJpc1NpbXBsZSIsImxvb2t1cCIsInNlbFRvRm4iLCJzdGF0ZVNlbGVjdG9yTWF0Y2hlcyIsInNlbCIsInN0YXRlU2VsZWN0b3JSZWdleCIsImNsZWFuTWV0YUNoYXJzIiwiJDEiLCJyZXBsYWNlTGFzdFF1ZXJ5IiwiZXhhbWluaW5nUXVlcnkiLCJyZXBsYWNlbWVudFF1ZXJ5IiwiZXhwcnMiLCJxdWVyeSIsInJlZ2V4IiwicG9wdWxhdGUiLCJfcmVmMiIsIl9yZWYzIiwiX3JlZjQiLCJfcmVmNSIsIl9yZWY2IiwiX3JlZjciLCJfcmVmOCIsIl9yZWY5IiwiX3JlZjEwIiwiX3JlZjExIiwiX3JlZjEyIiwidmFsdWVJc1N0cmluZyIsIm9wZXJhdG9yIiwiX3JlZjEzIiwiX3JlZjE0IiwiX3JlZjE1IiwiX3JlZjE2IiwiY3VycmVudFN1YmplY3QiLCJjb21wb3VuZENvdW50IiwibGFzdFEiLCJuZXh0UXVlcnkiLCJlZGdlUXVlcnkiLCJzcmNUZ3RRIiwiX3NvdXJjZSIsIl90YXJnZXQiLCJuaG9vZFEiLCJuZWlnaGJvciIsInBhcmVudENoaWxkUXVlcnkiLCJjb21wb3VuZCIsIl9jaGlsZCIsIl9wYXJlbnQiLCJfcGFyZW50MiIsIl9jaGlsZDIiLCJwY1FDaGVja3MiLCJhbmNDaFF1ZXJ5IiwiYW5jZXN0b3IiLCJfZGVzY2VuZGFudCIsIl9hbmNlc3RvciIsIl9hbmNlc3RvcjIiLCJfZGVzY2VuZGFudDIiLCJhZFFDaGVja3MiLCJtb2RpZmllciIsInRvcFEiLCJ0b3BDaGsiLCJ0b3BUeXBlIiwicmVnZXhPYmoiLCJjb25zdW1lRXhwciIsInJlbWFpbmluZyIsImV4cHIiLCJjb25zdW1lZCIsImNvbnN1bWVXaGl0ZXNwYWNlIiwicGFyc2UiLCJpbnB1dFRleHQiLCJjdXJyZW50UXVlcnkiLCJleHBySW5mbyIsInRvU3RyaW5nQ2FjaGUiLCJjbGVhbiIsImNsZWFuVmFsIiwic3BhY2UiLCJjaGVja1RvU3RyaW5nIiwiY2hlY2siLCJfb3BlcmF0b3IiLCJfZmllbGQiLCJfZmllbGQyIiwiX29wZXJhdG9yMiIsIl9maWVsZDMiLCJxdWVyeVRvU3RyaW5nIiwibGhzIiwicmhzIiwicmVkdWNlIiwiY2hrIiwicGFyc2UkMSIsInZhbENtcCIsImZpZWxkVmFsIiwiaXNGaWVsZFN0ciIsImlzRmllbGROdW0iLCJpc1ZhbFN0ciIsImZpZWxkU3RyIiwidmFsU3RyIiwiY2FzZUluc2Vuc2l0aXZlIiwibm90RXhwciIsImlzSW5lcUNtcCIsImJvb2xDbXAiLCJleGlzdENtcCIsImRhdGEkMSIsIm1hdGNoZXMkMSIsImV2ZXJ5Iiwic3RhdGVTZWxlY3RvciIsInFBIiwicUIiLCJpbmNvbWVycyIsImFuY2VzdG9ycyIsImRlc2NlbmRhbnRzIiwic2VsZWN0b3JGdW5jdGlvbiIsInRleHQiLCJtYXRjaGluZyIsIlNlbGVjdG9yIiwiYWRkUXVlcnkiLCJpbnZhbGlkIiwic2VsZm4iLCJzYW1lVGV4dCIsIm90aGVyU2VsIiwiZWxlc2ZuJGciLCJhbGxBcmUiLCJzZWxPYmoiLCJpcyIsInRoaXNMZW5ndGgiLCJjb2xsZWN0aW9uTGVuZ3RoIiwiYW55U2FtZSIsImFsbEFyZU5laWdoYm9ycyIsIm5ob29kIiwiYWxsQXJlTmVpZ2hib3VycyIsImVxdWFsIiwiZXF1YWxzIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYXJnNCIsInNlbGVjdG9yT3JFbGVzIiwidGNoIiwiY2giLCJjYWNoZUhpdCIsImVsZXNmbiRmIiwicGFyZW50cyIsIm5vbmVtcHR5IiwiY29tbW9uQW5jZXN0b3JzIiwib3JwaGFucyIsInN0ZEZpbHRlciIsIm5vbm9ycGhhbnMiLCJlbGVDaGlsZHJlbiIsInNpYmxpbmdzIiwibm90IiwiZWxlbWVudHMiLCJmb3JFYWNoQ29tcG91bmQiLCJpbmNsdWRlU2VsZiIsInJlY3Vyc2l2ZVN0ZXAiLCJkaWQiLCJoYXNDb21wb3VuZHMiLCJoYXNDb21wb3VuZE5vZGVzIiwiYWRkQ2hpbGRyZW4iLCJmb3JFYWNoRG93biIsImFkZFBhcmVudCIsImZvckVhY2hVcCIsImFkZFBhcmVudEFuZENoaWxkcmVuIiwiZm9yRWFjaFVwQW5kRG93biIsImZuJDUiLCJlbGVzZm4kZSIsInJlbW92ZVNjcmF0Y2giLCJyZW1vdmVSc2NyYXRjaCIsInJlbW92ZUF0dHIiLCJlbGVzZm4kZCIsImRlZmluZURlZ3JlZUZ1bmN0aW9uIiwiaW5jbHVkZUxvb3BzIiwiZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24iLCJkZWdyZWVGbiIsIm1pbkRlZ3JlZSIsIm1pbkluZGVncmVlIiwibWluT3V0ZGVncmVlIiwidG90YWxEZWdyZWUiLCJmbiQ0IiwiZWxlc2ZuJGMiLCJiZWZvcmVQb3NpdGlvblNldCIsIm5ld1BvcyIsInNpbGVudCIsIm9sZFBvcyIsImRpcnR5Qm91bmRpbmdCb3hDYWNoZSIsInBvc2l0aW9uRGVmIiwidmFsaWRLZXlzIiwidXBkYXRlQ29tcG91bmRCb3VuZHMiLCJkaXJ0eUNvbXBvdW5kQm91bmRzQ2FjaGUiLCJzaWxlbnRQb3NpdGlvbiIsInBvc2l0aW9ucyIsIl9mbiIsInN0YXJ0QmF0Y2giLCJfcG9zIiwiZW5kQmF0Y2giLCJzaWxlbnRQb3NpdGlvbnMiLCJzaWxlbnRTaGlmdCIsInNldHRpbmciLCJyZWxhdGl2ZVBvc2l0aW9uIiwicHBvcyIsIl9lbGUyIiwiaGFzUGFyZW50IiwicmVsYXRpdmVUb1BhcmVudCIsIm9yaWdpbiIsIl9oYXNQYXJlbnQiLCJfcmVsYXRpdmVUb1BhcmVudCIsIl9vcmlnaW4iLCJtb2RlbFBvc2l0aW9uIiwibW9kZWxQb3NpdGlvbnMiLCJyZW5kZXJlZFBvaW50IiwicmVsYXRpdmVQb2ludCIsImZuJDMiLCJlbGVzZm4kYiIsInJlbmRlcmVkQm91bmRpbmdCb3giLCJlbWl0QW5kTm90aWZ5IiwiZm9yY2UiLCJiYXRjaGluZyIsInVwZGF0ZSIsImluY2x1ZGVMYWJlbHMiLCJwc3R5bGUiLCJwZlZhbHVlIiwiaW5jbHVkZU92ZXJsYXlzIiwidXNlQ2FjaGUiLCJjb21wdXRlQmlhc1ZhbHVlcyIsInByb3BEaWZmIiwicHJvcEJpYXMiLCJwcm9wQmlhc0NvbXBsZW1lbnQiLCJiaWFzRGlmZiIsImJpYXNDb21wbGVtZW50RGlmZiIsImJpYXNUb3RhbCIsImNvbXB1dGVQYWRkaW5nVmFsdWVzIiwicGFkZGluZ09iamVjdCIsInJlbGF0aXZlVG8iLCJ1bml0cyIsImxlZnRWYWwiLCJyaWdodFZhbCIsInRvcFZhbCIsImJvdHRvbVZhbCIsIndpZHRoQmlhc0RpZmZzIiwiZGlmZkxlZnQiLCJkaWZmUmlnaHQiLCJoZWlnaHRCaWFzRGlmZnMiLCJkaWZmVG9wIiwiZGlmZkJvdHRvbSIsIm5vbmluZiIsInVwZGF0ZUJvdW5kcyIsInVwZGF0ZUJvdW5kc0Zyb21Cb3giLCJiMiIsInByZWZpeGVkUHJvcGVydHkiLCJ1cGRhdGVCb3VuZHNGcm9tQXJyb3ciLCJib3VuZHMiLCJoZWFkbGVzcyIsImhhbGZBclciLCJhcnJvd1dpZHRoIiwiYXJyb3dUeXBlIiwic3JjWCIsInNyY1kiLCJ0Z3RYIiwidGd0WSIsIm1pZFgiLCJtaWRZIiwiYmJzIiwidXBkYXRlQm91bmRzRnJvbUxhYmVsIiwicHJlZml4RGFzaCIsImxhYmVsIiwic3RyVmFsdWUiLCJoYWxpZ24iLCJ2YWxpZ24iLCJsYWJlbFdpZHRoIiwibGFiZWxIZWlnaHQiLCJsYWJlbFgiLCJsYWJlbFkiLCJtYXJnaW5YIiwibWFyZ2luWSIsInJvdGF0aW9uIiwib3V0bGluZVdpZHRoIiwiYm9yZGVyV2lkdGgiLCJoYWxmQm9yZGVyV2lkdGgiLCJtYXJnaW5PZkVycm9yIiwibGgiLCJsdyIsImx3XzIiLCJsaF8yIiwibGVmdFBhZCIsInJpZ2h0UGFkIiwidG9wUGFkIiwiYm90UGFkIiwiYmJQcmVmaXgiLCJpc0F1dG9yb3RhdGUiLCJpc1BmVmFsdWUiLCJ0aGV0YSIsInhvIiwieW8iLCJyb3RhdGUiLCJweDF5MSIsInB4MXkyIiwicHgyeTEiLCJweDJ5MiIsImJiUHJlZml4Um90IiwiYmJSb3QiLCJ1cGRhdGVCb3VuZHNGcm9tT3V0bGluZSIsIm91dGxpbmVPcGFjaXR5Iiwib3V0bGluZU9mZnNldCIsImV4cGFuc2lvbiIsInVwZGF0ZUJvdW5kc0Zyb21NaXRlciIsIm9wYWNpdHkiLCJleHBhbnNpb25TaXplIiwiZXhwYW5zaW9uUG9zaXRpb24iLCJ1c2VGYWxsYmFja1ZhbHVlIiwic2hhcGUiLCJyc2hhcGUiLCJyZW5kZXJlciIsIm5vZGVTaGFwZXMiLCJfZWxlJHBvc2l0aW9uIiwiaGFzTWl0ZXJCb3VuZHMiLCJtYmIiLCJtaXRlckJvdW5kcyIsInVwZGF0ZUJvdW5kc0Zyb21NaXRlckJvcmRlciIsImJvcmRlck9wYWNpdHkiLCJib3JkZXJQb3NpdGlvbiIsImJvdW5kaW5nQm94SW1wbCIsImV4MSIsImV4MiIsImV5MSIsImV5MiIsIm1hbnVhbEV4cGFuc2lvbiIsImlzRGlzcGxheWVkIiwiZGlzcGxheWVkIiwib3ZlcmxheU9wYWNpdHkiLCJvdmVybGF5UGFkZGluZyIsInVuZGVybGF5T3BhY2l0eSIsInVuZGVybGF5UGFkZGluZyIsImluY2x1ZGVVbmRlcmxheXMiLCJ3SGFsZiIsImluY2x1ZGVOb2RlcyIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsImluY2x1ZGVPdXRsaW5lcyIsImluY2x1ZGVFZGdlcyIsImN1cnZlU3R5bGUiLCJocHRzIiwiaGF5c3RhY2tQdHMiLCJfdGVtcCIsImJlemllclB0cyIsImxpbmVQdHMiLCJuMXBvcyIsIm4ycG9zIiwiX3RlbXAyIiwiX3RlbXAzIiwiZ2hvc3QiLCJneCIsImd5IiwiYmJCb2R5IiwiYmJPdmVybGF5IiwiYmJMYWJlbHMiLCJpbmNsdWRlTWFpbkxhYmVscyIsImluY2x1ZGVTb3VyY2VMYWJlbHMiLCJpbmNsdWRlVGFyZ2V0TGFiZWxzIiwiZ2V0S2V5IiwidGYiLCJpbmN1ZGVOb2RlcyIsImdldEJvdW5kaW5nQm94UG9zS2V5IiwiY2FjaGVkQm91bmRpbmdCb3hJbXBsIiwiZGVmQmJPcHRzS2V5IiwidXNpbmdEZWZPcHRzIiwiZGVmQmJPcHRzIiwiYmJDYWNoZVBvc0tleSIsIm1haW5Sb3QiLCJzb3VyY2VSb3QiLCJ0YXJnZXRSb3QiLCJmaWxsZWRCYk9wdHMiLCJpc0RpcnR5Iiwic3R5bGVEaXJ0eSIsInJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSIsImJvdW5kaW5nQm94QXQiLCJzdG9yZU9sZFBvcyIsImJiQXRPbGRQb3MiLCJnZXRPbGRQb3MiLCJib3VuZGluZ2JveCIsInJlbmRlcmVkQm91bmRpbmdib3giLCJmbiQyIiwiZWxlc2ZuJGEiLCJkZWZpbmVEaW1GbnMiLCJ1cHBlcmNhc2VOYW1lIiwiYXV0b05hbWUiLCJsYWJlbE5hbWUiLCJvdXRlck5hbWUiLCJ1cHBlcmNhc2VPdXRlck5hbWUiLCJkaW1JbXBsIiwib3V0ZXJEaW1JbXBsIiwiYm9yZGVyUG9zIiwiYm9yZGVyIiwicmVuZGVyZWREaW1JbXBsIiwicmVuZGVyZWRPdXRlckRpbUltcGwiLCJvZCIsInBhZGRlZEhlaWdodCIsInBhZGRlZFdpZHRoIiwid2lkdGhIZWlnaHQiLCJpZkVkZ2UiLCJ0YWtlc1VwU3BhY2UiLCJpZkVkZ2VSZW5kZXJlZFBvc2l0aW9uIiwiZ2V0UG9pbnQiLCJpZkVkZ2VSZW5kZXJlZFBvc2l0aW9ucyIsImdldFBvaW50cyIsImNvbnRyb2xQb2ludHMiLCJnZXRDb250cm9sUG9pbnRzIiwic2VnbWVudFBvaW50cyIsImdldFNlZ21lbnRQb2ludHMiLCJzb3VyY2VFbmRwb2ludCIsImdldFNvdXJjZUVuZHBvaW50IiwidGFyZ2V0RW5kcG9pbnQiLCJnZXRUYXJnZXRFbmRwb2ludCIsIm1pZHBvaW50IiwiZ2V0RWRnZU1pZHBvaW50IiwibXVsdCIsInJlbmRlcmVkTmFtZSIsInN1YnN0ciIsImVkZ2VQb2ludHMiLCJzcGVjIiwick5hbWUiLCJkaW1lbnNpb25zIiwiRXZlbnQiLCJyZWN5Y2xlIiwicmV0dXJuRmFsc2UiLCJyZXR1cm5UcnVlIiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzRGVmYXVsdFByZXZlbnRlZCIsInByZXZlbnREZWZhdWx0IiwiZGVmYXVsdFByZXZlbnRlZCIsIm9yaWdpbmFsRXZlbnQiLCJuYW1lc3BhY2UiLCJsYXlvdXQiLCJ0aW1lU3RhbXAiLCJzdG9wUHJvcGFnYXRpb24iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJldmVudFJlZ2V4IiwidW5pdmVyc2FsTmFtZXNwYWNlIiwiZGVmYXVsdHMkOCIsInF1YWxpZmllckNvbXBhcmUiLCJxMSIsInEyIiwiZXZlbnRNYXRjaGVzIiwiYWRkRXZlbnRGaWVsZHMiLCJjYWxsYmFja0NvbnRleHQiLCJjb250ZXh0IiwiYmVmb3JlRW1pdCIsImFmdGVyRW1pdCIsImJ1YmJsZSIsImRlZmF1bHRzS2V5cyIsImVtcHR5T3B0cyIsIkVtaXR0ZXIiLCJlbWl0dGluZyIsImZvckVhY2hFdmVudCIsImhhbmRsZXIiLCJxdWFsaWZpZXIiLCJjb25mIiwiY29uZk92ZXJyaWRlcyIsImV2ZW50TGlzdCIsImV2dCIsIm1ha2VFdmVudE9iaiIsImZvckVhY2hFdmVudE9iaiIsImV2ZW50T2JqIiwib25lIiwibGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJleHRyYVBhcmFtcyIsIm1hbnVhbENhbGxiYWNrIiwibnVtTGlzdGVuZXJzQmVmb3JlRW1pdCIsIl9sb29wMiIsImVtaXR0ZXJPcHRpb25zJDEiLCJzZWxlY3RvcjEiLCJzZWxlY3RvcjIiLCJvbmNlIiwib25jZUNvbGxlY3Rpb24iLCJhcmdTZWxlY3RvciQxIiwiYXJnU2VsZWN0b3IiLCJhcmciLCJlbGVzZm4kOSIsImVtaXR0ZXIiLCJhcmdTZWwiLCJlbGVzZm4kOCIsIl9maWx0ZXIiLCJmaWx0ZXJFbGVzIiwiaW5jbHVkZSIsInRvUmVtb3ZlIiwicmVtb3ZlIiwiYWJzb2x1dGVDb21wbGVtZW50IiwibXV0YWJsZUVsZW1lbnRzIiwiY29sMSIsImNvbDIiLCJjb2wxU21hbGxlciIsImNvbFMiLCJjb2xMIiwieG9yIiwiaW5PdGhlciIsImJvdGgiLCJyZXRFbGVzIiwidG9BZGQiLCJzcGF3blNlbGYiLCJ0b0FkZEVsZSIsInVubWVyZ2VBdCIsInVubWVyZ2VkTGFzdEVsZSIsImxhc3RFbGVJIiwibGFzdEVsZSIsImxhc3RFbGVJZCIsInVubWVyZ2VPbmUiLCJ1bm1lcmdlIiwidG9SbUZuIiwibWFwRm4iLCJpbml0aWFsVmFsdWUiLCJ2YWxGbiIsIm1heEVsZSIsIm1pbkVsZSIsImZuJDEiLCJ1bmlvbiIsIm9yIiwicmVsYXRpdmVDb21wbGVtZW50Iiwic3VidHJhY3QiLCJhbmQiLCJzeW1tZXRyaWNEaWZmZXJlbmNlIiwic3ltZGlmZiIsImZuRmlsdGVyIiwiZmlsdGVyRm4iLCJjb21wbGVtZW50IiwiYWJzY29tcCIsImVsZXNmbiQ3IiwiekluZGV4U29ydCIsImdldERlcHRoIiwiekRlcHRoIiwiZGVwdGhEaWZmIiwiZ2V0RWxlRGVwdGgiLCJlbGVEaWZmIiwiekRpZmYiLCJwb29sSW5kZXgiLCJlbGVzZm4kNiIsInRoaXNTaXplIiwiZmlyc3QiLCJsYXN0Iiwic29ydEZuIiwic29ydGVkIiwic29ydEJ5WkluZGV4Iiwic3JjRGVwdGgiLCJ0Z3REZXB0aCIsImVhY2giLCJkZWZpbmVTeW1ib2xJdGVyYXRvciIsInR5cGVvZlVuZGVmIiwiaXNJdGVyYXRvclN1cHBvcnRlZCIsImdldExheW91dERpbWVuc2lvbk9wdGlvbnMiLCJub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMiLCJlbGVzZm4kNSIsImxheW91dERpbWVuc2lvbnMiLCJkaW1zIiwiYmJEaW0iLCJsYXlvdXRQb3NpdGlvbnMiLCJsYXlvdXRFbGVzIiwiZ2V0TWVtb2l6ZUtleSIsImZuTWVtIiwiYW5pbWF0aW9ucyIsImNhbGN1bGF0ZVNwYWNpbmciLCJzcGFjaW5nIiwibm9kZXNCYiIsInNwYWNpbmdWZWN0b3IiLCJ1c2VTcGFjaW5nRmFjdG9yIiwic3BhY2luZ0ZhY3RvciIsInNwYWNpbmdCYiIsImdldEZpbmFsUG9zIiwidHJhbnNmb3JtIiwiYW5pbWF0ZU5vZGUiLCJhbmltYXRlRmlsdGVyIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJlYXNpbmciLCJhbmltYXRpb25FYXNpbmciLCJmaXRBbmkiLCJ6b29tUGFuQW5pIiwicmVhZHkiLCJtYWtlTGF5b3V0IiwiY3JlYXRlTGF5b3V0Iiwic3R5bGVDYWNoZSIsImNhY2hlU3R5bGVGdW5jdGlvbiIsImNhY2hlZFN0eWxlRnVuY3Rpb24iLCJjYWNoZVByb3RvdHlwZVN0eWxlRnVuY3Rpb24iLCJzZWxmRm4iLCJjYWNoZWRQcm90b3R5cGVTdHlsZUZ1bmN0aW9uIiwiZWxlc2ZuJDQiLCJkaXJ0eVN0eWxlQ2FjaGUiLCJkaXJ0eSIsIm5vdGlmeVJlbmRlcmVyIiwiYkVsZXMiLCJiYXRjaFN0eWxlRWxlcyIsInVwZGF0ZWRFbGVzIiwiY2hhbmdlZEVsZXMiLCJjbGVhblN0eWxlIiwicGFyc2VkU3R5bGUiLCJwcm9wZXJ0eSIsImluY2x1ZGVOb25EZWZhdWx0Iiwib3ZlcnJpZGRlblN0eWxlIiwiZ2V0RGVmYXVsdFByb3BlcnR5IiwibnVtZXJpY1N0eWxlIiwibnVtZXJpY1N0eWxlVW5pdHMiLCJyZW5kZXJlZFN0eWxlIiwiZ2V0UmVuZGVyZWRTdHlsZSIsInVwZGF0ZVRyYW5zaXRpb25zIiwiYXBwbHlCeXBhc3MiLCJnZXRTdHlsZVByb3BlcnR5VmFsdWUiLCJnZXRSYXdTdHlsZSIsInJlbW92ZVN0eWxlIiwicmVtb3ZlQWxsQnlwYXNzZXMiLCJyZW1vdmVCeXBhc3NlcyIsInNob3ciLCJoaWRlIiwiZWZmZWN0aXZlT3BhY2l0eSIsInBhcmVudE9wYWNpdHkiLCJjaGVja0NvbXBvdW5kIiwicGFyZW50T2siLCJkZWZpbmVEZXJpdmVkU3RhdGVGdW5jdGlvbiIsInNwZWNzIiwib2siLCJlZGdlT2tWaWFOb2RlIiwiZWxlVGFrZXNVcFNwYWNlIiwiZWxlSW50ZXJhY3RpdmUiLCJwYXJlbnRJbnRlcmFjdGl2ZSIsImludGVyYWN0aXZlIiwibm9uaW50ZXJhY3RpdmUiLCJlbGVWaXNpYmxlIiwiZWRnZVZpc2libGVWaWFOb2RlIiwiaGlkZGVuIiwiaXNCdW5kbGVkQmV6aWVyIiwicmVuZGVyZWRDc3MiLCJyZW1vdmVCeXBhc3MiLCJyZW1vdmVDc3MiLCJlbGVzZm4kMyIsImRlZmluZVN3aXRjaEZ1bmN0aW9uIiwiX2hhbmRsZXIiLCJhZGRsRXZlbnRzIiwiYWJsZSIsImFibGVGaWVsZCIsIm92ZXJyaWRlQWJsZSIsImNoYW5nZWRDb2xsIiwiZGVmaW5lU3dpdGNoU2V0Iiwib3ZlcnJpZGVGaWVsZCIsImF1dG9sb2NrIiwiYXV0b3VuZ3JhYmlmeSIsImF1dG91bnNlbGVjdGlmeSIsImRlc2VsZWN0IiwidW5zZWxlY3QiLCJpbmFjdGl2ZSIsImVsZXNmbiQyIiwiZGVmaW5lRGFnRXh0cmVtaXR5IiwiZGFnRXh0cmVtaXR5SW1wbCIsImRpc3F1YWxpZmllZCIsIm5vSW5jb21pbmdFZGdlcyIsIm5vT3V0Z29pbmdFZGdlcyIsImRlZmluZURhZ09uZUhvcCIsIm9FbGVzIiwiZGVmaW5lRGFnQWxsSG9wcyIsInNFbGVzIiwic0VsZXNJZHMiLCJuZXdOZXh0IiwibmlkIiwiY2xlYXJUcmF2ZXJzYWxDYWNoZSIsInN1Y2Nlc3NvcnMiLCJwcmVkZWNlc3NvcnMiLCJvdGhlck5vZGUiLCJjbG9zZWROZWlnaGJvcmhvb2QiLCJuZWlnaGJvdXJob29kIiwiY2xvc2VkTmVpZ2hib3VyaG9vZCIsIm9wZW5OZWlnaGJvdXJob29kIiwic291cmNlSW1wbCIsInRhcmdldEltcGwiLCJzb3VyY2VzIiwiZGVmaW5lU291cmNlRnVuY3Rpb24iLCJ0YXJnZXRzIiwiZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24iLCJ0aGlzSXNTcmMiLCJlZGdlc1dpdGhJbXBsIiwib3RoZXJOb2RlcyIsImVkZ2VEYXRhIiwidGhpc1RvT3RoZXIiLCJvdGhlclRvVGhpcyIsImVkZ2VDb25uZWN0c1RoaXNBbmRPdGhlciIsInRoaXNJc1RndCIsInBhcmFsbGVsRWRnZXMiLCJkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24iLCJjb2RpcmVjdGVkRWRnZXMiLCJjb2RpcmVjdGVkIiwicGFyYWxsZWxFZGdlc0ltcGwiLCJlZGdlMSIsImVkZ2UxX3AiLCJzcmMxIiwic3JjaWQxIiwidGd0aWQxIiwic3JjRWRnZXMxIiwiZWRnZTIiLCJlZGdlMmRhdGEiLCJ0Z3RpZDIiLCJzcmNpZDIiLCJvcHBkaXJlY3RlZCIsInZpc2l0ZWQiLCJ1bnZpc2l0ZWQiLCJ2aXNpdEluQ29tcG9uZW50IiwiY21wdCIsImNvbXBvbmVudHNPZiIsIkNvbGxlY3Rpb24iLCJ1bmlxdWUiLCJjcmVhdGVkRWxlbWVudHMiLCJlbGVzSWRzIiwianNvbiIsIl9kYXRhIiwiX2wiLCJlbGVtZW50JDEiLCJsYXp5TWFwIiwicmVidWlsZE1hcCIsImVsZXNmbiQxIiwiJGlkIiwiX2RhdGEyIiwibW92ZSIsIm5ld1BhcmVudFZhbFNwZWNkIiwiY2hlY2tTd2l0Y2giLCJ0cnVlRm5OYW1lIiwiZmFsc2VGbk5hbWUiLCJvYmpfayIsImpzb25zIiwiZWxlc0FyciIsImFkZFRvUG9vbCIsImN5X3AiLCJyZW1vdmVGcm9tRWxlbWVudHMiLCJfZGF0YTMiLCJmaWVsZHMiLCJmaWVsZHNMZW5ndGgiLCJiYWRTb3VyY2VPclRhcmdldCIsIl9kYXRhNCIsInBhcmVudElkIiwic3BlY2lmaWVkUGFyZW50Iiwic2VsZkFzUGFyZW50IiwicmVzdG9yZWQiLCJfZWxlMyIsInRvVXBkYXRlU3R5bGUiLCJpbnNpZGUiLCJyZW1vdmVGcm9tUG9vbCIsImVsZXNUb1JlbW92ZSIsImVsZXNUb1JlbW92ZUlkcyIsImFkZENvbm5lY3RlZEVkZ2VzIiwiYWxyZWFkeUFkZGVkIiwicmVtb3ZlRWRnZVJlZiIsInJlbW92ZVBhcmFsbGVsUmVmIiwicGxsRWRnZSIsImFsdGVyZWRQYXJlbnRzIiwiaWRzIiwicmVtb3ZlQ2hpbGRSZWYiLCJwaWQiLCJfZWxlNCIsInBsbEVkZ2VzIiwiZWxlc1N0aWxsSW5zaWRlIiwiX2VsZTUiLCJyZW1vdmVkRWxlbWVudHMiLCJfZWxlNiIsInN0cnVjdCIsIm1vZGlmeVBvb2wiLCJzcmNFeGlzdHMiLCJ0Z3RFeGlzdHMiLCJiYXRjaCIsIl9kYXRhNSIsInBhcmVudEV4aXN0cyIsInBpZFRvQXNzaWduIiwidXBkYXRlZCIsIl9kYXRhNiIsImNvcmVmbiQ5IiwiX2pzb25zIiwiZWxlc0J5R3JvdXAiLCJfanNvbnMyIiwiZ3JzIiwiZWxlc0FycmF5IiwiamwiLCJfanNvbiIsImdlbmVyYXRlQ3ViaWNCZXppZXIiLCJtWDEiLCJtWTEiLCJtWDIiLCJtWTIiLCJORVdUT05fSVRFUkFUSU9OUyIsIk5FV1RPTl9NSU5fU0xPUEUiLCJTVUJESVZJU0lPTl9QUkVDSVNJT04iLCJTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyIsImtTcGxpbmVUYWJsZVNpemUiLCJrU2FtcGxlU3RlcFNpemUiLCJmbG9hdDMyQXJyYXlTdXBwb3J0ZWQiLCJGbG9hdDMyQXJyYXkiLCJtU2FtcGxlVmFsdWVzIiwiYUExIiwiYUEyIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJuZXd0b25SYXBoc29uSXRlcmF0ZSIsImFYIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsImNhbGNTYW1wbGVWYWx1ZXMiLCJiaW5hcnlTdWJkaXZpZGUiLCJhQSIsImFCIiwiY3VycmVudFQiLCJnZXRURm9yWCIsImludGVydmFsU3RhcnQiLCJjdXJyZW50U2FtcGxlIiwibGFzdFNhbXBsZSIsImd1ZXNzRm9yVCIsImluaXRpYWxTbG9wZSIsIl9wcmVjb21wdXRlZCIsInByZWNvbXB1dGUiLCJnZW5lcmF0ZVNwcmluZ1JLNCIsInNwcmluZ0FjY2VsZXJhdGlvbkZvclN0YXRlIiwidGVuc2lvbiIsImZyaWN0aW9uIiwic3ByaW5nRXZhbHVhdGVTdGF0ZVdpdGhEZXJpdmF0aXZlIiwiaW5pdGlhbFN0YXRlIiwiZHQiLCJkZXJpdmF0aXZlIiwiZHYiLCJzcHJpbmdJbnRlZ3JhdGVTdGF0ZSIsImR4ZHQiLCJkdmR0Iiwic3ByaW5nUks0RmFjdG9yeSIsImluaXRTdGF0ZSIsInRpbWVfbGFwc2VkIiwiRFQiLCJoYXZlX2R1cmF0aW9uIiwibGFzdF9zdGF0ZSIsInBlcmNlbnRDb21wbGV0ZSIsImN1YmljQmV6aWVyIiwiYmV6aWVyIiwicGVyY2VudCIsImVhc2luZ3MiLCJsaW5lYXIiLCJzcHJpbmciLCJnZXRFYXNlZFZhbHVlIiwiZWFzaW5nRm4iLCJyb3VuZFZhbHVlIiwiZWFzZSIsInN0YXJ0UHJvcCIsImVuZFByb3AiLCJwcm9wU3BlYyIsImVhc2VkQXJyIiwic2kiLCJzdGVwJDEiLCJwRWFzaW5nIiwic3RhcnRUaW1lIiwiZWFzaW5nSW1wbCIsImVhc2luZ1ZhbHMiLCJlYXNpbmdQcm9wIiwic3RhcnRQb3MiLCJlbmRQb3MiLCJlbmRQYW4iLCJhbmltYXRpbmdQYW4iLCJlbmRab29tIiwiYW5pbWF0aW5nWm9vbSIsIm1pblpvb20iLCJtYXhab29tIiwiX25hbWUiLCJlYXNlZFZhbCIsIm92ZXJyaWRlQnlwYXNzIiwic3RhcnRBbmltYXRpb24iLCJzdGVwQWxsIiwiYW5pRWxlcyIsImRvbmVFbGVzIiwic3RlcE9uZSIsInJhbkFuaXMiLCJjYWxsYmFja3MiLCJfY2FsbGJhY2tzIiwic3RlcCIsInJhbkVsZUFuaSIsImhhbmRsZWRUaGlzRWxlIiwicmFuQ29yZUFuaSIsImNvcmVmbiQ4Iiwic3RvcEFuaW1hdGlvbkxvb3AiLCJhbmltYXRpb25zUnVubmluZyIsInN0YXJ0QW5pbWF0aW9uTG9vcCIsImhlYWRsZXNzU3RlcCIsImFuaW1hdGlvblN0ZXAiLCJiZWZvcmVSZW5kZXIiLCJyZW5kZXJlckFuaW1hdGlvblN0ZXAiLCJ3aWxsRHJhdyIsImJlZm9yZVJlbmRlclByaW9yaXRpZXMiLCJlbWl0dGVyT3B0aW9ucyIsImVsZXNmbiIsImNvcmVmbiQ3IiwicG5nIiwianBnIiwiYmciLCJqcGVnIiwiY29yZWZuJDYiLCJMYXlvdXQiLCJleHRlbnNpb24iLCJjb3JlZm4kNSIsImV2ZW50TmFtZSIsImV2ZW50RWxlcyIsImJhdGNoTm90aWZpY2F0aW9ucyIsIm5vdGlmaWNhdGlvbnNFbmFibGVkIiwiZGVzdHJveWVkIiwibm90aWZpY2F0aW9ucyIsImJvb2wiLCJub05vdGlmaWNhdGlvbnMiLCJiYXRjaENvdW50IiwiYmF0Y2hEYXRhIiwicmVuZGVyZXJEZWZhdWx0cyIsImhpZGVFZGdlc09uVmlld3BvcnQiLCJ0ZXh0dXJlT25WaWV3cG9ydCIsIm1vdGlvbkJsdXIiLCJtb3Rpb25CbHVyT3BhY2l0eSIsInBpeGVsUmF0aW8iLCJkZXNrdG9wVGFwVGhyZXNob2xkIiwidG91Y2hUYXBUaHJlc2hvbGQiLCJ3aGVlbFNlbnNpdGl2aXR5IiwiZGVidWciLCJzaG93RnBzIiwid2ViZ2wiLCJ3ZWJnbERlYnVnIiwid2ViZ2xEZWJ1Z1Nob3dBdGxhc2VzIiwid2ViZ2xUZXhTaXplIiwid2ViZ2xUZXhSb3dzIiwid2ViZ2xUZXhSb3dzTm9kZXMiLCJ3ZWJnbEJhdGNoU2l6ZSIsIndlYmdsVGV4UGVyQmF0Y2giLCJ3ZWJnbEJnQ29sb3IiLCJjb3JlZm4kNCIsInJlbmRlclRvIiwicHhSYXRpbyIsImZvcmNlUmVuZGVyIiwicmVzaXplIiwiaW52YWxpZGF0ZVNpemUiLCJpbml0UmVuZGVyZXIiLCJSZW5kZXJlclByb3RvIiwick9wdHMiLCJkZXN0cm95UmVuZGVyZXIiLCJkb21FbGUiLCJjb250YWluZXIiLCJfY3lyZWciLCJjaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJvblJlbmRlciIsIm9mZlJlbmRlciIsImludmFsaWRhdGVEaW1lbnNpb25zIiwiY29yZWZuJDMiLCJzdHlmbiQ4IiwiRkFMU0UiLCJpZSIsImN4dE1ldGEiLCJnZXRDb250ZXh0TWV0YSIsImN4dFN0eWxlIiwiZ2V0Q29udGV4dFN0eWxlIiwiYXBwIiwiYXBwbHlDb250ZXh0U3R5bGUiLCJhcHBsaWVkSW5pdFN0eWxlIiwiZGlmZlByb3BzIiwiaGludHNEaWZmIiwidXBkYXRlU3R5bGVIaW50cyIsImdldFByb3BlcnRpZXNEaWZmIiwib2xkQ3h0S2V5IiwibmV3Q3h0S2V5IiwicHJvcERpZmZzIiwiZHVhbEN4dEtleSIsImNhY2hlZFZhbCIsImFkZGVkUHJvcCIsImN4dCIsIm9sZEhhc0N4dCIsIm5ld0hhc0N4dCIsImN4dEhhc0RpZmZlZCIsImN4dEhhc01hcHBlZFByb3BzIiwibWFwcGVkUHJvcGVydGllcyIsImxhdGVyQ3h0T3ZlcnJpZGVzIiwibGF0ZXJDeHQiLCJoYXNMYXRlckN4dCIsImN4dEtleSIsInByZXZLZXkiLCJzdHlsZUN4dEtleSIsImNvbnRleHRTZWxlY3Rvck1hdGNoZXMiLCJkaWZmUHJvcE5hbWVzIiwiY3h0U3R5bGVzIiwiY29udGV4dFN0eWxlcyIsImhhc0N4dCIsInJldERpZmZQcm9wcyIsInR5cGVzIiwiZGlmZlByb3BOYW1lIiwiY3h0UHJvcCIsImVsZVByb3AiLCJkZWxldGVCeXBhc3NlZCIsIm1hcHBlZCIsIm1hcHBpbmciLCJmblZhbHVlIiwicHJldkZuVmFsdWUiLCJyZXREaWZmUHJvcCIsImFwcGx5UGFyc2VkUHJvcGVydHkiLCJieXBhc3NlZCIsInByb3BOYW1lcyIsInByb3BlcnR5R3JvdXBOYW1lcyIsInByb3BHcktleXMiLCJwcm9wZXJ0eUdyb3VwS2V5cyIsInByb3BIYXNoIiwic2VlZEtleSIsImdldFByb3BlcnRpZXNIYXNoIiwib2xkU3R5bGVLZXkiLCJzdHlsZUtleSIsIm92ZXJyaWRkZW5TdHlsZXMiLCJncktleSIsInVwZGF0ZUdyS2V5MSIsInVwZGF0ZUdyS2V5MiIsInVwZGF0ZUdyS2V5IiwidXBkYXRlR3JLZXlXU3RyIiwic3RyVmFsIiwiY2xlYW5OdW0iLCJwYXJzZWRQcm9wIiwicHJvcEluZm8iLCJfZ3JLZXkiLCJncm91cEtleSIsIm5vcm1hbGl6ZWROdW1iZXJWYWwiLCJoYXNoT3ZlcnJpZGUiLCJudW1iZXJWYWwiLCJlbnVtcyIsImhhdmVOb3JtTnVtIiwiaGF2ZVVuaXRlZE51bSIsImhhdmVOdW0iLCJtdWx0aXBsZSIsIl9ncktleTIiLCJnckhhc2giLCJzayIsImxhYmVsRGltc0tleSIsImxhYmVsRGltZW5zaW9ucyIsImxhYmVsS2V5cyIsImxhYmVsS2V5IiwibGFiZWxTdHlsZUtleSIsImNvbW1vbkxhYmVsIiwic291cmNlTGFiZWxLZXlzIiwic291cmNlTGFiZWxLZXkiLCJzb3VyY2VMYWJlbFN0eWxlS2V5IiwidGFyZ2V0TGFiZWxLZXlzIiwidGFyZ2V0TGFiZWxLZXkiLCJ0YXJnZXRMYWJlbFN0eWxlS2V5IiwiX3Akc3R5bGVLZXlzIiwibm9kZUJvZHkiLCJub2RlQm9yZGVyIiwibm9kZU91dGxpbmUiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJwaWUiLCJzdHJpcGUiLCJub2RlS2V5cyIsIm5vZGVLZXkiLCJoYXNQaWUiLCJoYXNTdHJpcGUiLCJjbGVhclN0eWxlSGludHMiLCJmbGF0UHJvcCIsInByb3BJc0J5cGFzcyIsIm9yaWdQcm9wIiwib3JpZ1Byb3BJc0J5cGFzcyIsImZsYXRQcm9wTWFwcGluZyIsImdldFZhbCIsImNoZWNrVHJpZ2dlcnMiLCJmcm9tVmFsIiwidG9WYWwiLCJkZWxldGVCeXBhc3MiLCJwcmludE1hcHBpbmdFcnIiLCJtYXBEYXRhIiwiZmllbGRXaWR0aCIsImZpZWxkTWF4IiwiZmllbGRNaW4iLCJyMSIsInZhbHVlTWluIiwicjIiLCJ2YWx1ZU1heCIsImcxIiwiZzIiLCJiMSIsImExIiwiYTIiLCJjbHIiLCJjYWxjVmFsdWUiLCJfZmllbGRzIiwiX2ZpZWxkVmFsIiwiZm5SZXRWYWwiLCJjbGVhbkVsZW1lbnRzIiwia2VlcEJ5cGFzc2VzIiwiYW55UHJldiIsInN0eVByb3AiLCJkaWZmUHJvcCIsInByZXZQcm9wIiwiZnJvbVByb3AiLCJ0b1Byb3AiLCJpbml0VmFsIiwiaW5pdER0IiwidHJhbnNpdGlvbmluZyIsImNoZWNrVHJpZ2dlciIsImZyb21WYWx1ZSIsInRvVmFsdWUiLCJnZXRUcmlnZ2VyIiwib25UcmlnZ2VyIiwidHJpZ2dlckNoZWNrIiwiY2hlY2taT3JkZXJUcmlnZ2VyIiwidHJpZ2dlcnNaT3JkZXIiLCJjaGVja0JvdW5kc1RyaWdnZXIiLCJ0cmlnZ2Vyc0JvdW5kcyIsImNoZWNrQ29ubmVjdGVkRWRnZXNCb3VuZHNUcmlnZ2VyIiwidHJpZ2dlcnNCb3VuZHNPZkNvbm5lY3RlZEVkZ2VzIiwiY2hlY2tQYXJhbGxlbEVkZ2VzQm91bmRzVHJpZ2dlciIsInRyaWdnZXJzQm91bmRzT2ZQYXJhbGxlbEVkZ2VzIiwic3R5Zm4kNyIsImlzQnlwYXNzIiwiX3BhcnNlZFByb3AiLCJzcGVjaWZpZWRQcm9wcyIsIl9uYW1lMiIsIl92YWx1ZSIsIl9wYXJzZWRQcm9wMiIsIl9wcm9wIiwiaXNDb2xvciIsImlzTXVsdGkiLCJtdXRpcGxlIiwib2xkVmFsdWUiLCJwcm9wZXJ0eU5hbWVzIiwic3R5Zm4kNiIsImdldEVtU2l6ZUluUGl4ZWxzIiwicHgiLCJjb250YWluZXJDc3MiLCJjb250YWluZXJXaW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInN0eWZuJDUiLCJpc1JlbmRlcmVkVmFsIiwiZ2V0SW5kZXhlZFN0eWxlIiwic3VicHJvcGVydHkiLCJhbGlhcyIsInBvaW50c1RvIiwic3R5bGVQcm9wIiwiZ2V0UmVuZGVyZWRWYWx1ZSIsImdldFZhbHVlU3RyaW5nV2l0aFVuaXRzIiwiaXNBcnJheVZhbHVlIiwiaGF2ZVVuaXRzIiwiYW5pUHJvcHMiLCJhbmlQcm9wIiwicHJvcHNPYmoiLCJnZXROb25EZWZhdWx0UHJvcGVydGllc0hhc2giLCJjaFZhbCIsInN0eWZuJDQiLCJhcHBlbmRGcm9tSnNvbiIsImZyb21Kc29uIiwicmVzZXRUb0RlZmF1bHQiLCJkZWZhdWx0TGVuZ3RoIiwic3R5Zm4kMyIsImFwcGVuZEZyb21TdHJpbmciLCJzZWxBbmRCbG9ja1N0ciIsImJsb2NrUmVtIiwicHJvcEFuZFZhbFN0ciIsInJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZyIsInJlbW92ZVByb3BBbmRWYWxGcm9tUmVtIiwibm90aGluZ0xlZnRUb1BhcnNlIiwic2VsQW5kQmxvY2siLCJzZWxlY3RvclN0ciIsImJsb2NrU3RyIiwiaW52YWxpZEJsb2NrIiwiX25vdGhpbmdMZWZ0VG9QYXJzZSIsInByb3BBbmRWYWwiLCJwcm9wU3RyIiwiZnJvbVN0cmluZyIsInN0eWZuJDIiLCJoZXgzJDEiLCJoZXg2JDEiLCJtYXBBcmciLCJ1cmxSZWdleGVzIiwiaW1wbGljaXRVbml0cyIsInBlcmNlbnRhZ2VzIiwiemVyb09uZU51bWJlciIsInVuaXRsZXNzIiwiemVyb09uZU51bWJlcnMiLCJuT25lT25lTnVtYmVyIiwibm9uTmVnYXRpdmVJbnQiLCJub25OZWdhdGl2ZU51bWJlciIsIm5vZGVTaXplIiwibnVtYmVycyIsInBvc2l0aXZlTnVtYmVyIiwic3RyaWN0TWluIiwiYmlkaXJlY3Rpb25hbFNpemUiLCJiaWRpcmVjdGlvbmFsU2l6ZU1heWJlUGVyY2VudCIsImFsbG93UGVyY2VudCIsImJpZGlyZWN0aW9uYWxTaXplcyIsInNpemVNYXliZVBlcmNlbnQiLCJheGlzRGlyZWN0aW9uIiwiYXhpc0RpcmVjdGlvbkV4cGxpY2l0IiwiYXhpc0RpcmVjdGlvblByaW1hcnkiLCJwYWRkaW5nUmVsYXRpdmVUbyIsImJnV0giLCJiZ1BvcyIsImJnUmVsYXRpdmVUbyIsImJnUmVwZWF0IiwiYmdGaXQiLCJiZ0Nyb3NzT3JpZ2luIiwiYmdDbGlwIiwiYmdDb250YWlubWVudCIsImJveFNlbGVjdGlvbiIsImZpbGwiLCJib29scyIsImxpbmVTdHlsZSIsImxpbmVDYXAiLCJsaW5lUG9zaXRpb24iLCJsaW5lSm9pbiIsImJvcmRlclN0eWxlIiwicmFkaXVzVHlwZSIsImZvbnRGYW1pbHkiLCJmb250U3R5bGUiLCJmb250V2VpZ2h0IiwidGV4dERlY29yYXRpb24iLCJ0ZXh0VHJhbnNmb3JtIiwidGV4dFdyYXAiLCJ0ZXh0T3ZlcmZsb3dXcmFwIiwidGV4dEJhY2tncm91bmRTaGFwZSIsIm5vZGVTaGFwZSIsIm92ZXJsYXlTaGFwZSIsImNvbXBvdW5kSW5jbHVkZUxhYmVscyIsImFycm93U2hhcGUiLCJhcnJvd0ZpbGwiLCJkaXNwbGF5IiwidmlzaWJpbGl0eSIsInpDb21wb3VuZERlcHRoIiwiekluZGV4Q29tcGFyZSIsImp1c3RpZmljYXRpb24iLCJsYXlvdXREYXRhIiwibWFwTGF5b3V0RGF0YSIsIm1hcFNjcmF0Y2giLCJ1cmwiLCJyZWdleGVzIiwic2luZ2xlUmVnZXhNYXRjaFZhbHVlIiwidXJscyIsInByb3BMaXN0IiwidGV4dFJvdGF0aW9uIiwicG9seWdvblBvaW50TGlzdCIsImV2ZW5NdWx0aXBsZSIsImVkZ2VEaXN0YW5jZXMiLCJlZGdlRW5kcG9pbnQiLCJzaW5nbGVFbnVtIiwidmFsaWRhdGUiLCJ2YWxBcnIiLCJ1bml0c0FyciIsImdyYWRpZW50RGlyZWN0aW9uIiwiYm91bmRzRXhwYW5zaW9uIiwiemVyb05vblplcm8iLCJ2YWwxIiwidmFsMiIsImFueSIsImVtcHR5Tm9uRW1wdHkiLCJzdHIxIiwic3RyMiIsImVtcHR5MSIsImVtcHR5MiIsIm1haW5MYWJlbCIsInNvdXJjZUxhYmVsIiwidGFyZ2V0TGFiZWwiLCJiZWhhdmlvciIsIm92ZXJsYXkiLCJ1bmRlcmxheSIsInRyYW5zaXRpb24iLCJub2RlU2l6ZUhhc2hPdmVycmlkZSIsImVkZ2VMaW5lIiwicGllQmFja2dyb3VuZE4iLCJzdHJpcGVCYWNrZ3JvdW5kTiIsImVkZ2VBcnJvdyIsImFycm93UHJlZml4ZXMiLCJwcm9wR3JvdXBzIiwicHJvcGVydHlHcm91cHMiLCJwcm9wR3JvdXBOYW1lcyIsInByb3BHcm91cEtleXMiLCJhbGlhc2VzIiwicG9pbnRzVG9Qcm9wIiwiYWxpYXNQcm9wIiwiZ2V0RGVmYXVsdFByb3BlcnRpZXMiLCJkZWZhdWx0UHJvcGVydGllcyIsInJhd1Byb3BzIiwicGFyc2VkUHJvcHMiLCJhZGREZWZhdWx0U3R5bGVzaGVldCIsInN0eWZuJDEiLCJwcm9wSXNGbGF0IiwicGFyc2VJbXBsV2FybiIsImZsYXRLZXkiLCJieXBhc3NLZXkiLCJ2YWx1ZUtleSIsImFyZ0hhc2giLCJwcm9wQ2FjaGUiLCJwYXJzZUltcGwiLCJwYXNzZWRWYWx1ZSIsInRyaW0iLCJfbWFwcGVkIiwicGZWYWxBcnIiLCJoYXNFbnVtIiwiY2hlY2tFbnVtcyIsImVuIiwidW5pdHNSZWdleCIsInN0cmljdE1heCIsInByb3BzU3RyIiwicHJvcHNTcGxpdCIsInR1cGxlIiwiZW51bVByb3AiLCJfU3R5bGUiLCJTdHlsZSIsImNvcmVTdHlsZSIsInN0eWZuIiwiZWxlX3AiLCJtYXBWYWwiLCJjc3NSdWxlIiwiY3VycmVudFNlbGVjdG9ySXNDb3JlIiwiYXBwZW5kIiwiYXBwZW5kVG9TdHlsZSIsImNvcmVmbiQyIiwibmV3U3R5bGUiLCJzZXRTdHlsZSIsImdlbmVyYXRlU3R5bGUiLCJkZWZhdWx0U2VsZWN0aW9uVHlwZSIsImNvcmVmbiQxIiwic2VsZWN0aW9uVHlwZSIsInNlbFR5cGUiLCJwYW5uaW5nRW5hYmxlZCIsInVzZXJQYW5uaW5nRW5hYmxlZCIsInpvb21pbmdFbmFibGVkIiwidXNlclpvb21pbmdFbmFibGVkIiwiYm94U2VsZWN0aW9uRW5hYmxlZCIsImFyZzAiLCJnYyIsInZpZXdwb3J0U3RhdGUiLCJiYmUiLCJ6b29tUmFuZ2UiLCJjdXJyZW50UGFuIiwiY3VycmVudFpvb20iLCJiYWlsIiwibGV2ZWwiLCJwYW4xIiwiem9vbTEiLCJ6b29tMiIsInBhbjIiLCJ2aWV3cG9ydCIsInpvb21EZWZkIiwicGFuRGVmZCIsInpvb21GYWlsZWQiLCJwYW5GYWlsZWQiLCJ6IiwiY2FuY2VsT25GYWlsZWRab29tIiwicmVzZXQiLCJzaXplQ2FjaGUiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImV4dGVudCIsInJiIiwicmVuZGVyZWRFeHRlbnQiLCJtdWx0aUNsaWNrRGVib3VuY2VUaW1lIiwiX2ludCIsImF1dG9sb2NrTm9kZXMiLCJhdXRvdW5ncmFiaWZ5Tm9kZXMiLCJDb3JlIiwicmVnIiwiZGVzdHJveSIsInJlYWRpZXMiLCJoZWFkIiwiZGVmVmFsIiwiZGVmIiwiYWx0VmFsIiwibG9hZEV4dERhdGEiLCJleHREYXRhIiwiYW55SXNQcm9taXNlIiwicmVuZGVyZXJPcHRpb25zIiwic2V0RWxlc0FuZExheW91dCIsIm9ubG9hZCIsIm9uZG9uZSIsIm9sZEVsZXMiLCJsYXlvdXRPcHRzIiwidGhlbnMiLCJpbml0U3R5bGUiLCJpbml0RWxlcyIsImNvcmVmbiIsImlzUmVhZHkiLCJpc0hlYWRsZXNzIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwibW91bnQiLCJ1bm1vdW50IiwiZ2V0RnJlc2hSZWYiLCJpZEluSnNvbiIsInVwZGF0ZUVsZXMiLCJnciIsInRvTW9kIiwiX3RvTW9kJF9pIiwicGFyZW50c1RvUmVtb3ZlIiwiZmxhdCIsImRlZmF1bHRzJDciLCJjaXJjbGUiLCJncmlkIiwiYXZvaWRPdmVybGFwIiwiZGVwdGhTb3J0IiwiZGVwcmVjYXRlZE9wdGlvbkRlZmF1bHRzIiwibWF4aW1hbCIsImFjeWNsaWMiLCJzZXRJbmZvIiwiQnJlYWR0aEZpcnN0TGF5b3V0IiwiZ3JhcGgiLCJtYXhpbWFsQWRqdXN0bWVudHMiLCJoYXNCb3VuZGluZ0JveCIsInN0cnVjdHVyZWRDbG9uZSIsInJvb3RzQXJyYXkiLCJjb21wIiwiY29tcFJvb3RzIiwiZGVwdGhzIiwiZm91bmRCeUJmcyIsImFkZFRvRGVwdGgiLCJjaGFuZ2VEZXB0aCIsIm5ld0RlcHRoIiwicE5vZGUiLCJvcnBoYW5Ob2RlcyIsImFzc2lnbkRlcHRoc0F0IiwiYWRqdXN0TWF4aW1hbGx5Iiwic2hpZnRlZCIsImVJbmZvIiwibWF4RGVwdGgiLCJpbmNtciIsImlJbmZvIiwiZW5xdWV1ZSIsImRlcXVldWUiLCJkaWRTaGlmdCIsIm1pbkRpc3RhbmNlIiwibmJiIiwiY2FjaGVkV2VpZ2h0ZWRQZXJjZW50IiwiZ2V0V2VpZ2h0ZWRQZXJjZW50IiwiZWxlRGVwdGgiLCJzYW1wbGVzIiwiYmYiLCJuRGVwdGgiLCJhcGN0IiwiYnBjdCIsImRlcHRoc0xlbiIsIm9ycGhhbkRlcHRoIiwiYXNzaWduRGVwdGhzIiwiYmlnZ2VzdERlcHRoU2l6ZSIsImF2ZU5vZGVTaXplIiwiYWNjIiwiZGlzdGFuY2VZIiwibWF4RGVwdGhTaXplIiwiZ2V0UG9zaXRpb25Ub3BCb3R0b20iLCJfZ2V0SW5mbzIiLCJyYWRpdXNTdGVwU2l6ZSIsImRlcHRoU2l6ZSIsImRpc3RhbmNlWCIsImVwb3MiLCJyb3RhdGVEZWdyZWVzIiwiZ2V0UG9zaXRpb24iLCJkZWZhdWx0cyQ2Iiwic3dlZXAiLCJjbG9ja3dpc2UiLCJDaXJjbGVMYXlvdXQiLCJjb3VudGVyY2xvY2t3aXNlIiwiZFRoZXRhIiwiZGNvcyIsImRzaW4iLCJyTWluIiwiZ2V0UG9zIiwicngiLCJyeSIsImRlZmF1bHRzJDUiLCJlcXVpZGlzdGFudCIsIm1pbk5vZGVTcGFjaW5nIiwiY29uY2VudHJpYyIsImxldmVsV2lkdGgiLCJDb25jZW50cmljTGF5b3V0Iiwibm9kZVZhbHVlcyIsIm1heE5vZGVTaXplIiwibGV2ZWxzIiwiY3VycmVudExldmVsIiwibWluRGlzdCIsImZpcnN0THZsSGFzTXVsdGkiLCJtYXhSIiwiclN0ZXAiLCJyRGVsdGFNYXgiLCJfciIsIl9sZXZlbCIsInJEZWx0YSIsIl9sZXZlbDIiLCJfbGV2ZWwzIiwiX2RUaGV0YSIsIl9yMiIsIl92YWwiLCJERUJVRyIsImRlZmF1bHRzJDQiLCJhbmltYXRpb25UaHJlc2hvbGQiLCJyZWZyZXNoIiwicmFuZG9taXplIiwiY29tcG9uZW50U3BhY2luZyIsIm5vZGVSZXB1bHNpb24iLCJub2RlT3ZlcmxhcCIsImlkZWFsRWRnZUxlbmd0aCIsImVkZ2VFbGFzdGljaXR5IiwibmVzdGluZ0ZhY3RvciIsImdyYXZpdHkiLCJpbml0aWFsVGVtcCIsImNvb2xpbmdGYWN0b3IiLCJtaW5UZW1wIiwiQ29zZUxheW91dCIsIm5vdEVkZ2VzIiwiaGFzU291cmNlIiwiaGFzVGFyZ2V0IiwibGF5b3V0SW5mbyIsImNyZWF0ZUxheW91dEluZm8iLCJwcmludExheW91dEluZm8iLCJyYW5kb21pemVQb3NpdGlvbnMiLCJyZWZyZXNoUG9zaXRpb25zIiwibWFpbkxvb3AiLCJ0ZW1wZXJhdHVyZSIsImdldFNjYWxlZFBvcyIsImdldFNjYWxlSW5Cb3VuZHNGbiIsImxvb3BSZXQiLCJfZnJhbWUiLCJmcmFtZSIsInNlcGFyYXRlQ29tcG9uZW50cyIsInRocmVhZCIsImlzQ29tcG91bmQiLCJsYXlvdXROb2RlcyIsImlkVG9JbmRleCIsImdyYXBoU2V0IiwiaW5kZXhUb0dyYXBoIiwibGF5b3V0RWRnZXMiLCJlZGdlU2l6ZSIsImlkMmNtcHRJZCIsInRlbXBOb2RlIiwiaXNMb2NrZWQiLCJjbXB0SWQiLCJwb3NpdGlvblgiLCJwb3NpdGlvblkiLCJwYWRMZWZ0IiwicGFkUmlnaHQiLCJwYWRUb3AiLCJwYWRCb3R0b20iLCJ0ZW1wR3JhcGgiLCJwX2lkIiwibm9kZV9pZCIsIm5vZGVfaXgiLCJ0ZW1wRWRnZSIsImlkZWFsTGVuZ3RoIiwiZWxhc3RpY2l0eSIsInNvdXJjZUl4IiwidGFyZ2V0SXgiLCJzb3VyY2VHcmFwaCIsInRhcmdldEdyYXBoIiwibGNhIiwiZmluZExDQSIsImxjYUdyYXBoIiwiX2ZpbmRMQ0FfYXV4IiwiY291bnQiLCJmaW5kTENBX2F1eCIsImdyYXBoSXgiLCJub2RlSXgiLCJjaGlsZEdyYXBoSXgiLCJjb3NlQkIiLCJsbm9kZSIsInBjdFgiLCJwY3RZIiwiY2FsY3VsYXRlTm9kZUZvcmNlcyIsImNhbGN1bGF0ZUVkZ2VGb3JjZXMiLCJjYWxjdWxhdGVHcmF2aXR5Rm9yY2VzIiwicHJvcGFnYXRlRm9yY2VzIiwidXBkYXRlUG9zaXRpb25zIiwicmFuZG9tRGlzdGFuY2UiLCJjbXB0SWQxIiwiY21wdElkMiIsImRpcmVjdGlvblgiLCJkaXJlY3Rpb25ZIiwibWF4UmFuZERpc3QiLCJvdmVybGFwIiwibm9kZXNPdmVybGFwIiwiZm9yY2VYIiwiZm9yY2VZIiwicG9pbnQxIiwiZmluZENsaXBwaW5nUG9pbnQiLCJwb2ludDIiLCJkaXN0YW5jZVNxciIsImRYIiwiZFkiLCJvdmVybGFwWCIsIm92ZXJsYXBZIiwiWCIsIlkiLCJIIiwiVyIsImRpclNsb3BlIiwibm9kZVNsb3BlIiwibHgiLCJseSIsImRpc3RUaHJlc2hvbGQiLCJmeCIsImZ5Iiwibm9kZUluZGV4Iiwib2ZmWCIsIm9mZlkiLCJjaGlsZE5vZGUiLCJ0ZW1wRm9yY2UiLCJsaW1pdEZvcmNlIiwiX3VwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyIsInVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyIsImZsYWciLCJjaWQiLCJ0b3RhbEEiLCJ1c2VkVyIsInJvd0giLCJtYXhSb3dXIiwiZGVmYXVsdHMkMyIsImF2b2lkT3ZlcmxhcFBhZGRpbmciLCJjb25kZW5zZSIsInJvd3MiLCJjb2xzIiwiR3JpZExheW91dCIsImNlbGxzIiwic3BsaXRzIiwic21hbGwiLCJsYXJnZSIsIm9Sb3dzIiwib0NvbHMiLCJjb2x1bW5zIiwic20iLCJsZyIsIl9zbSIsIl9sZyIsImNlbGxXaWR0aCIsImNlbGxIZWlnaHQiLCJjZWxsVXNlZCIsInVzZWQiLCJ1c2UiLCJtb3ZlVG9OZXh0Q2VsbCIsImlkMm1hblBvcyIsInJjUG9zIiwiZGVmYXVsdHMkMiIsIk51bGxMYXlvdXQiLCJkZWZhdWx0cyQxIiwiUHJlc2V0TGF5b3V0IiwicG9zSXNGbiIsIlJhbmRvbUxheW91dCIsIk51bGxSZW5kZXJlciIsInRocm93SW1nRXJyIiwiQlJwJGYiLCJhcnJvd1NoYXBlV2lkdGgiLCJyZWdpc3RlckFycm93U2hhcGVzIiwiYXJyb3dTaGFwZXMiLCJiYkNvbGxpZGUiLCJ0cmFuc2xhdGlvbiIsImVkZ2VXaWR0aCIsInhSb3RhdGVkIiwieVJvdGF0ZWQiLCJ4U2NhbGVkIiwieVNjYWxlZCIsInhUcmFuc2xhdGVkIiwieVRyYW5zbGF0ZWQiLCJyZXRQdHMiLCJwb2ludHNUb0FyciIsInN0YW5kYXJkR2FwIiwiZGVmaW5lQXJyb3dTaGFwZSIsImRlZm4iLCJjb2xsaWRlIiwicm91Z2hDb2xsaWRlIiwiZHJhdyIsImFycm93U2hhcGVJbXBsIiwiZ2FwIiwiY29udHJvbFBvaW50IiwicHRzVHJhbnMiLCJjdHJsUHQiLCJjdHJsUHRUcmFucyIsInBvaW50c1RlZSIsInRyaVB0cyIsInRlZVB0cyIsInBvaW50c1RyIiwiY2lyY2xlSW5zaWRlIiwiZ2V0QXJyb3dXaWR0aCIsImJhc2VDcm9zc0xpbmVQdHMiLCJjcm9zc0xpbmVQdHMiLCJzaGlmdEZhY3RvciIsInkwIiwiQlJwJGUiLCJwcm9qZWN0SW50b1ZpZXdwb3J0IiwiY2xpZW50WCIsImNsaWVudFkiLCJvZmZzZXRzIiwiZmluZENvbnRhaW5lckNsaWVudENvb3JkcyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJjb250YWluZXJCQiIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzdHlsZVZhbHVlIiwicGFkZGluZ0hvciIsInBhZGRpbmdWZXIiLCJib3JkZXJIb3IiLCJ1bnNjYWxlZFciLCJ1bnNjYWxlZEgiLCJpbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUiLCJmaW5kTmVhcmVzdEVsZW1lbnQiLCJpbnRlcmFjdGl2ZUVsZW1lbnRzT25seSIsImlzVG91Y2giLCJmaW5kTmVhcmVzdEVsZW1lbnRzIiwiZ2V0Q2FjaGVkWlNvcnRlZEVsZXMiLCJuZWFyIiwiZWRnZVRocmVzaG9sZCIsIm5vZGVUaHJlc2hvbGQiLCJsYWJlbFRocmVzaG9sZCIsIm1pblNxRGlzdCIsIm5lYXJFZGdlIiwibmVhck5vZGUiLCJhZGRFbGUiLCJzcURpc3QiLCJjaGVja05vZGUiLCJodyIsImhoIiwicnMiLCJnZXROb2RlU2hhcGUiLCJjaGVja1BvaW50IiwiY2hlY2tFZGdlIiwic3R5bGVXaWR0aCIsIndpZHRoU3EiLCJ3aWR0aDIiLCJlZGdlVHlwZSIsImFsbHB0cyIsImFyU2l6ZSIsImFycm93cyIsImFycm93U3RhcnRYIiwiYXJyb3dTdGFydFkiLCJzcmNBcnJvd0FuZ2xlIiwiYXJyb3dFbmRYIiwiYXJyb3dFbmRZIiwidGd0QXJyb3dBbmdsZSIsIm1pZHNyY0Fycm93QW5nbGUiLCJtaWR0Z3RBcnJvd0FuZ2xlIiwiYXIiLCJwcmVwcm9wIiwicHJlIiwiY2hlY2tMYWJlbCIsInRoIiwiZXZlbnRzRW5hYmxlZCIsIm94Iiwib3kiLCJnZXRBbGxJbkJveCIsIngxYyIsIngyYyIsInkxYyIsInkyYyIsImJveEJiIiwic2VsZWN0aW9uQm94IiwiYm94RWRnZXMiLCJnZXRSb3RhdGVkTGFiZWxCb3giLCJkb0xpbmVzSW50ZXJzZWN0IiwiY2N3IiwidGV4dEV2ZW50cyIsIm5vZGVCb3hTZWxlY3RNb2RlIiwibGFiZWxCb3hTZWxlY3RFbmFibGVkIiwibm9kZUJiIiwicm90YXRlZExhYmVsQm94Iiwibm9kZUJvZHlCYiIsIm5vZGVCb2R5Q29ybmVycyIsIl9yb3RhdGVkTGFiZWxCb3giLCJlZGdlQm94U2VsZWN0TW9kZSIsImVuZFgiLCJlbmRZIiwiYWxsSW5zaWRlIiwiX3NlbGVjdGVkIiwiX3B0cyIsInNlZ1N0YXJ0Iiwic2VnRW5kIiwiX2JveEVkZ2VzJGIiLCJib3hTdGFydCIsImJveEVuZCIsIkJScCRkIiwiY2FsY3VsYXRlQXJyb3dBbmdsZXMiLCJpc0hheXN0YWNrIiwiaXNCZXppZXIiLCJpc011bHRpYmV6aWVyIiwiaXNTZWdtZW50cyIsImlzU2VsZiIsInNlZ3B0cyIsImJYIiwiYlkiLCJpMiIsImkxIiwiaXNSb3VuZCIsIm1pZFZlY3RvciIsImNwdHMiLCJjdHJscHRzIiwiYnAweCIsImJwMHkiLCJicDF4IiwiYnAxeSIsImljIiwibWlkRGlzcFgiLCJtaWREaXNwWSIsImkzIiwiZ2V0QXJyb3dIZWlnaHQiLCJhcnJvd1dpZHRoQ2FjaGUiLCJzaW5BIiwic2luQTkwIiwicmFkRGlyZWN0aW9uIiwiZHJhd0RpcmVjdGlvbiIsImhhbGZBbmdsZSIsImNSYWRpdXMiLCJsZW5PdXQiLCJsaW1pdCIsImxhc3RQb2ludCIsImFzVmVjIiwicHAiLCJueCIsIm55IiwiYW5nIiwiaW52ZXJ0VmVjIiwib3JpZ2luYWxWIiwiaW52ZXJ0ZWRWIiwiY2FsY0Nvcm5lckFyYyIsInByZXZpb3VzUG9pbnQiLCJjdXJyZW50UG9pbnQiLCJuZXh0UG9pbnQiLCJyYWRpdXNNYXgiLCJpc0FyY1JhZGl1cyIsImFzaW4iLCJkcmF3UHJlcGFyZWRSb3VuZENvcm5lciIsImN0eCIsInJvdW5kQ29ybmVyIiwibGluZVRvIiwiYXJjIiwiZW5kQW5nbGUiLCJjb3VudGVyQ2xvY2t3aXNlIiwiZ2V0Um91bmRDb3JuZXIiLCJBVk9JRF9JTVBPU1NJQkxFX0JFWklFUl9DT05TVEFOVCIsIkFWT0lEX0lNUE9TU0lCTEVfQkVaSUVSX0NPTlNUQU5UX0wiLCJCUnAkYyIsImZpbmRNaWRwdFB0c0V0YyIsInBhaXJJbmZvIiwicG9zUHRzIiwiaW50ZXJzZWN0aW9uUHRzIiwidmVjdG9yTm9ybUludmVyc2UiLCJtaWRwdFB0cyIsInNyY01hbkVuZHB0IiwidGd0TWFuRW5kcHQiLCJoYXZlTWFudWFsRW5kUHRzIiwicmVjYWxjVmVjdG9yTm9ybUludmVyc2UiLCJfdGhpcyRtYW51YWxFbmRwdFRvUHgiLCJtYW51YWxFbmRwdFRvUHgiLCJfdGhpcyRtYW51YWxFbmRwdFRvUHgyIiwiX3RoaXMkbWFudWFsRW5kcHRUb1B4MyIsIl90aGlzJG1hbnVhbEVuZHB0VG9QeDQiLCJlbmRQdHMiLCJmaW5kSGF5c3RhY2tQb2ludHMiLCJoYXlzdGFjayIsInNyY1BvcyIsInRndFBvcyIsInNyY1ciLCJ0Z3RXIiwic3JjSCIsInRndEgiLCJoYWxmUmFkaXVzIiwic3RvcmVFZGdlUHJvamVjdGlvbnMiLCJyZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb25zIiwiY2FsY3VsYXRlTGFiZWxBbmdsZXMiLCJmaW5kU2VnbWVudHNQb2ludHMiLCJzZWdtZW50V3MiLCJzZWdtZW50RHMiLCJzZWdtZW50UnMiLCJzZWdtZW50VHMiLCJzZWdtZW50c04iLCJsYXN0UmFkaXVzIiwibGFzdFJhZGl1c1R5cGUiLCJyYWRpaSIsIncxIiwidzIiLCJfdGhpcyRmaW5kTWlkcHRQdHNFdGMiLCJhZGp1c3RlZE1pZHB0IiwiZmluZExvb3BQb2ludHMiLCJlZGdlSXNVbmJ1bmRsZWQiLCJkaXJDb3VudHMiLCJjdHJscHREaXN0cyIsImN0cmxwdERpc3QiLCJsb29wRGlyIiwibG9vcFN3cCIsInN0ZXBTaXplIiwibG9vcERpc3QiLCJsb29wQW5nbGUiLCJvdXRBbmdsZSIsImluQW5nbGUiLCJmaW5kQ29tcG91bmRMb29wUG9pbnRzIiwibG9vcFciLCJsb29wYVBvcyIsImxvb3BiUG9zIiwibG9vcFBvcyIsIm1pbkNvbXBvdW5kU3RyZXRjaCIsImNvbXBvdW5kU3RyZXRjaEEiLCJjb21wb3VuZFN0cmV0Y2hCIiwiZmluZFN0cmFpZ2h0RWRnZVBvaW50cyIsImZpbmRCZXppZXJQb2ludHMiLCJlZGdlSXNTd2FwcGVkIiwiY3RybHB0V3MiLCJiZXppZXJOIiwiY3RybHB0V2VpZ2h0IiwibXVsdGkiLCJub3JtY3RybHB0RGlzdCIsIm1hbmN0cmxwdERpc3QiLCJzaWduIiwiZGlzdGFuY2VGcm9tTWlkcG9pbnQiLCJfdGhpcyRmaW5kTWlkcHRQdHNFdGMyIiwiZmluZFRheGlQb2ludHMiLCJWRVJUSUNBTCIsIkhPUklaT05UQUwiLCJMRUZUV0FSRCIsIlJJR0hUV0FSRCIsIkRPV05XQVJEIiwiVVBXQVJEIiwiQVVUTyIsImRJbmNsdWRlc05vZGVCb2R5IiwidGF4aURpciIsInJhd1RheGlEaXIiLCJ0YXhpVHVybiIsInR1cm5Jc1BlcmNlbnQiLCJ0YXhpVHVyblBmVmFsIiwidHVybklzTmVnYXRpdmUiLCJtaW5EIiwiZHciLCJkaCIsInBkeCIsInBkeSIsInN1YkRXSCIsImR4eSIsImR3aCIsImlzRXhwbGljaXREaXIiLCJpc1ZlcnQiLCJwbCIsInNnbkwiLCJmb3JjZWREaXIiLCJnZXRJc1Rvb0Nsb3NlIiwiaXNUb29DbG9zZVNyYyIsImlzVG9vQ2xvc2VUZ3QiLCJpc1Rvb0Nsb3NlIiwibFNoYXBlSW5zaWRlU3JjIiwibFNoYXBlSW5zaWRlVGd0IiwiX2xTaGFwZUluc2lkZVNyYyIsIl9sU2hhcGVJbnNpZGVUZ3QiLCJfeSIsIl94IiwiX3gyIiwiX3gzIiwiX3kyIiwiX3kzIiwiX3k0IiwiX3g0IiwiX3g1IiwiX3g2IiwiX3k1IiwiX3k2IiwidHJ5VG9Db3JyZWN0SW52YWxpZFBvaW50cyIsInNyY1NoYXBlIiwidGd0U2hhcGUiLCJzcmNDb3JuZXJSYWRpdXMiLCJ0Z3RDb3JuZXJSYWRpdXMiLCJzcmNScyIsInRndFJzIiwiYmFkU3RhcnQiLCJiYWRBU3RhcnQiLCJiYWRFbmQiLCJiYWRBRW5kIiwibWluQ3BBRGlzdEZhY3RvciIsImFycm93VyIsIm1pbkNwQURpc3QiLCJzdGFydEFDcERpc3QiLCJjbG9zZVN0YXJ0QUNwIiwiZW5kQUNwRGlzdCIsImNsb3NlRW5kQUNwIiwib3ZlcmxhcHBpbmciLCJjcEQiLCJjcEwiLCJjcE0iLCJjcFByb2oiLCJzcmNDdHJsUHRJbnRuIiwiaW50ZXJzZWN0TGluZSIsIl9jcEQiLCJfY3BMIiwiX2NwTSIsIl9yYWRpdXMiLCJfY3BQcm9qIiwidGd0Q3RybFB0SW50biIsImZpbmRFbmRwb2ludHMiLCJzdG9yZUFsbHB0cyIsIm10Iiwicm91bmRDb3JuZXJzIiwiZmFjdG9yIiwiY2hlY2tGb3JJbnZhbGlkRWRnZVdhcm5pbmciLCJsb2dnZWRFcnIiLCJmaW5kRWRnZUNvbnRyb2xQb2ludHMiLCJoYXNoVGFibGUiLCJwYWlySWQiLCJwYWlySWRzIiwiaGF5c3RhY2tFZGdlcyIsImVkZ2VJc0JlemllciIsInNyY0luZGV4IiwidGd0SW5kZXgiLCJ0YWJsZUVudHJ5IiwiaGFzVW5idW5kbGVkIiwiaGFzQmV6aWVyIiwiX3BhaXJJZHMkcCIsInN3YXBwZWRwYWlySW5mbyIsImZpcnN0RWRnZSIsIl9jdXJ2ZVN0eWxlIiwiX2VkZ2VJc1VuYnVuZGxlZCIsImNhbGN1bGF0ZWRJbnRlcnNlY3Rpb24iLCJzcmNPdXRzaWRlIiwic3JjSW50biIsInRndE91dHNpZGUiLCJ0Z3RJbnRuIiwidmVjdG9yIiwidmVjdG9yTm9ybSIsInBhc3NlZFBhaXJJbmZvIiwic3RhcnRzV2l0aCIsImdldFB0cyIsIkJScCRiIiwibnBvcyIsIl90Z3RNYW5FbmRwdCRwZlZhbHVlIiwiX3NyY01hbkVuZHB0JHBmVmFsdWUiLCJ0Z3RBclNoYXBlIiwic3JjQXJTaGFwZSIsImV0IiwidGF4aSIsInNlZ21lbnRzIiwiaGFzRW5kcHRzIiwib3ZlcnJpZGVFbmRwdHMiLCJzcmNNYW5FbmRwdFZhbCIsInRndE1hbkVuZHB0VmFsIiwicDFfaSIsInAyX2kiLCJ0Z3RNYW5FbmRwdFB0Iiwic3JjTWFuRW5kcHRQdCIsImNwU3RhcnQiLCJjcEVuZCIsInNyY0Fycm93RnJvbVB0IiwidGd0QXJyb3dGcm9tUHQiLCJ0cnMiLCJsdzIiLCJsaDIiLCJ2YSIsImhhIiwibGFiZWxJbnRlcnNlY3QiLCJyZWZQdCIsImludFNxZGlzdCIsImxhYkludFNxZGlzdCIsImxhYkludDJTcURpc3QiLCJhcnJvd0VuZCIsImVkZ2VFbmQiLCJzcnMiLCJfbHciLCJfbGgiLCJfbHgiLCJfbHkiLCJfbHcyIiwiX2xoMiIsIl92YSIsIl9oYSIsIl9sYWJlbEludGVyc2VjdCIsIl9yZWZQdCIsIl9pbnRTcWRpc3QiLCJfbGFiSW50U3FkaXN0IiwiX21pblNxRGlzdCIsIl9sYWJJbnQyU3FEaXN0IiwiYXJyb3dTdGFydCIsImVkZ2VTdGFydCIsImJhZExpbmUiLCJCUnAkYSIsInB1c2hCZXppZXJQdHMiLCJxYmV6aWVyQXQkMSIsImJwdHMiLCJiZXppZXJQcm9qUGN0cyIsImxwdHMiLCJyZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyIsIkJScCQ5IiwicmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uIiwiY29udGVudCIsInRleHRYIiwidGV4dFkiLCJub2RlV2lkdGgiLCJub2RlSGVpZ2h0Iiwibm9kZVBvcyIsInRleHRIYWxpZ24iLCJ0ZXh0VmFsaWduIiwiYXBwbHlMYWJlbERpbWVuc2lvbnMiLCJsaW5lQW5nbGVGcm9tRGVsdGEiLCJsaW5lQW5nbGUiLCJiZXppZXJBbmdsZSIsInQwIiwibHAwIiwibHAxIiwic2V0UnMiLCJtaWRBbmdsZSIsIl9jcmVhdGVDb250cm9sUG9pbnRJbmZvIiwiY3JlYXRlQ29udHJvbFBvaW50SW5mbyIsInN0YXJ0RGlzdCIsIm5Qcm9qcyIsImFkZFNlZ21lbnQiLCJjcCIsInByZXZTZWdtZW50Iiwic2VnbWVudCIsInByZXZDcCIsImNhbGN1bGF0ZUVuZFByb2plY3Rpb24iLCJpc1NyYyIsImNwcyIsInRvdGFsRGlzdCIsIl9jcCIsIl9zZWciLCJsYXN0U2VnIiwic2VnIiwidFNlZ21lbnQiLCJzZWdEdCIsImRpIiwiZDAiLCJwRCIsIl90IiwiYXBwbHlQcmVmaXhlZExhYmVsRGltZW5zaW9ucyIsImdldExhYmVsVGV4dCIsImNhY2hlS2V5IiwibGFiZWxEaW1zIiwiY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zIiwibGluZUhlaWdodCIsIm51bUxpbmVzIiwibm9ybVBlckxpbmVIZWlnaHQiLCJsYWJlbExpbmVIZWlnaHQiLCJwZmQiLCJ3cmFwU3R5bGUiLCJ6d3NwIiwibWF4VyIsIm92ZXJmbG93Iiwib3ZlcmZsb3dBbnkiLCJ3cmFwcGVkTGluZXMiLCJzZXBhcmF0b3JSZWdleCIsImxpbmVEaW1zIiwibGluZVciLCJwcm9jZXNzZWRMaW5lIiwic2VwYXJhdG9yTWF0Y2hlcyIsIm1hdGNoQWxsIiwic3VibGluZSIsInByZXZpb3VzSW5kZXgiLCJzZXBhcmF0b3JNYXRjaCIsIndvcmRTZXBhcmF0b3IiLCJ3b3JkIiwidGVzdExpbmUiLCJ0ZXN0RGltcyIsInRlc3RXIiwiX21heFciLCJlbGxpcHNpemVkIiwiZWxsaXBzaXMiLCJpbmNMYXN0Q2giLCJ3aWR0aFdpdGhOZXh0Q2giLCJnZXRMYWJlbEp1c3RpZmljYXRpb24iLCJmU3R5bGUiLCJmYW1pbHkiLCJjYW52YXMiLCJsYWJlbENhbGNDYW52YXMiLCJjMmQiLCJsYWJlbENhbGNDYW52YXNDb250ZXh0IiwiY3JlYXRlRWxlbWVudCIsImdldENvbnRleHQiLCJkcyIsInpJbmRleCIsInBvaW50ZXJFdmVudHMiLCJmb250IiwibWV0cmljcyIsIm1lYXN1cmVUZXh0IiwiY2FsY3VsYXRlTGFiZWxBbmdsZSIsInJvdCIsInJvdFN0ciIsImxhYmVsQXV0b0FuZ2xlIiwibGFiZWxBbmdsZSIsInNvdXJjZUxhYmVsQW5nbGUiLCJ0YXJnZXRMYWJlbEFuZ2xlIiwiQlJwJDgiLCJUT09fU01BTExfQ1VUX1JFQ1QiLCJ3YXJuZWRDdXRSZWN0IiwibWFrZVBvbHlnb24iLCJCUnAkNyIsInJlZ2lzdGVyQ2FsY3VsYXRpb25MaXN0ZW5lcnMiLCJlbGVzVG9VcGRhdGUiLCJkaXJ0eVN0eWxlQ2FjaGVzIiwiY2xlYW5Db25uZWN0ZWQiLCJiaW5kZXIiLCJvbkRpcnR5Qm91bmRzIiwib25EaXJ0eVN0eWxlIiwidXBkYXRlRWxlQ2FsY3MiLCJmbnMiLCJvblVwZGF0ZUVsZUNhbGNzRm5zIiwiZmx1c2hSZW5kZXJlZFN0eWxlUXVldWUiLCJlbGVDYWxjcyIsIm9uVXBkYXRlRWxlQ2FsY3MiLCJpc0NsZWFuQ29ubmVjdGVkIiwiX3AyIiwiX3JzdHlsZSIsIm5vZGVXIiwibm9kZUgiLCJfcDMiLCJfcnN0eWxlMiIsIkJScCQ2IiwidXBkYXRlQ2FjaGVkR3JhYmJlZEVsZXMiLCJjYWNoZWRaU29ydGVkRWxlcyIsImRyYWciLCJub25kcmFnIiwiZ3JhYlRhcmdldHMiLCJpbkRyYWdMYXllciIsImludmFsaWRhdGVDYWNoZWRaU29ydGVkRWxlcyIsImZvcmNlUmVjYWxjIiwiQlJwJDUiLCJCUnAkNCIsImdldENhY2hlZEltYWdlIiwiY3Jvc3NPcmlnaW4iLCJvbkxvYWQiLCJpbWFnZUNhY2hlIiwiaW1hZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiSW1hZ2UiLCJkYXRhVXJpUHJlZml4IiwiaXNEYXRhVXJpIiwiQlJwJDMiLCJyZWdpc3RlckJpbmRpbmciLCJ1c2VDYXB0dXJlIiwidGd0SXNEb20iLCJib2R5Iiwic3VwcG9ydHNQYXNzaXZlRXZlbnRzIiwic3VwcG9ydHNQYXNzaXZlIiwiY2FwdHVyZSIsInBhc3NpdmUiLCJiaW5kaW5ncyIsIm5vZGVJc0RyYWdnYWJsZSIsIm5vZGVJc0dyYWJiYWJsZSIsImxvYWQiLCJpc1NlbGVjdGVkIiwiZ2V0U2hhZG93Um9vdCIsInJvb3ROb2RlIiwiZ2V0Um9vdE5vZGUiLCJub2RlVHlwZSIsImhvc3QiLCJ0cmlnZ2VyRXZlbnRzIiwiaXNNdWx0U2VsS2V5RG93biIsInNoaWZ0S2V5IiwibWV0YUtleSIsImN0cmxLZXkiLCJhbGxvd1Bhbm5pbmdQYXNzdGhyb3VnaCIsImRvd24iLCJkb3ducyIsImFsbG93UGFzc3Rocm91Z2giLCJzZXRHcmFiYmVkIiwic2V0RnJlZWQiLCJzZXRJbkRyYWdMYXllciIsInNldE91dERyYWdMYXllciIsInNldEdyYWJUYXJnZXQiLCJpc0dyYWJUYXJnZXQiLCJyZW1vdmVHcmFiVGFyZ2V0IiwiYWRkVG9EcmFnTGlzdCIsImxpc3QiLCJhZGRUb0xpc3QiLCJsaXN0SGFzRWxlIiwiYWRkRGVzY2VuZGFudHNUb0RyYWciLCJpbm5lck5vZGVzIiwiYWRkTm9kZXNUb0RyYWciLCJ1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciIsImFkZE5vZGVUb0RyYWciLCJmcmVlRHJhZ2dlZEVsZW1lbnRzIiwiZ3JhYmJlZEVsZXMiLCJibHVyQWN0aXZlRG9tRWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJibHVyIiwiaGF2ZU11dGF0aW9uc0FwaSIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJoYXZlUmVzaXplT2JzZXJ2ZXJBcGkiLCJSZXNpemVPYnNlcnZlciIsInJlbW92ZU9ic2VydmVyIiwibXV0bnMiLCJtdXRuIiwick5vZGVzIiwicmVtb3ZlZE5vZGVzIiwick5vZGUiLCJwYXJlbnROb2RlIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsIm9uUmVzaXplIiwic3R5bGVPYnNlcnZlciIsInJlc2l6ZU9ic2VydmVyIiwiaW52YWxpZGF0ZUNvb3JkcyIsImluQm94U2VsZWN0aW9uIiwic2VsZWN0aW9uIiwiZXZlbnRJbkNvbnRhaW5lciIsImNvbnRhaW5lclBhZ2VDb29yZHMiLCJ0b3VjaGVzIiwiYXRMZWFzdE9uZVBvc0luc2lkZSIsInRQYXJlbnQiLCJjb250YWluZXJJc1RhcmdldCIsIm1vdXNlZG93bkhhbmRsZXIiLCJob3ZlckRhdGEiLCJ3aGljaCIsImdwb3MiLCJzZWxlY3QiLCJuZWFycyIsImRyYWdnZWRFbGVtZW50cyIsImRyYWdEYXRhIiwicG9zc2libGVEcmFnRWxlbWVudHMiLCJtZG93blBvcyIsIm1kb3duR1BvcyIsIm1ha2VFdmVudCIsImNoZWNrRm9yVGFwaG9sZCIsInRhcGhvbGRDYW5jZWxsZWQiLCJ0YXBob2xkVGltZW91dCIsInRhcGhvbGREdXJhdGlvbiIsImN4dFN0YXJ0ZWQiLCJjeHRFdnQiLCJhY3RpdmF0ZSIsImRvd25UaW1lIiwiZ2V0VGltZSIsImN4dERyYWdnZWQiLCJ0cmlnZ2VyR3JhYiIsInNlbGVjdGVkTm9kZXMiLCJyZWRyYXdIaW50IiwiYmdBY3RpdmVQb3Npc3Rpb24iLCJyZWRyYXciLCJzaGFkb3dSb290IiwibW91c2Vtb3ZlSGFuZGxlciIsImRyYWdnaW5nRWxlcyIsImRyYWdnaW5nIiwic2VsZWN0aW5nIiwiaXNPdmVyVGhyZXNob2xkRHJhZyIsImR4MiIsImR5MiIsImRpc3QyIiwiZGVza3RvcFRhcFRocmVzaG9sZDIiLCJtdWx0U2VsS2V5RG93biIsInVwZGF0ZURyYWdEZWx0YSIsImRyYWdEZWx0YSIsImdvSW50b0JveE1vZGUiLCJjeHRPdmVyIiwiZGVsdGFQIiwianVzdFN0YXJ0ZWRQYW4iLCJtZFBvcyIsImRyYWdnZWQiLCJ1bmFjdGl2YXRlIiwiZGlkRHJhZyIsImp1c3RTdGFydGVkRHJhZyIsInRvdGFsU2hpZnQiLCJjbGlja1RpbWVvdXQiLCJkaWREb3VibGVDbGljayIsInByZXZDbGlja1RpbWVTdGFtcCIsIm1vdXNldXBIYW5kbGVyIiwiY3h0VGFwIiwiZWxlV291bGRCZVNlbGVjdGVkIiwiZG93bldhc0dyYWJiZWQiLCJ3aGVlbERlbHRhcyIsIndoZWVsRGVsdGFOIiwiaW5hY2N1cmF0ZVNjcm9sbERldmljZSIsImluYWNjdXJhdGVTY3JvbGxGYWN0b3IiLCJhbGxBcmVEaXZpc2libGVCeSIsImFsbEFyZVNhbWVNYWduaXR1ZGUiLCJmaXJzdE1hZyIsIndoZWVsSGFuZGxlciIsImNsYW1wIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwid2RzIiwic2Nyb2xsaW5nUGFnZSIsIndoZWVsWm9vbWluZyIsIndoZWVsVGltZW91dCIsIm5lZWRzV2hlZWxGaXgiLCJkZWx0YU1vZGUiLCJuZXdab29tIiwiZ2VzdHVyZVN0YXJ0Wm9vbSIsInNjcm9sbEhhbmRsZXIiLCJzY3JvbGxpbmdQYWdlVGltZW91dCIsImdlc3R1cmVTdGFydEhhbmRsZXIiLCJoYXNUb3VjaFN0YXJ0ZWQiLCJtb3VzZU91dEhhbmRsZXIiLCJtb3VzZU92ZXJIYW5kbGVyIiwiZjF4MSIsImYxeTEiLCJmMngxIiwiZjJ5MSIsImRpc3RhbmNlMSIsImRpc3RhbmNlMVNxIiwiY2VudGVyMSIsIm1vZGVsQ2VudGVyMSIsImNvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0IiwidHdvRmluZ2Vyc1N0YXJ0SW5zaWRlIiwiZGlzdGFuY2VTcSIsInRvdWNoc3RhcnRIYW5kbGVyIiwidG91Y2hEYXRhIiwiZWFybGllciIsInNpbmdsZVRvdWNoTW92ZWQiLCJ0b3VjaERyYWdFbGVzIiwiY3h0RGlzdFRocmVzaG9sZCIsImN4dERpc3RUaHJlc2hvbGRTcSIsIm5lYXIxIiwibmVhcjIiLCJzdGFydHMiLCJkcmFnZ2VkRWxlcyIsInNpbmdsZVRvdWNoU3RhcnRUaW1lIiwicGluY2hpbmciLCJzUG9zIiwidG91Y2gwIiwic3RhcnRHUG9zaXRpb24iLCJ0b3VjaG1vdmVIYW5kbGVyIiwic3RhcnRHUG9zIiwidG91Y2hUYXBUaHJlc2hvbGQyIiwiZjF4MiIsImYxeTIiLCJmMngyIiwiZjJ5MiIsImRpc3RhbmNlMlNxIiwiZmFjdG9yU3EiLCJkaXN0VGhyZXNob2xkU3EiLCJmYWN0b3JUaHJlc2hvbGQiLCJmYWN0b3JUaHJlc2hvbGRTcSIsImxhc3RUaHJlZVRvdWNoIiwiZGlkU2VsZWN0IiwiZGVfcCIsIl9zdGFydCIsImRpc3RhbmNlMiIsImRmMXgiLCJkZjF5IiwiZGYyeCIsImRmMnkiLCJ0eCIsInR5IiwiY3RyeCIsImN0cnkiLCJzd2lwZVBhbm5pbmciLCJ0b3VjaGNhbmNlbEhhbmRsZXIiLCJ0b3VjaGVuZEhhbmRsZXIiLCJkaWREb3VibGVUb3VjaCIsInRvdWNoVGltZW91dCIsInByZXZUb3VjaFRpbWVTdGFtcCIsImN0eFRhcGVuZCIsImN0eFRhcCIsInN0YXJ0V2FzR3JhYmJlZCIsInJkaXN0MiIsIlRvdWNoRXZlbnQiLCJwb2ludGVycyIsIm1ha2VUb3VjaCIsImlkZW50aWZpZXIiLCJwb2ludGVySWQiLCJwYWdlWCIsInBhZ2VZIiwicmFkaXVzWCIsInJhZGl1c1kiLCJzY3JlZW5YIiwic2NyZWVuWSIsIm1ha2VQb2ludGVyIiwidG91Y2giLCJhZGRQb2ludGVyIiwicmVtb3ZlUG9pbnRlciIsInVwZGF0ZVBvaW50ZXIiLCJhZGRUb3VjaGVzVG9FdmVudCIsInBvaW50ZXJJc01vdXNlIiwicG9pbnRlclR5cGUiLCJCUnAkMiIsImdlbmVyYXRlUG9seWdvbiIsIm5vZGVTaGFwZUltcGwiLCJzdHJva2VQb3NpdGlvbiIsImdlbmVyYXRlRWxsaXBzZSIsImdlbmVyYXRlUm91bmRQb2x5Z29uIiwiZ2V0T3JDcmVhdGVDb3JuZXJzIiwiZ2VuZXJhdGVSb3VuZFJlY3RhbmdsZSIsImRpYW0iLCJnZW5lcmF0ZUN1dFJlY3RhbmdsZSIsImNvcm5lckxlbmd0aCIsImdlbmVyYXRlQ3V0VHJpYW5nbGVQdHMiLCJjbCIsInhCZWdpbiIsInhFbmQiLCJ5QmVnaW4iLCJ5RW5kIiwidG9wTGVmdCIsInRvcFJpZ2h0IiwiYm90dG9tUmlnaHQiLCJib3R0b21MZWZ0IiwiY1B0cyIsImN1dFRyaWFuZ2xlUHRzIiwiZ2VuZXJhdGVCYXJyZWwiLCJiUHRzIiwiZ2VuZXJhdGVCYXJyZWxCZXppZXJQdHMiLCJhcHByb3hpbWF0ZUJhcnJlbEN1cnZlUHRzIiwibTAiLCJtMSIsIm0yIiwiY3VydmVDb25zdGFudHMiLCJoT2Zmc2V0Iiwid09mZnNldCIsImN0cmxQdFhPZmZzZXQiLCJpc1RvcCIsImlzQm90dG9tIiwiYmFycmVsQ3VydmVQdHMiLCJnZXRDdXJ2ZVQiLCJjdXJ2ZVB0cyIsIngwIiwieE1pbiIsInhNYXgiLCJ5TWluIiwieU1heCIsImNvZWZmIiwidmFsaWRSb290cyIsImN1cnZlUmVnaW9ucyIsImNvcm5lclB0cyIsImJlelkiLCJnZW5lcmF0ZUJvdHRvbVJvdW5kcmVjdGFuZ2xlIiwidG9wSW50ZXJzZWN0aW9ucyIsInJlZ2lzdGVyTm9kZVNoYXBlcyIsImRpYW1vbmRQb2ludHMiLCJzdGFyNVBvaW50cyIsIm91dGVyUG9pbnRzIiwiaW5uZXJQb2ludHMiLCJpbm5lclJhZGl1cyIsInRhZ1BvaW50cyIsIkJScCQxIiwidGltZVRvUmVuZGVyIiwicmVkcmF3VG90YWxUaW1lIiwicmVkcmF3Q291bnQiLCJhdmVyYWdlUmVkcmF3VGltZSIsImxhc3RSZWRyYXdUaW1lIiwibGFzdERyYXdUaW1lIiwicmVxdWVzdGVkRnJhbWUiLCJyZW5kZXJPcHRpb25zIiwicHJpb3JpdHkiLCJjYnMiLCJiZWZvcmVSZW5kZXJDYWxsYmFja3MiLCJzdGFydFJlbmRlckxvb3AiLCJyZW5kZXJMb29wU3RhcnRlZCIsIl9yZW5kZXJGbiIsInJlbmRlckZuIiwicmVxdWVzdFRpbWUiLCJza2lwRnJhbWUiLCJyZW5kZXIiLCJlbmRUaW1lIiwiQmFzZVJlbmRlcmVyIiwiQlIiLCJCUnAiLCJjbGllbnRGdW5jdGlvbnMiLCJjdHIiLCJzdHlsZXNoZWV0SWQiLCJzdHlsZXNoZWV0QWxyZWFkeUV4aXN0cyIsInRleHRDb250ZW50IiwiaW5zZXJ0QmVmb3JlIiwiY29tcHV0ZWRTdHlsZSIsInRyaWdnZXJNb2RlIiwiaW5pdGlhbFBhbiIsInJlZHJhd3MiLCJtb3Rpb25CbHVyRW5hYmxlZCIsImZvcmNlZFBpeGVsUmF0aW8iLCJtb3Rpb25CbHVyVHJhbnNwYXJlbmN5IiwibW90aW9uQmx1clB4UmF0aW8iLCJtYlB4UkJsdXJyeSIsIm1pbk1iTG93UXVhbEZyYW1lcyIsImZ1bGxRdWFsaXR5TWIiLCJjbGVhcmVkRm9yTW90aW9uQmx1ciIsImVsZVR4ckRlcSIsImx5clR4ckRlcSIsImx5clR4clNraXAiLCJtYXRjaENhbnZhc1NpemUiLCJiaW5kaW5nIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpc2Nvbm5lY3QiLCJsYWJlbENhbGNEaXYiLCJmdWxsRnBzVGltZSIsImRlZnMiLCJzZXR1cERlcXVldWVpbmciLCJzZXR1cERlcXVldWVpbmdJbXBsIiwiZGVxdWV1ZWluZ1NldHVwIiwicXVldWVSZWRyYXciLCJkZXFSZWRyYXdUaHJlc2hvbGQiLCJmcmFtZVN0YXJ0VGltZSIsImF2Z1JlbmRlclRpbWUiLCJyZW5kZXJUaW1lIiwiZGVxZCIsImdldFBpeGVsUmF0aW8iLCJmcmFtZUR1cmF0aW9uIiwidGltZUF2YWlsYWJsZSIsImRlcUZhc3RDb3N0IiwiZGVxQ29zdCIsImRlcUF2Z0Nvc3QiLCJkZXFOb0RyYXdDb3N0IiwidGhpc0RlcWQiLCJkZXEiLCJvbkRlcWQiLCJzaG91bGRSZWRyYXciLCJFbGVtZW50VGV4dHVyZUNhY2hlTG9va3VwIiwiZG9lc0VsZUludmFsaWRhdGVLZXkiLCJpZHNCeUtleSIsImtleUZvcklkIiwiY2FjaGVzQnlMdmwiLCJsdmxzIiwiZ2V0SWRzRm9yIiwiYWRkSWRGb3JLZXkiLCJkZWxldGVJZEZvcktleSIsImdldE51bWJlck9mSWRzRm9yS2V5IiwidXBkYXRlS2V5TWFwcGluZ0ZvciIsImN1cnJLZXkiLCJkZWxldGVLZXlNYXBwaW5nRm9yIiwia2V5SGFzQ2hhbmdlZEZvciIsIm5ld0tleSIsImlzSW52YWxpZCIsImdldENhY2hlc0F0IiwibHZsIiwiY2FjaGVzIiwiZ2V0Q2FjaGUiLCJnZXRGb3JDYWNoZWRLZXkiLCJoYXNDYWNoZSIsInNldENhY2hlIiwiZGVsZXRlQ2FjaGUiLCJpbnZhbGlkYXRlS2V5IiwiaW52YWxpZGF0ZSIsImVudGlyZUtleUludmFsaWRhdGVkIiwibWluVHhySCIsInR4clN0ZXBIIiwibWluTHZsJDEiLCJtYXhMdmwkMSIsIm1heFpvb20kMSIsImVsZVR4clNwYWNpbmciLCJkZWZUeHJXaWR0aCIsIm1heFR4clciLCJtYXhUeHJIIiwibWluVXRpbGl0eSIsIm1heEZ1bGxuZXNzIiwibWF4RnVsbG5lc3NDaGVja3MiLCJkZXFDb3N0JDEiLCJkZXFBdmdDb3N0JDEiLCJkZXFOb0RyYXdDb3N0JDEiLCJkZXFGYXN0Q29zdCQxIiwiZGVxUmVkcmF3VGhyZXNob2xkJDEiLCJtYXhEZXFTaXplJDEiLCJnZXRUeHJSZWFzb25zIiwiZG93bnNjYWxlIiwiaGlnaFF1YWxpdHkiLCJpbml0RGVmYXVsdHMiLCJkcmF3RWxlbWVudCIsImdldEJvdW5kaW5nQm94IiwiZ2V0Um90YXRpb25Qb2ludCIsImdldFJvdGF0aW9uT2Zmc2V0IiwiaXNWaXNpYmxlIiwiYWxsb3dFZGdlVHhyQ2FjaGluZyIsImFsbG93UGFyZW50VHhyQ2FjaGluZyIsIkVsZW1lbnRUZXh0dXJlQ2FjaGUiLCJpbml0T3B0aW9ucyIsIm9uRGVxdWV1ZXMiLCJFVENwIiwicmVhc29ucyIsImdldFRleHR1cmVRdWV1ZSIsInR4ckgiLCJlbGVJbWdDYWNoZXMiLCJnZXRSZXRpcmVkVGV4dHVyZVF1ZXVlIiwicnR4dHJRcyIsInJldGlyZWQiLCJydHh0clEiLCJnZXRFbGVtZW50UXVldWUiLCJlbGVDYWNoZVF1ZXVlIiwicmVxcyIsImdldEVsZW1lbnRLZXlUb1F1ZXVlIiwiazJxIiwiZWxlS2V5VG9DYWNoZVF1ZXVlIiwiZ2V0RWxlbWVudCIsInJlYXNvbiIsImVsZVNjYWxlZEgiLCJlbGVTY2FsZWRXIiwic2NhbGVkTGFiZWxTaG93biIsImVsZVRleHRCaWdnZXJUaGFuTWluIiwiZWxlQ2FjaGUiLCJpbnZhbGlkYXRlZCIsInRleHR1cmUiLCJpbnZhbGlkYXRlZFdpZHRoIiwidHhyUSIsInR4ciIsImFkZE5ld1R4ciIsInJlY3ljbGVUZXh0dXJlIiwiYWRkVGV4dHVyZSIsInVzZWRXaWR0aCIsInNjYWxhYmxlRnJvbSIsIm90aGVyQ2FjaGUiLCJkZXFpbmciLCJoaWdoUXVhbGl0eVJlcSIsImRvd25zY2FsZVJlcSIsImhpZ2hlckNhY2hlIiwib25lVXBDYWNoZSIsImRyYXdJbWFnZSIsInNldFRyYW5zZm9ybSIsImNsZWFyUmVjdCIsInF1ZXVlRWxlbWVudCIsImxvd2VyQ2FjaGUiLCJfbDIiLCJ0cmFuc2xhdGUiLCJlbGVDYWNoZXMiLCJjaGVja1RleHR1cmVGdWxsbmVzcyIsImludmFsaWRhdGVFbGVtZW50cyIsImludmFsaWRhdGVFbGVtZW50Iiwibm9PdGhlckVsZXNVc2VDYWNoZSIsIl9jYWNoZSIsImNoZWNrVGV4dHVyZVV0aWxpdHkiLCJyZW1vdmVGcm9tUXVldWUiLCJyZXRpcmVUZXh0dXJlIiwiZnVsbG5lc3NDaGVja3MiLCJtaW5XIiwibWFrZU9mZnNjcmVlbkNhbnZhcyIsImV4aXN0aW5nUmVxIiwicmVxIiwiZGVxdWV1ZWQiLCJjYWNoZUV4aXN0cyIsIm9uRGVxdWV1ZSIsIm9mZkRlcXVldWUiLCJkZWZOdW1MYXllcnMiLCJtaW5MdmwiLCJtYXhMdmwiLCJyZWZpbmVFbGVEZWJvdW5jZVRpbWUiLCJtYXhEZXFTaXplIiwiaW52YWxpZFRocmVzaG9sZCIsIm1heExheWVyQXJlYSIsIm1heExheWVyRGltIiwidXNlSGlnaFF1YWxpdHlFbGVUeHJSZXFzIiwiTGF5ZXJlZFRleHR1cmVDYWNoZSIsImxheWVyc0J5TGV2ZWwiLCJmaXJzdEdldCIsImxhc3RJbnZhbGlkYXRpb25UaW1lIiwic2tpcHBpbmciLCJlbGVUeHJEZXFzIiwic2NoZWR1bGVFbGVtZW50UmVmaW5lbWVudCIsInJlZmluZUVsZW1lbnRUZXh0dXJlcyIsInFTb3J0IiwibGF5ZXJzUXVldWUiLCJMVENwIiwibGF5ZXJJZFBvb2wiLCJNQVhfSU5UIiwibWFrZUxheWVyIiwibGF5ZXIiLCJlbGVzUXVldWUiLCJnZXRMYXllcnMiLCJ2YWxpZGF0ZUxheWVyc0VsZXNPcmRlcmluZyIsImxheWVyc0J5THZsIiwibGF5ZXJzIiwibHZsQ29tcGxldGUiLCJsZXZlbElzQ29tcGxldGUiLCJ0bXBMYXllcnMiLCJjaGVja1RlbXBMZXZlbHMiLCJjYW5Vc2VBc1RtcEx2bCIsImNoZWNrTHZscyIsImRpciIsImdldEJiIiwiYWZ0ZXIiLCJhcmVhIiwibWF4RWxlc1BlckxheWVyIiwiYWxsb3dMYXp5UXVldWVpbmciLCJpbWdMYXllckNhY2hlcyIsImV4aXN0aW5nTGF5ZXIiLCJxdWV1ZUxheWVyIiwiZHJhd0VsZUluTGF5ZXIiLCJnZXRFbGVMZXZlbEZvckxheWVyTGV2ZWwiLCJzZXRJbWdTbW9vdGhpbmciLCJkcmF3Q2FjaGVkRWxlbWVudCIsIm51bUVsZXNJbkxheWVycyIsImludmFsaWRhdGVMYXllciIsInVwZGF0ZUVsZW1lbnRzSW5MYXllcnMiLCJoYXZlTGF5ZXJzIiwiaW52YWxBc3NvY0xheWVycyIsInJlcGxhY2VtZW50IiwicmVmaW5lRWFjaEVsZSIsInJMeXIiLCJyZXBsYWNlcyIsImVucXVldWVFbGVtZW50UmVmaW5lbWVudCIsImVsZXNRIiwiaGFzSWQiLCJlbGVEZXFzIiwiYXBwbHlMYXllclJlcGxhY2VtZW50IiwicmVxdWVzdFJlZHJhdyIsImxheWVyc0luTGV2ZWwiLCJyZXBsYWNlZCIsIkNScCRiIiwidHJpYW5nbGVCYWNrY3VydmUiLCJmaXJzdFB0IiwicXVhZHJhdGljQ3VydmVUbyIsInRyaWFuZ2xlVGVlIiwidHJpYW5nbGVQb2ludHMiLCJ0ZWVQb2ludHMiLCJiZWdpblBhdGgiLCJmaXJzdFRlZVB0IiwibW92ZVRvIiwiY2xvc2VQYXRoIiwiY2lyY2xlVHJpYW5nbGUiLCJmaXJzdFRyUHQiLCJjaXJjbGUkMSIsIkNScCRhIiwic2hpZnRUb09yaWdpbldpdGhCYiIsInNob3dMYWJlbCIsInNob3dPdmVybGF5Iiwic2hvd09wYWNpdHkiLCJkcmF3Tm9kZSIsImRyYXdFZGdlIiwiZHJhd0VsZW1lbnRPdmVybGF5IiwiZHJhd05vZGVPdmVybGF5IiwiZHJhd0VkZ2VPdmVybGF5IiwiZHJhd0VsZW1lbnRVbmRlcmxheSIsImRyYXdOb2RlVW5kZXJsYXkiLCJkcmF3RWRnZVVuZGVybGF5IiwiZHJhd0NhY2hlZEVsZW1lbnRQb3J0aW9uIiwiZWxlVHhyQ2FjaGUiLCJnZXRSb3RhdGlvbiIsImdldE9wYWNpdHkiLCJzbW9vdGgiLCJyb3RQdCIsImdldEltZ1Ntb290aGluZyIsIm9sZEdsb2JhbEFscGhhIiwiZ2xvYmFsQWxwaGEiLCJnZXRaZXJvUm90YXRpb24iLCJnZXRMYWJlbFJvdGF0aW9uIiwiZ2V0VGV4dEFuZ2xlIiwiZ2V0U291cmNlTGFiZWxSb3RhdGlvbiIsImdldFRhcmdldExhYmVsUm90YXRpb24iLCJnZXRUZXh0T3BhY2l0eSIsInJlcXVlc3RIaWdoUXVhbGl0eSIsIl9yJGRhdGEiLCJsYmxUeHJDYWNoZSIsInNsYlR4ckNhY2hlIiwidGxiVHhyQ2FjaGUiLCJkcmF3RWxlbWVudHMiLCJkcmF3Q2FjaGVkRWxlbWVudHMiLCJkcmF3Q2FjaGVkTm9kZXMiLCJkcmF3TGF5ZXJlZEVsZW1lbnRzIiwibHlyVHhyQ2FjaGUiLCJDUnAkOSIsImRyYXdMYWJlbCIsInNob3VsZERyYXdPdmVybGF5Iiwic2hvdWxkRHJhd09wYWNpdHkiLCJsaW5lT3BhY2l0eSIsImxpbmVPdXRsaW5lV2lkdGgiLCJsaW5lT3V0bGluZUNvbG9yIiwiZWZmZWN0aXZlTGluZU9wYWNpdHkiLCJlZmZlY3RpdmVBcnJvd09wYWNpdHkiLCJkcmF3TGluZSIsInN0cm9rZU9wYWNpdHkiLCJlbGVTdHJva2VTdHlsZSIsImRyYXdFZGdlVHJpYW5nbGVQYXRoIiwibGluZVdpZHRoIiwiZHJhd0VkZ2VQYXRoIiwiZHJhd0xpbmVPdXRsaW5lIiwiY29sb3JTdHJva2VTdHlsZSIsImRyYXdPdmVybGF5IiwiZHJhd1VuZGVybGF5IiwiZHJhd0Fycm93cyIsImFycm93T3BhY2l0eSIsImRyYXdBcnJvd2hlYWRzIiwiZHJhd1RleHQiLCJkcmF3RWxlbWVudFRleHQiLCJnaG9zdE9wYWNpdHkiLCJlZmZlY3RpdmVHaG9zdE9wYWNpdHkiLCJkcmF3RWRnZU92ZXJsYXlVbmRlcmxheSIsIm92ZXJsYXlPclVuZGVybGF5IiwiaW5jbHVkZXMiLCJ1c2VQYXRocyIsImNhbnZhc0N4dCIsInBhdGhDYWNoZUhpdCIsImxpbmVEYXNoUGF0dGVybiIsImxpbmVEYXNoT2Zmc2V0IiwicGF0aENhY2hlS2V5Iiwia2V5TWF0Y2hlcyIsInBhdGhDYWNoZSIsIlBhdGgyRCIsInNldExpbmVEYXNoIiwic3Ryb2tlIiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJ0cmlhbmdsZUhlYWQiLCJkcmF3QXJyb3doZWFkIiwiYXJyb3dDbGVhckZpbGwiLCJwQXJyb3dXaWR0aCIsImVkZ2VPcGFjaXR5IiwiZ2NvIiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiY29sb3JGaWxsU3R5bGUiLCJkcmF3QXJyb3dTaGFwZSIsInNoYXBlV2lkdGgiLCJjYW52YXNDb250ZXh0Iiwic2hhcGVJbXBsIiwiYXJyb3dQYXRoQ2FjaGUiLCJjYWNoZWRQYXRoIiwiQ1JwJDgiLCJzYWZlRHJhd0ltYWdlIiwiaW1nIiwiaXgiLCJpeSIsIml3IiwiaWgiLCJkcmF3SW5zY3JpYmVkSW1hZ2UiLCJub2RlT3BhY2l0eSIsInN0eWxlT2JqIiwicmVwZWF0IiwicGFkZGluZ1gyIiwibm9kZVRXIiwibm9kZVRIIiwiY2xpcCIsInNob3VsZENsaXAiLCJpbWdPcGFjaXR5IiwiaW1nVyIsImNhY2hlZFciLCJpbWdIIiwiY2FjaGVkSCIsImFwcGVuZENoaWxkIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJwb3NYVW5pdHMiLCJwb3NYUGZWYWwiLCJvZmZYVW5pdHMiLCJvZmZYUGZWYWwiLCJwb3NZVW5pdHMiLCJwb3NZUGZWYWwiLCJvZmZZVW5pdHMiLCJvZmZZUGZWYWwiLCJnQWxwaGEiLCJzbW9vdGhpbmdFbmFibGVkIiwiaXNTbW9vdGhpbmdTd2l0Y2hlZCIsInNhdmUiLCJjcmVhdGVQYXR0ZXJuIiwiQ1JwJDciLCJjb21wdXRlZFNpemUiLCJtaW5TaXplIiwidXNlRWxlT3BhY2l0eSIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsIl9sYWJlbCIsInNyY0xhYmVsIiwidGd0TGFiZWwiLCJhcHBseVJvdGF0aW9uIiwiZ2V0Rm9udENhY2hlIiwiZm9udENhY2hlcyIsInNldHVwVGV4dFN0eWxlIiwibGFiZWxTdHlsZSIsImxhYmVsU2l6ZSIsImxhYmVsRmFtaWx5IiwibGFiZWxXZWlnaHQiLCJvdXRsaW5lQ29sb3IiLCJkaWFtZXRlciIsInJvdW5kUmVjdCIsInBkYXNoIiwidGV4dEFuZ2xlIiwib3JnVGV4dFgiLCJvcmdUZXh0WSIsInRleHRXIiwidGV4dEgiLCJiYWNrZ3JvdW5kT3BhY2l0eSIsInRleHRCb3JkZXJXaWR0aCIsImJhY2tncm91bmRQYWRkaW5nIiwic3R5bGVTaGFwZSIsInJvdW5kZWQiLCJjaXJjbGVkIiwicm91bmRSYWRpdXMiLCJ0ZXh0RmlsbCIsInRleHRTdHJva2UiLCJ0ZXh0TGluZVdpZHRoIiwidGV4dEJhY2tncm91bmRDb2xvciIsInRleHRCb3JkZXJDb2xvciIsInRleHRCb3JkZXJTdHlsZSIsImRvRmlsbCIsImRvU3Ryb2tlIiwiYmdYIiwiYmdZIiwiYmdXIiwiYmdIIiwid2hpdGVXaWR0aCIsImhhbGZUZXh0VyIsInN0cm9rZVRleHQiLCJmaWxsVGV4dCIsIkNScCQ2IiwiZWxlT3BhY2l0eSIsImJnSW1nUHJvcCIsInVybERlZmluZWQiLCJudW1JbWFnZXMiLCJkZWZkIiwiYmdJbWdDcm9zc09yaWdpbiIsImJhY2tncm91bmRUaW1lc3RhbXAiLCJkYXJrbmVzcyIsImJnT3BhY2l0eSIsImJvcmRlckNvbG9yIiwiYm9yZGVySm9pbiIsImJvcmRlckNhcCIsImJvcmRlclBhdHRlcm4iLCJib3JkZXJPZmZzZXQiLCJvdXRsaW5lU3R5bGUiLCJzZXR1cFNoYXBlQ29sb3IiLCJiZ09weSIsImVsZUZpbGxTdHlsZSIsInNldHVwQm9yZGVyQ29sb3IiLCJiZHJPcHkiLCJzZXR1cE91dGxpbmVDb2xvciIsIm90bG5PcHkiLCJnZXRQYXRoIiwibm9kZVBhdGhDYWNoZSIsInNoYXBlUHRzIiwic2hhcGVQYXRoIiwiZHJhd1NoYXBlIiwiZHJhd0ltYWdlcyIsInByZXZCZ2luZyIsInRvdGFsQ29tcGxldGVkIiwiZHJhd1BpZSIsInJlZHJhd1NoYXBlIiwicGllT3BhY2l0eSIsImRyYXdTdHJpcGUiLCJzdHJpcGVPcGFjaXR5IiwiZGFya2VuIiwiZGFya2VuT3BhY2l0eSIsImRyYXdCb3JkZXIiLCJyZWdpb24iLCJhZGRQYXRoIiwiZHJhd091dGxpbmUiLCJiV2lkdGgiLCJzY2FsZVgiLCJzY2FsZVkiLCJzV2lkdGgiLCJzSGVpZ2h0IiwiX3BhdGgiLCJvdXRsaW5lUGF0aCIsImRyYXdFbGxpcHNlUGF0aCIsInNNdWx0IiwiZHJhd1JvdW5kUG9seWdvblBhdGgiLCJkcmF3Um91bmRSZWN0YW5nbGVQYXRoIiwiZHJhd0N1dFJlY3RhbmdsZVBhdGgiLCJkcmF3Qm90dG9tUm91bmRSZWN0YW5nbGVQYXRoIiwiZHJhd0JhcnJlbFBhdGgiLCJkcmF3UG9seWdvblBhdGgiLCJfcGFkIiwiZWZmR2hvc3RPcGFjaXR5IiwiZHJhd05vZGVPdmVybGF5VW5kZXJsYXkiLCJjeVN0eWxlIiwicGllU2l6ZSIsImhvbGUiLCJvdmVyYWxsU3RhcnRBbmdsZSIsImhvbGVSYWRpdXMiLCJsYXN0UGVyY2VudCIsImFuZ2xlU3RhcnQiLCJhbmdsZURlbHRhIiwiYW5nbGVFbmQiLCJzdHJpcGVTaXplIiwic3RyaXBlVyIsInN0cmlwZUgiLCJDUnAkNSIsIm1vdGlvbkJsdXJEZWxheSIsImNvbnRleHRzIiwiYmFja2luZ1N0b3JlIiwiYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwibXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwib0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwicGFpbnRDYWNoZSIsInBhaW50Q2FjaGVzIiwibmVlZFRvQ3JlYXRlQ2FjaGUiLCJjcmVhdGVHcmFkaWVudFN0eWxlRm9yIiwic2hhcGVTdHlsZU5hbWUiLCJncmFkaWVudFN0eWxlIiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJfZW5kIiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJfd2lkdGgiLCJfaGVpZ2h0IiwiaGFzUG9zaXRpb25zIiwiYWRkQ29sb3JTdG9wIiwiZ3JhZGllbnRGaWxsU3R5bGUiLCJiYWNrZ3JvdW5kRmlsbCIsImJhY2tncm91bmRDb2xvciIsImdyYWRpZW50U3Ryb2tlU3R5bGUiLCJsaW5lRmlsbCIsImxpbmVDb2xvciIsIm1iUHhSYXRpbyIsImJ1ZmZlckNhbnZhc2VzIiwiTU9USU9OQkxVUl9CVUZGRVJfTk9ERSIsIk1PVElPTkJMVVJfQlVGRkVSX0RSQUciLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImNhbnZhc0NvbnRhaW5lciIsIkNBTlZBU19MQVlFUlMiLCJjYW52YXNlcyIsIkJVRkZFUl9DT1VOVCIsInRleHR1cmVNdWx0IiwiVEVYVFVSRV9CVUZGRVIiLCJmb3JjZWRDb250ZXh0IiwiZm9yY2VkWm9vbSIsImZvcmNlZFBhbiIsImRyYXdBbGxMYXllcnMiLCJmb3JjZWRQeFJhdGlvIiwiY2xlYXJDYW52YXMiLCJOT0RFIiwiRFJBRyIsImRyYXdPbmx5Tm9kZUxheWVyIiwibmVlZERyYXciLCJjYW52YXNOZWVkc1JlZHJhdyIsInRleHR1cmVEcmF3IiwiaW5Ob2RlRHJhZ0dlc3R1cmUiLCJtb3Rpb25CbHVyRmFkZUVmZmVjdCIsInByZXZQeFJhdGlvIiwibW90aW9uQmx1clRpbWVvdXQiLCJtYkZyYW1lcyIsImNsZWFyaW5nTW90aW9uQmx1ciIsInRleHR1cmVEcmF3TGFzdEZyYW1lIiwiU0VMRUNUX0JPWCIsImVmZmVjdGl2ZVpvb20iLCJlZmZlY3RpdmVQYW4iLCJwcmV2VnAiLCJwcmV2Vmlld3BvcnQiLCJ2aWV3cG9ydElzRGlmZiIsIm1iY2xlYXIiLCJmaWxsUmVjdCIsInNldENvbnRleHRUcmFuc2Zvcm0iLCJlUGFuIiwiZVpvb20iLCJidWZmZXJDb250ZXh0cyIsInRleHR1cmVDYWNoZSIsIm1wYW4iLCJvdXRzaWRlQmdDb2xvciIsIm91dHNpZGVCZ09wYWNpdHkiLCJ2cE1hbmlwIiwiaGlkZUVkZ2VzIiwibmVlZE1iQ2xlYXIiLCJ1c2VCdWZmZXIiLCJkcmF3RGVidWdQb2ludHMiLCJkcmF3U2VsZWN0aW9uUmVjdGFuZ2xlIiwiY3h0Tm9kZSIsInR4dE5vZGUiLCJjeHREcmFnIiwidHh0RHJhZyIsImRyYXdNb3Rpb25CbHVyIiwidHh0IiwibmVlZENsZWFyIiwicHhyIiwibW90aW9uQmx1ckNsZWFyZWQiLCJmcHNIZWlnaHQiLCJzdHJva2VSZWN0IiwiZnBzIiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJtYXhGcHMiLCJjb21waWxlU2hhZGVyIiwiZ2wiLCJzaGFkZXIiLCJjcmVhdGVTaGFkZXIiLCJzaGFkZXJTb3VyY2UiLCJnZXRTaGFkZXJQYXJhbWV0ZXIiLCJDT01QSUxFX1NUQVRVUyIsImdldFNoYWRlckluZm9Mb2ciLCJjcmVhdGVQcm9ncmFtIiwidmVydGV4U291cmNlIiwiZnJhZ2VtZW50U291cmNlIiwidmVydGV4U2hhZGVyIiwiVkVSVEVYX1NIQURFUiIsImZyYWdtZW50U2hhZGVyIiwiRlJBR01FTlRfU0hBREVSIiwicHJvZ3JhbSIsImF0dGFjaFNoYWRlciIsImxpbmtQcm9ncmFtIiwiZ2V0UHJvZ3JhbVBhcmFtZXRlciIsIkxJTktfU1RBVFVTIiwiY3JlYXRlVGV4dHVyZUNhbnZhcyIsImdldEVmZmVjdGl2ZVBhblpvb20iLCJnZXRFZmZlY3RpdmVab29tIiwiaXNTaW1wbGVTaGFwZSIsImFycmF5RXF1YWwiLCJ0b1dlYkdMQ29sb3IiLCJvdXRBcnJheSIsImluZGV4VG9WZWM0IiwidmVjNFRvSW5kZXgiLCJ2ZWM0IiwiY3JlYXRlVGV4dHVyZSIsImRlYnVnSUQiLCJidWZmZXIiLCJvZmZzY3JlZW5DYW52YXMiLCJiaW5kVGV4dHVyZSIsIlRFWFRVUkVfMkQiLCJ0ZXhQYXJhbWV0ZXJpIiwiVEVYVFVSRV9XUkFQX1MiLCJDTEFNUF9UT19FREdFIiwiVEVYVFVSRV9XUkFQX1QiLCJURVhUVVJFX01BR19GSUxURVIiLCJMSU5FQVIiLCJURVhUVVJFX01JTl9GSUxURVIiLCJMSU5FQVJfTUlQTUFQX05FQVJFU1QiLCJwaXhlbFN0b3JlaSIsIlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCIsInRleEltYWdlMkQiLCJSR0JBIiwiVU5TSUdORURfQllURSIsImdlbmVyYXRlTWlwbWFwIiwiZGVsZXRlVGV4dHVyZSIsImdldFR5cGVJbmZvIiwiZ2xzbFR5cGUiLCJGTE9BVCIsIklOVCIsImNyZWF0ZVR5cGVkQXJyYXkiLCJnbFR5cGUiLCJkYXRhT3JTaXplIiwiSW50MzJBcnJheSIsImNyZWF0ZVR5cGVkQXJyYXlWaWV3Iiwic3RyaWRlIiwiY3JlYXRlQnVmZmVyU3RhdGljRHJhdyIsImF0dHJpYnV0ZUxvYyIsImRhdGFBcnJheSIsIl9nZXRUeXBlSW5mbyIsIl9nZXRUeXBlSW5mbzIiLCJjcmVhdGVCdWZmZXIiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiYnVmZmVyRGF0YSIsIlNUQVRJQ19EUkFXIiwidmVydGV4QXR0cmliUG9pbnRlciIsInZlcnRleEF0dHJpYklQb2ludGVyIiwiZW5hYmxlVmVydGV4QXR0cmliQXJyYXkiLCJjcmVhdGVCdWZmZXJEeW5hbWljRHJhdyIsImluc3RhbmNlcyIsIl9nZXRUeXBlSW5mbzMiLCJfZ2V0VHlwZUluZm80IiwiYnl0ZXMiLCJEWU5BTUlDX0RSQVciLCJ2ZXJ0ZXhBdHRyaWJEaXZpc29yIiwidmlld3MiLCJnZXRWaWV3Iiwic2V0UG9pbnQiLCJ2aWV3IiwiYnVmZmVyU3ViRGF0YSIsImNyZWF0ZTN4M01hdHJpeEJ1ZmZlckR5bmFtaWNEcmF3IiwibWF0cml4U2l6ZSIsIm1hdHJpeERhdGEiLCJtYXRyaXhWaWV3cyIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwibG9jIiwiZ2V0TWF0cml4VmlldyIsInNldERhdGEiLCJjcmVhdGVQaWNraW5nRnJhbWVCdWZmZXIiLCJmYiIsImNyZWF0ZUZyYW1lYnVmZmVyIiwiYmluZEZyYW1lYnVmZmVyIiwiRlJBTUVCVUZGRVIiLCJ0YXJnZXRUZXh0dXJlIiwiZnJhbWVidWZmZXJUZXh0dXJlMkQiLCJDT0xPUl9BVFRBQ0hNRU5UMCIsInNldEZyYW1lYnVmZmVyQXR0YWNobWVudFNpemVzIiwiQVJSQVlfVFlQRSIsIm11bHRpcGx5IiwiYTAwIiwiYTAxIiwiYTAyIiwiYTEwIiwiYTExIiwiYTEyIiwiYTIwIiwiYTIxIiwiYTIyIiwiYjAwIiwiYjAxIiwiYjAyIiwiYjEwIiwiYjExIiwiYjEyIiwiYjIwIiwiYjIxIiwiYjIyIiwicmFkIiwiQXRsYXMiLCJ0ZXhTaXplIiwidGV4Um93cyIsInRleEhlaWdodCIsImVuYWJsZVdyYXBwaW5nIiwibmVlZHNCdWZmZXIiLCJmcmVlUG9pbnRlciIsImtleVRvTG9jYXRpb24iLCJsb2NrIiwiZ2V0S2V5cyIsImdldFNjYWxlIiwibWF4VGV4V2lkdGgiLCJ0ZXhXIiwidGV4SCIsImRvRHJhd2luZyIsIl90aGlzJGdldFNjYWxlIiwiZHJhd0F0IiwibG9jYXRpb24iLCJ4T2Zmc2V0IiwieU9mZnNldCIsImxvY2F0aW9ucyIsImRyYXdOb3JtYWwiLCJkcmF3V3JhcHBlZCIsImZpcnN0VGV4VyIsInNlY29uZFRleFciLCJfZHkiLCJtb3ZlVG9TdGFydE9mTmV4dFJvdyIsImdldE9mZnNldHMiLCJpc0VtcHR5IiwiY2FuRml0IiwiX3RoaXMkZ2V0U2NhbGUyIiwiYnVmZmVySWZOZWVkZWQiLCJkaXNwb3NlIiwiQXRsYXNDb2xsZWN0aW9uIiwiYXRsYXNlcyIsInN0eWxlS2V5VG9BdGxhcyIsIm1hcmtlZEtleXMiLCJfY3JlYXRlQXRsYXMiLCJfZ2V0U2NyYXRjaENhbnZhcyIsImF0bGFzIiwiZ2V0QXRsYXMiLCJoYXNBdGxhcyIsIm1hcmtLZXlGb3JHQyIsIl90aGlzMiIsIm5ld0F0bGFzZXMiLCJuZXdTdHlsZUtleVRvQXRsYXMiLCJuZXdBdGxhcyIsImtleXNUb0NvbGxlY3QiLCJfYXRsYXMkZ2V0T2Zmc2V0cyIsIl9hdGxhcyRnZXRPZmZzZXRzMiIsInMxIiwiczIiLCJfY29weVRleHR1cmVUb05ld0F0bGFzIiwib2xkQXRsYXMiLCJfb2xkQXRsYXMkZ2V0T2Zmc2V0cyIsIl9vbGRBdGxhcyRnZXRPZmZzZXRzMiIsImdldENvdW50cyIsImtleUNvdW50IiwiYXRsYXNDb3VudCIsInZhbHVlcyIsInNldDEiLCJzZXQyIiwiQXRsYXNNYW5hZ2VyIiwiZ2xvYmFsT3B0aW9ucyIsImF0bGFzU2l6ZSIsIm1heEF0bGFzZXNQZXJCYXRjaCIsInJlbmRlclR5cGVzIiwiY29sbGVjdGlvbnMiLCJ0eXBlQW5kSWRUb0tleSIsImdldEF0bGFzU2l6ZSIsImFkZEF0bGFzQ29sbGVjdGlvbiIsImNvbGxlY3Rpb25OYW1lIiwiYXRsYXNDb2xsZWN0aW9uT3B0aW9ucyIsIl90aGlzJGdsb2JhbE9wdGlvbnMiLCJjYWNoZWRDcmVhdGVUZXh0dXJlQ2FudmFzIiwiX2NhY2hlU2NyYXRjaENhbnZhcyIsImF0bGFzQ29sbGVjdGlvbiIsImFkZFJlbmRlclR5cGUiLCJyZW5kZXJUeXBlT3B0aW9ucyIsImdldFJlbmRlclR5cGVPcHRzIiwiZ2V0QXRsYXNDb2xsZWN0aW9uIiwicHJldlciLCJwcmV2SCIsInNjcmF0Y2hDYW52YXMiLCJyZW5kZXJUeXBlIiwiX3RoaXMzIiwiX3JlZjIkZm9yY2VSZWRyYXciLCJmb3JjZVJlZHJhdyIsIl9yZWYyJGZpbHRlckVsZSIsImZpbHRlckVsZSIsIl9yZWYyJGZpbHRlclR5cGUiLCJmaWx0ZXJUeXBlIiwibmVlZEdDIiwicnVuR0NOb3ciLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwiX2l0ZXJhdG9yNCIsIl9zdGVwNCIsImtleUFycmF5IiwiZ2V0SUQiLCJtYXBLZXkiLCJvbGRLZXlBcnJheSIsIm9sZEtleSIsIl9pdGVyYXRvcjUiLCJfc3RlcDUiLCJnZXRPckNyZWF0ZUF0bGFzIiwiZHJhd24iLCJkcmF3Q2xpcHBlZCIsImdldEF0bGFzSW5mbyIsIl90aGlzNCIsIl9hdGxhcyRnZXRPZmZzZXRzMyIsIl9hdGxhcyRnZXRPZmZzZXRzNCIsInRleDEiLCJ0ZXgyIiwidGV4IiwiZ2V0RGVidWdJbmZvIiwiZGVidWdJbmZvIiwiX2l0ZXJhdG9yNiIsIl9zdGVwNiIsIl9zdGVwNiR2YWx1ZSIsIl9jb2xsZWN0aW9uJGdldENvdW50cyIsIkF0bGFzQmF0Y2hNYW5hZ2VyIiwiYmF0Y2hBdGxhc2VzIiwiZ2V0TWF4QXRsYXNlc1BlckJhdGNoIiwiZ2V0SW5kZXhBcnJheSIsImdldEF0bGFzQ291bnQiLCJnZXRBdGxhc2VzIiwiY2FuQWRkVG9DdXJyZW50QmF0Y2giLCJnZXRBdGxhc0luZGV4Rm9yQmF0Y2giLCJhdGxhc0lEIiwiY2lyY2xlU0QiLCJyZWN0YW5nbGVTRCIsInJvdW5kUmVjdGFuZ2xlU0QiLCJlbGxpcHNlU0QiLCJSRU5ERVJfVEFSR0VUIiwiU0NSRUVOIiwic2NyZWVuIiwiUElDS0lORyIsInBpY2tpbmciLCJURVhfUElDS0lOR19NT0RFIiwiSUdOT1JFIiwiVVNFX0JCIiwiVEVYVFVSRSIsIkVER0VfU1RSQUlHSFQiLCJFREdFX0NVUlZFX1NFR01FTlQiLCJFREdFX0FSUk9XIiwiUkVDVEFOR0xFIiwiUk9VTkRfUkVDVEFOR0xFIiwiQk9UVE9NX1JPVU5EX1JFQ1RBTkdMRSIsIkVMTElQU0UiLCJFbGVtZW50RHJhd2luZ1dlYkdMIiwibWF4SW5zdGFuY2VzIiwiYmdDb2xvciIsImJhdGNoRGVidWdJbmZvIiwiYXRsYXNNYW5hZ2VyIiwiYmF0Y2hNYW5hZ2VyIiwic2ltcGxlU2hhcGVPcHRpb25zIiwiX2NyZWF0ZVNoYWRlclByb2dyYW0iLCJwaWNraW5nUHJvZ3JhbSIsInZhbyIsIl9jcmVhdGVWQU8iLCJhZGRUZXh0dXJlQXRsYXNSZW5kZXJUeXBlIiwidHlwZU5hbWUiLCJhZGRTaW1wbGVTaGFwZVJlbmRlclR5cGUiLCJyZW5kZXJUYXJnZXQiLCJ2ZXJ0ZXhTaGFkZXJTb3VyY2UiLCJpZHhzIiwiZnJhZ21lbnRTaGFkZXJTb3VyY2UiLCJhUG9zaXRpb24iLCJnZXRBdHRyaWJMb2NhdGlvbiIsImFJbmRleCIsImFWZXJ0VHlwZSIsImFUcmFuc2Zvcm0iLCJhQXRsYXNJZCIsImFUZXgiLCJhUG9pbnRBUG9pbnRCIiwiYVBvaW50Q1BvaW50RCIsImFMaW5lV2lkdGgiLCJhQ29sb3IiLCJhQ29ybmVyUmFkaXVzIiwiYUJvcmRlckNvbG9yIiwidVBhblpvb21NYXRyaXgiLCJnZXRVbmlmb3JtTG9jYXRpb24iLCJ1QXRsYXNTaXplIiwidUJHQ29sb3IiLCJ1Wm9vbSIsInVUZXh0dXJlcyIsInVuaXRTcXVhcmUiLCJ2ZXJ0ZXhDb3VudCIsImNyZWF0ZVZlcnRleEFycmF5IiwiYmluZFZlcnRleEFycmF5IiwidHJhbnNmb3JtQnVmZmVyIiwiaW5kZXhCdWZmZXIiLCJ2ZXJ0VHlwZUJ1ZmZlciIsImF0bGFzSWRCdWZmZXIiLCJ0ZXhCdWZmZXIiLCJwb2ludEFQb2ludEJCdWZmZXIiLCJwb2ludENQb2ludERCdWZmZXIiLCJsaW5lV2lkdGhCdWZmZXIiLCJjb2xvckJ1ZmZlciIsImNvcm5lclJhZGl1c0J1ZmZlciIsImJvcmRlckNvbG9yQnVmZmVyIiwiX2J1ZmZlcnMiLCJzdGFydEZyYW1lIiwicGFuWm9vbU1hdHJpeCIsIndyYXBwZWRDb3VudCIsInNpbXBsZUNvdW50IiwiaW5zdGFuY2VDb3VudCIsImVuZEZyYW1lIiwiX2lzVmlzaWJsZSIsImRyYXdUZXh0dXJlIiwiZWxlSW5kZXgiLCJfaXNWYWxpZEVkZ2UiLCJnZXRUZXhQaWNraW5nTW9kZSIsImRyYXdQaWNraW5nUmVjdGFuZ2xlIiwiYXRsYXNJbmZvQXJyYXkiLCJhdGxhc0luZm8iLCJhdGxhc0luZGV4IiwiX2FyciIsIl9hcnIkX2kiLCJpbnN0YW5jZSIsImluZGV4VmlldyIsImF0bGFzSWRWaWV3IiwidGV4VmlldyIsIm1hdHJpeFZpZXciLCJzZXRUcmFuc2Zvcm1NYXRyaXgiLCJzaGFwZVByb3BzIiwicmF0aW8iLCJhZGpCQiIsIl9nZXRBZGp1c3RlZEJCIiwiX2FwcGx5VHJhbnNmb3JtTWF0cml4IiwiX2JiIiwiX2FkakJCIiwiX29wdHMkZ2V0Um90YXRpb25Qb2luIiwiYWRqVyIsImNvbG9yVmlldyIsInZlcnRUeXBlIiwiX2dldFZlcnRUeXBlRm9yU2hhcGUiLCJfZ2V0Q29ybmVyUmFkaXVzIiwicmFkaXVzVmlldyIsImxpbmVXaWR0aFZpZXciLCJib3JkZXJDb2xvclZpZXciLCJzaGFwZVByb3AiLCJyYWRpdXNQcm9wIiwiZHJhd0VkZ2VBcnJvdyIsImJhc2VPcGFjaXR5Iiwic2NhbGUkMSIsImRyYXdFZGdlTGluZSIsIl9nZXRFZGdlUG9pbnRzIiwic291cmNlVGFyZ2V0VmlldyIsIl9pbnN0YW5jZSIsIl9pbmRleFZpZXciLCJfY29sb3JWaWV3IiwiX2xpbmVXaWR0aEJ1ZmZlciIsInBBeCIsInBBeSIsInBCeCIsInBCeSIsInBDeCIsInBDeSIsInBEeCIsInBEeSIsInBvaW50QUJWaWV3IiwicG9pbnRDRFZpZXciLCJudW1TZWdtZW50cyIsIl9nZXROdW1TZWdtZW50cyIsIl9nZXRDdXJ2ZVNlZ21lbnRQb2ludHMiLCJjdXJ2ZVBvaW50cyIsIl9zZXRDdXJ2ZVBvaW50IiwiY3BpIiwibmV3cG9pbnRzIiwidXNlUHJvZ3JhbSIsImJ1ZmZlcnMiLCJhY3RpdmVUZXh0dXJlIiwiVEVYVFVSRTAiLCJ1bmlmb3JtMWkiLCJ1bmlmb3JtMWYiLCJ1bmlmb3JtTWF0cml4M2Z2IiwidW5pZm9ybTRmdiIsImRyYXdBcnJheXNJbnN0YW5jZWQiLCJUUklBTkdMRVMiLCJ0b3RhbEF0bGFzZXMiLCJiYXRjaEluZm8iLCJ0b3RhbEluc3RhbmNlcyIsIkNScCQ0IiwiaW5pdFdlYmdsIiwiV0VCR0wiLCJnZXRCR0NvbG9yIiwiZ2V0UGFyYW1ldGVyIiwiTUFYX1RFWFRVUkVfU0laRSIsIk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTIiwicGlja2luZ0ZyYW1lQnVmZmVyIiwibmVlZHNEcmF3IiwiZHJhd2luZyIsImlzTGFiZWxWaXNpYmxlIiwiaXNMYXllclZpc2libGUiLCJnZXRCQkZvclNpbXBsZVNoYXBlIiwiX25vZGUkcG9zaXRpb24iLCJnZXRTdHlsZUtleSIsImdldEVsZW1lbnRCb3giLCJnZXRTdHlsZUtleXNGb3JMYWJlbCIsImdldExhYmVsS2V5IiwiZ2V0Qm91bmRpbmdCb3hGb3JMYWJlbCIsImdldExhYmVsQm94IiwiZ2V0TGFiZWxSb3RhdGlvblBvaW50IiwiZ2V0TGFiZWxSb3RhdGlvbk9mZnNldCIsImdldFNvdXJjZUxhYmVsS2V5IiwiZ2V0U291cmNlTGFiZWxCb3giLCJkcmF3U291cmNlTGFiZWwiLCJnZXRTb3VyY2VMYWJlbFJvdGF0aW9uUG9pbnQiLCJnZXRTb3VyY2VMYWJlbFJvdGF0aW9uT2Zmc2V0IiwiZ2V0VGFyZ2V0TGFiZWxLZXkiLCJnZXRUYXJnZXRMYWJlbEJveCIsImRyYXdUYXJnZXRMYWJlbCIsImdldFRhcmdldExhYmVsUm90YXRpb25Qb2ludCIsImdldFRhcmdldExhYmVsUm90YXRpb25PZmZzZXQiLCJzZXRHQ0ZsYWciLCJnY05lZWRlZCIsIm92ZXJyaWRlQ2FudmFzUmVuZGVyZXJGdW5jdGlvbnMiLCJjc3NDb2xvciIsImdldExhYmVsTGluZXMiLCJ1aSIsImxpbmVJbmRleCIsInJlbmRlckNhbnZhcyIsImNsZWFyV2ViZ2wiLCJyZW5kZXJXZWJnbCIsImJhc2VGdW5jIiwiZmluZE5lYXJlc3RFbGVtZW50c1dlYmdsIiwiX2Jhc2VGdW5jIiwiX2Jhc2VGdW5jMiIsIkNPTE9SX0JVRkZFUl9CSVQiLCJERVBUSF9CVUZGRVJfQklUIiwiY3JlYXRlUGFuWm9vbU1hdHJpeCIsIl91dGlsJGdldEVmZmVjdGl2ZVBhbiIsInByb2plY3Rpb24kMSIsInByb2R1Y3QiLCJfdXRpbCRnZXRFZmZlY3RpdmVQYW4yIiwiZHJhd0F4ZXMiLCJkcmF3QXRsYXNlcyIsImdldFBpY2tpbmdJbmRleGVzIiwiX3V0aWwkZ2V0RWZmZWN0aXZlUGFuMyIsIl91dGlsJG1vZGVsVG9SZW5kZXJlZCIsIl91dGlsJG1vZGVsVG9SZW5kZXJlZDIiLCJjWDEiLCJjWTEiLCJVaW50OEFycmF5IiwicmVhZFBpeGVscyIsImluZGV4ZXMiLCJwaXhlbCIsIkJvb2xlYW4iLCJkcmF3RWxlIiwiZWxlQ291bnQiLCJjbGVhckNvbG9yIiwiZW5hYmxlIiwiQkxFTkQiLCJibGVuZEZ1bmMiLCJPTkUiLCJPTkVfTUlOVVNfU1JDX0FMUEhBIiwiZGlzYWJsZSIsImNvbXBhY3QiLCJyZXBvcnQiLCJDUnAkMyIsImFyY1RvIiwiYmFycmVsQ3VydmVDb25zdGFudHMiLCJzaW4wIiwiY29zMCIsImVsbGlwc2VTdGVwU2l6ZSIsImVsbGlwc2UiLCJ4UG9zIiwieVBvcyIsInJ3IiwicmgiLCJDUnAkMiIsImJ1ZmZlckNhbnZhc0ltYWdlIiwiY3RyUmVjdCIsImZ1bGwiLCJzcGVjZE1heERpbXMiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1heFNjYWxlVyIsIm1heFNjYWxlSCIsImJ1ZmZDYW52YXMiLCJidWZmQ3h0IiwienNvcnRlZEVsZXMiLCJiNjRUb0Jsb2IiLCJiNjQiLCJtaW1lVHlwZSIsImF0b2IiLCJidWZmIiwiQXJyYXlCdWZmZXIiLCJidWZmVWludDgiLCJCbG9iIiwiYjY0VXJpVG9CNjQiLCJiNjR1cmkiLCJvdXRwdXQiLCJnZXRCNjRVcmkiLCJ0b0RhdGFVUkwiLCJxdWFsaXR5IiwidG9CbG9iIiwiYmxvYiIsIkNScCQxIiwiQ1IiLCJDYW52YXNSZW5kZXJlciIsIkNScCIsIkNBTlZBU19UWVBFUyIsInRhcEhsT2ZmQXR0ciIsInRhcEhsT2ZmU3R5bGUiLCJjb250YWluZXJTdHlsZSIsInN0eWxlTWFwIiwic2V0QXR0cmlidXRlIiwidG9wQ2FudmFzIiwicGF0aHNFbmFibGVkIiwiZW1wdHlCYiIsImdldEJveENlbnRlciIsImdldENlbnRlck9mZnNldCIsImJhY2tncm91bmRUaW1lc3RhbXBIYXNDaGFuZ2VkIiwib2xkQmFja2dyb3VuZFRpbWVzdGFtcCIsImlzTGFiZWxWaXNpYmxlQXRTY2FsZSIsImdldEVsZW1lbnRSb3RhdGlvblBvaW50IiwiYWRkVGV4dE1hcmdpbiIsImdldFJzUHQiLCJnZXRFbGVtZW50Um90YXRpb25PZmZzZXQiLCJpbnZhbGlkYXRlVGV4dHVyZUNhY2hlcyIsInJlZmluZUluTGF5ZXJzIiwicGF0aHNJbXBsZCIsInBhdGgyZEVuYWJsZWQiLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJ3ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtb3pJbWFnZVNtb290aGluZ0VuYWJsZWQiLCJtc0ltYWdlU21vb3RoaW5nRW5hYmxlZCIsIk9mZnNjcmVlbkNhbnZhcyIsImluY0V4dHMiLCJleHRlbnNpb25zIiwibW9kdWxlcyIsInNldEV4dGVuc2lvbiIsInJlZ2lzdHJhbnQiLCJleHQiLCJvdmVycmlkZUVyciIsImxheW91dFByb3RvIiwib3B0TGF5b3V0Rm5zIiwiZm5OYW1lIiwicmVnU3RvcCIsImdldEN5IiwiZW1pdHRlck9wdHMiLCJnZXRFeHRlbnNpb24iLCJiUHJvdG8iLCJSZWdpc3RyYW50UmVuZGVyZXIiLCJyUHJvdG8iLCJSZW5kZXJlciIsInBOYW1lIiwicFZhbCIsImV4aXN0c0luUiIsIl9wTmFtZSIsInNldE1vZHVsZSIsIm1vZHVsZVR5cGUiLCJtb2R1bGVOYW1lIiwiZ2V0TW9kdWxlIiwiX1N0eWxlc2hlZXQiLCJTdHlsZXNoZWV0Iiwic2hlZXRmbiIsInZlcnNpb24iLCJjeXRvc2NhcGUiLCJkZWZhdWx0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/cytoscape@3.33.1/node_modules/cytoscape/dist/cytoscape.esm.mjs\n");

/***/ })

};
;