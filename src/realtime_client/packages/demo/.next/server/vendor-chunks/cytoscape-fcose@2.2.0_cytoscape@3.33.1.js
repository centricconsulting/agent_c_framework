/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape-fcose@2.2.0_cytoscape@3.33.1";
exports.ids = ["vendor-chunks/cytoscape-fcose@2.2.0_cytoscape@3.33.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/cytoscape-fcose@2.2.0_cytoscape@3.33.1/node_modules/cytoscape-fcose/cytoscape-fcose.js":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/cytoscape-fcose@2.2.0_cytoscape@3.33.1/node_modules/cytoscape-fcose/cytoscape-fcose.js ***!
  \***********************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! cose-base */ \"(ssr)/../../node_modules/.pnpm/cose-base@2.2.0/node_modules/cose-base/cose-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 658:\n/***/ ((module) => {\n\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n\n/***/ 548:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1129__) => {\n\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/*\n * Auxiliary functions\n */\n\nvar LinkedList = __nested_webpack_require_1129__(140).layoutBase.LinkedList;\n\nvar auxiliary = {};\n\n// get the top most nodes\nauxiliary.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n// find disconnected components and create dummy nodes that connect them\nauxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n  var queue = new LinkedList();\n  var visited = new Set();\n  var visitedTopMostNodes = [];\n  var currentNeighbor = void 0;\n  var minDegreeNode = void 0;\n  var minDegree = void 0;\n\n  var isConnected = false;\n  var count = 1;\n  var nodesConnectedToDummy = [];\n  var components = [];\n\n  var _loop = function _loop() {\n    var cmpt = cy.collection();\n    components.push(cmpt);\n\n    var currentNode = topMostNodes[0];\n    var childrenOfCurrentNode = cy.collection();\n    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n    visitedTopMostNodes.push(currentNode);\n\n    childrenOfCurrentNode.forEach(function (node) {\n      queue.push(node);\n      visited.add(node);\n      cmpt.merge(node);\n    });\n\n    var _loop2 = function _loop2() {\n      currentNode = queue.shift();\n\n      // Traverse all neighbors of this node\n      var neighborNodes = cy.collection();\n      currentNode.neighborhood().nodes().forEach(function (node) {\n        if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n          neighborNodes.merge(node);\n        }\n      });\n\n      for (var i = 0; i < neighborNodes.length; i++) {\n        var neighborNode = neighborNodes[i];\n        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n\n          childrenOfNeighbor.forEach(function (node) {\n            queue.push(node);\n            visited.add(node);\n            cmpt.merge(node);\n            if (topMostNodes.has(node)) {\n              visitedTopMostNodes.push(node);\n            }\n          });\n        }\n      }\n    };\n\n    while (queue.length != 0) {\n      _loop2();\n    }\n\n    cmpt.forEach(function (node) {\n      eles.intersection(node.connectedEdges()).forEach(function (e) {\n        // connectedEdges() usually cached\n        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n          // has() is cheap\n          cmpt.merge(e);\n        }\n      });\n    });\n\n    if (visitedTopMostNodes.length == topMostNodes.length) {\n      isConnected = true;\n    }\n\n    if (!isConnected || isConnected && count > 1) {\n      minDegreeNode = visitedTopMostNodes[0];\n      minDegree = minDegreeNode.connectedEdges().length;\n      visitedTopMostNodes.forEach(function (node) {\n        if (node.connectedEdges().length < minDegree) {\n          minDegree = node.connectedEdges().length;\n          minDegreeNode = node;\n        }\n      });\n      nodesConnectedToDummy.push(minDegreeNode.id());\n      // TO DO: Check efficiency of this part\n      var temp = cy.collection();\n      temp.merge(visitedTopMostNodes[0]);\n      visitedTopMostNodes.forEach(function (node) {\n        temp.merge(node);\n      });\n      visitedTopMostNodes = [];\n      topMostNodes = topMostNodes.difference(temp);\n      count++;\n    }\n  };\n\n  do {\n    _loop();\n  } while (!isConnected);\n\n  if (dummyNodes) {\n    if (nodesConnectedToDummy.length > 0) {\n      dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n    }\n  }\n  return components;\n};\n\n// relocates componentResult to originalCenter if there is no fixedNodeConstraint\nauxiliary.relocateComponent = function (originalCenter, componentResult, options) {\n  if (!options.fixedNodeConstraint) {\n    var minXCoord = Number.POSITIVE_INFINITY;\n    var maxXCoord = Number.NEGATIVE_INFINITY;\n    var minYCoord = Number.POSITIVE_INFINITY;\n    var maxYCoord = Number.NEGATIVE_INFINITY;\n    if (options.quality == \"draft\") {\n      // calculate current bounding box\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          var key = _ref2[0];\n          var value = _ref2[1];\n\n          var cyNode = options.cy.getElementById(key);\n          if (cyNode) {\n            var nodeBB = cyNode.boundingBox();\n            var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n            var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n            var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n            var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n\n            if (leftX < minXCoord) minXCoord = leftX;\n            if (rightX > maxXCoord) maxXCoord = rightX;\n            if (topY < minYCoord) minYCoord = topY;\n            if (bottomY > maxYCoord) maxYCoord = bottomY;\n          }\n        }\n        // find difference between current and original center\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      componentResult.xCoords = componentResult.xCoords.map(function (x) {\n        return x + diffOnX;\n      });\n      componentResult.yCoords = componentResult.yCoords.map(function (y) {\n        return y + diffOnY;\n      });\n    } else {\n      // calculate current bounding box\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        var leftX = node.getRect().x;\n        var rightX = node.getRect().x + node.getRect().width;\n        var topY = node.getRect().y;\n        var bottomY = node.getRect().y + node.getRect().height;\n\n        if (leftX < minXCoord) minXCoord = leftX;\n        if (rightX > maxXCoord) maxXCoord = rightX;\n        if (topY < minYCoord) minYCoord = topY;\n        if (bottomY > maxYCoord) maxYCoord = bottomY;\n      });\n      // find difference between current and original center\n      var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n      });\n    }\n  }\n};\n\nauxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n  // calculate bounds\n  var left = Number.MAX_SAFE_INTEGER;\n  var right = Number.MIN_SAFE_INTEGER;\n  var top = Number.MAX_SAFE_INTEGER;\n  var bottom = Number.MIN_SAFE_INTEGER;\n  var nodeLeft = void 0;\n  var nodeRight = void 0;\n  var nodeTop = void 0;\n  var nodeBottom = void 0;\n\n  var nodes = parentNode.descendants().not(\":parent\");\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var node = nodes[i];\n\n    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingBox = {};\n  boundingBox.topLeftX = left;\n  boundingBox.topLeftY = top;\n  boundingBox.width = right - left;\n  boundingBox.height = bottom - top;\n  return boundingBox;\n};\n\n// This function finds and returns parent nodes whose all children are hidden\nauxiliary.calcParentsWithoutChildren = function (cy, eles) {\n  var parentsWithoutChildren = cy.collection();\n  eles.nodes(':parent').forEach(function (parent) {\n    var check = false;\n    parent.children().forEach(function (child) {\n      if (child.css('display') != 'none') {\n        check = true;\n      }\n    });\n    if (!check) {\n      parentsWithoutChildren.merge(parent);\n    }\n  });\n\n  return parentsWithoutChildren;\n};\n\nmodule.exports = auxiliary;\n\n/***/ }),\n\n/***/ 816:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_10973__) => {\n\n\n\n/**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/\n\nvar aux = __nested_webpack_require_10973__(548);\nvar CoSELayout = __nested_webpack_require_10973__(140).CoSELayout;\nvar CoSENode = __nested_webpack_require_10973__(140).CoSENode;\nvar PointD = __nested_webpack_require_10973__(140).layoutBase.PointD;\nvar DimensionD = __nested_webpack_require_10973__(140).layoutBase.DimensionD;\nvar LayoutConstants = __nested_webpack_require_10973__(140).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __nested_webpack_require_10973__(140).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __nested_webpack_require_10973__(140).CoSEConstants;\n\n// main function that cose layout is processed\nvar coseLayout = function coseLayout(options, spectralResult) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n\n  var nodeIndexes = void 0;\n  var xCoords = void 0;\n  var yCoords = void 0;\n  var idToLNode = {};\n\n  if (options.randomize) {\n    nodeIndexes = spectralResult[\"nodeIndexes\"];\n    xCoords = spectralResult[\"xCoords\"];\n    yCoords = spectralResult[\"yCoords\"];\n  }\n\n  var isFn = function isFn(fn) {\n    return typeof fn === 'function';\n  };\n\n  var optFn = function optFn(opt, ele) {\n    if (isFn(opt)) {\n      return opt(ele);\n    } else {\n      return opt;\n    }\n  };\n\n  /**** Postprocessing functions ****/\n\n  var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n\n  // transfer cytoscape nodes to cose nodes\n  var processChildrenList = function processChildrenList(parent, children, layout, options) {\n    var size = children.length;\n    for (var i = 0; i < size; i++) {\n      var theChild = children[i];\n      var children_of_children = null;\n      if (theChild.intersection(parentsWithoutChildren).length == 0) {\n        children_of_children = theChild.children();\n      }\n      var theNode = void 0;\n\n      var dimensions = theChild.layoutDimensions({\n        nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n      });\n\n      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n        if (options.randomize) {\n          if (!theChild.isParent()) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n            } else {\n              // for the parentsWithoutChildren\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n            }\n          }\n        } else {\n          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n        }\n      } else {\n        theNode = parent.add(new CoSENode(this.graphManager));\n      }\n      // Attach id to the layout node and repulsion value\n      theNode.id = theChild.data(\"id\");\n      theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n      // Attach the paddings of cy node to layout node\n      theNode.paddingLeft = parseInt(theChild.css('padding'));\n      theNode.paddingTop = parseInt(theChild.css('padding'));\n      theNode.paddingRight = parseInt(theChild.css('padding'));\n      theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n      //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n      //These properties will be used while updating bounds of compounds during iterations or tiling\n      //and will be used for simple nodes while transferring final positions to cytoscape\n      if (options.nodeDimensionsIncludeLabels) {\n        theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;\n        theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;\n        theNode.labelPosVertical = theChild.css(\"text-valign\");\n        theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n      }\n\n      // Map the layout node\n      idToLNode[theChild.data(\"id\")] = theNode;\n\n      if (isNaN(theNode.rect.x)) {\n        theNode.rect.x = 0;\n      }\n\n      if (isNaN(theNode.rect.y)) {\n        theNode.rect.y = 0;\n      }\n\n      if (children_of_children != null && children_of_children.length > 0) {\n        var theNewGraph = void 0;\n        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n        processChildrenList(theNewGraph, children_of_children, layout, options);\n      }\n    }\n  };\n\n  // transfer cytoscape edges to cose edges\n  var processEdges = function processEdges(layout, gm, edges) {\n    var idealLengthTotal = 0;\n    var edgeCount = 0;\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var sourceNode = idToLNode[edge.data(\"source\")];\n      var targetNode = idToLNode[edge.data(\"target\")];\n      if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n        e1.id = edge.id();\n        e1.idealLength = optFn(options.idealEdgeLength, edge);\n        e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n        idealLengthTotal += e1.idealLength;\n        edgeCount++;\n      }\n    }\n    // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n    // in case there is no edge, use other options\n    if (options.idealEdgeLength != null) {\n      if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength)) // in case there is no edge, but option gives a value to use\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else // in case there is no edge and we cannot get a value from option (because it's a function)\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      // we need to update these constant values based on the ideal edge length constant\n      CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    }\n  };\n\n  // transfer cytoscape constraints to cose layout\n  var processConstraints = function processConstraints(layout, options) {\n    // get nodes to be fixed\n    if (options.fixedNodeConstraint) {\n      layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n    }\n    // get nodes to be aligned\n    if (options.alignmentConstraint) {\n      layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n    }\n    // get nodes to be relatively placed\n    if (options.relativePlacementConstraint) {\n      layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n    }\n  };\n\n  /**** Apply postprocessing ****/\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n\n  if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n  CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n  // This part is for debug/demo purpose\n  if (options.step == \"transformed\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"enforced\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"cose\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n  if (options.step == \"all\") {\n    if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n\n  if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n  } else {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n  }\n\n  var coseLayout = new CoSELayout();\n  var gm = coseLayout.newGraphManager();\n\n  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n  processEdges(coseLayout, gm, edges);\n  processConstraints(coseLayout, options);\n\n  coseLayout.runLayout();\n\n  return idToLNode;\n};\n\nmodule.exports = { coseLayout: coseLayout };\n\n/***/ }),\n\n/***/ 212:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_22455__) => {\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n  The implementation of the fcose layout algorithm\n*/\n\nvar assign = __nested_webpack_require_22455__(658);\nvar aux = __nested_webpack_require_22455__(548);\n\nvar _require = __nested_webpack_require_22455__(657),\n    spectralLayout = _require.spectralLayout;\n\nvar _require2 = __nested_webpack_require_22455__(816),\n    coseLayout = _require2.coseLayout;\n\nvar defaults = Object.freeze({\n\n  // 'draft', 'default' or 'proof' \n  // - 'draft' only applies spectral layout \n  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n  quality: \"default\",\n  // Use random node positions at beginning of layout\n  // if this is set to false, then quality option must be \"proof\"\n  randomize: true,\n  // Whether or not to animate the layout\n  animate: true,\n  // Duration of animation in ms, if enabled\n  animationDuration: 1000,\n  // Easing of animation, if enabled\n  animationEasing: undefined,\n  // Fit the viewport to the repositioned nodes\n  fit: true,\n  // Padding around layout\n  padding: 30,\n  // Whether to include labels in node dimensions. Valid in \"proof\" quality\n  nodeDimensionsIncludeLabels: false,\n  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n  uniformNodeDimensions: false,\n  // Whether to pack disconnected components - valid only if randomize: true\n  packComponents: true,\n  // Layout step - all, transformed, enforced, cose - for debug purpose only\n  step: \"all\",\n\n  /* spectral layout options */\n\n  // False for random, true for greedy\n  samplingType: true,\n  // Sample size to construct distance matrix\n  sampleSize: 25,\n  // Separation amount between nodes\n  nodeSeparation: 75,\n  // Power iteration tolerance\n  piTol: 0.0000001,\n\n  /* CoSE layout options */\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 4500;\n  },\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 50;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 0.45;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n  tilingCompareBy: undefined,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout  \n  initialEnergyOnIncremental: 0.3,\n\n  /* constraint options */\n\n  // Fix required nodes to predefined positions\n  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n  fixedNodeConstraint: undefined,\n  // Align required nodes in vertical/horizontal direction\n  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n  alignmentConstraint: undefined,\n  // Place two nodes relatively in vertical/horizontal direction \n  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n  relativePlacementConstraint: undefined,\n\n  /* layout event callbacks */\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n});\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    this.options = assign({}, defaults, options);\n  }\n\n  _createClass(Layout, [{\n    key: 'run',\n    value: function run() {\n      var layout = this;\n      var options = this.options;\n      var cy = options.cy;\n      var eles = options.eles;\n\n      var spectralResult = [];\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var coseResult = [];\n      var components = void 0;\n      var componentCenters = [];\n\n      // basic validity check for constraint inputs \n      if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n        options.fixedNodeConstraint = undefined;\n      }\n\n      if (options.alignmentConstraint) {\n        if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n          options.alignmentConstraint.vertical = undefined;\n        }\n        if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n          options.alignmentConstraint.horizontal = undefined;\n        }\n      }\n\n      if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n        options.relativePlacementConstraint = undefined;\n      }\n\n      // if any constraint exists, set some options\n      var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n      if (constraintExist) {\n        // constraints work with these options\n        options.tile = false;\n        options.packComponents = false;\n      }\n\n      // decide component packing is enabled or not\n      var layUtil = void 0;\n      var packingEnabled = false;\n      if (cy.layoutUtilities && options.packComponents) {\n        layUtil = cy.layoutUtilities(\"get\");\n        if (!layUtil) layUtil = cy.layoutUtilities();\n        packingEnabled = true;\n      }\n\n      if (eles.nodes().length > 0) {\n        // if packing is not enabled, perform layout on the whole graph\n        if (!packingEnabled) {\n          // store component center\n          var boundingBox = options.eles.boundingBox();\n          componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          // apply spectral layout\n          if (options.randomize) {\n            var result = spectralLayout(options);\n            spectralResult.push(result);\n          }\n          // apply cose layout as postprocessing\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            coseResult.push(coseLayout(options, spectralResult[0]));\n            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n          } else {\n            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n          }\n        } else {\n          // packing is enabled\n          var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n          components = aux.connectComponents(cy, options.eles, topMostNodes);\n          // store component centers\n          components.forEach(function (component) {\n            var boundingBox = component.boundingBox();\n            componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          });\n\n          //send each component to spectral layout if randomized\n          if (options.randomize) {\n            components.forEach(function (component) {\n              options.eles = component;\n              spectralResult.push(spectralLayout(options));\n            });\n          }\n\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            var toBeTiledNodes = cy.collection();\n            if (options.tile) {\n              // behave nodes to be tiled as one component\n              var nodeIndexes = new Map();\n              var _xCoords = [];\n              var _yCoords = [];\n              var count = 0;\n              var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n              var indexesToBeDeleted = [];\n              components.forEach(function (component, index) {\n                if (component.edges().length == 0) {\n                  component.nodes().forEach(function (node, i) {\n                    toBeTiledNodes.merge(component.nodes()[i]);\n                    if (!node.isParent()) {\n                      tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                      tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                      tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                    }\n                  });\n                  indexesToBeDeleted.push(index);\n                }\n              });\n              if (toBeTiledNodes.length > 1) {\n                var _boundingBox = toBeTiledNodes.boundingBox();\n                componentCenters.push({ x: _boundingBox.x1 + _boundingBox.w / 2, y: _boundingBox.y1 + _boundingBox.h / 2 });\n                components.push(toBeTiledNodes);\n                spectralResult.push(tempSpectralResult);\n                for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                  components.splice(indexesToBeDeleted[i], 1);\n                  spectralResult.splice(indexesToBeDeleted[i], 1);\n                  componentCenters.splice(indexesToBeDeleted[i], 1);\n                };\n              }\n            }\n            components.forEach(function (component, index) {\n              // send each component to cose layout\n              options.eles = component;\n              coseResult.push(coseLayout(options, spectralResult[index]));\n              aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n            });\n          } else {\n            components.forEach(function (component, index) {\n              aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n            });\n          }\n\n          // packing\n          var componentsEvaluated = new Set();\n          if (components.length > 1) {\n            var subgraphs = [];\n            var hiddenEles = eles.filter(function (ele) {\n              return ele.css('display') == 'none';\n            });\n            components.forEach(function (component, index) {\n              var nodeIndexes = void 0;\n              if (options.quality == \"draft\") {\n                nodeIndexes = spectralResult[index].nodeIndexes;\n              }\n\n              if (component.nodes().not(hiddenEles).length > 0) {\n                var subgraph = {};\n                subgraph.edges = [];\n                subgraph.nodes = [];\n                var nodeIndex = void 0;\n                component.nodes().not(hiddenEles).forEach(function (node) {\n                  if (options.quality == \"draft\") {\n                    if (!node.isParent()) {\n                      nodeIndex = nodeIndexes.get(node.id());\n                      subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n                    } else {\n                      var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                      subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n                    }\n                  } else {\n                    if (coseResult[index][node.id()]) {\n                      subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n                    }\n                  }\n                });\n                component.edges().forEach(function (edge) {\n                  var source = edge.source();\n                  var target = edge.target();\n                  if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                    if (options.quality == \"draft\") {\n                      var sourceNodeIndex = nodeIndexes.get(source.id());\n                      var targetNodeIndex = nodeIndexes.get(target.id());\n                      var sourceCenter = [];\n                      var targetCenter = [];\n                      if (source.isParent()) {\n                        var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                        sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                      } else {\n                        sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                        sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                      }\n                      if (target.isParent()) {\n                        var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                        targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                      } else {\n                        targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                        targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                      }\n                      subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n                    } else {\n                      if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                        subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n                      }\n                    }\n                  }\n                });\n                if (subgraph.nodes.length > 0) {\n                  subgraphs.push(subgraph);\n                  componentsEvaluated.add(index);\n                }\n              }\n            });\n            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n            if (options.quality == \"draft\") {\n              spectralResult.forEach(function (result, index) {\n                var newXCoords = result.xCoords.map(function (x) {\n                  return x + shiftResult[index].dx;\n                });\n                var newYCoords = result.yCoords.map(function (y) {\n                  return y + shiftResult[index].dy;\n                });\n                result.xCoords = newXCoords;\n                result.yCoords = newYCoords;\n              });\n            } else {\n              var _count = 0;\n              componentsEvaluated.forEach(function (index) {\n                Object.keys(coseResult[index]).forEach(function (item) {\n                  var nodeRectangle = coseResult[index][item];\n                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                });\n                _count++;\n              });\n            }\n          }\n        }\n      }\n\n      // get each element's calculated position\n      var getPositions = function getPositions(ele, i) {\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n          var pos = void 0;\n          var node = void 0;\n          var theId = ele.data('id');\n          coseResult.forEach(function (result) {\n            if (theId in result) {\n              pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };\n              node = result[theId];\n            }\n          });\n          if (options.nodeDimensionsIncludeLabels) {\n            if (node.labelWidth) {\n              if (node.labelPosHorizontal == \"left\") {\n                pos.x += node.labelWidth / 2;\n              } else if (node.labelPosHorizontal == \"right\") {\n                pos.x -= node.labelWidth / 2;\n              }\n            }\n            if (node.labelHeight) {\n              if (node.labelPosVertical == \"top\") {\n                pos.y += node.labelHeight / 2;\n              } else if (node.labelPosVertical == \"bottom\") {\n                pos.y -= node.labelHeight / 2;\n              }\n            }\n          }\n          if (pos == undefined) pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: pos.x,\n            y: pos.y\n          };\n        } else {\n          var _pos = void 0;\n          spectralResult.forEach(function (result) {\n            var index = result.nodeIndexes.get(ele.id());\n            if (index != undefined) {\n              _pos = { x: result.xCoords[index], y: result.yCoords[index] };\n            }\n          });\n          if (_pos == undefined) _pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: _pos.x,\n            y: _pos.y\n          };\n        }\n      };\n\n      // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n      if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n        // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n        var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n        var _hiddenEles = eles.filter(function (ele) {\n          return ele.css('display') == 'none';\n        });\n        options.eles = eles.not(_hiddenEles);\n\n        eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n\n        if (parentsWithoutChildren.length > 0) {\n          parentsWithoutChildren.forEach(function (ele) {\n            ele.position(getPositions(ele));\n          });\n        }\n      } else {\n        console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n\n/***/ 657:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_41986__) => {\n\n\n\n/**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/\n\nvar aux = __nested_webpack_require_41986__(548);\nvar Matrix = __nested_webpack_require_41986__(140).layoutBase.Matrix;\nvar SVD = __nested_webpack_require_41986__(140).layoutBase.SVD;\n\n// main function that spectral layout is processed\nvar spectralLayout = function spectralLayout(options) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var parentNodes = eles.nodes(\":parent\");\n\n  var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n  var nodeIndexes = new Map(); // map to keep indexes to nodes\n  var parentChildMap = new Map(); // mapping btw. compound and its representative node \n  var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n  var xCoords = [];\n  var yCoords = [];\n\n  var samplesColumn = []; // sampled vertices\n  var minDistancesColumn = [];\n  var C = []; // column sampling matrix\n  var PHI = []; // intersection of column and row sampling matrices \n  var INV = []; // inverse of PHI \n\n  var firstSample = void 0; // the first sampled node\n  var nodeSize = void 0;\n\n  var infinity = 100000000;\n  var small = 0.000000001;\n\n  var piTol = options.piTol;\n  var samplingType = options.samplingType; // false for random, true for greedy\n  var nodeSeparation = options.nodeSeparation;\n  var sampleSize = void 0;\n\n  /**** Spectral-preprocessing functions ****/\n\n  /**** Spectral layout functions ****/\n\n  // determine which columns to be sampled\n  var randomSampleCR = function randomSampleCR() {\n    var sample = 0;\n    var count = 0;\n    var flag = false;\n\n    while (count < sampleSize) {\n      sample = Math.floor(Math.random() * nodeSize);\n\n      flag = false;\n      for (var i = 0; i < count; i++) {\n        if (samplesColumn[i] == sample) {\n          flag = true;\n          break;\n        }\n      }\n\n      if (!flag) {\n        samplesColumn[count] = sample;\n        count++;\n      } else {\n        continue;\n      }\n    }\n  };\n\n  // takes the index of the node(pivot) to initiate BFS as a parameter\n  var BFS = function BFS(pivot, index, samplingMethod) {\n    var path = []; // the front of the path\n    var front = 0; // the back of the path\n    var back = 0;\n    var current = 0;\n    var temp = void 0;\n    var distance = [];\n\n    var max_dist = 0; // the furthest node to be returned\n    var max_ind = 1;\n\n    for (var i = 0; i < nodeSize; i++) {\n      distance[i] = infinity;\n    }\n\n    path[back] = pivot;\n    distance[pivot] = 0;\n\n    while (back >= front) {\n      current = path[front++];\n      var neighbors = allNodesNeighborhood[current];\n      for (var _i = 0; _i < neighbors.length; _i++) {\n        temp = nodeIndexes.get(neighbors[_i]);\n        if (distance[temp] == infinity) {\n          distance[temp] = distance[current] + 1;\n          path[++back] = temp;\n        }\n      }\n      C[current][index] = distance[current] * nodeSeparation;\n    }\n\n    if (samplingMethod) {\n      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n        if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n      }\n\n      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n        if (minDistancesColumn[_i3] > max_dist) {\n          max_dist = minDistancesColumn[_i3];\n          max_ind = _i3;\n        }\n      }\n    }\n    return max_ind;\n  };\n\n  // apply BFS to all nodes or selected samples\n  var allBFS = function allBFS(samplingMethod) {\n\n    var sample = void 0;\n\n    if (!samplingMethod) {\n      randomSampleCR();\n\n      // call BFS\n      for (var i = 0; i < sampleSize; i++) {\n        BFS(samplesColumn[i], i, samplingMethod, false);\n      }\n    } else {\n      sample = Math.floor(Math.random() * nodeSize);\n      firstSample = sample;\n\n      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n        minDistancesColumn[_i4] = infinity;\n      }\n\n      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n        samplesColumn[_i5] = sample;\n        sample = BFS(sample, _i5, samplingMethod);\n      }\n    }\n\n    // form the squared distances for C\n    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n      for (var j = 0; j < sampleSize; j++) {\n        C[_i6][j] *= C[_i6][j];\n      }\n    }\n\n    // form PHI\n    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n      PHI[_i7] = [];\n    }\n\n    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n      for (var _j = 0; _j < sampleSize; _j++) {\n        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n      }\n    }\n  };\n\n  // perform the SVD algorithm and apply a regularization step\n  var sample = function sample() {\n\n    var SVDResult = SVD.svd(PHI);\n\n    var a_q = SVDResult.S;\n    var a_u = SVDResult.U;\n    var a_v = SVDResult.V;\n\n    var max_s = a_q[0] * a_q[0] * a_q[0];\n\n    var a_Sig = [];\n\n    //  regularization\n    for (var i = 0; i < sampleSize; i++) {\n      a_Sig[i] = [];\n      for (var j = 0; j < sampleSize; j++) {\n        a_Sig[i][j] = 0;\n        if (i == j) {\n          a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n        }\n      }\n    }\n\n    INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n  };\n\n  // calculate final coordinates \n  var powerIteration = function powerIteration() {\n    // two largest eigenvalues\n    var theta1 = void 0;\n    var theta2 = void 0;\n\n    // initial guesses for eigenvectors\n    var Y1 = [];\n    var Y2 = [];\n\n    var V1 = [];\n    var V2 = [];\n\n    for (var i = 0; i < nodeSize; i++) {\n      Y1[i] = Math.random();\n      Y2[i] = Math.random();\n    }\n\n    Y1 = Matrix.normalize(Y1);\n    Y2 = Matrix.normalize(Y2);\n\n    var count = 0;\n    // to keep track of the improvement ratio in power iteration\n    var current = small;\n    var previous = small;\n\n    var temp = void 0;\n\n    while (true) {\n      count++;\n\n      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n        V1[_i9] = Y1[_i9];\n      }\n\n      Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n      theta1 = Matrix.dotProduct(V1, Y1);\n      Y1 = Matrix.normalize(Y1);\n\n      current = Matrix.dotProduct(V1, Y1);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n      V1[_i10] = Y1[_i10];\n    }\n\n    count = 0;\n    previous = small;\n    while (true) {\n      count++;\n\n      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n        V2[_i11] = Y2[_i11];\n      }\n\n      V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n      Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n      theta2 = Matrix.dotProduct(V2, Y2);\n      Y2 = Matrix.normalize(Y2);\n\n      current = Matrix.dotProduct(V2, Y2);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n      V2[_i12] = Y2[_i12];\n    }\n\n    // theta1 now contains dominant eigenvalue\n    // theta2 now contains the second-largest eigenvalue\n    // V1 now contains theta1's eigenvector\n    // V2 now contains theta2's eigenvector\n\n    //populate the two vectors\n    xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n    yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n  };\n\n  /**** Preparation for spectral layout (Preprocessing) ****/\n\n  // connect disconnected components (first top level, then inside of each compound node)\n  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n\n  parentNodes.forEach(function (ele) {\n    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n  });\n\n  // assign indexes to nodes (first real, then dummy nodes)\n  var index = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    if (!nodes[i].isParent()) {\n      nodeIndexes.set(nodes[i].id(), index++);\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      nodeIndexes.set(key, index++);\n    }\n\n    // instantiate the neighborhood matrix\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n    allNodesNeighborhood[_i13] = [];\n  }\n\n  // form a parent-child map to keep representative node of each compound node  \n  parentNodes.forEach(function (ele) {\n    var children = ele.children().intersection(eles);\n\n    //      let random = 0;\n    while (children.nodes(\":childless\").length == 0) {\n      //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n      children = children.nodes()[0].children().intersection(eles);\n    }\n    //  select the representative node - we can apply different methods here\n    //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n    var index = 0;\n    var min = children.nodes(\":childless\")[0].connectedEdges().length;\n    children.nodes(\":childless\").forEach(function (ele2, i) {\n      if (ele2.connectedEdges().length < min) {\n        min = ele2.connectedEdges().length;\n        index = i;\n      }\n    });\n    parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n  });\n\n  // add neighborhood relations (first real, then dummy nodes)\n  nodes.forEach(function (ele) {\n    var eleIndex = void 0;\n\n    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n\n    ele.neighborhood().nodes().forEach(function (node) {\n      if (eles.intersection(ele.edgesWith(node)).length > 0) {\n        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n      }\n    });\n  });\n\n  var _loop = function _loop(_key) {\n    var eleIndex = nodeIndexes.get(_key);\n    var disconnectedId = void 0;\n    dummyNodes.get(_key).forEach(function (id) {\n      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n\n      allNodesNeighborhood[eleIndex].push(disconnectedId);\n      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n    });\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      _loop(_key);\n    }\n\n    // nodeSize now only considers the size of transformed graph\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  nodeSize = nodeIndexes.size;\n\n  var spectralResult = void 0;\n\n  // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n  // So skip spectral and layout the graph with cose\n  if (nodeSize > 2) {\n    // if # of nodes in transformed graph is smaller than sample size,\n    // then use # of nodes as sample size\n    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n    // instantiates the partial matrices that will be used in spectral layout\n    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n      C[_i14] = [];\n    }\n    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n      INV[_i15] = [];\n    }\n\n    /**** Apply spectral layout ****/\n\n    if (options.quality == \"draft\" || options.step == \"all\") {\n      allBFS(samplingType);\n      sample();\n      powerIteration();\n\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    } else {\n      nodeIndexes.forEach(function (value, key) {\n        xCoords.push(cy.getElementById(key).position(\"x\"));\n        yCoords.push(cy.getElementById(key).position(\"y\"));\n      });\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    }\n    return spectralResult;\n  } else {\n    var iterator = nodeIndexes.keys();\n    var firstNode = cy.getElementById(iterator.next().value);\n    var firstNodePos = firstNode.position();\n    var firstNodeWidth = firstNode.outerWidth();\n    xCoords.push(firstNodePos.x);\n    yCoords.push(firstNodePos.y);\n    if (nodeSize == 2) {\n      var secondNode = cy.getElementById(iterator.next().value);\n      var secondNodeWidth = secondNode.outerWidth();\n      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n      yCoords.push(firstNodePos.y);\n    }\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  }\n};\n\nmodule.exports = { spectralLayout: spectralLayout };\n\n/***/ }),\n\n/***/ 579:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_55337__) => {\n\n\n\nvar impl = __nested_webpack_require_55337__(212);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n\n/***/ 140:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_56127__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_56127__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_56127__(579);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2N5dG9zY2FwZS1mY29zZUAyLjIuMF9jeXRvc2NhcGVAMy4zMy4xL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUtZmNvc2UvY3l0b3NjYXBlLWZjb3NlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyxxR0FBVztBQUM5QyxNQUFNLEVBSytDO0FBQ3JELENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7O0FBRUE7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7Ozs7QUFJN0QsbUNBQW1DLGlDQUFpQyxlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsdUNBQXVDLGNBQWMsV0FBVyxZQUFZLFVBQVUsTUFBTSwyQ0FBMkMsVUFBVSxzQkFBc0IsZUFBZSwyQkFBMkIsMEJBQTBCLGNBQWMsMkNBQTJDLGdDQUFnQyxPQUFPLG1GQUFtRjs7QUFFcnBCO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsK0JBQW1COztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0NBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBbUIsR0FBRyxnQ0FBbUI7QUFDdkQ7QUFDQSxpQkFBaUIsMEJBQW1CO0FBQ3BDLFVBQVU7QUFDVjtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9FYm9vdGgvYWdlbnRfY19mcmFtZXdvcmsvc3JjL3JlYWx0aW1lX2NsaWVudC9ub2RlX21vZHVsZXMvLnBucG0vY3l0b3NjYXBlLWZjb3NlQDIuMi4wX2N5dG9zY2FwZUAzLjMzLjEvbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1mY29zZS9jeXRvc2NhcGUtZmNvc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiY29zZS1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImNvc2UtYmFzZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjeXRvc2NhcGVGY29zZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY3l0b3NjYXBlRmNvc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJjb3NlQmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNDBfXykge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNjU4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5cbi8vIFNpbXBsZSwgaW50ZXJuYWwgT2JqZWN0LmFzc2lnbigpIHBvbHlmaWxsIGZvciBvcHRpb25zIG9iamVjdHMgZXRjLlxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3JjcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzcmNzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHNyY3MuZm9yRWFjaChmdW5jdGlvbiAoc3JjKSB7XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICByZXR1cm4gdGd0W2tdID0gc3JjW2tdO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGd0O1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU0ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuLypcbiAqIEF1eGlsaWFyeSBmdW5jdGlvbnNcbiAqL1xuXG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLkxpbmtlZExpc3Q7XG5cbnZhciBhdXhpbGlhcnkgPSB7fTtcblxuLy8gZ2V0IHRoZSB0b3AgbW9zdCBub2Rlc1xuYXV4aWxpYXJ5LmdldFRvcE1vc3ROb2RlcyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbm9kZXNNYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGVzTWFwW25vZGVzW2ldLmlkKCldID0gdHJ1ZTtcbiAgfVxuICB2YXIgcm9vdHMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBlbGUgPSBpO1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gZWxlLnBhcmVudCgpWzBdO1xuICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGVzTWFwW3BhcmVudC5pZCgpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KClbMF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gcm9vdHM7XG59O1xuXG4vLyBmaW5kIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIGFuZCBjcmVhdGUgZHVtbXkgbm9kZXMgdGhhdCBjb25uZWN0IHRoZW1cbmF1eGlsaWFyeS5jb25uZWN0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdG9wTW9zdE5vZGVzLCBkdW1teU5vZGVzKSB7XG4gIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgdmlzaXRlZFRvcE1vc3ROb2RlcyA9IFtdO1xuICB2YXIgY3VycmVudE5laWdoYm9yID0gdm9pZCAwO1xuICB2YXIgbWluRGVncmVlTm9kZSA9IHZvaWQgMDtcbiAgdmFyIG1pbkRlZ3JlZSA9IHZvaWQgMDtcblxuICB2YXIgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgdmFyIGNvdW50ID0gMTtcbiAgdmFyIG5vZGVzQ29ubmVjdGVkVG9EdW1teSA9IFtdO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBjbXB0ID0gY3kuY29sbGVjdGlvbigpO1xuICAgIGNvbXBvbmVudHMucHVzaChjbXB0KTtcblxuICAgIHZhciBjdXJyZW50Tm9kZSA9IHRvcE1vc3ROb2Rlc1swXTtcbiAgICB2YXIgY2hpbGRyZW5PZkN1cnJlbnROb2RlID0gY3kuY29sbGVjdGlvbigpO1xuICAgIGNoaWxkcmVuT2ZDdXJyZW50Tm9kZS5tZXJnZShjdXJyZW50Tm9kZSkubWVyZ2UoY3VycmVudE5vZGUuZGVzY2VuZGFudHMoKS5pbnRlcnNlY3Rpb24oZWxlcykpO1xuICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMucHVzaChjdXJyZW50Tm9kZSk7XG5cbiAgICBjaGlsZHJlbk9mQ3VycmVudE5vZGUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgY21wdC5tZXJnZShub2RlKTtcbiAgICB9KTtcblxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgICB2YXIgbmVpZ2hib3JOb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGN1cnJlbnROb2RlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoZWxlcy5pbnRlcnNlY3Rpb24oY3VycmVudE5vZGUuZWRnZXNXaXRoKG5vZGUpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbmVpZ2hib3JOb2Rlcy5tZXJnZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcbiAgICAgICAgY3VycmVudE5laWdoYm9yID0gdG9wTW9zdE5vZGVzLmludGVyc2VjdGlvbihuZWlnaGJvck5vZGUudW5pb24obmVpZ2hib3JOb2RlLmFuY2VzdG9ycygpKSk7XG4gICAgICAgIGlmIChjdXJyZW50TmVpZ2hib3IgIT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yWzBdKSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk9mTmVpZ2hib3IgPSBjdXJyZW50TmVpZ2hib3IudW5pb24oY3VycmVudE5laWdoYm9yLmRlc2NlbmRhbnRzKCkpO1xuXG4gICAgICAgICAgY2hpbGRyZW5PZk5laWdoYm9yLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgICAgICAgIGNtcHQubWVyZ2Uobm9kZSk7XG4gICAgICAgICAgICBpZiAodG9wTW9zdE5vZGVzLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICBfbG9vcDIoKTtcbiAgICB9XG5cbiAgICBjbXB0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGVsZXMuaW50ZXJzZWN0aW9uKG5vZGUuY29ubmVjdGVkRWRnZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBjb25uZWN0ZWRFZGdlcygpIHVzdWFsbHkgY2FjaGVkXG4gICAgICAgIGlmIChjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgIC8vIGhhcygpIGlzIGNoZWFwXG4gICAgICAgICAgY21wdC5tZXJnZShlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAodmlzaXRlZFRvcE1vc3ROb2Rlcy5sZW5ndGggPT0gdG9wTW9zdE5vZGVzLmxlbmd0aCkge1xuICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaXNDb25uZWN0ZWQgfHwgaXNDb25uZWN0ZWQgJiYgY291bnQgPiAxKSB7XG4gICAgICBtaW5EZWdyZWVOb2RlID0gdmlzaXRlZFRvcE1vc3ROb2Rlc1swXTtcbiAgICAgIG1pbkRlZ3JlZSA9IG1pbkRlZ3JlZU5vZGUuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGggPCBtaW5EZWdyZWUpIHtcbiAgICAgICAgICBtaW5EZWdyZWUgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgICAgICAgIG1pbkRlZ3JlZU5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5vZGVzQ29ubmVjdGVkVG9EdW1teS5wdXNoKG1pbkRlZ3JlZU5vZGUuaWQoKSk7XG4gICAgICAvLyBUTyBETzogQ2hlY2sgZWZmaWNpZW5jeSBvZiB0aGlzIHBhcnRcbiAgICAgIHZhciB0ZW1wID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgdGVtcC5tZXJnZSh2aXNpdGVkVG9wTW9zdE5vZGVzWzBdKTtcbiAgICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0ZW1wLm1lcmdlKG5vZGUpO1xuICAgICAgfSk7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzID0gW107XG4gICAgICB0b3BNb3N0Tm9kZXMgPSB0b3BNb3N0Tm9kZXMuZGlmZmVyZW5jZSh0ZW1wKTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9O1xuXG4gIGRvIHtcbiAgICBfbG9vcCgpO1xuICB9IHdoaWxlICghaXNDb25uZWN0ZWQpO1xuXG4gIGlmIChkdW1teU5vZGVzKSB7XG4gICAgaWYgKG5vZGVzQ29ubmVjdGVkVG9EdW1teS5sZW5ndGggPiAwKSB7XG4gICAgICBkdW1teU5vZGVzLnNldCgnZHVtbXknICsgKGR1bW15Tm9kZXMuc2l6ZSArIDEpLCBub2Rlc0Nvbm5lY3RlZFRvRHVtbXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50cztcbn07XG5cbi8vIHJlbG9jYXRlcyBjb21wb25lbnRSZXN1bHQgdG8gb3JpZ2luYWxDZW50ZXIgaWYgdGhlcmUgaXMgbm8gZml4ZWROb2RlQ29uc3RyYWludFxuYXV4aWxpYXJ5LnJlbG9jYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKG9yaWdpbmFsQ2VudGVyLCBjb21wb25lbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICB2YXIgbWluWENvb3JkID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBtYXhYQ29vcmQgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1pbllDb29yZCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4WUNvb3JkID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBjb21wb25lbnRSZXN1bHQubm9kZUluZGV4ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG4gICAgICAgICAgdmFyIGtleSA9IF9yZWYyWzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgdmFyIGN5Tm9kZSA9IG9wdGlvbnMuY3kuZ2V0RWxlbWVudEJ5SWQoa2V5KTtcbiAgICAgICAgICBpZiAoY3lOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUJCID0gY3lOb2RlLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB2YXIgbGVmdFggPSBjb21wb25lbnRSZXN1bHQueENvb3Jkc1t2YWx1ZV0gLSBub2RlQkIudyAvIDI7XG4gICAgICAgICAgICB2YXIgcmlnaHRYID0gY29tcG9uZW50UmVzdWx0LnhDb29yZHNbdmFsdWVdICsgbm9kZUJCLncgLyAyO1xuICAgICAgICAgICAgdmFyIHRvcFkgPSBjb21wb25lbnRSZXN1bHQueUNvb3Jkc1t2YWx1ZV0gLSBub2RlQkIuaCAvIDI7XG4gICAgICAgICAgICB2YXIgYm90dG9tWSA9IGNvbXBvbmVudFJlc3VsdC55Q29vcmRzW3ZhbHVlXSArIG5vZGVCQi5oIC8gMjtcblxuICAgICAgICAgICAgaWYgKGxlZnRYIDwgbWluWENvb3JkKSBtaW5YQ29vcmQgPSBsZWZ0WDtcbiAgICAgICAgICAgIGlmIChyaWdodFggPiBtYXhYQ29vcmQpIG1heFhDb29yZCA9IHJpZ2h0WDtcbiAgICAgICAgICAgIGlmICh0b3BZIDwgbWluWUNvb3JkKSBtaW5ZQ29vcmQgPSB0b3BZO1xuICAgICAgICAgICAgaWYgKGJvdHRvbVkgPiBtYXhZQ29vcmQpIG1heFlDb29yZCA9IGJvdHRvbVk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIG9yaWdpbmFsIGNlbnRlclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkaWZmT25YID0gb3JpZ2luYWxDZW50ZXIueCAtIChtYXhYQ29vcmQgKyBtaW5YQ29vcmQpIC8gMjtcbiAgICAgIHZhciBkaWZmT25ZID0gb3JpZ2luYWxDZW50ZXIueSAtIChtYXhZQ29vcmQgKyBtaW5ZQ29vcmQpIC8gMjtcbiAgICAgIC8vIG1vdmUgY29tcG9uZW50IHRvIG9yaWdpbmFsIGNlbnRlclxuICAgICAgY29tcG9uZW50UmVzdWx0LnhDb29yZHMgPSBjb21wb25lbnRSZXN1bHQueENvb3Jkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggKyBkaWZmT25YO1xuICAgICAgfSk7XG4gICAgICBjb21wb25lbnRSZXN1bHQueUNvb3JkcyA9IGNvbXBvbmVudFJlc3VsdC55Q29vcmRzLm1hcChmdW5jdGlvbiAoeSkge1xuICAgICAgICByZXR1cm4geSArIGRpZmZPblk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2FsY3VsYXRlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgICBPYmplY3Qua2V5cyhjb21wb25lbnRSZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRSZXN1bHRbaXRlbV07XG4gICAgICAgIHZhciBsZWZ0WCA9IG5vZGUuZ2V0UmVjdCgpLng7XG4gICAgICAgIHZhciByaWdodFggPSBub2RlLmdldFJlY3QoKS54ICsgbm9kZS5nZXRSZWN0KCkud2lkdGg7XG4gICAgICAgIHZhciB0b3BZID0gbm9kZS5nZXRSZWN0KCkueTtcbiAgICAgICAgdmFyIGJvdHRvbVkgPSBub2RlLmdldFJlY3QoKS55ICsgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0O1xuXG4gICAgICAgIGlmIChsZWZ0WCA8IG1pblhDb29yZCkgbWluWENvb3JkID0gbGVmdFg7XG4gICAgICAgIGlmIChyaWdodFggPiBtYXhYQ29vcmQpIG1heFhDb29yZCA9IHJpZ2h0WDtcbiAgICAgICAgaWYgKHRvcFkgPCBtaW5ZQ29vcmQpIG1pbllDb29yZCA9IHRvcFk7XG4gICAgICAgIGlmIChib3R0b21ZID4gbWF4WUNvb3JkKSBtYXhZQ29vcmQgPSBib3R0b21ZO1xuICAgICAgfSk7XG4gICAgICAvLyBmaW5kIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBvcmlnaW5hbCBjZW50ZXJcbiAgICAgIHZhciBfZGlmZk9uWCA9IG9yaWdpbmFsQ2VudGVyLnggLSAobWF4WENvb3JkICsgbWluWENvb3JkKSAvIDI7XG4gICAgICB2YXIgX2RpZmZPblkgPSBvcmlnaW5hbENlbnRlci55IC0gKG1heFlDb29yZCArIG1pbllDb29yZCkgLyAyO1xuICAgICAgLy8gbW92ZSBjb21wb25lbnQgdG8gb3JpZ2luYWwgY2VudGVyXG4gICAgICBPYmplY3Qua2V5cyhjb21wb25lbnRSZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRSZXN1bHRbaXRlbV07XG4gICAgICAgIG5vZGUuc2V0Q2VudGVyKG5vZGUuZ2V0Q2VudGVyWCgpICsgX2RpZmZPblgsIG5vZGUuZ2V0Q2VudGVyWSgpICsgX2RpZmZPblkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuXG5hdXhpbGlhcnkuY2FsY0JvdW5kaW5nQm94ID0gZnVuY3Rpb24gKHBhcmVudE5vZGUsIHhDb29yZHMsIHlDb29yZHMsIG5vZGVJbmRleGVzKSB7XG4gIC8vIGNhbGN1bGF0ZSBib3VuZHNcbiAgdmFyIGxlZnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIHJpZ2h0ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gIHZhciB0b3AgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIGJvdHRvbSA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICB2YXIgbm9kZUxlZnQgPSB2b2lkIDA7XG4gIHZhciBub2RlUmlnaHQgPSB2b2lkIDA7XG4gIHZhciBub2RlVG9wID0gdm9pZCAwO1xuICB2YXIgbm9kZUJvdHRvbSA9IHZvaWQgMDtcblxuICB2YXIgbm9kZXMgPSBwYXJlbnROb2RlLmRlc2NlbmRhbnRzKCkubm90KFwiOnBhcmVudFwiKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIG5vZGVMZWZ0ID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gLSBub2RlLndpZHRoKCkgLyAyO1xuICAgIG5vZGVSaWdodCA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldICsgbm9kZS53aWR0aCgpIC8gMjtcbiAgICBub2RlVG9wID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gLSBub2RlLmhlaWdodCgpIC8gMjtcbiAgICBub2RlQm90dG9tID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gKyBub2RlLmhlaWdodCgpIC8gMjtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ0JveCA9IHt9O1xuICBib3VuZGluZ0JveC50b3BMZWZ0WCA9IGxlZnQ7XG4gIGJvdW5kaW5nQm94LnRvcExlZnRZID0gdG9wO1xuICBib3VuZGluZ0JveC53aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgYm91bmRpbmdCb3guaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICByZXR1cm4gYm91bmRpbmdCb3g7XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGZpbmRzIGFuZCByZXR1cm5zIHBhcmVudCBub2RlcyB3aG9zZSBhbGwgY2hpbGRyZW4gYXJlIGhpZGRlblxuYXV4aWxpYXJ5LmNhbGNQYXJlbnRzV2l0aG91dENoaWxkcmVuID0gZnVuY3Rpb24gKGN5LCBlbGVzKSB7XG4gIHZhciBwYXJlbnRzV2l0aG91dENoaWxkcmVuID0gY3kuY29sbGVjdGlvbigpO1xuICBlbGVzLm5vZGVzKCc6cGFyZW50JykuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgdmFyIGNoZWNrID0gZmFsc2U7XG4gICAgcGFyZW50LmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5jc3MoJ2Rpc3BsYXknKSAhPSAnbm9uZScpIHtcbiAgICAgICAgY2hlY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4ubWVyZ2UocGFyZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJlbnRzV2l0aG91dENoaWxkcmVuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhdXhpbGlhcnk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG4vKipcbiAgVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwb3N0cHJvY2Vzc2luZyBwYXJ0IHRoYXQgYXBwbGllcyBDb1NFIGxheW91dCBvdmVyIHRoZSBzcGVjdHJhbCBsYXlvdXRcbiovXG5cbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG52YXIgQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5Db1NFTGF5b3V0O1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLkNvU0VOb2RlO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLlBvaW50RDtcbnZhciBEaW1lbnNpb25EID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuRGltZW5zaW9uRDtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5MYXlvdXRDb25zdGFudHM7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5GRExheW91dENvbnN0YW50cztcbnZhciBDb1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLkNvU0VDb25zdGFudHM7XG5cbi8vIG1haW4gZnVuY3Rpb24gdGhhdCBjb3NlIGxheW91dCBpcyBwcm9jZXNzZWRcbnZhciBjb3NlTGF5b3V0ID0gZnVuY3Rpb24gY29zZUxheW91dChvcHRpb25zLCBzcGVjdHJhbFJlc3VsdCkge1xuXG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcblxuICB2YXIgbm9kZUluZGV4ZXMgPSB2b2lkIDA7XG4gIHZhciB4Q29vcmRzID0gdm9pZCAwO1xuICB2YXIgeUNvb3JkcyA9IHZvaWQgMDtcbiAgdmFyIGlkVG9MTm9kZSA9IHt9O1xuXG4gIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIG5vZGVJbmRleGVzID0gc3BlY3RyYWxSZXN1bHRbXCJub2RlSW5kZXhlc1wiXTtcbiAgICB4Q29vcmRzID0gc3BlY3RyYWxSZXN1bHRbXCJ4Q29vcmRzXCJdO1xuICAgIHlDb29yZHMgPSBzcGVjdHJhbFJlc3VsdFtcInlDb29yZHNcIl07XG4gIH1cblxuICB2YXIgaXNGbiA9IGZ1bmN0aW9uIGlzRm4oZm4pIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nO1xuICB9O1xuXG4gIHZhciBvcHRGbiA9IGZ1bmN0aW9uIG9wdEZuKG9wdCwgZWxlKSB7XG4gICAgaWYgKGlzRm4ob3B0KSkge1xuICAgICAgcmV0dXJuIG9wdChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0O1xuICAgIH1cbiAgfTtcblxuICAvKioqKiBQb3N0cHJvY2Vzc2luZyBmdW5jdGlvbnMgKioqKi9cblxuICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGF1eC5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbihjeSwgZWxlcyk7XG5cbiAgLy8gdHJhbnNmZXIgY3l0b3NjYXBlIG5vZGVzIHRvIGNvc2Ugbm9kZXNcbiAgdmFyIHByb2Nlc3NDaGlsZHJlbkxpc3QgPSBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRyZW5MaXN0KHBhcmVudCwgY2hpbGRyZW4sIGxheW91dCwgb3B0aW9ucykge1xuICAgIHZhciBzaXplID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBjaGlsZHJlbl9vZl9jaGlsZHJlbiA9IG51bGw7XG4gICAgICBpZiAodGhlQ2hpbGQuaW50ZXJzZWN0aW9uKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNoaWxkcmVuX29mX2NoaWxkcmVuID0gdGhlQ2hpbGQuY2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGVOb2RlID0gdm9pZCAwO1xuXG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoZUNoaWxkLmxheW91dERpbWVuc2lvbnMoe1xuICAgICAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoZUNoaWxkLm91dGVyV2lkdGgoKSAhPSBudWxsICYmIHRoZUNoaWxkLm91dGVySGVpZ2h0KCkgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgICBpZiAoIXRoZUNoaWxkLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHRoZUNoaWxkLmlkKCkpXSAtIGRpbWVuc2lvbnMudyAvIDIsIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHRoZUNoaWxkLmlkKCkpXSAtIGRpbWVuc2lvbnMuaCAvIDIpLCBuZXcgRGltZW5zaW9uRChwYXJzZUZsb2F0KGRpbWVuc2lvbnMudyksIHBhcnNlRmxvYXQoZGltZW5zaW9ucy5oKSkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcmVudEluZm8gPSBhdXguY2FsY0JvdW5kaW5nQm94KHRoZUNoaWxkLCB4Q29vcmRzLCB5Q29vcmRzLCBub2RlSW5kZXhlcyk7XG4gICAgICAgICAgICBpZiAodGhlQ2hpbGQuaW50ZXJzZWN0aW9uKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHBhcmVudEluZm8udG9wTGVmdFgsIHBhcmVudEluZm8udG9wTGVmdFkpLCBuZXcgRGltZW5zaW9uRChwYXJlbnRJbmZvLndpZHRoLCBwYXJlbnRJbmZvLmhlaWdodCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGZvciB0aGUgcGFyZW50c1dpdGhvdXRDaGlsZHJlblxuICAgICAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RChwYXJlbnRJbmZvLnRvcExlZnRYLCBwYXJlbnRJbmZvLnRvcExlZnRZKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHRoZUNoaWxkLnBvc2l0aW9uKCd4JykgLSBkaW1lbnNpb25zLncgLyAyLCB0aGVDaGlsZC5wb3NpdGlvbigneScpIC0gZGltZW5zaW9ucy5oIC8gMiksIG5ldyBEaW1lbnNpb25EKHBhcnNlRmxvYXQoZGltZW5zaW9ucy53KSwgcGFyc2VGbG9hdChkaW1lbnNpb25zLmgpKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUodGhpcy5ncmFwaE1hbmFnZXIpKTtcbiAgICAgIH1cbiAgICAgIC8vIEF0dGFjaCBpZCB0byB0aGUgbGF5b3V0IG5vZGUgYW5kIHJlcHVsc2lvbiB2YWx1ZVxuICAgICAgdGhlTm9kZS5pZCA9IHRoZUNoaWxkLmRhdGEoXCJpZFwiKTtcbiAgICAgIHRoZU5vZGUubm9kZVJlcHVsc2lvbiA9IG9wdEZuKG9wdGlvbnMubm9kZVJlcHVsc2lvbiwgdGhlQ2hpbGQpO1xuICAgICAgLy8gQXR0YWNoIHRoZSBwYWRkaW5ncyBvZiBjeSBub2RlIHRvIGxheW91dCBub2RlXG4gICAgICB0aGVOb2RlLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nVG9wID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nUmlnaHQgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgICB0aGVOb2RlLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG5cbiAgICAgIC8vQXR0YWNoIHRoZSBsYWJlbCBwcm9wZXJ0aWVzIHRvIGJvdGggY29tcG91bmQgYW5kIHNpbXBsZSBub2RlcyBpZiBsYWJlbHMgd2lsbCBiZSBpbmNsdWRlZCBpbiBub2RlIGRpbWVuc2lvbnNcbiAgICAgIC8vVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgd2hpbGUgdXBkYXRpbmcgYm91bmRzIG9mIGNvbXBvdW5kcyBkdXJpbmcgaXRlcmF0aW9ucyBvciB0aWxpbmdcbiAgICAgIC8vYW5kIHdpbGwgYmUgdXNlZCBmb3Igc2ltcGxlIG5vZGVzIHdoaWxlIHRyYW5zZmVycmluZyBmaW5hbCBwb3NpdGlvbnMgdG8gY3l0b3NjYXBlXG4gICAgICBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFdpZHRoID0gdGhlQ2hpbGQuYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiB0cnVlLCBpbmNsdWRlTm9kZXM6IGZhbHNlLCBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlIH0pLnc7XG4gICAgICAgIHRoZU5vZGUubGFiZWxIZWlnaHQgPSB0aGVDaGlsZC5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IHRydWUsIGluY2x1ZGVOb2RlczogZmFsc2UsIGluY2x1ZGVPdmVybGF5czogZmFsc2UgfSkuaDtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID0gdGhlQ2hpbGQuY3NzKFwidGV4dC12YWxpZ25cIik7XG4gICAgICAgIHRoZU5vZGUubGFiZWxQb3NIb3Jpem9udGFsID0gdGhlQ2hpbGQuY3NzKFwidGV4dC1oYWxpZ25cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcCB0aGUgbGF5b3V0IG5vZGVcbiAgICAgIGlkVG9MTm9kZVt0aGVDaGlsZC5kYXRhKFwiaWRcIildID0gdGhlTm9kZTtcblxuICAgICAgaWYgKGlzTmFOKHRoZU5vZGUucmVjdC54KSkge1xuICAgICAgICB0aGVOb2RlLnJlY3QueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueSkpIHtcbiAgICAgICAgdGhlTm9kZS5yZWN0LnkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGRyZW5fb2ZfY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbl9vZl9jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0aGVOZXdHcmFwaCA9IHZvaWQgMDtcbiAgICAgICAgdGhlTmV3R3JhcGggPSBsYXlvdXQuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKGxheW91dC5uZXdHcmFwaCgpLCB0aGVOb2RlKTtcbiAgICAgICAgcHJvY2Vzc0NoaWxkcmVuTGlzdCh0aGVOZXdHcmFwaCwgY2hpbGRyZW5fb2ZfY2hpbGRyZW4sIGxheW91dCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHRyYW5zZmVyIGN5dG9zY2FwZSBlZGdlcyB0byBjb3NlIGVkZ2VzXG4gIHZhciBwcm9jZXNzRWRnZXMgPSBmdW5jdGlvbiBwcm9jZXNzRWRnZXMobGF5b3V0LCBnbSwgZWRnZXMpIHtcbiAgICB2YXIgaWRlYWxMZW5ndGhUb3RhbCA9IDA7XG4gICAgdmFyIGVkZ2VDb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBzb3VyY2VOb2RlID0gaWRUb0xOb2RlW2VkZ2UuZGF0YShcInNvdXJjZVwiKV07XG4gICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGlkVG9MTm9kZVtlZGdlLmRhdGEoXCJ0YXJnZXRcIildO1xuICAgICAgaWYgKHNvdXJjZU5vZGUgJiYgdGFyZ2V0Tm9kZSAmJiBzb3VyY2VOb2RlICE9PSB0YXJnZXROb2RlICYmIHNvdXJjZU5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHRhcmdldE5vZGUpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHZhciBlMSA9IGdtLmFkZChsYXlvdXQubmV3RWRnZSgpLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKTtcbiAgICAgICAgZTEuaWQgPSBlZGdlLmlkKCk7XG4gICAgICAgIGUxLmlkZWFsTGVuZ3RoID0gb3B0Rm4ob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgsIGVkZ2UpO1xuICAgICAgICBlMS5lZGdlRWxhc3RpY2l0eSA9IG9wdEZuKG9wdGlvbnMuZWRnZUVsYXN0aWNpdHksIGVkZ2UpO1xuICAgICAgICBpZGVhbExlbmd0aFRvdGFsICs9IGUxLmlkZWFsTGVuZ3RoO1xuICAgICAgICBlZGdlQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgdGhlIGlkZWFsIGVkZ2UgbGVuZ3RoIGNvbnN0YW50IHdpdGggdGhlIGF2Zy4gaWRlYWwgbGVuZ3RoIHZhbHVlIGFmdGVyIHByb2Nlc3NpbmcgZWRnZXNcbiAgICAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UsIHVzZSBvdGhlciBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgIGlmIChlZGdlQ291bnQgPiAwKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gaWRlYWxMZW5ndGhUb3RhbCAvIGVkZ2VDb3VudDtlbHNlIGlmICghaXNGbihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkpIC8vIGluIGNhc2UgdGhlcmUgaXMgbm8gZWRnZSwgYnV0IG9wdGlvbiBnaXZlcyBhIHZhbHVlIHRvIHVzZVxuICAgICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7ZWxzZSAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UgYW5kIHdlIGNhbm5vdCBnZXQgYSB2YWx1ZSBmcm9tIG9wdGlvbiAoYmVjYXVzZSBpdCdzIGEgZnVuY3Rpb24pXG4gICAgICAgIENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSA1MDtcbiAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiYXNlZCBvbiB0aGUgaWRlYWwgZWRnZSBsZW5ndGggY29uc3RhbnRcbiAgICAgIENvU0VDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwLjA7XG4gICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cbiAgfTtcblxuICAvLyB0cmFuc2ZlciBjeXRvc2NhcGUgY29uc3RyYWludHMgdG8gY29zZSBsYXlvdXRcbiAgdmFyIHByb2Nlc3NDb25zdHJhaW50cyA9IGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cyhsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgZml4ZWRcbiAgICBpZiAob3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgICBsYXlvdXQuY29uc3RyYWludHNbXCJmaXhlZE5vZGVDb25zdHJhaW50XCJdID0gb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50O1xuICAgIH1cbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgYWxpZ25lZFxuICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGxheW91dC5jb25zdHJhaW50c1tcImFsaWdubWVudENvbnN0cmFpbnRcIl0gPSBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQ7XG4gICAgfVxuICAgIC8vIGdldCBub2RlcyB0byBiZSByZWxhdGl2ZWx5IHBsYWNlZFxuICAgIGlmIChvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgbGF5b3V0LmNvbnN0cmFpbnRzW1wicmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50XCJdID0gb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKioqIEFwcGx5IHBvc3Rwcm9jZXNzaW5nICoqKiovXG4gIGlmIChvcHRpb25zLm5lc3RpbmdGYWN0b3IgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eTtcbiAgaWYgKG9wdGlvbnMubnVtSXRlciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBvcHRpb25zLm51bUl0ZXI7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2U7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWwgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw7XG5cbiAgaWYgKG9wdGlvbnMudGlsaW5nQ29tcGFyZUJ5ICE9IG51bGwpIENvU0VDb25zdGFudHMuVElMSU5HX0NPTVBBUkVfQlkgPSBvcHRpb25zLnRpbGluZ0NvbXBhcmVCeTtcblxuICBpZiAob3B0aW9ucy5xdWFsaXR5ID09ICdwcm9vZicpIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMjtlbHNlIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMDtcblxuICBDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IEZETGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscztcbiAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gIW9wdGlvbnMucmFuZG9taXplO1xuICBDb1NFQ29uc3RhbnRzLkFOSU1BVEUgPSBGRExheW91dENvbnN0YW50cy5BTklNQVRFID0gTGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBvcHRpb25zLmFuaW1hdGU7XG4gIENvU0VDb25zdGFudHMuVElMRSA9IG9wdGlvbnMudGlsZTtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDtcblxuICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSB0cnVlO1xuICBDb1NFQ29uc3RhbnRzLlBVUkVfSU5DUkVNRU5UQUwgPSAhb3B0aW9ucy5yYW5kb21pemU7XG4gIExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTID0gb3B0aW9ucy51bmlmb3JtTm9kZURpbWVuc2lvbnM7XG5cbiAgLy8gVGhpcyBwYXJ0IGlzIGZvciBkZWJ1Zy9kZW1vIHB1cnBvc2VcbiAgaWYgKG9wdGlvbnMuc3RlcCA9PSBcInRyYW5zZm9ybWVkXCIpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HID0gdHJ1ZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLnN0ZXAgPT0gXCJlbmZvcmNlZFwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiY29zZVwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiYWxsXCIpIHtcbiAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSB0cnVlO2Vsc2UgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQgfHwgb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IHRydWU7XG4gIH1cblxuICB2YXIgY29zZUxheW91dCA9IG5ldyBDb1NFTGF5b3V0KCk7XG4gIHZhciBnbSA9IGNvc2VMYXlvdXQubmV3R3JhcGhNYW5hZ2VyKCk7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuTGlzdChnbS5hZGRSb290KCksIGF1eC5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpLCBjb3NlTGF5b3V0LCBvcHRpb25zKTtcbiAgcHJvY2Vzc0VkZ2VzKGNvc2VMYXlvdXQsIGdtLCBlZGdlcyk7XG4gIHByb2Nlc3NDb25zdHJhaW50cyhjb3NlTGF5b3V0LCBvcHRpb25zKTtcblxuICBjb3NlTGF5b3V0LnJ1bkxheW91dCgpO1xuXG4gIHJldHVybiBpZFRvTE5vZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgY29zZUxheW91dDogY29zZUxheW91dCB9O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjEyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZmNvc2UgbGF5b3V0IGFsZ29yaXRobVxuKi9cblxudmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjU4KTtcbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjU3KSxcbiAgICBzcGVjdHJhbExheW91dCA9IF9yZXF1aXJlLnNwZWN0cmFsTGF5b3V0O1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTYpLFxuICAgIGNvc2VMYXlvdXQgPSBfcmVxdWlyZTIuY29zZUxheW91dDtcblxudmFyIGRlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG5cbiAgLy8gJ2RyYWZ0JywgJ2RlZmF1bHQnIG9yICdwcm9vZicgXG4gIC8vIC0gJ2RyYWZ0JyBvbmx5IGFwcGxpZXMgc3BlY3RyYWwgbGF5b3V0IFxuICAvLyAtICdkZWZhdWx0JyBpbXByb3ZlcyB0aGUgcXVhbGl0eSB3aXRoIHN1YnNlcXVlbnQgQ29TRSBsYXlvdXQgKGZhc3QgY29vbGluZyByYXRlKVxuICAvLyAtICdwcm9vZicgaW1wcm92ZXMgdGhlIHF1YWxpdHkgd2l0aCBzdWJzZXF1ZW50IENvU0UgbGF5b3V0IChzbG93IGNvb2xpbmcgcmF0ZSkgXG4gIHF1YWxpdHk6IFwiZGVmYXVsdFwiLFxuICAvLyBVc2UgcmFuZG9tIG5vZGUgcG9zaXRpb25zIGF0IGJlZ2lubmluZyBvZiBsYXlvdXRcbiAgLy8gaWYgdGhpcyBpcyBzZXQgdG8gZmFsc2UsIHRoZW4gcXVhbGl0eSBvcHRpb24gbXVzdCBiZSBcInByb29mXCJcbiAgcmFuZG9taXplOiB0cnVlLFxuICAvLyBXaGV0aGVyIG9yIG5vdCB0byBhbmltYXRlIHRoZSBsYXlvdXRcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgLy8gRHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zLCBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwLFxuICAvLyBFYXNpbmcgb2YgYW5pbWF0aW9uLCBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBGaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSByZXBvc2l0aW9uZWQgbm9kZXNcbiAgZml0OiB0cnVlLFxuICAvLyBQYWRkaW5nIGFyb3VuZCBsYXlvdXRcbiAgcGFkZGluZzogMzAsXG4gIC8vIFdoZXRoZXIgdG8gaW5jbHVkZSBsYWJlbHMgaW4gbm9kZSBkaW1lbnNpb25zLiBWYWxpZCBpbiBcInByb29mXCIgcXVhbGl0eVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBXaGV0aGVyIG9yIG5vdCBzaW1wbGUgbm9kZXMgKG5vbi1jb21wb3VuZCBub2RlcykgYXJlIG9mIHVuaWZvcm0gZGltZW5zaW9uc1xuICB1bmlmb3JtTm9kZURpbWVuc2lvbnM6IGZhbHNlLFxuICAvLyBXaGV0aGVyIHRvIHBhY2sgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgLSB2YWxpZCBvbmx5IGlmIHJhbmRvbWl6ZTogdHJ1ZVxuICBwYWNrQ29tcG9uZW50czogdHJ1ZSxcbiAgLy8gTGF5b3V0IHN0ZXAgLSBhbGwsIHRyYW5zZm9ybWVkLCBlbmZvcmNlZCwgY29zZSAtIGZvciBkZWJ1ZyBwdXJwb3NlIG9ubHlcbiAgc3RlcDogXCJhbGxcIixcblxuICAvKiBzcGVjdHJhbCBsYXlvdXQgb3B0aW9ucyAqL1xuXG4gIC8vIEZhbHNlIGZvciByYW5kb20sIHRydWUgZm9yIGdyZWVkeVxuICBzYW1wbGluZ1R5cGU6IHRydWUsXG4gIC8vIFNhbXBsZSBzaXplIHRvIGNvbnN0cnVjdCBkaXN0YW5jZSBtYXRyaXhcbiAgc2FtcGxlU2l6ZTogMjUsXG4gIC8vIFNlcGFyYXRpb24gYW1vdW50IGJldHdlZW4gbm9kZXNcbiAgbm9kZVNlcGFyYXRpb246IDc1LFxuICAvLyBQb3dlciBpdGVyYXRpb24gdG9sZXJhbmNlXG4gIHBpVG9sOiAwLjAwMDAwMDEsXG5cbiAgLyogQ29TRSBsYXlvdXQgb3B0aW9ucyAqL1xuXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIDQ1MDA7XG4gIH0sXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IGZ1bmN0aW9uIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgcmV0dXJuIDUwO1xuICB9LFxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHk6IGZ1bmN0aW9uIGVkZ2VFbGFzdGljaXR5KGVkZ2UpIHtcbiAgICByZXR1cm4gMC40NTtcbiAgfSxcbiAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICBuZXN0aW5nRmFjdG9yOiAwLjEsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICBncmF2aXR5OiAwLjI1LFxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgbnVtSXRlcjogMjUwMCxcbiAgLy8gRm9yIGVuYWJsaW5nIHRpbGluZ1xuICB0aWxlOiB0cnVlLFxuICAvLyBUaGUgZnVuY3Rpb24gdGhhdCBzcGVjaWZpZXMgdGhlIGNyaXRlcmlhIGZvciBjb21wYXJpbmcgbm9kZXMgd2hpbGUgc29ydGluZyB0aGVtIGR1cmluZyB0aWxpbmcgb3BlcmF0aW9uLlxuICAvLyBUYWtlcyB0aGUgbm9kZSBpZCBhcyBhIHBhcmFtZXRlciBhbmQgdGhlIGRlZmF1bHQgdGlsaW5nIG9wZXJhdGlvbiBpcyBwZXJmb21lZCB3aGVuIHRoaXMgb3B0aW9uIGlzIG5vdCBzZXQuXG4gIHRpbGluZ0NvbXBhcmVCeTogdW5kZWZpbmVkLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIHZlcnRpY2FsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nVmVydGljYWw6IDEwLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIGhvcml6b250YWwgc3BhY2UgdG8gcHV0IGJldHdlZW4gdGhlIHplcm8gZGVncmVlIG1lbWJlcnMgZHVyaW5nIHRoZSB0aWxpbmcgb3BlcmF0aW9uKGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24pXG4gIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsOiAxMCxcbiAgLy8gR3Jhdml0eSByYW5nZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eVJhbmdlQ29tcG91bmQ6IDEuNSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eUNvbXBvdW5kOiAxLjAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KVxuICBncmF2aXR5UmFuZ2U6IDMuOCxcbiAgLy8gSW5pdGlhbCBjb29saW5nIGZhY3RvciBmb3IgaW5jcmVtZW50YWwgbGF5b3V0ICBcbiAgaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw6IDAuMyxcblxuICAvKiBjb25zdHJhaW50IG9wdGlvbnMgKi9cblxuICAvLyBGaXggcmVxdWlyZWQgbm9kZXMgdG8gcHJlZGVmaW5lZCBwb3NpdGlvbnNcbiAgLy8gW3tub2RlSWQ6ICduMScsIHBvc2l0aW9uOiB7eDogMTAwLCB5OiAyMDB9LCB7Li4ufV1cbiAgZml4ZWROb2RlQ29uc3RyYWludDogdW5kZWZpbmVkLFxuICAvLyBBbGlnbiByZXF1aXJlZCBub2RlcyBpbiB2ZXJ0aWNhbC9ob3Jpem9udGFsIGRpcmVjdGlvblxuICAvLyB7dmVydGljYWw6IFtbJ24xJywgJ24yJyldLCBbJ24zJywgJ240J11dLCBob3Jpem9udGFsOiBbJ24yJywgJ240J119XG4gIGFsaWdubWVudENvbnN0cmFpbnQ6IHVuZGVmaW5lZCxcbiAgLy8gUGxhY2UgdHdvIG5vZGVzIHJlbGF0aXZlbHkgaW4gdmVydGljYWwvaG9yaXpvbnRhbCBkaXJlY3Rpb24gXG4gIC8vIFt7dG9wOiAnbjEnLCBib3R0b206ICduMicsIGdhcDogMTAwfSwge2xlZnQ6ICduMycsIHJpZ2h0OiAnbjQnLCBnYXA6IDc1fV1cbiAgcmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50OiB1bmRlZmluZWQsXG5cbiAgLyogbGF5b3V0IGV2ZW50IGNhbGxiYWNrcyAqL1xuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9IC8vIG9uIGxheW91dHN0b3Bcbn0pO1xuXG52YXIgTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXlvdXQpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGF5b3V0LCBbe1xuICAgIGtleTogJ3J1bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG5cbiAgICAgIHZhciBzcGVjdHJhbFJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHhDb29yZHMgPSB2b2lkIDA7XG4gICAgICB2YXIgeUNvb3JkcyA9IHZvaWQgMDtcbiAgICAgIHZhciBjb3NlUmVzdWx0ID0gW107XG4gICAgICB2YXIgY29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICAgIHZhciBjb21wb25lbnRDZW50ZXJzID0gW107XG5cbiAgICAgIC8vIGJhc2ljIHZhbGlkaXR5IGNoZWNrIGZvciBjb25zdHJhaW50IGlucHV0cyBcbiAgICAgIGlmIChvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCkgfHwgb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aCA9PSAwKSkge1xuICAgICAgICBvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwubGVuZ3RoID09IDApKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsLmxlbmd0aCA9PSAwKSkge1xuICAgICAgICAgIG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHx8IG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50Lmxlbmd0aCA9PSAwKSkge1xuICAgICAgICBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYW55IGNvbnN0cmFpbnQgZXhpc3RzLCBzZXQgc29tZSBvcHRpb25zXG4gICAgICB2YXIgY29uc3RyYWludEV4aXN0ID0gb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50IHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludCB8fCBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDtcbiAgICAgIGlmIChjb25zdHJhaW50RXhpc3QpIHtcbiAgICAgICAgLy8gY29uc3RyYWludHMgd29yayB3aXRoIHRoZXNlIG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucy50aWxlID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMucGFja0NvbXBvbmVudHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVjaWRlIGNvbXBvbmVudCBwYWNraW5nIGlzIGVuYWJsZWQgb3Igbm90XG4gICAgICB2YXIgbGF5VXRpbCA9IHZvaWQgMDtcbiAgICAgIHZhciBwYWNraW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKGN5LmxheW91dFV0aWxpdGllcyAmJiBvcHRpb25zLnBhY2tDb21wb25lbnRzKSB7XG4gICAgICAgIGxheVV0aWwgPSBjeS5sYXlvdXRVdGlsaXRpZXMoXCJnZXRcIik7XG4gICAgICAgIGlmICghbGF5VXRpbCkgbGF5VXRpbCA9IGN5LmxheW91dFV0aWxpdGllcygpO1xuICAgICAgICBwYWNraW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVzLm5vZGVzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBpZiBwYWNraW5nIGlzIG5vdCBlbmFibGVkLCBwZXJmb3JtIGxheW91dCBvbiB0aGUgd2hvbGUgZ3JhcGhcbiAgICAgICAgaWYgKCFwYWNraW5nRW5hYmxlZCkge1xuICAgICAgICAgIC8vIHN0b3JlIGNvbXBvbmVudCBjZW50ZXJcbiAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBvcHRpb25zLmVsZXMuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnB1c2goeyB4OiBib3VuZGluZ0JveC54MSArIGJvdW5kaW5nQm94LncgLyAyLCB5OiBib3VuZGluZ0JveC55MSArIGJvdW5kaW5nQm94LmggLyAyIH0pO1xuICAgICAgICAgIC8vIGFwcGx5IHNwZWN0cmFsIGxheW91dFxuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpO1xuICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQucHVzaChyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhcHBseSBjb3NlIGxheW91dCBhcyBwb3N0cHJvY2Vzc2luZ1xuICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgICAgY29zZVJlc3VsdC5wdXNoKGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHRbMF0pKTtcbiAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzWzBdLCBjb3NlUmVzdWx0WzBdLCBvcHRpb25zKTsgLy8gcmVsb2NhdGUgY2VudGVyIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzWzBdLCBzcGVjdHJhbFJlc3VsdFswXSwgb3B0aW9ucyk7IC8vIHJlbG9jYXRlIGNlbnRlciB0byBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwYWNraW5nIGlzIGVuYWJsZWRcbiAgICAgICAgICB2YXIgdG9wTW9zdE5vZGVzID0gYXV4LmdldFRvcE1vc3ROb2RlcyhvcHRpb25zLmVsZXMubm9kZXMoKSk7XG4gICAgICAgICAgY29tcG9uZW50cyA9IGF1eC5jb25uZWN0Q29tcG9uZW50cyhjeSwgb3B0aW9ucy5lbGVzLCB0b3BNb3N0Tm9kZXMpO1xuICAgICAgICAgIC8vIHN0b3JlIGNvbXBvbmVudCBjZW50ZXJzXG4gICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IGNvbXBvbmVudC5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgY29tcG9uZW50Q2VudGVycy5wdXNoKHsgeDogYm91bmRpbmdCb3gueDEgKyBib3VuZGluZ0JveC53IC8gMiwgeTogYm91bmRpbmdCb3gueTEgKyBib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vc2VuZCBlYWNoIGNvbXBvbmVudCB0byBzcGVjdHJhbCBsYXlvdXQgaWYgcmFuZG9taXplZFxuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5lbGVzID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5wdXNoKHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgICAgdmFyIHRvQmVUaWxlZE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGlsZSkge1xuICAgICAgICAgICAgICAvLyBiZWhhdmUgbm9kZXMgdG8gYmUgdGlsZWQgYXMgb25lIGNvbXBvbmVudFxuICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIHZhciBfeENvb3JkcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgX3lDb29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgdmFyIHRlbXBTcGVjdHJhbFJlc3VsdCA9IHsgbm9kZUluZGV4ZXM6IG5vZGVJbmRleGVzLCB4Q29vcmRzOiBfeENvb3JkcywgeUNvb3JkczogX3lDb29yZHMgfTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ZXNUb0JlRGVsZXRlZCA9IFtdO1xuICAgICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmVkZ2VzKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9CZVRpbGVkTm9kZXMubWVyZ2UoY29tcG9uZW50Lm5vZGVzKClbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC5ub2RlSW5kZXhlcy5zZXQoY29tcG9uZW50Lm5vZGVzKClbaV0uaWQoKSwgY291bnQrKyk7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcFNwZWN0cmFsUmVzdWx0LnhDb29yZHMucHVzaChjb21wb25lbnQubm9kZXMoKVswXS5wb3NpdGlvbigpLngpO1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC55Q29vcmRzLnB1c2goY29tcG9uZW50Lm5vZGVzKClbMF0ucG9zaXRpb24oKS55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpbmRleGVzVG9CZURlbGV0ZWQucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHRvQmVUaWxlZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2JvdW5kaW5nQm94ID0gdG9CZVRpbGVkTm9kZXMuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnB1c2goeyB4OiBfYm91bmRpbmdCb3gueDEgKyBfYm91bmRpbmdCb3gudyAvIDIsIHk6IF9ib3VuZGluZ0JveC55MSArIF9ib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2godG9CZVRpbGVkTm9kZXMpO1xuICAgICAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LnB1c2godGVtcFNwZWN0cmFsUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXhlc1RvQmVEZWxldGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQuc3BsaWNlKGluZGV4ZXNUb0JlRGVsZXRlZFtpXSwgMSk7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAvLyBzZW5kIGVhY2ggY29tcG9uZW50IHRvIGNvc2UgbGF5b3V0XG4gICAgICAgICAgICAgIG9wdGlvbnMuZWxlcyA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgY29zZVJlc3VsdC5wdXNoKGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdKSk7XG4gICAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzW2luZGV4XSwgY29zZVJlc3VsdFtpbmRleF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgYXV4LnJlbG9jYXRlQ29tcG9uZW50KGNvbXBvbmVudENlbnRlcnNbaW5kZXhdLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHBhY2tpbmdcbiAgICAgICAgICB2YXIgY29tcG9uZW50c0V2YWx1YXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgc3ViZ3JhcGhzID0gW107XG4gICAgICAgICAgICB2YXIgaGlkZGVuRWxlcyA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZS5jc3MoJ2Rpc3BsYXknKSA9PSAnbm9uZSc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4ZXMgPSBzcGVjdHJhbFJlc3VsdFtpbmRleF0ubm9kZUluZGV4ZXM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm5vZGVzKCkubm90KGhpZGRlbkVsZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViZ3JhcGggPSB7fTtcbiAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHN1YmdyYXBoLm5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQubm9kZXMoKS5ub3QoaGlkZGVuRWxlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2Rlcy5wdXNoKHsgeDogc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHNbbm9kZUluZGV4XSAtIG5vZGUuYm91bmRpbmdib3goKS53IC8gMiwgeTogc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHNbbm9kZUluZGV4XSAtIG5vZGUuYm91bmRpbmdib3goKS5oIC8gMiwgd2lkdGg6IG5vZGUuYm91bmRpbmdib3goKS53LCBoZWlnaHQ6IG5vZGUuYm91bmRpbmdib3goKS5oIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveChub2RlLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2Rlcy5wdXNoKHsgeDogcGFyZW50SW5mby50b3BMZWZ0WCwgeTogcGFyZW50SW5mby50b3BMZWZ0WSwgd2lkdGg6IHBhcmVudEluZm8ud2lkdGgsIGhlaWdodDogcGFyZW50SW5mby5oZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgubm9kZXMucHVzaCh7IHg6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0TGVmdCgpLCB5OiBjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldLmdldFRvcCgpLCB3aWR0aDogY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXS5nZXRXaWR0aCgpLCBoZWlnaHQ6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0SGVpZ2h0KCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jc3MoXCJkaXNwbGF5XCIpICE9IFwibm9uZVwiICYmIHRhcmdldC5jc3MoXCJkaXNwbGF5XCIpICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5vZGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChzb3VyY2UuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldE5vZGVJbmRleCA9IG5vZGVJbmRleGVzLmdldCh0YXJnZXQuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUNlbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRDZW50ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveChzb3VyY2UsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkcywgbm9kZUluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2VudGVyLnB1c2gocGFyZW50SW5mby50b3BMZWZ0WCArIHBhcmVudEluZm8ud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHBhcmVudEluZm8udG9wTGVmdFkgKyBwYXJlbnRJbmZvLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDZW50ZXIucHVzaChzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkc1tzb3VyY2VOb2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzW3NvdXJjZU5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcGFyZW50SW5mbyA9IGF1eC5jYWxjQm91bmRpbmdCb3godGFyZ2V0LCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKF9wYXJlbnRJbmZvLnRvcExlZnRYICsgX3BhcmVudEluZm8ud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKF9wYXJlbnRJbmZvLnRvcExlZnRZICsgX3BhcmVudEluZm8uaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzW3RhcmdldE5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyLnB1c2goc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHNbdGFyZ2V0Tm9kZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLmVkZ2VzLnB1c2goeyBzdGFydFg6IHNvdXJjZUNlbnRlclswXSwgc3RhcnRZOiBzb3VyY2VDZW50ZXJbMV0sIGVuZFg6IHRhcmdldENlbnRlclswXSwgZW5kWTogdGFyZ2V0Q2VudGVyWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0gJiYgY29zZVJlc3VsdFtpbmRleF1bdGFyZ2V0LmlkKCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcy5wdXNoKHsgc3RhcnRYOiBjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0uZ2V0Q2VudGVyWCgpLCBzdGFydFk6IGNvc2VSZXN1bHRbaW5kZXhdW3NvdXJjZS5pZCgpXS5nZXRDZW50ZXJZKCksIGVuZFg6IGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXS5nZXRDZW50ZXJYKCksIGVuZFk6IGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXS5nZXRDZW50ZXJZKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmdyYXBoLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHN1YmdyYXBocy5wdXNoKHN1YmdyYXBoKTtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNFdmFsdWF0ZWQuYWRkKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHNoaWZ0UmVzdWx0ID0gbGF5VXRpbC5wYWNrQ29tcG9uZW50cyhzdWJncmFwaHMsIG9wdGlvbnMucmFuZG9taXplKS5zaGlmdHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1hDb29yZHMgPSByZXN1bHQueENvb3Jkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgc2hpZnRSZXN1bHRbaW5kZXhdLmR4O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdZQ29vcmRzID0gcmVzdWx0LnlDb29yZHMubWFwKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geSArIHNoaWZ0UmVzdWx0W2luZGV4XS5keTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQueENvb3JkcyA9IG5ld1hDb29yZHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnlDb29yZHMgPSBuZXdZQ29vcmRzO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfY291bnQgPSAwO1xuICAgICAgICAgICAgICBjb21wb25lbnRzRXZhbHVhdGVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29zZVJlc3VsdFtpbmRleF0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBub2RlUmVjdGFuZ2xlID0gY29zZVJlc3VsdFtpbmRleF1baXRlbV07XG4gICAgICAgICAgICAgICAgICBub2RlUmVjdGFuZ2xlLnNldENlbnRlcihub2RlUmVjdGFuZ2xlLmdldENlbnRlclgoKSArIHNoaWZ0UmVzdWx0W19jb3VudF0uZHgsIG5vZGVSZWN0YW5nbGUuZ2V0Q2VudGVyWSgpICsgc2hpZnRSZXN1bHRbX2NvdW50XS5keSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX2NvdW50Kys7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnZXQgZWFjaCBlbGVtZW50J3MgY2FsY3VsYXRlZCBwb3NpdGlvblxuICAgICAgdmFyIGdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhlbGUsIGkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRlZmF1bHRcIiB8fCBvcHRpb25zLnF1YWxpdHkgPT0gXCJwcm9vZlwiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGVsZSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRoZUlkID0gZWxlLmRhdGEoJ2lkJyk7XG4gICAgICAgICAgY29zZVJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aGVJZCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgcG9zID0geyB4OiByZXN1bHRbdGhlSWRdLmdldFJlY3QoKS5nZXRDZW50ZXJYKCksIHk6IHJlc3VsdFt0aGVJZF0uZ2V0UmVjdCgpLmdldENlbnRlclkoKSB9O1xuICAgICAgICAgICAgICBub2RlID0gcmVzdWx0W3RoZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxhYmVsV2lkdGgpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgcG9zLnggKz0gbm9kZS5sYWJlbFdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueCAtPSBub2RlLmxhYmVsV2lkdGggLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueSArPSBub2RlLmxhYmVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJib3R0b21cIikge1xuICAgICAgICAgICAgICAgIHBvcy55IC09IG5vZGUubGFiZWxIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3MgPT0gdW5kZWZpbmVkKSBwb3MgPSB7IHg6IGVsZS5wb3NpdGlvbihcInhcIiksIHk6IGVsZS5wb3NpdGlvbihcInlcIikgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgICB5OiBwb3MueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3MgPSB2b2lkIDA7XG4gICAgICAgICAgc3BlY3RyYWxSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubm9kZUluZGV4ZXMuZ2V0KGVsZS5pZCgpKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3BvcyA9IHsgeDogcmVzdWx0LnhDb29yZHNbaW5kZXhdLCB5OiByZXN1bHQueUNvb3Jkc1tpbmRleF0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoX3BvcyA9PSB1bmRlZmluZWQpIF9wb3MgPSB7IHg6IGVsZS5wb3NpdGlvbihcInhcIiksIHk6IGVsZS5wb3NpdGlvbihcInlcIikgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogX3Bvcy54LFxuICAgICAgICAgICAgeTogX3Bvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gcXVhbGl0eSA9IFwiZHJhZnRcIiBhbmQgcmFuZG9taXplID0gZmFsc2UgYXJlIGNvbnRyYWRpY3RpdmUgc28gaW4gdGhhdCBjYXNlIHBvc2l0aW9ucyBkb24ndCBjaGFuZ2VcbiAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIiB8fCBvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAvLyB0cmFuc2ZlciBjYWxjdWxhdGVkIHBvc2l0aW9ucyB0byBub2RlcyAocG9zaXRpb25zIG9mIG9ubHkgc2ltcGxlIG5vZGVzIGFyZSBldmFsdWF0ZWQsIGNvbXBvdW5kcyBhcmUgcG9zaXRpb25lZCBhdXRvbWF0aWNhbGx5KVxuICAgICAgICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGF1eC5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbihjeSwgZWxlcyk7XG4gICAgICAgIHZhciBfaGlkZGVuRWxlcyA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmNzcygnZGlzcGxheScpID09ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuZWxlcyA9IGVsZXMubm90KF9oaWRkZW5FbGVzKTtcblxuICAgICAgICBlbGVzLm5vZGVzKCkubm90KFwiOnBhcmVudFwiKS5ub3QoX2hpZGRlbkVsZXMpLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGdldFBvc2l0aW9ucyk7XG5cbiAgICAgICAgaWYgKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICBlbGUucG9zaXRpb24oZ2V0UG9zaXRpb25zKGVsZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIklmIHJhbmRvbWl6ZSBvcHRpb24gaXMgc2V0IHRvIGZhbHNlLCB0aGVuIHF1YWxpdHkgb3B0aW9uIG11c3QgYmUgJ2RlZmF1bHQnIG9yICdwcm9vZicuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXlvdXQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3BlY3RyYWwgbGF5b3V0IHRoYXQgaXMgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIGZjb3NlIGxheW91dCBhbGdvcml0aG1cbiovXG5cbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG52YXIgTWF0cml4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuTWF0cml4O1xudmFyIFNWRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLlNWRDtcblxuLy8gbWFpbiBmdW5jdGlvbiB0aGF0IHNwZWN0cmFsIGxheW91dCBpcyBwcm9jZXNzZWRcbnZhciBzcGVjdHJhbExheW91dCA9IGZ1bmN0aW9uIHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpIHtcblxuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICB2YXIgcGFyZW50Tm9kZXMgPSBlbGVzLm5vZGVzKFwiOnBhcmVudFwiKTtcblxuICB2YXIgZHVtbXlOb2RlcyA9IG5ldyBNYXAoKTsgLy8gbWFwIHRvIGtlZXAgZHVtbXkgbm9kZXMgYW5kIHRoZWlyIG5laWdoYm9yc1xuICB2YXIgbm9kZUluZGV4ZXMgPSBuZXcgTWFwKCk7IC8vIG1hcCB0byBrZWVwIGluZGV4ZXMgdG8gbm9kZXNcbiAgdmFyIHBhcmVudENoaWxkTWFwID0gbmV3IE1hcCgpOyAvLyBtYXBwaW5nIGJ0dy4gY29tcG91bmQgYW5kIGl0cyByZXByZXNlbnRhdGl2ZSBub2RlIFxuICB2YXIgYWxsTm9kZXNOZWlnaGJvcmhvb2QgPSBbXTsgLy8gYXJyYXkgdG8ga2VlcCBuZWlnaGJvcmhvb2Qgb2YgYWxsIG5vZGVzXG4gIHZhciB4Q29vcmRzID0gW107XG4gIHZhciB5Q29vcmRzID0gW107XG5cbiAgdmFyIHNhbXBsZXNDb2x1bW4gPSBbXTsgLy8gc2FtcGxlZCB2ZXJ0aWNlc1xuICB2YXIgbWluRGlzdGFuY2VzQ29sdW1uID0gW107XG4gIHZhciBDID0gW107IC8vIGNvbHVtbiBzYW1wbGluZyBtYXRyaXhcbiAgdmFyIFBISSA9IFtdOyAvLyBpbnRlcnNlY3Rpb24gb2YgY29sdW1uIGFuZCByb3cgc2FtcGxpbmcgbWF0cmljZXMgXG4gIHZhciBJTlYgPSBbXTsgLy8gaW52ZXJzZSBvZiBQSEkgXG5cbiAgdmFyIGZpcnN0U2FtcGxlID0gdm9pZCAwOyAvLyB0aGUgZmlyc3Qgc2FtcGxlZCBub2RlXG4gIHZhciBub2RlU2l6ZSA9IHZvaWQgMDtcblxuICB2YXIgaW5maW5pdHkgPSAxMDAwMDAwMDA7XG4gIHZhciBzbWFsbCA9IDAuMDAwMDAwMDAxO1xuXG4gIHZhciBwaVRvbCA9IG9wdGlvbnMucGlUb2w7XG4gIHZhciBzYW1wbGluZ1R5cGUgPSBvcHRpb25zLnNhbXBsaW5nVHlwZTsgLy8gZmFsc2UgZm9yIHJhbmRvbSwgdHJ1ZSBmb3IgZ3JlZWR5XG4gIHZhciBub2RlU2VwYXJhdGlvbiA9IG9wdGlvbnMubm9kZVNlcGFyYXRpb247XG4gIHZhciBzYW1wbGVTaXplID0gdm9pZCAwO1xuXG4gIC8qKioqIFNwZWN0cmFsLXByZXByb2Nlc3NpbmcgZnVuY3Rpb25zICoqKiovXG5cbiAgLyoqKiogU3BlY3RyYWwgbGF5b3V0IGZ1bmN0aW9ucyAqKioqL1xuXG4gIC8vIGRldGVybWluZSB3aGljaCBjb2x1bW5zIHRvIGJlIHNhbXBsZWRcbiAgdmFyIHJhbmRvbVNhbXBsZUNSID0gZnVuY3Rpb24gcmFuZG9tU2FtcGxlQ1IoKSB7XG4gICAgdmFyIHNhbXBsZSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGNvdW50IDwgc2FtcGxlU2l6ZSkge1xuICAgICAgc2FtcGxlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZVNpemUpO1xuXG4gICAgICBmbGFnID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgaWYgKHNhbXBsZXNDb2x1bW5baV0gPT0gc2FtcGxlKSB7XG4gICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgIHNhbXBsZXNDb2x1bW5bY291bnRdID0gc2FtcGxlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHRha2VzIHRoZSBpbmRleCBvZiB0aGUgbm9kZShwaXZvdCkgdG8gaW5pdGlhdGUgQkZTIGFzIGEgcGFyYW1ldGVyXG4gIHZhciBCRlMgPSBmdW5jdGlvbiBCRlMocGl2b3QsIGluZGV4LCBzYW1wbGluZ01ldGhvZCkge1xuICAgIHZhciBwYXRoID0gW107IC8vIHRoZSBmcm9udCBvZiB0aGUgcGF0aFxuICAgIHZhciBmcm9udCA9IDA7IC8vIHRoZSBiYWNrIG9mIHRoZSBwYXRoXG4gICAgdmFyIGJhY2sgPSAwO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgdGVtcCA9IHZvaWQgMDtcbiAgICB2YXIgZGlzdGFuY2UgPSBbXTtcblxuICAgIHZhciBtYXhfZGlzdCA9IDA7IC8vIHRoZSBmdXJ0aGVzdCBub2RlIHRvIGJlIHJldHVybmVkXG4gICAgdmFyIG1heF9pbmQgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2l6ZTsgaSsrKSB7XG4gICAgICBkaXN0YW5jZVtpXSA9IGluZmluaXR5O1xuICAgIH1cblxuICAgIHBhdGhbYmFja10gPSBwaXZvdDtcbiAgICBkaXN0YW5jZVtwaXZvdF0gPSAwO1xuXG4gICAgd2hpbGUgKGJhY2sgPj0gZnJvbnQpIHtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2Zyb250KytdO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGFsbE5vZGVzTmVpZ2hib3Job29kW2N1cnJlbnRdO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5laWdoYm9ycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGVtcCA9IG5vZGVJbmRleGVzLmdldChuZWlnaGJvcnNbX2ldKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlW3RlbXBdID09IGluZmluaXR5KSB7XG4gICAgICAgICAgZGlzdGFuY2VbdGVtcF0gPSBkaXN0YW5jZVtjdXJyZW50XSArIDE7XG4gICAgICAgICAgcGF0aFsrK2JhY2tdID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ1tjdXJyZW50XVtpbmRleF0gPSBkaXN0YW5jZVtjdXJyZW50XSAqIG5vZGVTZXBhcmF0aW9uO1xuICAgIH1cblxuICAgIGlmIChzYW1wbGluZ01ldGhvZCkge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZVNpemU7IF9pMisrKSB7XG4gICAgICAgIGlmIChDW19pMl1baW5kZXhdIDwgbWluRGlzdGFuY2VzQ29sdW1uW19pMl0pIG1pbkRpc3RhbmNlc0NvbHVtbltfaTJdID0gQ1tfaTJdW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZVNpemU7IF9pMysrKSB7XG4gICAgICAgIGlmIChtaW5EaXN0YW5jZXNDb2x1bW5bX2kzXSA+IG1heF9kaXN0KSB7XG4gICAgICAgICAgbWF4X2Rpc3QgPSBtaW5EaXN0YW5jZXNDb2x1bW5bX2kzXTtcbiAgICAgICAgICBtYXhfaW5kID0gX2kzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhfaW5kO1xuICB9O1xuXG4gIC8vIGFwcGx5IEJGUyB0byBhbGwgbm9kZXMgb3Igc2VsZWN0ZWQgc2FtcGxlc1xuICB2YXIgYWxsQkZTID0gZnVuY3Rpb24gYWxsQkZTKHNhbXBsaW5nTWV0aG9kKSB7XG5cbiAgICB2YXIgc2FtcGxlID0gdm9pZCAwO1xuXG4gICAgaWYgKCFzYW1wbGluZ01ldGhvZCkge1xuICAgICAgcmFuZG9tU2FtcGxlQ1IoKTtcblxuICAgICAgLy8gY2FsbCBCRlNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlU2l6ZTsgaSsrKSB7XG4gICAgICAgIEJGUyhzYW1wbGVzQ29sdW1uW2ldLCBpLCBzYW1wbGluZ01ldGhvZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzYW1wbGUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2RlU2l6ZSk7XG4gICAgICBmaXJzdFNhbXBsZSA9IHNhbXBsZTtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZVNpemU7IF9pNCsrKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlc0NvbHVtbltfaTRdID0gaW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHNhbXBsZVNpemU7IF9pNSsrKSB7XG4gICAgICAgIHNhbXBsZXNDb2x1bW5bX2k1XSA9IHNhbXBsZTtcbiAgICAgICAgc2FtcGxlID0gQkZTKHNhbXBsZSwgX2k1LCBzYW1wbGluZ01ldGhvZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9ybSB0aGUgc3F1YXJlZCBkaXN0YW5jZXMgZm9yIENcbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBub2RlU2l6ZTsgX2k2KyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2FtcGxlU2l6ZTsgaisrKSB7XG4gICAgICAgIENbX2k2XVtqXSAqPSBDW19pNl1bal07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9ybSBQSElcbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBzYW1wbGVTaXplOyBfaTcrKykge1xuICAgICAgUEhJW19pN10gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBzYW1wbGVTaXplOyBfaTgrKykge1xuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHNhbXBsZVNpemU7IF9qKyspIHtcbiAgICAgICAgUEhJW19pOF1bX2pdID0gQ1tzYW1wbGVzQ29sdW1uW19qXV1bX2k4XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcGVyZm9ybSB0aGUgU1ZEIGFsZ29yaXRobSBhbmQgYXBwbHkgYSByZWd1bGFyaXphdGlvbiBzdGVwXG4gIHZhciBzYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUoKSB7XG5cbiAgICB2YXIgU1ZEUmVzdWx0ID0gU1ZELnN2ZChQSEkpO1xuXG4gICAgdmFyIGFfcSA9IFNWRFJlc3VsdC5TO1xuICAgIHZhciBhX3UgPSBTVkRSZXN1bHQuVTtcbiAgICB2YXIgYV92ID0gU1ZEUmVzdWx0LlY7XG5cbiAgICB2YXIgbWF4X3MgPSBhX3FbMF0gKiBhX3FbMF0gKiBhX3FbMF07XG5cbiAgICB2YXIgYV9TaWcgPSBbXTtcblxuICAgIC8vICByZWd1bGFyaXphdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlU2l6ZTsgaSsrKSB7XG4gICAgICBhX1NpZ1tpXSA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzYW1wbGVTaXplOyBqKyspIHtcbiAgICAgICAgYV9TaWdbaV1bal0gPSAwO1xuICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgYV9TaWdbaV1bal0gPSBhX3FbaV0gLyAoYV9xW2ldICogYV9xW2ldICsgbWF4X3MgLyAoYV9xW2ldICogYV9xW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBJTlYgPSBNYXRyaXgubXVsdE1hdChNYXRyaXgubXVsdE1hdChhX3YsIGFfU2lnKSwgTWF0cml4LnRyYW5zcG9zZShhX3UpKTtcbiAgfTtcblxuICAvLyBjYWxjdWxhdGUgZmluYWwgY29vcmRpbmF0ZXMgXG4gIHZhciBwb3dlckl0ZXJhdGlvbiA9IGZ1bmN0aW9uIHBvd2VySXRlcmF0aW9uKCkge1xuICAgIC8vIHR3byBsYXJnZXN0IGVpZ2VudmFsdWVzXG4gICAgdmFyIHRoZXRhMSA9IHZvaWQgMDtcbiAgICB2YXIgdGhldGEyID0gdm9pZCAwO1xuXG4gICAgLy8gaW5pdGlhbCBndWVzc2VzIGZvciBlaWdlbnZlY3RvcnNcbiAgICB2YXIgWTEgPSBbXTtcbiAgICB2YXIgWTIgPSBbXTtcblxuICAgIHZhciBWMSA9IFtdO1xuICAgIHZhciBWMiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2l6ZTsgaSsrKSB7XG4gICAgICBZMVtpXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICBZMltpXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgfVxuXG4gICAgWTEgPSBNYXRyaXgubm9ybWFsaXplKFkxKTtcbiAgICBZMiA9IE1hdHJpeC5ub3JtYWxpemUoWTIpO1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICAvLyB0byBrZWVwIHRyYWNrIG9mIHRoZSBpbXByb3ZlbWVudCByYXRpbyBpbiBwb3dlciBpdGVyYXRpb25cbiAgICB2YXIgY3VycmVudCA9IHNtYWxsO1xuICAgIHZhciBwcmV2aW91cyA9IHNtYWxsO1xuXG4gICAgdmFyIHRlbXAgPSB2b2lkIDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY291bnQrKztcblxuICAgICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgbm9kZVNpemU7IF9pOSsrKSB7XG4gICAgICAgIFYxW19pOV0gPSBZMVtfaTldO1xuICAgICAgfVxuXG4gICAgICBZMSA9IE1hdHJpeC5tdWx0R2FtbWEoTWF0cml4Lm11bHRMKE1hdHJpeC5tdWx0R2FtbWEoVjEpLCBDLCBJTlYpKTtcbiAgICAgIHRoZXRhMSA9IE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBZMSk7XG4gICAgICBZMSA9IE1hdHJpeC5ub3JtYWxpemUoWTEpO1xuXG4gICAgICBjdXJyZW50ID0gTWF0cml4LmRvdFByb2R1Y3QoVjEsIFkxKTtcblxuICAgICAgdGVtcCA9IE1hdGguYWJzKGN1cnJlbnQgLyBwcmV2aW91cyk7XG5cbiAgICAgIGlmICh0ZW1wIDw9IDEgKyBwaVRvbCAmJiB0ZW1wID49IDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IG5vZGVTaXplOyBfaTEwKyspIHtcbiAgICAgIFYxW19pMTBdID0gWTFbX2kxMF07XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZpb3VzID0gc21hbGw7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvdW50Kys7XG5cbiAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgbm9kZVNpemU7IF9pMTErKykge1xuICAgICAgICBWMltfaTExXSA9IFkyW19pMTFdO1xuICAgICAgfVxuXG4gICAgICBWMiA9IE1hdHJpeC5taW51c09wKFYyLCBNYXRyaXgubXVsdENvbnMoVjEsIE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBWMikpKTtcbiAgICAgIFkyID0gTWF0cml4Lm11bHRHYW1tYShNYXRyaXgubXVsdEwoTWF0cml4Lm11bHRHYW1tYShWMiksIEMsIElOVikpO1xuICAgICAgdGhldGEyID0gTWF0cml4LmRvdFByb2R1Y3QoVjIsIFkyKTtcbiAgICAgIFkyID0gTWF0cml4Lm5vcm1hbGl6ZShZMik7XG5cbiAgICAgIGN1cnJlbnQgPSBNYXRyaXguZG90UHJvZHVjdChWMiwgWTIpO1xuXG4gICAgICB0ZW1wID0gTWF0aC5hYnMoY3VycmVudCAvIHByZXZpb3VzKTtcblxuICAgICAgaWYgKHRlbXAgPD0gMSArIHBpVG9sICYmIHRlbXAgPj0gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbm9kZVNpemU7IF9pMTIrKykge1xuICAgICAgVjJbX2kxMl0gPSBZMltfaTEyXTtcbiAgICB9XG5cbiAgICAvLyB0aGV0YTEgbm93IGNvbnRhaW5zIGRvbWluYW50IGVpZ2VudmFsdWVcbiAgICAvLyB0aGV0YTIgbm93IGNvbnRhaW5zIHRoZSBzZWNvbmQtbGFyZ2VzdCBlaWdlbnZhbHVlXG4gICAgLy8gVjEgbm93IGNvbnRhaW5zIHRoZXRhMSdzIGVpZ2VudmVjdG9yXG4gICAgLy8gVjIgbm93IGNvbnRhaW5zIHRoZXRhMidzIGVpZ2VudmVjdG9yXG5cbiAgICAvL3BvcHVsYXRlIHRoZSB0d28gdmVjdG9yc1xuICAgIHhDb29yZHMgPSBNYXRyaXgubXVsdENvbnMoVjEsIE1hdGguc3FydChNYXRoLmFicyh0aGV0YTEpKSk7XG4gICAgeUNvb3JkcyA9IE1hdHJpeC5tdWx0Q29ucyhWMiwgTWF0aC5zcXJ0KE1hdGguYWJzKHRoZXRhMikpKTtcbiAgfTtcblxuICAvKioqKiBQcmVwYXJhdGlvbiBmb3Igc3BlY3RyYWwgbGF5b3V0IChQcmVwcm9jZXNzaW5nKSAqKioqL1xuXG4gIC8vIGNvbm5lY3QgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgKGZpcnN0IHRvcCBsZXZlbCwgdGhlbiBpbnNpZGUgb2YgZWFjaCBjb21wb3VuZCBub2RlKVxuICBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIGVsZXMsIGF1eC5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpLCBkdW1teU5vZGVzKTtcblxuICBwYXJlbnROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIGVsZXMsIGF1eC5nZXRUb3BNb3N0Tm9kZXMoZWxlLmRlc2NlbmRhbnRzKCkuaW50ZXJzZWN0aW9uKGVsZXMpKSwgZHVtbXlOb2Rlcyk7XG4gIH0pO1xuXG4gIC8vIGFzc2lnbiBpbmRleGVzIHRvIG5vZGVzIChmaXJzdCByZWFsLCB0aGVuIGR1bW15IG5vZGVzKVxuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFub2Rlc1tpXS5pc1BhcmVudCgpKSB7XG4gICAgICBub2RlSW5kZXhlcy5zZXQobm9kZXNbaV0uaWQoKSwgaW5kZXgrKyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZHVtbXlOb2Rlcy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIG5vZGVJbmRleGVzLnNldChrZXksIGluZGV4KyspO1xuICAgIH1cblxuICAgIC8vIGluc3RhbnRpYXRlIHRoZSBuZWlnaGJvcmhvb2QgbWF0cml4XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kxMyA9IDA7IF9pMTMgPCBub2RlSW5kZXhlcy5zaXplOyBfaTEzKyspIHtcbiAgICBhbGxOb2Rlc05laWdoYm9yaG9vZFtfaTEzXSA9IFtdO1xuICB9XG5cbiAgLy8gZm9ybSBhIHBhcmVudC1jaGlsZCBtYXAgdG8ga2VlcCByZXByZXNlbnRhdGl2ZSBub2RlIG9mIGVhY2ggY29tcG91bmQgbm9kZSAgXG4gIHBhcmVudE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZS5jaGlsZHJlbigpLmludGVyc2VjdGlvbihlbGVzKTtcblxuICAgIC8vICAgICAgbGV0IHJhbmRvbSA9IDA7XG4gICAgd2hpbGUgKGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKS5sZW5ndGggPT0gMCkge1xuICAgICAgLy8gICAgICAgIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoaWxkcmVuLm5vZGVzKCkubGVuZ3RoKTsgLy8gaWYgYWxsIGNoaWxkcmVuIGFyZSBjb21wb3VuZCB0aGVuIHByb2NlZWQgcmFuZG9tbHlcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ubm9kZXMoKVswXS5jaGlsZHJlbigpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICB9XG4gICAgLy8gIHNlbGVjdCB0aGUgcmVwcmVzZW50YXRpdmUgbm9kZSAtIHdlIGNhbiBhcHBseSBkaWZmZXJlbnQgbWV0aG9kcyBoZXJlXG4gICAgLy8gICAgICByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIikubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBtaW4gPSBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIilbMF0uY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpLmZvckVhY2goZnVuY3Rpb24gKGVsZTIsIGkpIHtcbiAgICAgIGlmIChlbGUyLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGVsZTIuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwYXJlbnRDaGlsZE1hcC5zZXQoZWxlLmlkKCksIGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKVtpbmRleF0uaWQoKSk7XG4gIH0pO1xuXG4gIC8vIGFkZCBuZWlnaGJvcmhvb2QgcmVsYXRpb25zIChmaXJzdCByZWFsLCB0aGVuIGR1bW15IG5vZGVzKVxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgZWxlSW5kZXggPSB2b2lkIDA7XG5cbiAgICBpZiAoZWxlLmlzUGFyZW50KCkpIGVsZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KHBhcmVudENoaWxkTWFwLmdldChlbGUuaWQoKSkpO2Vsc2UgZWxlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQoZWxlLmlkKCkpO1xuXG4gICAgZWxlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKGVsZXMuaW50ZXJzZWN0aW9uKGVsZS5lZGdlc1dpdGgobm9kZSkpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKG5vZGUuaXNQYXJlbnQoKSkgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2gocGFyZW50Q2hpbGRNYXAuZ2V0KG5vZGUuaWQoKSkpO2Vsc2UgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2gobm9kZS5pZCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2tleSkge1xuICAgIHZhciBlbGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChfa2V5KTtcbiAgICB2YXIgZGlzY29ubmVjdGVkSWQgPSB2b2lkIDA7XG4gICAgZHVtbXlOb2Rlcy5nZXQoX2tleSkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChjeS5nZXRFbGVtZW50QnlJZChpZCkuaXNQYXJlbnQoKSkgZGlzY29ubmVjdGVkSWQgPSBwYXJlbnRDaGlsZE1hcC5nZXQoaWQpO2Vsc2UgZGlzY29ubmVjdGVkSWQgPSBpZDtcblxuICAgICAgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2goZGlzY29ubmVjdGVkSWQpO1xuICAgICAgYWxsTm9kZXNOZWlnaGJvcmhvb2Rbbm9kZUluZGV4ZXMuZ2V0KGRpc2Nvbm5lY3RlZElkKV0ucHVzaChfa2V5KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZHVtbXlOb2Rlcy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgIHZhciBfa2V5ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICBfbG9vcChfa2V5KTtcbiAgICB9XG5cbiAgICAvLyBub2RlU2l6ZSBub3cgb25seSBjb25zaWRlcnMgdGhlIHNpemUgb2YgdHJhbnNmb3JtZWQgZ3JhcGhcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbm9kZVNpemUgPSBub2RlSW5kZXhlcy5zaXplO1xuXG4gIHZhciBzcGVjdHJhbFJlc3VsdCA9IHZvaWQgMDtcblxuICAvLyBJZiBudW1iZXIgb2Ygbm9kZXMgaW4gdHJhbnNmb3JtZWQgZ3JhcGggaXMgMSBvciAyLCBlaXRoZXIgU1ZEIG9yIHBvd2VySXRlcmF0aW9uIGNhdXNlcyBwcm9ibGVtXG4gIC8vIFNvIHNraXAgc3BlY3RyYWwgYW5kIGxheW91dCB0aGUgZ3JhcGggd2l0aCBjb3NlXG4gIGlmIChub2RlU2l6ZSA+IDIpIHtcbiAgICAvLyBpZiAjIG9mIG5vZGVzIGluIHRyYW5zZm9ybWVkIGdyYXBoIGlzIHNtYWxsZXIgdGhhbiBzYW1wbGUgc2l6ZSxcbiAgICAvLyB0aGVuIHVzZSAjIG9mIG5vZGVzIGFzIHNhbXBsZSBzaXplXG4gICAgc2FtcGxlU2l6ZSA9IG5vZGVTaXplIDwgb3B0aW9ucy5zYW1wbGVTaXplID8gbm9kZVNpemUgOiBvcHRpb25zLnNhbXBsZVNpemU7XG5cbiAgICAvLyBpbnN0YW50aWF0ZXMgdGhlIHBhcnRpYWwgbWF0cmljZXMgdGhhdCB3aWxsIGJlIHVzZWQgaW4gc3BlY3RyYWwgbGF5b3V0XG4gICAgZm9yICh2YXIgX2kxNCA9IDA7IF9pMTQgPCBub2RlU2l6ZTsgX2kxNCsrKSB7XG4gICAgICBDW19pMTRdID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIF9pMTUgPSAwOyBfaTE1IDwgc2FtcGxlU2l6ZTsgX2kxNSsrKSB7XG4gICAgICBJTlZbX2kxNV0gPSBbXTtcbiAgICB9XG5cbiAgICAvKioqKiBBcHBseSBzcGVjdHJhbCBsYXlvdXQgKioqKi9cblxuICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiIHx8IG9wdGlvbnMuc3RlcCA9PSBcImFsbFwiKSB7XG4gICAgICBhbGxCRlMoc2FtcGxpbmdUeXBlKTtcbiAgICAgIHNhbXBsZSgpO1xuICAgICAgcG93ZXJJdGVyYXRpb24oKTtcblxuICAgICAgc3BlY3RyYWxSZXN1bHQgPSB7IG5vZGVJbmRleGVzOiBub2RlSW5kZXhlcywgeENvb3JkczogeENvb3JkcywgeUNvb3JkczogeUNvb3JkcyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHhDb29yZHMucHVzaChjeS5nZXRFbGVtZW50QnlJZChrZXkpLnBvc2l0aW9uKFwieFwiKSk7XG4gICAgICAgIHlDb29yZHMucHVzaChjeS5nZXRFbGVtZW50QnlJZChrZXkpLnBvc2l0aW9uKFwieVwiKSk7XG4gICAgICB9KTtcbiAgICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWN0cmFsUmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvciA9IG5vZGVJbmRleGVzLmtleXMoKTtcbiAgICB2YXIgZmlyc3ROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB2YXIgZmlyc3ROb2RlUG9zID0gZmlyc3ROb2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIGZpcnN0Tm9kZVdpZHRoID0gZmlyc3ROb2RlLm91dGVyV2lkdGgoKTtcbiAgICB4Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLngpO1xuICAgIHlDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueSk7XG4gICAgaWYgKG5vZGVTaXplID09IDIpIHtcbiAgICAgIHZhciBzZWNvbmROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICAgIHZhciBzZWNvbmROb2RlV2lkdGggPSBzZWNvbmROb2RlLm91dGVyV2lkdGgoKTtcbiAgICAgIHhDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueCArIGZpcnN0Tm9kZVdpZHRoIC8gMiArIHNlY29uZE5vZGVXaWR0aCAvIDIgKyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCk7XG4gICAgICB5Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLnkpO1xuICAgIH1cblxuICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICByZXR1cm4gc3BlY3RyYWxSZXN1bHQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBzcGVjdHJhbExheW91dDogc3BlY3RyYWxMYXlvdXQgfTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU3OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBpbXBsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTIpO1xuXG4vLyByZWdpc3RlcnMgdGhlIGV4dGVuc2lvbiBvbiBhIGN5dG9zY2FwZSBsaWIgcmVmXG52YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihjeXRvc2NhcGUpIHtcbiAgaWYgKCFjeXRvc2NhcGUpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gY2FuJ3QgcmVnaXN0ZXIgaWYgY3l0b3NjYXBlIHVuc3BlY2lmaWVkXG5cbiAgY3l0b3NjYXBlKCdsYXlvdXQnLCAnZmNvc2UnLCBpbXBsKTsgLy8gcmVnaXN0ZXIgd2l0aCBjeXRvc2NhcGUuanNcbn07XG5cbmlmICh0eXBlb2YgY3l0b3NjYXBlICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBleHBvc2UgdG8gZ2xvYmFsIGN5dG9zY2FwZSAoaS5lLiB3aW5kb3cuY3l0b3NjYXBlKVxuICByZWdpc3RlcihjeXRvc2NhcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQwOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNDBfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzkpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/cytoscape-fcose@2.2.0_cytoscape@3.33.1/node_modules/cytoscape-fcose/cytoscape-fcose.js\n");

/***/ })

};
;