"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-model@1.25.3";
exports.ids = ["vendor-chunks/prosemirror-model@1.25.3"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; } catch (e) { return typeof fn === \"function\"; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar OrderedMap = __webpack_require__(/*! orderedmap */ \"(rsc)/../../node_modules/.pnpm/orderedmap@2.1.1/node_modules/orderedmap/dist/index.cjs\");\nfunction _findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;\n    var childA = a.child(i),\n      childB = b.child(i);\n    if (childA == childB) {\n      pos += childA.nodeSize;\n      continue;\n    }\n    if (!childA.sameMarkup(childB)) return pos;\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++) pos++;\n      return pos;\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = _findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) return inner;\n    }\n    pos += childA.nodeSize;\n  }\n}\nfunction _findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0) return iA == iB ? null : {\n      a: posA,\n      b: posB\n    };\n    var childA = a.child(--iA),\n      childB = b.child(--iB),\n      size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size;\n      posB -= size;\n      continue;\n    }\n    if (!childA.sameMarkup(childB)) return {\n      a: posA,\n      b: posB\n    };\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0,\n        minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;\n        posA--;\n        posB--;\n      }\n      return {\n        a: posA,\n        b: posB\n      };\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) return inner;\n    }\n    posA -= size;\n    posB -= size;\n  }\n}\nvar Fragment = function () {\n  function Fragment(content, size) {\n    _classCallCheck(this, Fragment);\n    this.content = content;\n    this.size = size || 0;\n    if (size == null) for (var i = 0; i < content.length; i++) this.size += content[i].nodeSize;\n  }\n  _createClass(Fragment, [{\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f) {\n      var nodeStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var parent = arguments.length > 4 ? arguments[4] : undefined;\n      for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n          end = pos + child.nodeSize;\n        if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n          var start = pos + 1;\n          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n        }\n        pos = end;\n      }\n    }\n  }, {\n    key: \"descendants\",\n    value: function descendants(f) {\n      this.nodesBetween(0, this.size, f);\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to, blockSeparator, leafText) {\n      var text = \"\",\n        first = true;\n      this.nodesBetween(from, to, function (node, pos) {\n        var nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n        if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n          if (first) first = false;else text += blockSeparator;\n        }\n        text += nodeText;\n      }, 0);\n      return text;\n    }\n  }, {\n    key: \"append\",\n    value: function append(other) {\n      if (!other.size) return this;\n      if (!this.size) return other;\n      var last = this.lastChild,\n        first = other.firstChild,\n        content = this.content.slice(),\n        i = 0;\n      if (last.isText && last.sameMarkup(first)) {\n        content[content.length - 1] = last.withText(last.text + first.text);\n        i = 1;\n      }\n      for (; i < other.content.length; i++) content.push(other.content[i]);\n      return new Fragment(content, this.size + other.size);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      if (from == 0 && to == this.size) return this;\n      var result = [],\n        size = 0;\n      if (to > from) for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n          end = pos + child.nodeSize;\n        if (end > from) {\n          if (pos < from || end > to) {\n            if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n          result.push(child);\n          size += child.nodeSize;\n        }\n        pos = end;\n      }\n      return new Fragment(result, size);\n    }\n  }, {\n    key: \"cutByIndex\",\n    value: function cutByIndex(from, to) {\n      if (from == to) return Fragment.empty;\n      if (from == 0 && to == this.content.length) return this;\n      return new Fragment(this.content.slice(from, to));\n    }\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(index, node) {\n      var current = this.content[index];\n      if (current == node) return this;\n      var copy = this.content.slice();\n      var size = this.size + node.nodeSize - current.nodeSize;\n      copy[index] = node;\n      return new Fragment(copy, size);\n    }\n  }, {\n    key: \"addToStart\",\n    value: function addToStart(node) {\n      return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n  }, {\n    key: \"addToEnd\",\n    value: function addToEnd(node) {\n      return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (this.content.length != other.content.length) return false;\n      for (var i = 0; i < this.content.length; i++) if (!this.content[i].eq(other.content[i])) return false;\n      return true;\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.content.length ? this.content[0] : null;\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.length;\n    }\n  }, {\n    key: \"child\",\n    value: function child(index) {\n      var found = this.content[index];\n      if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n      return found;\n    }\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content[index] || null;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      for (var i = 0, p = 0; i < this.content.length; i++) {\n        var child = this.content[i];\n        f(child, p, i);\n        p += child.nodeSize;\n      }\n    }\n  }, {\n    key: \"findDiffStart\",\n    value: function findDiffStart(other) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return _findDiffStart(this, other, pos);\n    }\n  }, {\n    key: \"findDiffEnd\",\n    value: function findDiffEnd(other) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      var otherPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : other.size;\n      return _findDiffEnd(this, other, pos, otherPos);\n    }\n  }, {\n    key: \"findIndex\",\n    value: function findIndex(pos) {\n      if (pos == 0) return retIndex(0, pos);\n      if (pos == this.size) return retIndex(this.content.length, pos);\n      if (pos > this.size || pos < 0) throw new RangeError(\"Position \".concat(pos, \" outside of fragment (\").concat(this, \")\"));\n      for (var i = 0, curPos = 0;; i++) {\n        var cur = this.child(i),\n          end = curPos + cur.nodeSize;\n        if (end >= pos) {\n          if (end == pos) return retIndex(i + 1, end);\n          return retIndex(i, curPos);\n        }\n        curPos = end;\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"<\" + this.toStringInner() + \">\";\n    }\n  }, {\n    key: \"toStringInner\",\n    value: function toStringInner() {\n      return this.content.join(\", \");\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.content.length ? this.content.map(function (n) {\n        return n.toJSON();\n      }) : null;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, value) {\n      if (!value) return Fragment.empty;\n      if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n      return new Fragment(value.map(schema.nodeFromJSON));\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      if (!array.length) return Fragment.empty;\n      var joined,\n        size = 0;\n      for (var i = 0; i < array.length; i++) {\n        var node = array[i];\n        size += node.nodeSize;\n        if (i && node.isText && array[i - 1].sameMarkup(node)) {\n          if (!joined) joined = array.slice(0, i);\n          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n        } else if (joined) {\n          joined.push(node);\n        }\n      }\n      return new Fragment(joined || array, size);\n    }\n  }, {\n    key: \"from\",\n    value: function from(nodes) {\n      if (!nodes) return Fragment.empty;\n      if (nodes instanceof Fragment) return nodes;\n      if (Array.isArray(nodes)) return this.fromArray(nodes);\n      if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize);\n      throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n  }]);\n  return Fragment;\n}();\nFragment.empty = new Fragment([], 0);\nvar found = {\n  index: 0,\n  offset: 0\n};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found;\n}\nfunction compareDeep(a, b) {\n  if (a === b) return true;\n  if (!(a && _typeof(a) == \"object\") || !(b && _typeof(b) == \"object\")) return false;\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) return false;\n  if (array) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false;\n  } else {\n    for (var p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false;\n    for (var _p in b) if (!(_p in a)) return false;\n  }\n  return true;\n}\nvar Mark = function () {\n  function Mark(type, attrs) {\n    _classCallCheck(this, Mark);\n    this.type = type;\n    this.attrs = attrs;\n  }\n  _createClass(Mark, [{\n    key: \"addToSet\",\n    value: function addToSet(set) {\n      var copy,\n        placed = false;\n      for (var i = 0; i < set.length; i++) {\n        var other = set[i];\n        if (this.eq(other)) return set;\n        if (this.type.excludes(other.type)) {\n          if (!copy) copy = set.slice(0, i);\n        } else if (other.type.excludes(this.type)) {\n          return set;\n        } else {\n          if (!placed && other.type.rank > this.type.rank) {\n            if (!copy) copy = set.slice(0, i);\n            copy.push(this);\n            placed = true;\n          }\n          if (copy) copy.push(other);\n        }\n      }\n      if (!copy) copy = set.slice();\n      if (!placed) copy.push(this);\n      return copy;\n    }\n  }, {\n    key: \"removeFromSet\",\n    value: function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));\n      return set;\n    }\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return true;\n      return false;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = {\n        type: this.type.name\n      };\n      for (var _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      return obj;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\");\n      var type = schema.marks[json.type];\n      if (!type) throw new RangeError(\"There is no mark type \".concat(json.type, \" in this schema\"));\n      var mark = type.create(json.attrs);\n      type.checkAttrs(mark.attrs);\n      return mark;\n    }\n  }, {\n    key: \"sameSet\",\n    value: function sameSet(a, b) {\n      if (a == b) return true;\n      if (a.length != b.length) return false;\n      for (var i = 0; i < a.length; i++) if (!a[i].eq(b[i])) return false;\n      return true;\n    }\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(marks) {\n      if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;\n      if (marks instanceof Mark) return [marks];\n      var copy = marks.slice();\n      copy.sort(function (a, b) {\n        return a.type.rank - b.type.rank;\n      });\n      return copy;\n    }\n  }]);\n  return Mark;\n}();\nMark.none = [];\nvar ReplaceError = function (_Error) {\n  _inherits(ReplaceError, _Error);\n  var _super = _createSuper(ReplaceError);\n  function ReplaceError() {\n    _classCallCheck(this, ReplaceError);\n    return _super.apply(this, arguments);\n  }\n  return _createClass(ReplaceError);\n}(_wrapNativeSuper(Error));\nvar Slice = function () {\n  function Slice(content, openStart, openEnd) {\n    _classCallCheck(this, Slice);\n    this.content = content;\n    this.openStart = openStart;\n    this.openEnd = openEnd;\n  }\n  _createClass(Slice, [{\n    key: \"size\",\n    get: function get() {\n      return this.content.size - this.openStart - this.openEnd;\n    }\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(pos, fragment) {\n      var content = insertInto(this.content, pos + this.openStart, fragment);\n      return content && new Slice(content, this.openStart, this.openEnd);\n    }\n  }, {\n    key: \"removeBetween\",\n    value: function removeBetween(from, to) {\n      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      if (!this.content.size) return null;\n      var json = {\n        content: this.content.toJSON()\n      };\n      if (this.openStart > 0) json.openStart = this.openStart;\n      if (this.openEnd > 0) json.openEnd = this.openEnd;\n      return json;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) return Slice.empty;\n      var openStart = json.openStart || 0,\n        openEnd = json.openEnd || 0;\n      if (typeof openStart != \"number\" || typeof openEnd != \"number\") throw new RangeError(\"Invalid input for Slice.fromJSON\");\n      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n  }, {\n    key: \"maxOpen\",\n    value: function maxOpen(fragment) {\n      var openIsolating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var openStart = 0,\n        openEnd = 0;\n      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++;\n      for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) openEnd++;\n      return new Slice(fragment, openStart, openEnd);\n    }\n  }]);\n  return Slice;\n}();\nSlice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n  var _content$findIndex = content.findIndex(from),\n    index = _content$findIndex.index,\n    offset = _content$findIndex.offset,\n    child = content.maybeChild(index);\n  var _content$findIndex2 = content.findIndex(to),\n    indexTo = _content$findIndex2.index,\n    offsetTo = _content$findIndex2.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\");\n    return content.cut(0, from).append(content.cut(to));\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\");\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n  var _content$findIndex3 = content.findIndex(dist),\n    index = _content$findIndex3.index,\n    offset = _content$findIndex3.offset,\n    child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null;\n    return content.cut(0, dist).append(insert).append(content.cut(dist));\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert, child);\n  return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction _replace($from, $to, slice) {\n  if (slice.openStart > $from.depth) throw new ReplaceError(\"Inserted content deeper than insertion position\");\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError(\"Inconsistent open depths\");\n  return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth),\n    node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner));\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth));\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n    var parent = $from.parent,\n      content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n  } else {\n    var _prepareSliceForRepla = prepareSliceForReplace(slice, $from),\n      start = _prepareSliceForRepla.start,\n      end = _prepareSliceForRepla.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth));\n  }\n}\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type)) throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node;\n}\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);else target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0,\n    endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) addNode(node.child(i), target);\n  if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n  node.type.checkContent(content);\n  return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n    addRange($start, $end, depth, content);\n    if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart,\n    parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--) node = $along.node(i).copy(Fragment.from(node));\n  return {\n    start: node.resolveNoCache(slice.openStart + extra),\n    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n  };\n}\nvar ResolvedPos = function () {\n  function ResolvedPos(pos, path, parentOffset) {\n    _classCallCheck(this, ResolvedPos);\n    this.pos = pos;\n    this.path = path;\n    this.parentOffset = parentOffset;\n    this.depth = path.length / 3 - 1;\n  }\n  _createClass(ResolvedPos, [{\n    key: \"resolveDepth\",\n    value: function resolveDepth(val) {\n      if (val == null) return this.depth;\n      if (val < 0) return this.depth + val;\n      return val;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.node(this.depth);\n    }\n  }, {\n    key: \"doc\",\n    get: function get() {\n      return this.node(0);\n    }\n  }, {\n    key: \"node\",\n    value: function node(depth) {\n      return this.path[this.resolveDepth(depth) * 3];\n    }\n  }, {\n    key: \"index\",\n    value: function index(depth) {\n      return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n  }, {\n    key: \"indexAfter\",\n    value: function indexAfter(depth) {\n      depth = this.resolveDepth(depth);\n      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n  }, {\n    key: \"start\",\n    value: function start(depth) {\n      depth = this.resolveDepth(depth);\n      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n  }, {\n    key: \"end\",\n    value: function end(depth) {\n      depth = this.resolveDepth(depth);\n      return this.start(depth) + this.node(depth).content.size;\n    }\n  }, {\n    key: \"before\",\n    value: function before(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position before the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n  }, {\n    key: \"after\",\n    value: function after(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position after the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n  }, {\n    key: \"textOffset\",\n    get: function get() {\n      return this.pos - this.path[this.path.length - 1];\n    }\n  }, {\n    key: \"nodeAfter\",\n    get: function get() {\n      var parent = this.parent,\n        index = this.index(this.depth);\n      if (index == parent.childCount) return null;\n      var dOff = this.pos - this.path[this.path.length - 1],\n        child = parent.child(index);\n      return dOff ? parent.child(index).cut(dOff) : child;\n    }\n  }, {\n    key: \"nodeBefore\",\n    get: function get() {\n      var index = this.index(this.depth);\n      var dOff = this.pos - this.path[this.path.length - 1];\n      if (dOff) return this.parent.child(index).cut(0, dOff);\n      return index == 0 ? null : this.parent.child(index - 1);\n    }\n  }, {\n    key: \"posAtIndex\",\n    value: function posAtIndex(index, depth) {\n      depth = this.resolveDepth(depth);\n      var node = this.path[depth * 3],\n        pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n      for (var i = 0; i < index; i++) pos += node.child(i).nodeSize;\n      return pos;\n    }\n  }, {\n    key: \"marks\",\n    value: function marks() {\n      var parent = this.parent,\n        index = this.index();\n      if (parent.content.size == 0) return Mark.none;\n      if (this.textOffset) return parent.child(index).marks;\n      var main = parent.maybeChild(index - 1),\n        other = parent.maybeChild(index);\n      if (!main) {\n        var tmp = main;\n        main = other;\n        other = tmp;\n      }\n      var marks = main.marks;\n      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);\n      return marks;\n    }\n  }, {\n    key: \"marksAcross\",\n    value: function marksAcross($end) {\n      var after = this.parent.maybeChild(this.index());\n      if (!after || !after.isInline) return null;\n      var marks = after.marks,\n        next = $end.parent.maybeChild($end.index());\n      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);\n      return marks;\n    }\n  }, {\n    key: \"sharedDepth\",\n    value: function sharedDepth(pos) {\n      for (var depth = this.depth; depth > 0; depth--) if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;\n      return 0;\n    }\n  }, {\n    key: \"blockRange\",\n    value: function blockRange() {\n      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n      var pred = arguments.length > 1 ? arguments[1] : undefined;\n      if (other.pos < this.pos) return other.blockRange(this);\n      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);\n      return null;\n    }\n  }, {\n    key: \"sameParent\",\n    value: function sameParent(other) {\n      return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n  }, {\n    key: \"max\",\n    value: function max(other) {\n      return other.pos > this.pos ? other : this;\n    }\n  }, {\n    key: \"min\",\n    value: function min(other) {\n      return other.pos < this.pos ? other : this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var str = \"\";\n      for (var i = 1; i <= this.depth; i++) str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n      return str + \":\" + this.parentOffset;\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(doc, pos) {\n      if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\");\n      var path = [];\n      var start = 0,\n        parentOffset = pos;\n      for (var node = doc;;) {\n        var _node$content$findInd = node.content.findIndex(parentOffset),\n          index = _node$content$findInd.index,\n          offset = _node$content$findInd.offset;\n        var rem = parentOffset - offset;\n        path.push(node, index, start + offset);\n        if (!rem) break;\n        node = node.child(index);\n        if (node.isText) break;\n        parentOffset = rem - 1;\n        start += offset + 1;\n      }\n      return new ResolvedPos(pos, path, parentOffset);\n    }\n  }, {\n    key: \"resolveCached\",\n    value: function resolveCached(doc, pos) {\n      var cache = resolveCache.get(doc);\n      if (cache) {\n        for (var i = 0; i < cache.elts.length; i++) {\n          var elt = cache.elts[i];\n          if (elt.pos == pos) return elt;\n        }\n      } else {\n        resolveCache.set(doc, cache = new ResolveCache());\n      }\n      var result = cache.elts[cache.i] = ResolvedPos.resolve(doc, pos);\n      cache.i = (cache.i + 1) % resolveCacheSize;\n      return result;\n    }\n  }]);\n  return ResolvedPos;\n}();\nvar ResolveCache = _createClass(function ResolveCache() {\n  _classCallCheck(this, ResolveCache);\n  this.elts = [];\n  this.i = 0;\n});\nvar resolveCacheSize = 12,\n  resolveCache = new WeakMap();\nvar NodeRange = function () {\n  function NodeRange($from, $to, depth) {\n    _classCallCheck(this, NodeRange);\n    this.$from = $from;\n    this.$to = $to;\n    this.depth = depth;\n  }\n  _createClass(NodeRange, [{\n    key: \"start\",\n    get: function get() {\n      return this.$from.before(this.depth + 1);\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.$to.after(this.depth + 1);\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.$from.node(this.depth);\n    }\n  }, {\n    key: \"startIndex\",\n    get: function get() {\n      return this.$from.index(this.depth);\n    }\n  }, {\n    key: \"endIndex\",\n    get: function get() {\n      return this.$to.indexAfter(this.depth);\n    }\n  }]);\n  return NodeRange;\n}();\nvar emptyAttrs = Object.create(null);\nvar Node = function () {\n  function Node(type, attrs, content) {\n    var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Mark.none;\n    _classCallCheck(this, Node);\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.content = content || Fragment.empty;\n  }\n  _createClass(Node, [{\n    key: \"children\",\n    get: function get() {\n      return this.content.content;\n    }\n  }, {\n    key: \"nodeSize\",\n    get: function get() {\n      return this.isLeaf ? 1 : 2 + this.content.size;\n    }\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.childCount;\n    }\n  }, {\n    key: \"child\",\n    value: function child(index) {\n      return this.content.child(index);\n    }\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content.maybeChild(index);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      this.content.forEach(f);\n    }\n  }, {\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f) {\n      var startPos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      this.content.nodesBetween(from, to, f, startPos, this);\n    }\n  }, {\n    key: \"descendants\",\n    value: function descendants(f) {\n      this.nodesBetween(0, this.content.size, f);\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to, blockSeparator, leafText) {\n      return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.content.firstChild;\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.lastChild;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n  }, {\n    key: \"sameMarkup\",\n    value: function sameMarkup(other) {\n      return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n  }, {\n    key: \"hasMarkup\",\n    value: function hasMarkup(type, attrs, marks) {\n      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (content == this.content) return this;\n      return new Node(this.type, this.attrs, content, this.marks);\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;\n      if (from == 0 && to == this.content.size) return this;\n      return this.copy(this.content.cut(from, to));\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;\n      var includeParents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (from == to) return Slice.empty;\n      var $from = this.resolve(from),\n        $to = this.resolve(to);\n      var depth = includeParents ? 0 : $from.sharedDepth(to);\n      var start = $from.start(depth),\n        node = $from.node(depth);\n      var content = node.content.cut($from.pos - start, $to.pos - start);\n      return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, slice) {\n      return _replace(this.resolve(from), this.resolve(to), slice);\n    }\n  }, {\n    key: \"nodeAt\",\n    value: function nodeAt(pos) {\n      for (var node = this;;) {\n        var _node$content$findInd2 = node.content.findIndex(pos),\n          index = _node$content$findInd2.index,\n          offset = _node$content$findInd2.offset;\n        node = node.maybeChild(index);\n        if (!node) return null;\n        if (offset == pos || node.isText) return node;\n        pos -= offset + 1;\n      }\n    }\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      var _this$content$findInd = this.content.findIndex(pos),\n        index = _this$content$findInd.index,\n        offset = _this$content$findInd.offset;\n      return {\n        node: this.content.maybeChild(index),\n        index: index,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      if (pos == 0) return {\n        node: null,\n        index: 0,\n        offset: 0\n      };\n      var _this$content$findInd2 = this.content.findIndex(pos),\n        index = _this$content$findInd2.index,\n        offset = _this$content$findInd2.offset;\n      if (offset < pos) return {\n        node: this.content.child(index),\n        index: index,\n        offset: offset\n      };\n      var node = this.content.child(index - 1);\n      return {\n        node: node,\n        index: index - 1,\n        offset: offset - node.nodeSize\n      };\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      return ResolvedPos.resolveCached(this, pos);\n    }\n  }, {\n    key: \"resolveNoCache\",\n    value: function resolveNoCache(pos) {\n      return ResolvedPos.resolve(this, pos);\n    }\n  }, {\n    key: \"rangeHasMark\",\n    value: function rangeHasMark(from, to, type) {\n      var found = false;\n      if (to > from) this.nodesBetween(from, to, function (node) {\n        if (type.isInSet(node.marks)) found = true;\n        return !found;\n      });\n      return found;\n    }\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      return this.type.isBlock;\n    }\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.type.isTextblock;\n    }\n  }, {\n    key: \"inlineContent\",\n    get: function get() {\n      return this.type.inlineContent;\n    }\n  }, {\n    key: \"isInline\",\n    get: function get() {\n      return this.type.isInline;\n    }\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return this.type.isText;\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.type.isLeaf;\n    }\n  }, {\n    key: \"isAtom\",\n    get: function get() {\n      return this.type.isAtom;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n      var name = this.type.name;\n      if (this.content.size) name += \"(\" + this.content.toStringInner() + \")\";\n      return wrapMarks(this.marks, name);\n    }\n  }, {\n    key: \"contentMatchAt\",\n    value: function contentMatchAt(index) {\n      var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n      if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\");\n      return match;\n    }\n  }, {\n    key: \"canReplace\",\n    value: function canReplace(from, to) {\n      var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Fragment.empty;\n      var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : replacement.childCount;\n      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n      var two = one && one.matchFragment(this.content, to);\n      if (!two || !two.validEnd) return false;\n      for (var i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false;\n      return true;\n    }\n  }, {\n    key: \"canReplaceWith\",\n    value: function canReplaceWith(from, to, type, marks) {\n      if (marks && !this.type.allowsMarks(marks)) return false;\n      var start = this.contentMatchAt(from).matchType(type);\n      var end = start && start.matchFragment(this.content, to);\n      return end ? end.validEnd : false;\n    }\n  }, {\n    key: \"canAppend\",\n    value: function canAppend(other) {\n      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);\n    }\n  }, {\n    key: \"check\",\n    value: function check() {\n      this.type.checkContent(this.content);\n      this.type.checkAttrs(this.attrs);\n      var copy = Mark.none;\n      for (var i = 0; i < this.marks.length; i++) {\n        var mark = this.marks[i];\n        mark.type.checkAttrs(mark.attrs);\n        copy = mark.addToSet(copy);\n      }\n      if (!Mark.sameSet(copy, this.marks)) throw new RangeError(\"Invalid collection of marks for node \".concat(this.type.name, \": \").concat(this.marks.map(function (m) {\n        return m.type.name;\n      })));\n      this.content.forEach(function (node) {\n        return node.check();\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = {\n        type: this.type.name\n      };\n      for (var _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      if (this.content.size) obj.content = this.content.toJSON();\n      if (this.marks.length) obj.marks = this.marks.map(function (n) {\n        return n.toJSON();\n      });\n      return obj;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\");\n      var marks = undefined;\n      if (json.marks) {\n        if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n        marks = json.marks.map(schema.markFromJSON);\n      }\n      if (json.type == \"text\") {\n        if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\");\n        return schema.text(json.text, marks);\n      }\n      var content = Fragment.fromJSON(schema, json.content);\n      var node = schema.nodeType(json.type).create(json.attrs, content, marks);\n      node.type.checkAttrs(node.attrs);\n      return node;\n    }\n  }]);\n  return Node;\n}();\nNode.prototype.text = undefined;\nvar TextNode = function (_Node) {\n  _inherits(TextNode, _Node);\n  var _super2 = _createSuper(TextNode);\n  function TextNode(type, attrs, content, marks) {\n    var _this;\n    _classCallCheck(this, TextNode);\n    _this = _super2.call(this, type, attrs, null, marks);\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\");\n    _this.text = content;\n    return _this;\n  }\n  _createClass(TextNode, [{\n    key: \"toString\",\n    value: function toString() {\n      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n      return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.text;\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to) {\n      return this.text.slice(from, to);\n    }\n  }, {\n    key: \"nodeSize\",\n    get: function get() {\n      return this.text.length;\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n  }, {\n    key: \"withText\",\n    value: function withText(text) {\n      if (text == this.text) return this;\n      return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.text.length;\n      if (from == 0 && to == this.text.length) return this;\n      return this.withText(this.text.slice(from, to));\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.sameMarkup(other) && this.text == other.text;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var base = _get(_getPrototypeOf(TextNode.prototype), \"toJSON\", this).call(this);\n      base.text = this.text;\n      return base;\n    }\n  }]);\n  return TextNode;\n}(Node);\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--) str = marks[i].type.name + \"(\" + str + \")\";\n  return str;\n}\nvar ContentMatch = function () {\n  function ContentMatch(validEnd) {\n    _classCallCheck(this, ContentMatch);\n    this.validEnd = validEnd;\n    this.next = [];\n    this.wrapCache = [];\n  }\n  _createClass(ContentMatch, [{\n    key: \"matchType\",\n    value: function matchType(type) {\n      for (var i = 0; i < this.next.length; i++) if (this.next[i].type == type) return this.next[i].next;\n      return null;\n    }\n  }, {\n    key: \"matchFragment\",\n    value: function matchFragment(frag) {\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : frag.childCount;\n      var cur = this;\n      for (var i = start; cur && i < end; i++) cur = cur.matchType(frag.child(i).type);\n      return cur;\n    }\n  }, {\n    key: \"inlineContent\",\n    get: function get() {\n      return this.next.length != 0 && this.next[0].type.isInline;\n    }\n  }, {\n    key: \"defaultType\",\n    get: function get() {\n      for (var i = 0; i < this.next.length; i++) {\n        var type = this.next[i].type;\n        if (!(type.isText || type.hasRequiredAttrs())) return type;\n      }\n      return null;\n    }\n  }, {\n    key: \"compatible\",\n    value: function compatible(other) {\n      for (var i = 0; i < this.next.length; i++) for (var j = 0; j < other.next.length; j++) if (this.next[i].type == other.next[j].type) return true;\n      return false;\n    }\n  }, {\n    key: \"fillBefore\",\n    value: function fillBefore(after) {\n      var toEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var seen = [this];\n      function search(match, types) {\n        var finished = match.matchFragment(after, startIndex);\n        if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map(function (tp) {\n          return tp.createAndFill();\n        }));\n        for (var i = 0; i < match.next.length; i++) {\n          var _match$next$i = match.next[i],\n            type = _match$next$i.type,\n            next = _match$next$i.next;\n          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n            seen.push(next);\n            var _found = search(next, types.concat(type));\n            if (_found) return _found;\n          }\n        }\n        return null;\n      }\n      return search(this, []);\n    }\n  }, {\n    key: \"findWrapping\",\n    value: function findWrapping(target) {\n      for (var i = 0; i < this.wrapCache.length; i += 2) if (this.wrapCache[i] == target) return this.wrapCache[i + 1];\n      var computed = this.computeWrapping(target);\n      this.wrapCache.push(target, computed);\n      return computed;\n    }\n  }, {\n    key: \"computeWrapping\",\n    value: function computeWrapping(target) {\n      var seen = Object.create(null),\n        active = [{\n          match: this,\n          type: null,\n          via: null\n        }];\n      while (active.length) {\n        var current = active.shift(),\n          match = current.match;\n        if (match.matchType(target)) {\n          var result = [];\n          for (var obj = current; obj.type; obj = obj.via) result.push(obj.type);\n          return result.reverse();\n        }\n        for (var i = 0; i < match.next.length; i++) {\n          var _match$next$i2 = match.next[i],\n            type = _match$next$i2.type,\n            next = _match$next$i2.next;\n          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n            active.push({\n              match: type.contentMatch,\n              type: type,\n              via: current\n            });\n            seen[type.name] = true;\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"edgeCount\",\n    get: function get() {\n      return this.next.length;\n    }\n  }, {\n    key: \"edge\",\n    value: function edge(n) {\n      if (n >= this.next.length) throw new RangeError(\"There's no \".concat(n, \"th edge in this content match\"));\n      return this.next[n];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var seen = [];\n      function scan(m) {\n        seen.push(m);\n        for (var i = 0; i < m.next.length; i++) if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);\n      }\n      scan(this);\n      return seen.map(function (m, i) {\n        var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n        for (var _i = 0; _i < m.next.length; _i++) out += (_i ? \", \" : \"\") + m.next[_i].type.name + \"->\" + seen.indexOf(m.next[_i].next);\n        return out;\n      }).join(\"\\n\");\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(string, nodeTypes) {\n      var stream = new TokenStream(string, nodeTypes);\n      if (stream.next == null) return ContentMatch.empty;\n      var expr = parseExpr(stream);\n      if (stream.next) stream.err(\"Unexpected trailing text\");\n      var match = dfa(nfa(expr));\n      checkForDeadEnds(match, stream);\n      return match;\n    }\n  }]);\n  return ContentMatch;\n}();\nContentMatch.empty = new ContentMatch(true);\nvar TokenStream = function () {\n  function TokenStream(string, nodeTypes) {\n    _classCallCheck(this, TokenStream);\n    this.string = string;\n    this.nodeTypes = nodeTypes;\n    this.inline = null;\n    this.pos = 0;\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop();\n    if (this.tokens[0] == \"\") this.tokens.shift();\n  }\n  _createClass(TokenStream, [{\n    key: \"next\",\n    get: function get() {\n      return this.tokens[this.pos];\n    }\n  }, {\n    key: \"eat\",\n    value: function eat(tok) {\n      return this.next == tok && (this.pos++ || true);\n    }\n  }, {\n    key: \"err\",\n    value: function err(str) {\n      throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n    }\n  }]);\n  return TokenStream;\n}();\nfunction parseExpr(stream) {\n  var exprs = [];\n  do {\n    exprs.push(parseExprSeq(stream));\n  } while (stream.eat(\"|\"));\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"choice\",\n    exprs: exprs\n  };\n}\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do {\n    exprs.push(parseExprSubscript(stream));\n  } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"seq\",\n    exprs: exprs\n  };\n}\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\")) expr = {\n      type: \"plus\",\n      expr: expr\n    };else if (stream.eat(\"*\")) expr = {\n      type: \"star\",\n      expr: expr\n    };else if (stream.eat(\"?\")) expr = {\n      type: \"opt\",\n      expr: expr\n    };else if (stream.eat(\"{\")) expr = parseExprRange(stream, expr);else break;\n  }\n  return expr;\n}\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\");\n  var result = Number(stream.next);\n  stream.pos++;\n  return result;\n}\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream),\n    max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream);else max = -1;\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\");\n  return {\n    type: \"range\",\n    min: min,\n    max: max,\n    expr: expr\n  };\n}\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes,\n    type = types[name];\n  if (type) return [type];\n  var result = [];\n  for (var typeName in types) {\n    var _type = types[typeName];\n    if (_type.isInGroup(name)) result.push(_type);\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\");\n  return result;\n}\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\");\n    return expr;\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) stream.inline = type.isInline;else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\");\n      return {\n        type: \"name\",\n        value: type\n      };\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {\n      type: \"choice\",\n      exprs: exprs\n    };\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa;\n  function node() {\n    return nfa.push([]) - 1;\n  }\n  function edge(from, to, term) {\n    var edge = {\n      term: term,\n      to: to\n    };\n    nfa[from].push(edge);\n    return edge;\n  }\n  function connect(edges, to) {\n    edges.forEach(function (edge) {\n      return edge.to = to;\n    });\n  }\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) {\n        return out.concat(compile(expr, from));\n      }, []);\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) return next;\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr.type == \"plus\") {\n      var _loop = node();\n      connect(compile(expr.expr, from), _loop);\n      connect(compile(expr.expr, _loop), _loop);\n      return [edge(_loop)];\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from));\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var _i2 = 0; _i2 < expr.min; _i2++) {\n        var _next = node();\n        connect(compile(expr.expr, cur), _next);\n        cur = _next;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var _i3 = expr.min; _i3 < expr.max; _i3++) {\n          var _next2 = node();\n          edge(cur, _next2);\n          connect(compile(expr.expr, cur), _next2);\n          cur = _next2;\n        }\n      }\n      return [edge(cur)];\n    } else if (expr.type == \"name\") {\n      return [edge(from, undefined, expr.value)];\n    } else {\n      throw new Error(\"Unknown expr type\");\n    }\n  }\n}\nfunction cmp(a, b) {\n  return b - a;\n}\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp);\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var _edges$i = edges[i],\n        term = _edges$i.term,\n        to = _edges$i.to;\n      if (!term && result.indexOf(to) == -1) scan(to);\n    }\n  }\n}\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0));\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (_ref) {\n        var term = _ref.term,\n          to = _ref.to;\n        if (!term) return;\n        var set;\n        for (var i = 0; i < out.length; i++) if (out[i][0] == term) set = out[i][1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) out.push([term, set = []]);\n          if (set.indexOf(node) == -1) set.push(node);\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i++) {\n      var _states = out[i][1].sort(cmp);\n      state.next.push({\n        type: out[i][0],\n        next: labeled[_states.join(\",\")] || explore(_states)\n      });\n    }\n    return state;\n  }\n}\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i],\n      dead = !state.validEnd,\n      nodes = [];\n    for (var j = 0; j < state.next.length; j++) {\n      var _state$next$j = state.next[j],\n        type = _state$next$j.type,\n        next = _state$next$j.next;\n      nodes.push(type.name);\n      if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;\n      if (work.indexOf(next) == -1) work.push(next);\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n  }\n}\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) return null;\n    defaults[attrName] = attr[\"default\"];\n  }\n  return defaults;\n}\nfunction _computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) given = attr[\"default\"];else throw new RangeError(\"No value supplied for attribute \" + name);\n    }\n    built[name] = given;\n  }\n  return built;\n}\nfunction _checkAttrs(attrs, values, type, name) {\n  for (var _name in values) if (!(_name in attrs)) throw new RangeError(\"Unsupported attribute \".concat(_name, \" for \").concat(type, \" of type \").concat(_name));\n  for (var _name2 in attrs) {\n    var attr = attrs[_name2];\n    if (attr.validate) attr.validate(values[_name2]);\n  }\n}\nfunction initAttrs(typeName, attrs) {\n  var result = Object.create(null);\n  if (attrs) for (var name in attrs) result[name] = new Attribute(typeName, name, attrs[name]);\n  return result;\n}\nvar NodeType = function () {\n  function NodeType(name, schema, spec) {\n    _classCallCheck(this, NodeType);\n    this.name = name;\n    this.schema = schema;\n    this.spec = spec;\n    this.markSet = null;\n    this.groups = spec.group ? spec.group.split(\" \") : [];\n    this.attrs = initAttrs(name, spec.attrs);\n    this.defaultAttrs = defaultAttrs(this.attrs);\n    this.contentMatch = null;\n    this.inlineContent = null;\n    this.isBlock = !(spec.inline || name == \"text\");\n    this.isText = name == \"text\";\n  }\n  _createClass(NodeType, [{\n    key: \"isInline\",\n    get: function get() {\n      return !this.isBlock;\n    }\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.isBlock && this.inlineContent;\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.contentMatch == ContentMatch.empty;\n    }\n  }, {\n    key: \"isAtom\",\n    get: function get() {\n      return this.isLeaf || !!this.spec.atom;\n    }\n  }, {\n    key: \"isInGroup\",\n    value: function isInGroup(group) {\n      return this.groups.indexOf(group) > -1;\n    }\n  }, {\n    key: \"whitespace\",\n    get: function get() {\n      return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n  }, {\n    key: \"hasRequiredAttrs\",\n    value: function hasRequiredAttrs() {\n      for (var n in this.attrs) if (this.attrs[n].isRequired) return true;\n      return false;\n    }\n  }, {\n    key: \"compatibleContent\",\n    value: function compatibleContent(other) {\n      return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n  }, {\n    key: \"computeAttrs\",\n    value: function computeAttrs(attrs) {\n      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _computeAttrs(this.attrs, attrs);\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\");\n      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n  }, {\n    key: \"createChecked\",\n    value: function createChecked() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      content = Fragment.from(content);\n      this.checkContent(content);\n      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n  }, {\n    key: \"createAndFill\",\n    value: function createAndFill() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      attrs = this.computeAttrs(attrs);\n      content = Fragment.from(content);\n      if (content.size) {\n        var before = this.contentMatch.fillBefore(content);\n        if (!before) return null;\n        content = before.append(content);\n      }\n      var matched = this.contentMatch.matchFragment(content);\n      var after = matched && matched.fillBefore(Fragment.empty, true);\n      if (!after) return null;\n      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n  }, {\n    key: \"validContent\",\n    value: function validContent(content) {\n      var result = this.contentMatch.matchFragment(content);\n      if (!result || !result.validEnd) return false;\n      for (var i = 0; i < content.childCount; i++) if (!this.allowsMarks(content.child(i).marks)) return false;\n      return true;\n    }\n  }, {\n    key: \"checkContent\",\n    value: function checkContent(content) {\n      if (!this.validContent(content)) throw new RangeError(\"Invalid content for node \".concat(this.name, \": \").concat(content.toString().slice(0, 50)));\n    }\n  }, {\n    key: \"checkAttrs\",\n    value: function checkAttrs(attrs) {\n      _checkAttrs(this.attrs, attrs, \"node\", this.name);\n    }\n  }, {\n    key: \"allowsMarkType\",\n    value: function allowsMarkType(markType) {\n      return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n  }, {\n    key: \"allowsMarks\",\n    value: function allowsMarks(marks) {\n      if (this.markSet == null) return true;\n      for (var i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false;\n      return true;\n    }\n  }, {\n    key: \"allowedMarks\",\n    value: function allowedMarks(marks) {\n      if (this.markSet == null) return marks;\n      var copy;\n      for (var i = 0; i < marks.length; i++) {\n        if (!this.allowsMarkType(marks[i].type)) {\n          if (!copy) copy = marks.slice(0, i);\n        } else if (copy) {\n          copy.push(marks[i]);\n        }\n      }\n      return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(nodes, schema) {\n      var result = Object.create(null);\n      nodes.forEach(function (name, spec) {\n        return result[name] = new NodeType(name, schema, spec);\n      });\n      var topType = schema.spec.topNode || \"doc\";\n      if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n      if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\");\n      for (var _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\");\n      return result;\n    }\n  }]);\n  return NodeType;\n}();\nfunction validateType(typeName, attrName, type) {\n  var types = type.split(\"|\");\n  return function (value) {\n    var name = value === null ? \"null\" : _typeof(value);\n    if (types.indexOf(name) < 0) throw new RangeError(\"Expected value of type \".concat(types, \" for attribute \").concat(attrName, \" on type \").concat(typeName, \", got \").concat(name));\n  };\n}\nvar Attribute = function () {\n  function Attribute(typeName, attrName, options) {\n    _classCallCheck(this, Attribute);\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n    this[\"default\"] = options[\"default\"];\n    this.validate = typeof options.validate == \"string\" ? validateType(typeName, attrName, options.validate) : options.validate;\n  }\n  _createClass(Attribute, [{\n    key: \"isRequired\",\n    get: function get() {\n      return !this.hasDefault;\n    }\n  }]);\n  return Attribute;\n}();\nvar MarkType = function () {\n  function MarkType(name, rank, schema, spec) {\n    _classCallCheck(this, MarkType);\n    this.name = name;\n    this.rank = rank;\n    this.schema = schema;\n    this.spec = spec;\n    this.attrs = initAttrs(name, spec.attrs);\n    this.excluded = null;\n    var defaults = defaultAttrs(this.attrs);\n    this.instance = defaults ? new Mark(this, defaults) : null;\n  }\n  _createClass(MarkType, [{\n    key: \"create\",\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (!attrs && this.instance) return this.instance;\n      return new Mark(this, _computeAttrs(this.attrs, attrs));\n    }\n  }, {\n    key: \"removeFromSet\",\n    value: function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n        set = set.slice(0, i).concat(set.slice(i + 1));\n        i--;\n      }\n      return set;\n    }\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) if (set[i].type == this) return set[i];\n    }\n  }, {\n    key: \"checkAttrs\",\n    value: function checkAttrs(attrs) {\n      _checkAttrs(this.attrs, attrs, \"mark\", this.name);\n    }\n  }, {\n    key: \"excludes\",\n    value: function excludes(other) {\n      return this.excluded.indexOf(other) > -1;\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(marks, schema) {\n      var result = Object.create(null),\n        rank = 0;\n      marks.forEach(function (name, spec) {\n        return result[name] = new MarkType(name, rank++, schema, spec);\n      });\n      return result;\n    }\n  }]);\n  return MarkType;\n}();\nvar Schema = function () {\n  function Schema(spec) {\n    var _this2 = this;\n    _classCallCheck(this, Schema);\n    this.linebreakReplacement = null;\n    this.cached = Object.create(null);\n    var instanceSpec = this.spec = {};\n    for (var prop in spec) instanceSpec[prop] = spec[prop];\n    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);\n    this.marks = MarkType.compile(this.spec.marks, this);\n    var contentExprCache = Object.create(null);\n    for (var _prop in this.nodes) {\n      if (_prop in this.marks) throw new RangeError(_prop + \" can not be both a node and a mark\");\n      var type = this.nodes[_prop],\n        contentExpr = type.spec.content || \"\",\n        markExpr = type.spec.marks;\n      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n      type.inlineContent = type.contentMatch.inlineContent;\n      if (type.spec.linebreakReplacement) {\n        if (this.linebreakReplacement) throw new RangeError(\"Multiple linebreak nodes defined\");\n        if (!type.isInline || !type.isLeaf) throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n        this.linebreakReplacement = type;\n      }\n      type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n    }\n    for (var _prop2 in this.marks) {\n      var _type2 = this.marks[_prop2],\n        excl = _type2.spec.excludes;\n      _type2.excluded = excl == null ? [_type2] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n    }\n    this.nodeFromJSON = function (json) {\n      return Node.fromJSON(_this2, json);\n    };\n    this.markFromJSON = function (json) {\n      return Mark.fromJSON(_this2, json);\n    };\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n    this.cached.wrappings = Object.create(null);\n  }\n  _createClass(Schema, [{\n    key: \"node\",\n    value: function node(type) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var content = arguments.length > 2 ? arguments[2] : undefined;\n      var marks = arguments.length > 3 ? arguments[3] : undefined;\n      if (typeof type == \"string\") type = this.nodeType(type);else if (!(type instanceof NodeType)) throw new RangeError(\"Invalid node type: \" + type);else if (type.schema != this) throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n      return type.createChecked(attrs, content, marks);\n    }\n  }, {\n    key: \"text\",\n    value: function text(_text, marks) {\n      var type = this.nodes.text;\n      return new TextNode(type, type.defaultAttrs, _text, Mark.setFrom(marks));\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(type, attrs) {\n      if (typeof type == \"string\") type = this.marks[type];\n      return type.create(attrs);\n    }\n  }, {\n    key: \"nodeType\",\n    value: function nodeType(name) {\n      var found = this.nodes[name];\n      if (!found) throw new RangeError(\"Unknown node type: \" + name);\n      return found;\n    }\n  }]);\n  return Schema;\n}();\nfunction gatherMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i],\n      mark = schema.marks[name],\n      ok = mark;\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var _mark = schema.marks[prop];\n        if (name == \"_\" || _mark.spec.group && _mark.spec.group.split(\" \").indexOf(name) > -1) found.push(ok = _mark);\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n  }\n  return found;\n}\nfunction isTagRule(rule) {\n  return rule.tag != null;\n}\nfunction isStyleRule(rule) {\n  return rule.style != null;\n}\nvar DOMParser = function () {\n  function DOMParser(schema, rules) {\n    var _this3 = this;\n    _classCallCheck(this, DOMParser);\n    this.schema = schema;\n    this.rules = rules;\n    this.tags = [];\n    this.styles = [];\n    var matchedStyles = this.matchedStyles = [];\n    rules.forEach(function (rule) {\n      if (isTagRule(rule)) {\n        _this3.tags.push(rule);\n      } else if (isStyleRule(rule)) {\n        var prop = /[^=]*/.exec(rule.style)[0];\n        if (matchedStyles.indexOf(prop) < 0) matchedStyles.push(prop);\n        _this3.styles.push(rule);\n      }\n    });\n    this.normalizeLists = !this.tags.some(function (r) {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false;\n      var node = schema.nodes[r.node];\n      return node.contentMatch.matchType(node);\n    });\n  }\n  _createClass(DOMParser, [{\n    key: \"parse\",\n    value: function parse(dom) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = new ParseContext(this, options, false);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return context.finish();\n    }\n  }, {\n    key: \"parseSlice\",\n    value: function parseSlice(dom) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = new ParseContext(this, options, true);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return Slice.maxOpen(context.finish());\n    }\n  }, {\n    key: \"matchTag\",\n    value: function matchTag(dom, context, after) {\n      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n        var rule = this.tags[i];\n        if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n          if (rule.getAttrs) {\n            var result = rule.getAttrs(dom);\n            if (result === false) continue;\n            rule.attrs = result || undefined;\n          }\n          return rule;\n        }\n      }\n    }\n  }, {\n    key: \"matchStyle\",\n    value: function matchStyle(prop, value, context, after) {\n      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n        var rule = this.styles[i],\n          style = rule.style;\n        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;\n        if (rule.getAttrs) {\n          var result = rule.getAttrs(value);\n          if (result === false) continue;\n          rule.attrs = result || undefined;\n        }\n        return rule;\n      }\n    }\n  }], [{\n    key: \"schemaRules\",\n    value: function schemaRules(schema) {\n      var result = [];\n      function insert(rule) {\n        var priority = rule.priority == null ? 50 : rule.priority,\n          i = 0;\n        for (; i < result.length; i++) {\n          var next = result[i],\n            nextPriority = next.priority == null ? 50 : next.priority;\n          if (nextPriority < priority) break;\n        }\n        result.splice(i, 0, rule);\n      }\n      var _loop2 = function _loop2(name) {\n        var rules = schema.marks[name].spec.parseDOM;\n        if (rules) rules.forEach(function (rule) {\n          insert(rule = copy(rule));\n          if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;\n        });\n      };\n      for (var name in schema.marks) {\n        _loop2(name);\n      }\n      var _loop3 = function _loop3(_name3) {\n        var rules = schema.nodes[_name3].spec.parseDOM;\n        if (rules) rules.forEach(function (rule) {\n          insert(rule = copy(rule));\n          if (!(rule.node || rule.ignore || rule.mark)) rule.node = _name3;\n        });\n      };\n      for (var _name3 in schema.nodes) {\n        _loop3(_name3);\n      }\n      return result;\n    }\n  }, {\n    key: \"fromSchema\",\n    value: function fromSchema(schema) {\n      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n  }]);\n  return DOMParser;\n}();\nvar blockTags = {\n  address: true,\n  article: true,\n  aside: true,\n  blockquote: true,\n  canvas: true,\n  dd: true,\n  div: true,\n  dl: true,\n  fieldset: true,\n  figcaption: true,\n  figure: true,\n  footer: true,\n  form: true,\n  h1: true,\n  h2: true,\n  h3: true,\n  h4: true,\n  h5: true,\n  h6: true,\n  header: true,\n  hgroup: true,\n  hr: true,\n  li: true,\n  noscript: true,\n  ol: true,\n  output: true,\n  p: true,\n  pre: true,\n  section: true,\n  table: true,\n  tfoot: true,\n  ul: true\n};\nvar ignoreTags = {\n  head: true,\n  noscript: true,\n  object: true,\n  script: true,\n  style: true,\n  title: true\n};\nvar listTags = {\n  ol: true,\n  ul: true\n};\nvar OPT_PRESERVE_WS = 1,\n  OPT_PRESERVE_WS_FULL = 2,\n  OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nvar NodeContext = function () {\n  function NodeContext(type, attrs, marks, solid, match, options) {\n    _classCallCheck(this, NodeContext);\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.solid = solid;\n    this.options = options;\n    this.content = [];\n    this.activeMarks = Mark.none;\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  }\n  _createClass(NodeContext, [{\n    key: \"findWrapping\",\n    value: function findWrapping(node) {\n      if (!this.match) {\n        if (!this.type) return [];\n        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n        if (fill) {\n          this.match = this.type.contentMatch.matchFragment(fill);\n        } else {\n          var start = this.type.contentMatch,\n            wrap;\n          if (wrap = start.findWrapping(node.type)) {\n            this.match = start;\n            return wrap;\n          } else {\n            return null;\n          }\n        }\n      }\n      return this.match.findWrapping(node.type);\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(openEnd) {\n      if (!(this.options & OPT_PRESERVE_WS)) {\n        var last = this.content[this.content.length - 1],\n          m;\n        if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n          var text = last;\n          if (last.text.length == m[0].length) this.content.pop();else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n        }\n      }\n      var content = Fragment.from(this.content);\n      if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));\n      return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n  }, {\n    key: \"inlineContext\",\n    value: function inlineContext(node) {\n      if (this.type) return this.type.inlineContent;\n      if (this.content.length) return this.content[0].isInline;\n      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n  }]);\n  return NodeContext;\n}();\nvar ParseContext = function () {\n  function ParseContext(parser, options, isOpen) {\n    _classCallCheck(this, ParseContext);\n    this.parser = parser;\n    this.options = options;\n    this.isOpen = isOpen;\n    this.open = 0;\n    this.localPreserveWS = false;\n    var topNode = options.topNode,\n      topContext;\n    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n    if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);else if (isOpen) topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);\n    this.nodes = [topContext];\n    this.find = options.findPositions;\n    this.needsBlock = false;\n  }\n  _createClass(ParseContext, [{\n    key: \"top\",\n    get: function get() {\n      return this.nodes[this.open];\n    }\n  }, {\n    key: \"addDOM\",\n    value: function addDOM(dom, marks) {\n      if (dom.nodeType == 3) this.addTextNode(dom, marks);else if (dom.nodeType == 1) this.addElement(dom, marks);\n    }\n  }, {\n    key: \"addTextNode\",\n    value: function addTextNode(dom, marks) {\n      var value = dom.nodeValue;\n      var top = this.top,\n        preserveWS = top.options & OPT_PRESERVE_WS_FULL ? \"full\" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;\n      if (preserveWS === \"full\" || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n        if (!preserveWS) {\n          value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n          if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n            var nodeBefore = top.content[top.content.length - 1];\n            var domNodeBefore = dom.previousSibling;\n            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)) value = value.slice(1);\n          }\n        } else if (preserveWS !== \"full\") {\n          value = value.replace(/\\r?\\n|\\r/g, \" \");\n        } else {\n          value = value.replace(/\\r\\n?/g, \"\\n\");\n        }\n        if (value) this.insertNode(this.parser.schema.text(value), marks, !/\\S/.test(value));\n        this.findInText(dom);\n      } else {\n        this.findInside(dom);\n      }\n    }\n  }, {\n    key: \"addElement\",\n    value: function addElement(dom, marks, matchAfter) {\n      var outerWS = this.localPreserveWS,\n        top = this.top;\n      if (dom.tagName == \"PRE\" || /pre/.test(dom.style && dom.style.whiteSpace)) this.localPreserveWS = true;\n      var name = dom.nodeName.toLowerCase(),\n        ruleID;\n      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);\n      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n      out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n        this.findInside(dom);\n        this.ignoreFallback(dom, marks);\n      } else if (!rule || rule.skip || rule.closeParent) {\n        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);else if (rule && rule.skip.nodeType) dom = rule.skip;\n        var sync,\n          oldNeedsBlock = this.needsBlock;\n        if (blockTags.hasOwnProperty(name)) {\n          if (top.content.length && top.content[0].isInline && this.open) {\n            this.open--;\n            top = this.top;\n          }\n          sync = true;\n          if (!top.type) this.needsBlock = true;\n        } else if (!dom.firstChild) {\n          this.leafFallback(dom, marks);\n          break out;\n        }\n        var innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);\n        if (innerMarks) this.addAll(dom, innerMarks);\n        if (sync) this.sync(top);\n        this.needsBlock = oldNeedsBlock;\n      } else {\n        var _innerMarks = this.readStyles(dom, marks);\n        if (_innerMarks) this.addElementByRule(dom, rule, _innerMarks, rule.consuming === false ? ruleID : undefined);\n      }\n      this.localPreserveWS = outerWS;\n    }\n  }, {\n    key: \"leafFallback\",\n    value: function leafFallback(dom, marks) {\n      if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"), marks);\n    }\n  }, {\n    key: \"ignoreFallback\",\n    value: function ignoreFallback(dom, marks) {\n      if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text(\"-\"), marks, true);\n    }\n  }, {\n    key: \"readStyles\",\n    value: function readStyles(dom, marks) {\n      var _this4 = this;\n      var styles = dom.style;\n      if (styles && styles.length) for (var i = 0; i < this.parser.matchedStyles.length; i++) {\n        var name = this.parser.matchedStyles[i],\n          value = styles.getPropertyValue(name);\n        if (value) {\n          var _loop4 = function _loop4(_after) {\n              var rule = _this4.parser.matchStyle(name, value, _this4, _after);\n              if (!rule) {\n                after = _after;\n                return 0;\n              }\n              if (rule.ignore) return {\n                v: null\n              };\n              if (rule.clearMark) marks = marks.filter(function (m) {\n                return !rule.clearMark(m);\n              });else marks = marks.concat(_this4.parser.schema.marks[rule.mark].create(rule.attrs));\n              if (rule.consuming === false) _after = rule;else {\n                after = _after;\n                return 0;\n              }\n              after = _after;\n            },\n            _ret;\n          for (var after = undefined;;) {\n            _ret = _loop4(after);\n            if (_ret === 0) break;\n            if (_ret) return _ret.v;\n          }\n        }\n      }\n      return marks;\n    }\n  }, {\n    key: \"addElementByRule\",\n    value: function addElementByRule(dom, rule, marks, continueAfter) {\n      var _this5 = this;\n      var sync, nodeType;\n      if (rule.node) {\n        nodeType = this.parser.schema.nodes[rule.node];\n        if (!nodeType.isLeaf) {\n          var inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);\n          if (inner) {\n            sync = true;\n            marks = inner;\n          }\n        } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == \"BR\")) {\n          this.leafFallback(dom, marks);\n        }\n      } else {\n        var markType = this.parser.schema.marks[rule.mark];\n        marks = marks.concat(markType.create(rule.attrs));\n      }\n      var startIn = this.top;\n      if (nodeType && nodeType.isLeaf) {\n        this.findInside(dom);\n      } else if (continueAfter) {\n        this.addElement(dom, marks, continueAfter);\n      } else if (rule.getContent) {\n        this.findInside(dom);\n        rule.getContent(dom, this.parser.schema).forEach(function (node) {\n          return _this5.insertNode(node, marks, false);\n        });\n      } else {\n        var contentDOM = dom;\n        if (typeof rule.contentElement == \"string\") contentDOM = dom.querySelector(rule.contentElement);else if (typeof rule.contentElement == \"function\") contentDOM = rule.contentElement(dom);else if (rule.contentElement) contentDOM = rule.contentElement;\n        this.findAround(dom, contentDOM, true);\n        this.addAll(contentDOM, marks);\n        this.findAround(dom, contentDOM, false);\n      }\n      if (sync && this.sync(startIn)) this.open--;\n    }\n  }, {\n    key: \"addAll\",\n    value: function addAll(parent, marks, startIndex, endIndex) {\n      var index = startIndex || 0;\n      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n        this.findAtPoint(parent, index);\n        this.addDOM(dom, marks);\n      }\n      this.findAtPoint(parent, index);\n    }\n  }, {\n    key: \"findPlace\",\n    value: function findPlace(node, marks, cautious) {\n      var route, sync;\n      for (var depth = this.open, penalty = 0; depth >= 0; depth--) {\n        var cx = this.nodes[depth];\n        var _found2 = cx.findWrapping(node);\n        if (_found2 && (!route || route.length > _found2.length + penalty)) {\n          route = _found2;\n          sync = cx;\n          if (!_found2.length) break;\n        }\n        if (cx.solid) {\n          if (cautious) break;\n          penalty += 2;\n        }\n      }\n      if (!route) return null;\n      this.sync(sync);\n      for (var i = 0; i < route.length; i++) marks = this.enterInner(route[i], null, marks, false);\n      return marks;\n    }\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(node, marks, cautious) {\n      if (node.isInline && this.needsBlock && !this.top.type) {\n        var block = this.textblockFromContext();\n        if (block) marks = this.enterInner(block, null, marks);\n      }\n      var innerMarks = this.findPlace(node, marks, cautious);\n      if (innerMarks) {\n        this.closeExtra();\n        var top = this.top;\n        if (top.match) top.match = top.match.matchType(node.type);\n        var nodeMarks = Mark.none;\n        var _iterator = _createForOfIteratorHelper(innerMarks.concat(node.marks)),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var m = _step.value;\n            if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type)) nodeMarks = m.addToSet(nodeMarks);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        top.content.push(node.mark(nodeMarks));\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(type, attrs, marks, preserveWS) {\n      var innerMarks = this.findPlace(type.create(attrs), marks, false);\n      if (innerMarks) innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);\n      return innerMarks;\n    }\n  }, {\n    key: \"enterInner\",\n    value: function enterInner(type, attrs, marks) {\n      var solid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var preserveWS = arguments.length > 4 ? arguments[4] : undefined;\n      this.closeExtra();\n      var top = this.top;\n      top.match = top.match && top.match.matchType(type);\n      var options = wsOptionsFor(type, preserveWS, top.options);\n      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;\n      var applyMarks = Mark.none;\n      marks = marks.filter(function (m) {\n        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {\n          applyMarks = m.addToSet(applyMarks);\n          return false;\n        }\n        return true;\n      });\n      this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));\n      this.open++;\n      return marks;\n    }\n  }, {\n    key: \"closeExtra\",\n    value: function closeExtra() {\n      var openEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var i = this.nodes.length - 1;\n      if (i > this.open) {\n        for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n        this.nodes.length = this.open + 1;\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.open = 0;\n      this.closeExtra(this.isOpen);\n      return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));\n    }\n  }, {\n    key: \"sync\",\n    value: function sync(to) {\n      for (var i = this.open; i >= 0; i--) {\n        if (this.nodes[i] == to) {\n          this.open = i;\n          return true;\n        } else if (this.localPreserveWS) {\n          this.nodes[i].options |= OPT_PRESERVE_WS;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"currentPos\",\n    get: function get() {\n      this.closeExtra();\n      var pos = 0;\n      for (var i = this.open; i >= 0; i--) {\n        var content = this.nodes[i].content;\n        for (var j = content.length - 1; j >= 0; j--) pos += content[j].nodeSize;\n        if (i) pos++;\n      }\n      return pos;\n    }\n  }, {\n    key: \"findAtPoint\",\n    value: function findAtPoint(parent, offset) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;\n      }\n    }\n  }, {\n    key: \"findInside\",\n    value: function findInside(parent) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;\n      }\n    }\n  }, {\n    key: \"findAround\",\n    value: function findAround(parent, content, before) {\n      if (parent != content && this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n          var pos = content.compareDocumentPosition(this.find[i].node);\n          if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;\n        }\n      }\n    }\n  }, {\n    key: \"findInText\",\n    value: function findInText(textNode) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n      }\n    }\n  }, {\n    key: \"matchesContext\",\n    value: function matchesContext(context) {\n      var _this6 = this;\n      if (context.indexOf(\"|\") > -1) return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n      var parts = context.split(\"/\");\n      var option = this.options.context;\n      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n      var match = function match(i, depth) {\n        for (; i >= 0; i--) {\n          var part = parts[i];\n          if (part == \"\") {\n            if (i == parts.length - 1 || i == 0) continue;\n            for (; depth >= minDepth; depth--) if (match(i - 1, depth)) return true;\n            return false;\n          } else {\n            var next = depth > 0 || depth == 0 && useRoot ? _this6.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n            if (!next || next.name != part && !next.isInGroup(part)) return false;\n            depth--;\n          }\n        }\n        return true;\n      };\n      return match(parts.length - 1, this.open);\n    }\n  }, {\n    key: \"textblockFromContext\",\n    value: function textblockFromContext() {\n      var $context = this.options.context;\n      if ($context) for (var d = $context.depth; d >= 0; d--) {\n        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n        if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;\n      }\n      for (var name in this.parser.schema.nodes) {\n        var type = this.parser.schema.nodes[name];\n        if (type.isTextblock && type.defaultAttrs) return type;\n      }\n    }\n  }]);\n  return ParseContext;\n}();\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\nfunction copy(obj) {\n  var copy = {};\n  for (var prop in obj) copy[prop] = obj[prop];\n  return copy;\n}\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n  var _loop5 = function _loop5() {\n      var parent = nodes[name];\n      if (!parent.allowsMarkType(markType)) return 0;\n      var seen = [],\n        scan = function scan(match) {\n          seen.push(match);\n          for (var i = 0; i < match.edgeCount; i++) {\n            var _match$edge = match.edge(i),\n              type = _match$edge.type,\n              next = _match$edge.next;\n            if (type == nodeType) return true;\n            if (seen.indexOf(next) < 0 && scan(next)) return true;\n          }\n        };\n      if (scan(parent.contentMatch)) return {\n        v: true\n      };\n    },\n    _ret2;\n  for (var name in nodes) {\n    _ret2 = _loop5();\n    if (_ret2 === 0) continue;\n    if (_ret2) return _ret2.v;\n  }\n}\nvar DOMSerializer = function () {\n  function DOMSerializer(nodes, marks) {\n    _classCallCheck(this, DOMSerializer);\n    this.nodes = nodes;\n    this.marks = marks;\n  }\n  _createClass(DOMSerializer, [{\n    key: \"serializeFragment\",\n    value: function serializeFragment(fragment) {\n      var _this7 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var target = arguments.length > 2 ? arguments[2] : undefined;\n      if (!target) target = doc(options).createDocumentFragment();\n      var top = target,\n        active = [];\n      fragment.forEach(function (node) {\n        if (active.length || node.marks.length) {\n          var keep = 0,\n            rendered = 0;\n          while (keep < active.length && rendered < node.marks.length) {\n            var next = node.marks[rendered];\n            if (!_this7.marks[next.type.name]) {\n              rendered++;\n              continue;\n            }\n            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;\n            keep++;\n            rendered++;\n          }\n          while (keep < active.length) top = active.pop()[1];\n          while (rendered < node.marks.length) {\n            var add = node.marks[rendered++];\n            var markDOM = _this7.serializeMark(add, node.isInline, options);\n            if (markDOM) {\n              active.push([add, top]);\n              top.appendChild(markDOM.dom);\n              top = markDOM.contentDOM || markDOM.dom;\n            }\n          }\n        }\n        top.appendChild(_this7.serializeNodeInner(node, options));\n      });\n      return target;\n    }\n  }, {\n    key: \"serializeNodeInner\",\n    value: function serializeNodeInner(node, options) {\n      var _renderSpec2 = _renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs),\n        dom = _renderSpec2.dom,\n        contentDOM = _renderSpec2.contentDOM;\n      if (contentDOM) {\n        if (node.isLeaf) throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n        this.serializeFragment(node.content, options, contentDOM);\n      }\n      return dom;\n    }\n  }, {\n    key: \"serializeNode\",\n    value: function serializeNode(node) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var dom = this.serializeNodeInner(node, options);\n      for (var i = node.marks.length - 1; i >= 0; i--) {\n        var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n        if (wrap) {\n          (wrap.contentDOM || wrap.dom).appendChild(dom);\n          dom = wrap.dom;\n        }\n      }\n      return dom;\n    }\n  }, {\n    key: \"serializeMark\",\n    value: function serializeMark(mark, inline) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var toDOM = this.marks[mark.type.name];\n      return toDOM && _renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);\n    }\n  }], [{\n    key: \"renderSpec\",\n    value: function renderSpec(doc, structure) {\n      var xmlNS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var blockArraysIn = arguments.length > 3 ? arguments[3] : undefined;\n      return _renderSpec(doc, structure, xmlNS, blockArraysIn);\n    }\n  }, {\n    key: \"fromSchema\",\n    value: function fromSchema(schema) {\n      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n  }, {\n    key: \"nodesFromSchema\",\n    value: function nodesFromSchema(schema) {\n      var result = gatherToDOM(schema.nodes);\n      if (!result.text) result.text = function (node) {\n        return node.text;\n      };\n      return result;\n    }\n  }, {\n    key: \"marksFromSchema\",\n    value: function marksFromSchema(schema) {\n      return gatherToDOM(schema.marks);\n    }\n  }]);\n  return DOMSerializer;\n}();\nfunction gatherToDOM(obj) {\n  var result = {};\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) result[name] = toDOM;\n  }\n  return result;\n}\nfunction doc(options) {\n  return options.document || window.document;\n}\nvar suspiciousAttributeCache = new WeakMap();\nfunction suspiciousAttributes(attrs) {\n  var value = suspiciousAttributeCache.get(attrs);\n  if (value === undefined) suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));\n  return value;\n}\nfunction suspiciousAttributesInner(attrs) {\n  var result = null;\n  function scan(value) {\n    if (value && _typeof(value) == \"object\") {\n      if (Array.isArray(value)) {\n        if (typeof value[0] == \"string\") {\n          if (!result) result = [];\n          result.push(value);\n        } else {\n          for (var i = 0; i < value.length; i++) scan(value[i]);\n        }\n      } else {\n        for (var prop in value) scan(value[prop]);\n      }\n    }\n  }\n  scan(attrs);\n  return result;\n}\nfunction _renderSpec(doc, structure, xmlNS, blockArraysIn) {\n  if (typeof structure == \"string\") return {\n    dom: doc.createTextNode(structure)\n  };\n  if (structure.nodeType != null) return {\n    dom: structure\n  };\n  if (structure.dom && structure.dom.nodeType != null) return structure;\n  var tagName = structure[0],\n    suspicious;\n  if (typeof tagName != \"string\") throw new RangeError(\"Invalid array passed to renderSpec\");\n  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1) throw new RangeError(\"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.\");\n  var space = tagName.indexOf(\" \");\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n  var contentDOM;\n  var dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1],\n    start = 1;\n  if (attrs && _typeof(attrs) == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (var name in attrs) if (attrs[name] != null) {\n      var _space = name.indexOf(\" \");\n      if (_space > 0) dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);else if (name == \"style\" && dom.style) dom.style.cssText = attrs[name];else dom.setAttribute(name, attrs[name]);\n    }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start) throw new RangeError(\"Content hole must be the only child of its parent node\");\n      return {\n        dom: dom,\n        contentDOM: dom\n      };\n    } else {\n      var _renderSpec3 = _renderSpec(doc, child, xmlNS, blockArraysIn),\n        inner = _renderSpec3.dom,\n        innerContent = _renderSpec3.contentDOM;\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM) throw new RangeError(\"Multiple content holes\");\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return {\n    dom: dom,\n    contentDOM: contentDOM\n  };\n}\nexports.ContentMatch = ContentMatch;\nexports.DOMParser = DOMParser;\nexports.DOMSerializer = DOMSerializer;\nexports.Fragment = Fragment;\nexports.Mark = Mark;\nexports.MarkType = MarkType;\nexports.Node = Node;\nexports.NodeRange = NodeRange;\nexports.NodeType = NodeType;\nexports.ReplaceError = ReplaceError;\nexports.ResolvedPos = ResolvedPos;\nexports.Schema = Schema;\nexports.Slice = Slice;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLW1vZGVsQDEuMjUuMy9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7QUFDNzhCLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEO0FBQzdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsdUJBQXVCO0FBQ3JLLGtCQUFrQixxREFBcUQsNkJBQTZCLE9BQU8sbURBQW1ELDZDQUE2QyxtQkFBbUIsNERBQTRELGdCQUFnQixrRUFBa0Usd0JBQXdCO0FBQ3BZLDRDQUE0QyxrRUFBa0Usa0NBQWtDLDhCQUE4QjtBQUM5SywyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRywrQ0FBK0MsaUJBQWlCLEdBQUc7QUFDNVksaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDO0FBQ3BYLGtEQUFrRCwwRUFBMEUsZUFBZSw0QkFBNEIsbUZBQW1GO0FBQzFQLHdDQUF3Qyx1QkFBdUIseUZBQXlGO0FBQ3hKLG1DQUFtQyxnRUFBZ0Usc0RBQXNELCtEQUErRCxtQ0FBbUMsNkVBQTZFLHFDQUFxQyxpREFBaUQsOEJBQThCLHFCQUFxQiwwRUFBMEUscURBQXFELGVBQWUseUVBQXlFLEdBQUcsMkNBQTJDO0FBQ3R0QiwyQ0FBMkMsbUNBQW1DLHlDQUF5QyxPQUFPLHdE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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2REFBNkQ7QUFDckcsd0NBQXdDLGdFQUFnRTtBQUN4RztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUk7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsUUFBUTtBQUN0RztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZEQUE2RCxzQkFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0RBQStELHdCQUF3QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SkFBdUosNkZBQTZGO0FBQ3BQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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QUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLHVFQUF1RTtBQUM1SztBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLGNBQWM7QUFDZCxhQUFhIiwic291cmNlcyI6WyIvVXNlcnMvRWJvb3RoL2FnZW50X2NfZnJhbWV3b3JrL3NyYy9yZWFsdGltZV9jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLW1vZGVsQDEuMjUuMy9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpOyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyB0cnkgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9IGNhdGNoIChlKSB7IHJldHVybiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIjsgfSB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIE9yZGVyZWRNYXAgPSByZXF1aXJlKCdvcmRlcmVkbWFwJyk7XG5mdW5jdGlvbiBfZmluZERpZmZTdGFydChhLCBiLCBwb3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7OyBpKyspIHtcbiAgICBpZiAoaSA9PSBhLmNoaWxkQ291bnQgfHwgaSA9PSBiLmNoaWxkQ291bnQpIHJldHVybiBhLmNoaWxkQ291bnQgPT0gYi5jaGlsZENvdW50ID8gbnVsbCA6IHBvcztcbiAgICB2YXIgY2hpbGRBID0gYS5jaGlsZChpKSxcbiAgICAgIGNoaWxkQiA9IGIuY2hpbGQoaSk7XG4gICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKSByZXR1cm4gcG9zO1xuICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgY2hpbGRBLnRleHRbal0gPT0gY2hpbGRCLnRleHRbal07IGorKykgcG9zKys7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICB2YXIgaW5uZXIgPSBfZmluZERpZmZTdGFydChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvcyArIDEpO1xuICAgICAgaWYgKGlubmVyICE9IG51bGwpIHJldHVybiBpbm5lcjtcbiAgICB9XG4gICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgfVxufVxuZnVuY3Rpb24gX2ZpbmREaWZmRW5kKGEsIGIsIHBvc0EsIHBvc0IpIHtcbiAgZm9yICh2YXIgaUEgPSBhLmNoaWxkQ291bnQsIGlCID0gYi5jaGlsZENvdW50OzspIHtcbiAgICBpZiAoaUEgPT0gMCB8fCBpQiA9PSAwKSByZXR1cm4gaUEgPT0gaUIgPyBudWxsIDoge1xuICAgICAgYTogcG9zQSxcbiAgICAgIGI6IHBvc0JcbiAgICB9O1xuICAgIHZhciBjaGlsZEEgPSBhLmNoaWxkKC0taUEpLFxuICAgICAgY2hpbGRCID0gYi5jaGlsZCgtLWlCKSxcbiAgICAgIHNpemUgPSBjaGlsZEEubm9kZVNpemU7XG4gICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpIHJldHVybiB7XG4gICAgICBhOiBwb3NBLFxuICAgICAgYjogcG9zQlxuICAgIH07XG4gICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgIHZhciBzYW1lID0gMCxcbiAgICAgICAgbWluU2l6ZSA9IE1hdGgubWluKGNoaWxkQS50ZXh0Lmxlbmd0aCwgY2hpbGRCLnRleHQubGVuZ3RoKTtcbiAgICAgIHdoaWxlIChzYW1lIDwgbWluU2l6ZSAmJiBjaGlsZEEudGV4dFtjaGlsZEEudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0gPT0gY2hpbGRCLnRleHRbY2hpbGRCLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdKSB7XG4gICAgICAgIHNhbWUrKztcbiAgICAgICAgcG9zQS0tO1xuICAgICAgICBwb3NCLS07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBwb3NBLFxuICAgICAgICBiOiBwb3NCXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICB2YXIgaW5uZXIgPSBfZmluZERpZmZFbmQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3NBIC0gMSwgcG9zQiAtIDEpO1xuICAgICAgaWYgKGlubmVyKSByZXR1cm4gaW5uZXI7XG4gICAgfVxuICAgIHBvc0EgLT0gc2l6ZTtcbiAgICBwb3NCIC09IHNpemU7XG4gIH1cbn1cbnZhciBGcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhZ21lbnQoY29udGVudCwgc2l6ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcmFnbWVudCk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLnNpemUgPSBzaXplIHx8IDA7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB0aGlzLnNpemUgKz0gY29udGVudFtpXS5ub2RlU2l6ZTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRnJhZ21lbnQsIFt7XG4gICAga2V5OiBcIm5vZGVzQmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYpIHtcbiAgICAgIHZhciBub2RlU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgcGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sXG4gICAgICAgICAgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmIChlbmQgPiBmcm9tICYmIGYoY2hpbGQsIG5vZGVTdGFydCArIHBvcywgcGFyZW50IHx8IG51bGwsIGkpICE9PSBmYWxzZSAmJiBjaGlsZC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgIGNoaWxkLm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBmcm9tIC0gc3RhcnQpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gc3RhcnQpLCBmLCBub2RlU3RhcnQgKyBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXNjZW5kYW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNjZW5kYW50cyhmKSB7XG4gICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLnNpemUsIGYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0QmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICB2YXIgdGV4dCA9IFwiXCIsXG4gICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICAgIHZhciBub2RlVGV4dCA9IG5vZGUuaXNUZXh0ID8gbm9kZS50ZXh0LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKSA6ICFub2RlLmlzTGVhZiA/IFwiXCIgOiBsZWFmVGV4dCA/IHR5cGVvZiBsZWFmVGV4dCA9PT0gXCJmdW5jdGlvblwiID8gbGVhZlRleHQobm9kZSkgOiBsZWFmVGV4dCA6IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0ID8gbm9kZS50eXBlLnNwZWMubGVhZlRleHQobm9kZSkgOiBcIlwiO1xuICAgICAgICBpZiAobm9kZS5pc0Jsb2NrICYmIChub2RlLmlzTGVhZiAmJiBub2RlVGV4dCB8fCBub2RlLmlzVGV4dGJsb2NrKSAmJiBibG9ja1NlcGFyYXRvcikge1xuICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTtlbHNlIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCArPSBub2RlVGV4dDtcbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQob3RoZXIpIHtcbiAgICAgIGlmICghb3RoZXIuc2l6ZSkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoIXRoaXMuc2l6ZSkgcmV0dXJuIG90aGVyO1xuICAgICAgdmFyIGxhc3QgPSB0aGlzLmxhc3RDaGlsZCxcbiAgICAgICAgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLFxuICAgICAgICBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCksXG4gICAgICAgIGkgPSAwO1xuICAgICAgaWYgKGxhc3QuaXNUZXh0ICYmIGxhc3Quc2FtZU1hcmt1cChmaXJzdCkpIHtcbiAgICAgICAgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID0gbGFzdC53aXRoVGV4dChsYXN0LnRleHQgKyBmaXJzdC50ZXh0KTtcbiAgICAgICAgaSA9IDE7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IG90aGVyLmNvbnRlbnQubGVuZ3RoOyBpKyspIGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTtcbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCwgdGhpcy5zaXplICsgb3RoZXIuc2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXQoZnJvbSkge1xuICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNpemU7XG4gICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuc2l6ZSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIHNpemUgPSAwO1xuICAgICAgaWYgKHRvID4gZnJvbSkgZm9yICh2YXIgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jb250ZW50W2ldLFxuICAgICAgICAgIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgICAgIGlmIChwb3MgPCBmcm9tIHx8IGVuZCA+IHRvKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7ZWxzZSBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zIC0gMSksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBwb3MgLSAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBzaXplICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQocmVzdWx0LCBzaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3V0QnlJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXRCeUluZGV4KGZyb20sIHRvKSB7XG4gICAgICBpZiAoZnJvbSA9PSB0bykgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlQ2hpbGQoaW5kZXgsIG5vZGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgIGlmIChjdXJyZW50ID09IG5vZGUpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSAtIGN1cnJlbnQubm9kZVNpemU7XG4gICAgICBjb3B5W2luZGV4XSA9IG5vZGU7XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb1N0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRvU3RhcnQobm9kZSkge1xuICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZV0uY29uY2F0KHRoaXMuY29udGVudCksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb0VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb0VuZChub2RlKSB7XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5jb25jYXQobm9kZSksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggIT0gb3RoZXIuY29udGVudC5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKSBpZiAoIXRoaXMuY29udGVudFtpXS5lcShvdGhlci5jb250ZW50W2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0Q2hpbGRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZENvdW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGQoaW5kZXgpIHtcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICBpZiAoIWZvdW5kKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IFwiICsgaW5kZXggKyBcIiBvdXQgb2YgcmFuZ2UgZm9yIFwiICsgdGhpcyk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heWJlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtpbmRleF0gfHwgbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgIGYoY2hpbGQsIHAsIGkpO1xuICAgICAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kRGlmZlN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmREaWZmU3RhcnQob3RoZXIpIHtcbiAgICAgIHZhciBwb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICByZXR1cm4gX2ZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmREaWZmRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmREaWZmRW5kKG90aGVyKSB7XG4gICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNpemU7XG4gICAgICB2YXIgb3RoZXJQb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG90aGVyLnNpemU7XG4gICAgICByZXR1cm4gX2ZpbmREaWZmRW5kKHRoaXMsIG90aGVyLCBwb3MsIG90aGVyUG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJbmRleChwb3MpIHtcbiAgICAgIGlmIChwb3MgPT0gMCkgcmV0dXJuIHJldEluZGV4KDAsIHBvcyk7XG4gICAgICBpZiAocG9zID09IHRoaXMuc2l6ZSkgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcyk7XG4gICAgICBpZiAocG9zID4gdGhpcy5zaXplIHx8IHBvcyA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUG9zaXRpb24gXCIuY29uY2F0KHBvcywgXCIgb3V0c2lkZSBvZiBmcmFnbWVudCAoXCIpLmNvbmNhdCh0aGlzLCBcIilcIikpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuY2hpbGQoaSksXG4gICAgICAgICAgZW5kID0gY3VyUG9zICsgY3VyLm5vZGVTaXplO1xuICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgIGlmIChlbmQgPT0gcG9zKSByZXR1cm4gcmV0SW5kZXgoaSArIDEsIGVuZCk7XG4gICAgICAgICAgcmV0dXJuIHJldEluZGV4KGksIGN1clBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIjxcIiArIHRoaXMudG9TdHJpbmdJbm5lcigpICsgXCI+XCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmdJbm5lcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuam9pbihcIiwgXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnQubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuLnRvSlNPTigpO1xuICAgICAgfSkgOiBudWxsO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwgdmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRnJhZ21lbnQuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgIGlmICghYXJyYXkubGVuZ3RoKSByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICB2YXIgam9pbmVkLFxuICAgICAgICBzaXplID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgc2l6ZSArPSBub2RlLm5vZGVTaXplO1xuICAgICAgICBpZiAoaSAmJiBub2RlLmlzVGV4dCAmJiBhcnJheVtpIC0gMV0uc2FtZU1hcmt1cChub2RlKSkge1xuICAgICAgICAgIGlmICgham9pbmVkKSBqb2luZWQgPSBhcnJheS5zbGljZSgwLCBpKTtcbiAgICAgICAgICBqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdID0gbm9kZS53aXRoVGV4dChqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdLnRleHQgKyBub2RlLnRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGpvaW5lZCkge1xuICAgICAgICAgIGpvaW5lZC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGpvaW5lZCB8fCBhcnJheSwgc2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShub2Rlcykge1xuICAgICAgaWYgKCFub2RlcykgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRnJhZ21lbnQpIHJldHVybiBub2RlcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgIGlmIChub2Rlcy5hdHRycykgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbiBub3QgY29udmVydCBcIiArIG5vZGVzICsgXCIgdG8gYSBGcmFnbWVudFwiICsgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRnJhZ21lbnQ7XG59KCk7XG5GcmFnbWVudC5lbXB0eSA9IG5ldyBGcmFnbWVudChbXSwgMCk7XG52YXIgZm91bmQgPSB7XG4gIGluZGV4OiAwLFxuICBvZmZzZXQ6IDBcbn07XG5mdW5jdGlvbiByZXRJbmRleChpbmRleCwgb2Zmc2V0KSB7XG4gIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gIGZvdW5kLm9mZnNldCA9IG9mZnNldDtcbiAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGlmICghKGEgJiYgX3R5cGVvZihhKSA9PSBcIm9iamVjdFwiKSB8fCAhKGIgJiYgX3R5cGVvZihiKSA9PSBcIm9iamVjdFwiKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xuICBpZiAoQXJyYXkuaXNBcnJheShiKSAhPSBhcnJheSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYXJyYXkpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIGlmICghY29tcGFyZURlZXAoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBwIGluIGEpIGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgX3AgaW4gYikgaWYgKCEoX3AgaW4gYSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBNYXJrID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXJrKHR5cGUsIGF0dHJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmspO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhNYXJrLCBbe1xuICAgIGtleTogXCJhZGRUb1NldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb1NldChzZXQpIHtcbiAgICAgIHZhciBjb3B5LFxuICAgICAgICBwbGFjZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHNldFtpXTtcbiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKSByZXR1cm4gc2V0O1xuICAgICAgICBpZiAodGhpcy50eXBlLmV4Y2x1ZGVzKG90aGVyLnR5cGUpKSB7XG4gICAgICAgICAgaWYgKCFjb3B5KSBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICB9IGVsc2UgaWYgKG90aGVyLnR5cGUuZXhjbHVkZXModGhpcy50eXBlKSkge1xuICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFwbGFjZWQgJiYgb3RoZXIudHlwZS5yYW5rID4gdGhpcy50eXBlLnJhbmspIHtcbiAgICAgICAgICAgIGlmICghY29weSkgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5KSBjb3B5LnB1c2gob3RoZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNvcHkpIGNvcHkgPSBzZXQuc2xpY2UoKTtcbiAgICAgIGlmICghcGxhY2VkKSBjb3B5LnB1c2godGhpcyk7XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRnJvbVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIGlmICh0aGlzLmVxKHNldFtpXSkpIHJldHVybiBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJblNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0luU2V0KHNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIGlmICh0aGlzLmVxKHNldFtpXSkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy50eXBlID09IG90aGVyLnR5cGUgJiYgY29tcGFyZURlZXAodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLm5hbWVcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKCFqc29uKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICB2YXIgdHlwZSA9IHNjaGVtYS5tYXJrc1tqc29uLnR5cGVdO1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIG1hcmsgdHlwZSBcIi5jb25jYXQoanNvbi50eXBlLCBcIiBpbiB0aGlzIHNjaGVtYVwiKSk7XG4gICAgICB2YXIgbWFyayA9IHR5cGUuY3JlYXRlKGpzb24uYXR0cnMpO1xuICAgICAgdHlwZS5jaGVja0F0dHJzKG1hcmsuYXR0cnMpO1xuICAgICAgcmV0dXJuIG1hcms7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhbWVTZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FtZVNldChhLCBiKSB7XG4gICAgICBpZiAoYSA9PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSBpZiAoIWFbaV0uZXEoYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb20obWFya3MpIHtcbiAgICAgIGlmICghbWFya3MgfHwgQXJyYXkuaXNBcnJheShtYXJrcykgJiYgbWFya3MubGVuZ3RoID09IDApIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKSByZXR1cm4gW21hcmtzXTtcbiAgICAgIHZhciBjb3B5ID0gbWFya3Muc2xpY2UoKTtcbiAgICAgIGNvcHkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS50eXBlLnJhbmsgLSBiLnR5cGUucmFuaztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYXJrO1xufSgpO1xuTWFyay5ub25lID0gW107XG52YXIgUmVwbGFjZUVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoUmVwbGFjZUVycm9yLCBfRXJyb3IpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJlcGxhY2VFcnJvcik7XG4gIGZ1bmN0aW9uIFJlcGxhY2VFcnJvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwbGFjZUVycm9yKTtcbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSZXBsYWNlRXJyb3IpO1xufShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG52YXIgU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbGljZSk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB0aGlzLm9wZW5FbmQgPSBvcGVuRW5kO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhTbGljZSwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zaXplIC0gdGhpcy5vcGVuU3RhcnQgLSB0aGlzLm9wZW5FbmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KHBvcywgZnJhZ21lbnQpIHtcbiAgICAgIHZhciBjb250ZW50ID0gaW5zZXJ0SW50byh0aGlzLmNvbnRlbnQsIHBvcyArIHRoaXMub3BlblN0YXJ0LCBmcmFnbWVudCk7XG4gICAgICByZXR1cm4gY29udGVudCAmJiBuZXcgU2xpY2UoY29udGVudCwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUJldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIG5ldyBTbGljZShyZW1vdmVSYW5nZSh0aGlzLmNvbnRlbnQsIGZyb20gKyB0aGlzLm9wZW5TdGFydCwgdG8gKyB0aGlzLm9wZW5TdGFydCksIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSAmJiB0aGlzLm9wZW5TdGFydCA9PSBvdGhlci5vcGVuU3RhcnQgJiYgdGhpcy5vcGVuRW5kID09IG90aGVyLm9wZW5FbmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudCArIFwiKFwiICsgdGhpcy5vcGVuU3RhcnQgKyBcIixcIiArIHRoaXMub3BlbkVuZCArIFwiKVwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuc2l6ZSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIganNvbiA9IHtcbiAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50LnRvSlNPTigpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3BlblN0YXJ0ID4gMCkganNvbi5vcGVuU3RhcnQgPSB0aGlzLm9wZW5TdGFydDtcbiAgICAgIGlmICh0aGlzLm9wZW5FbmQgPiAwKSBqc29uLm9wZW5FbmQgPSB0aGlzLm9wZW5FbmQ7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgIGlmICghanNvbikgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgdmFyIG9wZW5TdGFydCA9IGpzb24ub3BlblN0YXJ0IHx8IDAsXG4gICAgICAgIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgICAgIGlmICh0eXBlb2Ygb3BlblN0YXJ0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wZW5FbmQgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heE9wZW4oZnJhZ21lbnQpIHtcbiAgICAgIHZhciBvcGVuSXNvbGF0aW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIG9wZW5TdGFydCA9IDAsXG4gICAgICAgIG9wZW5FbmQgPSAwO1xuICAgICAgZm9yICh2YXIgbiA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5maXJzdENoaWxkKSBvcGVuU3RhcnQrKztcbiAgICAgIGZvciAodmFyIF9uID0gZnJhZ21lbnQubGFzdENoaWxkOyBfbiAmJiAhX24uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFfbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgX24gPSBfbi5sYXN0Q2hpbGQpIG9wZW5FbmQrKztcbiAgICAgIHJldHVybiBuZXcgU2xpY2UoZnJhZ21lbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTbGljZTtcbn0oKTtcblNsaWNlLmVtcHR5ID0gbmV3IFNsaWNlKEZyYWdtZW50LmVtcHR5LCAwLCAwKTtcbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGNvbnRlbnQsIGZyb20sIHRvKSB7XG4gIHZhciBfY29udGVudCRmaW5kSW5kZXggPSBjb250ZW50LmZpbmRJbmRleChmcm9tKSxcbiAgICBpbmRleCA9IF9jb250ZW50JGZpbmRJbmRleC5pbmRleCxcbiAgICBvZmZzZXQgPSBfY29udGVudCRmaW5kSW5kZXgub2Zmc2V0LFxuICAgIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgdmFyIF9jb250ZW50JGZpbmRJbmRleDIgPSBjb250ZW50LmZpbmRJbmRleCh0byksXG4gICAgaW5kZXhUbyA9IF9jb250ZW50JGZpbmRJbmRleDIuaW5kZXgsXG4gICAgb2Zmc2V0VG8gPSBfY29udGVudCRmaW5kSW5kZXgyLm9mZnNldDtcbiAgaWYgKG9mZnNldCA9PSBmcm9tIHx8IGNoaWxkLmlzVGV4dCkge1xuICAgIGlmIChvZmZzZXRUbyAhPSB0byAmJiAhY29udGVudC5jaGlsZChpbmRleFRvKS5pc1RleHQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGZyb20pLmFwcGVuZChjb250ZW50LmN1dCh0bykpO1xuICB9XG4gIGlmIChpbmRleCAhPSBpbmRleFRvKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICByZXR1cm4gY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkocmVtb3ZlUmFuZ2UoY2hpbGQuY29udGVudCwgZnJvbSAtIG9mZnNldCAtIDEsIHRvIC0gb2Zmc2V0IC0gMSkpKTtcbn1cbmZ1bmN0aW9uIGluc2VydEludG8oY29udGVudCwgZGlzdCwgaW5zZXJ0LCBwYXJlbnQpIHtcbiAgdmFyIF9jb250ZW50JGZpbmRJbmRleDMgPSBjb250ZW50LmZpbmRJbmRleChkaXN0KSxcbiAgICBpbmRleCA9IF9jb250ZW50JGZpbmRJbmRleDMuaW5kZXgsXG4gICAgb2Zmc2V0ID0gX2NvbnRlbnQkZmluZEluZGV4My5vZmZzZXQsXG4gICAgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICBpZiAob2Zmc2V0ID09IGRpc3QgfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4LCBpbnNlcnQpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZGlzdCkuYXBwZW5kKGluc2VydCkuYXBwZW5kKGNvbnRlbnQuY3V0KGRpc3QpKTtcbiAgfVxuICB2YXIgaW5uZXIgPSBpbnNlcnRJbnRvKGNoaWxkLmNvbnRlbnQsIGRpc3QgLSBvZmZzZXQgLSAxLCBpbnNlcnQsIGNoaWxkKTtcbiAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiBfcmVwbGFjZSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICBpZiAoc2xpY2Uub3BlblN0YXJ0ID4gJGZyb20uZGVwdGgpIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnNlcnRlZCBjb250ZW50IGRlZXBlciB0aGFuIGluc2VydGlvbiBwb3NpdGlvblwiKTtcbiAgaWYgKCRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0ICE9ICR0by5kZXB0aCAtIHNsaWNlLm9wZW5FbmQpIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIik7XG4gIHJldHVybiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIDApO1xufVxuZnVuY3Rpb24gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCkge1xuICB2YXIgaW5kZXggPSAkZnJvbS5pbmRleChkZXB0aCksXG4gICAgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICBpZiAoaW5kZXggPT0gJHRvLmluZGV4KGRlcHRoKSAmJiBkZXB0aCA8ICRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgdmFyIGlubmVyID0gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCArIDEpO1xuICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKTtcbiAgfSBlbHNlIGlmICghc2xpY2UuY29udGVudC5zaXplKSB7XG4gICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpKTtcbiAgfSBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkge1xuICAgIHZhciBwYXJlbnQgPSAkZnJvbS5wYXJlbnQsXG4gICAgICBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgcmV0dXJuIGNsb3NlKHBhcmVudCwgY29udGVudC5jdXQoMCwgJGZyb20ucGFyZW50T2Zmc2V0KS5hcHBlbmQoc2xpY2UuY29udGVudCkuYXBwZW5kKGNvbnRlbnQuY3V0KCR0by5wYXJlbnRPZmZzZXQpKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9wcmVwYXJlU2xpY2VGb3JSZXBsYSA9IHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRmcm9tKSxcbiAgICAgIHN0YXJ0ID0gX3ByZXBhcmVTbGljZUZvclJlcGxhLnN0YXJ0LFxuICAgICAgZW5kID0gX3ByZXBhcmVTbGljZUZvclJlcGxhLmVuZDtcbiAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCBzdGFydCwgZW5kLCAkdG8sIGRlcHRoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSm9pbihtYWluLCBzdWIpIHtcbiAgaWYgKCFzdWIudHlwZS5jb21wYXRpYmxlQ29udGVudChtYWluLnR5cGUpKSB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiQ2Fubm90IGpvaW4gXCIgKyBzdWIudHlwZS5uYW1lICsgXCIgb250byBcIiArIG1haW4udHlwZS5uYW1lKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKCRiZWZvcmUsICRhZnRlciwgZGVwdGgpIHtcbiAgdmFyIG5vZGUgPSAkYmVmb3JlLm5vZGUoZGVwdGgpO1xuICBjaGVja0pvaW4obm9kZSwgJGFmdGVyLm5vZGUoZGVwdGgpKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhZGROb2RlKGNoaWxkLCB0YXJnZXQpIHtcbiAgdmFyIGxhc3QgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgaWYgKGxhc3QgPj0gMCAmJiBjaGlsZC5pc1RleHQgJiYgY2hpbGQuc2FtZU1hcmt1cCh0YXJnZXRbbGFzdF0pKSB0YXJnZXRbbGFzdF0gPSBjaGlsZC53aXRoVGV4dCh0YXJnZXRbbGFzdF0udGV4dCArIGNoaWxkLnRleHQpO2Vsc2UgdGFyZ2V0LnB1c2goY2hpbGQpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgdGFyZ2V0KSB7XG4gIHZhciBub2RlID0gKCRlbmQgfHwgJHN0YXJ0KS5ub2RlKGRlcHRoKTtcbiAgdmFyIHN0YXJ0SW5kZXggPSAwLFxuICAgIGVuZEluZGV4ID0gJGVuZCA/ICRlbmQuaW5kZXgoZGVwdGgpIDogbm9kZS5jaGlsZENvdW50O1xuICBpZiAoJHN0YXJ0KSB7XG4gICAgc3RhcnRJbmRleCA9ICRzdGFydC5pbmRleChkZXB0aCk7XG4gICAgaWYgKCRzdGFydC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICBzdGFydEluZGV4Kys7XG4gICAgfSBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgc3RhcnRJbmRleCsrO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIGFkZE5vZGUobm9kZS5jaGlsZChpKSwgdGFyZ2V0KTtcbiAgaWYgKCRlbmQgJiYgJGVuZC5kZXB0aCA9PSBkZXB0aCAmJiAkZW5kLnRleHRPZmZzZXQpIGFkZE5vZGUoJGVuZC5ub2RlQmVmb3JlLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gY2xvc2Uobm9kZSwgY29udGVudCkge1xuICBub2RlLnR5cGUuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICByZXR1cm4gbm9kZS5jb3B5KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGgpIHtcbiAgdmFyIG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKTtcbiAgdmFyIG9wZW5FbmQgPSAkdG8uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZW5kLCAkdG8sIGRlcHRoICsgMSk7XG4gIHZhciBjb250ZW50ID0gW107XG4gIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gIGlmIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiAkc3RhcnQuaW5kZXgoZGVwdGgpID09ICRlbmQuaW5kZXgoZGVwdGgpKSB7XG4gICAgY2hlY2tKb2luKG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3BlblN0YXJ0KSBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKG9wZW5FbmQpIGFkZE5vZGUoY2xvc2Uob3BlbkVuZCwgcmVwbGFjZVR3b1dheSgkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfVxuICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgaWYgKCRmcm9tLmRlcHRoID4gZGVwdGgpIHtcbiAgICB2YXIgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgYWRkTm9kZShjbG9zZSh0eXBlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfVxuICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRhbG9uZykge1xuICB2YXIgZXh0cmEgPSAkYWxvbmcuZGVwdGggLSBzbGljZS5vcGVuU3RhcnQsXG4gICAgcGFyZW50ID0gJGFsb25nLm5vZGUoZXh0cmEpO1xuICB2YXIgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuICBmb3IgKHZhciBpID0gZXh0cmEgLSAxOyBpID49IDA7IGktLSkgbm9kZSA9ICRhbG9uZy5ub2RlKGkpLmNvcHkoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUoc2xpY2Uub3BlblN0YXJ0ICsgZXh0cmEpLFxuICAgIGVuZDogbm9kZS5yZXNvbHZlTm9DYWNoZShub2RlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQgLSBleHRyYSlcbiAgfTtcbn1cbnZhciBSZXNvbHZlZFBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzb2x2ZWRQb3MpO1xuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5wYXJlbnRPZmZzZXQgPSBwYXJlbnRPZmZzZXQ7XG4gICAgdGhpcy5kZXB0aCA9IHBhdGgubGVuZ3RoIC8gMyAtIDE7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFJlc29sdmVkUG9zLCBbe1xuICAgIGtleTogXCJyZXNvbHZlRGVwdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZURlcHRoKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSByZXR1cm4gdGhpcy5kZXB0aDtcbiAgICAgIGlmICh2YWwgPCAwKSByZXR1cm4gdGhpcy5kZXB0aCArIHZhbDtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcmVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZSh0aGlzLmRlcHRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9jXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGUoZGVwdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogM107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4KGRlcHRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDMgKyAxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5kZXhBZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleEFmdGVyKGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4KGRlcHRoKSArIChkZXB0aCA9PSB0aGlzLmRlcHRoICYmICF0aGlzLnRleHRPZmZzZXQgPyAwIDogMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIHJldHVybiBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZGVwdGgpICsgdGhpcy5ub2RlKGRlcHRoKS5jb250ZW50LnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmUoZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgaWYgKCFkZXB0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBiZWZvcmUgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyKGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIGlmICghZGVwdGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYWZ0ZXIgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyB0aGlzLnBhdGhbZGVwdGggKiAzXS5ub2RlU2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dE9mZnNldFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZUFmdGVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaW5kZXgpO1xuICAgICAgcmV0dXJuIGRPZmYgPyBwYXJlbnQuY2hpbGQoaW5kZXgpLmN1dChkT2ZmKSA6IGNoaWxkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlQmVmb3JlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgdmFyIGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoZE9mZikgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkKGluZGV4KS5jdXQoMCwgZE9mZik7XG4gICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NBdEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc0F0SW5kZXgoaW5kZXgsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2RlcHRoICogM10sXG4gICAgICAgIHBvcyA9IGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykgcG9zICs9IG5vZGUuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXJrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrcygpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4KCk7XG4gICAgICBpZiAocGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwKSByZXR1cm4gTWFyay5ub25lO1xuICAgICAgaWYgKHRoaXMudGV4dE9mZnNldCkgcmV0dXJuIHBhcmVudC5jaGlsZChpbmRleCkubWFya3M7XG4gICAgICB2YXIgbWFpbiA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4IC0gMSksXG4gICAgICAgIG90aGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgaWYgKCFtYWluKSB7XG4gICAgICAgIHZhciB0bXAgPSBtYWluO1xuICAgICAgICBtYWluID0gb3RoZXI7XG4gICAgICAgIG90aGVyID0gdG1wO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmtzID0gbWFpbi5tYXJrcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW90aGVyIHx8ICFtYXJrc1tpXS5pc0luU2V0KG90aGVyLm1hcmtzKSkpIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya3NBY3Jvc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya3NBY3Jvc3MoJGVuZCkge1xuICAgICAgdmFyIGFmdGVyID0gdGhpcy5wYXJlbnQubWF5YmVDaGlsZCh0aGlzLmluZGV4KCkpO1xuICAgICAgaWYgKCFhZnRlciB8fCAhYWZ0ZXIuaXNJbmxpbmUpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG1hcmtzID0gYWZ0ZXIubWFya3MsXG4gICAgICAgIG5leHQgPSAkZW5kLnBhcmVudC5tYXliZUNoaWxkKCRlbmQuaW5kZXgoKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFuZXh0IHx8ICFtYXJrc1tpXS5pc0luU2V0KG5leHQubWFya3MpKSkgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGFyZWREZXB0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGFyZWREZXB0aChwb3MpIHtcbiAgICAgIGZvciAodmFyIGRlcHRoID0gdGhpcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aC0tKSBpZiAodGhpcy5zdGFydChkZXB0aCkgPD0gcG9zICYmIHRoaXMuZW5kKGRlcHRoKSA+PSBwb3MpIHJldHVybiBkZXB0aDtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJibG9ja1JhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJsb2NrUmFuZ2UoKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXM7XG4gICAgICB2YXIgcHJlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKSByZXR1cm4gb3RoZXIuYmxvY2tSYW5nZSh0aGlzKTtcbiAgICAgIGZvciAodmFyIGQgPSB0aGlzLmRlcHRoIC0gKHRoaXMucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdGhpcy5wb3MgPT0gb3RoZXIucG9zID8gMSA6IDApOyBkID49IDA7IGQtLSkgaWYgKG90aGVyLnBvcyA8PSB0aGlzLmVuZChkKSAmJiAoIXByZWQgfHwgcHJlZCh0aGlzLm5vZGUoZCkpKSkgcmV0dXJuIG5ldyBOb2RlUmFuZ2UodGhpcywgb3RoZXIsIGQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhbWVQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FtZVBhcmVudChvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXJlbnRPZmZzZXQgPT0gb3RoZXIucG9zIC0gb3RoZXIucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4KG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIucG9zID4gdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4ob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXMuZGVwdGg7IGkrKykgc3RyICs9IChzdHIgPyBcIi9cIiA6IFwiXCIpICsgdGhpcy5ub2RlKGkpLnR5cGUubmFtZSArIFwiX1wiICsgdGhpcy5pbmRleChpIC0gMSk7XG4gICAgICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUoZG9jLCBwb3MpIHtcbiAgICAgIGlmICghKHBvcyA+PSAwICYmIHBvcyA8PSBkb2MuY29udGVudC5zaXplKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQb3NpdGlvbiBcIiArIHBvcyArIFwiIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIHZhciBwYXRoID0gW107XG4gICAgICB2YXIgc3RhcnQgPSAwLFxuICAgICAgICBwYXJlbnRPZmZzZXQgPSBwb3M7XG4gICAgICBmb3IgKHZhciBub2RlID0gZG9jOzspIHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRlbnQkZmluZEluZCA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocGFyZW50T2Zmc2V0KSxcbiAgICAgICAgICBpbmRleCA9IF9ub2RlJGNvbnRlbnQkZmluZEluZC5pbmRleCxcbiAgICAgICAgICBvZmZzZXQgPSBfbm9kZSRjb250ZW50JGZpbmRJbmQub2Zmc2V0O1xuICAgICAgICB2YXIgcmVtID0gcGFyZW50T2Zmc2V0IC0gb2Zmc2V0O1xuICAgICAgICBwYXRoLnB1c2gobm9kZSwgaW5kZXgsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCFyZW0pIGJyZWFrO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZChpbmRleCk7XG4gICAgICAgIGlmIChub2RlLmlzVGV4dCkgYnJlYWs7XG4gICAgICAgIHBhcmVudE9mZnNldCA9IHJlbSAtIDE7XG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZUNhY2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlQ2FjaGVkKGRvYywgcG9zKSB7XG4gICAgICB2YXIgY2FjaGUgPSByZXNvbHZlQ2FjaGUuZ2V0KGRvYyk7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZS5lbHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsdCA9IGNhY2hlLmVsdHNbaV07XG4gICAgICAgICAgaWYgKGVsdC5wb3MgPT0gcG9zKSByZXR1cm4gZWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlQ2FjaGUuc2V0KGRvYywgY2FjaGUgPSBuZXcgUmVzb2x2ZUNhY2hlKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGNhY2hlLmVsdHNbY2FjaGUuaV0gPSBSZXNvbHZlZFBvcy5yZXNvbHZlKGRvYywgcG9zKTtcbiAgICAgIGNhY2hlLmkgPSAoY2FjaGUuaSArIDEpICUgcmVzb2x2ZUNhY2hlU2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZXNvbHZlZFBvcztcbn0oKTtcbnZhciBSZXNvbHZlQ2FjaGUgPSBfY3JlYXRlQ2xhc3MoZnVuY3Rpb24gUmVzb2x2ZUNhY2hlKCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzb2x2ZUNhY2hlKTtcbiAgdGhpcy5lbHRzID0gW107XG4gIHRoaXMuaSA9IDA7XG59KTtcbnZhciByZXNvbHZlQ2FjaGVTaXplID0gMTIsXG4gIHJlc29sdmVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTm9kZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlUmFuZ2UoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZVJhbmdlKTtcbiAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgdGhpcy4kdG8gPSAkdG87XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhOb2RlUmFuZ2UsIFt7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiR0by5hZnRlcih0aGlzLmRlcHRoICsgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcmVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSh0aGlzLmRlcHRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRJbmRleFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGZyb20uaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZEluZGV4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kdG8uaW5kZXhBZnRlcih0aGlzLmRlcHRoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5vZGVSYW5nZTtcbn0oKTtcbnZhciBlbXB0eUF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBOb2RlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlKHR5cGUsIGF0dHJzLCBjb250ZW50KSB7XG4gICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBNYXJrLm5vbmU7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGUpO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IEZyYWdtZW50LmVtcHR5O1xuICB9XG4gIF9jcmVhdGVDbGFzcyhOb2RlLCBbe1xuICAgIGtleTogXCJjaGlsZHJlblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jb250ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlU2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNMZWFmID8gMSA6IDIgKyB0aGlzLmNvbnRlbnQuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZENvdW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZChpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heWJlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGYpIHtcbiAgICAgIHRoaXMuY29udGVudC5mb3JFYWNoKGYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2Rlc0JldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmKSB7XG4gICAgICB2YXIgc3RhcnRQb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB0aGlzLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcywgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc2NlbmRhbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dENvbnRlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzTGVhZiAmJiB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCA/IHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KHRoaXMpIDogdGhpcy50ZXh0QmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgXCJcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRCZXR3ZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQudGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0Q2hpbGRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzYW1lTWFya3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbWVNYXJrdXAob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNNYXJrdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTWFya3VwKHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIGF0dHJzIHx8IHR5cGUuZGVmYXVsdEF0dHJzIHx8IGVtcHR5QXR0cnMpICYmIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrKG1hcmtzKSB7XG4gICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3V0KGZyb20pIHtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5jb250ZW50LnNpemU7XG4gICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5zaXplKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShmcm9tKSB7XG4gICAgICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuY29udGVudC5zaXplO1xuICAgICAgdmFyIGluY2x1ZGVQYXJlbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIGlmIChmcm9tID09IHRvKSByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICB2YXIgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksXG4gICAgICAgICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gICAgICB2YXIgZGVwdGggPSBpbmNsdWRlUGFyZW50cyA/IDAgOiAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgICB2YXIgc3RhcnQgPSAkZnJvbS5zdGFydChkZXB0aCksXG4gICAgICAgIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgIHZhciBjb250ZW50ID0gbm9kZS5jb250ZW50LmN1dCgkZnJvbS5wb3MgLSBzdGFydCwgJHRvLnBvcyAtIHN0YXJ0KTtcbiAgICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgJGZyb20uZGVwdGggLSBkZXB0aCwgJHRvLmRlcHRoIC0gZGVwdGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICByZXR1cm4gX3JlcGxhY2UodGhpcy5yZXNvbHZlKGZyb20pLCB0aGlzLnJlc29sdmUodG8pLCBzbGljZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2RlQXQocG9zKSB7XG4gICAgICBmb3IgKHZhciBub2RlID0gdGhpczs7KSB7XG4gICAgICAgIHZhciBfbm9kZSRjb250ZW50JGZpbmRJbmQyID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwb3MpLFxuICAgICAgICAgIGluZGV4ID0gX25vZGUkY29udGVudCRmaW5kSW5kMi5pbmRleCxcbiAgICAgICAgICBvZmZzZXQgPSBfbm9kZSRjb250ZW50JGZpbmRJbmQyLm9mZnNldDtcbiAgICAgICAgbm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChvZmZzZXQgPT0gcG9zIHx8IG5vZGUuaXNUZXh0KSByZXR1cm4gbm9kZTtcbiAgICAgICAgcG9zIC09IG9mZnNldCArIDE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoaWxkQWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGRBZnRlcihwb3MpIHtcbiAgICAgIHZhciBfdGhpcyRjb250ZW50JGZpbmRJbmQgPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyksXG4gICAgICAgIGluZGV4ID0gX3RoaXMkY29udGVudCRmaW5kSW5kLmluZGV4LFxuICAgICAgICBvZmZzZXQgPSBfdGhpcyRjb250ZW50JGZpbmRJbmQub2Zmc2V0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZEJlZm9yZShwb3MpIHtcbiAgICAgIGlmIChwb3MgPT0gMCkgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICAgIHZhciBfdGhpcyRjb250ZW50JGZpbmRJbmQyID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpLFxuICAgICAgICBpbmRleCA9IF90aGlzJGNvbnRlbnQkZmluZEluZDIuaW5kZXgsXG4gICAgICAgIG9mZnNldCA9IF90aGlzJGNvbnRlbnQkZmluZEluZDIub2Zmc2V0O1xuICAgICAgaWYgKG9mZnNldCA8IHBvcykgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgfTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBpbmRleDogaW5kZXggLSAxLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGUubm9kZVNpemVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShwb3MpIHtcbiAgICAgIHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVOb0NhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVOb0NhY2hlKHBvcykge1xuICAgICAgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmUodGhpcywgcG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VIYXNNYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmdlSGFzTWFyayhmcm9tLCB0bywgdHlwZSkge1xuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICBpZiAodG8gPiBmcm9tKSB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSkgZm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQmxvY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNCbG9jaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUZXh0YmxvY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlubGluZUNvbnRlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbmxpbmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVGV4dFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5pc1RleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTGVhZlwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQXRvbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5pc0F0b207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSkgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjtcbiAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRNYXRjaEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnRNYXRjaEF0KGluZGV4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCAwLCBpbmRleCk7XG4gICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5SZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlcGxhY2UoZnJvbSwgdG8pIHtcbiAgICAgIHZhciByZXBsYWNlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogRnJhZ21lbnQuZW1wdHk7XG4gICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiByZXBsYWNlbWVudC5jaGlsZENvdW50O1xuICAgICAgdmFyIG9uZSA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hGcmFnbWVudChyZXBsYWNlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgICB2YXIgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgaWYgKCF0d28gfHwgIXR3by52YWxpZEVuZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIGlmICghdGhpcy50eXBlLmFsbG93c01hcmtzKHJlcGxhY2VtZW50LmNoaWxkKGkpLm1hcmtzKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhblJlcGxhY2VXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlcGxhY2VXaXRoKGZyb20sIHRvLCB0eXBlLCBtYXJrcykge1xuICAgICAgaWYgKG1hcmtzICYmICF0aGlzLnR5cGUuYWxsb3dzTWFya3MobWFya3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgIHZhciBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgcmV0dXJuIGVuZCA/IGVuZC52YWxpZEVuZCA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5BcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuQXBwZW5kKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuY29udGVudC5zaXplKSByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KTtlbHNlIHJldHVybiB0aGlzLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQob3RoZXIudHlwZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgdGhpcy50eXBlLmNoZWNrQ29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgdGhpcy50eXBlLmNoZWNrQXR0cnModGhpcy5hdHRycyk7XG4gICAgICB2YXIgY29weSA9IE1hcmsubm9uZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWFyayA9IHRoaXMubWFya3NbaV07XG4gICAgICAgIG1hcmsudHlwZS5jaGVja0F0dHJzKG1hcmsuYXR0cnMpO1xuICAgICAgICBjb3B5ID0gbWFyay5hZGRUb1NldChjb3B5KTtcbiAgICAgIH1cbiAgICAgIGlmICghTWFyay5zYW1lU2V0KGNvcHksIHRoaXMubWFya3MpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29sbGVjdGlvbiBvZiBtYXJrcyBmb3Igbm9kZSBcIi5jb25jYXQodGhpcy50eXBlLm5hbWUsIFwiOiBcIikuY29uY2F0KHRoaXMubWFya3MubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnR5cGUubmFtZTtcbiAgICAgIH0pKSk7XG4gICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5jaGVjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUubmFtZVxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSkgb2JqLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQudG9KU09OKCk7XG4gICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpIG9iai5tYXJrcyA9IHRoaXMubWFya3MubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuLnRvSlNPTigpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKCFqc29uKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICB2YXIgbWFya3MgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoanNvbi5tYXJrcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtYXJrIGRhdGEgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgIG1hcmtzID0ganNvbi5tYXJrcy5tYXAoc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICB9XG4gICAgICBpZiAoanNvbi50eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi50ZXh0ICE9IFwic3RyaW5nXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0ZXh0IG5vZGUgaW4gSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS50ZXh0KGpzb24udGV4dCwgbWFya3MpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCk7XG4gICAgICB2YXIgbm9kZSA9IHNjaGVtYS5ub2RlVHlwZShqc29uLnR5cGUpLmNyZWF0ZShqc29uLmF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgICBub2RlLnR5cGUuY2hlY2tBdHRycyhub2RlLmF0dHJzKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZTtcbn0oKTtcbk5vZGUucHJvdG90eXBlLnRleHQgPSB1bmRlZmluZWQ7XG52YXIgVGV4dE5vZGUgPSBmdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKFRleHROb2RlLCBfTm9kZSk7XG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKFRleHROb2RlKTtcbiAgZnVuY3Rpb24gVGV4dE5vZGUodHlwZSwgYXR0cnMsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0Tm9kZSk7XG4gICAgX3RoaXMgPSBfc3VwZXIyLmNhbGwodGhpcywgdHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcbiAgICBpZiAoIWNvbnRlbnQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90IGFsbG93ZWRcIik7XG4gICAgX3RoaXMudGV4dCA9IGNvbnRlbnQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhUZXh0Tm9kZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZykgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIEpTT04uc3RyaW5naWZ5KHRoaXMudGV4dCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0Q29udGVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dEJldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dEJldHdlZW4oZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlU2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFyayhtYXJrcykge1xuICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhUZXh0KHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09IHRoaXMudGV4dCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGV4dCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXQoKSB7XG4gICAgICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy50ZXh0Lmxlbmd0aCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy53aXRoVGV4dCh0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGJhc2UgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihUZXh0Tm9kZS5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgYmFzZS50ZXh0ID0gdGhpcy50ZXh0O1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUZXh0Tm9kZTtcbn0oTm9kZSk7XG5mdW5jdGlvbiB3cmFwTWFya3MobWFya3MsIHN0cikge1xuICBmb3IgKHZhciBpID0gbWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHN0ciA9IG1hcmtzW2ldLnR5cGUubmFtZSArIFwiKFwiICsgc3RyICsgXCIpXCI7XG4gIHJldHVybiBzdHI7XG59XG52YXIgQ29udGVudE1hdGNoID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250ZW50TWF0Y2godmFsaWRFbmQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udGVudE1hdGNoKTtcbiAgICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gICAgdGhpcy5uZXh0ID0gW107XG4gICAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQ29udGVudE1hdGNoLCBbe1xuICAgIGtleTogXCJtYXRjaFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gdHlwZSkgcmV0dXJuIHRoaXMubmV4dFtpXS5uZXh0O1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoRnJhZ21lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hGcmFnbWVudChmcmFnKSB7XG4gICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmcmFnLmNoaWxkQ291bnQ7XG4gICAgICB2YXIgY3VyID0gdGhpcztcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgY3VyICYmIGkgPCBlbmQ7IGkrKykgY3VyID0gY3VyLm1hdGNoVHlwZShmcmFnLmNoaWxkKGkpLnR5cGUpO1xuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5saW5lQ29udGVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGggIT0gMCAmJiB0aGlzLm5leHRbMF0udHlwZS5pc0lubGluZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdFR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5uZXh0W2ldLnR5cGU7XG4gICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSkgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGF0aWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXRpYmxlKG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKykgZm9yICh2YXIgaiA9IDA7IGogPCBvdGhlci5uZXh0Lmxlbmd0aDsgaisrKSBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gb3RoZXIubmV4dFtqXS50eXBlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsbEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsQmVmb3JlKGFmdGVyKSB7XG4gICAgICB2YXIgdG9FbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICB2YXIgc2VlbiA9IFt0aGlzXTtcbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChtYXRjaCwgdHlwZXMpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgICAgIGlmIChmaW5pc2hlZCAmJiAoIXRvRW5kIHx8IGZpbmlzaGVkLnZhbGlkRW5kKSkgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKGZ1bmN0aW9uICh0cCkge1xuICAgICAgICAgIHJldHVybiB0cC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9tYXRjaCRuZXh0JGkgPSBtYXRjaC5uZXh0W2ldLFxuICAgICAgICAgICAgdHlwZSA9IF9tYXRjaCRuZXh0JGkudHlwZSxcbiAgICAgICAgICAgIG5leHQgPSBfbWF0Y2gkbmV4dCRpLm5leHQ7XG4gICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpICYmIHNlZW4uaW5kZXhPZihuZXh0KSA9PSAtMSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgdmFyIF9mb3VuZCA9IHNlYXJjaChuZXh0LCB0eXBlcy5jb25jYXQodHlwZSkpO1xuICAgICAgICAgICAgaWYgKF9mb3VuZCkgcmV0dXJuIF9mb3VuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFdyYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53cmFwQ2FjaGUubGVuZ3RoOyBpICs9IDIpIGlmICh0aGlzLndyYXBDYWNoZVtpXSA9PSB0YXJnZXQpIHJldHVybiB0aGlzLndyYXBDYWNoZVtpICsgMV07XG4gICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVXcmFwcGluZyh0YXJnZXQpO1xuICAgICAgdGhpcy53cmFwQ2FjaGUucHVzaCh0YXJnZXQsIGNvbXB1dGVkKTtcbiAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZVdyYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgIHZhciBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgYWN0aXZlID0gW3tcbiAgICAgICAgICBtYXRjaDogdGhpcyxcbiAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgIHZpYTogbnVsbFxuICAgICAgICB9XTtcbiAgICAgIHdoaWxlIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gYWN0aXZlLnNoaWZ0KCksXG4gICAgICAgICAgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoO1xuICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgb2JqID0gY3VycmVudDsgb2JqLnR5cGU7IG9iaiA9IG9iai52aWEpIHJlc3VsdC5wdXNoKG9iai50eXBlKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX21hdGNoJG5leHQkaTIgPSBtYXRjaC5uZXh0W2ldLFxuICAgICAgICAgICAgdHlwZSA9IF9tYXRjaCRuZXh0JGkyLnR5cGUsXG4gICAgICAgICAgICBuZXh0ID0gX21hdGNoJG5leHQkaTIubmV4dDtcbiAgICAgICAgICBpZiAoIXR5cGUuaXNMZWFmICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSAmJiAhKHR5cGUubmFtZSBpbiBzZWVuKSAmJiAoIWN1cnJlbnQudHlwZSB8fCBuZXh0LnZhbGlkRW5kKSkge1xuICAgICAgICAgICAgYWN0aXZlLnB1c2goe1xuICAgICAgICAgICAgICBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2gsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIHZpYTogY3VycmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVkZ2VDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRnZShuKSB7XG4gICAgICBpZiAobiA+PSB0aGlzLm5leHQubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlJ3Mgbm8gXCIuY29uY2F0KG4sIFwidGggZWRnZSBpbiB0aGlzIGNvbnRlbnQgbWF0Y2hcIikpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFtuXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc2VlbiA9IFtdO1xuICAgICAgZnVuY3Rpb24gc2NhbihtKSB7XG4gICAgICAgIHNlZW4ucHVzaChtKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspIGlmIChzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpID09IC0xKSBzY2FuKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgIH1cbiAgICAgIHNjYW4odGhpcyk7XG4gICAgICByZXR1cm4gc2Vlbi5tYXAoZnVuY3Rpb24gKG0sIGkpIHtcbiAgICAgICAgdmFyIG91dCA9IGkgKyAobS52YWxpZEVuZCA/IFwiKlwiIDogXCIgXCIpICsgXCIgXCI7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtLm5leHQubGVuZ3RoOyBfaSsrKSBvdXQgKz0gKF9pID8gXCIsIFwiIDogXCJcIikgKyBtLm5leHRbX2ldLnR5cGUubmFtZSArIFwiLT5cIiArIHNlZW4uaW5kZXhPZihtLm5leHRbX2ldLm5leHQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgdmFyIHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gICAgICBpZiAoc3RyZWFtLm5leHQgPT0gbnVsbCkgcmV0dXJuIENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICAgIHZhciBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICBpZiAoc3RyZWFtLm5leHQpIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRyYWlsaW5nIHRleHRcIik7XG4gICAgICB2YXIgbWF0Y2ggPSBkZmEobmZhKGV4cHIpKTtcbiAgICAgIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb250ZW50TWF0Y2g7XG59KCk7XG5Db250ZW50TWF0Y2guZW1wdHkgPSBuZXcgQ29udGVudE1hdGNoKHRydWUpO1xudmFyIFRva2VuU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2tlblN0cmVhbSk7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5ub2RlVHlwZXMgPSBub2RlVHlwZXM7XG4gICAgdGhpcy5pbmxpbmUgPSBudWxsO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLnRva2VucyA9IHN0cmluZy5zcGxpdCgvXFxzKig/PVxcYnxcXFd8JCkvKTtcbiAgICBpZiAodGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gPT0gXCJcIikgdGhpcy50b2tlbnMucG9wKCk7XG4gICAgaWYgKHRoaXMudG9rZW5zWzBdID09IFwiXCIpIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFRva2VuU3RyZWFtLCBbe1xuICAgIGtleTogXCJuZXh0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWF0KHRvaykge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnIoc3RyKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3RyICsgXCIgKGluIGNvbnRlbnQgZXhwcmVzc2lvbiAnXCIgKyB0aGlzLnN0cmluZyArIFwiJylcIik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUb2tlblN0cmVhbTtcbn0oKTtcbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHJlYW0pIHtcbiAgdmFyIGV4cHJzID0gW107XG4gIGRvIHtcbiAgICBleHBycy5wdXNoKHBhcnNlRXhwclNlcShzdHJlYW0pKTtcbiAgfSB3aGlsZSAoc3RyZWFtLmVhdChcInxcIikpO1xuICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHtcbiAgICB0eXBlOiBcImNob2ljZVwiLFxuICAgIGV4cHJzOiBleHByc1xuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU2VxKHN0cmVhbSkge1xuICB2YXIgZXhwcnMgPSBbXTtcbiAgZG8ge1xuICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkpO1xuICB9IHdoaWxlIChzdHJlYW0ubmV4dCAmJiBzdHJlYW0ubmV4dCAhPSBcIilcIiAmJiBzdHJlYW0ubmV4dCAhPSBcInxcIik7XG4gIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDoge1xuICAgIHR5cGU6IFwic2VxXCIsXG4gICAgZXhwcnM6IGV4cHJzXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSB7XG4gIHZhciBleHByID0gcGFyc2VFeHByQXRvbShzdHJlYW0pO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKSBleHByID0ge1xuICAgICAgdHlwZTogXCJwbHVzXCIsXG4gICAgICBleHByOiBleHByXG4gICAgfTtlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkgZXhwciA9IHtcbiAgICAgIHR5cGU6IFwic3RhclwiLFxuICAgICAgZXhwcjogZXhwclxuICAgIH07ZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpIGV4cHIgPSB7XG4gICAgICB0eXBlOiBcIm9wdFwiLFxuICAgICAgZXhwcjogZXhwclxuICAgIH07ZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpIGV4cHIgPSBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpO2Vsc2UgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59XG5mdW5jdGlvbiBwYXJzZU51bShzdHJlYW0pIHtcbiAgaWYgKC9cXEQvLnRlc3Qoc3RyZWFtLm5leHQpKSBzdHJlYW0uZXJyKFwiRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gIHZhciByZXN1bHQgPSBOdW1iZXIoc3RyZWFtLm5leHQpO1xuICBzdHJlYW0ucG9zKys7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpIHtcbiAgdmFyIG1pbiA9IHBhcnNlTnVtKHN0cmVhbSksXG4gICAgbWF4ID0gbWluO1xuICBpZiAoc3RyZWFtLmVhdChcIixcIikpIHtcbiAgICBpZiAoc3RyZWFtLm5leHQgIT0gXCJ9XCIpIG1heCA9IHBhcnNlTnVtKHN0cmVhbSk7ZWxzZSBtYXggPSAtMTtcbiAgfVxuICBpZiAoIXN0cmVhbS5lYXQoXCJ9XCIpKSBzdHJlYW0uZXJyKFwiVW5jbG9zZWQgYnJhY2VkIHJhbmdlXCIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heCxcbiAgICBleHByOiBleHByXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgdmFyIHR5cGVzID0gc3RyZWFtLm5vZGVUeXBlcyxcbiAgICB0eXBlID0gdHlwZXNbbmFtZV07XG4gIGlmICh0eXBlKSByZXR1cm4gW3R5cGVdO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgdmFyIF90eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgIGlmIChfdHlwZS5pc0luR3JvdXAobmFtZSkpIHJlc3VsdC5wdXNoKF90eXBlKTtcbiAgfVxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PSAwKSBzdHJlYW0uZXJyKFwiTm8gbm9kZSB0eXBlIG9yIGdyb3VwICdcIiArIG5hbWUgKyBcIicgZm91bmRcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtLmVhdChcIihcIikpIHtcbiAgICB2YXIgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgIGlmICghc3RyZWFtLmVhdChcIilcIikpIHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7XG4gICAgcmV0dXJuIGV4cHI7XG4gIH0gZWxzZSBpZiAoIS9cXFcvLnRlc3Qoc3RyZWFtLm5leHQpKSB7XG4gICAgdmFyIGV4cHJzID0gcmVzb2x2ZU5hbWUoc3RyZWFtLCBzdHJlYW0ubmV4dCkubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBpZiAoc3RyZWFtLmlubGluZSA9PSBudWxsKSBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTtlbHNlIGlmIChzdHJlYW0uaW5saW5lICE9IHR5cGUuaXNJbmxpbmUpIHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuYW1lXCIsXG4gICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHN0cmVhbS5wb3MrKztcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHtcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBleHByczogZXhwcnNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICB9XG59XG5mdW5jdGlvbiBuZmEoZXhwcikge1xuICB2YXIgbmZhID0gW1tdXTtcbiAgY29ubmVjdChjb21waWxlKGV4cHIsIDApLCBub2RlKCkpO1xuICByZXR1cm4gbmZhO1xuICBmdW5jdGlvbiBub2RlKCkge1xuICAgIHJldHVybiBuZmEucHVzaChbXSkgLSAxO1xuICB9XG4gIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICB2YXIgZWRnZSA9IHtcbiAgICAgIHRlcm06IHRlcm0sXG4gICAgICB0bzogdG9cbiAgICB9O1xuICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgIHJldHVybiBlZGdlO1xuICB9XG4gIGZ1bmN0aW9uIGNvbm5lY3QoZWRnZXMsIHRvKSB7XG4gICAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UudG8gPSB0bztcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjb21waWxlKGV4cHIsIGZyb20pIHtcbiAgICBpZiAoZXhwci50eXBlID09IFwiY2hvaWNlXCIpIHtcbiAgICAgIHJldHVybiBleHByLmV4cHJzLnJlZHVjZShmdW5jdGlvbiAob3V0LCBleHByKSB7XG4gICAgICAgIHJldHVybiBvdXQuY29uY2F0KGNvbXBpbGUoZXhwciwgZnJvbSkpO1xuICAgICAgfSwgW10pO1xuICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY29tcGlsZShleHByLmV4cHJzW2ldLCBmcm9tKTtcbiAgICAgICAgaWYgKGkgPT0gZXhwci5leHBycy5sZW5ndGggLSAxKSByZXR1cm4gbmV4dDtcbiAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInN0YXJcIikge1xuICAgICAgdmFyIGxvb3AgPSBub2RlKCk7XG4gICAgICBlZGdlKGZyb20sIGxvb3ApO1xuICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInBsdXNcIikge1xuICAgICAgdmFyIF9sb29wID0gbm9kZSgpO1xuICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSksIF9sb29wKTtcbiAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIF9sb29wKSwgX2xvb3ApO1xuICAgICAgcmV0dXJuIFtlZGdlKF9sb29wKV07XG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJvcHRcIikge1xuICAgICAgcmV0dXJuIFtlZGdlKGZyb20pXS5jb25jYXQoY29tcGlsZShleHByLmV4cHIsIGZyb20pKTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInJhbmdlXCIpIHtcbiAgICAgIHZhciBjdXIgPSBmcm9tO1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZXhwci5taW47IF9pMisrKSB7XG4gICAgICAgIHZhciBfbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgX25leHQpO1xuICAgICAgICBjdXIgPSBfbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChleHByLm1heCA9PSAtMSkge1xuICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBjdXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gZXhwci5taW47IF9pMyA8IGV4cHIubWF4OyBfaTMrKykge1xuICAgICAgICAgIHZhciBfbmV4dDIgPSBub2RlKCk7XG4gICAgICAgICAgZWRnZShjdXIsIF9uZXh0Mik7XG4gICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgX25leHQyKTtcbiAgICAgICAgICBjdXIgPSBfbmV4dDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbZWRnZShjdXIpXTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIHVuZGVmaW5lZCwgZXhwci52YWx1ZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV4cHIgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNtcChhLCBiKSB7XG4gIHJldHVybiBiIC0gYTtcbn1cbmZ1bmN0aW9uIG51bGxGcm9tKG5mYSwgbm9kZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHNjYW4obm9kZSk7XG4gIHJldHVybiByZXN1bHQuc29ydChjbXApO1xuICBmdW5jdGlvbiBzY2FuKG5vZGUpIHtcbiAgICB2YXIgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgaWYgKGVkZ2VzLmxlbmd0aCA9PSAxICYmICFlZGdlc1swXS50ZXJtKSByZXR1cm4gc2NhbihlZGdlc1swXS50byk7XG4gICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9lZGdlcyRpID0gZWRnZXNbaV0sXG4gICAgICAgIHRlcm0gPSBfZWRnZXMkaS50ZXJtLFxuICAgICAgICB0byA9IF9lZGdlcyRpLnRvO1xuICAgICAgaWYgKCF0ZXJtICYmIHJlc3VsdC5pbmRleE9mKHRvKSA9PSAtMSkgc2Nhbih0byk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gIHZhciBsYWJlbGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIGV4cGxvcmUobnVsbEZyb20obmZhLCAwKSk7XG4gIGZ1bmN0aW9uIGV4cGxvcmUoc3RhdGVzKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBuZmFbbm9kZV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdGVybSA9IF9yZWYudGVybSxcbiAgICAgICAgICB0byA9IF9yZWYudG87XG4gICAgICAgIGlmICghdGVybSkgcmV0dXJuO1xuICAgICAgICB2YXIgc2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykgaWYgKG91dFtpXVswXSA9PSB0ZXJtKSBzZXQgPSBvdXRbaV1bMV07XG4gICAgICAgIG51bGxGcm9tKG5mYSwgdG8pLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIXNldCkgb3V0LnB1c2goW3Rlcm0sIHNldCA9IFtdXSk7XG4gICAgICAgICAgaWYgKHNldC5pbmRleE9mKG5vZGUpID09IC0xKSBzZXQucHVzaChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgc3RhdGUgPSBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gPSBuZXcgQ29udGVudE1hdGNoKHN0YXRlcy5pbmRleE9mKG5mYS5sZW5ndGggLSAxKSA+IC0xKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9zdGF0ZXMgPSBvdXRbaV1bMV0uc29ydChjbXApO1xuICAgICAgc3RhdGUubmV4dC5wdXNoKHtcbiAgICAgICAgdHlwZTogb3V0W2ldWzBdLFxuICAgICAgICBuZXh0OiBsYWJlbGVkW19zdGF0ZXMuam9pbihcIixcIildIHx8IGV4cGxvcmUoX3N0YXRlcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSkge1xuICBmb3IgKHZhciBpID0gMCwgd29yayA9IFttYXRjaF07IGkgPCB3b3JrLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXRlID0gd29ya1tpXSxcbiAgICAgIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsXG4gICAgICBub2RlcyA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIF9zdGF0ZSRuZXh0JGogPSBzdGF0ZS5uZXh0W2pdLFxuICAgICAgICB0eXBlID0gX3N0YXRlJG5leHQkai50eXBlLFxuICAgICAgICBuZXh0ID0gX3N0YXRlJG5leHQkai5uZXh0O1xuICAgICAgbm9kZXMucHVzaCh0eXBlLm5hbWUpO1xuICAgICAgaWYgKGRlYWQgJiYgISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpIGRlYWQgPSBmYWxzZTtcbiAgICAgIGlmICh3b3JrLmluZGV4T2YobmV4dCkgPT0gLTEpIHdvcmsucHVzaChuZXh0KTtcbiAgICB9XG4gICAgaWYgKGRlYWQpIHN0cmVhbS5lcnIoXCJPbmx5IG5vbi1nZW5lcmF0YWJsZSBub2RlcyAoXCIgKyBub2Rlcy5qb2luKFwiLCBcIikgKyBcIikgaW4gYSByZXF1aXJlZCBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2dlbmVyYXRhYmxlKVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmYXVsdEF0dHJzKGF0dHJzKSB7XG4gIHZhciBkZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAodmFyIGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgaWYgKCFhdHRyLmhhc0RlZmF1bHQpIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHRzW2F0dHJOYW1lXSA9IGF0dHJbXCJkZWZhdWx0XCJdO1xuICB9XG4gIHJldHVybiBkZWZhdWx0cztcbn1cbmZ1bmN0aW9uIF9jb21wdXRlQXR0cnMoYXR0cnMsIHZhbHVlKSB7XG4gIHZhciBidWlsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHtcbiAgICB2YXIgZ2l2ZW4gPSB2YWx1ZSAmJiB2YWx1ZVtuYW1lXTtcbiAgICBpZiAoZ2l2ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgIGlmIChhdHRyLmhhc0RlZmF1bHQpIGdpdmVuID0gYXR0cltcImRlZmF1bHRcIl07ZWxzZSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKTtcbiAgICB9XG4gICAgYnVpbHRbbmFtZV0gPSBnaXZlbjtcbiAgfVxuICByZXR1cm4gYnVpbHQ7XG59XG5mdW5jdGlvbiBfY2hlY2tBdHRycyhhdHRycywgdmFsdWVzLCB0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIF9uYW1lIGluIHZhbHVlcykgaWYgKCEoX25hbWUgaW4gYXR0cnMpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZSBcIi5jb25jYXQoX25hbWUsIFwiIGZvciBcIikuY29uY2F0KHR5cGUsIFwiIG9mIHR5cGUgXCIpLmNvbmNhdChfbmFtZSkpO1xuICBmb3IgKHZhciBfbmFtZTIgaW4gYXR0cnMpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW19uYW1lMl07XG4gICAgaWYgKGF0dHIudmFsaWRhdGUpIGF0dHIudmFsaWRhdGUodmFsdWVzW19uYW1lMl0pO1xuICB9XG59XG5mdW5jdGlvbiBpbml0QXR0cnModHlwZU5hbWUsIGF0dHJzKSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoYXR0cnMpIGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHJlc3VsdFtuYW1lXSA9IG5ldyBBdHRyaWJ1dGUodHlwZU5hbWUsIG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBOb2RlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVUeXBlKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgdGhpcy5tYXJrU2V0ID0gbnVsbDtcbiAgICB0aGlzLmdyb3VwcyA9IHNwZWMuZ3JvdXAgPyBzcGVjLmdyb3VwLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMobmFtZSwgc3BlYy5hdHRycyk7XG4gICAgdGhpcy5kZWZhdWx0QXR0cnMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgdGhpcy5jb250ZW50TWF0Y2ggPSBudWxsO1xuICAgIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG4gICAgdGhpcy5pc0Jsb2NrID0gIShzcGVjLmlubGluZSB8fCBuYW1lID09IFwidGV4dFwiKTtcbiAgICB0aGlzLmlzVGV4dCA9IG5hbWUgPT0gXCJ0ZXh0XCI7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE5vZGVUeXBlLCBbe1xuICAgIGtleTogXCJpc0lubGluZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICF0aGlzLmlzQmxvY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVGV4dGJsb2NrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Jsb2NrICYmIHRoaXMuaW5saW5lQ29udGVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNMZWFmXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50TWF0Y2ggPT0gQ29udGVudE1hdGNoLmVtcHR5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0F0b21cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzTGVhZiB8fCAhIXRoaXMuc3BlYy5hdG9tO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0luR3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbkdyb3VwKGdyb3VwKSB7XG4gICAgICByZXR1cm4gdGhpcy5ncm91cHMuaW5kZXhPZihncm91cCkgPiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2hpdGVzcGFjZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BlYy53aGl0ZXNwYWNlIHx8ICh0aGlzLnNwZWMuY29kZSA/IFwicHJlXCIgOiBcIm5vcm1hbFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzUmVxdWlyZWRBdHRyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNSZXF1aXJlZEF0dHJzKCkge1xuICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLmF0dHJzKSBpZiAodGhpcy5hdHRyc1tuXS5pc1JlcXVpcmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGF0aWJsZUNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGF0aWJsZUNvbnRlbnQob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29udGVudE1hdGNoLmNvbXBhdGlibGUob3RoZXIuY29udGVudE1hdGNoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZUF0dHJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVBdHRycyhhdHRycykge1xuICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmRlZmF1bHRBdHRycykgcmV0dXJuIHRoaXMuZGVmYXVsdEF0dHJzO2Vsc2UgcmV0dXJuIF9jb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtYXJrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMuaXNUZXh0KSB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlVHlwZS5jcmVhdGUgY2FuJ3QgY29uc3RydWN0IHRleHQgbm9kZXNcIik7XG4gICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQ2hlY2tlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDaGVja2VkKCkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtYXJrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICB0aGlzLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIGNvbnRlbnQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVBbmRGaWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUFuZEZpbGwoKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBhdHRycyA9IHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKTtcbiAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShjb250ZW50KTtcbiAgICAgICAgaWYgKCFiZWZvcmUpIHJldHVybiBudWxsO1xuICAgICAgICBjb250ZW50ID0gYmVmb3JlLmFwcGVuZChjb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXRjaGVkID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgIHZhciBhZnRlciA9IG1hdGNoZWQgJiYgbWF0Y2hlZC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgIGlmICghYWZ0ZXIpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZENvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC52YWxpZEVuZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKykgaWYgKCF0aGlzLmFsbG93c01hcmtzKGNvbnRlbnQuY2hpbGQoaSkubWFya3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQ29udGVudChjb250ZW50KSB7XG4gICAgICBpZiAoIXRoaXMudmFsaWRDb250ZW50KGNvbnRlbnQpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSBcIi5jb25jYXQodGhpcy5uYW1lLCBcIjogXCIpLmNvbmNhdChjb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgNTApKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrQXR0cnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBdHRycyhhdHRycykge1xuICAgICAgX2NoZWNrQXR0cnModGhpcy5hdHRycywgYXR0cnMsIFwibm9kZVwiLCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbGxvd3NNYXJrVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFya1NldCA9PSBudWxsIHx8IHRoaXMubWFya1NldC5pbmRleE9mKG1hcmtUeXBlKSA+IC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbGxvd3NNYXJrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxvd3NNYXJrcyhtYXJrcykge1xuICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFsbG93ZWRNYXJrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxvd2VkTWFya3MobWFya3MpIHtcbiAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbCkgcmV0dXJuIG1hcmtzO1xuICAgICAgdmFyIGNvcHk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkge1xuICAgICAgICAgIGlmICghY29weSkgY29weSA9IG1hcmtzLnNsaWNlKDAsIGkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgICBjb3B5LnB1c2gobWFya3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gIWNvcHkgPyBtYXJrcyA6IGNvcHkubGVuZ3RoID8gY29weSA6IE1hcmsubm9uZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjb21waWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUobm9kZXMsIHNjaGVtYSkge1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbbmFtZV0gPSBuZXcgTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHRvcFR5cGUgPSBzY2hlbWEuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCI7XG4gICAgICBpZiAoIXJlc3VsdFt0b3BUeXBlXSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIik7XG4gICAgICBpZiAoIXJlc3VsdC50ZXh0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV2ZXJ5IHNjaGVtYSBuZWVkcyBhICd0ZXh0JyB0eXBlXCIpO1xuICAgICAgZm9yICh2YXIgXyBpbiByZXN1bHQudGV4dC5hdHRycykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZVR5cGU7XG59KCk7XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZU5hbWUsIGF0dHJOYW1lLCB0eXBlKSB7XG4gIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpO1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG5hbWUgPSB2YWx1ZSA9PT0gbnVsbCA/IFwibnVsbFwiIDogX3R5cGVvZih2YWx1ZSk7XG4gICAgaWYgKHR5cGVzLmluZGV4T2YobmFtZSkgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV4cGVjdGVkIHZhbHVlIG9mIHR5cGUgXCIuY29uY2F0KHR5cGVzLCBcIiBmb3IgYXR0cmlidXRlIFwiKS5jb25jYXQoYXR0ck5hbWUsIFwiIG9uIHR5cGUgXCIpLmNvbmNhdCh0eXBlTmFtZSwgXCIsIGdvdCBcIikuY29uY2F0KG5hbWUpKTtcbiAgfTtcbn1cbnZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSh0eXBlTmFtZSwgYXR0ck5hbWUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXR0cmlidXRlKTtcbiAgICB0aGlzLmhhc0RlZmF1bHQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJkZWZhdWx0XCIpO1xuICAgIHRoaXNbXCJkZWZhdWx0XCJdID0gb3B0aW9uc1tcImRlZmF1bHRcIl07XG4gICAgdGhpcy52YWxpZGF0ZSA9IHR5cGVvZiBvcHRpb25zLnZhbGlkYXRlID09IFwic3RyaW5nXCIgPyB2YWxpZGF0ZVR5cGUodHlwZU5hbWUsIGF0dHJOYW1lLCBvcHRpb25zLnZhbGlkYXRlKSA6IG9wdGlvbnMudmFsaWRhdGU7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEF0dHJpYnV0ZSwgW3tcbiAgICBrZXk6IFwiaXNSZXF1aXJlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhc0RlZmF1bHQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBdHRyaWJ1dGU7XG59KCk7XG52YXIgTWFya1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcmtUeXBlKG5hbWUsIHJhbmssIHNjaGVtYSwgc3BlYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrVHlwZSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhuYW1lLCBzcGVjLmF0dHJzKTtcbiAgICB0aGlzLmV4Y2x1ZGVkID0gbnVsbDtcbiAgICB2YXIgZGVmYXVsdHMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgdGhpcy5pbnN0YW5jZSA9IGRlZmF1bHRzID8gbmV3IE1hcmsodGhpcywgZGVmYXVsdHMpIDogbnVsbDtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTWFya1R5cGUsIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICBpZiAoIWF0dHJzICYmIHRoaXMuaW5zdGFuY2UpIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgICAgcmV0dXJuIG5ldyBNYXJrKHRoaXMsIF9jb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRnJvbVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKSB7XG4gICAgICAgIHNldCA9IHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW5TZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJblNldChzZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykgcmV0dXJuIHNldFtpXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tBdHRyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0F0dHJzKGF0dHJzKSB7XG4gICAgICBfY2hlY2tBdHRycyh0aGlzLmF0dHJzLCBhdHRycywgXCJtYXJrXCIsIHRoaXMubmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4Y2x1ZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4Y2x1ZGVzKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5leGNsdWRlZC5pbmRleE9mKG90aGVyKSA+IC0xO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNvbXBpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZShtYXJrcywgc2NoZW1hKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgcmFuayA9IDA7XG4gICAgICBtYXJrcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbbmFtZV0gPSBuZXcgTWFya1R5cGUobmFtZSwgcmFuaysrLCBzY2hlbWEsIHNwZWMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWFya1R5cGU7XG59KCk7XG52YXIgU2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2hlbWEoc3BlYykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2hlbWEpO1xuICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgaW5zdGFuY2VTcGVjID0gdGhpcy5zcGVjID0ge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzcGVjKSBpbnN0YW5jZVNwZWNbcHJvcF0gPSBzcGVjW3Byb3BdO1xuICAgIGluc3RhbmNlU3BlYy5ub2RlcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm5vZGVzKSwgaW5zdGFuY2VTcGVjLm1hcmtzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubWFya3MgfHwge30pLCB0aGlzLm5vZGVzID0gTm9kZVR5cGUuY29tcGlsZSh0aGlzLnNwZWMubm9kZXMsIHRoaXMpO1xuICAgIHRoaXMubWFya3MgPSBNYXJrVHlwZS5jb21waWxlKHRoaXMuc3BlYy5tYXJrcywgdGhpcyk7XG4gICAgdmFyIGNvbnRlbnRFeHByQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIF9wcm9wIGluIHRoaXMubm9kZXMpIHtcbiAgICAgIGlmIChfcHJvcCBpbiB0aGlzLm1hcmtzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihfcHJvcCArIFwiIGNhbiBub3QgYmUgYm90aCBhIG5vZGUgYW5kIGEgbWFya1wiKTtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5ub2Rlc1tfcHJvcF0sXG4gICAgICAgIGNvbnRlbnRFeHByID0gdHlwZS5zcGVjLmNvbnRlbnQgfHwgXCJcIixcbiAgICAgICAgbWFya0V4cHIgPSB0eXBlLnNwZWMubWFya3M7XG4gICAgICB0eXBlLmNvbnRlbnRNYXRjaCA9IGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdIHx8IChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgICAgdHlwZS5pbmxpbmVDb250ZW50ID0gdHlwZS5jb250ZW50TWF0Y2guaW5saW5lQ29udGVudDtcbiAgICAgIGlmICh0eXBlLnNwZWMubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgbGluZWJyZWFrIG5vZGVzIGRlZmluZWRcIik7XG4gICAgICAgIGlmICghdHlwZS5pc0lubGluZSB8fCAhdHlwZS5pc0xlYWYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZWJyZWFrIHJlcGxhY2VtZW50IG5vZGVzIG11c3QgYmUgaW5saW5lIGxlYWYgbm9kZXNcIik7XG4gICAgICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSB0eXBlO1xuICAgICAgfVxuICAgICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDogbWFya0V4cHIgPyBnYXRoZXJNYXJrcyh0aGlzLCBtYXJrRXhwci5zcGxpdChcIiBcIikpIDogbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBfcHJvcDIgaW4gdGhpcy5tYXJrcykge1xuICAgICAgdmFyIF90eXBlMiA9IHRoaXMubWFya3NbX3Byb3AyXSxcbiAgICAgICAgZXhjbCA9IF90eXBlMi5zcGVjLmV4Y2x1ZGVzO1xuICAgICAgX3R5cGUyLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW190eXBlMl0gOiBleGNsID09IFwiXCIgPyBbXSA6IGdhdGhlck1hcmtzKHRoaXMsIGV4Y2wuc3BsaXQoXCIgXCIpKTtcbiAgICB9XG4gICAgdGhpcy5ub2RlRnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgcmV0dXJuIE5vZGUuZnJvbUpTT04oX3RoaXMyLCBqc29uKTtcbiAgICB9O1xuICAgIHRoaXMubWFya0Zyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgIHJldHVybiBNYXJrLmZyb21KU09OKF90aGlzMiwganNvbik7XG4gICAgfTtcbiAgICB0aGlzLnRvcE5vZGVUeXBlID0gdGhpcy5ub2Rlc1t0aGlzLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiXTtcbiAgICB0aGlzLmNhY2hlZC53cmFwcGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhTY2hlbWEsIFt7XG4gICAga2V5OiBcIm5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZSh0eXBlKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIikgdHlwZSA9IHRoaXMubm9kZVR5cGUodHlwZSk7ZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgTm9kZVR5cGUpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIiArIHR5cGUpO2Vsc2UgaWYgKHR5cGUuc2NoZW1hICE9IHRoaXMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgIHJldHVybiB0eXBlLmNyZWF0ZUNoZWNrZWQoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0KF90ZXh0LCBtYXJrcykge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gICAgICByZXR1cm4gbmV3IFRleHROb2RlKHR5cGUsIHR5cGUuZGVmYXVsdEF0dHJzLCBfdGV4dCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFyayh0eXBlLCBhdHRycykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpIHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdO1xuICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlKGF0dHJzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZVR5cGUobmFtZSkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgIGlmICghZm91bmQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTY2hlbWE7XG59KCk7XG5mdW5jdGlvbiBnYXRoZXJNYXJrcyhzY2hlbWEsIG1hcmtzKSB7XG4gIHZhciBmb3VuZCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBtYXJrc1tpXSxcbiAgICAgIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sXG4gICAgICBvayA9IG1hcms7XG4gICAgaWYgKG1hcmspIHtcbiAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgIHZhciBfbWFyayA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJfXCIgfHwgX21hcmsuc3BlYy5ncm91cCAmJiBfbWFyay5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpIGZvdW5kLnB1c2gob2sgPSBfbWFyayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghb2spIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gbWFyayB0eXBlOiAnXCIgKyBtYXJrc1tpXSArIFwiJ1wiKTtcbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc1RhZ1J1bGUocnVsZSkge1xuICByZXR1cm4gcnVsZS50YWcgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzU3R5bGVSdWxlKHJ1bGUpIHtcbiAgcmV0dXJuIHJ1bGUuc3R5bGUgIT0gbnVsbDtcbn1cbnZhciBET01QYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERPTVBhcnNlcihzY2hlbWEsIHJ1bGVzKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTVBhcnNlcik7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgdmFyIG1hdGNoZWRTdHlsZXMgPSB0aGlzLm1hdGNoZWRTdHlsZXMgPSBbXTtcbiAgICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBpZiAoaXNUYWdSdWxlKHJ1bGUpKSB7XG4gICAgICAgIF90aGlzMy50YWdzLnB1c2gocnVsZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3R5bGVSdWxlKHJ1bGUpKSB7XG4gICAgICAgIHZhciBwcm9wID0gL1tePV0qLy5leGVjKHJ1bGUuc3R5bGUpWzBdO1xuICAgICAgICBpZiAobWF0Y2hlZFN0eWxlcy5pbmRleE9mKHByb3ApIDwgMCkgbWF0Y2hlZFN0eWxlcy5wdXNoKHByb3ApO1xuICAgICAgICBfdGhpczMuc3R5bGVzLnB1c2gocnVsZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5ub3JtYWxpemVMaXN0cyA9ICF0aGlzLnRhZ3Muc29tZShmdW5jdGlvbiAocikge1xuICAgICAgaWYgKCEvXih1bHxvbClcXGIvLnRlc3Qoci50YWcpIHx8ICFyLm5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBub2RlID0gc2NoZW1hLm5vZGVzW3Iubm9kZV07XG4gICAgICByZXR1cm4gbm9kZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKG5vZGUpO1xuICAgIH0pO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhET01QYXJzZXIsIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGRvbSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgTWFyay5ub25lLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQuZmluaXNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlU2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VTbGljZShkb20pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgTWFyay5ub25lLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgcmV0dXJuIFNsaWNlLm1heE9wZW4oY29udGV4dC5maW5pc2goKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoVGFnKGRvbSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhZnRlciA/IHRoaXMudGFncy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy50YWdzW2ldO1xuICAgICAgICBpZiAobWF0Y2hlcyhkb20sIHJ1bGUudGFnKSAmJiAocnVsZS5uYW1lc3BhY2UgPT09IHVuZGVmaW5lZCB8fCBkb20ubmFtZXNwYWNlVVJJID09IHJ1bGUubmFtZXNwYWNlKSAmJiAoIXJ1bGUuY29udGV4dCB8fCBjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkpKSB7XG4gICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBydWxlLmdldEF0dHJzKGRvbSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgY29udGludWU7XG4gICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaFN0eWxlKHByb3AsIHZhbHVlLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgZm9yICh2YXIgaSA9IGFmdGVyID8gdGhpcy5zdHlsZXMuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMuc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy5zdHlsZXNbaV0sXG4gICAgICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZihwcm9wKSAhPSAwIHx8IHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8IHN0eWxlLmxlbmd0aCA+IHByb3AubGVuZ3RoICYmIChzdHlsZS5jaGFyQ29kZUF0KHByb3AubGVuZ3RoKSAhPSA2MSB8fCBzdHlsZS5zbGljZShwcm9wLmxlbmd0aCArIDEpICE9IHZhbHVlKSkgY29udGludWU7XG4gICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnModmFsdWUpO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJzY2hlbWFSdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlbWFSdWxlcyhzY2hlbWEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgICAgIHZhciBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSxcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHJlc3VsdFtpXSxcbiAgICAgICAgICAgIG5leHRQcmlvcml0eSA9IG5leHQucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogbmV4dC5wcmlvcml0eTtcbiAgICAgICAgICBpZiAobmV4dFByaW9yaXR5IDwgcHJpb3JpdHkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgICB9XG4gICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKG5hbWUpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gc2NoZW1hLm1hcmtzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgIGlmIChydWxlcykgcnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgaWYgKCEocnVsZS5tYXJrIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUuY2xlYXJNYXJrKSkgcnVsZS5tYXJrID0gbmFtZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgX2xvb3AyKG5hbWUpO1xuICAgICAgfVxuICAgICAgdmFyIF9sb29wMyA9IGZ1bmN0aW9uIF9sb29wMyhfbmFtZTMpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gc2NoZW1hLm5vZGVzW19uYW1lM10uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgaWYgKHJ1bGVzKSBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICBpZiAoIShydWxlLm5vZGUgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5tYXJrKSkgcnVsZS5ub2RlID0gX25hbWUzO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBfbmFtZTMgaW4gc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgIF9sb29wMyhfbmFtZTMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVNjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyIHx8IChzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoc2NoZW1hLCBET01QYXJzZXIuc2NoZW1hUnVsZXMoc2NoZW1hKSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRE9NUGFyc2VyO1xufSgpO1xudmFyIGJsb2NrVGFncyA9IHtcbiAgYWRkcmVzczogdHJ1ZSxcbiAgYXJ0aWNsZTogdHJ1ZSxcbiAgYXNpZGU6IHRydWUsXG4gIGJsb2NrcXVvdGU6IHRydWUsXG4gIGNhbnZhczogdHJ1ZSxcbiAgZGQ6IHRydWUsXG4gIGRpdjogdHJ1ZSxcbiAgZGw6IHRydWUsXG4gIGZpZWxkc2V0OiB0cnVlLFxuICBmaWdjYXB0aW9uOiB0cnVlLFxuICBmaWd1cmU6IHRydWUsXG4gIGZvb3RlcjogdHJ1ZSxcbiAgZm9ybTogdHJ1ZSxcbiAgaDE6IHRydWUsXG4gIGgyOiB0cnVlLFxuICBoMzogdHJ1ZSxcbiAgaDQ6IHRydWUsXG4gIGg1OiB0cnVlLFxuICBoNjogdHJ1ZSxcbiAgaGVhZGVyOiB0cnVlLFxuICBoZ3JvdXA6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBsaTogdHJ1ZSxcbiAgbm9zY3JpcHQ6IHRydWUsXG4gIG9sOiB0cnVlLFxuICBvdXRwdXQ6IHRydWUsXG4gIHA6IHRydWUsXG4gIHByZTogdHJ1ZSxcbiAgc2VjdGlvbjogdHJ1ZSxcbiAgdGFibGU6IHRydWUsXG4gIHRmb290OiB0cnVlLFxuICB1bDogdHJ1ZVxufTtcbnZhciBpZ25vcmVUYWdzID0ge1xuICBoZWFkOiB0cnVlLFxuICBub3NjcmlwdDogdHJ1ZSxcbiAgb2JqZWN0OiB0cnVlLFxuICBzY3JpcHQ6IHRydWUsXG4gIHN0eWxlOiB0cnVlLFxuICB0aXRsZTogdHJ1ZVxufTtcbnZhciBsaXN0VGFncyA9IHtcbiAgb2w6IHRydWUsXG4gIHVsOiB0cnVlXG59O1xudmFyIE9QVF9QUkVTRVJWRV9XUyA9IDEsXG4gIE9QVF9QUkVTRVJWRV9XU19GVUxMID0gMixcbiAgT1BUX09QRU5fTEVGVCA9IDQ7XG5mdW5jdGlvbiB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXaGl0ZXNwYWNlLCBiYXNlKSB7XG4gIGlmIChwcmVzZXJ2ZVdoaXRlc3BhY2UgIT0gbnVsbCkgcmV0dXJuIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPyBPUFRfUFJFU0VSVkVfV1MgOiAwKSB8IChwcmVzZXJ2ZVdoaXRlc3BhY2UgPT09IFwiZnVsbFwiID8gT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiAwKTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBPUFRfUFJFU0VSVkVfV1MgfCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IGJhc2UgJiB+T1BUX09QRU5fTEVGVDtcbn1cbnZhciBOb2RlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIG1hcmtzLCBzb2xpZCwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUNvbnRleHQpO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAgIHRoaXMubWF0Y2ggPSBtYXRjaCB8fCAob3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgPyBudWxsIDogdHlwZS5jb250ZW50TWF0Y2gpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhOb2RlQ29udGV4dCwgW3tcbiAgICBrZXk6IFwiZmluZFdyYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRXcmFwcGluZyhub2RlKSB7XG4gICAgICBpZiAoIXRoaXMubWF0Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGZpbGwgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmaWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLFxuICAgICAgICAgICAgd3JhcDtcbiAgICAgICAgICBpZiAod3JhcCA9IHN0YXJ0LmZpbmRXcmFwcGluZyhub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gd3JhcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluaXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSxcbiAgICAgICAgICBtO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmlzVGV4dCAmJiAobSA9IC9bIFxcdFxcclxcblxcdTAwMGNdKyQvLmV4ZWMobGFzdC50ZXh0KSkpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGxhc3Q7XG4gICAgICAgICAgaWYgKGxhc3QudGV4dC5sZW5ndGggPT0gbVswXS5sZW5ndGgpIHRoaXMuY29udGVudC5wb3AoKTtlbHNlIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gPSB0ZXh0LndpdGhUZXh0KHRleHQudGV4dC5zbGljZSgwLCB0ZXh0LnRleHQubGVuZ3RoIC0gbVswXS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHRoaXMuY29udGVudCk7XG4gICAgICBpZiAoIW9wZW5FbmQgJiYgdGhpcy5tYXRjaCkgY29udGVudCA9IGNvbnRlbnQuYXBwZW5kKHRoaXMubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgICAgcmV0dXJuIHRoaXMudHlwZSA/IHRoaXMudHlwZS5jcmVhdGUodGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcykgOiBjb250ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmxpbmVDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlubGluZUNvbnRleHQobm9kZSkge1xuICAgICAgaWYgKHRoaXMudHlwZSkgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50O1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpIHJldHVybiB0aGlzLmNvbnRlbnRbMF0uaXNJbmxpbmU7XG4gICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmICFibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZUNvbnRleHQ7XG59KCk7XG52YXIgUGFyc2VDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzZUNvbnRleHQocGFyc2VyLCBvcHRpb25zLCBpc09wZW4pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VDb250ZXh0KTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaXNPcGVuID0gaXNPcGVuO1xuICAgIHRoaXMub3BlbiA9IDA7XG4gICAgdGhpcy5sb2NhbFByZXNlcnZlV1MgPSBmYWxzZTtcbiAgICB2YXIgdG9wTm9kZSA9IG9wdGlvbnMudG9wTm9kZSxcbiAgICAgIHRvcENvbnRleHQ7XG4gICAgdmFyIHRvcE9wdGlvbnMgPSB3c09wdGlvbnNGb3IobnVsbCwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIDApIHwgKGlzT3BlbiA/IE9QVF9PUEVOX0xFRlQgOiAwKTtcbiAgICBpZiAodG9wTm9kZSkgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dCh0b3BOb2RlLnR5cGUsIHRvcE5vZGUuYXR0cnMsIE1hcmsubm9uZSwgdHJ1ZSwgb3B0aW9ucy50b3BNYXRjaCB8fCB0b3BOb2RlLnR5cGUuY29udGVudE1hdGNoLCB0b3BPcHRpb25zKTtlbHNlIGlmIChpc09wZW4pIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQobnVsbCwgbnVsbCwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtlbHNlIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQocGFyc2VyLnNjaGVtYS50b3BOb2RlVHlwZSwgbnVsbCwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICB0aGlzLm5vZGVzID0gW3RvcENvbnRleHRdO1xuICAgIHRoaXMuZmluZCA9IG9wdGlvbnMuZmluZFBvc2l0aW9ucztcbiAgICB0aGlzLm5lZWRzQmxvY2sgPSBmYWxzZTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoUGFyc2VDb250ZXh0LCBbe1xuICAgIGtleTogXCJ0b3BcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzW3RoaXMub3Blbl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZERPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRET00oZG9tLCBtYXJrcykge1xuICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKSB0aGlzLmFkZFRleHROb2RlKGRvbSwgbWFya3MpO2Vsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB0aGlzLmFkZEVsZW1lbnQoZG9tLCBtYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFRleHROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRleHROb2RlKGRvbSwgbWFya3MpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGRvbS5ub2RlVmFsdWU7XG4gICAgICB2YXIgdG9wID0gdGhpcy50b3AsXG4gICAgICAgIHByZXNlcnZlV1MgPSB0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMID8gXCJmdWxsXCIgOiB0aGlzLmxvY2FsUHJlc2VydmVXUyB8fCAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpID4gMDtcbiAgICAgIGlmIChwcmVzZXJ2ZVdTID09PSBcImZ1bGxcIiB8fCB0b3AuaW5saW5lQ29udGV4dChkb20pIHx8IC9bXiBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFwcmVzZXJ2ZVdTKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG4gICAgICAgICAgaWYgKC9eWyBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy5vcGVuID09IHRoaXMubm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdmFyIG5vZGVCZWZvcmUgPSB0b3AuY29udGVudFt0b3AuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBkb21Ob2RlQmVmb3JlID0gZG9tLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIGlmICghbm9kZUJlZm9yZSB8fCBkb21Ob2RlQmVmb3JlICYmIGRvbU5vZGVCZWZvcmUubm9kZU5hbWUgPT0gJ0JSJyB8fCBub2RlQmVmb3JlLmlzVGV4dCAmJiAvWyBcXHRcXHJcXG5cXHUwMDBjXSQvLnRlc3Qobm9kZUJlZm9yZS50ZXh0KSkgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJlc2VydmVXUyAhPT0gXCJmdWxsXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlKSB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpLCBtYXJrcywgIS9cXFMvLnRlc3QodmFsdWUpKTtcbiAgICAgICAgdGhpcy5maW5kSW5UZXh0KGRvbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFbGVtZW50KGRvbSwgbWFya3MsIG1hdGNoQWZ0ZXIpIHtcbiAgICAgIHZhciBvdXRlcldTID0gdGhpcy5sb2NhbFByZXNlcnZlV1MsXG4gICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgaWYgKGRvbS50YWdOYW1lID09IFwiUFJFXCIgfHwgL3ByZS8udGVzdChkb20uc3R5bGUgJiYgZG9tLnN0eWxlLndoaXRlU3BhY2UpKSB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IHRydWU7XG4gICAgICB2YXIgbmFtZSA9IGRvbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBydWxlSUQ7XG4gICAgICBpZiAobGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5wYXJzZXIubm9ybWFsaXplTGlzdHMpIG5vcm1hbGl6ZUxpc3QoZG9tKTtcbiAgICAgIHZhciBydWxlID0gdGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZSAmJiB0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlKGRvbSkgfHwgKHJ1bGVJRCA9IHRoaXMucGFyc2VyLm1hdGNoVGFnKGRvbSwgdGhpcywgbWF0Y2hBZnRlcikpO1xuICAgICAgb3V0OiBpZiAocnVsZSA/IHJ1bGUuaWdub3JlIDogaWdub3JlVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20sIG1hcmtzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJ1bGUgfHwgcnVsZS5za2lwIHx8IHJ1bGUuY2xvc2VQYXJlbnQpIHtcbiAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5jbG9zZVBhcmVudCkgdGhpcy5vcGVuID0gTWF0aC5tYXgoMCwgdGhpcy5vcGVuIC0gMSk7ZWxzZSBpZiAocnVsZSAmJiBydWxlLnNraXAubm9kZVR5cGUpIGRvbSA9IHJ1bGUuc2tpcDtcbiAgICAgICAgdmFyIHN5bmMsXG4gICAgICAgICAgb2xkTmVlZHNCbG9jayA9IHRoaXMubmVlZHNCbG9jaztcbiAgICAgICAgaWYgKGJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGlmICh0b3AuY29udGVudC5sZW5ndGggJiYgdG9wLmNvbnRlbnRbMF0uaXNJbmxpbmUgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXRvcC50eXBlKSB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFkb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSwgbWFya3MpO1xuICAgICAgICAgIGJyZWFrIG91dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5uZXJNYXJrcyA9IHJ1bGUgJiYgcnVsZS5za2lwID8gbWFya3MgOiB0aGlzLnJlYWRTdHlsZXMoZG9tLCBtYXJrcyk7XG4gICAgICAgIGlmIChpbm5lck1hcmtzKSB0aGlzLmFkZEFsbChkb20sIGlubmVyTWFya3MpO1xuICAgICAgICBpZiAoc3luYykgdGhpcy5zeW5jKHRvcCk7XG4gICAgICAgIHRoaXMubmVlZHNCbG9jayA9IG9sZE5lZWRzQmxvY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2lubmVyTWFya3MgPSB0aGlzLnJlYWRTdHlsZXMoZG9tLCBtYXJrcyk7XG4gICAgICAgIGlmIChfaW5uZXJNYXJrcykgdGhpcy5hZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgX2lubmVyTWFya3MsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IG91dGVyV1M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlYWZGYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWFmRmFsbGJhY2soZG9tLCBtYXJrcykge1xuICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgdGhpcy50b3AudHlwZSAmJiB0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpIHRoaXMuYWRkVGV4dE5vZGUoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIiksIG1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlRmFsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWdub3JlRmFsbGJhY2soZG9tLCBtYXJrcykge1xuICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKSB0aGlzLmZpbmRQbGFjZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dChcIi1cIiksIG1hcmtzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFN0eWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkU3R5bGVzKGRvbSwgbWFya3MpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIHN0eWxlcyA9IGRvbS5zdHlsZTtcbiAgICAgIGlmIChzdHlsZXMgJiYgc3R5bGVzLmxlbmd0aCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcnNlci5tYXRjaGVkU3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZXIubWF0Y2hlZFN0eWxlc1tpXSxcbiAgICAgICAgICB2YWx1ZSA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgX2xvb3A0ID0gZnVuY3Rpb24gX2xvb3A0KF9hZnRlcikge1xuICAgICAgICAgICAgICB2YXIgcnVsZSA9IF90aGlzNC5wYXJzZXIubWF0Y2hTdHlsZShuYW1lLCB2YWx1ZSwgX3RoaXM0LCBfYWZ0ZXIpO1xuICAgICAgICAgICAgICBpZiAoIXJ1bGUpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IF9hZnRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocnVsZS5pZ25vcmUpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdjogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmspIG1hcmtzID0gbWFya3MuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFydWxlLmNsZWFyTWFyayhtKTtcbiAgICAgICAgICAgICAgfSk7ZWxzZSBtYXJrcyA9IG1hcmtzLmNvbmNhdChfdGhpczQucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdLmNyZWF0ZShydWxlLmF0dHJzKSk7XG4gICAgICAgICAgICAgIGlmIChydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UpIF9hZnRlciA9IHJ1bGU7ZWxzZSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBfYWZ0ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWZ0ZXIgPSBfYWZ0ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JldDtcbiAgICAgICAgICBmb3IgKHZhciBhZnRlciA9IHVuZGVmaW5lZDs7KSB7XG4gICAgICAgICAgICBfcmV0ID0gX2xvb3A0KGFmdGVyKTtcbiAgICAgICAgICAgIGlmIChfcmV0ID09PSAwKSBicmVhaztcbiAgICAgICAgICAgIGlmIChfcmV0KSByZXR1cm4gX3JldC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFbGVtZW50QnlSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBtYXJrcywgY29udGludWVBZnRlcikge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgc3luYywgbm9kZVR5cGU7XG4gICAgICBpZiAocnVsZS5ub2RlKSB7XG4gICAgICAgIG5vZGVUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW3J1bGUubm9kZV07XG4gICAgICAgIGlmICghbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgdmFyIGlubmVyID0gdGhpcy5lbnRlcihub2RlVHlwZSwgcnVsZS5hdHRycyB8fCBudWxsLCBtYXJrcywgcnVsZS5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuICAgICAgICAgIGlmIChpbm5lcikge1xuICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICBtYXJrcyA9IGlubmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pbnNlcnROb2RlKG5vZGVUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSwgbWFya3MsIGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIpKSB7XG4gICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tLCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXJrVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChtYXJrVHlwZS5jcmVhdGUocnVsZS5hdHRycykpO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXJ0SW4gPSB0aGlzLnRvcDtcbiAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSwgbWFya3MsIGNvbnRpbnVlQWZ0ZXIpO1xuICAgICAgfSBlbHNlIGlmIChydWxlLmdldENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIHJ1bGUuZ2V0Q29udGVudChkb20sIHRoaXMucGFyc2VyLnNjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuaW5zZXJ0Tm9kZShub2RlLCBtYXJrcywgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb250ZW50RE9NID0gZG9tO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJzdHJpbmdcIikgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKHJ1bGUuY29udGVudEVsZW1lbnQpO2Vsc2UgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwiZnVuY3Rpb25cIikgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQoZG9tKTtlbHNlIGlmIChydWxlLmNvbnRlbnRFbGVtZW50KSBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkQWxsKGNvbnRlbnRET00sIG1hcmtzKTtcbiAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bmMgJiYgdGhpcy5zeW5jKHN0YXJ0SW4pKSB0aGlzLm9wZW4tLTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFsbChwYXJlbnQsIG1hcmtzLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuICAgICAgZm9yICh2YXIgZG9tID0gc3RhcnRJbmRleCA/IHBhcmVudC5jaGlsZE5vZGVzW3N0YXJ0SW5kZXhdIDogcGFyZW50LmZpcnN0Q2hpbGQsIGVuZCA9IGVuZEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50LmNoaWxkTm9kZXNbZW5kSW5kZXhdOyBkb20gIT0gZW5kOyBkb20gPSBkb20ubmV4dFNpYmxpbmcsICsraW5kZXgpIHtcbiAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgdGhpcy5hZGRET00oZG9tLCBtYXJrcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kUGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFBsYWNlKG5vZGUsIG1hcmtzLCBjYXV0aW91cykge1xuICAgICAgdmFyIHJvdXRlLCBzeW5jO1xuICAgICAgZm9yICh2YXIgZGVwdGggPSB0aGlzLm9wZW4sIHBlbmFsdHkgPSAwOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgIHZhciBjeCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgICAgICB2YXIgX2ZvdW5kMiA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcbiAgICAgICAgaWYgKF9mb3VuZDIgJiYgKCFyb3V0ZSB8fCByb3V0ZS5sZW5ndGggPiBfZm91bmQyLmxlbmd0aCArIHBlbmFsdHkpKSB7XG4gICAgICAgICAgcm91dGUgPSBfZm91bmQyO1xuICAgICAgICAgIHN5bmMgPSBjeDtcbiAgICAgICAgICBpZiAoIV9mb3VuZDIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3guc29saWQpIHtcbiAgICAgICAgICBpZiAoY2F1dGlvdXMpIGJyZWFrO1xuICAgICAgICAgIHBlbmFsdHkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFyb3V0ZSkgcmV0dXJuIG51bGw7XG4gICAgICB0aGlzLnN5bmMoc3luYyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKSBtYXJrcyA9IHRoaXMuZW50ZXJJbm5lcihyb3V0ZVtpXSwgbnVsbCwgbWFya3MsIGZhbHNlKTtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb2RlKG5vZGUsIG1hcmtzLCBjYXV0aW91cykge1xuICAgICAgaWYgKG5vZGUuaXNJbmxpbmUgJiYgdGhpcy5uZWVkc0Jsb2NrICYmICF0aGlzLnRvcC50eXBlKSB7XG4gICAgICAgIHZhciBibG9jayA9IHRoaXMudGV4dGJsb2NrRnJvbUNvbnRleHQoKTtcbiAgICAgICAgaWYgKGJsb2NrKSBtYXJrcyA9IHRoaXMuZW50ZXJJbm5lcihibG9jaywgbnVsbCwgbWFya3MpO1xuICAgICAgfVxuICAgICAgdmFyIGlubmVyTWFya3MgPSB0aGlzLmZpbmRQbGFjZShub2RlLCBtYXJrcywgY2F1dGlvdXMpO1xuICAgICAgaWYgKGlubmVyTWFya3MpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKHRvcC5tYXRjaCkgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZShub2RlLnR5cGUpO1xuICAgICAgICB2YXIgbm9kZU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaW5uZXJNYXJrcy5jb25jYXQobm9kZS5tYXJrcykpLFxuICAgICAgICAgIF9zdGVwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvcC50eXBlID8gdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobS50eXBlKSA6IG1hcmtNYXlBcHBseShtLnR5cGUsIG5vZGUudHlwZSkpIG5vZGVNYXJrcyA9IG0uYWRkVG9TZXQobm9kZU1hcmtzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhub2RlTWFya3MpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyKHR5cGUsIGF0dHJzLCBtYXJrcywgcHJlc2VydmVXUykge1xuICAgICAgdmFyIGlubmVyTWFya3MgPSB0aGlzLmZpbmRQbGFjZSh0eXBlLmNyZWF0ZShhdHRycyksIG1hcmtzLCBmYWxzZSk7XG4gICAgICBpZiAoaW5uZXJNYXJrcykgaW5uZXJNYXJrcyA9IHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgbWFya3MsIHRydWUsIHByZXNlcnZlV1MpO1xuICAgICAgcmV0dXJuIGlubmVyTWFya3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudGVySW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXJJbm5lcih0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICAgIHZhciBzb2xpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICB2YXIgcHJlc2VydmVXUyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICB2YXIgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2ggJiYgdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgIHZhciBvcHRpb25zID0gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV1MsIHRvcC5vcHRpb25zKTtcbiAgICAgIGlmICh0b3Aub3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgJiYgdG9wLmNvbnRlbnQubGVuZ3RoID09IDApIG9wdGlvbnMgfD0gT1BUX09QRU5fTEVGVDtcbiAgICAgIHZhciBhcHBseU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgbWFya3MgPSBtYXJrcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKHRvcC50eXBlID8gdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobS50eXBlKSA6IG1hcmtNYXlBcHBseShtLnR5cGUsIHR5cGUpKSB7XG4gICAgICAgICAgYXBwbHlNYXJrcyA9IG0uYWRkVG9TZXQoYXBwbHlNYXJrcyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGVDb250ZXh0KHR5cGUsIGF0dHJzLCBhcHBseU1hcmtzLCBzb2xpZCwgbnVsbCwgb3B0aW9ucykpO1xuICAgICAgdGhpcy5vcGVuKys7XG4gICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlRXh0cmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VFeHRyYSgpIHtcbiAgICAgIHZhciBvcGVuRW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgaWYgKGkgPiB0aGlzLm9wZW4pIHtcbiAgICAgICAgZm9yICg7IGkgPiB0aGlzLm9wZW47IGktLSkgdGhpcy5ub2Rlc1tpIC0gMV0uY29udGVudC5wdXNoKHRoaXMubm9kZXNbaV0uZmluaXNoKG9wZW5FbmQpKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5sZW5ndGggPSB0aGlzLm9wZW4gKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5pc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgIHRoaXMuY2xvc2VFeHRyYSh0aGlzLmlzT3Blbik7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2goISEodGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jKHRvKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSA9PSB0bykge1xuICAgICAgICAgIHRoaXMub3BlbiA9IGk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbFByZXNlcnZlV1MpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzW2ldLm9wdGlvbnMgfD0gT1BUX1BSRVNFUlZFX1dTO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1cnJlbnRQb3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMubm9kZXNbaV0uY29udGVudDtcbiAgICAgICAgZm9yICh2YXIgaiA9IGNvbnRlbnQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHBvcyArPSBjb250ZW50W2pdLm5vZGVTaXplO1xuICAgICAgICBpZiAoaSkgcG9zKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQXRQb2ludChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgaWYgKHRoaXMuZmluZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHBhcmVudCAmJiB0aGlzLmZpbmRbaV0ub2Zmc2V0ID09IG9mZnNldCkgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEluc2lkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kSW5zaWRlKHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuZmluZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQXJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBcm91bmQocGFyZW50LCBjb250ZW50LCBiZWZvcmUpIHtcbiAgICAgIGlmIChwYXJlbnQgIT0gY29udGVudCAmJiB0aGlzLmZpbmQpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSkge1xuICAgICAgICAgIHZhciBwb3MgPSBjb250ZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuZmluZFtpXS5ub2RlKTtcbiAgICAgICAgICBpZiAocG9zICYgKGJlZm9yZSA/IDIgOiA0KSkgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kSW5UZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJblRleHQodGV4dE5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmZpbmQpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSB0ZXh0Tm9kZSkgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcyAtICh0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gdGhpcy5maW5kW2ldLm9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoZXNDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoZXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgaWYgKGNvbnRleHQuaW5kZXhPZihcInxcIikgPiAtMSkgcmV0dXJuIGNvbnRleHQuc3BsaXQoL1xccypcXHxcXHMqLykuc29tZSh0aGlzLm1hdGNoZXNDb250ZXh0LCB0aGlzKTtcbiAgICAgIHZhciBwYXJ0cyA9IGNvbnRleHQuc3BsaXQoXCIvXCIpO1xuICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgdmFyIHVzZVJvb3QgPSAhdGhpcy5pc09wZW4gJiYgKCFvcHRpb24gfHwgb3B0aW9uLnBhcmVudC50eXBlID09IHRoaXMubm9kZXNbMF0udHlwZSk7XG4gICAgICB2YXIgbWluRGVwdGggPSAtKG9wdGlvbiA/IG9wdGlvbi5kZXB0aCArIDEgOiAwKSArICh1c2VSb290ID8gMCA6IDEpO1xuICAgICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goaSwgZGVwdGgpIHtcbiAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydCA9PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBwYXJ0cy5sZW5ndGggLSAxIHx8IGkgPT0gMCkgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKDsgZGVwdGggPj0gbWluRGVwdGg7IGRlcHRoLS0pIGlmIChtYXRjaChpIC0gMSwgZGVwdGgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBkZXB0aCA+IDAgfHwgZGVwdGggPT0gMCAmJiB1c2VSb290ID8gX3RoaXM2Lm5vZGVzW2RlcHRoXS50eXBlIDogb3B0aW9uICYmIGRlcHRoID49IG1pbkRlcHRoID8gb3B0aW9uLm5vZGUoZGVwdGggLSBtaW5EZXB0aCkudHlwZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5uYW1lICE9IHBhcnQgJiYgIW5leHQuaXNJbkdyb3VwKHBhcnQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbWF0Y2gocGFydHMubGVuZ3RoIC0gMSwgdGhpcy5vcGVuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dGJsb2NrRnJvbUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dGJsb2NrRnJvbUNvbnRleHQoKSB7XG4gICAgICB2YXIgJGNvbnRleHQgPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgIGlmICgkY29udGV4dCkgZm9yICh2YXIgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICB2YXIgZGVmbHQgPSAkY29udGV4dC5ub2RlKGQpLmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4QWZ0ZXIoZCkpLmRlZmF1bHRUeXBlO1xuICAgICAgICBpZiAoZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2sgJiYgZGVmbHQuZGVmYXVsdEF0dHJzKSByZXR1cm4gZGVmbHQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlcykge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgdHlwZS5kZWZhdWx0QXR0cnMpIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGFyc2VDb250ZXh0O1xufSgpO1xuZnVuY3Rpb24gbm9ybWFsaXplTGlzdChkb20pIHtcbiAgZm9yICh2YXIgY2hpbGQgPSBkb20uZmlyc3RDaGlsZCwgcHJldkl0ZW0gPSBudWxsOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIHZhciBuYW1lID0gY2hpbGQubm9kZVR5cGUgPT0gMSA/IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImxpXCIpIHtcbiAgICAgIHByZXZJdGVtID0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICBwcmV2SXRlbSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXRjaGVzKGRvbSwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIChkb20ubWF0Y2hlcyB8fCBkb20ubXNNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb20ubW96TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGRvbSwgc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgdmFyIGNvcHkgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gbWFya01heUFwcGx5KG1hcmtUeXBlLCBub2RlVHlwZSkge1xuICB2YXIgbm9kZXMgPSBub2RlVHlwZS5zY2hlbWEubm9kZXM7XG4gIHZhciBfbG9vcDUgPSBmdW5jdGlvbiBfbG9vcDUoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZXNbbmFtZV07XG4gICAgICBpZiAoIXBhcmVudC5hbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkpIHJldHVybiAwO1xuICAgICAgdmFyIHNlZW4gPSBbXSxcbiAgICAgICAgc2NhbiA9IGZ1bmN0aW9uIHNjYW4obWF0Y2gpIHtcbiAgICAgICAgICBzZWVuLnB1c2gobWF0Y2gpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2gkZWRnZSA9IG1hdGNoLmVkZ2UoaSksXG4gICAgICAgICAgICAgIHR5cGUgPSBfbWF0Y2gkZWRnZS50eXBlLFxuICAgICAgICAgICAgICBuZXh0ID0gX21hdGNoJGVkZ2UubmV4dDtcbiAgICAgICAgICAgIGlmICh0eXBlID09IG5vZGVUeXBlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobmV4dCkgPCAwICYmIHNjYW4obmV4dCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIGlmIChzY2FuKHBhcmVudC5jb250ZW50TWF0Y2gpKSByZXR1cm4ge1xuICAgICAgICB2OiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgX3JldDI7XG4gIGZvciAodmFyIG5hbWUgaW4gbm9kZXMpIHtcbiAgICBfcmV0MiA9IF9sb29wNSgpO1xuICAgIGlmIChfcmV0MiA9PT0gMCkgY29udGludWU7XG4gICAgaWYgKF9yZXQyKSByZXR1cm4gX3JldDIudjtcbiAgfVxufVxudmFyIERPTVNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERPTVNlcmlhbGl6ZXIobm9kZXMsIG1hcmtzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTVNlcmlhbGl6ZXIpO1xuICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKERPTVNlcmlhbGl6ZXIsIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZUZyYWdtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICghdGFyZ2V0KSB0YXJnZXQgPSBkb2Mob3B0aW9ucykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIHRvcCA9IHRhcmdldCxcbiAgICAgICAgYWN0aXZlID0gW107XG4gICAgICBmcmFnbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtlZXAgPSAwLFxuICAgICAgICAgICAgcmVuZGVyZWQgPSAwO1xuICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aCAmJiByZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IG5vZGUubWFya3NbcmVuZGVyZWRdO1xuICAgICAgICAgICAgaWYgKCFfdGhpczcubWFya3NbbmV4dC50eXBlLm5hbWVdKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0LmVxKGFjdGl2ZVtrZWVwXVswXSkgfHwgbmV4dC50eXBlLnNwZWMuc3Bhbm5pbmcgPT09IGZhbHNlKSBicmVhaztcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aCkgdG9wID0gYWN0aXZlLnBvcCgpWzFdO1xuICAgICAgICAgIHdoaWxlIChyZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYWRkID0gbm9kZS5tYXJrc1tyZW5kZXJlZCsrXTtcbiAgICAgICAgICAgIHZhciBtYXJrRE9NID0gX3RoaXM3LnNlcmlhbGl6ZU1hcmsoYWRkLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtYXJrRE9NKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKFthZGQsIHRvcF0pO1xuICAgICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgICAgICB0b3AgPSBtYXJrRE9NLmNvbnRlbnRET00gfHwgbWFya0RPTS5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvcC5hcHBlbmRDaGlsZChfdGhpczcuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplTm9kZUlubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3JlbmRlclNwZWMyID0gX3JlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0aGlzLm5vZGVzW25vZGUudHlwZS5uYW1lXShub2RlKSwgbnVsbCwgbm9kZS5hdHRycyksXG4gICAgICAgIGRvbSA9IF9yZW5kZXJTcGVjMi5kb20sXG4gICAgICAgIGNvbnRlbnRET00gPSBfcmVuZGVyU3BlYzIuY29udGVudERPTTtcbiAgICAgIGlmIChjb250ZW50RE9NKSB7XG4gICAgICAgIGlmIChub2RlLmlzTGVhZikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVGcmFnbWVudChub2RlLmNvbnRlbnQsIG9wdGlvbnMsIGNvbnRlbnRET00pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemVOb2RlKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBkb20gPSB0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKTtcbiAgICAgIGZvciAodmFyIGkgPSBub2RlLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciB3cmFwID0gdGhpcy5zZXJpYWxpemVNYXJrKG5vZGUubWFya3NbaV0sIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICh3cmFwLmNvbnRlbnRET00gfHwgd3JhcC5kb20pLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgZG9tID0gd3JhcC5kb207XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZU1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplTWFyayhtYXJrLCBpbmxpbmUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciB0b0RPTSA9IHRoaXMubWFya3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgcmV0dXJuIHRvRE9NICYmIF9yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdG9ET00obWFyaywgaW5saW5lKSwgbnVsbCwgbWFyay5hdHRycyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicmVuZGVyU3BlY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlKSB7XG4gICAgICB2YXIgeG1sTlMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgYmxvY2tBcnJheXNJbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIF9yZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUywgYmxvY2tBcnJheXNJbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21TY2hlbWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgfHwgKHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciA9IG5ldyBET01TZXJpYWxpemVyKHRoaXMubm9kZXNGcm9tU2NoZW1hKHNjaGVtYSksIHRoaXMubWFya3NGcm9tU2NoZW1hKHNjaGVtYSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZXNGcm9tU2NoZW1hXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGVzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnYXRoZXJUb0RPTShzY2hlbWEubm9kZXMpO1xuICAgICAgaWYgKCFyZXN1bHQudGV4dCkgcmVzdWx0LnRleHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtzRnJvbVNjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICByZXR1cm4gZ2F0aGVyVG9ET00oc2NoZW1hLm1hcmtzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERPTVNlcmlhbGl6ZXI7XG59KCk7XG5mdW5jdGlvbiBnYXRoZXJUb0RPTShvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIG9iaikge1xuICAgIHZhciB0b0RPTSA9IG9ialtuYW1lXS5zcGVjLnRvRE9NO1xuICAgIGlmICh0b0RPTSkgcmVzdWx0W25hbWVdID0gdG9ET007XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRvYyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbn1cbnZhciBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc3VzcGljaW91c0F0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgdmFyIHZhbHVlID0gc3VzcGljaW91c0F0dHJpYnV0ZUNhY2hlLmdldChhdHRycyk7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUuc2V0KGF0dHJzLCB2YWx1ZSA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVzSW5uZXIoYXR0cnMpKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc3VzcGljaW91c0F0dHJpYnV0ZXNJbm5lcihhdHRycykge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgZnVuY3Rpb24gc2Nhbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiBfdHlwZW9mKHZhbHVlKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSBzY2FuKHZhbHVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkgc2Nhbih2YWx1ZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNjYW4oYXR0cnMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX3JlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TLCBibG9ja0FycmF5c0luKSB7XG4gIGlmICh0eXBlb2Ygc3RydWN0dXJlID09IFwic3RyaW5nXCIpIHJldHVybiB7XG4gICAgZG9tOiBkb2MuY3JlYXRlVGV4dE5vZGUoc3RydWN0dXJlKVxuICB9O1xuICBpZiAoc3RydWN0dXJlLm5vZGVUeXBlICE9IG51bGwpIHJldHVybiB7XG4gICAgZG9tOiBzdHJ1Y3R1cmVcbiAgfTtcbiAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKSByZXR1cm4gc3RydWN0dXJlO1xuICB2YXIgdGFnTmFtZSA9IHN0cnVjdHVyZVswXSxcbiAgICBzdXNwaWNpb3VzO1xuICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFycmF5IHBhc3NlZCB0byByZW5kZXJTcGVjXCIpO1xuICBpZiAoYmxvY2tBcnJheXNJbiAmJiAoc3VzcGljaW91cyA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVzKGJsb2NrQXJyYXlzSW4pKSAmJiBzdXNwaWNpb3VzLmluZGV4T2Yoc3RydWN0dXJlKSA+IC0xKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVzaW5nIGFuIGFycmF5IGZyb20gYW4gYXR0cmlidXRlIG9iamVjdCBhcyBhIERPTSBzcGVjLiBUaGlzIG1heSBiZSBhbiBhdHRlbXB0ZWQgY3Jvc3Mgc2l0ZSBzY3JpcHRpbmcgYXR0YWNrLlwiKTtcbiAgdmFyIHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgaWYgKHNwYWNlID4gMCkge1xuICAgIHhtbE5TID0gdGFnTmFtZS5zbGljZSgwLCBzcGFjZSk7XG4gICAgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2Uoc3BhY2UgKyAxKTtcbiAgfVxuICB2YXIgY29udGVudERPTTtcbiAgdmFyIGRvbSA9IHhtbE5TID8gZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxOUywgdGFnTmFtZSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgdmFyIGF0dHJzID0gc3RydWN0dXJlWzFdLFxuICAgIHN0YXJ0ID0gMTtcbiAgaWYgKGF0dHJzICYmIF90eXBlb2YoYXR0cnMpID09IFwib2JqZWN0XCIgJiYgYXR0cnMubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICBzdGFydCA9IDI7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBhdHRycykgaWYgKGF0dHJzW25hbWVdICE9IG51bGwpIHtcbiAgICAgIHZhciBfc3BhY2UgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgaWYgKF9zcGFjZSA+IDApIGRvbS5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNsaWNlKDAsIF9zcGFjZSksIG5hbWUuc2xpY2UoX3NwYWNlICsgMSksIGF0dHJzW25hbWVdKTtlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIiAmJiBkb20uc3R5bGUpIGRvbS5zdHlsZS5jc3NUZXh0ID0gYXR0cnNbbmFtZV07ZWxzZSBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RydWN0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gc3RydWN0dXJlW2ldO1xuICAgIGlmIChjaGlsZCA9PT0gMCkge1xuICAgICAgaWYgKGkgPCBzdHJ1Y3R1cmUubGVuZ3RoIC0gMSB8fCBpID4gc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9tOiBkb20sXG4gICAgICAgIGNvbnRlbnRET006IGRvbVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9yZW5kZXJTcGVjMyA9IF9yZW5kZXJTcGVjKGRvYywgY2hpbGQsIHhtbE5TLCBibG9ja0FycmF5c0luKSxcbiAgICAgICAgaW5uZXIgPSBfcmVuZGVyU3BlYzMuZG9tLFxuICAgICAgICBpbm5lckNvbnRlbnQgPSBfcmVuZGVyU3BlYzMuY29udGVudERPTTtcbiAgICAgIGRvbS5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICBpZiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50RE9NKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGNvbnRlbnQgaG9sZXNcIik7XG4gICAgICAgIGNvbnRlbnRET00gPSBpbm5lckNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZG9tOiBkb20sXG4gICAgY29udGVudERPTTogY29udGVudERPTVxuICB9O1xufVxuZXhwb3J0cy5Db250ZW50TWF0Y2ggPSBDb250ZW50TWF0Y2g7XG5leHBvcnRzLkRPTVBhcnNlciA9IERPTVBhcnNlcjtcbmV4cG9ydHMuRE9NU2VyaWFsaXplciA9IERPTVNlcmlhbGl6ZXI7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLk1hcmsgPSBNYXJrO1xuZXhwb3J0cy5NYXJrVHlwZSA9IE1hcmtUeXBlO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmV4cG9ydHMuTm9kZVJhbmdlID0gTm9kZVJhbmdlO1xuZXhwb3J0cy5Ob2RlVHlwZSA9IE5vZGVUeXBlO1xuZXhwb3J0cy5SZXBsYWNlRXJyb3IgPSBSZXBsYWNlRXJyb3I7XG5leHBvcnRzLlJlc29sdmVkUG9zID0gUmVzb2x2ZWRQb3M7XG5leHBvcnRzLlNjaGVtYSA9IFNjaGVtYTtcbmV4cG9ydHMuU2xpY2UgPSBTbGljZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs":
/*!*******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; } catch (e) { return typeof fn === \"function\"; } }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar OrderedMap = __webpack_require__(/*! orderedmap */ \"(ssr)/../../node_modules/.pnpm/orderedmap@2.1.1/node_modules/orderedmap/dist/index.cjs\");\nfunction _findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;\n    var childA = a.child(i),\n      childB = b.child(i);\n    if (childA == childB) {\n      pos += childA.nodeSize;\n      continue;\n    }\n    if (!childA.sameMarkup(childB)) return pos;\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++) pos++;\n      return pos;\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = _findDiffStart(childA.content, childB.content, pos + 1);\n      if (inner != null) return inner;\n    }\n    pos += childA.nodeSize;\n  }\n}\nfunction _findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0) return iA == iB ? null : {\n      a: posA,\n      b: posB\n    };\n    var childA = a.child(--iA),\n      childB = b.child(--iB),\n      size = childA.nodeSize;\n    if (childA == childB) {\n      posA -= size;\n      posB -= size;\n      continue;\n    }\n    if (!childA.sameMarkup(childB)) return {\n      a: posA,\n      b: posB\n    };\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0,\n        minSize = Math.min(childA.text.length, childB.text.length);\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;\n        posA--;\n        posB--;\n      }\n      return {\n        a: posA,\n        b: posB\n      };\n    }\n    if (childA.content.size || childB.content.size) {\n      var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n      if (inner) return inner;\n    }\n    posA -= size;\n    posB -= size;\n  }\n}\nvar Fragment = function () {\n  function Fragment(content, size) {\n    _classCallCheck(this, Fragment);\n    this.content = content;\n    this.size = size || 0;\n    if (size == null) for (var i = 0; i < content.length; i++) this.size += content[i].nodeSize;\n  }\n  _createClass(Fragment, [{\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f) {\n      var nodeStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var parent = arguments.length > 4 ? arguments[4] : undefined;\n      for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n          end = pos + child.nodeSize;\n        if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n          var start = pos + 1;\n          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n        }\n        pos = end;\n      }\n    }\n  }, {\n    key: \"descendants\",\n    value: function descendants(f) {\n      this.nodesBetween(0, this.size, f);\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to, blockSeparator, leafText) {\n      var text = \"\",\n        first = true;\n      this.nodesBetween(from, to, function (node, pos) {\n        var nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n        if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n          if (first) first = false;else text += blockSeparator;\n        }\n        text += nodeText;\n      }, 0);\n      return text;\n    }\n  }, {\n    key: \"append\",\n    value: function append(other) {\n      if (!other.size) return this;\n      if (!this.size) return other;\n      var last = this.lastChild,\n        first = other.firstChild,\n        content = this.content.slice(),\n        i = 0;\n      if (last.isText && last.sameMarkup(first)) {\n        content[content.length - 1] = last.withText(last.text + first.text);\n        i = 1;\n      }\n      for (; i < other.content.length; i++) content.push(other.content[i]);\n      return new Fragment(content, this.size + other.size);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      if (from == 0 && to == this.size) return this;\n      var result = [],\n        size = 0;\n      if (to > from) for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n          end = pos + child.nodeSize;\n        if (end > from) {\n          if (pos < from || end > to) {\n            if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n          result.push(child);\n          size += child.nodeSize;\n        }\n        pos = end;\n      }\n      return new Fragment(result, size);\n    }\n  }, {\n    key: \"cutByIndex\",\n    value: function cutByIndex(from, to) {\n      if (from == to) return Fragment.empty;\n      if (from == 0 && to == this.content.length) return this;\n      return new Fragment(this.content.slice(from, to));\n    }\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(index, node) {\n      var current = this.content[index];\n      if (current == node) return this;\n      var copy = this.content.slice();\n      var size = this.size + node.nodeSize - current.nodeSize;\n      copy[index] = node;\n      return new Fragment(copy, size);\n    }\n  }, {\n    key: \"addToStart\",\n    value: function addToStart(node) {\n      return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n  }, {\n    key: \"addToEnd\",\n    value: function addToEnd(node) {\n      return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (this.content.length != other.content.length) return false;\n      for (var i = 0; i < this.content.length; i++) if (!this.content[i].eq(other.content[i])) return false;\n      return true;\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.content.length ? this.content[0] : null;\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.length;\n    }\n  }, {\n    key: \"child\",\n    value: function child(index) {\n      var found = this.content[index];\n      if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n      return found;\n    }\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content[index] || null;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      for (var i = 0, p = 0; i < this.content.length; i++) {\n        var child = this.content[i];\n        f(child, p, i);\n        p += child.nodeSize;\n      }\n    }\n  }, {\n    key: \"findDiffStart\",\n    value: function findDiffStart(other) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return _findDiffStart(this, other, pos);\n    }\n  }, {\n    key: \"findDiffEnd\",\n    value: function findDiffEnd(other) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      var otherPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : other.size;\n      return _findDiffEnd(this, other, pos, otherPos);\n    }\n  }, {\n    key: \"findIndex\",\n    value: function findIndex(pos) {\n      if (pos == 0) return retIndex(0, pos);\n      if (pos == this.size) return retIndex(this.content.length, pos);\n      if (pos > this.size || pos < 0) throw new RangeError(\"Position \".concat(pos, \" outside of fragment (\").concat(this, \")\"));\n      for (var i = 0, curPos = 0;; i++) {\n        var cur = this.child(i),\n          end = curPos + cur.nodeSize;\n        if (end >= pos) {\n          if (end == pos) return retIndex(i + 1, end);\n          return retIndex(i, curPos);\n        }\n        curPos = end;\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"<\" + this.toStringInner() + \">\";\n    }\n  }, {\n    key: \"toStringInner\",\n    value: function toStringInner() {\n      return this.content.join(\", \");\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.content.length ? this.content.map(function (n) {\n        return n.toJSON();\n      }) : null;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, value) {\n      if (!value) return Fragment.empty;\n      if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n      return new Fragment(value.map(schema.nodeFromJSON));\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      if (!array.length) return Fragment.empty;\n      var joined,\n        size = 0;\n      for (var i = 0; i < array.length; i++) {\n        var node = array[i];\n        size += node.nodeSize;\n        if (i && node.isText && array[i - 1].sameMarkup(node)) {\n          if (!joined) joined = array.slice(0, i);\n          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n        } else if (joined) {\n          joined.push(node);\n        }\n      }\n      return new Fragment(joined || array, size);\n    }\n  }, {\n    key: \"from\",\n    value: function from(nodes) {\n      if (!nodes) return Fragment.empty;\n      if (nodes instanceof Fragment) return nodes;\n      if (Array.isArray(nodes)) return this.fromArray(nodes);\n      if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize);\n      throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n  }]);\n  return Fragment;\n}();\nFragment.empty = new Fragment([], 0);\nvar found = {\n  index: 0,\n  offset: 0\n};\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found;\n}\nfunction compareDeep(a, b) {\n  if (a === b) return true;\n  if (!(a && _typeof(a) == \"object\") || !(b && _typeof(b) == \"object\")) return false;\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) return false;\n  if (array) {\n    if (a.length != b.length) return false;\n    for (var i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false;\n  } else {\n    for (var p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false;\n    for (var _p in b) if (!(_p in a)) return false;\n  }\n  return true;\n}\nvar Mark = function () {\n  function Mark(type, attrs) {\n    _classCallCheck(this, Mark);\n    this.type = type;\n    this.attrs = attrs;\n  }\n  _createClass(Mark, [{\n    key: \"addToSet\",\n    value: function addToSet(set) {\n      var copy,\n        placed = false;\n      for (var i = 0; i < set.length; i++) {\n        var other = set[i];\n        if (this.eq(other)) return set;\n        if (this.type.excludes(other.type)) {\n          if (!copy) copy = set.slice(0, i);\n        } else if (other.type.excludes(this.type)) {\n          return set;\n        } else {\n          if (!placed && other.type.rank > this.type.rank) {\n            if (!copy) copy = set.slice(0, i);\n            copy.push(this);\n            placed = true;\n          }\n          if (copy) copy.push(other);\n        }\n      }\n      if (!copy) copy = set.slice();\n      if (!placed) copy.push(this);\n      return copy;\n    }\n  }, {\n    key: \"removeFromSet\",\n    value: function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));\n      return set;\n    }\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return true;\n      return false;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = {\n        type: this.type.name\n      };\n      for (var _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      return obj;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\");\n      var type = schema.marks[json.type];\n      if (!type) throw new RangeError(\"There is no mark type \".concat(json.type, \" in this schema\"));\n      var mark = type.create(json.attrs);\n      type.checkAttrs(mark.attrs);\n      return mark;\n    }\n  }, {\n    key: \"sameSet\",\n    value: function sameSet(a, b) {\n      if (a == b) return true;\n      if (a.length != b.length) return false;\n      for (var i = 0; i < a.length; i++) if (!a[i].eq(b[i])) return false;\n      return true;\n    }\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(marks) {\n      if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;\n      if (marks instanceof Mark) return [marks];\n      var copy = marks.slice();\n      copy.sort(function (a, b) {\n        return a.type.rank - b.type.rank;\n      });\n      return copy;\n    }\n  }]);\n  return Mark;\n}();\nMark.none = [];\nvar ReplaceError = function (_Error) {\n  _inherits(ReplaceError, _Error);\n  var _super = _createSuper(ReplaceError);\n  function ReplaceError() {\n    _classCallCheck(this, ReplaceError);\n    return _super.apply(this, arguments);\n  }\n  return _createClass(ReplaceError);\n}(_wrapNativeSuper(Error));\nvar Slice = function () {\n  function Slice(content, openStart, openEnd) {\n    _classCallCheck(this, Slice);\n    this.content = content;\n    this.openStart = openStart;\n    this.openEnd = openEnd;\n  }\n  _createClass(Slice, [{\n    key: \"size\",\n    get: function get() {\n      return this.content.size - this.openStart - this.openEnd;\n    }\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(pos, fragment) {\n      var content = insertInto(this.content, pos + this.openStart, fragment);\n      return content && new Slice(content, this.openStart, this.openEnd);\n    }\n  }, {\n    key: \"removeBetween\",\n    value: function removeBetween(from, to) {\n      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      if (!this.content.size) return null;\n      var json = {\n        content: this.content.toJSON()\n      };\n      if (this.openStart > 0) json.openStart = this.openStart;\n      if (this.openEnd > 0) json.openEnd = this.openEnd;\n      return json;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) return Slice.empty;\n      var openStart = json.openStart || 0,\n        openEnd = json.openEnd || 0;\n      if (typeof openStart != \"number\" || typeof openEnd != \"number\") throw new RangeError(\"Invalid input for Slice.fromJSON\");\n      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n  }, {\n    key: \"maxOpen\",\n    value: function maxOpen(fragment) {\n      var openIsolating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var openStart = 0,\n        openEnd = 0;\n      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++;\n      for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) openEnd++;\n      return new Slice(fragment, openStart, openEnd);\n    }\n  }]);\n  return Slice;\n}();\nSlice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n  var _content$findIndex = content.findIndex(from),\n    index = _content$findIndex.index,\n    offset = _content$findIndex.offset,\n    child = content.maybeChild(index);\n  var _content$findIndex2 = content.findIndex(to),\n    indexTo = _content$findIndex2.index,\n    offsetTo = _content$findIndex2.offset;\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\");\n    return content.cut(0, from).append(content.cut(to));\n  }\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\");\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n  var _content$findIndex3 = content.findIndex(dist),\n    index = _content$findIndex3.index,\n    offset = _content$findIndex3.offset,\n    child = content.maybeChild(index);\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null;\n    return content.cut(0, dist).append(insert).append(content.cut(dist));\n  }\n  var inner = insertInto(child.content, dist - offset - 1, insert, child);\n  return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction _replace($from, $to, slice) {\n  if (slice.openStart > $from.depth) throw new ReplaceError(\"Inserted content deeper than insertion position\");\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError(\"Inconsistent open depths\");\n  return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth),\n    node = $from.node(depth);\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner));\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth));\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n    var parent = $from.parent,\n      content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n  } else {\n    var _prepareSliceForRepla = prepareSliceForReplace(slice, $from),\n      start = _prepareSliceForRepla.start,\n      end = _prepareSliceForRepla.end;\n    return close(node, replaceThreeWay($from, start, end, $to, depth));\n  }\n}\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type)) throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node;\n}\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);else target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0,\n    endIndex = $end ? $end.index(depth) : node.childCount;\n  if ($start) {\n    startIndex = $start.index(depth);\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n  for (var i = startIndex; i < endIndex; i++) addNode(node.child(i), target);\n  if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n  node.type.checkContent(content);\n  return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n  var content = [];\n  addRange(null, $from, depth, content);\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n    addRange($start, $end, depth, content);\n    if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart,\n    parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n  for (var i = extra - 1; i >= 0; i--) node = $along.node(i).copy(Fragment.from(node));\n  return {\n    start: node.resolveNoCache(slice.openStart + extra),\n    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n  };\n}\nvar ResolvedPos = function () {\n  function ResolvedPos(pos, path, parentOffset) {\n    _classCallCheck(this, ResolvedPos);\n    this.pos = pos;\n    this.path = path;\n    this.parentOffset = parentOffset;\n    this.depth = path.length / 3 - 1;\n  }\n  _createClass(ResolvedPos, [{\n    key: \"resolveDepth\",\n    value: function resolveDepth(val) {\n      if (val == null) return this.depth;\n      if (val < 0) return this.depth + val;\n      return val;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.node(this.depth);\n    }\n  }, {\n    key: \"doc\",\n    get: function get() {\n      return this.node(0);\n    }\n  }, {\n    key: \"node\",\n    value: function node(depth) {\n      return this.path[this.resolveDepth(depth) * 3];\n    }\n  }, {\n    key: \"index\",\n    value: function index(depth) {\n      return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n  }, {\n    key: \"indexAfter\",\n    value: function indexAfter(depth) {\n      depth = this.resolveDepth(depth);\n      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n  }, {\n    key: \"start\",\n    value: function start(depth) {\n      depth = this.resolveDepth(depth);\n      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n  }, {\n    key: \"end\",\n    value: function end(depth) {\n      depth = this.resolveDepth(depth);\n      return this.start(depth) + this.node(depth).content.size;\n    }\n  }, {\n    key: \"before\",\n    value: function before(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position before the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n  }, {\n    key: \"after\",\n    value: function after(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position after the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n  }, {\n    key: \"textOffset\",\n    get: function get() {\n      return this.pos - this.path[this.path.length - 1];\n    }\n  }, {\n    key: \"nodeAfter\",\n    get: function get() {\n      var parent = this.parent,\n        index = this.index(this.depth);\n      if (index == parent.childCount) return null;\n      var dOff = this.pos - this.path[this.path.length - 1],\n        child = parent.child(index);\n      return dOff ? parent.child(index).cut(dOff) : child;\n    }\n  }, {\n    key: \"nodeBefore\",\n    get: function get() {\n      var index = this.index(this.depth);\n      var dOff = this.pos - this.path[this.path.length - 1];\n      if (dOff) return this.parent.child(index).cut(0, dOff);\n      return index == 0 ? null : this.parent.child(index - 1);\n    }\n  }, {\n    key: \"posAtIndex\",\n    value: function posAtIndex(index, depth) {\n      depth = this.resolveDepth(depth);\n      var node = this.path[depth * 3],\n        pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n      for (var i = 0; i < index; i++) pos += node.child(i).nodeSize;\n      return pos;\n    }\n  }, {\n    key: \"marks\",\n    value: function marks() {\n      var parent = this.parent,\n        index = this.index();\n      if (parent.content.size == 0) return Mark.none;\n      if (this.textOffset) return parent.child(index).marks;\n      var main = parent.maybeChild(index - 1),\n        other = parent.maybeChild(index);\n      if (!main) {\n        var tmp = main;\n        main = other;\n        other = tmp;\n      }\n      var marks = main.marks;\n      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);\n      return marks;\n    }\n  }, {\n    key: \"marksAcross\",\n    value: function marksAcross($end) {\n      var after = this.parent.maybeChild(this.index());\n      if (!after || !after.isInline) return null;\n      var marks = after.marks,\n        next = $end.parent.maybeChild($end.index());\n      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);\n      return marks;\n    }\n  }, {\n    key: \"sharedDepth\",\n    value: function sharedDepth(pos) {\n      for (var depth = this.depth; depth > 0; depth--) if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;\n      return 0;\n    }\n  }, {\n    key: \"blockRange\",\n    value: function blockRange() {\n      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n      var pred = arguments.length > 1 ? arguments[1] : undefined;\n      if (other.pos < this.pos) return other.blockRange(this);\n      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);\n      return null;\n    }\n  }, {\n    key: \"sameParent\",\n    value: function sameParent(other) {\n      return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n  }, {\n    key: \"max\",\n    value: function max(other) {\n      return other.pos > this.pos ? other : this;\n    }\n  }, {\n    key: \"min\",\n    value: function min(other) {\n      return other.pos < this.pos ? other : this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var str = \"\";\n      for (var i = 1; i <= this.depth; i++) str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n      return str + \":\" + this.parentOffset;\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(doc, pos) {\n      if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\");\n      var path = [];\n      var start = 0,\n        parentOffset = pos;\n      for (var node = doc;;) {\n        var _node$content$findInd = node.content.findIndex(parentOffset),\n          index = _node$content$findInd.index,\n          offset = _node$content$findInd.offset;\n        var rem = parentOffset - offset;\n        path.push(node, index, start + offset);\n        if (!rem) break;\n        node = node.child(index);\n        if (node.isText) break;\n        parentOffset = rem - 1;\n        start += offset + 1;\n      }\n      return new ResolvedPos(pos, path, parentOffset);\n    }\n  }, {\n    key: \"resolveCached\",\n    value: function resolveCached(doc, pos) {\n      var cache = resolveCache.get(doc);\n      if (cache) {\n        for (var i = 0; i < cache.elts.length; i++) {\n          var elt = cache.elts[i];\n          if (elt.pos == pos) return elt;\n        }\n      } else {\n        resolveCache.set(doc, cache = new ResolveCache());\n      }\n      var result = cache.elts[cache.i] = ResolvedPos.resolve(doc, pos);\n      cache.i = (cache.i + 1) % resolveCacheSize;\n      return result;\n    }\n  }]);\n  return ResolvedPos;\n}();\nvar ResolveCache = _createClass(function ResolveCache() {\n  _classCallCheck(this, ResolveCache);\n  this.elts = [];\n  this.i = 0;\n});\nvar resolveCacheSize = 12,\n  resolveCache = new WeakMap();\nvar NodeRange = function () {\n  function NodeRange($from, $to, depth) {\n    _classCallCheck(this, NodeRange);\n    this.$from = $from;\n    this.$to = $to;\n    this.depth = depth;\n  }\n  _createClass(NodeRange, [{\n    key: \"start\",\n    get: function get() {\n      return this.$from.before(this.depth + 1);\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.$to.after(this.depth + 1);\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.$from.node(this.depth);\n    }\n  }, {\n    key: \"startIndex\",\n    get: function get() {\n      return this.$from.index(this.depth);\n    }\n  }, {\n    key: \"endIndex\",\n    get: function get() {\n      return this.$to.indexAfter(this.depth);\n    }\n  }]);\n  return NodeRange;\n}();\nvar emptyAttrs = Object.create(null);\nvar Node = function () {\n  function Node(type, attrs, content) {\n    var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Mark.none;\n    _classCallCheck(this, Node);\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.content = content || Fragment.empty;\n  }\n  _createClass(Node, [{\n    key: \"children\",\n    get: function get() {\n      return this.content.content;\n    }\n  }, {\n    key: \"nodeSize\",\n    get: function get() {\n      return this.isLeaf ? 1 : 2 + this.content.size;\n    }\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.childCount;\n    }\n  }, {\n    key: \"child\",\n    value: function child(index) {\n      return this.content.child(index);\n    }\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content.maybeChild(index);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      this.content.forEach(f);\n    }\n  }, {\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f) {\n      var startPos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      this.content.nodesBetween(from, to, f, startPos, this);\n    }\n  }, {\n    key: \"descendants\",\n    value: function descendants(f) {\n      this.nodesBetween(0, this.content.size, f);\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to, blockSeparator, leafText) {\n      return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.content.firstChild;\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.lastChild;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n  }, {\n    key: \"sameMarkup\",\n    value: function sameMarkup(other) {\n      return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n  }, {\n    key: \"hasMarkup\",\n    value: function hasMarkup(type, attrs, marks) {\n      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (content == this.content) return this;\n      return new Node(this.type, this.attrs, content, this.marks);\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;\n      if (from == 0 && to == this.content.size) return this;\n      return this.copy(this.content.cut(from, to));\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;\n      var includeParents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (from == to) return Slice.empty;\n      var $from = this.resolve(from),\n        $to = this.resolve(to);\n      var depth = includeParents ? 0 : $from.sharedDepth(to);\n      var start = $from.start(depth),\n        node = $from.node(depth);\n      var content = node.content.cut($from.pos - start, $to.pos - start);\n      return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, slice) {\n      return _replace(this.resolve(from), this.resolve(to), slice);\n    }\n  }, {\n    key: \"nodeAt\",\n    value: function nodeAt(pos) {\n      for (var node = this;;) {\n        var _node$content$findInd2 = node.content.findIndex(pos),\n          index = _node$content$findInd2.index,\n          offset = _node$content$findInd2.offset;\n        node = node.maybeChild(index);\n        if (!node) return null;\n        if (offset == pos || node.isText) return node;\n        pos -= offset + 1;\n      }\n    }\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      var _this$content$findInd = this.content.findIndex(pos),\n        index = _this$content$findInd.index,\n        offset = _this$content$findInd.offset;\n      return {\n        node: this.content.maybeChild(index),\n        index: index,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      if (pos == 0) return {\n        node: null,\n        index: 0,\n        offset: 0\n      };\n      var _this$content$findInd2 = this.content.findIndex(pos),\n        index = _this$content$findInd2.index,\n        offset = _this$content$findInd2.offset;\n      if (offset < pos) return {\n        node: this.content.child(index),\n        index: index,\n        offset: offset\n      };\n      var node = this.content.child(index - 1);\n      return {\n        node: node,\n        index: index - 1,\n        offset: offset - node.nodeSize\n      };\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      return ResolvedPos.resolveCached(this, pos);\n    }\n  }, {\n    key: \"resolveNoCache\",\n    value: function resolveNoCache(pos) {\n      return ResolvedPos.resolve(this, pos);\n    }\n  }, {\n    key: \"rangeHasMark\",\n    value: function rangeHasMark(from, to, type) {\n      var found = false;\n      if (to > from) this.nodesBetween(from, to, function (node) {\n        if (type.isInSet(node.marks)) found = true;\n        return !found;\n      });\n      return found;\n    }\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      return this.type.isBlock;\n    }\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.type.isTextblock;\n    }\n  }, {\n    key: \"inlineContent\",\n    get: function get() {\n      return this.type.inlineContent;\n    }\n  }, {\n    key: \"isInline\",\n    get: function get() {\n      return this.type.isInline;\n    }\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return this.type.isText;\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.type.isLeaf;\n    }\n  }, {\n    key: \"isAtom\",\n    get: function get() {\n      return this.type.isAtom;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n      var name = this.type.name;\n      if (this.content.size) name += \"(\" + this.content.toStringInner() + \")\";\n      return wrapMarks(this.marks, name);\n    }\n  }, {\n    key: \"contentMatchAt\",\n    value: function contentMatchAt(index) {\n      var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n      if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\");\n      return match;\n    }\n  }, {\n    key: \"canReplace\",\n    value: function canReplace(from, to) {\n      var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Fragment.empty;\n      var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : replacement.childCount;\n      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n      var two = one && one.matchFragment(this.content, to);\n      if (!two || !two.validEnd) return false;\n      for (var i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false;\n      return true;\n    }\n  }, {\n    key: \"canReplaceWith\",\n    value: function canReplaceWith(from, to, type, marks) {\n      if (marks && !this.type.allowsMarks(marks)) return false;\n      var start = this.contentMatchAt(from).matchType(type);\n      var end = start && start.matchFragment(this.content, to);\n      return end ? end.validEnd : false;\n    }\n  }, {\n    key: \"canAppend\",\n    value: function canAppend(other) {\n      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);\n    }\n  }, {\n    key: \"check\",\n    value: function check() {\n      this.type.checkContent(this.content);\n      this.type.checkAttrs(this.attrs);\n      var copy = Mark.none;\n      for (var i = 0; i < this.marks.length; i++) {\n        var mark = this.marks[i];\n        mark.type.checkAttrs(mark.attrs);\n        copy = mark.addToSet(copy);\n      }\n      if (!Mark.sameSet(copy, this.marks)) throw new RangeError(\"Invalid collection of marks for node \".concat(this.type.name, \": \").concat(this.marks.map(function (m) {\n        return m.type.name;\n      })));\n      this.content.forEach(function (node) {\n        return node.check();\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = {\n        type: this.type.name\n      };\n      for (var _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      if (this.content.size) obj.content = this.content.toJSON();\n      if (this.marks.length) obj.marks = this.marks.map(function (n) {\n        return n.toJSON();\n      });\n      return obj;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\");\n      var marks = undefined;\n      if (json.marks) {\n        if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n        marks = json.marks.map(schema.markFromJSON);\n      }\n      if (json.type == \"text\") {\n        if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\");\n        return schema.text(json.text, marks);\n      }\n      var content = Fragment.fromJSON(schema, json.content);\n      var node = schema.nodeType(json.type).create(json.attrs, content, marks);\n      node.type.checkAttrs(node.attrs);\n      return node;\n    }\n  }]);\n  return Node;\n}();\nNode.prototype.text = undefined;\nvar TextNode = function (_Node) {\n  _inherits(TextNode, _Node);\n  var _super2 = _createSuper(TextNode);\n  function TextNode(type, attrs, content, marks) {\n    var _this;\n    _classCallCheck(this, TextNode);\n    _this = _super2.call(this, type, attrs, null, marks);\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\");\n    _this.text = content;\n    return _this;\n  }\n  _createClass(TextNode, [{\n    key: \"toString\",\n    value: function toString() {\n      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n      return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.text;\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to) {\n      return this.text.slice(from, to);\n    }\n  }, {\n    key: \"nodeSize\",\n    get: function get() {\n      return this.text.length;\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n  }, {\n    key: \"withText\",\n    value: function withText(text) {\n      if (text == this.text) return this;\n      return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.text.length;\n      if (from == 0 && to == this.text.length) return this;\n      return this.withText(this.text.slice(from, to));\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.sameMarkup(other) && this.text == other.text;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var base = _get(_getPrototypeOf(TextNode.prototype), \"toJSON\", this).call(this);\n      base.text = this.text;\n      return base;\n    }\n  }]);\n  return TextNode;\n}(Node);\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--) str = marks[i].type.name + \"(\" + str + \")\";\n  return str;\n}\nvar ContentMatch = function () {\n  function ContentMatch(validEnd) {\n    _classCallCheck(this, ContentMatch);\n    this.validEnd = validEnd;\n    this.next = [];\n    this.wrapCache = [];\n  }\n  _createClass(ContentMatch, [{\n    key: \"matchType\",\n    value: function matchType(type) {\n      for (var i = 0; i < this.next.length; i++) if (this.next[i].type == type) return this.next[i].next;\n      return null;\n    }\n  }, {\n    key: \"matchFragment\",\n    value: function matchFragment(frag) {\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : frag.childCount;\n      var cur = this;\n      for (var i = start; cur && i < end; i++) cur = cur.matchType(frag.child(i).type);\n      return cur;\n    }\n  }, {\n    key: \"inlineContent\",\n    get: function get() {\n      return this.next.length != 0 && this.next[0].type.isInline;\n    }\n  }, {\n    key: \"defaultType\",\n    get: function get() {\n      for (var i = 0; i < this.next.length; i++) {\n        var type = this.next[i].type;\n        if (!(type.isText || type.hasRequiredAttrs())) return type;\n      }\n      return null;\n    }\n  }, {\n    key: \"compatible\",\n    value: function compatible(other) {\n      for (var i = 0; i < this.next.length; i++) for (var j = 0; j < other.next.length; j++) if (this.next[i].type == other.next[j].type) return true;\n      return false;\n    }\n  }, {\n    key: \"fillBefore\",\n    value: function fillBefore(after) {\n      var toEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var seen = [this];\n      function search(match, types) {\n        var finished = match.matchFragment(after, startIndex);\n        if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map(function (tp) {\n          return tp.createAndFill();\n        }));\n        for (var i = 0; i < match.next.length; i++) {\n          var _match$next$i = match.next[i],\n            type = _match$next$i.type,\n            next = _match$next$i.next;\n          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n            seen.push(next);\n            var _found = search(next, types.concat(type));\n            if (_found) return _found;\n          }\n        }\n        return null;\n      }\n      return search(this, []);\n    }\n  }, {\n    key: \"findWrapping\",\n    value: function findWrapping(target) {\n      for (var i = 0; i < this.wrapCache.length; i += 2) if (this.wrapCache[i] == target) return this.wrapCache[i + 1];\n      var computed = this.computeWrapping(target);\n      this.wrapCache.push(target, computed);\n      return computed;\n    }\n  }, {\n    key: \"computeWrapping\",\n    value: function computeWrapping(target) {\n      var seen = Object.create(null),\n        active = [{\n          match: this,\n          type: null,\n          via: null\n        }];\n      while (active.length) {\n        var current = active.shift(),\n          match = current.match;\n        if (match.matchType(target)) {\n          var result = [];\n          for (var obj = current; obj.type; obj = obj.via) result.push(obj.type);\n          return result.reverse();\n        }\n        for (var i = 0; i < match.next.length; i++) {\n          var _match$next$i2 = match.next[i],\n            type = _match$next$i2.type,\n            next = _match$next$i2.next;\n          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n            active.push({\n              match: type.contentMatch,\n              type: type,\n              via: current\n            });\n            seen[type.name] = true;\n          }\n        }\n      }\n      return null;\n    }\n  }, {\n    key: \"edgeCount\",\n    get: function get() {\n      return this.next.length;\n    }\n  }, {\n    key: \"edge\",\n    value: function edge(n) {\n      if (n >= this.next.length) throw new RangeError(\"There's no \".concat(n, \"th edge in this content match\"));\n      return this.next[n];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var seen = [];\n      function scan(m) {\n        seen.push(m);\n        for (var i = 0; i < m.next.length; i++) if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);\n      }\n      scan(this);\n      return seen.map(function (m, i) {\n        var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n        for (var _i = 0; _i < m.next.length; _i++) out += (_i ? \", \" : \"\") + m.next[_i].type.name + \"->\" + seen.indexOf(m.next[_i].next);\n        return out;\n      }).join(\"\\n\");\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(string, nodeTypes) {\n      var stream = new TokenStream(string, nodeTypes);\n      if (stream.next == null) return ContentMatch.empty;\n      var expr = parseExpr(stream);\n      if (stream.next) stream.err(\"Unexpected trailing text\");\n      var match = dfa(nfa(expr));\n      checkForDeadEnds(match, stream);\n      return match;\n    }\n  }]);\n  return ContentMatch;\n}();\nContentMatch.empty = new ContentMatch(true);\nvar TokenStream = function () {\n  function TokenStream(string, nodeTypes) {\n    _classCallCheck(this, TokenStream);\n    this.string = string;\n    this.nodeTypes = nodeTypes;\n    this.inline = null;\n    this.pos = 0;\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop();\n    if (this.tokens[0] == \"\") this.tokens.shift();\n  }\n  _createClass(TokenStream, [{\n    key: \"next\",\n    get: function get() {\n      return this.tokens[this.pos];\n    }\n  }, {\n    key: \"eat\",\n    value: function eat(tok) {\n      return this.next == tok && (this.pos++ || true);\n    }\n  }, {\n    key: \"err\",\n    value: function err(str) {\n      throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n    }\n  }]);\n  return TokenStream;\n}();\nfunction parseExpr(stream) {\n  var exprs = [];\n  do {\n    exprs.push(parseExprSeq(stream));\n  } while (stream.eat(\"|\"));\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"choice\",\n    exprs: exprs\n  };\n}\nfunction parseExprSeq(stream) {\n  var exprs = [];\n  do {\n    exprs.push(parseExprSubscript(stream));\n  } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"seq\",\n    exprs: exprs\n  };\n}\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n  for (;;) {\n    if (stream.eat(\"+\")) expr = {\n      type: \"plus\",\n      expr: expr\n    };else if (stream.eat(\"*\")) expr = {\n      type: \"star\",\n      expr: expr\n    };else if (stream.eat(\"?\")) expr = {\n      type: \"opt\",\n      expr: expr\n    };else if (stream.eat(\"{\")) expr = parseExprRange(stream, expr);else break;\n  }\n  return expr;\n}\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\");\n  var result = Number(stream.next);\n  stream.pos++;\n  return result;\n}\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream),\n    max = min;\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream);else max = -1;\n  }\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\");\n  return {\n    type: \"range\",\n    min: min,\n    max: max,\n    expr: expr\n  };\n}\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes,\n    type = types[name];\n  if (type) return [type];\n  var result = [];\n  for (var typeName in types) {\n    var _type = types[typeName];\n    if (_type.isInGroup(name)) result.push(_type);\n  }\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\");\n  return result;\n}\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\");\n    return expr;\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) stream.inline = type.isInline;else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\");\n      return {\n        type: \"name\",\n        value: type\n      };\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {\n      type: \"choice\",\n      exprs: exprs\n    };\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa;\n  function node() {\n    return nfa.push([]) - 1;\n  }\n  function edge(from, to, term) {\n    var edge = {\n      term: term,\n      to: to\n    };\n    nfa[from].push(edge);\n    return edge;\n  }\n  function connect(edges, to) {\n    edges.forEach(function (edge) {\n      return edge.to = to;\n    });\n  }\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) {\n        return out.concat(compile(expr, from));\n      }, []);\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) return next;\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr.type == \"plus\") {\n      var _loop = node();\n      connect(compile(expr.expr, from), _loop);\n      connect(compile(expr.expr, _loop), _loop);\n      return [edge(_loop)];\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from));\n    } else if (expr.type == \"range\") {\n      var cur = from;\n      for (var _i2 = 0; _i2 < expr.min; _i2++) {\n        var _next = node();\n        connect(compile(expr.expr, cur), _next);\n        cur = _next;\n      }\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var _i3 = expr.min; _i3 < expr.max; _i3++) {\n          var _next2 = node();\n          edge(cur, _next2);\n          connect(compile(expr.expr, cur), _next2);\n          cur = _next2;\n        }\n      }\n      return [edge(cur)];\n    } else if (expr.type == \"name\") {\n      return [edge(from, undefined, expr.value)];\n    } else {\n      throw new Error(\"Unknown expr type\");\n    }\n  }\n}\nfunction cmp(a, b) {\n  return b - a;\n}\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp);\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);\n    result.push(node);\n    for (var i = 0; i < edges.length; i++) {\n      var _edges$i = edges[i],\n        term = _edges$i.term,\n        to = _edges$i.to;\n      if (!term && result.indexOf(to) == -1) scan(to);\n    }\n  }\n}\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0));\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (_ref) {\n        var term = _ref.term,\n          to = _ref.to;\n        if (!term) return;\n        var set;\n        for (var i = 0; i < out.length; i++) if (out[i][0] == term) set = out[i][1];\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) out.push([term, set = []]);\n          if (set.indexOf(node) == -1) set.push(node);\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n    for (var i = 0; i < out.length; i++) {\n      var _states = out[i][1].sort(cmp);\n      state.next.push({\n        type: out[i][0],\n        next: labeled[_states.join(\",\")] || explore(_states)\n      });\n    }\n    return state;\n  }\n}\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i],\n      dead = !state.validEnd,\n      nodes = [];\n    for (var j = 0; j < state.next.length; j++) {\n      var _state$next$j = state.next[j],\n        type = _state$next$j.type,\n        next = _state$next$j.next;\n      nodes.push(type.name);\n      if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;\n      if (work.indexOf(next) == -1) work.push(next);\n    }\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n  }\n}\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) return null;\n    defaults[attrName] = attr[\"default\"];\n  }\n  return defaults;\n}\nfunction _computeAttrs(attrs, value) {\n  var built = Object.create(null);\n  for (var name in attrs) {\n    var given = value && value[name];\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) given = attr[\"default\"];else throw new RangeError(\"No value supplied for attribute \" + name);\n    }\n    built[name] = given;\n  }\n  return built;\n}\nfunction _checkAttrs(attrs, values, type, name) {\n  for (var _name in values) if (!(_name in attrs)) throw new RangeError(\"Unsupported attribute \".concat(_name, \" for \").concat(type, \" of type \").concat(_name));\n  for (var _name2 in attrs) {\n    var attr = attrs[_name2];\n    if (attr.validate) attr.validate(values[_name2]);\n  }\n}\nfunction initAttrs(typeName, attrs) {\n  var result = Object.create(null);\n  if (attrs) for (var name in attrs) result[name] = new Attribute(typeName, name, attrs[name]);\n  return result;\n}\nvar NodeType = function () {\n  function NodeType(name, schema, spec) {\n    _classCallCheck(this, NodeType);\n    this.name = name;\n    this.schema = schema;\n    this.spec = spec;\n    this.markSet = null;\n    this.groups = spec.group ? spec.group.split(\" \") : [];\n    this.attrs = initAttrs(name, spec.attrs);\n    this.defaultAttrs = defaultAttrs(this.attrs);\n    this.contentMatch = null;\n    this.inlineContent = null;\n    this.isBlock = !(spec.inline || name == \"text\");\n    this.isText = name == \"text\";\n  }\n  _createClass(NodeType, [{\n    key: \"isInline\",\n    get: function get() {\n      return !this.isBlock;\n    }\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.isBlock && this.inlineContent;\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.contentMatch == ContentMatch.empty;\n    }\n  }, {\n    key: \"isAtom\",\n    get: function get() {\n      return this.isLeaf || !!this.spec.atom;\n    }\n  }, {\n    key: \"isInGroup\",\n    value: function isInGroup(group) {\n      return this.groups.indexOf(group) > -1;\n    }\n  }, {\n    key: \"whitespace\",\n    get: function get() {\n      return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n  }, {\n    key: \"hasRequiredAttrs\",\n    value: function hasRequiredAttrs() {\n      for (var n in this.attrs) if (this.attrs[n].isRequired) return true;\n      return false;\n    }\n  }, {\n    key: \"compatibleContent\",\n    value: function compatibleContent(other) {\n      return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n  }, {\n    key: \"computeAttrs\",\n    value: function computeAttrs(attrs) {\n      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _computeAttrs(this.attrs, attrs);\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\");\n      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n  }, {\n    key: \"createChecked\",\n    value: function createChecked() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      content = Fragment.from(content);\n      this.checkContent(content);\n      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n  }, {\n    key: \"createAndFill\",\n    value: function createAndFill() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      attrs = this.computeAttrs(attrs);\n      content = Fragment.from(content);\n      if (content.size) {\n        var before = this.contentMatch.fillBefore(content);\n        if (!before) return null;\n        content = before.append(content);\n      }\n      var matched = this.contentMatch.matchFragment(content);\n      var after = matched && matched.fillBefore(Fragment.empty, true);\n      if (!after) return null;\n      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n  }, {\n    key: \"validContent\",\n    value: function validContent(content) {\n      var result = this.contentMatch.matchFragment(content);\n      if (!result || !result.validEnd) return false;\n      for (var i = 0; i < content.childCount; i++) if (!this.allowsMarks(content.child(i).marks)) return false;\n      return true;\n    }\n  }, {\n    key: \"checkContent\",\n    value: function checkContent(content) {\n      if (!this.validContent(content)) throw new RangeError(\"Invalid content for node \".concat(this.name, \": \").concat(content.toString().slice(0, 50)));\n    }\n  }, {\n    key: \"checkAttrs\",\n    value: function checkAttrs(attrs) {\n      _checkAttrs(this.attrs, attrs, \"node\", this.name);\n    }\n  }, {\n    key: \"allowsMarkType\",\n    value: function allowsMarkType(markType) {\n      return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n  }, {\n    key: \"allowsMarks\",\n    value: function allowsMarks(marks) {\n      if (this.markSet == null) return true;\n      for (var i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false;\n      return true;\n    }\n  }, {\n    key: \"allowedMarks\",\n    value: function allowedMarks(marks) {\n      if (this.markSet == null) return marks;\n      var copy;\n      for (var i = 0; i < marks.length; i++) {\n        if (!this.allowsMarkType(marks[i].type)) {\n          if (!copy) copy = marks.slice(0, i);\n        } else if (copy) {\n          copy.push(marks[i]);\n        }\n      }\n      return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(nodes, schema) {\n      var result = Object.create(null);\n      nodes.forEach(function (name, spec) {\n        return result[name] = new NodeType(name, schema, spec);\n      });\n      var topType = schema.spec.topNode || \"doc\";\n      if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n      if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\");\n      for (var _ in result.text.attrs) throw new RangeError(\"The text node type should not have attributes\");\n      return result;\n    }\n  }]);\n  return NodeType;\n}();\nfunction validateType(typeName, attrName, type) {\n  var types = type.split(\"|\");\n  return function (value) {\n    var name = value === null ? \"null\" : _typeof(value);\n    if (types.indexOf(name) < 0) throw new RangeError(\"Expected value of type \".concat(types, \" for attribute \").concat(attrName, \" on type \").concat(typeName, \", got \").concat(name));\n  };\n}\nvar Attribute = function () {\n  function Attribute(typeName, attrName, options) {\n    _classCallCheck(this, Attribute);\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n    this[\"default\"] = options[\"default\"];\n    this.validate = typeof options.validate == \"string\" ? validateType(typeName, attrName, options.validate) : options.validate;\n  }\n  _createClass(Attribute, [{\n    key: \"isRequired\",\n    get: function get() {\n      return !this.hasDefault;\n    }\n  }]);\n  return Attribute;\n}();\nvar MarkType = function () {\n  function MarkType(name, rank, schema, spec) {\n    _classCallCheck(this, MarkType);\n    this.name = name;\n    this.rank = rank;\n    this.schema = schema;\n    this.spec = spec;\n    this.attrs = initAttrs(name, spec.attrs);\n    this.excluded = null;\n    var defaults = defaultAttrs(this.attrs);\n    this.instance = defaults ? new Mark(this, defaults) : null;\n  }\n  _createClass(MarkType, [{\n    key: \"create\",\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (!attrs && this.instance) return this.instance;\n      return new Mark(this, _computeAttrs(this.attrs, attrs));\n    }\n  }, {\n    key: \"removeFromSet\",\n    value: function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) if (set[i].type == this) {\n        set = set.slice(0, i).concat(set.slice(i + 1));\n        i--;\n      }\n      return set;\n    }\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) if (set[i].type == this) return set[i];\n    }\n  }, {\n    key: \"checkAttrs\",\n    value: function checkAttrs(attrs) {\n      _checkAttrs(this.attrs, attrs, \"mark\", this.name);\n    }\n  }, {\n    key: \"excludes\",\n    value: function excludes(other) {\n      return this.excluded.indexOf(other) > -1;\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(marks, schema) {\n      var result = Object.create(null),\n        rank = 0;\n      marks.forEach(function (name, spec) {\n        return result[name] = new MarkType(name, rank++, schema, spec);\n      });\n      return result;\n    }\n  }]);\n  return MarkType;\n}();\nvar Schema = function () {\n  function Schema(spec) {\n    var _this2 = this;\n    _classCallCheck(this, Schema);\n    this.linebreakReplacement = null;\n    this.cached = Object.create(null);\n    var instanceSpec = this.spec = {};\n    for (var prop in spec) instanceSpec[prop] = spec[prop];\n    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);\n    this.marks = MarkType.compile(this.spec.marks, this);\n    var contentExprCache = Object.create(null);\n    for (var _prop in this.nodes) {\n      if (_prop in this.marks) throw new RangeError(_prop + \" can not be both a node and a mark\");\n      var type = this.nodes[_prop],\n        contentExpr = type.spec.content || \"\",\n        markExpr = type.spec.marks;\n      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n      type.inlineContent = type.contentMatch.inlineContent;\n      if (type.spec.linebreakReplacement) {\n        if (this.linebreakReplacement) throw new RangeError(\"Multiple linebreak nodes defined\");\n        if (!type.isInline || !type.isLeaf) throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n        this.linebreakReplacement = type;\n      }\n      type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n    }\n    for (var _prop2 in this.marks) {\n      var _type2 = this.marks[_prop2],\n        excl = _type2.spec.excludes;\n      _type2.excluded = excl == null ? [_type2] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n    }\n    this.nodeFromJSON = function (json) {\n      return Node.fromJSON(_this2, json);\n    };\n    this.markFromJSON = function (json) {\n      return Mark.fromJSON(_this2, json);\n    };\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n    this.cached.wrappings = Object.create(null);\n  }\n  _createClass(Schema, [{\n    key: \"node\",\n    value: function node(type) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var content = arguments.length > 2 ? arguments[2] : undefined;\n      var marks = arguments.length > 3 ? arguments[3] : undefined;\n      if (typeof type == \"string\") type = this.nodeType(type);else if (!(type instanceof NodeType)) throw new RangeError(\"Invalid node type: \" + type);else if (type.schema != this) throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n      return type.createChecked(attrs, content, marks);\n    }\n  }, {\n    key: \"text\",\n    value: function text(_text, marks) {\n      var type = this.nodes.text;\n      return new TextNode(type, type.defaultAttrs, _text, Mark.setFrom(marks));\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(type, attrs) {\n      if (typeof type == \"string\") type = this.marks[type];\n      return type.create(attrs);\n    }\n  }, {\n    key: \"nodeType\",\n    value: function nodeType(name) {\n      var found = this.nodes[name];\n      if (!found) throw new RangeError(\"Unknown node type: \" + name);\n      return found;\n    }\n  }]);\n  return Schema;\n}();\nfunction gatherMarks(schema, marks) {\n  var found = [];\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i],\n      mark = schema.marks[name],\n      ok = mark;\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var _mark = schema.marks[prop];\n        if (name == \"_\" || _mark.spec.group && _mark.spec.group.split(\" \").indexOf(name) > -1) found.push(ok = _mark);\n      }\n    }\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n  }\n  return found;\n}\nfunction isTagRule(rule) {\n  return rule.tag != null;\n}\nfunction isStyleRule(rule) {\n  return rule.style != null;\n}\nvar DOMParser = function () {\n  function DOMParser(schema, rules) {\n    var _this3 = this;\n    _classCallCheck(this, DOMParser);\n    this.schema = schema;\n    this.rules = rules;\n    this.tags = [];\n    this.styles = [];\n    var matchedStyles = this.matchedStyles = [];\n    rules.forEach(function (rule) {\n      if (isTagRule(rule)) {\n        _this3.tags.push(rule);\n      } else if (isStyleRule(rule)) {\n        var prop = /[^=]*/.exec(rule.style)[0];\n        if (matchedStyles.indexOf(prop) < 0) matchedStyles.push(prop);\n        _this3.styles.push(rule);\n      }\n    });\n    this.normalizeLists = !this.tags.some(function (r) {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false;\n      var node = schema.nodes[r.node];\n      return node.contentMatch.matchType(node);\n    });\n  }\n  _createClass(DOMParser, [{\n    key: \"parse\",\n    value: function parse(dom) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = new ParseContext(this, options, false);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return context.finish();\n    }\n  }, {\n    key: \"parseSlice\",\n    value: function parseSlice(dom) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = new ParseContext(this, options, true);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return Slice.maxOpen(context.finish());\n    }\n  }, {\n    key: \"matchTag\",\n    value: function matchTag(dom, context, after) {\n      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n        var rule = this.tags[i];\n        if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n          if (rule.getAttrs) {\n            var result = rule.getAttrs(dom);\n            if (result === false) continue;\n            rule.attrs = result || undefined;\n          }\n          return rule;\n        }\n      }\n    }\n  }, {\n    key: \"matchStyle\",\n    value: function matchStyle(prop, value, context, after) {\n      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n        var rule = this.styles[i],\n          style = rule.style;\n        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;\n        if (rule.getAttrs) {\n          var result = rule.getAttrs(value);\n          if (result === false) continue;\n          rule.attrs = result || undefined;\n        }\n        return rule;\n      }\n    }\n  }], [{\n    key: \"schemaRules\",\n    value: function schemaRules(schema) {\n      var result = [];\n      function insert(rule) {\n        var priority = rule.priority == null ? 50 : rule.priority,\n          i = 0;\n        for (; i < result.length; i++) {\n          var next = result[i],\n            nextPriority = next.priority == null ? 50 : next.priority;\n          if (nextPriority < priority) break;\n        }\n        result.splice(i, 0, rule);\n      }\n      var _loop2 = function _loop2(name) {\n        var rules = schema.marks[name].spec.parseDOM;\n        if (rules) rules.forEach(function (rule) {\n          insert(rule = copy(rule));\n          if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;\n        });\n      };\n      for (var name in schema.marks) {\n        _loop2(name);\n      }\n      var _loop3 = function _loop3(_name3) {\n        var rules = schema.nodes[_name3].spec.parseDOM;\n        if (rules) rules.forEach(function (rule) {\n          insert(rule = copy(rule));\n          if (!(rule.node || rule.ignore || rule.mark)) rule.node = _name3;\n        });\n      };\n      for (var _name3 in schema.nodes) {\n        _loop3(_name3);\n      }\n      return result;\n    }\n  }, {\n    key: \"fromSchema\",\n    value: function fromSchema(schema) {\n      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n  }]);\n  return DOMParser;\n}();\nvar blockTags = {\n  address: true,\n  article: true,\n  aside: true,\n  blockquote: true,\n  canvas: true,\n  dd: true,\n  div: true,\n  dl: true,\n  fieldset: true,\n  figcaption: true,\n  figure: true,\n  footer: true,\n  form: true,\n  h1: true,\n  h2: true,\n  h3: true,\n  h4: true,\n  h5: true,\n  h6: true,\n  header: true,\n  hgroup: true,\n  hr: true,\n  li: true,\n  noscript: true,\n  ol: true,\n  output: true,\n  p: true,\n  pre: true,\n  section: true,\n  table: true,\n  tfoot: true,\n  ul: true\n};\nvar ignoreTags = {\n  head: true,\n  noscript: true,\n  object: true,\n  script: true,\n  style: true,\n  title: true\n};\nvar listTags = {\n  ol: true,\n  ul: true\n};\nvar OPT_PRESERVE_WS = 1,\n  OPT_PRESERVE_WS_FULL = 2,\n  OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nvar NodeContext = function () {\n  function NodeContext(type, attrs, marks, solid, match, options) {\n    _classCallCheck(this, NodeContext);\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.solid = solid;\n    this.options = options;\n    this.content = [];\n    this.activeMarks = Mark.none;\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  }\n  _createClass(NodeContext, [{\n    key: \"findWrapping\",\n    value: function findWrapping(node) {\n      if (!this.match) {\n        if (!this.type) return [];\n        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n        if (fill) {\n          this.match = this.type.contentMatch.matchFragment(fill);\n        } else {\n          var start = this.type.contentMatch,\n            wrap;\n          if (wrap = start.findWrapping(node.type)) {\n            this.match = start;\n            return wrap;\n          } else {\n            return null;\n          }\n        }\n      }\n      return this.match.findWrapping(node.type);\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(openEnd) {\n      if (!(this.options & OPT_PRESERVE_WS)) {\n        var last = this.content[this.content.length - 1],\n          m;\n        if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n          var text = last;\n          if (last.text.length == m[0].length) this.content.pop();else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n        }\n      }\n      var content = Fragment.from(this.content);\n      if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));\n      return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n  }, {\n    key: \"inlineContext\",\n    value: function inlineContext(node) {\n      if (this.type) return this.type.inlineContent;\n      if (this.content.length) return this.content[0].isInline;\n      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n  }]);\n  return NodeContext;\n}();\nvar ParseContext = function () {\n  function ParseContext(parser, options, isOpen) {\n    _classCallCheck(this, ParseContext);\n    this.parser = parser;\n    this.options = options;\n    this.isOpen = isOpen;\n    this.open = 0;\n    this.localPreserveWS = false;\n    var topNode = options.topNode,\n      topContext;\n    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n    if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);else if (isOpen) topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);\n    this.nodes = [topContext];\n    this.find = options.findPositions;\n    this.needsBlock = false;\n  }\n  _createClass(ParseContext, [{\n    key: \"top\",\n    get: function get() {\n      return this.nodes[this.open];\n    }\n  }, {\n    key: \"addDOM\",\n    value: function addDOM(dom, marks) {\n      if (dom.nodeType == 3) this.addTextNode(dom, marks);else if (dom.nodeType == 1) this.addElement(dom, marks);\n    }\n  }, {\n    key: \"addTextNode\",\n    value: function addTextNode(dom, marks) {\n      var value = dom.nodeValue;\n      var top = this.top,\n        preserveWS = top.options & OPT_PRESERVE_WS_FULL ? \"full\" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;\n      if (preserveWS === \"full\" || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n        if (!preserveWS) {\n          value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n          if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n            var nodeBefore = top.content[top.content.length - 1];\n            var domNodeBefore = dom.previousSibling;\n            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)) value = value.slice(1);\n          }\n        } else if (preserveWS !== \"full\") {\n          value = value.replace(/\\r?\\n|\\r/g, \" \");\n        } else {\n          value = value.replace(/\\r\\n?/g, \"\\n\");\n        }\n        if (value) this.insertNode(this.parser.schema.text(value), marks, !/\\S/.test(value));\n        this.findInText(dom);\n      } else {\n        this.findInside(dom);\n      }\n    }\n  }, {\n    key: \"addElement\",\n    value: function addElement(dom, marks, matchAfter) {\n      var outerWS = this.localPreserveWS,\n        top = this.top;\n      if (dom.tagName == \"PRE\" || /pre/.test(dom.style && dom.style.whiteSpace)) this.localPreserveWS = true;\n      var name = dom.nodeName.toLowerCase(),\n        ruleID;\n      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);\n      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n      out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n        this.findInside(dom);\n        this.ignoreFallback(dom, marks);\n      } else if (!rule || rule.skip || rule.closeParent) {\n        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);else if (rule && rule.skip.nodeType) dom = rule.skip;\n        var sync,\n          oldNeedsBlock = this.needsBlock;\n        if (blockTags.hasOwnProperty(name)) {\n          if (top.content.length && top.content[0].isInline && this.open) {\n            this.open--;\n            top = this.top;\n          }\n          sync = true;\n          if (!top.type) this.needsBlock = true;\n        } else if (!dom.firstChild) {\n          this.leafFallback(dom, marks);\n          break out;\n        }\n        var innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);\n        if (innerMarks) this.addAll(dom, innerMarks);\n        if (sync) this.sync(top);\n        this.needsBlock = oldNeedsBlock;\n      } else {\n        var _innerMarks = this.readStyles(dom, marks);\n        if (_innerMarks) this.addElementByRule(dom, rule, _innerMarks, rule.consuming === false ? ruleID : undefined);\n      }\n      this.localPreserveWS = outerWS;\n    }\n  }, {\n    key: \"leafFallback\",\n    value: function leafFallback(dom, marks) {\n      if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"), marks);\n    }\n  }, {\n    key: \"ignoreFallback\",\n    value: function ignoreFallback(dom, marks) {\n      if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text(\"-\"), marks, true);\n    }\n  }, {\n    key: \"readStyles\",\n    value: function readStyles(dom, marks) {\n      var _this4 = this;\n      var styles = dom.style;\n      if (styles && styles.length) for (var i = 0; i < this.parser.matchedStyles.length; i++) {\n        var name = this.parser.matchedStyles[i],\n          value = styles.getPropertyValue(name);\n        if (value) {\n          var _loop4 = function _loop4(_after) {\n              var rule = _this4.parser.matchStyle(name, value, _this4, _after);\n              if (!rule) {\n                after = _after;\n                return 0;\n              }\n              if (rule.ignore) return {\n                v: null\n              };\n              if (rule.clearMark) marks = marks.filter(function (m) {\n                return !rule.clearMark(m);\n              });else marks = marks.concat(_this4.parser.schema.marks[rule.mark].create(rule.attrs));\n              if (rule.consuming === false) _after = rule;else {\n                after = _after;\n                return 0;\n              }\n              after = _after;\n            },\n            _ret;\n          for (var after = undefined;;) {\n            _ret = _loop4(after);\n            if (_ret === 0) break;\n            if (_ret) return _ret.v;\n          }\n        }\n      }\n      return marks;\n    }\n  }, {\n    key: \"addElementByRule\",\n    value: function addElementByRule(dom, rule, marks, continueAfter) {\n      var _this5 = this;\n      var sync, nodeType;\n      if (rule.node) {\n        nodeType = this.parser.schema.nodes[rule.node];\n        if (!nodeType.isLeaf) {\n          var inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);\n          if (inner) {\n            sync = true;\n            marks = inner;\n          }\n        } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == \"BR\")) {\n          this.leafFallback(dom, marks);\n        }\n      } else {\n        var markType = this.parser.schema.marks[rule.mark];\n        marks = marks.concat(markType.create(rule.attrs));\n      }\n      var startIn = this.top;\n      if (nodeType && nodeType.isLeaf) {\n        this.findInside(dom);\n      } else if (continueAfter) {\n        this.addElement(dom, marks, continueAfter);\n      } else if (rule.getContent) {\n        this.findInside(dom);\n        rule.getContent(dom, this.parser.schema).forEach(function (node) {\n          return _this5.insertNode(node, marks, false);\n        });\n      } else {\n        var contentDOM = dom;\n        if (typeof rule.contentElement == \"string\") contentDOM = dom.querySelector(rule.contentElement);else if (typeof rule.contentElement == \"function\") contentDOM = rule.contentElement(dom);else if (rule.contentElement) contentDOM = rule.contentElement;\n        this.findAround(dom, contentDOM, true);\n        this.addAll(contentDOM, marks);\n        this.findAround(dom, contentDOM, false);\n      }\n      if (sync && this.sync(startIn)) this.open--;\n    }\n  }, {\n    key: \"addAll\",\n    value: function addAll(parent, marks, startIndex, endIndex) {\n      var index = startIndex || 0;\n      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n        this.findAtPoint(parent, index);\n        this.addDOM(dom, marks);\n      }\n      this.findAtPoint(parent, index);\n    }\n  }, {\n    key: \"findPlace\",\n    value: function findPlace(node, marks, cautious) {\n      var route, sync;\n      for (var depth = this.open, penalty = 0; depth >= 0; depth--) {\n        var cx = this.nodes[depth];\n        var _found2 = cx.findWrapping(node);\n        if (_found2 && (!route || route.length > _found2.length + penalty)) {\n          route = _found2;\n          sync = cx;\n          if (!_found2.length) break;\n        }\n        if (cx.solid) {\n          if (cautious) break;\n          penalty += 2;\n        }\n      }\n      if (!route) return null;\n      this.sync(sync);\n      for (var i = 0; i < route.length; i++) marks = this.enterInner(route[i], null, marks, false);\n      return marks;\n    }\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(node, marks, cautious) {\n      if (node.isInline && this.needsBlock && !this.top.type) {\n        var block = this.textblockFromContext();\n        if (block) marks = this.enterInner(block, null, marks);\n      }\n      var innerMarks = this.findPlace(node, marks, cautious);\n      if (innerMarks) {\n        this.closeExtra();\n        var top = this.top;\n        if (top.match) top.match = top.match.matchType(node.type);\n        var nodeMarks = Mark.none;\n        var _iterator = _createForOfIteratorHelper(innerMarks.concat(node.marks)),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var m = _step.value;\n            if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type)) nodeMarks = m.addToSet(nodeMarks);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        top.content.push(node.mark(nodeMarks));\n        return true;\n      }\n      return false;\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(type, attrs, marks, preserveWS) {\n      var innerMarks = this.findPlace(type.create(attrs), marks, false);\n      if (innerMarks) innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);\n      return innerMarks;\n    }\n  }, {\n    key: \"enterInner\",\n    value: function enterInner(type, attrs, marks) {\n      var solid = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var preserveWS = arguments.length > 4 ? arguments[4] : undefined;\n      this.closeExtra();\n      var top = this.top;\n      top.match = top.match && top.match.matchType(type);\n      var options = wsOptionsFor(type, preserveWS, top.options);\n      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;\n      var applyMarks = Mark.none;\n      marks = marks.filter(function (m) {\n        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {\n          applyMarks = m.addToSet(applyMarks);\n          return false;\n        }\n        return true;\n      });\n      this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));\n      this.open++;\n      return marks;\n    }\n  }, {\n    key: \"closeExtra\",\n    value: function closeExtra() {\n      var openEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var i = this.nodes.length - 1;\n      if (i > this.open) {\n        for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n        this.nodes.length = this.open + 1;\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.open = 0;\n      this.closeExtra(this.isOpen);\n      return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));\n    }\n  }, {\n    key: \"sync\",\n    value: function sync(to) {\n      for (var i = this.open; i >= 0; i--) {\n        if (this.nodes[i] == to) {\n          this.open = i;\n          return true;\n        } else if (this.localPreserveWS) {\n          this.nodes[i].options |= OPT_PRESERVE_WS;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"currentPos\",\n    get: function get() {\n      this.closeExtra();\n      var pos = 0;\n      for (var i = this.open; i >= 0; i--) {\n        var content = this.nodes[i].content;\n        for (var j = content.length - 1; j >= 0; j--) pos += content[j].nodeSize;\n        if (i) pos++;\n      }\n      return pos;\n    }\n  }, {\n    key: \"findAtPoint\",\n    value: function findAtPoint(parent, offset) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;\n      }\n    }\n  }, {\n    key: \"findInside\",\n    value: function findInside(parent) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;\n      }\n    }\n  }, {\n    key: \"findAround\",\n    value: function findAround(parent, content, before) {\n      if (parent != content && this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n          var pos = content.compareDocumentPosition(this.find[i].node);\n          if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;\n        }\n      }\n    }\n  }, {\n    key: \"findInText\",\n    value: function findInText(textNode) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n      }\n    }\n  }, {\n    key: \"matchesContext\",\n    value: function matchesContext(context) {\n      var _this6 = this;\n      if (context.indexOf(\"|\") > -1) return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n      var parts = context.split(\"/\");\n      var option = this.options.context;\n      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n      var match = function match(i, depth) {\n        for (; i >= 0; i--) {\n          var part = parts[i];\n          if (part == \"\") {\n            if (i == parts.length - 1 || i == 0) continue;\n            for (; depth >= minDepth; depth--) if (match(i - 1, depth)) return true;\n            return false;\n          } else {\n            var next = depth > 0 || depth == 0 && useRoot ? _this6.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n            if (!next || next.name != part && !next.isInGroup(part)) return false;\n            depth--;\n          }\n        }\n        return true;\n      };\n      return match(parts.length - 1, this.open);\n    }\n  }, {\n    key: \"textblockFromContext\",\n    value: function textblockFromContext() {\n      var $context = this.options.context;\n      if ($context) for (var d = $context.depth; d >= 0; d--) {\n        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n        if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;\n      }\n      for (var name in this.parser.schema.nodes) {\n        var type = this.parser.schema.nodes[name];\n        if (type.isTextblock && type.defaultAttrs) return type;\n      }\n    }\n  }]);\n  return ParseContext;\n}();\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\nfunction copy(obj) {\n  var copy = {};\n  for (var prop in obj) copy[prop] = obj[prop];\n  return copy;\n}\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n  var _loop5 = function _loop5() {\n      var parent = nodes[name];\n      if (!parent.allowsMarkType(markType)) return 0;\n      var seen = [],\n        scan = function scan(match) {\n          seen.push(match);\n          for (var i = 0; i < match.edgeCount; i++) {\n            var _match$edge = match.edge(i),\n              type = _match$edge.type,\n              next = _match$edge.next;\n            if (type == nodeType) return true;\n            if (seen.indexOf(next) < 0 && scan(next)) return true;\n          }\n        };\n      if (scan(parent.contentMatch)) return {\n        v: true\n      };\n    },\n    _ret2;\n  for (var name in nodes) {\n    _ret2 = _loop5();\n    if (_ret2 === 0) continue;\n    if (_ret2) return _ret2.v;\n  }\n}\nvar DOMSerializer = function () {\n  function DOMSerializer(nodes, marks) {\n    _classCallCheck(this, DOMSerializer);\n    this.nodes = nodes;\n    this.marks = marks;\n  }\n  _createClass(DOMSerializer, [{\n    key: \"serializeFragment\",\n    value: function serializeFragment(fragment) {\n      var _this7 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var target = arguments.length > 2 ? arguments[2] : undefined;\n      if (!target) target = doc(options).createDocumentFragment();\n      var top = target,\n        active = [];\n      fragment.forEach(function (node) {\n        if (active.length || node.marks.length) {\n          var keep = 0,\n            rendered = 0;\n          while (keep < active.length && rendered < node.marks.length) {\n            var next = node.marks[rendered];\n            if (!_this7.marks[next.type.name]) {\n              rendered++;\n              continue;\n            }\n            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;\n            keep++;\n            rendered++;\n          }\n          while (keep < active.length) top = active.pop()[1];\n          while (rendered < node.marks.length) {\n            var add = node.marks[rendered++];\n            var markDOM = _this7.serializeMark(add, node.isInline, options);\n            if (markDOM) {\n              active.push([add, top]);\n              top.appendChild(markDOM.dom);\n              top = markDOM.contentDOM || markDOM.dom;\n            }\n          }\n        }\n        top.appendChild(_this7.serializeNodeInner(node, options));\n      });\n      return target;\n    }\n  }, {\n    key: \"serializeNodeInner\",\n    value: function serializeNodeInner(node, options) {\n      var _renderSpec2 = _renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs),\n        dom = _renderSpec2.dom,\n        contentDOM = _renderSpec2.contentDOM;\n      if (contentDOM) {\n        if (node.isLeaf) throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n        this.serializeFragment(node.content, options, contentDOM);\n      }\n      return dom;\n    }\n  }, {\n    key: \"serializeNode\",\n    value: function serializeNode(node) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var dom = this.serializeNodeInner(node, options);\n      for (var i = node.marks.length - 1; i >= 0; i--) {\n        var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n        if (wrap) {\n          (wrap.contentDOM || wrap.dom).appendChild(dom);\n          dom = wrap.dom;\n        }\n      }\n      return dom;\n    }\n  }, {\n    key: \"serializeMark\",\n    value: function serializeMark(mark, inline) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var toDOM = this.marks[mark.type.name];\n      return toDOM && _renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);\n    }\n  }], [{\n    key: \"renderSpec\",\n    value: function renderSpec(doc, structure) {\n      var xmlNS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var blockArraysIn = arguments.length > 3 ? arguments[3] : undefined;\n      return _renderSpec(doc, structure, xmlNS, blockArraysIn);\n    }\n  }, {\n    key: \"fromSchema\",\n    value: function fromSchema(schema) {\n      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n  }, {\n    key: \"nodesFromSchema\",\n    value: function nodesFromSchema(schema) {\n      var result = gatherToDOM(schema.nodes);\n      if (!result.text) result.text = function (node) {\n        return node.text;\n      };\n      return result;\n    }\n  }, {\n    key: \"marksFromSchema\",\n    value: function marksFromSchema(schema) {\n      return gatherToDOM(schema.marks);\n    }\n  }]);\n  return DOMSerializer;\n}();\nfunction gatherToDOM(obj) {\n  var result = {};\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) result[name] = toDOM;\n  }\n  return result;\n}\nfunction doc(options) {\n  return options.document || window.document;\n}\nvar suspiciousAttributeCache = new WeakMap();\nfunction suspiciousAttributes(attrs) {\n  var value = suspiciousAttributeCache.get(attrs);\n  if (value === undefined) suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));\n  return value;\n}\nfunction suspiciousAttributesInner(attrs) {\n  var result = null;\n  function scan(value) {\n    if (value && _typeof(value) == \"object\") {\n      if (Array.isArray(value)) {\n        if (typeof value[0] == \"string\") {\n          if (!result) result = [];\n          result.push(value);\n        } else {\n          for (var i = 0; i < value.length; i++) scan(value[i]);\n        }\n      } else {\n        for (var prop in value) scan(value[prop]);\n      }\n    }\n  }\n  scan(attrs);\n  return result;\n}\nfunction _renderSpec(doc, structure, xmlNS, blockArraysIn) {\n  if (typeof structure == \"string\") return {\n    dom: doc.createTextNode(structure)\n  };\n  if (structure.nodeType != null) return {\n    dom: structure\n  };\n  if (structure.dom && structure.dom.nodeType != null) return structure;\n  var tagName = structure[0],\n    suspicious;\n  if (typeof tagName != \"string\") throw new RangeError(\"Invalid array passed to renderSpec\");\n  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1) throw new RangeError(\"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.\");\n  var space = tagName.indexOf(\" \");\n  if (space > 0) {\n    xmlNS = tagName.slice(0, space);\n    tagName = tagName.slice(space + 1);\n  }\n  var contentDOM;\n  var dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n  var attrs = structure[1],\n    start = 1;\n  if (attrs && _typeof(attrs) == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n    start = 2;\n    for (var name in attrs) if (attrs[name] != null) {\n      var _space = name.indexOf(\" \");\n      if (_space > 0) dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);else if (name == \"style\" && dom.style) dom.style.cssText = attrs[name];else dom.setAttribute(name, attrs[name]);\n    }\n  }\n  for (var i = start; i < structure.length; i++) {\n    var child = structure[i];\n    if (child === 0) {\n      if (i < structure.length - 1 || i > start) throw new RangeError(\"Content hole must be the only child of its parent node\");\n      return {\n        dom: dom,\n        contentDOM: dom\n      };\n    } else {\n      var _renderSpec3 = _renderSpec(doc, child, xmlNS, blockArraysIn),\n        inner = _renderSpec3.dom,\n        innerContent = _renderSpec3.contentDOM;\n      dom.appendChild(inner);\n      if (innerContent) {\n        if (contentDOM) throw new RangeError(\"Multiple content holes\");\n        contentDOM = innerContent;\n      }\n    }\n  }\n  return {\n    dom: dom,\n    contentDOM: contentDOM\n  };\n}\nexports.ContentMatch = ContentMatch;\nexports.DOMParser = DOMParser;\nexports.DOMSerializer = DOMSerializer;\nexports.Fragment = Fragment;\nexports.Mark = Mark;\nexports.MarkType = MarkType;\nexports.Node = Node;\nexports.NodeRange = NodeRange;\nexports.NodeType = NodeType;\nexports.ReplaceError = ReplaceError;\nexports.ResolvedPos = ResolvedPos;\nexports.Schema = Schema;\nexports.Slice = Slice;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLW1vZGVsQDEuMjUuMy9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5janMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIseURBQXlELGlGQUFpRixXQUFXLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUywrQkFBK0Isc0JBQXNCLFdBQVcsWUFBWSxnS0FBZ0ssa0RBQWtELFNBQVMsa0JBQWtCLGtCQUFrQixvQkFBb0Isc0JBQXNCLDhCQUE4QixjQUFjLHVCQUF1QixlQUFlLFlBQVksb0JBQW9CLE1BQU0saUVBQWlFLFVBQVU7QUFDNzhCLGtEQUFrRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNEO0FBQzdTLHVDQUF1Qyx1REFBdUQsdUNBQXVDLFNBQVMsdUJBQXVCO0FBQ3JLLGtCQUFrQixxREFBcUQsNkJBQTZCLE9BQU8sbURBQW1ELDZDQUE2QyxtQkFBbUIsNERBQTRELGdCQUFnQixrRUFBa0Usd0JBQXdCO0FBQ3BZLDRDQUE0QyxrRUFBa0Usa0NBQWtDLDhCQUE4QjtBQUM5SywyQ0FBMkMsK0RBQStELDZFQUE2RSx5RUFBeUUsZUFBZSx1REFBdUQsR0FBRywrQ0FBK0MsaUJBQWlCLEdBQUc7QUFDNVksaUNBQWlDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQsMkRBQTJELE9BQU8seUNBQXlDO0FBQ3BYLGtEQUFrRCwwRUFBMEUsZUFBZSw0QkFBNEIsbUZBQW1GO0FBQzFQLHdDQUF3Qyx1QkFBdUIseUZBQXlGO0FBQ3hKLG1DQUFtQyxnRUFBZ0Usc0RBQXNELCtEQUErRCxtQ0FBbUMsNkVBQTZFLHFDQUFxQyxpREFBaUQsOEJBQThCLHFCQUFxQiwwRUFBMEUscURBQXFELGVBQWUseUVBQXlFLEdBQUcsMkNBQTJDO0FBQ3R0QiwyQ0FBMkMsbUNBQW1DLHlDQUF5QyxPQUFPLHdE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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2REFBNkQ7QUFDckcsd0NBQXdDLGdFQUFnRTtBQUN4RztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpSUFBaUk7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsUUFBUTtBQUN0RztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZEQUE2RCxzQkFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0RBQStELHdCQUF3QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SkFBdUosNkZBQTZGO0FBQ3BQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FB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QUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLHVFQUF1RTtBQUM1SztBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsaUJBQWlCO0FBQ2pCLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLGNBQWM7QUFDZCxhQUFhIiwic291cmNlcyI6WyIvVXNlcnMvRWJvb3RoL2FnZW50X2NfZnJhbWV3b3JrL3NyYy9yZWFsdGltZV9jbGllbnQvbm9kZV9tb2R1bGVzLy5wbnBtL3Byb3NlbWlycm9yLW1vZGVsQDEuMjUuMy9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5janMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9nZXQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpOyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDsgX3dyYXBOYXRpdmVTdXBlciA9IGZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHsgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzczsgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBpZiAodHlwZW9mIF9jYWNoZSAhPT0gXCJ1bmRlZmluZWRcIikgeyBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTsgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7IH0gZnVuY3Rpb24gV3JhcHBlcigpIHsgcmV0dXJuIF9jb25zdHJ1Y3QoQ2xhc3MsIGFyZ3VtZW50cywgX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfSBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBXcmFwcGVyLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyByZXR1cm4gX3NldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTsgfTsgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpOyB9XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHsgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkgeyBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3QuYmluZCgpOyB9IGVsc2UgeyBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7IHZhciBhID0gW251bGxdOyBhLnB1c2guYXBwbHkoYSwgYXJncyk7IHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTsgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7IGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpOyByZXR1cm4gaW5zdGFuY2U7IH07IH0gcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5mdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikgeyB0cnkgeyByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xOyB9IGNhdGNoIChlKSB7IHJldHVybiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIjsgfSB9XG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIF90b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6IGZhbHNlIH0pOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykgeyB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7IHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0OyB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmIChwcmltICE9PSB1bmRlZmluZWQpIHsgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7IGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTsgfVxudmFyIE9yZGVyZWRNYXAgPSByZXF1aXJlKCdvcmRlcmVkbWFwJyk7XG5mdW5jdGlvbiBfZmluZERpZmZTdGFydChhLCBiLCBwb3MpIHtcbiAgZm9yICh2YXIgaSA9IDA7OyBpKyspIHtcbiAgICBpZiAoaSA9PSBhLmNoaWxkQ291bnQgfHwgaSA9PSBiLmNoaWxkQ291bnQpIHJldHVybiBhLmNoaWxkQ291bnQgPT0gYi5jaGlsZENvdW50ID8gbnVsbCA6IHBvcztcbiAgICB2YXIgY2hpbGRBID0gYS5jaGlsZChpKSxcbiAgICAgIGNoaWxkQiA9IGIuY2hpbGQoaSk7XG4gICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKSByZXR1cm4gcG9zO1xuICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgY2hpbGRBLnRleHRbal0gPT0gY2hpbGRCLnRleHRbal07IGorKykgcG9zKys7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICB2YXIgaW5uZXIgPSBfZmluZERpZmZTdGFydChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvcyArIDEpO1xuICAgICAgaWYgKGlubmVyICE9IG51bGwpIHJldHVybiBpbm5lcjtcbiAgICB9XG4gICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgfVxufVxuZnVuY3Rpb24gX2ZpbmREaWZmRW5kKGEsIGIsIHBvc0EsIHBvc0IpIHtcbiAgZm9yICh2YXIgaUEgPSBhLmNoaWxkQ291bnQsIGlCID0gYi5jaGlsZENvdW50OzspIHtcbiAgICBpZiAoaUEgPT0gMCB8fCBpQiA9PSAwKSByZXR1cm4gaUEgPT0gaUIgPyBudWxsIDoge1xuICAgICAgYTogcG9zQSxcbiAgICAgIGI6IHBvc0JcbiAgICB9O1xuICAgIHZhciBjaGlsZEEgPSBhLmNoaWxkKC0taUEpLFxuICAgICAgY2hpbGRCID0gYi5jaGlsZCgtLWlCKSxcbiAgICAgIHNpemUgPSBjaGlsZEEubm9kZVNpemU7XG4gICAgaWYgKGNoaWxkQSA9PSBjaGlsZEIpIHtcbiAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgIHBvc0IgLT0gc2l6ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpIHJldHVybiB7XG4gICAgICBhOiBwb3NBLFxuICAgICAgYjogcG9zQlxuICAgIH07XG4gICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgIHZhciBzYW1lID0gMCxcbiAgICAgICAgbWluU2l6ZSA9IE1hdGgubWluKGNoaWxkQS50ZXh0Lmxlbmd0aCwgY2hpbGRCLnRleHQubGVuZ3RoKTtcbiAgICAgIHdoaWxlIChzYW1lIDwgbWluU2l6ZSAmJiBjaGlsZEEudGV4dFtjaGlsZEEudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0gPT0gY2hpbGRCLnRleHRbY2hpbGRCLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdKSB7XG4gICAgICAgIHNhbWUrKztcbiAgICAgICAgcG9zQS0tO1xuICAgICAgICBwb3NCLS07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhOiBwb3NBLFxuICAgICAgICBiOiBwb3NCXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICB2YXIgaW5uZXIgPSBfZmluZERpZmZFbmQoY2hpbGRBLmNvbnRlbnQsIGNoaWxkQi5jb250ZW50LCBwb3NBIC0gMSwgcG9zQiAtIDEpO1xuICAgICAgaWYgKGlubmVyKSByZXR1cm4gaW5uZXI7XG4gICAgfVxuICAgIHBvc0EgLT0gc2l6ZTtcbiAgICBwb3NCIC09IHNpemU7XG4gIH1cbn1cbnZhciBGcmFnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRnJhZ21lbnQoY29udGVudCwgc2l6ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcmFnbWVudCk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLnNpemUgPSBzaXplIHx8IDA7XG4gICAgaWYgKHNpemUgPT0gbnVsbCkgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB0aGlzLnNpemUgKz0gY29udGVudFtpXS5ub2RlU2l6ZTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRnJhZ21lbnQsIFt7XG4gICAga2V5OiBcIm5vZGVzQmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYpIHtcbiAgICAgIHZhciBub2RlU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgcGFyZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sXG4gICAgICAgICAgZW5kID0gcG9zICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGlmIChlbmQgPiBmcm9tICYmIGYoY2hpbGQsIG5vZGVTdGFydCArIHBvcywgcGFyZW50IHx8IG51bGwsIGkpICE9PSBmYWxzZSAmJiBjaGlsZC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgIGNoaWxkLm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBmcm9tIC0gc3RhcnQpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gc3RhcnQpLCBmLCBub2RlU3RhcnQgKyBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXNjZW5kYW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNjZW5kYW50cyhmKSB7XG4gICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLnNpemUsIGYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0QmV0d2VlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICB2YXIgdGV4dCA9IFwiXCIsXG4gICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmdW5jdGlvbiAobm9kZSwgcG9zKSB7XG4gICAgICAgIHZhciBub2RlVGV4dCA9IG5vZGUuaXNUZXh0ID8gbm9kZS50ZXh0LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKSA6ICFub2RlLmlzTGVhZiA/IFwiXCIgOiBsZWFmVGV4dCA/IHR5cGVvZiBsZWFmVGV4dCA9PT0gXCJmdW5jdGlvblwiID8gbGVhZlRleHQobm9kZSkgOiBsZWFmVGV4dCA6IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0ID8gbm9kZS50eXBlLnNwZWMubGVhZlRleHQobm9kZSkgOiBcIlwiO1xuICAgICAgICBpZiAobm9kZS5pc0Jsb2NrICYmIChub2RlLmlzTGVhZiAmJiBub2RlVGV4dCB8fCBub2RlLmlzVGV4dGJsb2NrKSAmJiBibG9ja1NlcGFyYXRvcikge1xuICAgICAgICAgIGlmIChmaXJzdCkgZmlyc3QgPSBmYWxzZTtlbHNlIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCArPSBub2RlVGV4dDtcbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBlbmQob3RoZXIpIHtcbiAgICAgIGlmICghb3RoZXIuc2l6ZSkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoIXRoaXMuc2l6ZSkgcmV0dXJuIG90aGVyO1xuICAgICAgdmFyIGxhc3QgPSB0aGlzLmxhc3RDaGlsZCxcbiAgICAgICAgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLFxuICAgICAgICBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCksXG4gICAgICAgIGkgPSAwO1xuICAgICAgaWYgKGxhc3QuaXNUZXh0ICYmIGxhc3Quc2FtZU1hcmt1cChmaXJzdCkpIHtcbiAgICAgICAgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID0gbGFzdC53aXRoVGV4dChsYXN0LnRleHQgKyBmaXJzdC50ZXh0KTtcbiAgICAgICAgaSA9IDE7XG4gICAgICB9XG4gICAgICBmb3IgKDsgaSA8IG90aGVyLmNvbnRlbnQubGVuZ3RoOyBpKyspIGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTtcbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCwgdGhpcy5zaXplICsgb3RoZXIuc2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXQoZnJvbSkge1xuICAgICAgdmFyIHRvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNpemU7XG4gICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuc2l6ZSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIHNpemUgPSAwO1xuICAgICAgaWYgKHRvID4gZnJvbSkgZm9yICh2YXIgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jb250ZW50W2ldLFxuICAgICAgICAgIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgICAgIGlmIChwb3MgPCBmcm9tIHx8IGVuZCA+IHRvKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7ZWxzZSBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zIC0gMSksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBwb3MgLSAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBzaXplICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQocmVzdWx0LCBzaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3V0QnlJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXRCeUluZGV4KGZyb20sIHRvKSB7XG4gICAgICBpZiAoZnJvbSA9PSB0bykgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcGxhY2VDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlQ2hpbGQoaW5kZXgsIG5vZGUpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgIGlmIChjdXJyZW50ID09IG5vZGUpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgIHZhciBzaXplID0gdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSAtIGN1cnJlbnQubm9kZVNpemU7XG4gICAgICBjb3B5W2luZGV4XSA9IG5vZGU7XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb1N0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRvU3RhcnQobm9kZSkge1xuICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZV0uY29uY2F0KHRoaXMuY29udGVudCksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRUb0VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb0VuZChub2RlKSB7XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5jb25jYXQobm9kZSksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggIT0gb3RoZXIuY29udGVudC5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKSBpZiAoIXRoaXMuY29udGVudFtpXS5lcShvdGhlci5jb250ZW50W2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0Q2hpbGRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZENvdW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGQoaW5kZXgpIHtcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICBpZiAoIWZvdW5kKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IFwiICsgaW5kZXggKyBcIiBvdXQgb2YgcmFuZ2UgZm9yIFwiICsgdGhpcyk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heWJlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtpbmRleF0gfHwgbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGYpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgIGYoY2hpbGQsIHAsIGkpO1xuICAgICAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kRGlmZlN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmREaWZmU3RhcnQob3RoZXIpIHtcbiAgICAgIHZhciBwb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICByZXR1cm4gX2ZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmREaWZmRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmREaWZmRW5kKG90aGVyKSB7XG4gICAgICB2YXIgcG9zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNpemU7XG4gICAgICB2YXIgb3RoZXJQb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG90aGVyLnNpemU7XG4gICAgICByZXR1cm4gX2ZpbmREaWZmRW5kKHRoaXMsIG90aGVyLCBwb3MsIG90aGVyUG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJbmRleChwb3MpIHtcbiAgICAgIGlmIChwb3MgPT0gMCkgcmV0dXJuIHJldEluZGV4KDAsIHBvcyk7XG4gICAgICBpZiAocG9zID09IHRoaXMuc2l6ZSkgcmV0dXJuIHJldEluZGV4KHRoaXMuY29udGVudC5sZW5ndGgsIHBvcyk7XG4gICAgICBpZiAocG9zID4gdGhpcy5zaXplIHx8IHBvcyA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUG9zaXRpb24gXCIuY29uY2F0KHBvcywgXCIgb3V0c2lkZSBvZiBmcmFnbWVudCAoXCIpLmNvbmNhdCh0aGlzLCBcIilcIikpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGN1clBvcyA9IDA7OyBpKyspIHtcbiAgICAgICAgdmFyIGN1ciA9IHRoaXMuY2hpbGQoaSksXG4gICAgICAgICAgZW5kID0gY3VyUG9zICsgY3VyLm5vZGVTaXplO1xuICAgICAgICBpZiAoZW5kID49IHBvcykge1xuICAgICAgICAgIGlmIChlbmQgPT0gcG9zKSByZXR1cm4gcmV0SW5kZXgoaSArIDEsIGVuZCk7XG4gICAgICAgICAgcmV0dXJuIHJldEluZGV4KGksIGN1clBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiBcIjxcIiArIHRoaXMudG9TdHJpbmdJbm5lcigpICsgXCI+XCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nSW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmdJbm5lcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuam9pbihcIiwgXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnQubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuLnRvSlNPTigpO1xuICAgICAgfSkgOiBudWxsO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwgdmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRnJhZ21lbnQuZnJvbUpTT05cIik7XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQXJyYXkoYXJyYXkpIHtcbiAgICAgIGlmICghYXJyYXkubGVuZ3RoKSByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICB2YXIgam9pbmVkLFxuICAgICAgICBzaXplID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgc2l6ZSArPSBub2RlLm5vZGVTaXplO1xuICAgICAgICBpZiAoaSAmJiBub2RlLmlzVGV4dCAmJiBhcnJheVtpIC0gMV0uc2FtZU1hcmt1cChub2RlKSkge1xuICAgICAgICAgIGlmICgham9pbmVkKSBqb2luZWQgPSBhcnJheS5zbGljZSgwLCBpKTtcbiAgICAgICAgICBqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdID0gbm9kZS53aXRoVGV4dChqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdLnRleHQgKyBub2RlLnRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGpvaW5lZCkge1xuICAgICAgICAgIGpvaW5lZC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGpvaW5lZCB8fCBhcnJheSwgc2l6ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbShub2Rlcykge1xuICAgICAgaWYgKCFub2RlcykgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRnJhZ21lbnQpIHJldHVybiBub2RlcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgIGlmIChub2Rlcy5hdHRycykgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbiBub3QgY29udmVydCBcIiArIG5vZGVzICsgXCIgdG8gYSBGcmFnbWVudFwiICsgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRnJhZ21lbnQ7XG59KCk7XG5GcmFnbWVudC5lbXB0eSA9IG5ldyBGcmFnbWVudChbXSwgMCk7XG52YXIgZm91bmQgPSB7XG4gIGluZGV4OiAwLFxuICBvZmZzZXQ6IDBcbn07XG5mdW5jdGlvbiByZXRJbmRleChpbmRleCwgb2Zmc2V0KSB7XG4gIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gIGZvdW5kLm9mZnNldCA9IG9mZnNldDtcbiAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gIGlmICghKGEgJiYgX3R5cGVvZihhKSA9PSBcIm9iamVjdFwiKSB8fCAhKGIgJiYgX3R5cGVvZihiKSA9PSBcIm9iamVjdFwiKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xuICBpZiAoQXJyYXkuaXNBcnJheShiKSAhPSBhcnJheSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYXJyYXkpIHtcbiAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIGlmICghY29tcGFyZURlZXAoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBwIGluIGEpIGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yICh2YXIgX3AgaW4gYikgaWYgKCEoX3AgaW4gYSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBNYXJrID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXJrKHR5cGUsIGF0dHJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmspO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhNYXJrLCBbe1xuICAgIGtleTogXCJhZGRUb1NldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb1NldChzZXQpIHtcbiAgICAgIHZhciBjb3B5LFxuICAgICAgICBwbGFjZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHNldFtpXTtcbiAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKSByZXR1cm4gc2V0O1xuICAgICAgICBpZiAodGhpcy50eXBlLmV4Y2x1ZGVzKG90aGVyLnR5cGUpKSB7XG4gICAgICAgICAgaWYgKCFjb3B5KSBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICB9IGVsc2UgaWYgKG90aGVyLnR5cGUuZXhjbHVkZXModGhpcy50eXBlKSkge1xuICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFwbGFjZWQgJiYgb3RoZXIudHlwZS5yYW5rID4gdGhpcy50eXBlLnJhbmspIHtcbiAgICAgICAgICAgIGlmICghY29weSkgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5KSBjb3B5LnB1c2gob3RoZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNvcHkpIGNvcHkgPSBzZXQuc2xpY2UoKTtcbiAgICAgIGlmICghcGxhY2VkKSBjb3B5LnB1c2godGhpcyk7XG4gICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRnJvbVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIGlmICh0aGlzLmVxKHNldFtpXSkpIHJldHVybiBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJblNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0luU2V0KHNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIGlmICh0aGlzLmVxKHNldFtpXSkpIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHwgdGhpcy50eXBlID09IG90aGVyLnR5cGUgJiYgY29tcGFyZURlZXAodGhpcy5hdHRycywgb3RoZXIuYXR0cnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLm5hbWVcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKCFqc29uKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICB2YXIgdHlwZSA9IHNjaGVtYS5tYXJrc1tqc29uLnR5cGVdO1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlIGlzIG5vIG1hcmsgdHlwZSBcIi5jb25jYXQoanNvbi50eXBlLCBcIiBpbiB0aGlzIHNjaGVtYVwiKSk7XG4gICAgICB2YXIgbWFyayA9IHR5cGUuY3JlYXRlKGpzb24uYXR0cnMpO1xuICAgICAgdHlwZS5jaGVja0F0dHJzKG1hcmsuYXR0cnMpO1xuICAgICAgcmV0dXJuIG1hcms7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhbWVTZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FtZVNldChhLCBiKSB7XG4gICAgICBpZiAoYSA9PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSBpZiAoIWFbaV0uZXEoYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRGcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZyb20obWFya3MpIHtcbiAgICAgIGlmICghbWFya3MgfHwgQXJyYXkuaXNBcnJheShtYXJrcykgJiYgbWFya3MubGVuZ3RoID09IDApIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICBpZiAobWFya3MgaW5zdGFuY2VvZiBNYXJrKSByZXR1cm4gW21hcmtzXTtcbiAgICAgIHZhciBjb3B5ID0gbWFya3Muc2xpY2UoKTtcbiAgICAgIGNvcHkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS50eXBlLnJhbmsgLSBiLnR5cGUucmFuaztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNYXJrO1xufSgpO1xuTWFyay5ub25lID0gW107XG52YXIgUmVwbGFjZUVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoUmVwbGFjZUVycm9yLCBfRXJyb3IpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFJlcGxhY2VFcnJvcik7XG4gIGZ1bmN0aW9uIFJlcGxhY2VFcnJvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVwbGFjZUVycm9yKTtcbiAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSZXBsYWNlRXJyb3IpO1xufShfd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG52YXIgU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbGljZSk7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLm9wZW5TdGFydCA9IG9wZW5TdGFydDtcbiAgICB0aGlzLm9wZW5FbmQgPSBvcGVuRW5kO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhTbGljZSwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zaXplIC0gdGhpcy5vcGVuU3RhcnQgLSB0aGlzLm9wZW5FbmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEF0KHBvcywgZnJhZ21lbnQpIHtcbiAgICAgIHZhciBjb250ZW50ID0gaW5zZXJ0SW50byh0aGlzLmNvbnRlbnQsIHBvcyArIHRoaXMub3BlblN0YXJ0LCBmcmFnbWVudCk7XG4gICAgICByZXR1cm4gY29udGVudCAmJiBuZXcgU2xpY2UoY29udGVudCwgdGhpcy5vcGVuU3RhcnQsIHRoaXMub3BlbkVuZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUJldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQmV0d2Vlbihmcm9tLCB0bykge1xuICAgICAgcmV0dXJuIG5ldyBTbGljZShyZW1vdmVSYW5nZSh0aGlzLmNvbnRlbnQsIGZyb20gKyB0aGlzLm9wZW5TdGFydCwgdG8gKyB0aGlzLm9wZW5TdGFydCksIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlcVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcShvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSAmJiB0aGlzLm9wZW5TdGFydCA9PSBvdGhlci5vcGVuU3RhcnQgJiYgdGhpcy5vcGVuRW5kID09IG90aGVyLm9wZW5FbmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudCArIFwiKFwiICsgdGhpcy5vcGVuU3RhcnQgKyBcIixcIiArIHRoaXMub3BlbkVuZCArIFwiKVwiO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuc2l6ZSkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIganNvbiA9IHtcbiAgICAgICAgY29udGVudDogdGhpcy5jb250ZW50LnRvSlNPTigpXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMub3BlblN0YXJ0ID4gMCkganNvbi5vcGVuU3RhcnQgPSB0aGlzLm9wZW5TdGFydDtcbiAgICAgIGlmICh0aGlzLm9wZW5FbmQgPiAwKSBqc29uLm9wZW5FbmQgPSB0aGlzLm9wZW5FbmQ7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgIGlmICghanNvbikgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgdmFyIG9wZW5TdGFydCA9IGpzb24ub3BlblN0YXJ0IHx8IDAsXG4gICAgICAgIG9wZW5FbmQgPSBqc29uLm9wZW5FbmQgfHwgMDtcbiAgICAgIGlmICh0eXBlb2Ygb3BlblN0YXJ0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wZW5FbmQgIT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTbGljZS5mcm9tSlNPTlwiKTtcbiAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhPcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heE9wZW4oZnJhZ21lbnQpIHtcbiAgICAgIHZhciBvcGVuSXNvbGF0aW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdmFyIG9wZW5TdGFydCA9IDAsXG4gICAgICAgIG9wZW5FbmQgPSAwO1xuICAgICAgZm9yICh2YXIgbiA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5maXJzdENoaWxkKSBvcGVuU3RhcnQrKztcbiAgICAgIGZvciAodmFyIF9uID0gZnJhZ21lbnQubGFzdENoaWxkOyBfbiAmJiAhX24uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFfbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgX24gPSBfbi5sYXN0Q2hpbGQpIG9wZW5FbmQrKztcbiAgICAgIHJldHVybiBuZXcgU2xpY2UoZnJhZ21lbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTbGljZTtcbn0oKTtcblNsaWNlLmVtcHR5ID0gbmV3IFNsaWNlKEZyYWdtZW50LmVtcHR5LCAwLCAwKTtcbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGNvbnRlbnQsIGZyb20sIHRvKSB7XG4gIHZhciBfY29udGVudCRmaW5kSW5kZXggPSBjb250ZW50LmZpbmRJbmRleChmcm9tKSxcbiAgICBpbmRleCA9IF9jb250ZW50JGZpbmRJbmRleC5pbmRleCxcbiAgICBvZmZzZXQgPSBfY29udGVudCRmaW5kSW5kZXgub2Zmc2V0LFxuICAgIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgdmFyIF9jb250ZW50JGZpbmRJbmRleDIgPSBjb250ZW50LmZpbmRJbmRleCh0byksXG4gICAgaW5kZXhUbyA9IF9jb250ZW50JGZpbmRJbmRleDIuaW5kZXgsXG4gICAgb2Zmc2V0VG8gPSBfY29udGVudCRmaW5kSW5kZXgyLm9mZnNldDtcbiAgaWYgKG9mZnNldCA9PSBmcm9tIHx8IGNoaWxkLmlzVGV4dCkge1xuICAgIGlmIChvZmZzZXRUbyAhPSB0byAmJiAhY29udGVudC5jaGlsZChpbmRleFRvKS5pc1RleHQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGZyb20pLmFwcGVuZChjb250ZW50LmN1dCh0bykpO1xuICB9XG4gIGlmIChpbmRleCAhPSBpbmRleFRvKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlJlbW92aW5nIG5vbi1mbGF0IHJhbmdlXCIpO1xuICByZXR1cm4gY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkocmVtb3ZlUmFuZ2UoY2hpbGQuY29udGVudCwgZnJvbSAtIG9mZnNldCAtIDEsIHRvIC0gb2Zmc2V0IC0gMSkpKTtcbn1cbmZ1bmN0aW9uIGluc2VydEludG8oY29udGVudCwgZGlzdCwgaW5zZXJ0LCBwYXJlbnQpIHtcbiAgdmFyIF9jb250ZW50JGZpbmRJbmRleDMgPSBjb250ZW50LmZpbmRJbmRleChkaXN0KSxcbiAgICBpbmRleCA9IF9jb250ZW50JGZpbmRJbmRleDMuaW5kZXgsXG4gICAgb2Zmc2V0ID0gX2NvbnRlbnQkZmluZEluZGV4My5vZmZzZXQsXG4gICAgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICBpZiAob2Zmc2V0ID09IGRpc3QgfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4LCBpbnNlcnQpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZGlzdCkuYXBwZW5kKGluc2VydCkuYXBwZW5kKGNvbnRlbnQuY3V0KGRpc3QpKTtcbiAgfVxuICB2YXIgaW5uZXIgPSBpbnNlcnRJbnRvKGNoaWxkLmNvbnRlbnQsIGRpc3QgLSBvZmZzZXQgLSAxLCBpbnNlcnQsIGNoaWxkKTtcbiAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiBfcmVwbGFjZSgkZnJvbSwgJHRvLCBzbGljZSkge1xuICBpZiAoc2xpY2Uub3BlblN0YXJ0ID4gJGZyb20uZGVwdGgpIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnNlcnRlZCBjb250ZW50IGRlZXBlciB0aGFuIGluc2VydGlvbiBwb3NpdGlvblwiKTtcbiAgaWYgKCRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0ICE9ICR0by5kZXB0aCAtIHNsaWNlLm9wZW5FbmQpIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIik7XG4gIHJldHVybiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIDApO1xufVxuZnVuY3Rpb24gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCkge1xuICB2YXIgaW5kZXggPSAkZnJvbS5pbmRleChkZXB0aCksXG4gICAgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICBpZiAoaW5kZXggPT0gJHRvLmluZGV4KGRlcHRoKSAmJiBkZXB0aCA8ICRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgdmFyIGlubmVyID0gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCBkZXB0aCArIDEpO1xuICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKTtcbiAgfSBlbHNlIGlmICghc2xpY2UuY29udGVudC5zaXplKSB7XG4gICAgcmV0dXJuIGNsb3NlKG5vZGUsIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpKTtcbiAgfSBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkge1xuICAgIHZhciBwYXJlbnQgPSAkZnJvbS5wYXJlbnQsXG4gICAgICBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgcmV0dXJuIGNsb3NlKHBhcmVudCwgY29udGVudC5jdXQoMCwgJGZyb20ucGFyZW50T2Zmc2V0KS5hcHBlbmQoc2xpY2UuY29udGVudCkuYXBwZW5kKGNvbnRlbnQuY3V0KCR0by5wYXJlbnRPZmZzZXQpKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9wcmVwYXJlU2xpY2VGb3JSZXBsYSA9IHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRmcm9tKSxcbiAgICAgIHN0YXJ0ID0gX3ByZXBhcmVTbGljZUZvclJlcGxhLnN0YXJ0LFxuICAgICAgZW5kID0gX3ByZXBhcmVTbGljZUZvclJlcGxhLmVuZDtcbiAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCBzdGFydCwgZW5kLCAkdG8sIGRlcHRoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrSm9pbihtYWluLCBzdWIpIHtcbiAgaWYgKCFzdWIudHlwZS5jb21wYXRpYmxlQ29udGVudChtYWluLnR5cGUpKSB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiQ2Fubm90IGpvaW4gXCIgKyBzdWIudHlwZS5uYW1lICsgXCIgb250byBcIiArIG1haW4udHlwZS5uYW1lKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKCRiZWZvcmUsICRhZnRlciwgZGVwdGgpIHtcbiAgdmFyIG5vZGUgPSAkYmVmb3JlLm5vZGUoZGVwdGgpO1xuICBjaGVja0pvaW4obm9kZSwgJGFmdGVyLm5vZGUoZGVwdGgpKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhZGROb2RlKGNoaWxkLCB0YXJnZXQpIHtcbiAgdmFyIGxhc3QgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgaWYgKGxhc3QgPj0gMCAmJiBjaGlsZC5pc1RleHQgJiYgY2hpbGQuc2FtZU1hcmt1cCh0YXJnZXRbbGFzdF0pKSB0YXJnZXRbbGFzdF0gPSBjaGlsZC53aXRoVGV4dCh0YXJnZXRbbGFzdF0udGV4dCArIGNoaWxkLnRleHQpO2Vsc2UgdGFyZ2V0LnB1c2goY2hpbGQpO1xufVxuZnVuY3Rpb24gYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgdGFyZ2V0KSB7XG4gIHZhciBub2RlID0gKCRlbmQgfHwgJHN0YXJ0KS5ub2RlKGRlcHRoKTtcbiAgdmFyIHN0YXJ0SW5kZXggPSAwLFxuICAgIGVuZEluZGV4ID0gJGVuZCA/ICRlbmQuaW5kZXgoZGVwdGgpIDogbm9kZS5jaGlsZENvdW50O1xuICBpZiAoJHN0YXJ0KSB7XG4gICAgc3RhcnRJbmRleCA9ICRzdGFydC5pbmRleChkZXB0aCk7XG4gICAgaWYgKCRzdGFydC5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICBzdGFydEluZGV4Kys7XG4gICAgfSBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgc3RhcnRJbmRleCsrO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIGFkZE5vZGUobm9kZS5jaGlsZChpKSwgdGFyZ2V0KTtcbiAgaWYgKCRlbmQgJiYgJGVuZC5kZXB0aCA9PSBkZXB0aCAmJiAkZW5kLnRleHRPZmZzZXQpIGFkZE5vZGUoJGVuZC5ub2RlQmVmb3JlLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gY2xvc2Uobm9kZSwgY29udGVudCkge1xuICBub2RlLnR5cGUuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICByZXR1cm4gbm9kZS5jb3B5KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGgpIHtcbiAgdmFyIG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKTtcbiAgdmFyIG9wZW5FbmQgPSAkdG8uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZW5kLCAkdG8sIGRlcHRoICsgMSk7XG4gIHZhciBjb250ZW50ID0gW107XG4gIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gIGlmIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiAkc3RhcnQuaW5kZXgoZGVwdGgpID09ICRlbmQuaW5kZXgoZGVwdGgpKSB7XG4gICAgY2hlY2tKb2luKG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3BlblN0YXJ0KSBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHN0YXJ0LCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKG9wZW5FbmQpIGFkZE5vZGUoY2xvc2Uob3BlbkVuZCwgcmVwbGFjZVR3b1dheSgkZW5kLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfVxuICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUd29XYXkoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgdmFyIGNvbnRlbnQgPSBbXTtcbiAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgaWYgKCRmcm9tLmRlcHRoID4gZGVwdGgpIHtcbiAgICB2YXIgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgYWRkTm9kZShjbG9zZSh0eXBlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgfVxuICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRhbG9uZykge1xuICB2YXIgZXh0cmEgPSAkYWxvbmcuZGVwdGggLSBzbGljZS5vcGVuU3RhcnQsXG4gICAgcGFyZW50ID0gJGFsb25nLm5vZGUoZXh0cmEpO1xuICB2YXIgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuICBmb3IgKHZhciBpID0gZXh0cmEgLSAxOyBpID49IDA7IGktLSkgbm9kZSA9ICRhbG9uZy5ub2RlKGkpLmNvcHkoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG5vZGUucmVzb2x2ZU5vQ2FjaGUoc2xpY2Uub3BlblN0YXJ0ICsgZXh0cmEpLFxuICAgIGVuZDogbm9kZS5yZXNvbHZlTm9DYWNoZShub2RlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQgLSBleHRyYSlcbiAgfTtcbn1cbnZhciBSZXNvbHZlZFBvcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzb2x2ZWRQb3MpO1xuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5wYXJlbnRPZmZzZXQgPSBwYXJlbnRPZmZzZXQ7XG4gICAgdGhpcy5kZXB0aCA9IHBhdGgubGVuZ3RoIC8gMyAtIDE7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFJlc29sdmVkUG9zLCBbe1xuICAgIGtleTogXCJyZXNvbHZlRGVwdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZURlcHRoKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSByZXR1cm4gdGhpcy5kZXB0aDtcbiAgICAgIGlmICh2YWwgPCAwKSByZXR1cm4gdGhpcy5kZXB0aCArIHZhbDtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcmVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZSh0aGlzLmRlcHRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG9jXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlKDApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGUoZGVwdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogM107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluZGV4KGRlcHRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDMgKyAxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5kZXhBZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmRleEFmdGVyKGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4KGRlcHRoKSArIChkZXB0aCA9PSB0aGlzLmRlcHRoICYmICF0aGlzLnRleHRPZmZzZXQgPyAwIDogMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIHJldHVybiBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmQoZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZGVwdGgpICsgdGhpcy5ub2RlKGRlcHRoKS5jb250ZW50LnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiZWZvcmUoZGVwdGgpIHtcbiAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgaWYgKCFkZXB0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBiZWZvcmUgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyKGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIGlmICghZGVwdGgpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYWZ0ZXIgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyB0aGlzLnBhdGhbZGVwdGggKiAzXS5ub2RlU2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dE9mZnNldFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZUFmdGVyXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICAgIGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaW5kZXgpO1xuICAgICAgcmV0dXJuIGRPZmYgPyBwYXJlbnQuY2hpbGQoaW5kZXgpLmN1dChkT2ZmKSA6IGNoaWxkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlQmVmb3JlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgdmFyIGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoZE9mZikgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkKGluZGV4KS5jdXQoMCwgZE9mZik7XG4gICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3NBdEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc0F0SW5kZXgoaW5kZXgsIGRlcHRoKSB7XG4gICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2RlcHRoICogM10sXG4gICAgICAgIHBvcyA9IGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKykgcG9zICs9IG5vZGUuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXJrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrcygpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCxcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4KCk7XG4gICAgICBpZiAocGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwKSByZXR1cm4gTWFyay5ub25lO1xuICAgICAgaWYgKHRoaXMudGV4dE9mZnNldCkgcmV0dXJuIHBhcmVudC5jaGlsZChpbmRleCkubWFya3M7XG4gICAgICB2YXIgbWFpbiA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4IC0gMSksXG4gICAgICAgIG90aGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgaWYgKCFtYWluKSB7XG4gICAgICAgIHZhciB0bXAgPSBtYWluO1xuICAgICAgICBtYWluID0gb3RoZXI7XG4gICAgICAgIG90aGVyID0gdG1wO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmtzID0gbWFpbi5tYXJrcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIGlmIChtYXJrc1tpXS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSAmJiAoIW90aGVyIHx8ICFtYXJrc1tpXS5pc0luU2V0KG90aGVyLm1hcmtzKSkpIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya3NBY3Jvc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFya3NBY3Jvc3MoJGVuZCkge1xuICAgICAgdmFyIGFmdGVyID0gdGhpcy5wYXJlbnQubWF5YmVDaGlsZCh0aGlzLmluZGV4KCkpO1xuICAgICAgaWYgKCFhZnRlciB8fCAhYWZ0ZXIuaXNJbmxpbmUpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG1hcmtzID0gYWZ0ZXIubWFya3MsXG4gICAgICAgIG5leHQgPSAkZW5kLnBhcmVudC5tYXliZUNoaWxkKCRlbmQuaW5kZXgoKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFuZXh0IHx8ICFtYXJrc1tpXS5pc0luU2V0KG5leHQubWFya3MpKSkgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGFyZWREZXB0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGFyZWREZXB0aChwb3MpIHtcbiAgICAgIGZvciAodmFyIGRlcHRoID0gdGhpcy5kZXB0aDsgZGVwdGggPiAwOyBkZXB0aC0tKSBpZiAodGhpcy5zdGFydChkZXB0aCkgPD0gcG9zICYmIHRoaXMuZW5kKGRlcHRoKSA+PSBwb3MpIHJldHVybiBkZXB0aDtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJibG9ja1JhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJsb2NrUmFuZ2UoKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXM7XG4gICAgICB2YXIgcHJlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKSByZXR1cm4gb3RoZXIuYmxvY2tSYW5nZSh0aGlzKTtcbiAgICAgIGZvciAodmFyIGQgPSB0aGlzLmRlcHRoIC0gKHRoaXMucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdGhpcy5wb3MgPT0gb3RoZXIucG9zID8gMSA6IDApOyBkID49IDA7IGQtLSkgaWYgKG90aGVyLnBvcyA8PSB0aGlzLmVuZChkKSAmJiAoIXByZWQgfHwgcHJlZCh0aGlzLm5vZGUoZCkpKSkgcmV0dXJuIG5ldyBOb2RlUmFuZ2UodGhpcywgb3RoZXIsIGQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhbWVQYXJlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2FtZVBhcmVudChvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXJlbnRPZmZzZXQgPT0gb3RoZXIucG9zIC0gb3RoZXIucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4KG90aGVyKSB7XG4gICAgICByZXR1cm4gb3RoZXIucG9zID4gdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW4ob3RoZXIpIHtcbiAgICAgIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXMuZGVwdGg7IGkrKykgc3RyICs9IChzdHIgPyBcIi9cIiA6IFwiXCIpICsgdGhpcy5ub2RlKGkpLnR5cGUubmFtZSArIFwiX1wiICsgdGhpcy5pbmRleChpIC0gMSk7XG4gICAgICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJyZXNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUoZG9jLCBwb3MpIHtcbiAgICAgIGlmICghKHBvcyA+PSAwICYmIHBvcyA8PSBkb2MuY29udGVudC5zaXplKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJQb3NpdGlvbiBcIiArIHBvcyArIFwiIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIHZhciBwYXRoID0gW107XG4gICAgICB2YXIgc3RhcnQgPSAwLFxuICAgICAgICBwYXJlbnRPZmZzZXQgPSBwb3M7XG4gICAgICBmb3IgKHZhciBub2RlID0gZG9jOzspIHtcbiAgICAgICAgdmFyIF9ub2RlJGNvbnRlbnQkZmluZEluZCA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocGFyZW50T2Zmc2V0KSxcbiAgICAgICAgICBpbmRleCA9IF9ub2RlJGNvbnRlbnQkZmluZEluZC5pbmRleCxcbiAgICAgICAgICBvZmZzZXQgPSBfbm9kZSRjb250ZW50JGZpbmRJbmQub2Zmc2V0O1xuICAgICAgICB2YXIgcmVtID0gcGFyZW50T2Zmc2V0IC0gb2Zmc2V0O1xuICAgICAgICBwYXRoLnB1c2gobm9kZSwgaW5kZXgsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCFyZW0pIGJyZWFrO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZChpbmRleCk7XG4gICAgICAgIGlmIChub2RlLmlzVGV4dCkgYnJlYWs7XG4gICAgICAgIHBhcmVudE9mZnNldCA9IHJlbSAtIDE7XG4gICAgICAgIHN0YXJ0ICs9IG9mZnNldCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZUNhY2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlQ2FjaGVkKGRvYywgcG9zKSB7XG4gICAgICB2YXIgY2FjaGUgPSByZXNvbHZlQ2FjaGUuZ2V0KGRvYyk7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZS5lbHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVsdCA9IGNhY2hlLmVsdHNbaV07XG4gICAgICAgICAgaWYgKGVsdC5wb3MgPT0gcG9zKSByZXR1cm4gZWx0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlQ2FjaGUuc2V0KGRvYywgY2FjaGUgPSBuZXcgUmVzb2x2ZUNhY2hlKCkpO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGNhY2hlLmVsdHNbY2FjaGUuaV0gPSBSZXNvbHZlZFBvcy5yZXNvbHZlKGRvYywgcG9zKTtcbiAgICAgIGNhY2hlLmkgPSAoY2FjaGUuaSArIDEpICUgcmVzb2x2ZUNhY2hlU2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBSZXNvbHZlZFBvcztcbn0oKTtcbnZhciBSZXNvbHZlQ2FjaGUgPSBfY3JlYXRlQ2xhc3MoZnVuY3Rpb24gUmVzb2x2ZUNhY2hlKCkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzb2x2ZUNhY2hlKTtcbiAgdGhpcy5lbHRzID0gW107XG4gIHRoaXMuaSA9IDA7XG59KTtcbnZhciByZXNvbHZlQ2FjaGVTaXplID0gMTIsXG4gIHJlc29sdmVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTm9kZVJhbmdlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlUmFuZ2UoJGZyb20sICR0bywgZGVwdGgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZVJhbmdlKTtcbiAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgdGhpcy4kdG8gPSAkdG87XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhOb2RlUmFuZ2UsIFt7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlbmRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLiR0by5hZnRlcih0aGlzLmRlcHRoICsgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcmVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGZyb20ubm9kZSh0aGlzLmRlcHRoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhcnRJbmRleFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuJGZyb20uaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuZEluZGV4XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kdG8uaW5kZXhBZnRlcih0aGlzLmRlcHRoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5vZGVSYW5nZTtcbn0oKTtcbnZhciBlbXB0eUF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBOb2RlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb2RlKHR5cGUsIGF0dHJzLCBjb250ZW50KSB7XG4gICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBNYXJrLm5vbmU7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGUpO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IEZyYWdtZW50LmVtcHR5O1xuICB9XG4gIF9jcmVhdGVDbGFzcyhOb2RlLCBbe1xuICAgIGtleTogXCJjaGlsZHJlblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jb250ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlU2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNMZWFmID8gMSA6IDIgKyB0aGlzLmNvbnRlbnQuc2l6ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hpbGRDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZENvdW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZChpbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heWJlQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF5YmVDaGlsZChpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGYpIHtcbiAgICAgIHRoaXMuY29udGVudC5mb3JFYWNoKGYpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2Rlc0JldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmKSB7XG4gICAgICB2YXIgc3RhcnRQb3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB0aGlzLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcywgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc2NlbmRhbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dENvbnRlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzTGVhZiAmJiB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCA/IHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KHRoaXMpIDogdGhpcy50ZXh0QmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgXCJcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRCZXR3ZWVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQudGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0Q2hpbGRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibGFzdENoaWxkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxhc3RDaGlsZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzYW1lTWFya3VwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhbWVNYXJrdXAob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc01hcmt1cChvdGhlci50eXBlLCBvdGhlci5hdHRycywgb3RoZXIubWFya3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNNYXJrdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTWFya3VwKHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PSB0eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIGF0dHJzIHx8IHR5cGUuZGVmYXVsdEF0dHJzIHx8IGVtcHR5QXR0cnMpICYmIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIGlmIChjb250ZW50ID09IHRoaXMuY29udGVudCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCBjb250ZW50LCB0aGlzLm1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWFya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrKG1hcmtzKSB7XG4gICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3V0KGZyb20pIHtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5jb250ZW50LnNpemU7XG4gICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5zaXplKSByZXR1cm4gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShmcm9tKSB7XG4gICAgICB2YXIgdG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuY29udGVudC5zaXplO1xuICAgICAgdmFyIGluY2x1ZGVQYXJlbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIGlmIChmcm9tID09IHRvKSByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICB2YXIgJGZyb20gPSB0aGlzLnJlc29sdmUoZnJvbSksXG4gICAgICAgICR0byA9IHRoaXMucmVzb2x2ZSh0byk7XG4gICAgICB2YXIgZGVwdGggPSBpbmNsdWRlUGFyZW50cyA/IDAgOiAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgICB2YXIgc3RhcnQgPSAkZnJvbS5zdGFydChkZXB0aCksXG4gICAgICAgIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgIHZhciBjb250ZW50ID0gbm9kZS5jb250ZW50LmN1dCgkZnJvbS5wb3MgLSBzdGFydCwgJHRvLnBvcyAtIHN0YXJ0KTtcbiAgICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgJGZyb20uZGVwdGggLSBkZXB0aCwgJHRvLmRlcHRoIC0gZGVwdGgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICByZXR1cm4gX3JlcGxhY2UodGhpcy5yZXNvbHZlKGZyb20pLCB0aGlzLnJlc29sdmUodG8pLCBzbGljZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5vZGVBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub2RlQXQocG9zKSB7XG4gICAgICBmb3IgKHZhciBub2RlID0gdGhpczs7KSB7XG4gICAgICAgIHZhciBfbm9kZSRjb250ZW50JGZpbmRJbmQyID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwb3MpLFxuICAgICAgICAgIGluZGV4ID0gX25vZGUkY29udGVudCRmaW5kSW5kMi5pbmRleCxcbiAgICAgICAgICBvZmZzZXQgPSBfbm9kZSRjb250ZW50JGZpbmRJbmQyLm9mZnNldDtcbiAgICAgICAgbm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChvZmZzZXQgPT0gcG9zIHx8IG5vZGUuaXNUZXh0KSByZXR1cm4gbm9kZTtcbiAgICAgICAgcG9zIC09IG9mZnNldCArIDE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoaWxkQWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hpbGRBZnRlcihwb3MpIHtcbiAgICAgIHZhciBfdGhpcyRjb250ZW50JGZpbmRJbmQgPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyksXG4gICAgICAgIGluZGV4ID0gX3RoaXMkY29udGVudCRmaW5kSW5kLmluZGV4LFxuICAgICAgICBvZmZzZXQgPSBfdGhpcyRjb250ZW50JGZpbmRJbmQub2Zmc2V0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGlsZEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGlsZEJlZm9yZShwb3MpIHtcbiAgICAgIGlmIChwb3MgPT0gMCkgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfTtcbiAgICAgIHZhciBfdGhpcyRjb250ZW50JGZpbmRJbmQyID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpLFxuICAgICAgICBpbmRleCA9IF90aGlzJGNvbnRlbnQkZmluZEluZDIuaW5kZXgsXG4gICAgICAgIG9mZnNldCA9IF90aGlzJGNvbnRlbnQkZmluZEluZDIub2Zmc2V0O1xuICAgICAgaWYgKG9mZnNldCA8IHBvcykgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgfTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBpbmRleDogaW5kZXggLSAxLFxuICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGUubm9kZVNpemVcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShwb3MpIHtcbiAgICAgIHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVOb0NhY2hlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVOb0NhY2hlKHBvcykge1xuICAgICAgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmUodGhpcywgcG9zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmFuZ2VIYXNNYXJrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJhbmdlSGFzTWFyayhmcm9tLCB0bywgdHlwZSkge1xuICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICBpZiAodG8gPiBmcm9tKSB0aGlzLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKHR5cGUuaXNJblNldChub2RlLm1hcmtzKSkgZm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQmxvY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNCbG9jaztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNUZXh0YmxvY2tcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlubGluZUNvbnRlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJbmxpbmVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGUuaXNJbmxpbmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVGV4dFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5pc1RleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzTGVhZlwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQXRvbVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudHlwZS5pc0F0b207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIG5hbWUgPSB0aGlzLnR5cGUubmFtZTtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSkgbmFtZSArPSBcIihcIiArIHRoaXMuY29udGVudC50b1N0cmluZ0lubmVyKCkgKyBcIilcIjtcbiAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRNYXRjaEF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnRlbnRNYXRjaEF0KGluZGV4KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQodGhpcy5jb250ZW50LCAwLCBpbmRleCk7XG4gICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgY29udGVudE1hdGNoQXQgb24gYSBub2RlIHdpdGggaW52YWxpZCBjb250ZW50XCIpO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5SZXBsYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlcGxhY2UoZnJvbSwgdG8pIHtcbiAgICAgIHZhciByZXBsYWNlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogRnJhZ21lbnQuZW1wdHk7XG4gICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiByZXBsYWNlbWVudC5jaGlsZENvdW50O1xuICAgICAgdmFyIG9uZSA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hGcmFnbWVudChyZXBsYWNlbWVudCwgc3RhcnQsIGVuZCk7XG4gICAgICB2YXIgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgaWYgKCF0d28gfHwgIXR3by52YWxpZEVuZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIGlmICghdGhpcy50eXBlLmFsbG93c01hcmtzKHJlcGxhY2VtZW50LmNoaWxkKGkpLm1hcmtzKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhblJlcGxhY2VXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhblJlcGxhY2VXaXRoKGZyb20sIHRvLCB0eXBlLCBtYXJrcykge1xuICAgICAgaWYgKG1hcmtzICYmICF0aGlzLnR5cGUuYWxsb3dzTWFya3MobWFya3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgIHZhciBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgcmV0dXJuIGVuZCA/IGVuZC52YWxpZEVuZCA6IGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5BcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuQXBwZW5kKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIuY29udGVudC5zaXplKSByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KTtlbHNlIHJldHVybiB0aGlzLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQob3RoZXIudHlwZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgdGhpcy50eXBlLmNoZWNrQ29udGVudCh0aGlzLmNvbnRlbnQpO1xuICAgICAgdGhpcy50eXBlLmNoZWNrQXR0cnModGhpcy5hdHRycyk7XG4gICAgICB2YXIgY29weSA9IE1hcmsubm9uZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWFyayA9IHRoaXMubWFya3NbaV07XG4gICAgICAgIG1hcmsudHlwZS5jaGVja0F0dHJzKG1hcmsuYXR0cnMpO1xuICAgICAgICBjb3B5ID0gbWFyay5hZGRUb1NldChjb3B5KTtcbiAgICAgIH1cbiAgICAgIGlmICghTWFyay5zYW1lU2V0KGNvcHksIHRoaXMubWFya3MpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29sbGVjdGlvbiBvZiBtYXJrcyBmb3Igbm9kZSBcIi5jb25jYXQodGhpcy50eXBlLm5hbWUsIFwiOiBcIikuY29uY2F0KHRoaXMubWFya3MubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiBtLnR5cGUubmFtZTtcbiAgICAgIH0pKSk7XG4gICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5jaGVjaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB2YXIgb2JqID0ge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUubmFtZVxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSkgb2JqLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQudG9KU09OKCk7XG4gICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpIG9iai5tYXJrcyA9IHRoaXMubWFya3MubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHJldHVybiBuLnRvSlNPTigpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgaWYgKCFqc29uKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICB2YXIgbWFya3MgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoanNvbi5tYXJrcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtYXJrIGRhdGEgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgIG1hcmtzID0ganNvbi5tYXJrcy5tYXAoc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICB9XG4gICAgICBpZiAoanNvbi50eXBlID09IFwidGV4dFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi50ZXh0ICE9IFwic3RyaW5nXCIpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB0ZXh0IG5vZGUgaW4gSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS50ZXh0KGpzb24udGV4dCwgbWFya3MpO1xuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCk7XG4gICAgICB2YXIgbm9kZSA9IHNjaGVtYS5ub2RlVHlwZShqc29uLnR5cGUpLmNyZWF0ZShqc29uLmF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgICBub2RlLnR5cGUuY2hlY2tBdHRycyhub2RlLmF0dHJzKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZTtcbn0oKTtcbk5vZGUucHJvdG90eXBlLnRleHQgPSB1bmRlZmluZWQ7XG52YXIgVGV4dE5vZGUgPSBmdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKFRleHROb2RlLCBfTm9kZSk7XG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKFRleHROb2RlKTtcbiAgZnVuY3Rpb24gVGV4dE5vZGUodHlwZSwgYXR0cnMsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0Tm9kZSk7XG4gICAgX3RoaXMgPSBfc3VwZXIyLmNhbGwodGhpcywgdHlwZSwgYXR0cnMsIG51bGwsIG1hcmtzKTtcbiAgICBpZiAoIWNvbnRlbnQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90IGFsbG93ZWRcIik7XG4gICAgX3RoaXMudGV4dCA9IGNvbnRlbnQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhUZXh0Tm9kZSwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZykgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIEpTT04uc3RyaW5naWZ5KHRoaXMudGV4dCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0ZXh0Q29udGVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dEJldHdlZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dEJldHdlZW4oZnJvbSwgdG8pIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub2RlU2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFyayhtYXJrcykge1xuICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGhpcy50ZXh0LCBtYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpdGhUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhUZXh0KHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09IHRoaXMudGV4dCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGV4dCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXQoKSB7XG4gICAgICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcbiAgICAgIHZhciB0byA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy50ZXh0Lmxlbmd0aDtcbiAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy50ZXh0Lmxlbmd0aCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy53aXRoVGV4dCh0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgdmFyIGJhc2UgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihUZXh0Tm9kZS5wcm90b3R5cGUpLCBcInRvSlNPTlwiLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgYmFzZS50ZXh0ID0gdGhpcy50ZXh0O1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUZXh0Tm9kZTtcbn0oTm9kZSk7XG5mdW5jdGlvbiB3cmFwTWFya3MobWFya3MsIHN0cikge1xuICBmb3IgKHZhciBpID0gbWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHN0ciA9IG1hcmtzW2ldLnR5cGUubmFtZSArIFwiKFwiICsgc3RyICsgXCIpXCI7XG4gIHJldHVybiBzdHI7XG59XG52YXIgQ29udGVudE1hdGNoID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250ZW50TWF0Y2godmFsaWRFbmQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udGVudE1hdGNoKTtcbiAgICB0aGlzLnZhbGlkRW5kID0gdmFsaWRFbmQ7XG4gICAgdGhpcy5uZXh0ID0gW107XG4gICAgdGhpcy53cmFwQ2FjaGUgPSBbXTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQ29udGVudE1hdGNoLCBbe1xuICAgIGtleTogXCJtYXRjaFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gdHlwZSkgcmV0dXJuIHRoaXMubmV4dFtpXS5uZXh0O1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoRnJhZ21lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hGcmFnbWVudChmcmFnKSB7XG4gICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmcmFnLmNoaWxkQ291bnQ7XG4gICAgICB2YXIgY3VyID0gdGhpcztcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgY3VyICYmIGkgPCBlbmQ7IGkrKykgY3VyID0gY3VyLm1hdGNoVHlwZShmcmFnLmNoaWxkKGkpLnR5cGUpO1xuICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5saW5lQ29udGVudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGggIT0gMCAmJiB0aGlzLm5leHRbMF0udHlwZS5pc0lubGluZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVmYXVsdFR5cGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5uZXh0W2ldLnR5cGU7XG4gICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSkgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGF0aWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXRpYmxlKG90aGVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKykgZm9yICh2YXIgaiA9IDA7IGogPCBvdGhlci5uZXh0Lmxlbmd0aDsgaisrKSBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gb3RoZXIubmV4dFtqXS50eXBlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsbEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsQmVmb3JlKGFmdGVyKSB7XG4gICAgICB2YXIgdG9FbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICB2YXIgc2VlbiA9IFt0aGlzXTtcbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChtYXRjaCwgdHlwZXMpIHtcbiAgICAgICAgdmFyIGZpbmlzaGVkID0gbWF0Y2gubWF0Y2hGcmFnbWVudChhZnRlciwgc3RhcnRJbmRleCk7XG4gICAgICAgIGlmIChmaW5pc2hlZCAmJiAoIXRvRW5kIHx8IGZpbmlzaGVkLnZhbGlkRW5kKSkgcmV0dXJuIEZyYWdtZW50LmZyb20odHlwZXMubWFwKGZ1bmN0aW9uICh0cCkge1xuICAgICAgICAgIHJldHVybiB0cC5jcmVhdGVBbmRGaWxsKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaC5uZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9tYXRjaCRuZXh0JGkgPSBtYXRjaC5uZXh0W2ldLFxuICAgICAgICAgICAgdHlwZSA9IF9tYXRjaCRuZXh0JGkudHlwZSxcbiAgICAgICAgICAgIG5leHQgPSBfbWF0Y2gkbmV4dCRpLm5leHQ7XG4gICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpICYmIHNlZW4uaW5kZXhPZihuZXh0KSA9PSAtMSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgdmFyIF9mb3VuZCA9IHNlYXJjaChuZXh0LCB0eXBlcy5jb25jYXQodHlwZSkpO1xuICAgICAgICAgICAgaWYgKF9mb3VuZCkgcmV0dXJuIF9mb3VuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VhcmNoKHRoaXMsIFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZFdyYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53cmFwQ2FjaGUubGVuZ3RoOyBpICs9IDIpIGlmICh0aGlzLndyYXBDYWNoZVtpXSA9PSB0YXJnZXQpIHJldHVybiB0aGlzLndyYXBDYWNoZVtpICsgMV07XG4gICAgICB2YXIgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVXcmFwcGluZyh0YXJnZXQpO1xuICAgICAgdGhpcy53cmFwQ2FjaGUucHVzaCh0YXJnZXQsIGNvbXB1dGVkKTtcbiAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZVdyYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgIHZhciBzZWVuID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgYWN0aXZlID0gW3tcbiAgICAgICAgICBtYXRjaDogdGhpcyxcbiAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgIHZpYTogbnVsbFxuICAgICAgICB9XTtcbiAgICAgIHdoaWxlIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gYWN0aXZlLnNoaWZ0KCksXG4gICAgICAgICAgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoO1xuICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgZm9yICh2YXIgb2JqID0gY3VycmVudDsgb2JqLnR5cGU7IG9iaiA9IG9iai52aWEpIHJlc3VsdC5wdXNoKG9iai50eXBlKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX21hdGNoJG5leHQkaTIgPSBtYXRjaC5uZXh0W2ldLFxuICAgICAgICAgICAgdHlwZSA9IF9tYXRjaCRuZXh0JGkyLnR5cGUsXG4gICAgICAgICAgICBuZXh0ID0gX21hdGNoJG5leHQkaTIubmV4dDtcbiAgICAgICAgICBpZiAoIXR5cGUuaXNMZWFmICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSAmJiAhKHR5cGUubmFtZSBpbiBzZWVuKSAmJiAoIWN1cnJlbnQudHlwZSB8fCBuZXh0LnZhbGlkRW5kKSkge1xuICAgICAgICAgICAgYWN0aXZlLnB1c2goe1xuICAgICAgICAgICAgICBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2gsXG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIHZpYTogY3VycmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWVuW3R5cGUubmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVkZ2VDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRnZShuKSB7XG4gICAgICBpZiAobiA+PSB0aGlzLm5leHQubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZXJlJ3Mgbm8gXCIuY29uY2F0KG4sIFwidGggZWRnZSBpbiB0aGlzIGNvbnRlbnQgbWF0Y2hcIikpO1xuICAgICAgcmV0dXJuIHRoaXMubmV4dFtuXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgc2VlbiA9IFtdO1xuICAgICAgZnVuY3Rpb24gc2NhbihtKSB7XG4gICAgICAgIHNlZW4ucHVzaChtKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspIGlmIChzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpID09IC0xKSBzY2FuKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgIH1cbiAgICAgIHNjYW4odGhpcyk7XG4gICAgICByZXR1cm4gc2Vlbi5tYXAoZnVuY3Rpb24gKG0sIGkpIHtcbiAgICAgICAgdmFyIG91dCA9IGkgKyAobS52YWxpZEVuZCA/IFwiKlwiIDogXCIgXCIpICsgXCIgXCI7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBtLm5leHQubGVuZ3RoOyBfaSsrKSBvdXQgKz0gKF9pID8gXCIsIFwiIDogXCJcIikgKyBtLm5leHRbX2ldLnR5cGUubmFtZSArIFwiLT5cIiArIHNlZW4uaW5kZXhPZihtLm5leHRbX2ldLm5leHQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgdmFyIHN0cmVhbSA9IG5ldyBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcyk7XG4gICAgICBpZiAoc3RyZWFtLm5leHQgPT0gbnVsbCkgcmV0dXJuIENvbnRlbnRNYXRjaC5lbXB0eTtcbiAgICAgIHZhciBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICBpZiAoc3RyZWFtLm5leHQpIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRyYWlsaW5nIHRleHRcIik7XG4gICAgICB2YXIgbWF0Y2ggPSBkZmEobmZhKGV4cHIpKTtcbiAgICAgIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSk7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb250ZW50TWF0Y2g7XG59KCk7XG5Db250ZW50TWF0Y2guZW1wdHkgPSBuZXcgQ29udGVudE1hdGNoKHRydWUpO1xudmFyIFRva2VuU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUb2tlblN0cmVhbShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2tlblN0cmVhbSk7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5ub2RlVHlwZXMgPSBub2RlVHlwZXM7XG4gICAgdGhpcy5pbmxpbmUgPSBudWxsO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLnRva2VucyA9IHN0cmluZy5zcGxpdCgvXFxzKig/PVxcYnxcXFd8JCkvKTtcbiAgICBpZiAodGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gPT0gXCJcIikgdGhpcy50b2tlbnMucG9wKCk7XG4gICAgaWYgKHRoaXMudG9rZW5zWzBdID09IFwiXCIpIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFRva2VuU3RyZWFtLCBbe1xuICAgIGtleTogXCJuZXh0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWF0KHRvaykge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dCA9PSB0b2sgJiYgKHRoaXMucG9zKysgfHwgdHJ1ZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVyclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlcnIoc3RyKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3RyICsgXCIgKGluIGNvbnRlbnQgZXhwcmVzc2lvbiAnXCIgKyB0aGlzLnN0cmluZyArIFwiJylcIik7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUb2tlblN0cmVhbTtcbn0oKTtcbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHJlYW0pIHtcbiAgdmFyIGV4cHJzID0gW107XG4gIGRvIHtcbiAgICBleHBycy5wdXNoKHBhcnNlRXhwclNlcShzdHJlYW0pKTtcbiAgfSB3aGlsZSAoc3RyZWFtLmVhdChcInxcIikpO1xuICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHtcbiAgICB0eXBlOiBcImNob2ljZVwiLFxuICAgIGV4cHJzOiBleHByc1xuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByU2VxKHN0cmVhbSkge1xuICB2YXIgZXhwcnMgPSBbXTtcbiAgZG8ge1xuICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkpO1xuICB9IHdoaWxlIChzdHJlYW0ubmV4dCAmJiBzdHJlYW0ubmV4dCAhPSBcIilcIiAmJiBzdHJlYW0ubmV4dCAhPSBcInxcIik7XG4gIHJldHVybiBleHBycy5sZW5ndGggPT0gMSA/IGV4cHJzWzBdIDoge1xuICAgIHR5cGU6IFwic2VxXCIsXG4gICAgZXhwcnM6IGV4cHJzXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSB7XG4gIHZhciBleHByID0gcGFyc2VFeHByQXRvbShzdHJlYW0pO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIrXCIpKSBleHByID0ge1xuICAgICAgdHlwZTogXCJwbHVzXCIsXG4gICAgICBleHByOiBleHByXG4gICAgfTtlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSkgZXhwciA9IHtcbiAgICAgIHR5cGU6IFwic3RhclwiLFxuICAgICAgZXhwcjogZXhwclxuICAgIH07ZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpIGV4cHIgPSB7XG4gICAgICB0eXBlOiBcIm9wdFwiLFxuICAgICAgZXhwcjogZXhwclxuICAgIH07ZWxzZSBpZiAoc3RyZWFtLmVhdChcIntcIikpIGV4cHIgPSBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpO2Vsc2UgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59XG5mdW5jdGlvbiBwYXJzZU51bShzdHJlYW0pIHtcbiAgaWYgKC9cXEQvLnRlc3Qoc3RyZWFtLm5leHQpKSBzdHJlYW0uZXJyKFwiRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJ1wiICsgc3RyZWFtLm5leHQgKyBcIidcIik7XG4gIHZhciByZXN1bHQgPSBOdW1iZXIoc3RyZWFtLm5leHQpO1xuICBzdHJlYW0ucG9zKys7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpIHtcbiAgdmFyIG1pbiA9IHBhcnNlTnVtKHN0cmVhbSksXG4gICAgbWF4ID0gbWluO1xuICBpZiAoc3RyZWFtLmVhdChcIixcIikpIHtcbiAgICBpZiAoc3RyZWFtLm5leHQgIT0gXCJ9XCIpIG1heCA9IHBhcnNlTnVtKHN0cmVhbSk7ZWxzZSBtYXggPSAtMTtcbiAgfVxuICBpZiAoIXN0cmVhbS5lYXQoXCJ9XCIpKSBzdHJlYW0uZXJyKFwiVW5jbG9zZWQgYnJhY2VkIHJhbmdlXCIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmFuZ2VcIixcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heCxcbiAgICBleHByOiBleHByXG4gIH07XG59XG5mdW5jdGlvbiByZXNvbHZlTmFtZShzdHJlYW0sIG5hbWUpIHtcbiAgdmFyIHR5cGVzID0gc3RyZWFtLm5vZGVUeXBlcyxcbiAgICB0eXBlID0gdHlwZXNbbmFtZV07XG4gIGlmICh0eXBlKSByZXR1cm4gW3R5cGVdO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gICAgdmFyIF90eXBlID0gdHlwZXNbdHlwZU5hbWVdO1xuICAgIGlmIChfdHlwZS5pc0luR3JvdXAobmFtZSkpIHJlc3VsdC5wdXNoKF90eXBlKTtcbiAgfVxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PSAwKSBzdHJlYW0uZXJyKFwiTm8gbm9kZSB0eXBlIG9yIGdyb3VwICdcIiArIG5hbWUgKyBcIicgZm91bmRcIik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtLmVhdChcIihcIikpIHtcbiAgICB2YXIgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgIGlmICghc3RyZWFtLmVhdChcIilcIikpIHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7XG4gICAgcmV0dXJuIGV4cHI7XG4gIH0gZWxzZSBpZiAoIS9cXFcvLnRlc3Qoc3RyZWFtLm5leHQpKSB7XG4gICAgdmFyIGV4cHJzID0gcmVzb2x2ZU5hbWUoc3RyZWFtLCBzdHJlYW0ubmV4dCkubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBpZiAoc3RyZWFtLmlubGluZSA9PSBudWxsKSBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTtlbHNlIGlmIChzdHJlYW0uaW5saW5lICE9IHR5cGUuaXNJbmxpbmUpIHN0cmVhbS5lcnIoXCJNaXhpbmcgaW5saW5lIGFuZCBibG9jayBjb250ZW50XCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuYW1lXCIsXG4gICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHN0cmVhbS5wb3MrKztcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHtcbiAgICAgIHR5cGU6IFwiY2hvaWNlXCIsXG4gICAgICBleHByczogZXhwcnNcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICB9XG59XG5mdW5jdGlvbiBuZmEoZXhwcikge1xuICB2YXIgbmZhID0gW1tdXTtcbiAgY29ubmVjdChjb21waWxlKGV4cHIsIDApLCBub2RlKCkpO1xuICByZXR1cm4gbmZhO1xuICBmdW5jdGlvbiBub2RlKCkge1xuICAgIHJldHVybiBuZmEucHVzaChbXSkgLSAxO1xuICB9XG4gIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICB2YXIgZWRnZSA9IHtcbiAgICAgIHRlcm06IHRlcm0sXG4gICAgICB0bzogdG9cbiAgICB9O1xuICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgIHJldHVybiBlZGdlO1xuICB9XG4gIGZ1bmN0aW9uIGNvbm5lY3QoZWRnZXMsIHRvKSB7XG4gICAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UudG8gPSB0bztcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjb21waWxlKGV4cHIsIGZyb20pIHtcbiAgICBpZiAoZXhwci50eXBlID09IFwiY2hvaWNlXCIpIHtcbiAgICAgIHJldHVybiBleHByLmV4cHJzLnJlZHVjZShmdW5jdGlvbiAob3V0LCBleHByKSB7XG4gICAgICAgIHJldHVybiBvdXQuY29uY2F0KGNvbXBpbGUoZXhwciwgZnJvbSkpO1xuICAgICAgfSwgW10pO1xuICAgIH0gZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY29tcGlsZShleHByLmV4cHJzW2ldLCBmcm9tKTtcbiAgICAgICAgaWYgKGkgPT0gZXhwci5leHBycy5sZW5ndGggLSAxKSByZXR1cm4gbmV4dDtcbiAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInN0YXJcIikge1xuICAgICAgdmFyIGxvb3AgPSBub2RlKCk7XG4gICAgICBlZGdlKGZyb20sIGxvb3ApO1xuICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgbG9vcCksIGxvb3ApO1xuICAgICAgcmV0dXJuIFtlZGdlKGxvb3ApXTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInBsdXNcIikge1xuICAgICAgdmFyIF9sb29wID0gbm9kZSgpO1xuICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSksIF9sb29wKTtcbiAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIF9sb29wKSwgX2xvb3ApO1xuICAgICAgcmV0dXJuIFtlZGdlKF9sb29wKV07XG4gICAgfSBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJvcHRcIikge1xuICAgICAgcmV0dXJuIFtlZGdlKGZyb20pXS5jb25jYXQoY29tcGlsZShleHByLmV4cHIsIGZyb20pKTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInJhbmdlXCIpIHtcbiAgICAgIHZhciBjdXIgPSBmcm9tO1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZXhwci5taW47IF9pMisrKSB7XG4gICAgICAgIHZhciBfbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgX25leHQpO1xuICAgICAgICBjdXIgPSBfbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChleHByLm1heCA9PSAtMSkge1xuICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBjdXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gZXhwci5taW47IF9pMyA8IGV4cHIubWF4OyBfaTMrKykge1xuICAgICAgICAgIHZhciBfbmV4dDIgPSBub2RlKCk7XG4gICAgICAgICAgZWRnZShjdXIsIF9uZXh0Mik7XG4gICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgX25leHQyKTtcbiAgICAgICAgICBjdXIgPSBfbmV4dDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbZWRnZShjdXIpXTtcbiAgICB9IGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIHVuZGVmaW5lZCwgZXhwci52YWx1ZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV4cHIgdHlwZVwiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNtcChhLCBiKSB7XG4gIHJldHVybiBiIC0gYTtcbn1cbmZ1bmN0aW9uIG51bGxGcm9tKG5mYSwgbm9kZSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHNjYW4obm9kZSk7XG4gIHJldHVybiByZXN1bHQuc29ydChjbXApO1xuICBmdW5jdGlvbiBzY2FuKG5vZGUpIHtcbiAgICB2YXIgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgaWYgKGVkZ2VzLmxlbmd0aCA9PSAxICYmICFlZGdlc1swXS50ZXJtKSByZXR1cm4gc2NhbihlZGdlc1swXS50byk7XG4gICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9lZGdlcyRpID0gZWRnZXNbaV0sXG4gICAgICAgIHRlcm0gPSBfZWRnZXMkaS50ZXJtLFxuICAgICAgICB0byA9IF9lZGdlcyRpLnRvO1xuICAgICAgaWYgKCF0ZXJtICYmIHJlc3VsdC5pbmRleE9mKHRvKSA9PSAtMSkgc2Nhbih0byk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gIHZhciBsYWJlbGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIGV4cGxvcmUobnVsbEZyb20obmZhLCAwKSk7XG4gIGZ1bmN0aW9uIGV4cGxvcmUoc3RhdGVzKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBuZmFbbm9kZV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgdGVybSA9IF9yZWYudGVybSxcbiAgICAgICAgICB0byA9IF9yZWYudG87XG4gICAgICAgIGlmICghdGVybSkgcmV0dXJuO1xuICAgICAgICB2YXIgc2V0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykgaWYgKG91dFtpXVswXSA9PSB0ZXJtKSBzZXQgPSBvdXRbaV1bMV07XG4gICAgICAgIG51bGxGcm9tKG5mYSwgdG8pLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoIXNldCkgb3V0LnB1c2goW3Rlcm0sIHNldCA9IFtdXSk7XG4gICAgICAgICAgaWYgKHNldC5pbmRleE9mKG5vZGUpID09IC0xKSBzZXQucHVzaChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB2YXIgc3RhdGUgPSBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gPSBuZXcgQ29udGVudE1hdGNoKHN0YXRlcy5pbmRleE9mKG5mYS5sZW5ndGggLSAxKSA+IC0xKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIF9zdGF0ZXMgPSBvdXRbaV1bMV0uc29ydChjbXApO1xuICAgICAgc3RhdGUubmV4dC5wdXNoKHtcbiAgICAgICAgdHlwZTogb3V0W2ldWzBdLFxuICAgICAgICBuZXh0OiBsYWJlbGVkW19zdGF0ZXMuam9pbihcIixcIildIHx8IGV4cGxvcmUoX3N0YXRlcylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRm9yRGVhZEVuZHMobWF0Y2gsIHN0cmVhbSkge1xuICBmb3IgKHZhciBpID0gMCwgd29yayA9IFttYXRjaF07IGkgPCB3b3JrLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN0YXRlID0gd29ya1tpXSxcbiAgICAgIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsXG4gICAgICBub2RlcyA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIF9zdGF0ZSRuZXh0JGogPSBzdGF0ZS5uZXh0W2pdLFxuICAgICAgICB0eXBlID0gX3N0YXRlJG5leHQkai50eXBlLFxuICAgICAgICBuZXh0ID0gX3N0YXRlJG5leHQkai5uZXh0O1xuICAgICAgbm9kZXMucHVzaCh0eXBlLm5hbWUpO1xuICAgICAgaWYgKGRlYWQgJiYgISh0eXBlLmlzVGV4dCB8fCB0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkpIGRlYWQgPSBmYWxzZTtcbiAgICAgIGlmICh3b3JrLmluZGV4T2YobmV4dCkgPT0gLTEpIHdvcmsucHVzaChuZXh0KTtcbiAgICB9XG4gICAgaWYgKGRlYWQpIHN0cmVhbS5lcnIoXCJPbmx5IG5vbi1nZW5lcmF0YWJsZSBub2RlcyAoXCIgKyBub2Rlcy5qb2luKFwiLCBcIikgKyBcIikgaW4gYSByZXF1aXJlZCBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2dlbmVyYXRhYmxlKVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmYXVsdEF0dHJzKGF0dHJzKSB7XG4gIHZhciBkZWZhdWx0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAodmFyIGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgdmFyIGF0dHIgPSBhdHRyc1thdHRyTmFtZV07XG4gICAgaWYgKCFhdHRyLmhhc0RlZmF1bHQpIHJldHVybiBudWxsO1xuICAgIGRlZmF1bHRzW2F0dHJOYW1lXSA9IGF0dHJbXCJkZWZhdWx0XCJdO1xuICB9XG4gIHJldHVybiBkZWZhdWx0cztcbn1cbmZ1bmN0aW9uIF9jb21wdXRlQXR0cnMoYXR0cnMsIHZhbHVlKSB7XG4gIHZhciBidWlsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHtcbiAgICB2YXIgZ2l2ZW4gPSB2YWx1ZSAmJiB2YWx1ZVtuYW1lXTtcbiAgICBpZiAoZ2l2ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgIGlmIChhdHRyLmhhc0RlZmF1bHQpIGdpdmVuID0gYXR0cltcImRlZmF1bHRcIl07ZWxzZSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKTtcbiAgICB9XG4gICAgYnVpbHRbbmFtZV0gPSBnaXZlbjtcbiAgfVxuICByZXR1cm4gYnVpbHQ7XG59XG5mdW5jdGlvbiBfY2hlY2tBdHRycyhhdHRycywgdmFsdWVzLCB0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIF9uYW1lIGluIHZhbHVlcykgaWYgKCEoX25hbWUgaW4gYXR0cnMpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVuc3VwcG9ydGVkIGF0dHJpYnV0ZSBcIi5jb25jYXQoX25hbWUsIFwiIGZvciBcIikuY29uY2F0KHR5cGUsIFwiIG9mIHR5cGUgXCIpLmNvbmNhdChfbmFtZSkpO1xuICBmb3IgKHZhciBfbmFtZTIgaW4gYXR0cnMpIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW19uYW1lMl07XG4gICAgaWYgKGF0dHIudmFsaWRhdGUpIGF0dHIudmFsaWRhdGUodmFsdWVzW19uYW1lMl0pO1xuICB9XG59XG5mdW5jdGlvbiBpbml0QXR0cnModHlwZU5hbWUsIGF0dHJzKSB7XG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoYXR0cnMpIGZvciAodmFyIG5hbWUgaW4gYXR0cnMpIHJlc3VsdFtuYW1lXSA9IG5ldyBBdHRyaWJ1dGUodHlwZU5hbWUsIG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBOb2RlVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVUeXBlKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgdGhpcy5tYXJrU2V0ID0gbnVsbDtcbiAgICB0aGlzLmdyb3VwcyA9IHNwZWMuZ3JvdXAgPyBzcGVjLmdyb3VwLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMobmFtZSwgc3BlYy5hdHRycyk7XG4gICAgdGhpcy5kZWZhdWx0QXR0cnMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgdGhpcy5jb250ZW50TWF0Y2ggPSBudWxsO1xuICAgIHRoaXMuaW5saW5lQ29udGVudCA9IG51bGw7XG4gICAgdGhpcy5pc0Jsb2NrID0gIShzcGVjLmlubGluZSB8fCBuYW1lID09IFwidGV4dFwiKTtcbiAgICB0aGlzLmlzVGV4dCA9IG5hbWUgPT0gXCJ0ZXh0XCI7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE5vZGVUeXBlLCBbe1xuICAgIGtleTogXCJpc0lubGluZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICF0aGlzLmlzQmxvY2s7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVGV4dGJsb2NrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Jsb2NrICYmIHRoaXMuaW5saW5lQ29udGVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNMZWFmXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZW50TWF0Y2ggPT0gQ29udGVudE1hdGNoLmVtcHR5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0F0b21cIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzTGVhZiB8fCAhIXRoaXMuc3BlYy5hdG9tO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0luR3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbkdyb3VwKGdyb3VwKSB7XG4gICAgICByZXR1cm4gdGhpcy5ncm91cHMuaW5kZXhPZihncm91cCkgPiAtMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwid2hpdGVzcGFjZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BlYy53aGl0ZXNwYWNlIHx8ICh0aGlzLnNwZWMuY29kZSA/IFwicHJlXCIgOiBcIm5vcm1hbFwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzUmVxdWlyZWRBdHRyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNSZXF1aXJlZEF0dHJzKCkge1xuICAgICAgZm9yICh2YXIgbiBpbiB0aGlzLmF0dHJzKSBpZiAodGhpcy5hdHRyc1tuXS5pc1JlcXVpcmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGF0aWJsZUNvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGF0aWJsZUNvbnRlbnQob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29udGVudE1hdGNoLmNvbXBhdGlibGUob3RoZXIuY29udGVudE1hdGNoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcHV0ZUF0dHJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVBdHRycyhhdHRycykge1xuICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmRlZmF1bHRBdHRycykgcmV0dXJuIHRoaXMuZGVmYXVsdEF0dHJzO2Vsc2UgcmV0dXJuIF9jb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtYXJrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMuaXNUZXh0KSB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlVHlwZS5jcmVhdGUgY2FuJ3QgY29uc3RydWN0IHRleHQgbm9kZXNcIik7XG4gICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQ2hlY2tlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDaGVja2VkKCkge1xuICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBtYXJrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICB0aGlzLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIGNvbnRlbnQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVBbmRGaWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUFuZEZpbGwoKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBhdHRycyA9IHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKTtcbiAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShjb250ZW50KTtcbiAgICAgICAgaWYgKCFiZWZvcmUpIHJldHVybiBudWxsO1xuICAgICAgICBjb250ZW50ID0gYmVmb3JlLmFwcGVuZChjb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXRjaGVkID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgIHZhciBhZnRlciA9IG1hdGNoZWQgJiYgbWF0Y2hlZC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgIGlmICghYWZ0ZXIpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGF0dHJzLCBjb250ZW50LmFwcGVuZChhZnRlciksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZENvbnRlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgaWYgKCFyZXN1bHQgfHwgIXJlc3VsdC52YWxpZEVuZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50LmNoaWxkQ291bnQ7IGkrKykgaWYgKCF0aGlzLmFsbG93c01hcmtzKGNvbnRlbnQuY2hpbGQoaSkubWFya3MpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tDb250ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQ29udGVudChjb250ZW50KSB7XG4gICAgICBpZiAoIXRoaXMudmFsaWRDb250ZW50KGNvbnRlbnQpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgY29udGVudCBmb3Igbm9kZSBcIi5jb25jYXQodGhpcy5uYW1lLCBcIjogXCIpLmNvbmNhdChjb250ZW50LnRvU3RyaW5nKCkuc2xpY2UoMCwgNTApKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrQXR0cnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBdHRycyhhdHRycykge1xuICAgICAgX2NoZWNrQXR0cnModGhpcy5hdHRycywgYXR0cnMsIFwibm9kZVwiLCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbGxvd3NNYXJrVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkge1xuICAgICAgcmV0dXJuIHRoaXMubWFya1NldCA9PSBudWxsIHx8IHRoaXMubWFya1NldC5pbmRleE9mKG1hcmtUeXBlKSA+IC0xO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbGxvd3NNYXJrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxvd3NNYXJrcyhtYXJrcykge1xuICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFsbG93ZWRNYXJrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxvd2VkTWFya3MobWFya3MpIHtcbiAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbCkgcmV0dXJuIG1hcmtzO1xuICAgICAgdmFyIGNvcHk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkge1xuICAgICAgICAgIGlmICghY29weSkgY29weSA9IG1hcmtzLnNsaWNlKDAsIGkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvcHkpIHtcbiAgICAgICAgICBjb3B5LnB1c2gobWFya3NbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gIWNvcHkgPyBtYXJrcyA6IGNvcHkubGVuZ3RoID8gY29weSA6IE1hcmsubm9uZTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJjb21waWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUobm9kZXMsIHNjaGVtYSkge1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbbmFtZV0gPSBuZXcgTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHRvcFR5cGUgPSBzY2hlbWEuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCI7XG4gICAgICBpZiAoIXJlc3VsdFt0b3BUeXBlXSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBpdHMgdG9wIG5vZGUgdHlwZSAoJ1wiICsgdG9wVHlwZSArIFwiJylcIik7XG4gICAgICBpZiAoIXJlc3VsdC50ZXh0KSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV2ZXJ5IHNjaGVtYSBuZWVkcyBhICd0ZXh0JyB0eXBlXCIpO1xuICAgICAgZm9yICh2YXIgXyBpbiByZXN1bHQudGV4dC5hdHRycykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdGV4dCBub2RlIHR5cGUgc2hvdWxkIG5vdCBoYXZlIGF0dHJpYnV0ZXNcIik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZVR5cGU7XG59KCk7XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZU5hbWUsIGF0dHJOYW1lLCB0eXBlKSB7XG4gIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoXCJ8XCIpO1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIG5hbWUgPSB2YWx1ZSA9PT0gbnVsbCA/IFwibnVsbFwiIDogX3R5cGVvZih2YWx1ZSk7XG4gICAgaWYgKHR5cGVzLmluZGV4T2YobmFtZSkgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkV4cGVjdGVkIHZhbHVlIG9mIHR5cGUgXCIuY29uY2F0KHR5cGVzLCBcIiBmb3IgYXR0cmlidXRlIFwiKS5jb25jYXQoYXR0ck5hbWUsIFwiIG9uIHR5cGUgXCIpLmNvbmNhdCh0eXBlTmFtZSwgXCIsIGdvdCBcIikuY29uY2F0KG5hbWUpKTtcbiAgfTtcbn1cbnZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0dHJpYnV0ZSh0eXBlTmFtZSwgYXR0ck5hbWUsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXR0cmlidXRlKTtcbiAgICB0aGlzLmhhc0RlZmF1bHQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJkZWZhdWx0XCIpO1xuICAgIHRoaXNbXCJkZWZhdWx0XCJdID0gb3B0aW9uc1tcImRlZmF1bHRcIl07XG4gICAgdGhpcy52YWxpZGF0ZSA9IHR5cGVvZiBvcHRpb25zLnZhbGlkYXRlID09IFwic3RyaW5nXCIgPyB2YWxpZGF0ZVR5cGUodHlwZU5hbWUsIGF0dHJOYW1lLCBvcHRpb25zLnZhbGlkYXRlKSA6IG9wdGlvbnMudmFsaWRhdGU7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEF0dHJpYnV0ZSwgW3tcbiAgICBrZXk6IFwiaXNSZXF1aXJlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhc0RlZmF1bHQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBdHRyaWJ1dGU7XG59KCk7XG52YXIgTWFya1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hcmtUeXBlKG5hbWUsIHJhbmssIHNjaGVtYSwgc3BlYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNYXJrVHlwZSk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhuYW1lLCBzcGVjLmF0dHJzKTtcbiAgICB0aGlzLmV4Y2x1ZGVkID0gbnVsbDtcbiAgICB2YXIgZGVmYXVsdHMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgdGhpcy5pbnN0YW5jZSA9IGRlZmF1bHRzID8gbmV3IE1hcmsodGhpcywgZGVmYXVsdHMpIDogbnVsbDtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTWFya1R5cGUsIFt7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICBpZiAoIWF0dHJzICYmIHRoaXMuaW5zdGFuY2UpIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICAgICAgcmV0dXJuIG5ldyBNYXJrKHRoaXMsIF9jb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRnJvbVNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKSB7XG4gICAgICAgIHNldCA9IHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW5TZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNJblNldChzZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcykgcmV0dXJuIHNldFtpXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tBdHRyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0F0dHJzKGF0dHJzKSB7XG4gICAgICBfY2hlY2tBdHRycyh0aGlzLmF0dHJzLCBhdHRycywgXCJtYXJrXCIsIHRoaXMubmFtZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4Y2x1ZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4Y2x1ZGVzKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5leGNsdWRlZC5pbmRleE9mKG90aGVyKSA+IC0xO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNvbXBpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZShtYXJrcywgc2NoZW1hKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgcmFuayA9IDA7XG4gICAgICBtYXJrcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRbbmFtZV0gPSBuZXcgTWFya1R5cGUobmFtZSwgcmFuaysrLCBzY2hlbWEsIHNwZWMpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWFya1R5cGU7XG59KCk7XG52YXIgU2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2hlbWEoc3BlYykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY2hlbWEpO1xuICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuY2FjaGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgaW5zdGFuY2VTcGVjID0gdGhpcy5zcGVjID0ge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzcGVjKSBpbnN0YW5jZVNwZWNbcHJvcF0gPSBzcGVjW3Byb3BdO1xuICAgIGluc3RhbmNlU3BlYy5ub2RlcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm5vZGVzKSwgaW5zdGFuY2VTcGVjLm1hcmtzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubWFya3MgfHwge30pLCB0aGlzLm5vZGVzID0gTm9kZVR5cGUuY29tcGlsZSh0aGlzLnNwZWMubm9kZXMsIHRoaXMpO1xuICAgIHRoaXMubWFya3MgPSBNYXJrVHlwZS5jb21waWxlKHRoaXMuc3BlYy5tYXJrcywgdGhpcyk7XG4gICAgdmFyIGNvbnRlbnRFeHByQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAodmFyIF9wcm9wIGluIHRoaXMubm9kZXMpIHtcbiAgICAgIGlmIChfcHJvcCBpbiB0aGlzLm1hcmtzKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihfcHJvcCArIFwiIGNhbiBub3QgYmUgYm90aCBhIG5vZGUgYW5kIGEgbWFya1wiKTtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5ub2Rlc1tfcHJvcF0sXG4gICAgICAgIGNvbnRlbnRFeHByID0gdHlwZS5zcGVjLmNvbnRlbnQgfHwgXCJcIixcbiAgICAgICAgbWFya0V4cHIgPSB0eXBlLnNwZWMubWFya3M7XG4gICAgICB0eXBlLmNvbnRlbnRNYXRjaCA9IGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdIHx8IChjb250ZW50RXhwckNhY2hlW2NvbnRlbnRFeHByXSA9IENvbnRlbnRNYXRjaC5wYXJzZShjb250ZW50RXhwciwgdGhpcy5ub2RlcykpO1xuICAgICAgdHlwZS5pbmxpbmVDb250ZW50ID0gdHlwZS5jb250ZW50TWF0Y2guaW5saW5lQ29udGVudDtcbiAgICAgIGlmICh0eXBlLnNwZWMubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgbGluZWJyZWFrIG5vZGVzIGRlZmluZWRcIik7XG4gICAgICAgIGlmICghdHlwZS5pc0lubGluZSB8fCAhdHlwZS5pc0xlYWYpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZWJyZWFrIHJlcGxhY2VtZW50IG5vZGVzIG11c3QgYmUgaW5saW5lIGxlYWYgbm9kZXNcIik7XG4gICAgICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSB0eXBlO1xuICAgICAgfVxuICAgICAgdHlwZS5tYXJrU2V0ID0gbWFya0V4cHIgPT0gXCJfXCIgPyBudWxsIDogbWFya0V4cHIgPyBnYXRoZXJNYXJrcyh0aGlzLCBtYXJrRXhwci5zcGxpdChcIiBcIikpIDogbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBfcHJvcDIgaW4gdGhpcy5tYXJrcykge1xuICAgICAgdmFyIF90eXBlMiA9IHRoaXMubWFya3NbX3Byb3AyXSxcbiAgICAgICAgZXhjbCA9IF90eXBlMi5zcGVjLmV4Y2x1ZGVzO1xuICAgICAgX3R5cGUyLmV4Y2x1ZGVkID0gZXhjbCA9PSBudWxsID8gW190eXBlMl0gOiBleGNsID09IFwiXCIgPyBbXSA6IGdhdGhlck1hcmtzKHRoaXMsIGV4Y2wuc3BsaXQoXCIgXCIpKTtcbiAgICB9XG4gICAgdGhpcy5ub2RlRnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgcmV0dXJuIE5vZGUuZnJvbUpTT04oX3RoaXMyLCBqc29uKTtcbiAgICB9O1xuICAgIHRoaXMubWFya0Zyb21KU09OID0gZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgIHJldHVybiBNYXJrLmZyb21KU09OKF90aGlzMiwganNvbik7XG4gICAgfTtcbiAgICB0aGlzLnRvcE5vZGVUeXBlID0gdGhpcy5ub2Rlc1t0aGlzLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiXTtcbiAgICB0aGlzLmNhY2hlZC53cmFwcGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhTY2hlbWEsIFt7XG4gICAga2V5OiBcIm5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZSh0eXBlKSB7XG4gICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB2YXIgY29udGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIG1hcmtzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgPyBhcmd1bWVudHNbM10gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIikgdHlwZSA9IHRoaXMubm9kZVR5cGUodHlwZSk7ZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgTm9kZVR5cGUpKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIiArIHR5cGUpO2Vsc2UgaWYgKHR5cGUuc2NoZW1hICE9IHRoaXMpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgIHJldHVybiB0eXBlLmNyZWF0ZUNoZWNrZWQoYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXh0KF90ZXh0LCBtYXJrcykge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gICAgICByZXR1cm4gbmV3IFRleHROb2RlKHR5cGUsIHR5cGUuZGVmYXVsdEF0dHJzLCBfdGV4dCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFyayh0eXBlLCBhdHRycykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpIHR5cGUgPSB0aGlzLm1hcmtzW3R5cGVdO1xuICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlKGF0dHJzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9kZVR5cGUobmFtZSkge1xuICAgICAgdmFyIGZvdW5kID0gdGhpcy5ub2Rlc1tuYW1lXTtcbiAgICAgIGlmICghZm91bmQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVW5rbm93biBub2RlIHR5cGU6IFwiICsgbmFtZSk7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTY2hlbWE7XG59KCk7XG5mdW5jdGlvbiBnYXRoZXJNYXJrcyhzY2hlbWEsIG1hcmtzKSB7XG4gIHZhciBmb3VuZCA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBtYXJrc1tpXSxcbiAgICAgIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sXG4gICAgICBvayA9IG1hcms7XG4gICAgaWYgKG1hcmspIHtcbiAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgIHZhciBfbWFyayA9IHNjaGVtYS5tYXJrc1twcm9wXTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJfXCIgfHwgX21hcmsuc3BlYy5ncm91cCAmJiBfbWFyay5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpIGZvdW5kLnB1c2gob2sgPSBfbWFyayk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghb2spIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gbWFyayB0eXBlOiAnXCIgKyBtYXJrc1tpXSArIFwiJ1wiKTtcbiAgfVxuICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBpc1RhZ1J1bGUocnVsZSkge1xuICByZXR1cm4gcnVsZS50YWcgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzU3R5bGVSdWxlKHJ1bGUpIHtcbiAgcmV0dXJuIHJ1bGUuc3R5bGUgIT0gbnVsbDtcbn1cbnZhciBET01QYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERPTVBhcnNlcihzY2hlbWEsIHJ1bGVzKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTVBhcnNlcik7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgIHRoaXMudGFncyA9IFtdO1xuICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgdmFyIG1hdGNoZWRTdHlsZXMgPSB0aGlzLm1hdGNoZWRTdHlsZXMgPSBbXTtcbiAgICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBpZiAoaXNUYWdSdWxlKHJ1bGUpKSB7XG4gICAgICAgIF90aGlzMy50YWdzLnB1c2gocnVsZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzU3R5bGVSdWxlKHJ1bGUpKSB7XG4gICAgICAgIHZhciBwcm9wID0gL1tePV0qLy5leGVjKHJ1bGUuc3R5bGUpWzBdO1xuICAgICAgICBpZiAobWF0Y2hlZFN0eWxlcy5pbmRleE9mKHByb3ApIDwgMCkgbWF0Y2hlZFN0eWxlcy5wdXNoKHByb3ApO1xuICAgICAgICBfdGhpczMuc3R5bGVzLnB1c2gocnVsZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5ub3JtYWxpemVMaXN0cyA9ICF0aGlzLnRhZ3Muc29tZShmdW5jdGlvbiAocikge1xuICAgICAgaWYgKCEvXih1bHxvbClcXGIvLnRlc3Qoci50YWcpIHx8ICFyLm5vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBub2RlID0gc2NoZW1hLm5vZGVzW3Iubm9kZV07XG4gICAgICByZXR1cm4gbm9kZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKG5vZGUpO1xuICAgIH0pO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhET01QYXJzZXIsIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGRvbSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgTWFyay5ub25lLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQuZmluaXNoKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlU2xpY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VTbGljZShkb20pIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgTWFyay5ub25lLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgcmV0dXJuIFNsaWNlLm1heE9wZW4oY29udGV4dC5maW5pc2goKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoVGFnKGRvbSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgIGZvciAodmFyIGkgPSBhZnRlciA/IHRoaXMudGFncy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy50YWdzW2ldO1xuICAgICAgICBpZiAobWF0Y2hlcyhkb20sIHJ1bGUudGFnKSAmJiAocnVsZS5uYW1lc3BhY2UgPT09IHVuZGVmaW5lZCB8fCBkb20ubmFtZXNwYWNlVVJJID09IHJ1bGUubmFtZXNwYWNlKSAmJiAoIXJ1bGUuY29udGV4dCB8fCBjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkpKSB7XG4gICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBydWxlLmdldEF0dHJzKGRvbSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgY29udGludWU7XG4gICAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaFN0eWxlKHByb3AsIHZhbHVlLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgZm9yICh2YXIgaSA9IGFmdGVyID8gdGhpcy5zdHlsZXMuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMuc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBydWxlID0gdGhpcy5zdHlsZXNbaV0sXG4gICAgICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZihwcm9wKSAhPSAwIHx8IHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8IHN0eWxlLmxlbmd0aCA+IHByb3AubGVuZ3RoICYmIChzdHlsZS5jaGFyQ29kZUF0KHByb3AubGVuZ3RoKSAhPSA2MSB8fCBzdHlsZS5zbGljZShwcm9wLmxlbmd0aCArIDEpICE9IHZhbHVlKSkgY29udGludWU7XG4gICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnModmFsdWUpO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICAgICAgICBydWxlLmF0dHJzID0gcmVzdWx0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJzY2hlbWFSdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlbWFSdWxlcyhzY2hlbWEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgICAgIHZhciBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSxcbiAgICAgICAgICBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHJlc3VsdFtpXSxcbiAgICAgICAgICAgIG5leHRQcmlvcml0eSA9IG5leHQucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogbmV4dC5wcmlvcml0eTtcbiAgICAgICAgICBpZiAobmV4dFByaW9yaXR5IDwgcHJpb3JpdHkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgICB9XG4gICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKG5hbWUpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gc2NoZW1hLm1hcmtzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgIGlmIChydWxlcykgcnVsZXMuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgaWYgKCEocnVsZS5tYXJrIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUuY2xlYXJNYXJrKSkgcnVsZS5tYXJrID0gbmFtZTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgX2xvb3AyKG5hbWUpO1xuICAgICAgfVxuICAgICAgdmFyIF9sb29wMyA9IGZ1bmN0aW9uIF9sb29wMyhfbmFtZTMpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gc2NoZW1hLm5vZGVzW19uYW1lM10uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgaWYgKHJ1bGVzKSBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICBpZiAoIShydWxlLm5vZGUgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5tYXJrKSkgcnVsZS5ub2RlID0gX25hbWUzO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBfbmFtZTMgaW4gc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgIF9sb29wMyhfbmFtZTMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVNjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyIHx8IChzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoc2NoZW1hLCBET01QYXJzZXIuc2NoZW1hUnVsZXMoc2NoZW1hKSkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRE9NUGFyc2VyO1xufSgpO1xudmFyIGJsb2NrVGFncyA9IHtcbiAgYWRkcmVzczogdHJ1ZSxcbiAgYXJ0aWNsZTogdHJ1ZSxcbiAgYXNpZGU6IHRydWUsXG4gIGJsb2NrcXVvdGU6IHRydWUsXG4gIGNhbnZhczogdHJ1ZSxcbiAgZGQ6IHRydWUsXG4gIGRpdjogdHJ1ZSxcbiAgZGw6IHRydWUsXG4gIGZpZWxkc2V0OiB0cnVlLFxuICBmaWdjYXB0aW9uOiB0cnVlLFxuICBmaWd1cmU6IHRydWUsXG4gIGZvb3RlcjogdHJ1ZSxcbiAgZm9ybTogdHJ1ZSxcbiAgaDE6IHRydWUsXG4gIGgyOiB0cnVlLFxuICBoMzogdHJ1ZSxcbiAgaDQ6IHRydWUsXG4gIGg1OiB0cnVlLFxuICBoNjogdHJ1ZSxcbiAgaGVhZGVyOiB0cnVlLFxuICBoZ3JvdXA6IHRydWUsXG4gIGhyOiB0cnVlLFxuICBsaTogdHJ1ZSxcbiAgbm9zY3JpcHQ6IHRydWUsXG4gIG9sOiB0cnVlLFxuICBvdXRwdXQ6IHRydWUsXG4gIHA6IHRydWUsXG4gIHByZTogdHJ1ZSxcbiAgc2VjdGlvbjogdHJ1ZSxcbiAgdGFibGU6IHRydWUsXG4gIHRmb290OiB0cnVlLFxuICB1bDogdHJ1ZVxufTtcbnZhciBpZ25vcmVUYWdzID0ge1xuICBoZWFkOiB0cnVlLFxuICBub3NjcmlwdDogdHJ1ZSxcbiAgb2JqZWN0OiB0cnVlLFxuICBzY3JpcHQ6IHRydWUsXG4gIHN0eWxlOiB0cnVlLFxuICB0aXRsZTogdHJ1ZVxufTtcbnZhciBsaXN0VGFncyA9IHtcbiAgb2w6IHRydWUsXG4gIHVsOiB0cnVlXG59O1xudmFyIE9QVF9QUkVTRVJWRV9XUyA9IDEsXG4gIE9QVF9QUkVTRVJWRV9XU19GVUxMID0gMixcbiAgT1BUX09QRU5fTEVGVCA9IDQ7XG5mdW5jdGlvbiB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXaGl0ZXNwYWNlLCBiYXNlKSB7XG4gIGlmIChwcmVzZXJ2ZVdoaXRlc3BhY2UgIT0gbnVsbCkgcmV0dXJuIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPyBPUFRfUFJFU0VSVkVfV1MgOiAwKSB8IChwcmVzZXJ2ZVdoaXRlc3BhY2UgPT09IFwiZnVsbFwiID8gT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiAwKTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBPUFRfUFJFU0VSVkVfV1MgfCBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IGJhc2UgJiB+T1BUX09QRU5fTEVGVDtcbn1cbnZhciBOb2RlQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIG1hcmtzLCBzb2xpZCwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUNvbnRleHQpO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAgIHRoaXMubWF0Y2ggPSBtYXRjaCB8fCAob3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgPyBudWxsIDogdHlwZS5jb250ZW50TWF0Y2gpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhOb2RlQ29udGV4dCwgW3tcbiAgICBrZXk6IFwiZmluZFdyYXBwaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRXcmFwcGluZyhub2RlKSB7XG4gICAgICBpZiAoIXRoaXMubWF0Y2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGZpbGwgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmaWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLFxuICAgICAgICAgICAgd3JhcDtcbiAgICAgICAgICBpZiAod3JhcCA9IHN0YXJ0LmZpbmRXcmFwcGluZyhub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gc3RhcnQ7XG4gICAgICAgICAgICByZXR1cm4gd3JhcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluaXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmlzaChvcGVuRW5kKSB7XG4gICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSxcbiAgICAgICAgICBtO1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmlzVGV4dCAmJiAobSA9IC9bIFxcdFxcclxcblxcdTAwMGNdKyQvLmV4ZWMobGFzdC50ZXh0KSkpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGxhc3Q7XG4gICAgICAgICAgaWYgKGxhc3QudGV4dC5sZW5ndGggPT0gbVswXS5sZW5ndGgpIHRoaXMuY29udGVudC5wb3AoKTtlbHNlIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gPSB0ZXh0LndpdGhUZXh0KHRleHQudGV4dC5zbGljZSgwLCB0ZXh0LnRleHQubGVuZ3RoIC0gbVswXS5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHRoaXMuY29udGVudCk7XG4gICAgICBpZiAoIW9wZW5FbmQgJiYgdGhpcy5tYXRjaCkgY29udGVudCA9IGNvbnRlbnQuYXBwZW5kKHRoaXMubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgICAgcmV0dXJuIHRoaXMudHlwZSA/IHRoaXMudHlwZS5jcmVhdGUodGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcykgOiBjb250ZW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbmxpbmVDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlubGluZUNvbnRleHQobm9kZSkge1xuICAgICAgaWYgKHRoaXMudHlwZSkgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50O1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpIHJldHVybiB0aGlzLmNvbnRlbnRbMF0uaXNJbmxpbmU7XG4gICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmICFibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZUNvbnRleHQ7XG59KCk7XG52YXIgUGFyc2VDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzZUNvbnRleHQocGFyc2VyLCBvcHRpb25zLCBpc09wZW4pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VDb250ZXh0KTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuaXNPcGVuID0gaXNPcGVuO1xuICAgIHRoaXMub3BlbiA9IDA7XG4gICAgdGhpcy5sb2NhbFByZXNlcnZlV1MgPSBmYWxzZTtcbiAgICB2YXIgdG9wTm9kZSA9IG9wdGlvbnMudG9wTm9kZSxcbiAgICAgIHRvcENvbnRleHQ7XG4gICAgdmFyIHRvcE9wdGlvbnMgPSB3c09wdGlvbnNGb3IobnVsbCwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIDApIHwgKGlzT3BlbiA/IE9QVF9PUEVOX0xFRlQgOiAwKTtcbiAgICBpZiAodG9wTm9kZSkgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dCh0b3BOb2RlLnR5cGUsIHRvcE5vZGUuYXR0cnMsIE1hcmsubm9uZSwgdHJ1ZSwgb3B0aW9ucy50b3BNYXRjaCB8fCB0b3BOb2RlLnR5cGUuY29udGVudE1hdGNoLCB0b3BPcHRpb25zKTtlbHNlIGlmIChpc09wZW4pIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQobnVsbCwgbnVsbCwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtlbHNlIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQocGFyc2VyLnNjaGVtYS50b3BOb2RlVHlwZSwgbnVsbCwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICB0aGlzLm5vZGVzID0gW3RvcENvbnRleHRdO1xuICAgIHRoaXMuZmluZCA9IG9wdGlvbnMuZmluZFBvc2l0aW9ucztcbiAgICB0aGlzLm5lZWRzQmxvY2sgPSBmYWxzZTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoUGFyc2VDb250ZXh0LCBbe1xuICAgIGtleTogXCJ0b3BcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzW3RoaXMub3Blbl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZERPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRET00oZG9tLCBtYXJrcykge1xuICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKSB0aGlzLmFkZFRleHROb2RlKGRvbSwgbWFya3MpO2Vsc2UgaWYgKGRvbS5ub2RlVHlwZSA9PSAxKSB0aGlzLmFkZEVsZW1lbnQoZG9tLCBtYXJrcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFRleHROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFRleHROb2RlKGRvbSwgbWFya3MpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGRvbS5ub2RlVmFsdWU7XG4gICAgICB2YXIgdG9wID0gdGhpcy50b3AsXG4gICAgICAgIHByZXNlcnZlV1MgPSB0b3Aub3B0aW9ucyAmIE9QVF9QUkVTRVJWRV9XU19GVUxMID8gXCJmdWxsXCIgOiB0aGlzLmxvY2FsUHJlc2VydmVXUyB8fCAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpID4gMDtcbiAgICAgIGlmIChwcmVzZXJ2ZVdTID09PSBcImZ1bGxcIiB8fCB0b3AuaW5saW5lQ29udGV4dChkb20pIHx8IC9bXiBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFwcmVzZXJ2ZVdTKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG4gICAgICAgICAgaWYgKC9eWyBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy5vcGVuID09IHRoaXMubm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdmFyIG5vZGVCZWZvcmUgPSB0b3AuY29udGVudFt0b3AuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBkb21Ob2RlQmVmb3JlID0gZG9tLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgIGlmICghbm9kZUJlZm9yZSB8fCBkb21Ob2RlQmVmb3JlICYmIGRvbU5vZGVCZWZvcmUubm9kZU5hbWUgPT0gJ0JSJyB8fCBub2RlQmVmb3JlLmlzVGV4dCAmJiAvWyBcXHRcXHJcXG5cXHUwMDBjXSQvLnRlc3Qobm9kZUJlZm9yZS50ZXh0KSkgdmFsdWUgPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocHJlc2VydmVXUyAhPT0gXCJmdWxsXCIpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlKSB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpLCBtYXJrcywgIS9cXFMvLnRlc3QodmFsdWUpKTtcbiAgICAgICAgdGhpcy5maW5kSW5UZXh0KGRvbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFbGVtZW50KGRvbSwgbWFya3MsIG1hdGNoQWZ0ZXIpIHtcbiAgICAgIHZhciBvdXRlcldTID0gdGhpcy5sb2NhbFByZXNlcnZlV1MsXG4gICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgaWYgKGRvbS50YWdOYW1lID09IFwiUFJFXCIgfHwgL3ByZS8udGVzdChkb20uc3R5bGUgJiYgZG9tLnN0eWxlLndoaXRlU3BhY2UpKSB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IHRydWU7XG4gICAgICB2YXIgbmFtZSA9IGRvbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBydWxlSUQ7XG4gICAgICBpZiAobGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5wYXJzZXIubm9ybWFsaXplTGlzdHMpIG5vcm1hbGl6ZUxpc3QoZG9tKTtcbiAgICAgIHZhciBydWxlID0gdGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZSAmJiB0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlKGRvbSkgfHwgKHJ1bGVJRCA9IHRoaXMucGFyc2VyLm1hdGNoVGFnKGRvbSwgdGhpcywgbWF0Y2hBZnRlcikpO1xuICAgICAgb3V0OiBpZiAocnVsZSA/IHJ1bGUuaWdub3JlIDogaWdub3JlVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20sIG1hcmtzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJ1bGUgfHwgcnVsZS5za2lwIHx8IHJ1bGUuY2xvc2VQYXJlbnQpIHtcbiAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5jbG9zZVBhcmVudCkgdGhpcy5vcGVuID0gTWF0aC5tYXgoMCwgdGhpcy5vcGVuIC0gMSk7ZWxzZSBpZiAocnVsZSAmJiBydWxlLnNraXAubm9kZVR5cGUpIGRvbSA9IHJ1bGUuc2tpcDtcbiAgICAgICAgdmFyIHN5bmMsXG4gICAgICAgICAgb2xkTmVlZHNCbG9jayA9IHRoaXMubmVlZHNCbG9jaztcbiAgICAgICAgaWYgKGJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIGlmICh0b3AuY29udGVudC5sZW5ndGggJiYgdG9wLmNvbnRlbnRbMF0uaXNJbmxpbmUgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXRvcC50eXBlKSB0aGlzLm5lZWRzQmxvY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFkb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSwgbWFya3MpO1xuICAgICAgICAgIGJyZWFrIG91dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5uZXJNYXJrcyA9IHJ1bGUgJiYgcnVsZS5za2lwID8gbWFya3MgOiB0aGlzLnJlYWRTdHlsZXMoZG9tLCBtYXJrcyk7XG4gICAgICAgIGlmIChpbm5lck1hcmtzKSB0aGlzLmFkZEFsbChkb20sIGlubmVyTWFya3MpO1xuICAgICAgICBpZiAoc3luYykgdGhpcy5zeW5jKHRvcCk7XG4gICAgICAgIHRoaXMubmVlZHNCbG9jayA9IG9sZE5lZWRzQmxvY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2lubmVyTWFya3MgPSB0aGlzLnJlYWRTdHlsZXMoZG9tLCBtYXJrcyk7XG4gICAgICAgIGlmIChfaW5uZXJNYXJrcykgdGhpcy5hZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgX2lubmVyTWFya3MsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IG91dGVyV1M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlYWZGYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZWFmRmFsbGJhY2soZG9tLCBtYXJrcykge1xuICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgdGhpcy50b3AudHlwZSAmJiB0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpIHRoaXMuYWRkVGV4dE5vZGUoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIiksIG1hcmtzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaWdub3JlRmFsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWdub3JlRmFsbGJhY2soZG9tLCBtYXJrcykge1xuICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKSB0aGlzLmZpbmRQbGFjZSh0aGlzLnBhcnNlci5zY2hlbWEudGV4dChcIi1cIiksIG1hcmtzLCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFN0eWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkU3R5bGVzKGRvbSwgbWFya3MpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIHN0eWxlcyA9IGRvbS5zdHlsZTtcbiAgICAgIGlmIChzdHlsZXMgJiYgc3R5bGVzLmxlbmd0aCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhcnNlci5tYXRjaGVkU3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJzZXIubWF0Y2hlZFN0eWxlc1tpXSxcbiAgICAgICAgICB2YWx1ZSA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgX2xvb3A0ID0gZnVuY3Rpb24gX2xvb3A0KF9hZnRlcikge1xuICAgICAgICAgICAgICB2YXIgcnVsZSA9IF90aGlzNC5wYXJzZXIubWF0Y2hTdHlsZShuYW1lLCB2YWx1ZSwgX3RoaXM0LCBfYWZ0ZXIpO1xuICAgICAgICAgICAgICBpZiAoIXJ1bGUpIHtcbiAgICAgICAgICAgICAgICBhZnRlciA9IF9hZnRlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocnVsZS5pZ25vcmUpIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdjogbnVsbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmspIG1hcmtzID0gbWFya3MuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFydWxlLmNsZWFyTWFyayhtKTtcbiAgICAgICAgICAgICAgfSk7ZWxzZSBtYXJrcyA9IG1hcmtzLmNvbmNhdChfdGhpczQucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdLmNyZWF0ZShydWxlLmF0dHJzKSk7XG4gICAgICAgICAgICAgIGlmIChydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UpIF9hZnRlciA9IHJ1bGU7ZWxzZSB7XG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBfYWZ0ZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWZ0ZXIgPSBfYWZ0ZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3JldDtcbiAgICAgICAgICBmb3IgKHZhciBhZnRlciA9IHVuZGVmaW5lZDs7KSB7XG4gICAgICAgICAgICBfcmV0ID0gX2xvb3A0KGFmdGVyKTtcbiAgICAgICAgICAgIGlmIChfcmV0ID09PSAwKSBicmVhaztcbiAgICAgICAgICAgIGlmIChfcmV0KSByZXR1cm4gX3JldC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFbGVtZW50QnlSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBtYXJrcywgY29udGludWVBZnRlcikge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgc3luYywgbm9kZVR5cGU7XG4gICAgICBpZiAocnVsZS5ub2RlKSB7XG4gICAgICAgIG5vZGVUeXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW3J1bGUubm9kZV07XG4gICAgICAgIGlmICghbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgdmFyIGlubmVyID0gdGhpcy5lbnRlcihub2RlVHlwZSwgcnVsZS5hdHRycyB8fCBudWxsLCBtYXJrcywgcnVsZS5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuICAgICAgICAgIGlmIChpbm5lcikge1xuICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICBtYXJrcyA9IGlubmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pbnNlcnROb2RlKG5vZGVUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSwgbWFya3MsIGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIpKSB7XG4gICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tLCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBtYXJrVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdO1xuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChtYXJrVHlwZS5jcmVhdGUocnVsZS5hdHRycykpO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXJ0SW4gPSB0aGlzLnRvcDtcbiAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSwgbWFya3MsIGNvbnRpbnVlQWZ0ZXIpO1xuICAgICAgfSBlbHNlIGlmIChydWxlLmdldENvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIHJ1bGUuZ2V0Q29udGVudChkb20sIHRoaXMucGFyc2VyLnNjaGVtYSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUuaW5zZXJ0Tm9kZShub2RlLCBtYXJrcywgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb250ZW50RE9NID0gZG9tO1xuICAgICAgICBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJzdHJpbmdcIikgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKHJ1bGUuY29udGVudEVsZW1lbnQpO2Vsc2UgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwiZnVuY3Rpb25cIikgY29udGVudERPTSA9IHJ1bGUuY29udGVudEVsZW1lbnQoZG9tKTtlbHNlIGlmIChydWxlLmNvbnRlbnRFbGVtZW50KSBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkQWxsKGNvbnRlbnRET00sIG1hcmtzKTtcbiAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgaWYgKHN5bmMgJiYgdGhpcy5zeW5jKHN0YXJ0SW4pKSB0aGlzLm9wZW4tLTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkQWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEFsbChwYXJlbnQsIG1hcmtzLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgdmFyIGluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuICAgICAgZm9yICh2YXIgZG9tID0gc3RhcnRJbmRleCA/IHBhcmVudC5jaGlsZE5vZGVzW3N0YXJ0SW5kZXhdIDogcGFyZW50LmZpcnN0Q2hpbGQsIGVuZCA9IGVuZEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50LmNoaWxkTm9kZXNbZW5kSW5kZXhdOyBkb20gIT0gZW5kOyBkb20gPSBkb20ubmV4dFNpYmxpbmcsICsraW5kZXgpIHtcbiAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICAgICAgdGhpcy5hZGRET00oZG9tLCBtYXJrcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kUGxhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFBsYWNlKG5vZGUsIG1hcmtzLCBjYXV0aW91cykge1xuICAgICAgdmFyIHJvdXRlLCBzeW5jO1xuICAgICAgZm9yICh2YXIgZGVwdGggPSB0aGlzLm9wZW4sIHBlbmFsdHkgPSAwOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgIHZhciBjeCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgICAgICB2YXIgX2ZvdW5kMiA9IGN4LmZpbmRXcmFwcGluZyhub2RlKTtcbiAgICAgICAgaWYgKF9mb3VuZDIgJiYgKCFyb3V0ZSB8fCByb3V0ZS5sZW5ndGggPiBfZm91bmQyLmxlbmd0aCArIHBlbmFsdHkpKSB7XG4gICAgICAgICAgcm91dGUgPSBfZm91bmQyO1xuICAgICAgICAgIHN5bmMgPSBjeDtcbiAgICAgICAgICBpZiAoIV9mb3VuZDIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3guc29saWQpIHtcbiAgICAgICAgICBpZiAoY2F1dGlvdXMpIGJyZWFrO1xuICAgICAgICAgIHBlbmFsdHkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFyb3V0ZSkgcmV0dXJuIG51bGw7XG4gICAgICB0aGlzLnN5bmMoc3luYyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKSBtYXJrcyA9IHRoaXMuZW50ZXJJbm5lcihyb3V0ZVtpXSwgbnVsbCwgbWFya3MsIGZhbHNlKTtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb2RlKG5vZGUsIG1hcmtzLCBjYXV0aW91cykge1xuICAgICAgaWYgKG5vZGUuaXNJbmxpbmUgJiYgdGhpcy5uZWVkc0Jsb2NrICYmICF0aGlzLnRvcC50eXBlKSB7XG4gICAgICAgIHZhciBibG9jayA9IHRoaXMudGV4dGJsb2NrRnJvbUNvbnRleHQoKTtcbiAgICAgICAgaWYgKGJsb2NrKSBtYXJrcyA9IHRoaXMuZW50ZXJJbm5lcihibG9jaywgbnVsbCwgbWFya3MpO1xuICAgICAgfVxuICAgICAgdmFyIGlubmVyTWFya3MgPSB0aGlzLmZpbmRQbGFjZShub2RlLCBtYXJrcywgY2F1dGlvdXMpO1xuICAgICAgaWYgKGlubmVyTWFya3MpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIHZhciB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKHRvcC5tYXRjaCkgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZShub2RlLnR5cGUpO1xuICAgICAgICB2YXIgbm9kZU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaW5uZXJNYXJrcy5jb25jYXQobm9kZS5tYXJrcykpLFxuICAgICAgICAgIF9zdGVwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvcC50eXBlID8gdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobS50eXBlKSA6IG1hcmtNYXlBcHBseShtLnR5cGUsIG5vZGUudHlwZSkpIG5vZGVNYXJrcyA9IG0uYWRkVG9TZXQobm9kZU1hcmtzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuICAgICAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhub2RlTWFya3MpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyKHR5cGUsIGF0dHJzLCBtYXJrcywgcHJlc2VydmVXUykge1xuICAgICAgdmFyIGlubmVyTWFya3MgPSB0aGlzLmZpbmRQbGFjZSh0eXBlLmNyZWF0ZShhdHRycyksIG1hcmtzLCBmYWxzZSk7XG4gICAgICBpZiAoaW5uZXJNYXJrcykgaW5uZXJNYXJrcyA9IHRoaXMuZW50ZXJJbm5lcih0eXBlLCBhdHRycywgbWFya3MsIHRydWUsIHByZXNlcnZlV1MpO1xuICAgICAgcmV0dXJuIGlubmVyTWFya3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVudGVySW5uZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW50ZXJJbm5lcih0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICAgIHZhciBzb2xpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICB2YXIgcHJlc2VydmVXUyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICB2YXIgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2ggJiYgdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgIHZhciBvcHRpb25zID0gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV1MsIHRvcC5vcHRpb25zKTtcbiAgICAgIGlmICh0b3Aub3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQgJiYgdG9wLmNvbnRlbnQubGVuZ3RoID09IDApIG9wdGlvbnMgfD0gT1BUX09QRU5fTEVGVDtcbiAgICAgIHZhciBhcHBseU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgbWFya3MgPSBtYXJrcy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKHRvcC50eXBlID8gdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobS50eXBlKSA6IG1hcmtNYXlBcHBseShtLnR5cGUsIHR5cGUpKSB7XG4gICAgICAgICAgYXBwbHlNYXJrcyA9IG0uYWRkVG9TZXQoYXBwbHlNYXJrcyk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGVDb250ZXh0KHR5cGUsIGF0dHJzLCBhcHBseU1hcmtzLCBzb2xpZCwgbnVsbCwgb3B0aW9ucykpO1xuICAgICAgdGhpcy5vcGVuKys7XG4gICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsb3NlRXh0cmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VFeHRyYSgpIHtcbiAgICAgIHZhciBvcGVuRW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHZhciBpID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgaWYgKGkgPiB0aGlzLm9wZW4pIHtcbiAgICAgICAgZm9yICg7IGkgPiB0aGlzLm9wZW47IGktLSkgdGhpcy5ub2Rlc1tpIC0gMV0uY29udGVudC5wdXNoKHRoaXMubm9kZXNbaV0uZmluaXNoKG9wZW5FbmQpKTtcbiAgICAgICAgdGhpcy5ub2Rlcy5sZW5ndGggPSB0aGlzLm9wZW4gKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5pc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgIHRoaXMuY2xvc2VFeHRyYSh0aGlzLmlzT3Blbik7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2goISEodGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3luY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzeW5jKHRvKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGhpcy5ub2Rlc1tpXSA9PSB0bykge1xuICAgICAgICAgIHRoaXMub3BlbiA9IGk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sb2NhbFByZXNlcnZlV1MpIHtcbiAgICAgICAgICB0aGlzLm5vZGVzW2ldLm9wdGlvbnMgfD0gT1BUX1BSRVNFUlZFX1dTO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImN1cnJlbnRQb3NcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMubm9kZXNbaV0uY29udGVudDtcbiAgICAgICAgZm9yICh2YXIgaiA9IGNvbnRlbnQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHBvcyArPSBjb250ZW50W2pdLm5vZGVTaXplO1xuICAgICAgICBpZiAoaSkgcG9zKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQXRQb2ludChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgaWYgKHRoaXMuZmluZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHBhcmVudCAmJiB0aGlzLmZpbmRbaV0ub2Zmc2V0ID09IG9mZnNldCkgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZEluc2lkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kSW5zaWRlKHBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuZmluZCkgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQXJvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRBcm91bmQocGFyZW50LCBjb250ZW50LCBiZWZvcmUpIHtcbiAgICAgIGlmIChwYXJlbnQgIT0gY29udGVudCAmJiB0aGlzLmZpbmQpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSkge1xuICAgICAgICAgIHZhciBwb3MgPSBjb250ZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuZmluZFtpXS5ub2RlKTtcbiAgICAgICAgICBpZiAocG9zICYgKGJlZm9yZSA/IDIgOiA0KSkgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kSW5UZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRJblRleHQodGV4dE5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmZpbmQpIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmRbaV0ubm9kZSA9PSB0ZXh0Tm9kZSkgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcyAtICh0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gdGhpcy5maW5kW2ldLm9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoZXNDb250ZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoZXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgaWYgKGNvbnRleHQuaW5kZXhPZihcInxcIikgPiAtMSkgcmV0dXJuIGNvbnRleHQuc3BsaXQoL1xccypcXHxcXHMqLykuc29tZSh0aGlzLm1hdGNoZXNDb250ZXh0LCB0aGlzKTtcbiAgICAgIHZhciBwYXJ0cyA9IGNvbnRleHQuc3BsaXQoXCIvXCIpO1xuICAgICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgdmFyIHVzZVJvb3QgPSAhdGhpcy5pc09wZW4gJiYgKCFvcHRpb24gfHwgb3B0aW9uLnBhcmVudC50eXBlID09IHRoaXMubm9kZXNbMF0udHlwZSk7XG4gICAgICB2YXIgbWluRGVwdGggPSAtKG9wdGlvbiA/IG9wdGlvbi5kZXB0aCArIDEgOiAwKSArICh1c2VSb290ID8gMCA6IDEpO1xuICAgICAgdmFyIG1hdGNoID0gZnVuY3Rpb24gbWF0Y2goaSwgZGVwdGgpIHtcbiAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICBpZiAocGFydCA9PSBcIlwiKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBwYXJ0cy5sZW5ndGggLSAxIHx8IGkgPT0gMCkgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKDsgZGVwdGggPj0gbWluRGVwdGg7IGRlcHRoLS0pIGlmIChtYXRjaChpIC0gMSwgZGVwdGgpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBkZXB0aCA+IDAgfHwgZGVwdGggPT0gMCAmJiB1c2VSb290ID8gX3RoaXM2Lm5vZGVzW2RlcHRoXS50eXBlIDogb3B0aW9uICYmIGRlcHRoID49IG1pbkRlcHRoID8gb3B0aW9uLm5vZGUoZGVwdGggLSBtaW5EZXB0aCkudHlwZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5uYW1lICE9IHBhcnQgJiYgIW5leHQuaXNJbkdyb3VwKHBhcnQpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gbWF0Y2gocGFydHMubGVuZ3RoIC0gMSwgdGhpcy5vcGVuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidGV4dGJsb2NrRnJvbUNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGV4dGJsb2NrRnJvbUNvbnRleHQoKSB7XG4gICAgICB2YXIgJGNvbnRleHQgPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgIGlmICgkY29udGV4dCkgZm9yICh2YXIgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICB2YXIgZGVmbHQgPSAkY29udGV4dC5ub2RlKGQpLmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4QWZ0ZXIoZCkpLmRlZmF1bHRUeXBlO1xuICAgICAgICBpZiAoZGVmbHQgJiYgZGVmbHQuaXNUZXh0YmxvY2sgJiYgZGVmbHQuZGVmYXVsdEF0dHJzKSByZXR1cm4gZGVmbHQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlcykge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgdHlwZS5kZWZhdWx0QXR0cnMpIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGFyc2VDb250ZXh0O1xufSgpO1xuZnVuY3Rpb24gbm9ybWFsaXplTGlzdChkb20pIHtcbiAgZm9yICh2YXIgY2hpbGQgPSBkb20uZmlyc3RDaGlsZCwgcHJldkl0ZW0gPSBudWxsOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIHZhciBuYW1lID0gY2hpbGQubm9kZVR5cGUgPT0gMSA/IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImxpXCIpIHtcbiAgICAgIHByZXZJdGVtID0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChuYW1lKSB7XG4gICAgICBwcmV2SXRlbSA9IG51bGw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXRjaGVzKGRvbSwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIChkb20ubWF0Y2hlcyB8fCBkb20ubXNNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb20ubW96TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGRvbSwgc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgdmFyIGNvcHkgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBvYmopIGNvcHlbcHJvcF0gPSBvYmpbcHJvcF07XG4gIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gbWFya01heUFwcGx5KG1hcmtUeXBlLCBub2RlVHlwZSkge1xuICB2YXIgbm9kZXMgPSBub2RlVHlwZS5zY2hlbWEubm9kZXM7XG4gIHZhciBfbG9vcDUgPSBmdW5jdGlvbiBfbG9vcDUoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZXNbbmFtZV07XG4gICAgICBpZiAoIXBhcmVudC5hbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkpIHJldHVybiAwO1xuICAgICAgdmFyIHNlZW4gPSBbXSxcbiAgICAgICAgc2NhbiA9IGZ1bmN0aW9uIHNjYW4obWF0Y2gpIHtcbiAgICAgICAgICBzZWVuLnB1c2gobWF0Y2gpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2gkZWRnZSA9IG1hdGNoLmVkZ2UoaSksXG4gICAgICAgICAgICAgIHR5cGUgPSBfbWF0Y2gkZWRnZS50eXBlLFxuICAgICAgICAgICAgICBuZXh0ID0gX21hdGNoJGVkZ2UubmV4dDtcbiAgICAgICAgICAgIGlmICh0eXBlID09IG5vZGVUeXBlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobmV4dCkgPCAwICYmIHNjYW4obmV4dCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIGlmIChzY2FuKHBhcmVudC5jb250ZW50TWF0Y2gpKSByZXR1cm4ge1xuICAgICAgICB2OiB0cnVlXG4gICAgICB9O1xuICAgIH0sXG4gICAgX3JldDI7XG4gIGZvciAodmFyIG5hbWUgaW4gbm9kZXMpIHtcbiAgICBfcmV0MiA9IF9sb29wNSgpO1xuICAgIGlmIChfcmV0MiA9PT0gMCkgY29udGludWU7XG4gICAgaWYgKF9yZXQyKSByZXR1cm4gX3JldDIudjtcbiAgfVxufVxudmFyIERPTVNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERPTVNlcmlhbGl6ZXIobm9kZXMsIG1hcmtzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTVNlcmlhbGl6ZXIpO1xuICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKERPTVNlcmlhbGl6ZXIsIFt7XG4gICAga2V5OiBcInNlcmlhbGl6ZUZyYWdtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZUZyYWdtZW50KGZyYWdtZW50KSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICghdGFyZ2V0KSB0YXJnZXQgPSBkb2Mob3B0aW9ucykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdmFyIHRvcCA9IHRhcmdldCxcbiAgICAgICAgYWN0aXZlID0gW107XG4gICAgICBmcmFnbWVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChhY3RpdmUubGVuZ3RoIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtlZXAgPSAwLFxuICAgICAgICAgICAgcmVuZGVyZWQgPSAwO1xuICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aCAmJiByZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IG5vZGUubWFya3NbcmVuZGVyZWRdO1xuICAgICAgICAgICAgaWYgKCFfdGhpczcubWFya3NbbmV4dC50eXBlLm5hbWVdKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0LmVxKGFjdGl2ZVtrZWVwXVswXSkgfHwgbmV4dC50eXBlLnNwZWMuc3Bhbm5pbmcgPT09IGZhbHNlKSBicmVhaztcbiAgICAgICAgICAgIGtlZXArKztcbiAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aCkgdG9wID0gYWN0aXZlLnBvcCgpWzFdO1xuICAgICAgICAgIHdoaWxlIChyZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYWRkID0gbm9kZS5tYXJrc1tyZW5kZXJlZCsrXTtcbiAgICAgICAgICAgIHZhciBtYXJrRE9NID0gX3RoaXM3LnNlcmlhbGl6ZU1hcmsoYWRkLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChtYXJrRE9NKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKFthZGQsIHRvcF0pO1xuICAgICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgICAgICB0b3AgPSBtYXJrRE9NLmNvbnRlbnRET00gfHwgbWFya0RPTS5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvcC5hcHBlbmRDaGlsZChfdGhpczcuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplTm9kZUlubmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3JlbmRlclNwZWMyID0gX3JlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0aGlzLm5vZGVzW25vZGUudHlwZS5uYW1lXShub2RlKSwgbnVsbCwgbm9kZS5hdHRycyksXG4gICAgICAgIGRvbSA9IF9yZW5kZXJTcGVjMi5kb20sXG4gICAgICAgIGNvbnRlbnRET00gPSBfcmVuZGVyU3BlYzIuY29udGVudERPTTtcbiAgICAgIGlmIChjb250ZW50RE9NKSB7XG4gICAgICAgIGlmIChub2RlLmlzTGVhZikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbm90IGFsbG93ZWQgaW4gYSBsZWFmIG5vZGUgc3BlY1wiKTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemVGcmFnbWVudChub2RlLmNvbnRlbnQsIG9wdGlvbnMsIGNvbnRlbnRET00pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemVOb2RlKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBkb20gPSB0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKTtcbiAgICAgIGZvciAodmFyIGkgPSBub2RlLm1hcmtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciB3cmFwID0gdGhpcy5zZXJpYWxpemVNYXJrKG5vZGUubWFya3NbaV0sIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICh3cmFwLmNvbnRlbnRET00gfHwgd3JhcC5kb20pLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgZG9tID0gd3JhcC5kb207XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZU1hcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplTWFyayhtYXJrLCBpbmxpbmUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIHZhciB0b0RPTSA9IHRoaXMubWFya3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgcmV0dXJuIHRvRE9NICYmIF9yZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdG9ET00obWFyaywgaW5saW5lKSwgbnVsbCwgbWFyay5hdHRycyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicmVuZGVyU3BlY1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlKSB7XG4gICAgICB2YXIgeG1sTlMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgYmxvY2tBcnJheXNJbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIF9yZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUywgYmxvY2tBcnJheXNJbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZyb21TY2hlbWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVNlcmlhbGl6ZXIgfHwgKHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciA9IG5ldyBET01TZXJpYWxpemVyKHRoaXMubm9kZXNGcm9tU2NoZW1hKHNjaGVtYSksIHRoaXMubWFya3NGcm9tU2NoZW1hKHNjaGVtYSkpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibm9kZXNGcm9tU2NoZW1hXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vZGVzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnYXRoZXJUb0RPTShzY2hlbWEubm9kZXMpO1xuICAgICAgaWYgKCFyZXN1bHQudGV4dCkgcmVzdWx0LnRleHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hcmtzRnJvbVNjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICByZXR1cm4gZ2F0aGVyVG9ET00oc2NoZW1hLm1hcmtzKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERPTVNlcmlhbGl6ZXI7XG59KCk7XG5mdW5jdGlvbiBnYXRoZXJUb0RPTShvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBuYW1lIGluIG9iaikge1xuICAgIHZhciB0b0RPTSA9IG9ialtuYW1lXS5zcGVjLnRvRE9NO1xuICAgIGlmICh0b0RPTSkgcmVzdWx0W25hbWVdID0gdG9ET007XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRvYyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudDtcbn1cbnZhciBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc3VzcGljaW91c0F0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgdmFyIHZhbHVlID0gc3VzcGljaW91c0F0dHJpYnV0ZUNhY2hlLmdldChhdHRycyk7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUuc2V0KGF0dHJzLCB2YWx1ZSA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVzSW5uZXIoYXR0cnMpKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc3VzcGljaW91c0F0dHJpYnV0ZXNJbm5lcihhdHRycykge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgZnVuY3Rpb24gc2Nhbih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiBfdHlwZW9mKHZhbHVlKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKCFyZXN1bHQpIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSBzY2FuKHZhbHVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkgc2Nhbih2YWx1ZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNjYW4oYXR0cnMpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX3JlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TLCBibG9ja0FycmF5c0luKSB7XG4gIGlmICh0eXBlb2Ygc3RydWN0dXJlID09IFwic3RyaW5nXCIpIHJldHVybiB7XG4gICAgZG9tOiBkb2MuY3JlYXRlVGV4dE5vZGUoc3RydWN0dXJlKVxuICB9O1xuICBpZiAoc3RydWN0dXJlLm5vZGVUeXBlICE9IG51bGwpIHJldHVybiB7XG4gICAgZG9tOiBzdHJ1Y3R1cmVcbiAgfTtcbiAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKSByZXR1cm4gc3RydWN0dXJlO1xuICB2YXIgdGFnTmFtZSA9IHN0cnVjdHVyZVswXSxcbiAgICBzdXNwaWNpb3VzO1xuICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFycmF5IHBhc3NlZCB0byByZW5kZXJTcGVjXCIpO1xuICBpZiAoYmxvY2tBcnJheXNJbiAmJiAoc3VzcGljaW91cyA9IHN1c3BpY2lvdXNBdHRyaWJ1dGVzKGJsb2NrQXJyYXlzSW4pKSAmJiBzdXNwaWNpb3VzLmluZGV4T2Yoc3RydWN0dXJlKSA+IC0xKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVzaW5nIGFuIGFycmF5IGZyb20gYW4gYXR0cmlidXRlIG9iamVjdCBhcyBhIERPTSBzcGVjLiBUaGlzIG1heSBiZSBhbiBhdHRlbXB0ZWQgY3Jvc3Mgc2l0ZSBzY3JpcHRpbmcgYXR0YWNrLlwiKTtcbiAgdmFyIHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgaWYgKHNwYWNlID4gMCkge1xuICAgIHhtbE5TID0gdGFnTmFtZS5zbGljZSgwLCBzcGFjZSk7XG4gICAgdGFnTmFtZSA9IHRhZ05hbWUuc2xpY2Uoc3BhY2UgKyAxKTtcbiAgfVxuICB2YXIgY29udGVudERPTTtcbiAgdmFyIGRvbSA9IHhtbE5TID8gZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxOUywgdGFnTmFtZSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgdmFyIGF0dHJzID0gc3RydWN0dXJlWzFdLFxuICAgIHN0YXJ0ID0gMTtcbiAgaWYgKGF0dHJzICYmIF90eXBlb2YoYXR0cnMpID09IFwib2JqZWN0XCIgJiYgYXR0cnMubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICBzdGFydCA9IDI7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBhdHRycykgaWYgKGF0dHJzW25hbWVdICE9IG51bGwpIHtcbiAgICAgIHZhciBfc3BhY2UgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgaWYgKF9zcGFjZSA+IDApIGRvbS5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNsaWNlKDAsIF9zcGFjZSksIG5hbWUuc2xpY2UoX3NwYWNlICsgMSksIGF0dHJzW25hbWVdKTtlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIiAmJiBkb20uc3R5bGUpIGRvbS5zdHlsZS5jc3NUZXh0ID0gYXR0cnNbbmFtZV07ZWxzZSBkb20uc2V0QXR0cmlidXRlKG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgc3RydWN0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gc3RydWN0dXJlW2ldO1xuICAgIGlmIChjaGlsZCA9PT0gMCkge1xuICAgICAgaWYgKGkgPCBzdHJ1Y3R1cmUubGVuZ3RoIC0gMSB8fCBpID4gc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9tOiBkb20sXG4gICAgICAgIGNvbnRlbnRET006IGRvbVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9yZW5kZXJTcGVjMyA9IF9yZW5kZXJTcGVjKGRvYywgY2hpbGQsIHhtbE5TLCBibG9ja0FycmF5c0luKSxcbiAgICAgICAgaW5uZXIgPSBfcmVuZGVyU3BlYzMuZG9tLFxuICAgICAgICBpbm5lckNvbnRlbnQgPSBfcmVuZGVyU3BlYzMuY29udGVudERPTTtcbiAgICAgIGRvbS5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICBpZiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgIGlmIChjb250ZW50RE9NKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGNvbnRlbnQgaG9sZXNcIik7XG4gICAgICAgIGNvbnRlbnRET00gPSBpbm5lckNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZG9tOiBkb20sXG4gICAgY29udGVudERPTTogY29udGVudERPTVxuICB9O1xufVxuZXhwb3J0cy5Db250ZW50TWF0Y2ggPSBDb250ZW50TWF0Y2g7XG5leHBvcnRzLkRPTVBhcnNlciA9IERPTVBhcnNlcjtcbmV4cG9ydHMuRE9NU2VyaWFsaXplciA9IERPTVNlcmlhbGl6ZXI7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLk1hcmsgPSBNYXJrO1xuZXhwb3J0cy5NYXJrVHlwZSA9IE1hcmtUeXBlO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmV4cG9ydHMuTm9kZVJhbmdlID0gTm9kZVJhbmdlO1xuZXhwb3J0cy5Ob2RlVHlwZSA9IE5vZGVUeXBlO1xuZXhwb3J0cy5SZXBsYWNlRXJyb3IgPSBSZXBsYWNlRXJyb3I7XG5leHBvcnRzLlJlc29sdmVkUG9zID0gUmVzb2x2ZWRQb3M7XG5leHBvcnRzLlNjaGVtYSA9IFNjaGVtYTtcbmV4cG9ydHMuU2xpY2UgPSBTbGljZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/prosemirror-model@1.25.3/node_modules/prosemirror-model/dist/index.cjs\n");

/***/ })

};
;